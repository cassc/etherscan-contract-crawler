{"SourceCode": "// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity ^0.8.4;\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and making it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        _nonReentrantBefore();\r\n        _;\r\n        _nonReentrantAfter();\r\n    }\r\n\r\n    function _nonReentrantBefore() private {\r\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n    }\r\n\r\n    function _nonReentrantAfter() private {\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\r\n     * `nonReentrant` function in the call stack.\r\n     */\r\n    function _reentrancyGuardEntered() internal view returns (bool) {\r\n        return _status == _ENTERED;\r\n    }\r\n}\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\r\n\r\n/**\r\n * @dev Standard math utilities missing in the Solidity language.\r\n */\r\nlibrary Math {\r\n    enum Rounding {\r\n        Down, // Toward negative infinity\r\n        Up, // Toward infinity\r\n        Zero // Toward zero\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the largest of two numbers.\r\n     */\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a > b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the smallest of two numbers.\r\n     */\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the average of two numbers. The result is rounded towards\r\n     * zero.\r\n     */\r\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b) / 2 can overflow.\r\n        return (a & b) + (a ^ b) / 2;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the ceiling of the division of two numbers.\r\n     *\r\n     * This differs from standard division with `/` in that it rounds up instead\r\n     * of rounding down.\r\n     */\r\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b - 1) / b can overflow on addition, so we distribute.\r\n        return a == 0 ? 0 : (a - 1) / b + 1;\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\r\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\r\n     * with further edits by Uniswap Labs also under MIT license.\r\n     */\r\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\r\n        unchecked {\r\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\r\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\r\n            // variables such that product = prod1 * 2^256 + prod0.\r\n            uint256 prod0; // Least significant 256 bits of the product\r\n            uint256 prod1; // Most significant 256 bits of the product\r\n            assembly {\r\n                let mm := mulmod(x, y, not(0))\r\n                prod0 := mul(x, y)\r\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\r\n            }\r\n\r\n            // Handle non-overflow cases, 256 by 256 division.\r\n            if (prod1 == 0) {\r\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\r\n                // The surrounding unchecked block does not change this fact.\r\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\r\n                return prod0 / denominator;\r\n            }\r\n\r\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\r\n            require(denominator > prod1, \"Math: mulDiv overflow\");\r\n\r\n            ///////////////////////////////////////////////\r\n            // 512 by 256 division.\r\n            ///////////////////////////////////////////////\r\n\r\n            // Make division exact by subtracting the remainder from [prod1 prod0].\r\n            uint256 remainder;\r\n            assembly {\r\n                // Compute remainder using mulmod.\r\n                remainder := mulmod(x, y, denominator)\r\n\r\n                // Subtract 256 bit number from 512 bit number.\r\n                prod1 := sub(prod1, gt(remainder, prod0))\r\n                prod0 := sub(prod0, remainder)\r\n            }\r\n\r\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\r\n            // See https://cs.stackexchange.com/q/138556/92363.\r\n\r\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\r\n            uint256 twos = denominator & (~denominator + 1);\r\n            assembly {\r\n                // Divide denominator by twos.\r\n                denominator := div(denominator, twos)\r\n\r\n                // Divide [prod1 prod0] by twos.\r\n                prod0 := div(prod0, twos)\r\n\r\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\r\n                twos := add(div(sub(0, twos), twos), 1)\r\n            }\r\n\r\n            // Shift in bits from prod1 into prod0.\r\n            prod0 |= prod1 * twos;\r\n\r\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\r\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\r\n            // four bits. That is, denominator * inv = 1 mod 2^4.\r\n            uint256 inverse = (3 * denominator) ^ 2;\r\n\r\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\r\n            // in modular arithmetic, doubling the correct bits in each step.\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\r\n\r\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\r\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\r\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\r\n            // is no longer required.\r\n            result = prod0 * inverse;\r\n            return result;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\r\n     */\r\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\r\n        uint256 result = mulDiv(x, y, denominator);\r\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\r\n            result += 1;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\r\n     *\r\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\r\n     */\r\n    function sqrt(uint256 a) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\r\n        //\r\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\r\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\r\n        //\r\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\r\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\r\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\r\n        //\r\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\r\n        uint256 result = 1 << (log2(a) >> 1);\r\n\r\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\r\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\r\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\r\n        // into the expected uint128 result.\r\n        unchecked {\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            return min(result, a / result);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates sqrt(a), following the selected rounding direction.\r\n     */\r\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\r\n        unchecked {\r\n            uint256 result = sqrt(a);\r\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 2, rounded down, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log2(uint256 value) internal pure returns (uint256) {\r\n        uint256 result = 0;\r\n        unchecked {\r\n            if (value >> 128 > 0) {\r\n                value >>= 128;\r\n                result += 128;\r\n            }\r\n            if (value >> 64 > 0) {\r\n                value >>= 64;\r\n                result += 64;\r\n            }\r\n            if (value >> 32 > 0) {\r\n                value >>= 32;\r\n                result += 32;\r\n            }\r\n            if (value >> 16 > 0) {\r\n                value >>= 16;\r\n                result += 16;\r\n            }\r\n            if (value >> 8 > 0) {\r\n                value >>= 8;\r\n                result += 8;\r\n            }\r\n            if (value >> 4 > 0) {\r\n                value >>= 4;\r\n                result += 4;\r\n            }\r\n            if (value >> 2 > 0) {\r\n                value >>= 2;\r\n                result += 2;\r\n            }\r\n            if (value >> 1 > 0) {\r\n                result += 1;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\r\n        unchecked {\r\n            uint256 result = log2(value);\r\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 10, rounded down, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log10(uint256 value) internal pure returns (uint256) {\r\n        uint256 result = 0;\r\n        unchecked {\r\n            if (value >= 10 ** 64) {\r\n                value /= 10 ** 64;\r\n                result += 64;\r\n            }\r\n            if (value >= 10 ** 32) {\r\n                value /= 10 ** 32;\r\n                result += 32;\r\n            }\r\n            if (value >= 10 ** 16) {\r\n                value /= 10 ** 16;\r\n                result += 16;\r\n            }\r\n            if (value >= 10 ** 8) {\r\n                value /= 10 ** 8;\r\n                result += 8;\r\n            }\r\n            if (value >= 10 ** 4) {\r\n                value /= 10 ** 4;\r\n                result += 4;\r\n            }\r\n            if (value >= 10 ** 2) {\r\n                value /= 10 ** 2;\r\n                result += 2;\r\n            }\r\n            if (value >= 10 ** 1) {\r\n                result += 1;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\r\n        unchecked {\r\n            uint256 result = log10(value);\r\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 256, rounded down, of a positive value.\r\n     * Returns 0 if given 0.\r\n     *\r\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\r\n     */\r\n    function log256(uint256 value) internal pure returns (uint256) {\r\n        uint256 result = 0;\r\n        unchecked {\r\n            if (value >> 128 > 0) {\r\n                value >>= 128;\r\n                result += 16;\r\n            }\r\n            if (value >> 64 > 0) {\r\n                value >>= 64;\r\n                result += 8;\r\n            }\r\n            if (value >> 32 > 0) {\r\n                value >>= 32;\r\n                result += 4;\r\n            }\r\n            if (value >> 16 > 0) {\r\n                value >>= 16;\r\n                result += 2;\r\n            }\r\n            if (value >> 8 > 0) {\r\n                result += 1;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\r\n        unchecked {\r\n            uint256 result = log256(value);\r\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\r\n        }\r\n    }\r\n}\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\r\n}\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\r\n\r\n/**\r\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\r\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\r\n *\r\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\r\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\r\n * need to send a transaction, and thus is not required to hold Ether at all.\r\n */\r\ninterface IERC20Permit {\r\n    /**\r\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\r\n     * given ``owner``'s signed approval.\r\n     *\r\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\r\n     * ordering also apply here.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `deadline` must be a timestamp in the future.\r\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\r\n     * over the EIP712-formatted function arguments.\r\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\r\n     *\r\n     * For more information on the signature format, see the\r\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\r\n     * section].\r\n     */\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Returns the current nonce for `owner`. This value must be\r\n     * included whenever a signature is generated for {permit}.\r\n     *\r\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\r\n     * prevents a signature from being used multiple times.\r\n     */\r\n    function nonces(address owner) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\r\n     */\r\n    // solhint-disable-next-line func-name-mixedcase\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n}\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     *\r\n     * Furthermore, `isContract` will also return true if the target contract within\r\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\r\n     * which only has an effect at the end of a transaction.\r\n     * ====\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\r\n     *\r\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\r\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\r\n     * constructor.\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize/address.code.length, which returns 0\r\n        // for contracts in construction, since the code is only stored at the end\r\n        // of the constructor execution.\r\n\r\n        return account.code.length > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain `call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\r\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\r\n     *\r\n     * _Available since v4.8._\r\n     */\r\n    function verifyCallResultFromTarget(\r\n        address target,\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        if (success) {\r\n            if (returndata.length == 0) {\r\n                // only check isContract if the call was successful and the return data is empty\r\n                // otherwise we already know that it was a contract\r\n                require(isContract(target), \"Address: call to non-contract\");\r\n            }\r\n            return returndata;\r\n        } else {\r\n            _revert(returndata, errorMessage);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\r\n     * revert reason or using the provided one.\r\n     *\r\n     * _Available since v4.3._\r\n     */\r\n    function verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            _revert(returndata, errorMessage);\r\n        }\r\n    }\r\n\r\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\r\n        // Look for revert reason and bubble it up if present\r\n        if (returndata.length > 0) {\r\n            // The easiest way to bubble the revert reason is using memory via assembly\r\n            /// @solidity memory-safe-assembly\r\n            assembly {\r\n                let returndata_size := mload(returndata)\r\n                revert(add(32, returndata), returndata_size)\r\n            }\r\n        } else {\r\n            revert(errorMessage);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using Address for address;\r\n\r\n    /**\r\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\r\n     * non-reverting calls are assumed to be successful.\r\n     */\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\r\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\r\n     */\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Deprecated. This function has issues similar to the ones found in\r\n     * {IERC20-approve}, and its usage is discouraged.\r\n     *\r\n     * Whenever possible, use {safeIncreaseAllowance} and\r\n     * {safeDecreaseAllowance} instead.\r\n     */\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        require(\r\n            (value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\r\n     * non-reverting calls are assumed to be successful.\r\n     */\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 oldAllowance = token.allowance(address(this), spender);\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\r\n    }\r\n\r\n    /**\r\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\r\n     * non-reverting calls are assumed to be successful.\r\n     */\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        unchecked {\r\n            uint256 oldAllowance = token.allowance(address(this), spender);\r\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\r\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\r\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\r\n     * to be set to zero before setting it to a non-zero value, such as USDT.\r\n     */\r\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\r\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\r\n\r\n        if (!_callOptionalReturnBool(token, approvalCall)) {\r\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\r\n            _callOptionalReturn(token, approvalCall);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\r\n     * Revert on invalid signature.\r\n     */\r\n    function safePermit(\r\n        IERC20Permit token,\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) internal {\r\n        uint256 nonceBefore = token.nonces(owner);\r\n        token.permit(owner, spender, value, deadline, v, r, s);\r\n        uint256 nonceAfter = token.nonces(owner);\r\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     *\r\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\r\n     */\r\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\r\n        // and not revert is the subcall reverts.\r\n\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        return\r\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\r\n    }\r\n}\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable2Step.sol)\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the sender is not the owner.\r\n     */\r\n    function _checkOwner() internal view virtual {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby disabling any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Contract module which provides access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership} and {acceptOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available all functions\r\n * from parent (Ownable).\r\n */\r\nabstract contract Ownable2Step is Ownable {\r\n    address private _pendingOwner;\r\n\r\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Returns the address of the pending owner.\r\n     */\r\n    function pendingOwner() public view virtual returns (address) {\r\n        return _pendingOwner;\r\n    }\r\n\r\n    /**\r\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\r\n        _pendingOwner = newOwner;\r\n        emit OwnershipTransferStarted(owner(), newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual override {\r\n        delete _pendingOwner;\r\n        super._transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev The new owner accepts the ownership transfer.\r\n     */\r\n    function acceptOwnership() public virtual {\r\n        address sender = _msgSender();\r\n        require(pendingOwner() == sender, \"Ownable2Step: caller is not the new owner\");\r\n        _transferOwnership(sender);\r\n    }\r\n}\r\n\r\n// For compatibility, we're keeping the same function names as in the original Curve code, including the mixed-case\r\n// naming convention.\r\n// solhint-disable func-name-mixedcase\r\n\r\ninterface IVotingEscrow {\r\n    struct Point {\r\n        int128 bias;\r\n        int128 slope; // - dweight / dt\r\n        uint256 ts;\r\n        uint256 blk; // block\r\n    }\r\n\r\n    struct LockedBalance {\r\n        int128 amount;\r\n        uint256 end;\r\n    }\r\n\r\n    function MAXTIME() external view returns (uint256);\r\n\r\n    function MINTIME() external view returns (uint256);\r\n\r\n    function token() external view returns (address);\r\n\r\n    function supply() external view returns (uint256);\r\n\r\n    function unlocked() external view returns (bool);\r\n\r\n    function locked(address) external view returns (int128, uint256);\r\n\r\n    function epoch() external view returns (uint256);\r\n\r\n    function balanceOf(address user) external view returns (uint256);\r\n\r\n    function balanceOfAt(address user, uint256 _block) external view returns (uint256);\r\n\r\n    function balanceOfAtT(address user, uint256 timestamp) external view returns (uint256);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function totalSupplyAt(uint256 _block) external view returns (uint256);\r\n\r\n    function totalSupplyAtT(uint256 timestamp) external view returns (uint256);\r\n\r\n    function user_point_epoch(address user) external view returns (uint256);\r\n\r\n    function slope_changes(uint256 i) external view returns (int128);\r\n\r\n    function point_history(uint256 timestamp) external view returns (int128, int128, uint256, uint256);\r\n\r\n    function user_point_history(\r\n        address user,\r\n        uint256 timestamp\r\n    )\r\n        external\r\n        view\r\n        returns (int128, int128, uint256, uint256);\r\n\r\n    function unlock() external;\r\n\r\n    function checkpoint() external;\r\n\r\n    function locked__end(address user) external view returns (uint256);\r\n\r\n    function deposit_for(address _addr, uint256 _value) external;\r\n\r\n    function create_lock(uint256 _value, uint256 _unlock_time) external;\r\n\r\n    function create_lock_for(address _addr, uint256 _value, uint256 _unlock_time) external;\r\n\r\n    function increase_amount(uint256 _value) external;\r\n\r\n    function withdraw() external;\r\n\r\n    function add_to_whitelist(address _addr) external;\r\n\r\n    function remove_from_whitelist(address _addr) external;\r\n}\r\n\r\n/**\r\n * @title Fee Distributor\r\n * @notice Distributes any tokens transferred to the contract (e.g. Protocol fees) among veRAFT\r\n * holders proportionally based on a snapshot of the week at which the tokens are sent to the FeeDistributor contract.\r\n * @dev Supports distributing arbitrarily many different tokens. In order to start distributing a new token to veRAFT\r\n * holders simply transfer the tokens to the `FeeDistributor` contract and then call `checkpointToken`.\r\n */\r\ninterface IFeeDistributor {\r\n    event TokenCheckpointed(IERC20 token, uint256 amount, uint256 lastCheckpointTimestamp);\r\n    event TokensClaimed(address user, IERC20 token, uint256 amount, uint256 userTokenTimeCursor);\r\n    event TokenWithdrawn(IERC20 token, uint256 amount, address recipient);\r\n    event TokenClaimingEnabled(IERC20 token, bool enabled);\r\n    event OnlyVeHolderClaimingEnabled(address user, bool enabled);\r\n\r\n    /**\r\n     * @notice Returns the VotingEscrow (veRAFT) token contract\r\n     */\r\n    function getVotingEscrow() external view returns (IVotingEscrow);\r\n\r\n    /**\r\n     * @notice Returns the time when fee distribution starts.\r\n     */\r\n    function getStartTime() external view returns (uint256);\r\n\r\n    /**\r\n     * @notice Returns the global time cursor representing the most earliest uncheckpointed week.\r\n     */\r\n    function getTimeCursor() external view returns (uint256);\r\n\r\n    /**\r\n     * @notice Returns the user-level time cursor representing the most earliest uncheckpointed week.\r\n     * @param user - The address of the user to query.\r\n     */\r\n    function getUserTimeCursor(address user) external view returns (uint256);\r\n\r\n    /**\r\n     * @notice Returns the user-level start time representing the first week they're eligible to claim tokens.\r\n     * @param user - The address of the user to query.\r\n     */\r\n    function getUserStartTime(address user) external view returns (uint256);\r\n\r\n    /**\r\n     * @notice True if the given token can be claimed, false otherwise.\r\n     * @param token - The ERC20 token address to query.\r\n     */\r\n    function canTokenBeClaimed(IERC20 token) external view returns (bool);\r\n\r\n    /**\r\n     * @notice Returns the token-level start time representing the timestamp users could start claiming this token\r\n     * @param token - The ERC20 token address to query.\r\n     */\r\n    function getTokenStartTime(IERC20 token) external view returns (uint256);\r\n\r\n    /**\r\n     * @notice Returns the token-level time cursor storing the timestamp at up to which tokens have been distributed.\r\n     * @param token - The ERC20 token address to query.\r\n     */\r\n    function getTokenTimeCursor(IERC20 token) external view returns (uint256);\r\n\r\n    /**\r\n     * @notice Returns the token-level cached balance.\r\n     * @param token - The ERC20 token address to query.\r\n     */\r\n    function getTokenCachedBalance(IERC20 token) external view returns (uint256);\r\n\r\n    /**\r\n     * @notice Returns the user-level last checkpointed epoch.\r\n     * @param user - The address of the user to query.\r\n     */\r\n    function getUserLastEpochCheckpointed(address user) external view returns (uint256);\r\n\r\n    /**\r\n     * @notice Returns the user-level time cursor storing the timestamp of the latest token distribution claimed.\r\n     * @param user - The address of the user to query.\r\n     * @param token - The ERC20 token address to query.\r\n     */\r\n    function getUserTokenTimeCursor(address user, IERC20 token) external view returns (uint256);\r\n\r\n    /**\r\n     * @notice Returns the user's cached balance of veRAFT as of the provided timestamp.\r\n     * @dev Only timestamps which fall on Thursdays 00:00:00 UTC will return correct values.\r\n     * This function requires `user` to have been checkpointed past `timestamp` so that their balance is cached.\r\n     * @param user - The address of the user of which to read the cached balance of.\r\n     * @param timestamp - The timestamp at which to read the `user`'s cached balance at.\r\n     */\r\n    function getUserBalanceAtTimestamp(address user, uint256 timestamp) external view returns (uint256);\r\n\r\n    /**\r\n     * @notice Returns the cached total supply of veRAFT as of the provided timestamp.\r\n     * @dev Only timestamps which fall on Thursdays 00:00:00 UTC will return correct values.\r\n     * This function requires the contract to have been checkpointed past `timestamp` so that the supply is cached.\r\n     * @param timestamp - The timestamp at which to read the cached total supply at.\r\n     */\r\n    function getTotalSupplyAtTimestamp(uint256 timestamp) external view returns (uint256);\r\n\r\n    /**\r\n     * @notice Returns the FeeDistributor's cached balance of `token`.\r\n     */\r\n    function getTokenLastBalance(IERC20 token) external view returns (uint256);\r\n\r\n    /**\r\n     * @notice Returns the amount of `token` which the FeeDistributor received in the week beginning at `timestamp`.\r\n     * @param token - The ERC20 token address to query.\r\n     * @param timestamp - The timestamp corresponding to the beginning of the week of interest.\r\n     */\r\n    function getTokensDistributedInWeek(IERC20 token, uint256 timestamp) external view returns (uint256);\r\n\r\n    // Preventing third-party claiming\r\n\r\n    /**\r\n     * @notice Enables / disables rewards claiming only by the VotingEscrow holder for the message sender.\r\n     * @param enabled - True if only the VotingEscrow holder can claim their rewards, false otherwise.\r\n     */\r\n    function enableOnlyVeHolderClaiming(bool enabled) external;\r\n\r\n    /**\r\n     * @notice Returns true if only the VotingEscrow holder can claim their rewards, false otherwise.\r\n     */\r\n    function onlyVeHolderClaimingEnabled(address user) external view returns (bool);\r\n\r\n    // Depositing\r\n\r\n    /**\r\n     * @notice Deposits tokens to be distributed in the current week.\r\n     * @dev Sending tokens directly to the FeeDistributor instead of using `depositTokens` may result in tokens being\r\n     * retroactively distributed to past weeks, or for the distribution to carry over to future weeks.\r\n     *\r\n     * If for some reason `depositTokens` cannot be called, in order to ensure that all tokens are correctly\r\n     * distributed\r\n     * manually call `checkpointToken` before and after the token transfer.\r\n     * @param token - The ERC20 token address to distribute.\r\n     * @param amount - The amount of tokens to deposit.\r\n     */\r\n    function depositToken(IERC20 token, uint256 amount) external;\r\n\r\n    /**\r\n     * @notice Deposits tokens to be distributed in the current week.\r\n     * @dev A version of `depositToken` which supports depositing multiple `tokens` at once.\r\n     * See `depositToken` for more details.\r\n     * @param tokens - An array of ERC20 token addresses to distribute.\r\n     * @param amounts - An array of token amounts to deposit.\r\n     */\r\n    function depositTokens(IERC20[] calldata tokens, uint256[] calldata amounts) external;\r\n\r\n    // Checkpointing\r\n\r\n    /**\r\n     * @notice Caches the total supply of veRAFT at the beginning of each week.\r\n     * This function will be called automatically before claiming tokens to ensure the contract is properly updated.\r\n     */\r\n    function checkpoint() external;\r\n\r\n    /**\r\n     * @notice Caches the user's balance of veRAFT at the beginning of each week.\r\n     * This function will be called automatically before claiming tokens to ensure the contract is properly updated.\r\n     * @param user - The address of the user to be checkpointed.\r\n     */\r\n    function checkpointUser(address user) external;\r\n\r\n    /**\r\n     * @notice Assigns any newly-received tokens held by the FeeDistributor to weekly distributions.\r\n     * @dev Any `token` balance held by the FeeDistributor above that which is returned by `getTokenLastBalance`\r\n     * will be distributed evenly across the time period since `token` was last checkpointed.\r\n     *\r\n     * This function will be called automatically before claiming tokens to ensure the contract is properly updated.\r\n     * @param token - The ERC20 token address to be checkpointed.\r\n     */\r\n    function checkpointToken(IERC20 token) external;\r\n\r\n    /**\r\n     * @notice Assigns any newly-received tokens held by the FeeDistributor to weekly distributions.\r\n     * @dev A version of `checkpointToken` which supports checkpointing multiple tokens.\r\n     * See `checkpointToken` for more details.\r\n     * @param tokens - An array of ERC20 token addresses to be checkpointed.\r\n     */\r\n    function checkpointTokens(IERC20[] calldata tokens) external;\r\n\r\n    // Claiming\r\n\r\n    /**\r\n     * @notice Claims all pending distributions of the provided token for a user.\r\n     * @dev It's not necessary to explicitly checkpoint before calling this function, it will ensure the FeeDistributor\r\n     * is up to date before calculating the amount of tokens to be claimed.\r\n     * @param user - The user on behalf of which to claim.\r\n     * @param token - The ERC20 token address to be claimed.\r\n     * @return The amount of `token` sent to `user` as a result of claiming.\r\n     */\r\n    function claimToken(address user, IERC20 token) external returns (uint256);\r\n\r\n    /**\r\n     * @notice Claims a number of tokens on behalf of a user.\r\n     * @dev A version of `claimToken` which supports claiming multiple `tokens` on behalf of `user`.\r\n     * See `claimToken` for more details.\r\n     * @param user - The user on behalf of which to claim.\r\n     * @param tokens - An array of ERC20 token addresses to be claimed.\r\n     * @return An array of the amounts of each token in `tokens` sent to `user` as a result of claiming.\r\n     */\r\n    function claimTokens(address user, IERC20[] calldata tokens) external returns (uint256[] memory);\r\n\r\n    // Governance\r\n\r\n    /**\r\n     * @notice Withdraws the specified `amount` of the `token` from the contract to the `recipient`. Can be called only\r\n     * by Stargate DAO.\r\n     * @param token - The token to withdraw.\r\n     * @param amount - The amount to withdraw.\r\n     * @param recipient - The address to transfer the tokens to.\r\n     */\r\n    function withdrawToken(IERC20 token, uint256 amount, address recipient) external;\r\n\r\n    /**\r\n     * @notice Enables or disables claiming of the given token. Can be called only by Stargate DAO.\r\n     * @param token - The token to enable or disable claiming.\r\n     * @param enable - True if the token can be claimed, false otherwise.\r\n     */\r\n    function enableTokenClaiming(IERC20 token, bool enable) external;\r\n}\r\n\r\n// solhint-disable not-rely-on-time\r\n\r\n/**\r\n * @title Fee Distributor\r\n * @author Balancer Labs. Original version\r\n * https://github.com/balancer/balancer-v2-monorepo/blob/master/pkg/liquidity-mining/contracts/fee-distribution/FeeDistributor.sol\r\n * @notice Distributes any tokens transferred to the contract (e.g. Protocol fees) among veRAFT\r\n * holders proportionally based on a snapshot of the week at which the tokens are sent to the FeeDistributor contract.\r\n * @dev Supports distributing arbitrarily many different tokens. In order to start distributing a new token to veRAFT\r\n * holders call `depositToken`.\r\n */\r\ncontract FeeDistributor is IFeeDistributor, Ownable2Step, ReentrancyGuard {\r\n    using SafeERC20 for IERC20;\r\n\r\n    // gas optimization\r\n    uint256 private constant WEEK_MINUS_SECOND = 1 weeks - 1;\r\n\r\n    IVotingEscrow private immutable _votingEscrow;\r\n\r\n    uint256 private immutable _startTime;\r\n\r\n    // Global State\r\n    uint256 private _timeCursor;\r\n    mapping(uint256 => uint256) private _veSupplyCache;\r\n\r\n    // Token State\r\n\r\n    // `startTime` and `timeCursor` are both timestamps so comfortably fit in a uint64.\r\n    // `cachedBalance` will comfortably fit the total supply of any meaningful token.\r\n    // Should more than 2^128 tokens be sent to this contract then checkpointing this token will fail until enough\r\n    // tokens have been claimed to bring the total balance back below 2^128.\r\n    struct TokenState {\r\n        uint64 startTime;\r\n        uint64 timeCursor;\r\n        uint128 cachedBalance;\r\n    }\r\n\r\n    mapping(IERC20 => TokenState) private _tokenState;\r\n    mapping(IERC20 => mapping(uint256 => uint256)) private _tokensPerWeek;\r\n    mapping(IERC20 => bool) private _tokenClaimingEnabled;\r\n\r\n    // User State\r\n\r\n    // `startTime` and `timeCursor` are timestamps so will comfortably fit in a uint64.\r\n    // For `lastEpochCheckpointed` to overflow would need over 2^128 transactions to the VotingEscrow contract.\r\n    struct UserState {\r\n        uint64 startTime;\r\n        uint64 timeCursor;\r\n        uint128 lastEpochCheckpointed;\r\n    }\r\n\r\n    mapping(address => UserState) internal _userState;\r\n    mapping(address => mapping(uint256 => uint256)) private _userBalanceAtTimestamp;\r\n    mapping(address => mapping(IERC20 => uint256)) private _userTokenTimeCursor;\r\n    mapping(address => bool) private _onlyVeHolderClaimingEnabled;\r\n\r\n    /**\r\n     * @dev Reverts if only the VotingEscrow holder can claim their rewards and the given address is a third-party\r\n     * caller.\r\n     * @param user - The address to validate as the only allowed caller.\r\n     */\r\n    modifier userAllowedToClaim(address user) {\r\n        if (_onlyVeHolderClaimingEnabled[user]) {\r\n            require(msg.sender == user, \"Claiming is not allowed\");\r\n        }\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Reverts if the given token cannot be claimed.\r\n     * @param token - The token to check.\r\n     */\r\n    modifier tokenCanBeClaimed(IERC20 token) {\r\n        _checkIfClaimingEnabled(token);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Reverts if the given tokens cannot be claimed.\r\n     * @param tokens - The tokens to check.\r\n     */\r\n    modifier tokensCanBeClaimed(IERC20[] calldata tokens) {\r\n        uint256 tokensLength = tokens.length;\r\n        for (uint256 i = 0; i < tokensLength; ++i) {\r\n            _checkIfClaimingEnabled(tokens[i]);\r\n        }\r\n        _;\r\n    }\r\n\r\n    constructor(IVotingEscrow votingEscrow, uint256 startTime) {\r\n        _votingEscrow = votingEscrow;\r\n\r\n        startTime = _roundDownTimestamp(startTime);\r\n        uint256 currentWeek = _roundDownTimestamp(block.timestamp);\r\n        require(startTime >= currentWeek, \"Cannot start before current week\");\r\n\r\n        (int128 bias, int128 slope, uint256 ts, uint256 blk) = votingEscrow.point_history(0);\r\n        IVotingEscrow.Point memory pt = IVotingEscrow.Point(bias, slope, ts, blk);\r\n        require(startTime > pt.ts, \"Cannot start before VotingEscrow first epoch\");\r\n\r\n        _startTime = startTime;\r\n        _timeCursor = startTime;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the VotingEscrow (veRAFT) token contract\r\n     */\r\n    function getVotingEscrow() external view override returns (IVotingEscrow) {\r\n        return _votingEscrow;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the time when fee distribution starts.\r\n     */\r\n    function getStartTime() external view override returns (uint256) {\r\n        return _startTime;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the global time cursor representing the most earliest uncheckpointed week.\r\n     */\r\n    function getTimeCursor() external view override returns (uint256) {\r\n        return _timeCursor;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the user-level start time representing the first week they're eligible to claim tokens.\r\n     * @param user - The address of the user to query.\r\n     */\r\n    function getUserStartTime(address user) external view override returns (uint256) {\r\n        return _userState[user].startTime;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the user-level time cursor representing the most earliest uncheckpointed week.\r\n     * @param user - The address of the user to query.\r\n     */\r\n    function getUserTimeCursor(address user) external view override returns (uint256) {\r\n        return _userState[user].timeCursor;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the user-level last checkpointed epoch.\r\n     * @param user - The address of the user to query.\r\n     */\r\n    function getUserLastEpochCheckpointed(address user) external view override returns (uint256) {\r\n        return _userState[user].lastEpochCheckpointed;\r\n    }\r\n\r\n    /**\r\n     * @notice True if the given token can be claimed, false otherwise.\r\n     * @param token - The ERC20 token address to query.\r\n     */\r\n    function canTokenBeClaimed(IERC20 token) external view override returns (bool) {\r\n        return _tokenClaimingEnabled[token];\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the token-level start time representing the timestamp users could start claiming this token\r\n     * @param token - The ERC20 token address to query.\r\n     */\r\n    function getTokenStartTime(IERC20 token) external view override returns (uint256) {\r\n        return _tokenState[token].startTime;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the token-level time cursor storing the timestamp at up to which tokens have been distributed.\r\n     * @param token - The ERC20 token address to query.\r\n     */\r\n    function getTokenTimeCursor(IERC20 token) external view override returns (uint256) {\r\n        return _tokenState[token].timeCursor;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the token-level cached balance.\r\n     * @param token - The ERC20 token address to query.\r\n     */\r\n    function getTokenCachedBalance(IERC20 token) external view override returns (uint256) {\r\n        return _tokenState[token].cachedBalance;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the user-level time cursor storing the timestamp of the latest token distribution claimed.\r\n     * @param user - The address of the user to query.\r\n     * @param token - The ERC20 token address to query.\r\n     */\r\n    function getUserTokenTimeCursor(address user, IERC20 token) external view override returns (uint256) {\r\n        return _getUserTokenTimeCursor(user, token);\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the user's cached balance of veRAFT as of the provided timestamp.\r\n     * @dev Only timestamps which fall on Thursdays 00:00:00 UTC will return correct values.\r\n     * This function requires `user` to have been checkpointed past `timestamp` so that their balance is cached.\r\n     * @param user - The address of the user of which to read the cached balance of.\r\n     * @param timestamp - The timestamp at which to read the `user`'s cached balance at.\r\n     */\r\n    function getUserBalanceAtTimestamp(address user, uint256 timestamp) external view override returns (uint256) {\r\n        return _userBalanceAtTimestamp[user][timestamp];\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the cached total supply of veRAFT as of the provided timestamp.\r\n     * @dev Only timestamps which fall on Thursdays 00:00:00 UTC will return correct values.\r\n     * This function requires the contract to have been checkpointed past `timestamp` so that the supply is cached.\r\n     * @param timestamp - The timestamp at which to read the cached total supply at.\r\n     */\r\n    function getTotalSupplyAtTimestamp(uint256 timestamp) external view override returns (uint256) {\r\n        return _veSupplyCache[timestamp];\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the FeeDistributor's cached balance of `token`.\r\n     */\r\n    function getTokenLastBalance(IERC20 token) external view override returns (uint256) {\r\n        return _tokenState[token].cachedBalance;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the amount of `token` which the FeeDistributor received in the week beginning at `timestamp`.\r\n     * @param token - The ERC20 token address to query.\r\n     * @param timestamp - The timestamp corresponding to the beginning of the week of interest.\r\n     */\r\n    function getTokensDistributedInWeek(IERC20 token, uint256 timestamp) external view override returns (uint256) {\r\n        return _tokensPerWeek[token][timestamp];\r\n    }\r\n\r\n    // Preventing third-party claiming\r\n\r\n    /**\r\n     * @notice Enables / disables rewards claiming only by the VotingEscrow holder for the message sender.\r\n     * @param enabled - True if only the VotingEscrow holder can claim their rewards, false otherwise.\r\n     */\r\n    function enableOnlyVeHolderClaiming(bool enabled) external override {\r\n        _onlyVeHolderClaimingEnabled[msg.sender] = enabled;\r\n        emit OnlyVeHolderClaimingEnabled(msg.sender, enabled);\r\n    }\r\n\r\n    /**\r\n     * @notice Returns true if only the VotingEscrow holder can claim their rewards, false otherwise.\r\n     */\r\n    function onlyVeHolderClaimingEnabled(address user) external view override returns (bool) {\r\n        return _onlyVeHolderClaimingEnabled[user];\r\n    }\r\n\r\n    // Depositing\r\n\r\n    /**\r\n     * @notice Deposits tokens to be distributed in the current week.\r\n     * @dev Sending tokens directly to the FeeDistributor instead of using `depositToken` may result in tokens being\r\n     * retroactively distributed to past weeks, or for the distribution to carry over to future weeks.\r\n     *\r\n     * If for some reason `depositToken` cannot be called, in order to ensure that all tokens are correctly distributed\r\n     * manually call `checkpointToken` before and after the token transfer.\r\n     * @param token - The ERC20 token address to distribute.\r\n     * @param amount - The amount of tokens to deposit.\r\n     */\r\n    function depositToken(IERC20 token, uint256 amount) external override nonReentrant tokenCanBeClaimed(token) {\r\n        _checkpointToken(token, false);\r\n        token.safeTransferFrom(msg.sender, address(this), amount);\r\n        _checkpointToken(token, true);\r\n    }\r\n\r\n    /**\r\n     * @notice Deposits tokens to be distributed in the current week.\r\n     * @dev A version of `depositToken` which supports depositing multiple `tokens` at once.\r\n     * See `depositToken` for more details.\r\n     * @param tokens - An array of ERC20 token addresses to distribute.\r\n     * @param amounts - An array of token amounts to deposit.\r\n     */\r\n    function depositTokens(IERC20[] calldata tokens, uint256[] calldata amounts) external override nonReentrant {\r\n        require(tokens.length == amounts.length, \"Input length mismatch\");\r\n\r\n        uint256 length = tokens.length;\r\n        for (uint256 i = 0; i < length; ++i) {\r\n            _checkIfClaimingEnabled(tokens[i]);\r\n            _checkpointToken(tokens[i], false);\r\n            tokens[i].safeTransferFrom(msg.sender, address(this), amounts[i]);\r\n            _checkpointToken(tokens[i], true);\r\n        }\r\n    }\r\n\r\n    // Checkpointing\r\n\r\n    /**\r\n     * @notice Caches the total supply of veRAFT at the beginning of each week.\r\n     * This function will be called automatically before claiming tokens to ensure the contract is properly updated.\r\n     */\r\n    function checkpoint() external override nonReentrant {\r\n        _checkpointTotalSupply();\r\n    }\r\n\r\n    /**\r\n     * @notice Caches the user's balance of veRAFT at the beginning of each week.\r\n     * This function will be called automatically before claiming tokens to ensure the contract is properly updated.\r\n     * @param user - The address of the user to be checkpointed.\r\n     */\r\n    function checkpointUser(address user) external override nonReentrant {\r\n        _checkpointUserBalance(user);\r\n    }\r\n\r\n    /**\r\n     * @notice Assigns any newly-received tokens held by the FeeDistributor to weekly distributions.\r\n     * @dev Any `token` balance held by the FeeDistributor above that which is returned by `getTokenLastBalance`\r\n     * will be distributed evenly across the time period since `token` was last checkpointed.\r\n     *\r\n     * This function will be called automatically before claiming tokens to ensure the contract is properly updated.\r\n     * @param token - The ERC20 token address to be checkpointed.\r\n     */\r\n    function checkpointToken(IERC20 token) external override nonReentrant tokenCanBeClaimed(token) {\r\n        _checkpointToken(token, true);\r\n    }\r\n\r\n    /**\r\n     * @notice Assigns any newly-received tokens held by the FeeDistributor to weekly distributions.\r\n     * @dev A version of `checkpointToken` which supports checkpointing multiple tokens.\r\n     * See `checkpointToken` for more details.\r\n     * @param tokens - An array of ERC20 token addresses to be checkpointed.\r\n     */\r\n    function checkpointTokens(IERC20[] calldata tokens) external override nonReentrant {\r\n        uint256 tokensLength = tokens.length;\r\n        for (uint256 i = 0; i < tokensLength; ++i) {\r\n            _checkIfClaimingEnabled(tokens[i]);\r\n            _checkpointToken(tokens[i], true);\r\n        }\r\n    }\r\n\r\n    // Claiming\r\n\r\n    /**\r\n     * @notice Claims all pending distributions of the provided token for a user.\r\n     * @dev It's not necessary to explicitly checkpoint before calling this function, it will ensure the FeeDistributor\r\n     * is up to date before calculating the amount of tokens to be claimed.\r\n     * @param user - The user on behalf of which to claim.\r\n     * @param token - The ERC20 token address to be claimed.\r\n     * @return The amount of `token` sent to `user` as a result of claiming.\r\n     */\r\n    function claimToken(\r\n        address user,\r\n        IERC20 token\r\n    )\r\n        external\r\n        override\r\n        nonReentrant\r\n        userAllowedToClaim(user)\r\n        tokenCanBeClaimed(token)\r\n        returns (uint256)\r\n    {\r\n        _checkpointTotalSupply();\r\n        _checkpointUserBalance(user);\r\n        _checkpointToken(token, false);\r\n\r\n        return _claimToken(user, token);\r\n    }\r\n\r\n    /**\r\n     * @notice Claims a number of tokens on behalf of a user.\r\n     * @dev A version of `claimToken` which supports claiming multiple `tokens` on behalf of `user`.\r\n     * See `claimToken` for more details.\r\n     * @param user - The user on behalf of which to claim.\r\n     * @param tokens - An array of ERC20 token addresses to be claimed.\r\n     * @return An array of the amounts of each token in `tokens` sent to `user` as a result of claiming.\r\n     */\r\n    function claimTokens(\r\n        address user,\r\n        IERC20[] calldata tokens\r\n    )\r\n        external\r\n        override\r\n        nonReentrant\r\n        userAllowedToClaim(user)\r\n        tokensCanBeClaimed(tokens)\r\n        returns (uint256[] memory)\r\n    {\r\n        _checkpointTotalSupply();\r\n        _checkpointUserBalance(user);\r\n\r\n        uint256 tokensLength = tokens.length;\r\n        uint256[] memory amounts = new uint256[](tokensLength);\r\n        for (uint256 i = 0; i < tokensLength; ++i) {\r\n            _checkpointToken(tokens[i], false);\r\n            amounts[i] = _claimToken(user, tokens[i]);\r\n        }\r\n\r\n        return amounts;\r\n    }\r\n\r\n    // Governance\r\n\r\n    /**\r\n     * @notice Withdraws the specified `amount` of the `token` from the contract to the `recipient`. Can be called only\r\n     * by Raft DAO.\r\n     * @param token - The token to withdraw.\r\n     * @param amount - The amount to withdraw.\r\n     * @param recipient - The address to transfer the tokens to.\r\n     */\r\n    function withdrawToken(IERC20 token, uint256 amount, address recipient) external override onlyOwner {\r\n        token.safeTransfer(recipient, amount);\r\n        emit TokenWithdrawn(token, amount, recipient);\r\n    }\r\n\r\n    /**\r\n     * @notice Enables or disables claiming of the given token. Can be called only by Raft DAO.\r\n     * @param token - The token to enable or disable claiming.\r\n     * @param enable - True if the token can be claimed, false otherwise.\r\n     */\r\n    function enableTokenClaiming(IERC20 token, bool enable) external override onlyOwner {\r\n        _tokenClaimingEnabled[token] = enable;\r\n        emit TokenClaimingEnabled(token, enable);\r\n    }\r\n\r\n    // Internal functions\r\n\r\n    /**\r\n     * @dev It is required that both the global, token and user state have been properly checkpointed\r\n     * before calling this function.\r\n     */\r\n    function _claimToken(address user, IERC20 token) internal returns (uint256) {\r\n        TokenState storage tokenState = _tokenState[token];\r\n        uint256 nextUserTokenWeekToClaim = _getUserTokenTimeCursor(user, token);\r\n\r\n        // The first week which cannot be correctly claimed is the earliest of:\r\n        // - A) The global or user time cursor (whichever is earliest), rounded up to the end of the week.\r\n        // - B) The token time cursor, rounded down to the beginning of the week.\r\n        //\r\n        // This prevents the two failure modes:\r\n        // - A) A user may claim a week for which we have not processed their balance, resulting in tokens being\r\n        // locked.\r\n        // - B) A user may claim a week which then receives more tokens to be distributed. However the user has\r\n        //      already claimed for that week so their share of these new tokens are lost.\r\n        uint256 firstUnclaimableWeek = Math.min(\r\n            _roundUpTimestamp(Math.min(_timeCursor, _userState[user].timeCursor)),\r\n            _roundDownTimestamp(tokenState.timeCursor)\r\n        );\r\n\r\n        mapping(uint256 => uint256) storage tokensPerWeek = _tokensPerWeek[token];\r\n        mapping(uint256 => uint256) storage userBalanceAtTimestamp = _userBalanceAtTimestamp[user];\r\n\r\n        uint256 amount;\r\n        for (uint256 i = 0; i < 20; ++i) {\r\n            // We clearly cannot claim for `firstUnclaimableWeek` and so we break here.\r\n            if (nextUserTokenWeekToClaim >= firstUnclaimableWeek) break;\r\n\r\n            amount += (tokensPerWeek[nextUserTokenWeekToClaim] * userBalanceAtTimestamp[nextUserTokenWeekToClaim])\r\n                / _veSupplyCache[nextUserTokenWeekToClaim];\r\n            nextUserTokenWeekToClaim += 1 weeks;\r\n        }\r\n        // Update the stored user-token time cursor to prevent this user claiming this week again.\r\n        _userTokenTimeCursor[user][token] = nextUserTokenWeekToClaim;\r\n\r\n        if (amount > 0) {\r\n            // For a token to be claimable it must have been added to the cached balance so this is safe.\r\n            tokenState.cachedBalance = uint128(tokenState.cachedBalance - amount);\r\n            token.safeTransfer(user, amount);\r\n            emit TokensClaimed(user, token, amount, nextUserTokenWeekToClaim);\r\n        }\r\n\r\n        return amount;\r\n    }\r\n\r\n    /**\r\n     * @dev Calculate the amount of `token` to be distributed to `_votingEscrow` holders since the last checkpoint.\r\n     */\r\n    function _checkpointToken(IERC20 token, bool force) internal {\r\n        TokenState storage tokenState = _tokenState[token];\r\n        uint256 lastTokenTime = tokenState.timeCursor;\r\n        uint256 timeSinceLastCheckpoint;\r\n        if (lastTokenTime == 0) {\r\n            // Prevent someone from assigning tokens to an inaccessible week.\r\n            require(block.timestamp > _startTime, \"Fee distribution has not started yet\");\r\n\r\n            // If it's the first time we're checkpointing this token then start distributing from now.\r\n            // Also mark at which timestamp users should start attempts to claim this token from.\r\n            lastTokenTime = block.timestamp;\r\n            tokenState.startTime = uint64(_roundDownTimestamp(block.timestamp));\r\n        } else {\r\n            timeSinceLastCheckpoint = block.timestamp - lastTokenTime;\r\n\r\n            if (!force) {\r\n                // Checkpointing N times within a single week is completely equivalent to checkpointing once at the\r\n                // end.\r\n                // We then want to get as close as possible to a single checkpoint every Wed 23:59 UTC to save gas.\r\n\r\n                // We then skip checkpointing if we're in the same week as the previous checkpoint.\r\n                bool alreadyCheckpointedThisWeek =\r\n                    _roundDownTimestamp(block.timestamp) == _roundDownTimestamp(lastTokenTime);\r\n                // However we want to ensure that all of this week's fees are assigned to the current week without\r\n                // overspilling into the next week. To mitigate this, we checkpoint if we're near the end of the week.\r\n                bool nearingEndOfWeek = _roundUpTimestamp(block.timestamp) - block.timestamp < 1 days;\r\n\r\n                // This ensures that we checkpoint once at the beginning of the week and again for each user\r\n                // interaction\r\n                // towards the end of the week to give an accurate final reading of the balance.\r\n                if (alreadyCheckpointedThisWeek && !nearingEndOfWeek) {\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n\r\n        tokenState.timeCursor = uint64(block.timestamp);\r\n\r\n        uint256 tokenBalance = token.balanceOf(address(this));\r\n        uint256 newTokensToDistribute = tokenBalance - tokenState.cachedBalance;\r\n        if (newTokensToDistribute == 0) return;\r\n        require(tokenBalance <= type(uint128).max, \"Maximum token balance exceeded\");\r\n        tokenState.cachedBalance = uint128(tokenBalance);\r\n\r\n        uint256 firstIncompleteWeek = _roundDownTimestamp(lastTokenTime);\r\n        uint256 nextWeek = 0;\r\n\r\n        // Distribute `newTokensToDistribute` evenly across the time period from `lastTokenTime` to now.\r\n        // These tokens are assigned to weeks proportionally to how much of this period falls into each week.\r\n        mapping(uint256 => uint256) storage tokensPerWeek = _tokensPerWeek[token];\r\n        for (uint256 i = 0; i < 20; ++i) {\r\n            // This is safe as we're incrementing a timestamp.\r\n            nextWeek = firstIncompleteWeek + 1 weeks;\r\n            if (block.timestamp < nextWeek) {\r\n                // `firstIncompleteWeek` is now the beginning of the current week, i.e. this is the final iteration.\r\n                if (timeSinceLastCheckpoint == 0 && block.timestamp == lastTokenTime) {\r\n                    tokensPerWeek[firstIncompleteWeek] += newTokensToDistribute;\r\n                } else {\r\n                    // block.timestamp >= lastTokenTime by definition.\r\n                    tokensPerWeek[firstIncompleteWeek] +=\r\n                        (newTokensToDistribute * (block.timestamp - lastTokenTime)) / timeSinceLastCheckpoint;\r\n                }\r\n                // As we've caught up to the present then we should now break.\r\n                break;\r\n            } else {\r\n                // We've gone a full week or more without checkpointing so need to distribute tokens to previous weeks.\r\n                if (timeSinceLastCheckpoint == 0 && nextWeek == lastTokenTime) {\r\n                    // It shouldn't be possible to enter this block\r\n                    tokensPerWeek[firstIncompleteWeek] += newTokensToDistribute;\r\n                } else {\r\n                    // nextWeek > lastTokenTime by definition.\r\n                    tokensPerWeek[firstIncompleteWeek] +=\r\n                        (newTokensToDistribute * (nextWeek - lastTokenTime)) / timeSinceLastCheckpoint;\r\n                }\r\n            }\r\n\r\n            // We've now \"checkpointed\" up to the beginning of next week so must update timestamps appropriately.\r\n            lastTokenTime = nextWeek;\r\n            firstIncompleteWeek = nextWeek;\r\n        }\r\n\r\n        emit TokenCheckpointed(token, newTokensToDistribute, lastTokenTime);\r\n    }\r\n\r\n    /**\r\n     * @dev Cache the `user`'s balance of `_votingEscrow` at the beginning of each new week\r\n     */\r\n    function _checkpointUserBalance(address user) internal {\r\n        uint256 maxUserEpoch = _votingEscrow.user_point_epoch(user);\r\n\r\n        // If user has no epochs then they have never locked RAFT.\r\n        // They clearly will not then receive fees.\r\n        require(maxUserEpoch > 0, \"veRAFT balance is zero\");\r\n\r\n        UserState storage userState = _userState[user];\r\n\r\n        // `nextWeekToCheckpoint` represents the timestamp of the beginning of the first week\r\n        // which we haven't checkpointed the user's VotingEscrow balance yet.\r\n        uint256 nextWeekToCheckpoint = userState.timeCursor;\r\n\r\n        uint256 userEpoch;\r\n        if (nextWeekToCheckpoint == 0) {\r\n            // First checkpoint for user so need to do the initial binary search\r\n            userEpoch = _findTimestampUserEpoch(user, _startTime, 0, maxUserEpoch);\r\n        } else {\r\n            if (nextWeekToCheckpoint >= block.timestamp) {\r\n                // User has checkpointed the current week already so perform early return.\r\n                // This prevents a user from processing epochs created later in this week, however this is not an issue\r\n                // as if a significant number of these builds up then the user will skip past them with a binary\r\n                // search.\r\n                return;\r\n            }\r\n\r\n            // Otherwise use the value saved from last time\r\n            userEpoch = userState.lastEpochCheckpointed;\r\n\r\n            // This optimizes a scenario common for power users, which have frequent `VotingEscrow` interactions in\r\n            // the same week. We assume that any such user is also claiming fees every week, and so we only perform\r\n            // a binary search here rather than integrating it into the main search algorithm, effectively skipping\r\n            // most of the week's irrelevant checkpoints.\r\n            // The slight tradeoff is that users who have multiple infrequent `VotingEscrow` interactions and also\r\n            // don't\r\n            // claim frequently will also perform the binary search, despite it not leading to gas savings.\r\n            if (maxUserEpoch - userEpoch > 20) {\r\n                userEpoch = _findTimestampUserEpoch(user, nextWeekToCheckpoint, userEpoch, maxUserEpoch);\r\n            }\r\n        }\r\n\r\n        // Epoch 0 is always empty so bump onto the next one so that we start on a valid epoch.\r\n        if (userEpoch == 0) {\r\n            userEpoch = 1;\r\n        }\r\n\r\n        IVotingEscrow.Point memory nextUserPoint;\r\n        {\r\n            (int128 bias, int128 slope, uint256 ts, uint256 blk) = _votingEscrow.user_point_history(user, userEpoch);\r\n            nextUserPoint = IVotingEscrow.Point(bias, slope, ts, blk);\r\n        }\r\n\r\n        // If this is the first checkpoint for the user, calculate the first week they're eligible for.\r\n        // i.e. the timestamp of the first Thursday after they locked.\r\n        // If this is earlier then the first distribution then fast forward to then.\r\n        if (nextWeekToCheckpoint == 0) {\r\n            // Disallow checkpointing before `startTime`.\r\n            require(block.timestamp > _startTime, \"Fee distribution has not started yet\");\r\n            nextWeekToCheckpoint = Math.max(_startTime, _roundUpTimestamp(nextUserPoint.ts));\r\n            userState.startTime = uint64(nextWeekToCheckpoint);\r\n        }\r\n\r\n        // It's safe to increment `userEpoch` and `nextWeekToCheckpoint` in this loop as epochs and timestamps\r\n        // are always much smaller than 2^256 and are being incremented by small values.\r\n        IVotingEscrow.Point memory currentUserPoint;\r\n        for (uint256 i = 0; i < 50; ++i) {\r\n            if (nextWeekToCheckpoint >= nextUserPoint.ts && userEpoch <= maxUserEpoch) {\r\n                // The week being considered is contained in a user epoch after that described by `currentUserPoint`.\r\n                // We then shift `nextUserPoint` into `currentUserPoint` and query the Point for the next user epoch.\r\n                // We do this in order to step though epochs until we find the first epoch starting after\r\n                // `nextWeekToCheckpoint`, making the previous epoch the one that contains `nextWeekToCheckpoint`.\r\n                userEpoch += 1;\r\n                currentUserPoint = nextUserPoint;\r\n                if (userEpoch > maxUserEpoch) {\r\n                    nextUserPoint = IVotingEscrow.Point(0, 0, 0, 0);\r\n                } else {\r\n                    (int128 bias, int128 slope, uint256 ts, uint256 blk) =\r\n                        _votingEscrow.user_point_history(user, userEpoch);\r\n                    nextUserPoint = IVotingEscrow.Point(bias, slope, ts, blk);\r\n                }\r\n            } else {\r\n                // The week being considered lies inside the user epoch described by `oldUserPoint`\r\n                // we can then use it to calculate the user's balance at the beginning of the week.\r\n                if (nextWeekToCheckpoint >= block.timestamp) {\r\n                    // Break if we're trying to cache the user's balance at a timestamp in the future.\r\n                    // We only perform this check here to ensure that we can still process checkpoints created\r\n                    // in the current week.\r\n                    break;\r\n                }\r\n\r\n                int128 dt = int128(int256(nextWeekToCheckpoint) - int256(currentUserPoint.ts));\r\n                uint256 userBalance = currentUserPoint.bias > currentUserPoint.slope * dt\r\n                    ? uint256(int256(currentUserPoint.bias - currentUserPoint.slope * dt))\r\n                    : 0;\r\n\r\n                // User's lock has expired and they haven't relocked yet.\r\n                if (userBalance == 0 && userEpoch > maxUserEpoch) {\r\n                    nextWeekToCheckpoint = _roundUpTimestamp(block.timestamp);\r\n                    break;\r\n                }\r\n\r\n                // User had a nonzero lock and so is eligible to collect fees.\r\n                _userBalanceAtTimestamp[user][nextWeekToCheckpoint] = uint256(userBalance);\r\n\r\n                nextWeekToCheckpoint += 1 weeks;\r\n            }\r\n        }\r\n\r\n        // We subtract off 1 from the userEpoch to step back once so that on the next attempt to checkpoint\r\n        // the current `currentUserPoint` will be loaded as `nextUserPoint`. This ensures that we can't skip over the\r\n        // user epoch containing `nextWeekToCheckpoint`.\r\n        // userEpoch > 0 so this is safe.\r\n        userState.lastEpochCheckpointed = uint64(userEpoch - 1);\r\n        userState.timeCursor = uint64(nextWeekToCheckpoint);\r\n    }\r\n\r\n    /**\r\n     * @dev Cache the totalSupply of VotingEscrow token at the beginning of each new week\r\n     */\r\n    function _checkpointTotalSupply() internal {\r\n        uint256 nextWeekToCheckpoint = _timeCursor;\r\n        uint256 weekStart = _roundDownTimestamp(block.timestamp);\r\n\r\n        // We expect `timeCursor == weekStart + 1 weeks` when fully up to date.\r\n        if (nextWeekToCheckpoint > weekStart || weekStart == block.timestamp) {\r\n            // We've already checkpointed up to this week so perform early return\r\n            return;\r\n        }\r\n\r\n        _votingEscrow.checkpoint();\r\n\r\n        // Step through the each week and cache the total supply at beginning of week on this contract\r\n        for (uint256 i = 0; i < 20; ++i) {\r\n            if (nextWeekToCheckpoint > weekStart) break;\r\n\r\n            // NOTE: Replaced Balancer's logic with Solidly/Velodrome implementation due to the differences in the\r\n            // VotingEscrow totalSupply function\r\n            // See https://github.com/velodrome-finance/v1/blob/master/contracts/RewardsDistributor.sol#L143\r\n\r\n            uint256 epoch = _findTimestampEpoch(nextWeekToCheckpoint);\r\n\r\n            (int128 bias, int128 slope, uint256 ts, uint256 blk) = _votingEscrow.point_history(epoch);\r\n            IVotingEscrow.Point memory pt = IVotingEscrow.Point(bias, slope, ts, blk);\r\n\r\n            int128 dt = nextWeekToCheckpoint > pt.ts ? int128(uint128(nextWeekToCheckpoint - pt.ts)) : int128(0);\r\n            int128 supply = pt.bias - pt.slope * dt;\r\n            _veSupplyCache[nextWeekToCheckpoint] = supply > 0 ? uint256(int256(supply)) : 0;\r\n\r\n            // This is safe as we're incrementing a timestamp\r\n            nextWeekToCheckpoint += 1 weeks;\r\n        }\r\n        // Update state to the end of the current week (`weekStart` + 1 weeks)\r\n        _timeCursor = nextWeekToCheckpoint;\r\n    }\r\n\r\n    // Helper functions\r\n\r\n    /**\r\n     * @dev Wrapper around `_userTokenTimeCursor` which returns the start timestamp for `token`\r\n     * if `user` has not attempted to interact with it previously.\r\n     */\r\n    function _getUserTokenTimeCursor(address user, IERC20 token) internal view returns (uint256) {\r\n        uint256 userTimeCursor = _userTokenTimeCursor[user][token];\r\n        if (userTimeCursor > 0) return userTimeCursor;\r\n        // This is the first time that the user has interacted with this token.\r\n        // We then start from the latest out of either when `user` first locked veRAFT or `token` was first\r\n        // checkpointed.\r\n        return Math.max(_userState[user].startTime, _tokenState[token].startTime);\r\n    }\r\n\r\n    /**\r\n     * @dev Return the user epoch number for `user` corresponding to the provided `timestamp`\r\n     */\r\n    function _findTimestampUserEpoch(\r\n        address user,\r\n        uint256 timestamp,\r\n        uint256 minUserEpoch,\r\n        uint256 maxUserEpoch\r\n    )\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 min = minUserEpoch;\r\n        uint256 max = maxUserEpoch;\r\n\r\n        // Perform binary search through epochs to find epoch containing `timestamp`\r\n        for (uint256 i = 0; i < 128; ++i) {\r\n            if (min >= max) break;\r\n\r\n            // Algorithm assumes that inputs are less than 2^128 so this operation is safe.\r\n            // +2 avoids getting stuck in min == mid < max\r\n            uint256 mid = (min + max + 2) / 2;\r\n            (int128 bias, int128 slope, uint256 ts, uint256 blk) = _votingEscrow.user_point_history(user, mid);\r\n            IVotingEscrow.Point memory pt = IVotingEscrow.Point(bias, slope, ts, blk);\r\n            if (pt.ts <= timestamp) {\r\n                min = mid;\r\n            } else {\r\n                // max > min so this is safe.\r\n                max = mid - 1;\r\n            }\r\n        }\r\n        return min;\r\n    }\r\n\r\n    /**\r\n     * @dev Return the global epoch number corresponding to the provided `timestamp`\r\n     */\r\n    function _findTimestampEpoch(uint256 timestamp) internal view returns (uint256) {\r\n        uint256 min = 0;\r\n        uint256 max = _votingEscrow.epoch();\r\n\r\n        // Perform binary search through epochs to find epoch containing `timestamp`\r\n        for (uint256 i = 0; i < 128; i++) {\r\n            if (min >= max) break;\r\n\r\n            // Algorithm assumes that inputs are less than 2^128 so this operation is safe.\r\n            // +2 avoids getting stuck in min == mid < max\r\n            uint256 mid = (min + max + 2) / 2;\r\n            (int128 bias, int128 slope, uint256 ts, uint256 blk) = _votingEscrow.point_history(mid);\r\n            IVotingEscrow.Point memory pt = IVotingEscrow.Point(bias, slope, ts, blk);\r\n            if (pt.ts <= timestamp) {\r\n                min = mid;\r\n            } else {\r\n                max = mid - 1;\r\n            }\r\n        }\r\n        return min;\r\n    }\r\n\r\n    /**\r\n     * @dev Rounds the provided timestamp down to the beginning of the previous week (Thurs 00:00 UTC)\r\n     */\r\n    function _roundDownTimestamp(uint256 timestamp) private pure returns (uint256) {\r\n        // Division by zero or overflows are impossible here.\r\n        return (timestamp / 1 weeks) * 1 weeks;\r\n    }\r\n\r\n    /**\r\n     * @dev Rounds the provided timestamp up to the beginning of the next week (Thurs 00:00 UTC)\r\n     */\r\n    function _roundUpTimestamp(uint256 timestamp) private pure returns (uint256) {\r\n        // Overflows are impossible here for all realistic inputs.\r\n        return _roundDownTimestamp(timestamp + WEEK_MINUS_SECOND);\r\n    }\r\n\r\n    /**\r\n     * @dev Reverts if the provided token cannot be claimed.\r\n     */\r\n    function _checkIfClaimingEnabled(IERC20 token) private view {\r\n        require(_tokenClaimingEnabled[token], \"Token is not allowed\");\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IVotingEscrow\",\"name\":\"votingEscrow\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"OnlyVeHolderClaimingEnabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lastCheckpointTimestamp\",\"type\":\"uint256\"}],\"name\":\"TokenCheckpointed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"TokenClaimingEnabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"TokenWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"userTokenTimeCursor\",\"type\":\"uint256\"}],\"name\":\"TokensClaimed\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"canTokenBeClaimed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"checkpoint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"checkpointToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"name\":\"checkpointTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"checkpointUser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"claimToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"contract IERC20[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"name\":\"claimTokens\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"depositToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"depositTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"enableOnlyVeHolderClaiming\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"enable\",\"type\":\"bool\"}],\"name\":\"enableTokenClaiming\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getStartTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTimeCursor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getTokenCachedBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getTokenLastBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getTokenStartTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getTokenTimeCursor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"getTokensDistributedInWeek\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"getTotalSupplyAtTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"getUserBalanceAtTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserLastEpochCheckpointed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserStartTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserTimeCursor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getUserTokenTimeCursor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getVotingEscrow\",\"outputs\":[{\"internalType\":\"contract IVotingEscrow\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"onlyVeHolderClaimingEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "FeeDistributor", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000045d117011da1d49ba86af6ced94126488084186f00000000000000000000000000000000000000000000000000000000651e9629", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU GPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://0d1dfcfd4fbcd20032016ec79ec1fe6ac10e09c4935c4119236117b6c727fb2f"}