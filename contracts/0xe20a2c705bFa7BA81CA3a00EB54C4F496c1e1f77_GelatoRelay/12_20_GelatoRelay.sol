// SPDX-License-Identifier: MIT
pragma solidity 0.8.17;

import {IGelatoRelay} from "./interfaces/IGelatoRelay.sol";
import {IGelato1Balance} from "./interfaces/IGelato1Balance.sol";
import {GelatoCallUtils} from "./lib/GelatoCallUtils.sol";
import {GelatoTokenUtils} from "./lib/GelatoTokenUtils.sol";
import {SponsoredCall} from "./types/CallTypes.sol";
import {
    _encodeFeeCollector,
    _encodeRelayContext
} from "@gelatonetwork/relay-context/contracts/functions/GelatoRelayUtils.sol";
import {
    __getFeeCollector
} from "@gelatonetwork/relay-context/contracts/GelatoRelayFeeCollector.sol";
import {
    _getFeeCollectorRelayContext,
    _getFeeTokenRelayContext,
    _getFeeRelayContext
} from "@gelatonetwork/relay-context/contracts/GelatoRelayContext.sol";
// backwards compatible encoding for msg.sender support instead of feeCollector
import {_deprecatedRelayContext} from "./functions/DeprecatedUtils.sol";

/// @title  Gelato Relay contract
/// @notice This contract deals with synchronous payments and Gelato 1Balance payments
/// @dev    This contract must NEVER hold funds!
/// @dev    Maliciously crafted transaction payloads could wipe out any funds left here
// solhint-disable-next-line max-states-count
contract GelatoRelay is IGelatoRelay, IGelato1Balance {
    using GelatoCallUtils for address;
    using GelatoTokenUtils for address;

    address public immutable gelato;

    modifier onlyGelato() {
        require(msg.sender == gelato, "Only callable by gelato");
        _;
    }

    constructor(address _gelato) {
        gelato = _gelato;
    }

    /// @dev Previous version kept for backward compatibility
    function callWithSyncFee(
        address _target,
        bytes calldata _data,
        address _feeToken,
        uint256 _fee,
        bytes32 _taskId
    ) external onlyGelato {
        uint256 preBalance = _feeToken.getBalance(address(this));

        _target.revertingContractCall(
            _deprecatedRelayContext(_data, msg.sender, _feeToken, _fee),
            "GelatoRelay.callWithSyncFee:"
        );

        uint256 postBalance = _feeToken.getBalance(address(this));

        uint256 fee = postBalance - preBalance;

        if (fee != 0) _feeToken.transfer(msg.sender, fee);

        emit LogCallWithSyncFee(_target, _feeToken, _fee, _taskId);
    }

    /// @notice Relay call with Synchronous Payment
    /// @notice The target contract pays Gelato during the call forward
    /// @dev    This is the most straightforward use case, and `transfer` handles token payments.
    /// @param _target Target smart contract
    /// @param _data Payload for call on _target
    /// @param _isRelayContext true: all relay context encoding, false: only feeCollector encoding
    /// @param _correlationId Unique task identifier generated by gelato
    function callWithSyncFeeV2(
        address _target,
        bytes calldata _data,
        bool _isRelayContext,
        bytes32 _correlationId
    ) external onlyGelato {
        address feeToken;
        address feeCollector;
        uint256 preBalance;

        if (_isRelayContext) {
            feeCollector = _getFeeCollectorRelayContext();
            feeToken = _getFeeTokenRelayContext();
            preBalance = feeToken.getBalance(address(this));
        }

        _isRelayContext
            ? _target.revertingContractCall(
                _encodeRelayContext(
                    _data,
                    feeCollector,
                    feeToken,
                    _getFeeRelayContext()
                ),
                "GelatoRelay.callWithSyncFeeV2:"
            )
            : _target.revertingContractCall(
                _encodeFeeCollector(_data, __getFeeCollector()),
                "GelatoRelay.callWithSyncFeeV2:"
            );

        if (_isRelayContext) {
            uint256 fee = feeToken.getBalance(address(this)) - preBalance;
            if (fee != 0) feeToken.transfer(feeCollector, fee);
        }

        emit LogCallWithSyncFeeV2(_target, _correlationId);
    }

    /// @notice Relay call + One Balance payment - with sponsor authentication
    /// @dev    Payment is handled with off-chain accounting using Gelato's 1Balance system
    /// @param _call Relay call data packed into SponsoredCall struct
    /// @notice Oracle value for exchange rate between native tokens and fee token
    /// @param  _nativeToFeeTokenXRateNumerator Exchange rate numerator
    /// @param  _nativeToFeeTokenXRateDenominator Exchange rate denominator
    /// @param _correlationId Unique task identifier generated by gelato
    // solhint-disable-next-line function-max-lines
    function sponsoredCall(
        SponsoredCall calldata _call,
        address _sponsor,
        address _feeToken,
        uint256 _oneBalanceChainId,
        uint256 _nativeToFeeTokenXRateNumerator,
        uint256 _nativeToFeeTokenXRateDenominator,
        bytes32 _correlationId
    ) external onlyGelato {
        // CHECKS
        require(
            _call.chainId == block.chainid,
            "GelatoRelay.sponsoredCall:chainid"
        );

        // INTERACTIONS
        _call.target.revertingContractCall(
            _call.data,
            "GelatoRelay.sponsoredCall:"
        );

        emit LogUseGelato1Balance(
            _sponsor,
            _call.target,
            _feeToken,
            _oneBalanceChainId,
            _nativeToFeeTokenXRateNumerator,
            _nativeToFeeTokenXRateDenominator,
            _correlationId
        );
    }
}