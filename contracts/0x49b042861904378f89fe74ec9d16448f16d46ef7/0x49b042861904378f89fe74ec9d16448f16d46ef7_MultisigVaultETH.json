{"SourceCode": "\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n\npragma solidity ^0.5.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, \"SafeMath: division by zero\");\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n}\n\n/**\n * @title Basic token\n * @dev Basic version of StandardToken, with no allowances.\n */\ncontract MultisigVaultETH {\n\n    using SafeMath for uint256;\n\n    struct Approval {\n        uint256 nonce;\n        uint256 coincieded;\n        address[] coinciedeParties;\n    }\n\n    uint256 private participantsAmount;\n    uint256 private signatureMinThreshold;\n    uint256 private nonce;\n\n    string  private _symbol;\n    uint8   private _decimals;\n\n    address constant public ETHER_ADDRESS = address(0x1);\n\n    mapping(address => bool) public parties;\n\n    mapping(\n        // Destination\n        address => mapping(\n            // Amount\n            uint256 => Approval\n        )\n    ) public approvals;\n\n    mapping(uint256 => bool) public finished;\n\n    event ConfirmationReceived(address indexed from, address indexed destination, address currency, uint256 amount);\n    event ConsensusAchived(address indexed destination, address currency, uint256 amount);\n\n    /**\n      * @dev Construcor.\n      *\n      * Requirements:\n      * - `_signatureMinThreshold` .\n      * - `_parties`.\n      */\n    constructor(\n        uint256 _signatureMinThreshold,\n        address[] memory _parties\n    ) public {\n        require(_parties.length > 0 && _parties.length <= 10);\n        require(_signatureMinThreshold > 0 && _signatureMinThreshold <= _parties.length);\n\n        signatureMinThreshold = _signatureMinThreshold;\n\n        _symbol = \"ETH\";\n        _decimals = 18;\n\n        for (uint256 i = 0; i < _parties.length; i++) parties[_parties[i]] = true;\n    }\n\n    modifier isMember() {\n        require(parties[msg.sender]);\n        _;\n    }\n\n    modifier sufficient(uint256 _amount) {\n        // https://biboknow.com/page-ethereum/78597/solidity-0-6-0-addressthis-balance-throws-error-invalid-opcode\n        address me = address(this);\n        require(me.balance >= _amount);\n        _;\n    }\n\n    function getNonce(\n        address _destination,\n        uint256 _amount\n    ) public view returns (uint256) {\n        Approval storage approval = approvals[_destination][_amount];\n\n        return approval.nonce;\n    }\n\n    function partyCoincieded(\n        address _destination,\n        uint256 _amount,\n        uint256 _nonce,\n        address _partyAddress\n    ) public view returns (bool) {\n        if ( finished[_nonce] ) {\n          return true;\n        } else {\n          Approval storage approval = approvals[_destination][_amount];\n\n          for (uint i=0; i<approval.coinciedeParties.length; i++) {\n             if (approval.coinciedeParties[i] == _partyAddress) return true;\n          }\n\n          return false;\n        }\n    }\n\n    // https://ethereum.stackexchange.com/questions/19341/address-send-vs-address-transfer-best-practice-usage\n    function approve(\n        address payable _destination,\n        uint256 _amount\n    ) public isMember sufficient(_amount) returns (bool) {\n        Approval storage approval = approvals[_destination][_amount]; // Create new project\n\n        bool coinciedeParties = false;\n        for (uint i=0; i<approval.coinciedeParties.length; i++) {\n           if (approval.coinciedeParties[i] == msg.sender) coinciedeParties = true;\n        }\n\n        require(!coinciedeParties);\n\n        if (approval.coincieded == 0) {\n            nonce += 1;\n            approval.nonce = nonce;\n        }\n\n        approval.coinciedeParties.push(msg.sender);\n        approval.coincieded += 1;\n\n        emit ConfirmationReceived(msg.sender, _destination, ETHER_ADDRESS, _amount);\n\n        if ( approval.coincieded >= signatureMinThreshold ) {\n            _destination.transfer(_amount);    // Release\n\n            finished[approval.nonce] = true;\n            delete approvals[_destination][_amount];\n\n            emit ConsensusAchived(_destination, ETHER_ADDRESS, _amount);\n        }\n\n        return true;\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    function() external payable { }\n}\n", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_signatureMinThreshold\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"_parties\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"destination\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"currency\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ConfirmationReceived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"destination\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"currency\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ConsensusAchived\",\"type\":\"event\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":true,\"inputs\":[],\"name\":\"ETHER_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"approvals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"coincieded\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_destination\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"finished\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_destination\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"getNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"parties\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_destination\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_nonce\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_partyAddress\",\"type\":\"address\"}],\"name\":\"partyCoincieded\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "MultisigVaultETH", "CompilerVersion": "v0.5.16+commit.9c3226ce", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000030000000000000000000000008e27e80f0390f0bb19bee42115b9e20f8bab99b3000000000000000000000000f0cbcd78ee7c9b38e4cc806e56ff035d38ff37cd0000000000000000000000005a98821e40c681bd433f8acaac64650cc0445d1c", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}