{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/interfaces/voting-escrow/IVotingEscrow.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n// solhint-disable func-name-mixedcase\\n\\ninterface IVotingEscrow {\\n  /***********\\n   * Structs *\\n   ***********/\\n\\n  struct Point {\\n    int128 bias;\\n    int128 slope;\\n    uint256 ts;\\n    uint256 blk;\\n  }\\n\\n  /*************************\\n   * Public View Functions *\\n   *************************/\\n\\n  function token() external view returns (address);\\n\\n  function epoch() external view returns (uint256);\\n\\n  function point_history(uint256 epoch) external view returns (Point memory);\\n\\n  function user_point_epoch(address account) external view returns (uint256);\\n\\n  function user_point_history(address account, uint256 epoch) external view returns (Point memory);\\n\\n  /// @notice Get the timestamp for checkpoint `epoch` for `addr`\\n  /// @param addr User wallet address\\n  /// @param epoch User epoch number\\n  /// @return Epoch time of the checkpoint\\n  function user_point_history__ts(address addr, uint256 epoch) external view returns (uint256);\\n\\n  /// @notice Get timestamp when `addr`'s lock finishes\\n  /// @param addr User wallet\\n  /// @return Epoch time of the lock end\\n  function locked__end(address addr) external view returns (uint256);\\n\\n  /// @notice Calculate total voting power\\n  /// @dev Adheres to the ERC20 `totalSupply` interface for Aragon compatibility\\n  /// @return Total voting power\\n  function totalSupply() external view returns (uint256);\\n\\n  /// @notice Get the current voting power for `msg.sender`\\n  /// @dev Adheres to the ERC20 `balanceOf` interface for Aragon compatibility\\n  /// @param addr User wallet address\\n  /// @return User voting power\\n  function balanceOf(address addr) external view returns (uint256);\\n\\n  /// @notice time -> signed slope change\\n  function slope_changes(uint256 week) external view returns (int128);\\n\\n  /****************************\\n   * Public Mutated Functions *\\n   ****************************/\\n\\n  /// @notice Deposit `value` tokens for `addr` and add to the lock\\n  /// @dev Anyone (even a smart contract) can deposit for someone else, but\\n  ///      cannot extend their locktime and deposit for a brand new user\\n  /// @param addr User's wallet address\\n  /// @param value Amount to add to user's lock\\n  function deposit_for(address addr, uint256 value) external;\\n\\n  /// @notice Deposit `value` tokens for `msg.sender` and lock until `unlock_time`\\n  /// @param value Amount to deposit\\n  /// @param unlock_time Epoch time when tokens unlock, rounded down to whole weeks\\n  function create_lock(uint256 value, uint256 unlock_time) external;\\n\\n  /// @notice Deposit `value` additional tokens for `msg.sender`\\n  ///         without modifying the unlock time\\n  /// @param value Amount of tokens to deposit and add to the lock\\n  function increase_amount(uint256 value) external;\\n\\n  /// @notice Extend the unlock time for `msg.sender` to `unlock_time`\\n  /// @param unlock_time New epoch time for unlocking\\n  function increase_unlock_time(uint256 unlock_time) external;\\n\\n  /// @notice Withdraw all tokens for `msg.sender`\\n  /// @dev Only possible if the lock has expired\\n  function withdraw() external;\\n\\n  /// @notice Record global data to checkpoint\\n  function checkpoint() external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/voting-escrow/IVotingEscrowHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\ninterface IVotingEscrowHelper {\\n  /**********\\n   * Errors *\\n   **********/\\n\\n  /// @dev Thrown when try to checkpoint a future timestamp.\\n  error ErrorCheckpointFutureTime();\\n\\n  /// @dev Thrown when try to checkpoint a timestamp before start.\\n  error ErrorCheckpointInvalidPastTime();\\n\\n  /*************************\\n   * Public View Functions *\\n   *************************/\\n\\n  /// @notice Return the ve total supply at some specific time point.\\n  /// @param timestamp The time point in second to query.\\n  function totalSupply(uint256 timestamp) external view returns (uint256);\\n\\n  /// @notice Return the ve balance of some user at some specific time point.\\n  /// @param account The address of user to query.\\n  /// @param timestamp The time point in second to query.\\n  function balanceOf(address account, uint256 timestamp) external view returns (uint256);\\n\\n  /****************************\\n   * Public Mutated Functions *\\n   ****************************/\\n\\n  /// @notice Snapshot the state of some user.\\n  /// @param account The address of user to checkpoint.\\n  function checkpoint(address account) external;\\n\\n  /// @notice Snapshot the state of some user.\\n  /// @param account The address of user to checkpoint.\\n  /// @param timestamp The timestamp to checkpoint, should not less than current timestamp.\\n  function checkpoint(address account, uint256 timestamp) external;\\n}\\n\"\r\n    },\r\n    \"contracts/voting-escrow/VotingEscrowHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity =0.8.20;\\n\\nimport { IVotingEscrow } from \\\"../interfaces/voting-escrow/IVotingEscrow.sol\\\";\\nimport { IVotingEscrowHelper } from \\\"../interfaces/voting-escrow/IVotingEscrowHelper.sol\\\";\\n\\ncontract VotingEscrowHelper is IVotingEscrowHelper {\\n  /*************\\n   * Constants *\\n   *************/\\n\\n  /// @notice The address of VotingEscrow contract.\\n  address public immutable ve;\\n\\n  /// @notice The ve start timestamp.\\n  uint256 public immutable start;\\n\\n  /// @dev The number of seconds in a week.\\n  uint256 private constant WEEK = 7 days;\\n\\n  /***********\\n   * Structs *\\n   ***********/\\n\\n  /// @notice The ve balance/supply struct.\\n  /// @dev Compiler will pack this into single `uint256`.\\n  /// @param value The current ve balance/supply.\\n  /// @param epoch The corresponding ve balance/supply history point epoch.\\n  struct Balance {\\n    uint128 value;\\n    uint128 epoch;\\n  }\\n\\n  /*************\\n   * Variables *\\n   *************/\\n\\n  /// @dev Mapping from timestamp to corresponding ve supply struct.\\n  mapping(uint256 => Balance) private _supply;\\n\\n  /// @dev Mapping from account address to timestamp to corresponding ve balance struct.\\n  ///\\n  /// Note that we only record the struct for the timestamp when `checkpoint(account)` is\\n  /// invoked. This is used to saving gas, the reasons are below.\\n  ///\\n  /// There are two user types: EOA and contract account.  For normal EOA, the number\\n  /// of history points usually are small and the call to `checkpoint(account)` is also\\n  /// not frequently. For contract account, the number of history points usually are large\\n  /// and the call to `checkpoint(account)` is very frequently.\\n  ///\\n  /// According to the implementation of `balanceOf(address account, uint256 timestamp)`.\\n  /// For EOA, it is very likely to binary search for the correct epoch. And since the number\\n  /// of history points is small, the number of contract call is also small. For contract\\n  /// account, it is very likely to find the value in `_balances[account][week]`. Overall,\\n  /// we will find the correct balance using only `O(1)` contract read.\\n  mapping(address => mapping(uint256 => Balance)) private _balances;\\n\\n  /***************\\n   * Constructor *\\n   ***************/\\n\\n  constructor(address _ve) {\\n    ve = _ve;\\n    start = IVotingEscrow(_ve).point_history(1).ts;\\n\\n    uint256 epoch = IVotingEscrow(_ve).epoch();\\n    uint256 week = (block.timestamp / WEEK) * WEEK;\\n    require(week >= start, \\\"VotingEscrow not ready\\\");\\n\\n    (uint256 nowEpoch, IVotingEscrow.Point memory nowPoint) = _binarySearchSupplyPoint(week, 1, epoch);\\n    _supply[week] = Balance(uint128(_veSupplyAt(nowPoint, week)), uint128(nowEpoch));\\n  }\\n\\n  /*************************\\n   * Public View Functions *\\n   *************************/\\n\\n  /// @inheritdoc IVotingEscrowHelper\\n  function totalSupply(uint256 timestamp) external view override returns (uint256) {\\n    if (timestamp < start) return 0;\\n\\n    uint256 week = (timestamp / WEEK) * WEEK;\\n    Balance memory prevSupply = _supply[week];\\n    IVotingEscrow.Point memory point;\\n    if (prevSupply.epoch > 0) {\\n      if (week == timestamp) return prevSupply.value;\\n      Balance memory nextSupply = _supply[week + WEEK];\\n      uint256 nextEpoch = nextSupply.epoch;\\n      if (nextEpoch == 0) nextEpoch = IVotingEscrow(ve).epoch();\\n      (, point) = _binarySearchSupplyPoint(timestamp, prevSupply.epoch, nextEpoch);\\n    } else {\\n      (, point) = _binarySearchSupplyPoint(timestamp, 1, IVotingEscrow(ve).epoch());\\n    }\\n    return _veSupplyAt(point, timestamp);\\n  }\\n\\n  /// @inheritdoc IVotingEscrowHelper\\n  function balanceOf(address account, uint256 timestamp) external view override returns (uint256) {\\n    if (timestamp < start) return 0;\\n\\n    // check whether the user has no locks\\n    uint256 epoch = IVotingEscrow(ve).user_point_epoch(account);\\n    if (epoch == 0) return 0;\\n    IVotingEscrow.Point memory point = IVotingEscrow(ve).user_point_history(account, 1);\\n    if (timestamp < point.ts) return 0;\\n\\n    uint256 week = (timestamp / WEEK) * WEEK;\\n    Balance memory prevBalance = _balances[account][week];\\n    if (prevBalance.epoch > 0) {\\n      if (week == timestamp) return prevBalance.value;\\n      Balance memory nextBalance = _balances[account][week + WEEK];\\n      uint256 nextEpoch = nextBalance.epoch;\\n      if (nextEpoch == 0) nextEpoch = epoch;\\n      (, point) = _binarySearchBalancePoint(account, timestamp, prevBalance.epoch, nextEpoch);\\n    } else {\\n      (, point) = _binarySearchBalancePoint(account, timestamp, 1, epoch);\\n    }\\n    return _veBalanceAt(point, timestamp);\\n  }\\n\\n  /****************************\\n   * Public Mutated Functions *\\n   ****************************/\\n\\n  /// @inheritdoc IVotingEscrowHelper\\n  function checkpoint(address account) external override {\\n    // checkpoint supply\\n    uint256 week = (block.timestamp / WEEK) * WEEK;\\n    _checkpoint(account, week);\\n  }\\n\\n  /// @inheritdoc IVotingEscrowHelper\\n  function checkpoint(address account, uint256 timestamp) external override {\\n    if (timestamp > block.timestamp) revert ErrorCheckpointFutureTime();\\n    if (timestamp < start) revert ErrorCheckpointInvalidPastTime();\\n\\n    // checkpoint supply\\n    uint256 week = (timestamp / WEEK) * WEEK;\\n    _checkpoint(account, week);\\n  }\\n\\n  /**********************\\n   * Internal Functions *\\n   **********************/\\n\\n  /// @dev Internal function to checkpoint ve balance and supply at timestamp week.\\n  /// @param account The address of user to checkpoint.\\n  /// @param week The timestamp to checkpoint, should not less than current timestamp.\\n  function _checkpoint(address account, uint256 week) internal {\\n    IVotingEscrow(ve).checkpoint();\\n\\n    // checkpoint supply\\n    Balance memory nowSupply = _supply[week];\\n    if (nowSupply.epoch == 0) {\\n      Balance memory prevSupply = _supply[week - WEEK];\\n      uint256 epoch;\\n      IVotingEscrow.Point memory point;\\n      if (prevSupply.epoch == 0) {\\n        (epoch, point) = _binarySearchSupplyPoint(week, 1, IVotingEscrow(ve).epoch());\\n      } else {\\n        (epoch, point) = _binarySearchSupplyPoint(week, prevSupply.epoch, IVotingEscrow(ve).epoch());\\n      }\\n\\n      nowSupply.value = uint128(_veSupplyAt(point, week));\\n      nowSupply.epoch = uint128(epoch);\\n      _supply[week] = nowSupply;\\n    }\\n\\n    // checkpoint balance for nonzero address\\n    if (account == address(0)) return;\\n    uint256 userPointEpoch = IVotingEscrow(ve).user_point_epoch(account);\\n    if (userPointEpoch == 0) return;\\n\\n    Balance memory nowBalance = _balances[account][week];\\n    if (nowBalance.epoch == 0) {\\n      Balance memory prevBalance = _balances[account][week - WEEK];\\n      uint256 epoch;\\n      IVotingEscrow.Point memory point;\\n      if (prevBalance.epoch == 0) {\\n        (epoch, point) = _binarySearchBalancePoint(account, week, 1, userPointEpoch);\\n      } else {\\n        (epoch, point) = _binarySearchBalancePoint(account, week, prevBalance.epoch, userPointEpoch);\\n      }\\n\\n      // @note `week < point.ts` can happen if user create lock after week timestamp\\n      if (week >= point.ts) {\\n        nowBalance.value = uint128(_veBalanceAt(point, week));\\n      }\\n\\n      nowBalance.epoch = uint128(epoch);\\n      _balances[account][week] = nowBalance;\\n    }\\n  }\\n\\n  /// @dev Internal function to find largest `epoch` belongs to `[startEpoch, endEpoch]` and\\n  /// `ve.point_history(epoch) <= timestamp`.\\n  ///\\n  /// Caller should make sure the `ve.point_history(startEpoch) <= timestamp`.\\n  ///\\n  /// @param timestamp The timestamp to search.\\n  /// @param startEpoch The number of start epoch, inclusive.\\n  /// @param endEpoch The number of end epoch, inclusive.\\n  /// @return epoch The largest `epoch` that `ve.point_history(epoch) <= timestamp`.\\n  /// @return point The value of `ve.point_history(epoch)`.\\n  function _binarySearchSupplyPoint(\\n    uint256 timestamp,\\n    uint256 startEpoch,\\n    uint256 endEpoch\\n  ) internal view returns (uint256 epoch, IVotingEscrow.Point memory point) {\\n    unchecked {\\n      while (startEpoch < endEpoch) {\\n        uint256 mid = (startEpoch + endEpoch + 1) / 2;\\n        IVotingEscrow.Point memory p = IVotingEscrow(ve).point_history(mid);\\n        if (p.ts <= timestamp) {\\n          startEpoch = mid;\\n          point = p;\\n        } else {\\n          endEpoch = mid - 1;\\n        }\\n      }\\n    }\\n    epoch = startEpoch;\\n    // in case, the `p.ts <= timestamp` never hit in the binary search\\n    if (point.ts == 0) {\\n      point = IVotingEscrow(ve).point_history(epoch);\\n    }\\n  }\\n\\n  /// @dev Internal function to find largest `epoch` belongs to `[startEpoch, endEpoch]` and\\n  /// `ve.user_point_history(account, epoch) <= timestamp`.\\n  ///\\n  /// Caller should make sure the `ve.user_point_history(account, startEpoch) <= timestamp`.\\n  ///\\n  /// @param account The address of user to search.\\n  /// @param timestamp The timestamp to search.\\n  /// @param startEpoch The number of start epoch, inclusive.\\n  /// @param endEpoch The number of end epoch, inclusive.\\n  /// @return epoch The largest `epoch` that `ve.user_point_history(account, epoch) <= timestamp`.\\n  /// @return point The value of `ve.user_point_history(account, epoch)`.\\n  function _binarySearchBalancePoint(\\n    address account,\\n    uint256 timestamp,\\n    uint256 startEpoch,\\n    uint256 endEpoch\\n  ) internal view returns (uint256 epoch, IVotingEscrow.Point memory point) {\\n    unchecked {\\n      while (startEpoch < endEpoch) {\\n        uint256 mid = (startEpoch + endEpoch + 1) / 2;\\n        IVotingEscrow.Point memory p = IVotingEscrow(ve).user_point_history(account, mid);\\n        if (p.ts <= timestamp) {\\n          startEpoch = mid;\\n          point = p;\\n        } else {\\n          endEpoch = mid - 1;\\n        }\\n      }\\n    }\\n    epoch = startEpoch;\\n    // in case, the `p.ts <= timestamp` never hit in the binary search\\n    if (point.ts == 0) {\\n      point = IVotingEscrow(ve).user_point_history(account, epoch);\\n    }\\n  }\\n\\n  /// @dev Internal function to compute the ve supply. Caller should make sure `timestamp` is not less than `point.ts`.\\n  /// @param point The point for ve.\\n  /// @param timestamp The timestamp to compute.\\n  function _veSupplyAt(IVotingEscrow.Point memory point, uint256 timestamp) internal view returns (uint256) {\\n    int256 bias = point.bias;\\n    int256 slope = point.slope;\\n    uint256 last = point.ts;\\n    uint256 ti = (last / WEEK) * WEEK;\\n    while (true) {\\n      ti += WEEK;\\n      int128 dslope = 0;\\n      if (ti > timestamp) ti = timestamp;\\n      else {\\n        dslope = IVotingEscrow(ve).slope_changes(ti);\\n      }\\n      bias -= slope * int256(ti - last);\\n      if (ti == timestamp) break;\\n      slope += dslope;\\n      last = ti;\\n    }\\n    if (bias < 0) bias = 0; // the lock has expired, only happens when it is the last point\\n\\n    return uint256(int256(bias));\\n  }\\n\\n  /// @dev Internal function to compute the ve balance. Caller should make sure `timestamp` is not less than `point.ts`.\\n  /// @param point The point for ve.\\n  /// @param timestamp The timestamp to compute.\\n  function _veBalanceAt(IVotingEscrow.Point memory point, uint256 timestamp) internal pure returns (uint256) {\\n    int256 bias = point.bias - point.slope * int256(timestamp - point.ts);\\n    if (bias < 0) bias = 0; // the lock has expired, only happens when it is the last point\\n\\n    return uint256(bias);\\n  }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"shanghai\",\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_ve\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ErrorCheckpointFutureTime\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ErrorCheckpointInvalidPastTime\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"checkpoint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"checkpoint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"start\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ve\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "VotingEscrowHelper", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000ec6b8a3f3605b083f7044c0f31f2cac0caf1d469", "EVMVersion": "shanghai", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}