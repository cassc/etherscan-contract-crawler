{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/evm/tools/ImmutableCreate2Factory.sol\": {\r\n      \"content\": \"pragma solidity 0.5.10; // optimization enabled, 99999 runs, evm: petersburg\\n\\ninterface Ownable {\\n    function transferOwnership(address newOwner) external;\\n}\\n\\n/**\\n * @title Immutable Create2 Contract Factory\\n * @author 0age\\n * @notice This contract provides a safeCreate2 function that takes a salt value\\n * and a block of initialization code as arguments and passes them into inline\\n * assembly. The contract prevents redeploys by maintaining a mapping of all\\n * contracts that have already been deployed, and prevents frontrunning or other\\n * collisions by requiring that the first 20 bytes of the salt are equal to the\\n * address of the caller (this can be bypassed by setting the first 20 bytes to\\n * the null address). There is also a view function that computes the address of\\n * the contract that will be created when submitting a given salt or nonce along\\n * with a given block of initialization code.\\n * @dev This contract has not yet been fully tested or audited - proceed with\\n * caution and please share any exploits or optimizations you discover.\\n */\\ncontract ImmutableCreate2Factory {\\n    // mapping to track which addresses have already been deployed.\\n    mapping(address => bool) private _deployed;\\n\\n    function safeCreate2Internal(\\n        bytes32 salt,\\n        bytes memory initializationCode\\n    ) internal returns (address deploymentAddress) {\\n        // move the initialization code from calldata to memory.\\n        bytes memory initCode = initializationCode;\\n\\n        // determine the target address for contract deployment.\\n        address targetDeploymentAddress = address(\\n            uint160( // downcast to match the address type.\\n                uint256( // convert to uint to truncate upper digits.\\n                    keccak256( // compute the CREATE2 hash using 4 inputs.\\n                        abi.encodePacked( // pack all inputs to the hash together.\\n                            hex\\\"ff\\\", // start with 0xff to distinguish from RLP.\\n                            address(this), // this contract will be the caller.\\n                            salt, // pass in the supplied salt value.\\n                            keccak256(abi.encodePacked(initCode)) // pass in the hash of initialization code.\\n                        )\\n                    )\\n                )\\n            )\\n        );\\n\\n        // ensure that a contract hasn't been previously deployed to target address.\\n        require(!_deployed[targetDeploymentAddress], \\\"Invalid contract creation - contract has already been deployed.\\\");\\n\\n        // using inline assembly: load data and length of data, then call CREATE2.\\n        assembly {\\n            // solhint-disable-line\\n            let encoded_data := add(0x20, initCode) // load initialization code.\\n            let encoded_size := mload(initCode) // load the init code's length.\\n            deploymentAddress := create2(\\n                // call CREATE2 with 4 arguments.\\n                callvalue, // forward any attached value.\\n                encoded_data, // pass in initialization code.\\n                encoded_size, // pass in init code's length.\\n                salt // pass in the salt value.\\n            )\\n        }\\n\\n        // check address against target to ensure that deployment was successful.\\n        require(\\n            deploymentAddress == targetDeploymentAddress,\\n            \\\"Failed to deploy contract using provided salt and initialization code.\\\"\\n        );\\n\\n        // record the deployment of the contract to prevent redeploys.\\n        _deployed[deploymentAddress] = true;\\n    }\\n\\n    /**\\n     * @dev Create a contract using CREATE2 by submitting a given salt or nonce\\n     * along with the initialization code for the contract. Note that the first 20\\n     * bytes of the salt must match those of the calling address, which prevents\\n     * contract creation events from being submitted by unintended parties.\\n     * @param salt bytes32 The nonce that will be passed into the CREATE2 call.\\n     * @param initializationCode bytes The initialization code that will be passed\\n     * into the CREATE2 call.\\n     * @return Address of the contract that will be created, or the null address\\n     * if a contract already exists at that address.\\n     */\\n    function safeCreate2(\\n        bytes32 salt,\\n        bytes memory initializationCode\\n    ) public payable containsCaller(salt) returns (address deploymentAddress) {\\n        return safeCreate2Internal(salt, initializationCode);\\n    }\\n\\n    /**\\n     * @dev Compute the address of the contract that will be created when\\n     * submitting a given salt or nonce to the contract along with the contract's\\n     * initialization code. The CREATE2 address is computed in accordance with\\n     * EIP-1014, and adheres to the formula therein of\\n     * `keccak256( 0xff ++ address ++ salt ++ keccak256(init_code)))[12:]` when\\n     * performing the computation. The computed address is then checked for any\\n     * existing contract code - if so, the null address will be returned instead.\\n     * @param salt bytes32 The nonce passed into the CREATE2 address calculation.\\n     * @param initCode bytes The contract initialization code to be used.\\n     * that will be passed into the CREATE2 address calculation.\\n     * @return Address of the contract that will be created, or the null address\\n     * if a contract has already been deployed to that address.\\n     */\\n    function findCreate2Address(\\n        bytes32 salt,\\n        bytes calldata initCode\\n    ) external view returns (address deploymentAddress) {\\n        // determine the address where the contract will be deployed.\\n        deploymentAddress = address(\\n            uint160( // downcast to match the address type.\\n                uint256( // convert to uint to truncate upper digits.\\n                    keccak256( // compute the CREATE2 hash using 4 inputs.\\n                        abi.encodePacked( // pack all inputs to the hash together.\\n                            hex\\\"ff\\\", // start with 0xff to distinguish from RLP.\\n                            address(this), // this contract will be the caller.\\n                            salt, // pass in the supplied salt value.\\n                            keccak256(abi.encodePacked(initCode)) // pass in the hash of initialization code.\\n                        )\\n                    )\\n                )\\n            )\\n        );\\n\\n        // return null address to signify failure if contract has been deployed.\\n        if (_deployed[deploymentAddress]) {\\n            return address(0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Compute the address of the contract that will be created when\\n     * submitting a given salt or nonce to the contract along with the keccak256\\n     * hash of the contract's initialization code. The CREATE2 address is computed\\n     * in accordance with EIP-1014, and adheres to the formula therein of\\n     * `keccak256( 0xff ++ address ++ salt ++ keccak256(init_code)))[12:]` when\\n     * performing the computation. The computed address is then checked for any\\n     * existing contract code - if so, the null address will be returned instead.\\n     * @param salt bytes32 The nonce passed into the CREATE2 address calculation.\\n     * @param initCodeHash bytes32 The keccak256 hash of the initialization code\\n     * that will be passed into the CREATE2 address calculation.\\n     * @return Address of the contract that will be created, or the null address\\n     * if a contract has already been deployed to that address.\\n     */\\n    function findCreate2AddressViaHash(\\n        bytes32 salt,\\n        bytes32 initCodeHash\\n    ) external view returns (address deploymentAddress) {\\n        // determine the address where the contract will be deployed.\\n        deploymentAddress = address(\\n            uint160( // downcast to match the address type.\\n                uint256( // convert to uint to truncate upper digits.\\n                    keccak256( // compute the CREATE2 hash using 4 inputs.\\n                        abi.encodePacked( // pack all inputs to the hash together.\\n                            hex\\\"ff\\\", // start with 0xff to distinguish from RLP.\\n                            address(this), // this contract will be the caller.\\n                            salt, // pass in the supplied salt value.\\n                            initCodeHash // pass in the hash of initialization code.\\n                        )\\n                    )\\n                )\\n            )\\n        );\\n\\n        // return null address to signify failure if contract has been deployed.\\n        if (_deployed[deploymentAddress]) {\\n            return address(0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Determine if a contract has already been deployed by the factory to a\\n     * given address.\\n     * @param deploymentAddress address The contract address to check.\\n     * @return True if the contract has been deployed, false otherwise.\\n     */\\n    function hasBeenDeployed(address deploymentAddress) external view returns (bool) {\\n        // determine if a contract has been deployed to the provided address.\\n        return _deployed[deploymentAddress];\\n    }\\n\\n    /**\\n     * @dev Modifier to ensure that the first 20 bytes of a submitted salt match\\n     * those of the calling account. This provides protection against the salt\\n     * being stolen by frontrunners or other attackers. The protection can also be\\n     * bypassed if desired by setting each of the first 20 bytes to zero.\\n     * @param salt bytes32 The salt value to check against the calling address.\\n     */\\n    modifier containsCaller(bytes32 salt) {\\n        // prevent contract submissions from being stolen from tx.pool by requiring\\n        // that the first 20 bytes of the submitted salt match msg.sender.\\n        require(\\n            (address(bytes20(salt)) == msg.sender) || (bytes20(salt) == bytes20(0)),\\n            \\\"Invalid salt - first 20 bytes of the salt must match calling address.\\\"\\n        );\\n        _;\\n    }\\n\\n    function safeCreate2AndTransfer(\\n        bytes32 salt,\\n        bytes calldata initializationCode\\n    ) external payable containsCaller(salt) returns (address deploymentAddress) {\\n        deploymentAddress = safeCreate2Internal(salt, initializationCode);\\n        Ownable(deploymentAddress).transferOwnership(msg.sender);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"constant\":true,\"inputs\":[{\"name\":\"deploymentAddress\",\"type\":\"address\"}],\"name\":\"hasBeenDeployed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"salt\",\"type\":\"bytes32\"},{\"name\":\"initializationCode\",\"type\":\"bytes\"}],\"name\":\"safeCreate2AndTransfer\",\"outputs\":[{\"name\":\"deploymentAddress\",\"type\":\"address\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"salt\",\"type\":\"bytes32\"},{\"name\":\"initializationCode\",\"type\":\"bytes\"}],\"name\":\"safeCreate2\",\"outputs\":[{\"name\":\"deploymentAddress\",\"type\":\"address\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"salt\",\"type\":\"bytes32\"},{\"name\":\"initCode\",\"type\":\"bytes\"}],\"name\":\"findCreate2Address\",\"outputs\":[{\"name\":\"deploymentAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"salt\",\"type\":\"bytes32\"},{\"name\":\"initCodeHash\",\"type\":\"bytes32\"}],\"name\":\"findCreate2AddressViaHash\",\"outputs\":[{\"name\":\"deploymentAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "ImmutableCreate2Factory", "CompilerVersion": "v0.5.10+commit.5a6ea5b1", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}