{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/adapters/unsheth/UnshETHAdapter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.13;\\n\\nimport { IERC20 } from \\\"openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\\\";\\n\\nimport { IllegalArgument, Unauthorized, UnsupportedOperation } from \\\"../../base/ErrorMessages.sol\\\";\\nimport { MutexLock } from \\\"../../base/MutexLock.sol\\\";\\n\\nimport { SafeERC20 } from \\\"../../libraries/SafeERC20.sol\\\";\\n\\nimport { ITokenAdapter } from \\\"../../interfaces/ITokenAdapter.sol\\\";\\nimport { IWETH9 } from \\\"../../interfaces/external/IWETH9.sol\\\";\\nimport { IStableSwap2Pool } from \\\"../../interfaces/external/curve/IStableSwap2Pool.sol\\\";\\nimport { IunshETHZap } from \\\"./../../interfaces/external/unsheth/IunshETHZap.sol\\\";\\nimport { ILSDVault } from \\\"./../../interfaces/external/unsheth/ILSDVault.sol\\\";\\nimport { IWstETH } from \\\"../../interfaces/external/lido/IWstETH.sol\\\";\\nimport { IStakedFraxEth } from \\\"../../interfaces/external/frax/IStakedFraxEth.sol\\\";\\nimport { IRETH } from \\\"../../interfaces/external/rocketpool/IRETH.sol\\\";\\nimport { ISwapRouter } from \\\"../../interfaces/external/uniswap/ISwapRouter.sol\\\";\\nimport { ISwapRouter as IMaverickSwapRouter } from \\\"../../interfaces/external/maverick/ISwapRouter.sol\\\";\\nimport { IPool as IMaverickPool } from \\\"../../interfaces/external/maverick/IPool.sol\\\";\\n\\nstruct InitializationParams {\\n    address zeroliquid;\\n    address token;\\n    address underlyingToken;\\n    address lsdVault;\\n    address unshEthZap;\\n    // stETH\\n    address stETHCurvePool;\\n    uint256 ethIndexStETHCurvePool;\\n    uint256 stETHIndexCurvePool;\\n    // frxETH\\n    address frxETHCurvePool;\\n    uint256 ethIndexFrxETHCurvePool;\\n    uint256 frxETHIndexCurvePool;\\n    // ankrETH\\n    address ankrETHCurvePool;\\n    uint256 ethIndexAnkrETHCurvePool;\\n    uint256 ankrETHIndexCurvePool;\\n    // swETH\\n    address swETHMaverickPool;\\n    address maverickRouter;\\n}\\n\\ncontract UnshETHAdapter is ITokenAdapter, MutexLock {\\n    string public override version = \\\"1.0.0\\\";\\n\\n    address constant uniswapRouterV3 = 0xE592427A0AEce92De3Edee1F18E0157C05861564;\\n    address public constant stETH = 0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84;\\n    address public constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;\\n    address public constant rETH = 0xae78736Cd615f374D3085123A210448E74Fc6393;\\n    address public constant frxETH = 0x5E8422345238F34275888049021821E8E08CAa1f;\\n    address public constant sfrxETH = 0xac3E018457B222d93114458476f3E3416Abbe38F;\\n    address public constant cbETH = 0xBe9895146f7AF43049ca1c1AE358B0541Ea49704;\\n    address public constant ankrETH = 0xE95A203B1a91a908F9B9CE46459d101078c2c3cb;\\n    address public constant swETH = 0xf951E335afb289353dc249e82926178EaC7DEd78;\\n\\n    address public immutable override token;\\n    address public immutable override underlyingToken;\\n    address public immutable zeroliquid;\\n    address public immutable lsdVault;\\n    address public immutable unshEthZap;\\n    address public immutable stETHCurvePool;\\n    uint256 public immutable ethIndexStETHCurvePool;\\n    uint256 public immutable stETHIndexCurvePool;\\n\\n    address public immutable frxETHCurvePool;\\n    uint256 public immutable ethIndexFrxETHCurvePool;\\n    uint256 public immutable frxETHIndexCurvePool;\\n\\n    address public immutable ankrETHCurvePool;\\n    uint256 public immutable ethIndexAnkrETHCurvePool;\\n    uint256 public immutable ankrETHIndexCurvePool;\\n\\n    address public immutable swETHMaverickPool;\\n    address public immutable maverickRouter;\\n\\n    constructor(InitializationParams memory params) {\\n        zeroliquid = params.zeroliquid;\\n        token = params.token;\\n        underlyingToken = params.underlyingToken;\\n        lsdVault = params.lsdVault;\\n        unshEthZap = params.unshEthZap;\\n\\n        stETHCurvePool = params.stETHCurvePool;\\n        ethIndexStETHCurvePool = params.ethIndexStETHCurvePool;\\n        stETHIndexCurvePool = params.stETHIndexCurvePool;\\n        // Verify and make sure that the provided ETH matches the curve pool ETH.\\n        if (\\n            IStableSwap2Pool(params.stETHCurvePool).coins(params.ethIndexStETHCurvePool)\\n                != 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\\n        ) {\\n            revert IllegalArgument(\\\"Curve pool ETH token mismatch\\\");\\n        }\\n        // Verify and make sure that the provided stETH matches the curve pool stETH.\\n        if (IStableSwap2Pool(params.stETHCurvePool).coins(params.stETHIndexCurvePool) != stETH) {\\n            revert IllegalArgument(\\\"Curve pool stETH token mismatch\\\");\\n        }\\n\\n        frxETHCurvePool = params.frxETHCurvePool;\\n        ethIndexFrxETHCurvePool = params.ethIndexFrxETHCurvePool;\\n        frxETHIndexCurvePool = params.frxETHIndexCurvePool;\\n        // Verify and make sure that the provided ETH matches the curve pool ETH.\\n        if (\\n            IStableSwap2Pool(params.frxETHCurvePool).coins(params.ethIndexFrxETHCurvePool)\\n                != 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\\n        ) {\\n            revert IllegalArgument(\\\"Curve pool ETH token mismatch\\\");\\n        }\\n        // Verify and make sure that the provided frxETH matches the curve pool frxETH.\\n        if (IStableSwap2Pool(params.frxETHCurvePool).coins(params.frxETHIndexCurvePool) != frxETH) {\\n            revert IllegalArgument(\\\"Curve pool frxETH token mismatch\\\");\\n        }\\n\\n        ankrETHCurvePool = params.ankrETHCurvePool;\\n        ethIndexAnkrETHCurvePool = params.ethIndexAnkrETHCurvePool;\\n        ankrETHIndexCurvePool = params.ankrETHIndexCurvePool;\\n        // Verify and make sure that the provided ETH matches the curve pool ETH.\\n        if (\\n            IStableSwap2Pool(params.ankrETHCurvePool).coins(params.ethIndexAnkrETHCurvePool)\\n                != 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\\n        ) {\\n            revert IllegalArgument(\\\"Curve pool ETH token mismatch\\\");\\n        }\\n        // Verify and make sure that the provided ankrETH matches the curve pool ankrETH.\\n        if (IStableSwap2Pool(params.ankrETHCurvePool).coins(params.ankrETHIndexCurvePool) != ankrETH) {\\n            revert IllegalArgument(\\\"Curve pool ankrETH token mismatch\\\");\\n        }\\n\\n        swETHMaverickPool = params.swETHMaverickPool;\\n        maverickRouter = params.maverickRouter;\\n    }\\n\\n    /// @dev Checks that the message sender is the zeroliquid that the adapter is bound to.\\n    modifier onlyZeroLiquid() {\\n        if (msg.sender != zeroliquid) {\\n            revert Unauthorized(\\\"Not zeroliquid\\\");\\n        }\\n        _;\\n    }\\n\\n    receive() external payable {\\n        if (\\n            msg.sender != underlyingToken && msg.sender != rETH && msg.sender != stETHCurvePool\\n                && msg.sender != frxETHCurvePool && msg.sender != ankrETHCurvePool\\n        ) {\\n            revert Unauthorized(\\\"Payments only permitted from WETH, rETH or Curve Pools\\\");\\n        }\\n    }\\n\\n    /// @inheritdoc ITokenAdapter\\n    function price() external view returns (uint256) {\\n        return ILSDVault(lsdVault).stakedETHperunshETH();\\n    }\\n\\n    /// @inheritdoc ITokenAdapter\\n    function wrap(uint256 amount, address recipient) external lock onlyZeroLiquid returns (uint256) {\\n        amount;\\n        recipient; // Silence, compiler!\\n\\n        revert UnsupportedOperation(\\\"Wrapping is not supported\\\");\\n    }\\n\\n    // @inheritdoc ITokenAdapter\\n    function unwrap(uint256 amount, address recipient) external lock onlyZeroLiquid returns (uint256) {\\n        // Transfer the tokens from the message sender.\\n        SafeERC20.safeTransferFrom(token, msg.sender, address(this), amount);\\n\\n        uint256 startingWETHBalance = IERC20(underlyingToken).balanceOf(address(this));\\n        uint256 startingWstETHBalance = IERC20(wstETH).balanceOf(address(this));\\n        uint256 startingRETHBalance = IERC20(rETH).balanceOf(address(this));\\n        uint256 startingSfrxETHBalance = IERC20(sfrxETH).balanceOf(address(this));\\n        uint256 startingCbETHBalance = IERC20(cbETH).balanceOf(address(this));\\n        uint256 startingAnkrETHBalance = IERC20(ankrETH).balanceOf(address(this));\\n        uint256 startingSwETHBalance = IERC20(swETH).balanceOf(address(this));\\n\\n        SafeERC20.safeApprove(token, lsdVault, amount);\\n        ILSDVault(lsdVault).exit(amount);\\n\\n        uint256 wethBalance = 0;\\n\\n        uint256 receivedWETH = IERC20(underlyingToken).balanceOf(address(this)) - startingWETHBalance;\\n        wethBalance += receivedWETH;\\n        wethBalance += _convertWstETHToUnderlying(startingWstETHBalance);\\n        wethBalance += _convertRETHToUnderlying(startingRETHBalance);\\n        wethBalance += _convertSfrxETHToUnderlying(startingSfrxETHBalance);\\n        wethBalance += _convertCbETHToUnderlying(startingCbETHBalance);\\n        wethBalance += _convertAnkrETHToUnderlying(startingAnkrETHBalance);\\n        wethBalance += _convertSwETHToUnderlying(startingSwETHBalance);\\n\\n        // Transfer the tokens to the recipient.\\n        SafeERC20.safeTransfer(underlyingToken, recipient, wethBalance);\\n\\n        return wethBalance;\\n    }\\n\\n    function _convertWstETHToUnderlying(uint256 startingWstETHBalance) internal returns (uint256) {\\n        uint256 receivedWstETH = IERC20(wstETH).balanceOf(address(this)) - startingWstETHBalance;\\n\\n        if (receivedWstETH > 0) {\\n            uint256 startingStETHBalance = IERC20(stETH).balanceOf(address(this));\\n            IWstETH(wstETH).unwrap(receivedWstETH);\\n            uint256 receivedStETH = IERC20(stETH).balanceOf(address(this)) - startingStETHBalance;\\n\\n            SafeERC20.safeApprove(stETH, stETHCurvePool, receivedStETH);\\n\\n            uint256 receivedETHFromStETH = IStableSwap2Pool(stETHCurvePool).exchange(\\n                int128(uint128(stETHIndexCurvePool)), // stETH Pool index\\n                int128(uint128(ethIndexStETHCurvePool)), // ETH pool index\\n                receivedStETH,\\n                0 // <- Slippage is handled upstream\\n            );\\n\\n            IWETH9(underlyingToken).deposit{ value: receivedETHFromStETH }();\\n\\n            return receivedETHFromStETH;\\n        } else {\\n            return 0;\\n        }\\n    }\\n\\n    function _convertRETHToUnderlying(uint256 startingRETHBalance) internal returns (uint256) {\\n        uint256 receivedRETH = IERC20(rETH).balanceOf(address(this)) - startingRETHBalance;\\n\\n        if (receivedRETH > 0) {\\n            uint256 receivedETHFromRETH = 0;\\n            uint256 ethUnderlyingRETH = IRETH(rETH).getEthValue(receivedRETH);\\n\\n            if (IRETH(rETH).getTotalCollateral() >= ethUnderlyingRETH) {\\n                // Burn the rETH to receive ETH.\\n                uint256 startingETHBalance = address(this).balance;\\n                IRETH(rETH).burn(receivedRETH);\\n                receivedETHFromRETH = address(this).balance - startingETHBalance;\\n\\n                // Wrap the ETH that we received from the burn.\\n                IWETH9(underlyingToken).deposit{ value: receivedETHFromRETH }();\\n            } else {\\n                SafeERC20.safeApprove(rETH, uniswapRouterV3, receivedRETH);\\n\\n                ISwapRouter.ExactInputSingleParams memory params = ISwapRouter.ExactInputSingleParams({\\n                    tokenIn: rETH,\\n                    tokenOut: underlyingToken,\\n                    fee: 3000,\\n                    recipient: address(this),\\n                    deadline: block.timestamp,\\n                    amountIn: receivedRETH,\\n                    amountOutMinimum: 0,\\n                    sqrtPriceLimitX96: 0\\n                });\\n\\n                receivedETHFromRETH = ISwapRouter(uniswapRouterV3).exactInputSingle(params);\\n            }\\n\\n            return receivedETHFromRETH;\\n        } else {\\n            return 0;\\n        }\\n    }\\n\\n    function _convertSfrxETHToUnderlying(uint256 startingSfrxETHBalance) internal returns (uint256) {\\n        uint256 receivedSfrxETH = IERC20(sfrxETH).balanceOf(address(this)) - startingSfrxETHBalance;\\n\\n        if (receivedSfrxETH > 0) {\\n            uint256 startingFraxETHBalance = IERC20(frxETH).balanceOf(address(this));\\n            IStakedFraxEth(sfrxETH).withdraw(\\n                receivedSfrxETH * IStakedFraxEth(sfrxETH).convertToAssets(1e18)\\n                    / 10 ** SafeERC20.expectDecimals(sfrxETH),\\n                address(this),\\n                address(this)\\n            );\\n            uint256 receivedFraxETH = IERC20(frxETH).balanceOf(address(this)) - startingFraxETHBalance;\\n\\n            SafeERC20.safeApprove(frxETH, frxETHCurvePool, receivedFraxETH);\\n\\n            uint256 receivedETHFromFrxETH = IStableSwap2Pool(frxETHCurvePool).exchange(\\n                int128(uint128(frxETHIndexCurvePool)), // frxETH Pool index\\n                int128(uint128(ethIndexFrxETHCurvePool)), // ETH pool index\\n                receivedFraxETH,\\n                0 // <- Slippage is handled upstream\\n            );\\n\\n            IWETH9(underlyingToken).deposit{ value: receivedETHFromFrxETH }();\\n\\n            return receivedETHFromFrxETH;\\n        } else {\\n            return 0;\\n        }\\n    }\\n\\n    function _convertCbETHToUnderlying(uint256 startingCbETHBalance) internal returns (uint256) {\\n        uint256 receivedCbETH = IERC20(cbETH).balanceOf(address(this)) - startingCbETHBalance;\\n\\n        if (receivedCbETH > 0) {\\n            SafeERC20.safeApprove(cbETH, uniswapRouterV3, receivedCbETH);\\n\\n            ISwapRouter.ExactInputSingleParams memory params = ISwapRouter.ExactInputSingleParams({\\n                tokenIn: cbETH,\\n                tokenOut: underlyingToken,\\n                fee: 500,\\n                recipient: address(this),\\n                deadline: block.timestamp,\\n                amountIn: receivedCbETH,\\n                amountOutMinimum: 0,\\n                sqrtPriceLimitX96: 0\\n            });\\n\\n            uint256 receivedETHFromCbETH = ISwapRouter(uniswapRouterV3).exactInputSingle(params);\\n\\n            return receivedETHFromCbETH;\\n        } else {\\n            return 0;\\n        }\\n    }\\n\\n    function _convertAnkrETHToUnderlying(uint256 startingAnkrETHBalance) internal returns (uint256) {\\n        uint256 receivedAnkrETH = IERC20(ankrETH).balanceOf(address(this)) - startingAnkrETHBalance;\\n\\n        if (receivedAnkrETH > 0) {\\n            SafeERC20.safeApprove(ankrETH, ankrETHCurvePool, receivedAnkrETH);\\n\\n            uint256 receivedETHFromAnkrETH = IStableSwap2Pool(ankrETHCurvePool).exchange(\\n                int128(uint128(ankrETHIndexCurvePool)), // ankrETH Pool index\\n                int128(uint128(ethIndexAnkrETHCurvePool)), // ETH pool index\\n                receivedAnkrETH,\\n                0 // <- Slippage is handled upstream\\n            );\\n\\n            IWETH9(underlyingToken).deposit{ value: receivedETHFromAnkrETH }();\\n\\n            return receivedETHFromAnkrETH;\\n        } else {\\n            return 0;\\n        }\\n    }\\n\\n    function _convertSwETHToUnderlying(uint256 startingSwETHBalance) internal returns (uint256) {\\n        uint256 receivedSwETH = IERC20(swETH).balanceOf(address(this)) - startingSwETHBalance;\\n\\n        if (receivedSwETH > 0) {\\n            SafeERC20.safeApprove(swETH, maverickRouter, receivedSwETH);\\n\\n            IMaverickSwapRouter.ExactInputSingleParams memory params = IMaverickSwapRouter.ExactInputSingleParams({\\n                tokenIn: swETH,\\n                tokenOut: underlyingToken,\\n                pool: IMaverickPool(swETHMaverickPool),\\n                recipient: address(this),\\n                deadline: block.timestamp,\\n                amountIn: receivedSwETH,\\n                amountOutMinimum: 0,\\n                sqrtPriceLimitD18: 0\\n            });\\n\\n            uint256 receivedWETHFromSwETH = IMaverickSwapRouter(maverickRouter).exactInputSingle(params);\\n\\n            return receivedWETHFromSwETH;\\n        } else {\\n            return 0;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"src/base/ErrorMessages.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity >=0.8.4;\\n\\n/// @notice An error used to indicate that an argument passed to a function is illegal or\\n///         inappropriate.\\n///\\n/// @param message The error message.\\nerror IllegalArgument(string message);\\n\\n/// @notice An error used to indicate that a function has encountered an unrecoverable state.\\n///\\n/// @param message The error message.\\nerror IllegalState(string message);\\n\\n/// @notice An error used to indicate that an operation is unsupported.\\n///\\n/// @param message The error message.\\nerror UnsupportedOperation(string message);\\n\\n/// @notice An error used to indicate that a message sender tried to execute a privileged function.\\n///\\n/// @param message The error message.\\nerror Unauthorized(string message);\\n\"\r\n    },\r\n    \"src/base/MutexLock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.13;\\n\\nimport { IllegalState } from \\\"./ErrorMessages.sol\\\";\\n\\n/// @title  Mutex\\n/// @author ZeroLiquid\\n///\\n/// @notice Provides a mutual exclusion lock for implementing contracts.\\nabstract contract MutexLock {\\n    enum State {\\n        RESERVED,\\n        UNLOCKED,\\n        LOCKED\\n    }\\n\\n    /// @notice The lock state.\\n    State private _lockState = State.UNLOCKED;\\n\\n    /// @dev A modifier which acquires the mutex.\\n    modifier lock() {\\n        _claimLock();\\n\\n        _;\\n\\n        _freeLock();\\n    }\\n\\n    /// @dev Gets if the mutex is locked.\\n    ///\\n    /// @return if the mutex is locked.\\n    function _isLocked() internal view returns (bool) {\\n        return _lockState == State.LOCKED;\\n    }\\n\\n    /// @dev Claims the lock. If the lock is already claimed, then this will revert.\\n    function _claimLock() internal {\\n        // Check that the lock has not been claimed yet.\\n        if (_lockState != State.UNLOCKED) {\\n            revert IllegalState(\\\"Lock already claimed\\\");\\n        }\\n\\n        // Claim the lock.\\n        _lockState = State.LOCKED;\\n    }\\n\\n    /// @dev Frees the lock.\\n    function _freeLock() internal {\\n        _lockState = State.UNLOCKED;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libraries/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.4;\\n\\nimport { IERC20 } from \\\"../../lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\\\";\\n\\nimport { IllegalState } from \\\"../base/ErrorMessages.sol\\\";\\n\\nimport { IERC20Metadata } from \\\"../interfaces/IERC20Metadata.sol\\\";\\n\\n/// @title  SafeERC20\\n/// @author ZeroLiquid\\nlibrary SafeERC20 {\\n    /// @notice An error used to indicate that a call to an ERC20 contract failed.\\n    ///\\n    /// @param target  The target address.\\n    /// @param success If the call to the token was a success.\\n    /// @param data    The resulting data from the call. This is error data when the call was not a\\n    ///                success. Otherwise, this is malformed data when the call was a success.\\n    error ERC20CallFailed(address target, bool success, bytes data);\\n\\n    /// @dev A safe function to get the decimals of an ERC20 token.\\n    ///\\n    /// @dev Reverts with a {CallFailed} error if execution of the query fails or returns an\\n    ///      unexpected value.\\n    ///\\n    /// @param token The target token.\\n    ///\\n    /// @return The amount of decimals of the token.\\n    function expectDecimals(address token) internal view returns (uint8) {\\n        (bool success, bytes memory data) = token.staticcall(abi.encodeWithSelector(IERC20Metadata.decimals.selector));\\n\\n        if (!success || data.length < 32) {\\n            revert ERC20CallFailed(token, success, data);\\n        }\\n\\n        return abi.decode(data, (uint8));\\n    }\\n\\n    /// @dev Transfers tokens to another address.\\n    ///\\n    /// @dev Reverts with a {CallFailed} error if execution of the transfer failed or returns an\\n    ///      unexpected value.\\n    ///\\n    /// @param token     The token to transfer.\\n    /// @param recipient The address of the recipient.\\n    /// @param amount    The amount of tokens to transfer.\\n    function safeTransfer(address token, address recipient, uint256 amount) internal {\\n        (bool success, bytes memory data) =\\n            token.call(abi.encodeWithSelector(IERC20.transfer.selector, recipient, amount));\\n\\n        if (!success || (data.length != 0 && !abi.decode(data, (bool)))) {\\n            revert ERC20CallFailed(token, success, data);\\n        }\\n    }\\n\\n    /// @dev Approves tokens for the smart contract.\\n    ///\\n    /// @dev Reverts with a {CallFailed} error if execution of the approval fails or returns an\\n    ///      unexpected value.\\n    ///\\n    /// @param token   The token to approve.\\n    /// @param spender The contract to spend the tokens.\\n    /// @param value   The amount of tokens to approve.\\n    function safeApprove(address token, address spender, uint256 value) internal {\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.approve.selector, spender, value));\\n\\n        if (!success || (data.length != 0 && !abi.decode(data, (bool)))) {\\n            revert ERC20CallFailed(token, success, data);\\n        }\\n    }\\n\\n    /// @dev Transfer tokens from one address to another address.\\n    ///\\n    /// @dev Reverts with a {CallFailed} error if execution of the transfer fails or returns an\\n    ///      unexpected value.\\n    ///\\n    /// @param token     The token to transfer.\\n    /// @param owner     The address of the owner.\\n    /// @param recipient The address of the recipient.\\n    /// @param amount    The amount of tokens to transfer.\\n    function safeTransferFrom(address token, address owner, address recipient, uint256 amount) internal {\\n        (bool success, bytes memory data) =\\n            token.call(abi.encodeWithSelector(IERC20.transferFrom.selector, owner, recipient, amount));\\n\\n        if (!success || (data.length != 0 && !abi.decode(data, (bool)))) {\\n            revert ERC20CallFailed(token, success, data);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ITokenAdapter.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\n/// @title  ITokenAdapter\\n/// @author ZeroLiquid\\ninterface ITokenAdapter {\\n    /// @notice Gets the current version.\\n    ///\\n    /// @return The version.\\n    function version() external view returns (string memory);\\n\\n    /// @notice Gets the address of the yield token that this adapter supports.\\n    ///\\n    /// @return The address of the yield token.\\n    function token() external view returns (address);\\n\\n    /// @notice Gets the address of the underlying token that the yield token wraps.\\n    ///\\n    /// @return The address of the underlying token.\\n    function underlyingToken() external view returns (address);\\n\\n    /// @notice Gets the number of underlying tokens that a single whole yield token is redeemable\\n    ///         for.\\n    ///\\n    /// @return The price.\\n    function price() external view returns (uint256);\\n\\n    /// @notice Wraps `amount` underlying tokens into the yield token.\\n    ///\\n    /// @param amount    The amount of the underlying token to wrap.\\n    /// @param recipient The address which will receive the yield tokens.\\n    ///\\n    /// @return amountYieldTokens The amount of yield tokens minted to `recipient`.\\n    function wrap(uint256 amount, address recipient) external returns (uint256 amountYieldTokens);\\n\\n    /// @notice Unwraps `amount` yield tokens into the underlying token.\\n    ///\\n    /// @param amount    The amount of yield-tokens to redeem.\\n    /// @param recipient The recipient of the resulting underlying-tokens.\\n    ///\\n    /// @return amountUnderlyingTokens The amount of underlying tokens unwrapped to `recipient`.\\n    function unwrap(uint256 amount, address recipient) external returns (uint256 amountUnderlyingTokens);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/external/IWETH9.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\nimport \\\"../../../lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\\\";\\n\\nimport \\\"../IERC20Metadata.sol\\\";\\n\\n/// @title IWETH9\\ninterface IWETH9 is IERC20, IERC20Metadata {\\n    /// @notice Deposits `msg.value` ethereum into the contract and mints `msg.value` tokens.\\n    function deposit() external payable;\\n\\n    /// @notice Burns `amount` tokens to retrieve `amount` ethereum from the contract.\\n    ///\\n    /// @dev This version of WETH utilizes the `transfer` function which hard codes the amount of gas\\n    ///      that is allowed to be utilized to be exactly 2300 when receiving ethereum.\\n    ///\\n    /// @param amount The amount of tokens to burn.\\n    function withdraw(uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/external/curve/IStableSwap2Pool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity >=0.5.0;\\n\\nuint256 constant N_COINS = 2;\\n\\ninterface IStableSwap2Pool {\\n    function coins(uint256 index) external view returns (address);\\n\\n    function A() external view returns (uint256);\\n\\n    function get_virtual_price() external view returns (uint256);\\n\\n    function calc_token_amount(\\n        uint256[N_COINS] calldata amounts,\\n        bool deposit\\n    )\\n        external\\n        view\\n        returns (uint256 amount);\\n\\n    function add_liquidity(uint256[N_COINS] calldata amounts, uint256 minimumMintAmount) external;\\n\\n    function get_dy(int128 i, int128 j, uint256 dx) external view returns (uint256 dy);\\n\\n    function get_dy_underlying(int128 i, int128 j, uint256 dx) external view returns (uint256 dy);\\n\\n    function exchange(int128 i, int128 j, uint256 dx, uint256 minimumDy) external payable returns (uint256);\\n\\n    function exchange_underlying(\\n        int128 i,\\n        int128 j,\\n        uint256 dx,\\n        uint256 minimumDy\\n    )\\n        external\\n        payable\\n        returns (uint256);\\n\\n    function remove_liquidity(uint256 amount, uint256[N_COINS] calldata minimumAmounts) external;\\n\\n    function remove_liquidity_imbalance(uint256[N_COINS] calldata amounts, uint256 maximumBurnAmount) external;\\n\\n    function calc_withdraw_one_coin(uint256 tokenAmount, int128 i) external view returns (uint256);\\n\\n    function remove_liquidity_one_coin(uint256 tokenAmount, int128 i, uint256 minimumAmount) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/external/unsheth/IunshETHZap.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity >=0.8.0;\\n\\ninterface IunshETHZap {\\n    function mint_unsheth_with_eth(uint256 amountOutMin, uint256 pathId) external payable;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/external/unsheth/ILSDVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity >=0.8.0;\\n\\ninterface ILSDVault {\\n    function stakedETHperunshETH() external view returns (uint256);\\n    function exit(uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/external/lido/IWstETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity >=0.5.0;\\n\\nimport { IERC20 } from \\\"../../../../lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IWstETH is IERC20 {\\n    function getWstETHByStETH(uint256 amount) external view returns (uint256);\\n    function getStETHByWstETH(uint256 amount) external view returns (uint256);\\n    function wrap(uint256 amount) external returns (uint256);\\n    function unwrap(uint256 amount) external returns (uint256);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/external/frax/IStakedFraxEth.sol\": {\r\n      \"content\": \"pragma solidity >= 0.8.13;\\n\\ninterface IStakedFraxEth {\\n    function convertToAssets(uint256 shares) external view returns (uint256);\\n\\n    function convertToShares(uint256 assets) external view returns (uint256);\\n\\n    function pricePerShare() external view returns (uint256);\\n\\n    function deposit(uint256 assets, address receiver) external returns (uint256);\\n\\n    function withdraw(uint256 assets, address receiver, address owner) external returns (uint256);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/external/rocketpool/IRETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity >=0.5.0;\\n\\nimport { IERC20 } from \\\"../../../../lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\\\";\\n\\nimport { IERC20Metadata } from \\\"../../IERC20Metadata.sol\\\";\\n\\ninterface IRETH is IERC20, IERC20Metadata {\\n    function getEthValue(uint256 amount) external view returns (uint256);\\n    function getRethValue(uint256 amount) external view returns (uint256);\\n    function getExchangeRate() external view returns (uint256);\\n    function getTotalCollateral() external view returns (uint256);\\n    function getCollateralRate() external view returns (uint256);\\n    function depositExcess() external payable;\\n    function depositExcessCollateral() external;\\n    function mint(uint256 amount, address receiver) external;\\n    function burn(uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/external/uniswap/ISwapRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\n/// @title  ISwapRouter\\n/// @author Uniswap Labs\\n///\\n/// @notice Functions for swapping tokens via Uniswap V3.\\ninterface ISwapRouter {\\n    struct ExactInputSingleParams {\\n        address tokenIn;\\n        address tokenOut;\\n        uint24 fee;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountIn;\\n        uint256 amountOutMinimum;\\n        uint160 sqrtPriceLimitX96;\\n    }\\n\\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token.\\n    ///\\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata.\\n    ///\\n    /// @return amountOut The amount of the received token\\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\\n\\n    struct ExactInputParams {\\n        bytes path;\\n        address recipient;\\n        uint256 amountIn;\\n        uint256 amountOutMinimum;\\n    }\\n\\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path.\\n    ///\\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata.\\n    ///\\n    /// @return amountOut The amount of the received token\\n    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);\\n\\n    struct ExactOutputSingleParams {\\n        address tokenIn;\\n        address tokenOut;\\n        uint24 fee;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountOut;\\n        uint256 amountInMaximum;\\n        uint160 sqrtPriceLimitX96;\\n    }\\n\\n    /// @notice Swaps as little as possible of one token for `amountOut` of another token.\\n    ///\\n    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata.\\n    ///\\n    /// @return amountIn The amount of the input token.\\n    function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);\\n\\n    struct ExactOutputParams {\\n        bytes path;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountOut;\\n        uint256 amountInMaximum;\\n    }\\n\\n    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed).\\n    ///\\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata.\\n    ///\\n    /// @return amountIn The amount of the input token\\n    function exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);\\n\\n    /// @notice Ensures that the current (synthetic) tick over the path is no worse than\\n    /// `maximumTickDivergence` ticks away from the average as of `secondsAgo`\\n    /// @param path The path to fetch prices over\\n    /// @param maximumTickDivergence The maximum number of ticks that the price can degrade by\\n    /// @param secondsAgo The number of seconds ago to compute oracle prices against\\n    function checkOracleSlippage(bytes memory path, uint24 maximumTickDivergence, uint32 secondsAgo) external view;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/external/maverick/ISwapRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.13;\\n\\nimport \\\"./IPool.sol\\\";\\n\\ninterface ISwapRouter {\\n    struct ExactInputSingleParams {\\n        address tokenIn;\\n        address tokenOut;\\n        IPool pool;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountIn;\\n        uint256 amountOutMinimum;\\n        uint256 sqrtPriceLimitD18;\\n    }\\n\\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/external/maverick/IPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"./IFactory.sol\\\";\\n\\ninterface IPool {\\n    event Swap(\\n        address sender,\\n        address recipient,\\n        bool tokenAIn,\\n        bool exactOutput,\\n        uint256 amountIn,\\n        uint256 amountOut,\\n        int32 activeTick\\n    );\\n    event AddLiquidity(address indexed sender, uint256 indexed tokenId, BinDelta[] binDeltas);\\n    event MigrateBinsUpStack(address indexed sender, uint128 binId, uint32 maxRecursion);\\n    event TransferLiquidity(uint256 fromTokenId, uint256 toTokenId, RemoveLiquidityParams[] params);\\n    event RemoveLiquidity(\\n        address indexed sender, address indexed recipient, uint256 indexed tokenId, BinDelta[] binDeltas\\n    );\\n    event BinMerged(uint128 indexed binId, uint128 reserveA, uint128 reserveB, uint128 mergeId);\\n    event BinMoved(uint128 indexed binId, int128 previousTick, int128 newTick);\\n    event ProtocolFeeCollected(uint256 protocolFee, bool isTokenA);\\n    event SetProtocolFeeRatio(uint256 protocolFee);\\n    /// @notice return parameters for Add/Remove liquidity\\n    /// @param binId of the bin that changed\\n    /// @param kind one of the 4 Kinds (0=static, 1=right, 2=left, 3=both)\\n    /// @param isActive bool to indicate whether the bin is still active\\n    /// @param lowerTick is the lower price tick of the bin in its current state\\n    /// @param deltaA amount of A token that has been added or removed\\n    /// @param deltaB amount of B token that has been added or removed\\n    /// @param deltaLpToken amount of LP balance that has increase (add) or decreased (remove)\\n\\n    struct BinDelta {\\n        uint128 deltaA;\\n        uint128 deltaB;\\n        uint256 deltaLpBalance;\\n        uint128 binId;\\n        uint8 kind;\\n        int32 lowerTick;\\n        bool isActive;\\n    }\\n    /// @notice time weighted average state\\n    /// @param twa the twa at the last update instant\\n    /// @param value the new value that was passed in at the last update\\n    /// @param lastTimestamp timestamp of the last update in seconds\\n    /// @param lookback time in seconds\\n\\n    struct TwaState {\\n        int96 twa;\\n        int96 value;\\n        uint64 lastTimestamp;\\n    }\\n    /// @notice bin state parameters\\n    /// @param kind one of the 4 Kinds (0=static, 1=right, 2=left, 3=both)\\n    /// @param lowerTick is the lower price tick of the bin in its current state\\n    /// @param mergeId binId of the bin that this bin has merged in to\\n    /// @param reserveA amount of A token in bin\\n    /// @param reserveB amount of B token in bin\\n    /// @param totalSupply total amount of LP tokens in this bin\\n    /// @param mergeBinBalance LP token balance that this bin posseses of the merge bin\\n\\n    struct BinState {\\n        uint128 reserveA;\\n        uint128 reserveB;\\n        uint128 mergeBinBalance;\\n        uint128 mergeId;\\n        uint128 totalSupply;\\n        uint8 kind;\\n        int32 lowerTick;\\n    }\\n    /// @notice Parameters for each bin that will get new liquidity\\n    /// @param kind one of the 4 Kinds (0=static, 1=right, 2=left, 3=both)\\n    /// @param pos bin position\\n    /// @param isDelta bool that indicates whether the bin position is relative\\n    //to the current bin or an absolute position\\n    /// @param deltaA amount of A token to add\\n    /// @param deltaB amount of B token to add\\n\\n    struct AddLiquidityParams {\\n        uint8 kind;\\n        int32 pos;\\n        bool isDelta;\\n        uint128 deltaA;\\n        uint128 deltaB;\\n    }\\n    /// @notice Parameters for each bin that will have liquidity removed\\n    /// @param binId index of the bin losing liquidity\\n    /// @param amount LP balance amount to remove\\n\\n    struct RemoveLiquidityParams {\\n        uint128 binId;\\n        uint128 amount;\\n    }\\n    /// @notice State of the pool\\n    /// @param activeTick  current bin position that contains the active bins\\n    /// @param status pool status.  e.g. locked or unlocked; status values\\n    //defined in Pool.sol\\n    /// @param binCounter index of the last bin created\\n    /// @param protocolFeeRatio ratio of the swap fee that is kept for the\\n    //protocol\\n\\n    struct State {\\n        int32 activeTick;\\n        uint8 status;\\n        uint128 binCounter;\\n        uint64 protocolFeeRatio;\\n    }\\n    /// @notice fee for pool in 18 decimal format\\n\\n    function fee() external view returns (uint256);\\n    /// @notice tickSpacing of pool where 1.0001^tickSpacing is the bin width\\n    function tickSpacing() external view returns (uint256);\\n    /// @notice address of token A\\n    function tokenA() external view returns (IERC20);\\n    /// @notice address of token B\\n    function tokenB() external view returns (IERC20);\\n    /// @notice address of Factory\\n    function factory() external view returns (IFactory);\\n    /// @notice bitmap of active bins\\n    function binMap(int32 tick) external view returns (uint256);\\n    /// @notice mapping of tick/kind to binId\\n    function binPositions(int32 tick, uint256 kind) external view returns (uint128);\\n    /// @notice internal accounting of the sum tokenA balance across bins\\n    function binBalanceA() external view returns (uint128);\\n    /// @notice internal accounting of the sum tokenB balance across bins\\n    function binBalanceB() external view returns (uint128);\\n    /// @notice Twa state values\\n    function getTwa() external view returns (TwaState memory);\\n    /// @notice log base binWidth of the time weighted average price\\n    function getCurrentTwa() external view returns (int256);\\n    /// @notice pool state\\n    function getState() external view returns (State memory);\\n    /// @notice Add liquidity to a pool.\\n    /// @param tokenId NFT token ID that will hold the position\\n    /// @param params array of AddLiquidityParams that specify the mode and\\n    //position of the liquidity\\n    /// @param data callback function that addLiquidity will call so that the\\n    //caller can transfer tokens\\n    function addLiquidity(\\n        uint256 tokenId,\\n        AddLiquidityParams[] calldata params,\\n        bytes calldata data\\n    )\\n        external\\n        returns (uint256 tokenAAmount, uint256 tokenBAmount, BinDelta[] memory binDeltas);\\n    /// @notice Transfer liquidity in an array of bins from one nft tokenId\\n    //to another\\n    /// @param fromTokenId NFT token ID that holds the position being transferred\\n    /// @param toTokenId NFT token ID that is receiving liquidity\\n    /// @param params array of binIds and amounts to transfer\\n    function transferLiquidity(\\n        uint256 fromTokenId,\\n        uint256 toTokenId,\\n        RemoveLiquidityParams[] calldata params\\n    )\\n        external;\\n    /// @notice Remove liquidity from a pool.\\n    /// @param recipient address that will receive the removed tokens\\n    /// @param tokenId NFT token ID that holds the position being removed\\n    /// @param params array of RemoveLiquidityParams that specify the bins,\\n    //and amounts\\n    function removeLiquidity(\\n        address recipient,\\n        uint256 tokenId,\\n        RemoveLiquidityParams[] calldata params\\n    )\\n        external\\n        returns (uint256 tokenAOut, uint256 tokenBOut, BinDelta[] memory binDeltas);\\n    /// @notice Migrate bins up the linked list of merged bins so that its\\n    //mergeId is the currrent active bin.\\n    /// @param binId is an array of the binIds to be migrated\\n    /// @param maxRecursion is the maximum recursion depth of the migration. set to\\n    //zero to recurse until the active bin is found.\\n    function migrateBinUpStack(uint128 binId, uint32 maxRecursion) external;\\n    /// @notice swap tokens\\n    /// @param recipient address that will receive the output tokens\\n    /// @param amount amount of token that is either the input if exactOutput\\n    //is false or the output if exactOutput is true\\n    /// @param tokenAIn bool indicating whether tokenA is the input\\n    /// @param exactOutput bool indicating whether the amount specified is the\\n    //exact output amount (true)\\n    /// @param sqrtPriceLimit limiting sqrt price of the swap.  A value of 0\\n    //indicates no limit.  Limit is only engaged for exactOutput=false.  If the\\n    //limit is reached only part of the input amount will be swapped and the\\n    //callback will only require that amount of the swap to be paid.\\n    /// @param data callback function that swap will call so that the\\n    //caller can transfer tokens\\n    function swap(\\n        address recipient,\\n        uint256 amount,\\n        bool tokenAIn,\\n        bool exactOutput,\\n        uint256 sqrtPriceLimit,\\n        bytes calldata data\\n    )\\n        external\\n        returns (uint256 amountIn, uint256 amountOut);\\n    /// @notice bin information for a given binId\\n    function getBin(uint128 binId) external view returns (BinState memory bin);\\n    /// @notice LP token balance for a given tokenId at a given binId\\n    function balanceOf(uint256 tokenId, uint128 binId) external view returns (uint256 lpToken);\\n    /// @notice tokenA scale value\\n    /// @dev msb is a flag to indicate whether tokenA has more or less than 18\\n    //decimals.  Scale is used in conjuction with Math.toScale/Math.fromScale\\n    //functions to convert from token amounts to D18 scale internal pool\\n    //accounting.\\n    function tokenAScale() external view returns (uint256);\\n    /// @notice tokenB scale value\\n    /// @dev msb is a flag to indicate whether tokenA has more or less than 18\\n    //decimals.  Scale is used in conjuction with Math.toScale/Math.fromScale\\n    //functions to convert from token amounts to D18 scale internal pool\\n    //accounting.\\n    function tokenBScale() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IERC20Metadata.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\n/// @title  IERC20Metadata\\n/// @author ZeroLiquid\\ninterface IERC20Metadata {\\n    /// @notice Gets the name of the token.\\n    ///\\n    /// @return The name.\\n    function name() external view returns (string memory);\\n\\n    /// @notice Gets the symbol of the token.\\n    ///\\n    /// @return The symbol.\\n    function symbol() external view returns (string memory);\\n\\n    /// @notice Gets the number of decimals that the token has.\\n    ///\\n    /// @return The number of decimals.\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/external/maverick/IFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"./IPool.sol\\\";\\nimport \\\"./IPosition.sol\\\";\\n\\ninterface IFactory {\\n    event PoolCreated(\\n        address poolAddress,\\n        uint256 fee,\\n        uint256 tickSpacing,\\n        int32 activeTick,\\n        int256 lookback,\\n        uint64 protocolFeeRatio,\\n        IERC20 tokenA,\\n        IERC20 tokenB\\n    );\\n    event SetFactoryProtocolFeeRatio(uint64 protocolFeeRatio);\\n    event SetFactoryOwner(address owner);\\n    /// @notice creates new pool\\n    /// @param _fee is a rate in prbmath 60x18 decimal format\\n    /// @param _tickSpacing  1.0001^tickSpacing is the bin width\\n    /// @param _activeTick initial activeTick of the pool\\n    /// @param _lookback TWAP lookback in whole seconds\\n    /// @param _tokenA ERC20 token\\n    /// @param _tokenB ERC20 token\\n\\n    function create(\\n        uint256 _fee,\\n        uint256 _tickSpacing,\\n        int256 _lookback,\\n        int32 _activeTick,\\n        IERC20 _tokenA,\\n        IERC20 _tokenB\\n    )\\n        external\\n        returns (IPool);\\n    function lookup(\\n        uint256 fee,\\n        uint256 tickSpacing,\\n        int256 lookback,\\n        IERC20 tokenA,\\n        IERC20 tokenB\\n    )\\n        external\\n        view\\n        returns (IPool);\\n    function owner() external view returns (address);\\n    function position() external view returns (IPosition);\\n    /// @notice protocolFeeRatio ratio of the swap fee that is kept for the\\n    //protocol\\n    function protocolFeeRatio() external view returns (uint64);\\n    /// @notice lookup table for whether a pool is owned by the factory\\n    function isFactoryPool(IPool pool) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/external/maverick/IPosition.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"openzeppelin-contracts/contracts/token/ERC721/extensions/IERC721Enumerable.sol\\\";\\nimport \\\"./IPositionMetadata.sol\\\";\\n\\ninterface IPosition is IERC721Enumerable {\\n    event SetMetadata(IPositionMetadata metadata);\\n    /// @notice mint new position NFT\\n\\n    function mint(address to) external returns (uint256 tokenId);\\n    /// @notice mint new position NFT\\n    function tokenOfOwnerByIndexExists(address owner, uint256 index) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC721/extensions/IERC721Enumerable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Enumerable is IERC721 {\\n    /**\\n     * @dev Returns the total amount of tokens stored by the contract.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\\n     */\\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\\n     * Use along with {totalSupply} to enumerate all tokens.\\n     */\\n    function tokenByIndex(uint256 index) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/external/maverick/IPositionMetadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IPositionMetadata {\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@prb/test/=lib/prb-test/src/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts-upgradeable/lib/erc4626-tests/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"openzeppelin/=lib/openzeppelin-contracts-upgradeable/contracts/\",\r\n      \"prb-test/=lib/prb-test/src/\",\r\n      \"src/=src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\",\r\n      \"appendCBOR\": false\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"zeroliquid\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"underlyingToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"lsdVault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"unshEthZap\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"stETHCurvePool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"ethIndexStETHCurvePool\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stETHIndexCurvePool\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"frxETHCurvePool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"ethIndexFrxETHCurvePool\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"frxETHIndexCurvePool\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"ankrETHCurvePool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"ethIndexAnkrETHCurvePool\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ankrETHIndexCurvePool\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"swETHMaverickPool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"maverickRouter\",\"type\":\"address\"}],\"internalType\":\"struct InitializationParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ERC20CallFailed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"}],\"name\":\"IllegalArgument\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"}],\"name\":\"IllegalState\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"}],\"name\":\"Unauthorized\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"}],\"name\":\"UnsupportedOperation\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ankrETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ankrETHCurvePool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ankrETHIndexCurvePool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cbETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ethIndexAnkrETHCurvePool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ethIndexFrxETHCurvePool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ethIndexStETHCurvePool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"frxETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"frxETHCurvePool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"frxETHIndexCurvePool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lsdVault\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maverickRouter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"price\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sfrxETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stETHCurvePool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stETHIndexCurvePool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swETHMaverickPool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"underlyingToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unshEthZap\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"unwrap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"wrap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wstETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"zeroliquid\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "UnshETHAdapter", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000000246e28c6b161764492e54cbf852e28a4da2d6720000000000000000000000000ae38f7e10a43b5b2fb064b42a2f4514cba909ef000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc200000000000000000000000051a80238b5738725128d3a3e06ab41c1d4c05c74000000000000000000000000c258ff338322b6852c281936d4edeff8adff23ee000000000000000000000000dc24316b9ae028f1497c275eb9192a3ea0f6702200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000a1f8a6807c402e4a15ef4eba36528a3fed24e57700000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000a96a65c051bf88b4095ee1f2451c2a9d43f53ae2000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000ce176e1b11a8f88a4ba2535de80e81f88592bad000000000000000000000000bbf1ee38152e9d8e3470dc47947eaa65dca94913", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}