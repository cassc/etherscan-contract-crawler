{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"lib/openzeppelin-contracts/contracts/interfaces/IERC1271.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC1271.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC1271 standard signature validation method for\\n * contracts as defined in https://eips.ethereum.org/EIPS/eip-1271[ERC-1271].\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC1271 {\\n    /**\\n     * @dev Should return whether the signature provided is valid for the provided data\\n     * @param hash      Hash of the data to be signed\\n     * @param signature Signature byte array associated with _data\\n     */\\n    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../../utils/Address.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```solidity\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n *\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     * @custom:oz-retyped-from bool\\n     */\\n    uint8 private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint8 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts.\\n     *\\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\\n     * constructor.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier initializer() {\\n        bool isTopLevelCall = !_initializing;\\n        require(\\n            (isTopLevelCall && _initialized < 1) || (!Address.isContract(address(this)) && _initialized == 1),\\n            \\\"Initializable: contract is already initialized\\\"\\n        );\\n        _initialized = 1;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\\n     * are added through upgrades and that require initialization.\\n     *\\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     *\\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier reinitializer(uint8 version) {\\n        require(!_initializing && _initialized < version, \\\"Initializable: contract is already initialized\\\");\\n        _initialized = version;\\n        _initializing = true;\\n        _;\\n        _initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     *\\n     * Emits an {Initialized} event the first time it is successfully executed.\\n     */\\n    function _disableInitializers() internal virtual {\\n        require(!_initializing, \\\"Initializable: contract is initializing\\\");\\n        if (_initialized != type(uint8).max) {\\n            _initialized = type(uint8).max;\\n            emit Initialized(type(uint8).max);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\\n     */\\n    function _getInitializedVersion() internal view returns (uint8) {\\n        return _initialized;\\n    }\\n\\n    /**\\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\\n     */\\n    function _isInitializing() internal view returns (bool) {\\n        return _initializing;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Returns true if the reentrancy guard is currently set to \\\"entered\\\", which indicates there is a\\n     * `nonReentrant` function in the call stack.\\n     */\\n    function _reentrancyGuardEntered() internal view returns (bool) {\\n        return _status == _ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../extensions/IERC20Permit.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    /**\\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 oldAllowance = token.allowance(address(this), spender);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\\n    }\\n\\n    /**\\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\\n        }\\n    }\\n\\n    /**\\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful. Compatible with tokens that require the approval to be set to\\n     * 0 before setting it to a non-zero value.\\n     */\\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\\n\\n        if (!_callOptionalReturnBool(token, approvalCall)) {\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\\n            _callOptionalReturn(token, approvalCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\\n     * Revert on invalid signature.\\n     */\\n    function safePermit(\\n        IERC20Permit token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     *\\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\\n     */\\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\\n        // and not revert is the subcall reverts.\\n\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        return\\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     *\\n     * Furthermore, `isContract` will also return true if the target contract within\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\n     * which only has an effect at the end of a transaction.\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/Math.sol\\\";\\nimport \\\"./math/SignedMath.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(int256 value) internal pure returns (string memory) {\\n        return string(abi.encodePacked(value < 0 ? \\\"-\\\" : \\\"\\\", toString(SignedMath.abs(value))));\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n\\n    /**\\n     * @dev Returns true if the two strings are equal.\\n     */\\n    function equal(string memory a, string memory b) internal pure returns (bool) {\\n        return keccak256(bytes(a)) == keccak256(bytes(b));\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/cryptography/ECDSA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/ECDSA.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../Strings.sol\\\";\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    enum RecoverError {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS,\\n        InvalidSignatureV // Deprecated in v4.8\\n    }\\n\\n    function _throwError(RecoverError error) private pure {\\n        if (error == RecoverError.NoError) {\\n            return; // no error: do nothing\\n        } else if (error == RecoverError.InvalidSignature) {\\n            revert(\\\"ECDSA: invalid signature\\\");\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        } else if (error == RecoverError.InvalidSignatureS) {\\n            revert(\\\"ECDSA: invalid signature 's' value\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature` or error string. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return tryRecover(hash, v, r, s);\\n        } else {\\n            return (address(0), RecoverError.InvalidSignatureLength);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError) {\\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\\n        return tryRecover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\n     *\\n     * _Available since v4.2._\\n     */\\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (302): v \u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return (address(0), RecoverError.InvalidSignatureS);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        if (signer == address(0)) {\\n            return (address(0), RecoverError.InvalidSignature);\\n        }\\n\\n        return (signer, RecoverError.NoError);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\")\\n            mstore(0x1c, hash)\\n            message := keccak256(0x00, 0x3c)\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n\\\", Strings.toString(s.length), s));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 data) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, \\\"\\\\x19\\\\x01\\\")\\n            mstore(add(ptr, 0x02), domainSeparator)\\n            mstore(add(ptr, 0x22), structHash)\\n            data := keccak256(ptr, 0x42)\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Data with intended validator, created from a\\n     * `validator` and `data` according to the version 0 of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x00\\\", validator, data));\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/cryptography/SignatureChecker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/SignatureChecker.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ECDSA.sol\\\";\\nimport \\\"../../interfaces/IERC1271.sol\\\";\\n\\n/**\\n * @dev Signature verification helper that can be used instead of `ECDSA.recover` to seamlessly support both ECDSA\\n * signatures from externally owned accounts (EOAs) as well as ERC1271 signatures from smart contract wallets like\\n * Argent and Gnosis Safe.\\n *\\n * _Available since v4.1._\\n */\\nlibrary SignatureChecker {\\n    /**\\n     * @dev Checks if a signature is valid for a given signer and data hash. If the signer is a smart contract, the\\n     * signature is validated against that smart contract using ERC1271, otherwise it's validated using `ECDSA.recover`.\\n     *\\n     * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus\\n     * change through time. It could return true at block N and false at block N+1 (or the opposite).\\n     */\\n    function isValidSignatureNow(address signer, bytes32 hash, bytes memory signature) internal view returns (bool) {\\n        (address recovered, ECDSA.RecoverError error) = ECDSA.tryRecover(hash, signature);\\n        return\\n            (error == ECDSA.RecoverError.NoError && recovered == signer) ||\\n            isValidERC1271SignatureNow(signer, hash, signature);\\n    }\\n\\n    /**\\n     * @dev Checks if a signature is valid for a given signer and data hash. The signature is validated\\n     * against the signer smart contract using ERC1271.\\n     *\\n     * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus\\n     * change through time. It could return true at block N and false at block N+1 (or the opposite).\\n     */\\n    function isValidERC1271SignatureNow(\\n        address signer,\\n        bytes32 hash,\\n        bytes memory signature\\n    ) internal view returns (bool) {\\n        (bool success, bytes memory result) = signer.staticcall(\\n            abi.encodeWithSelector(IERC1271.isValidSignature.selector, hash, signature)\\n        );\\n        return (success &&\\n            result.length >= 32 &&\\n            abi.decode(result, (bytes32)) == bytes32(IERC1271.isValidSignature.selector));\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1, \\\"Math: mulDiv overflow\\\");\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/math/SignedMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard signed math utilities missing in the Solidity language.\\n */\\nlibrary SignedMath {\\n    /**\\n     * @dev Returns the largest of two signed numbers.\\n     */\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two signed numbers.\\n     */\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two signed numbers without overflow.\\n     * The result is rounded towards zero.\\n     */\\n    function average(int256 a, int256 b) internal pure returns (int256) {\\n        // Formula from the book \\\"Hacker's Delight\\\"\\n        int256 x = (a & b) + ((a ^ b) >> 1);\\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\\n    }\\n\\n    /**\\n     * @dev Returns the absolute unsigned value of a signed value.\\n     */\\n    function abs(int256 n) internal pure returns (uint256) {\\n        unchecked {\\n            // must be unchecked in order to support `n = type(int256).min`\\n            return uint256(n >= 0 ? n : -n);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/rain.datacontract/lib/rain.solmem/src/lib/LibMemCpy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\nimport \\\"./LibPointer.sol\\\";\\n\\nlibrary LibMemCpy {\\n    /// Copy an arbitrary number of bytes from one location in memory to another.\\n    /// As we can only read/write bytes in 32 byte chunks we first have to loop\\n    /// over 32 byte values to copy then handle any unaligned remaining data. The\\n    /// remaining data will be appropriately masked with the existing data in the\\n    /// final chunk so as to not write past the desired length. Note that the\\n    /// final unaligned write will be more gas intensive than the prior aligned\\n    /// writes. The writes are completely unsafe, the caller MUST ensure that\\n    /// sufficient memory is allocated and reading/writing the requested number\\n    /// of bytes from/to the requested locations WILL NOT corrupt memory in the\\n    /// opinion of solidity or other subsequent read/write operations.\\n    /// @param sourceCursor The starting pointer to read from.\\n    /// @param targetCursor The starting pointer to write to.\\n    /// @param length The number of bytes to read/write.\\n    function unsafeCopyBytesTo(Pointer sourceCursor, Pointer targetCursor, uint256 length) internal pure {\\n        assembly (\\\"memory-safe\\\") {\\n            // Precalculating the end here, rather than tracking the remaining\\n            // length each iteration uses relatively more gas for less data, but\\n            // scales better for more data. Copying 1-2 words is ~30 gas more\\n            // expensive but copying 3+ words favours a precalculated end point\\n            // increasingly for more data.\\n            let m := mod(length, 0x20)\\n            let end := add(sourceCursor, sub(length, m))\\n            for {} lt(sourceCursor, end) {\\n                sourceCursor := add(sourceCursor, 0x20)\\n                targetCursor := add(targetCursor, 0x20)\\n            } { mstore(targetCursor, mload(sourceCursor)) }\\n\\n            if iszero(iszero(m)) {\\n                //slither-disable-next-line incorrect-shift\\n                let mask_ := shr(mul(m, 8), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\\n                // preserve existing bytes\\n                mstore(\\n                    targetCursor,\\n                    or(\\n                        // input\\n                        and(mload(sourceCursor), not(mask_)),\\n                        and(mload(targetCursor), mask_)\\n                    )\\n                )\\n            }\\n        }\\n    }\\n\\n    /// Copies `length` `uint256` values starting from `source` to `target`\\n    /// with NO attempt to check that this is safe to do so. The caller MUST\\n    /// ensure that there exists allocated memory at `target` in which it is\\n    /// safe and appropriate to copy `length * 32` bytes to. Anything that was\\n    /// already written to memory at `[target:target+(length * 32 bytes)]`\\n    /// will be overwritten.\\n    /// There is no return value as memory is modified directly.\\n    /// @param source The starting position in memory that data will be copied\\n    /// from.\\n    /// @param target The starting position in memory that data will be copied\\n    /// to.\\n    /// @param length The number of 32 byte (i.e. `uint256`) words that will\\n    /// be copied.\\n    function unsafeCopyWordsTo(Pointer source, Pointer target, uint256 length) internal pure {\\n        assembly (\\\"memory-safe\\\") {\\n            for { let end_ := add(source, mul(0x20, length)) } lt(source, end_) {\\n                source := add(source, 0x20)\\n                target := add(target, 0x20)\\n            } { mstore(target, mload(source)) }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/rain.datacontract/lib/rain.solmem/src/lib/LibPointer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\n/// A pointer to a location in memory. This is a `uint256` to save gas on low\\n/// level operations on the evm stack. These same low level operations typically\\n/// WILL NOT check for overflow or underflow, so all pointer logic MUST ensure\\n/// that reads, writes and movements are not out of bounds.\\ntype Pointer is uint256;\\n\\n/// @title LibPointer\\n/// Ergonomic wrappers around common pointer movements, reading and writing. As\\n/// wrappers on such low level operations often introduce too much jump gas\\n/// overhead, these functions MAY find themselves used in reference\\n/// implementations that more optimised code can be fuzzed against. MAY also be\\n/// situationally useful on cooler performance paths.\\nlibrary LibPointer {\\n    /// Cast a `Pointer` to `bytes` without modification or any safety checks.\\n    /// The caller MUST ensure the pointer is to a valid region of memory for\\n    /// some `bytes`.\\n    /// @param pointer The pointer to cast to `bytes`.\\n    /// @return data The cast `bytes`.\\n    function unsafeAsBytes(Pointer pointer) internal pure returns (bytes memory data) {\\n        assembly (\\\"memory-safe\\\") {\\n            data := pointer\\n        }\\n    }\\n\\n    /// Increase some pointer by a number of bytes.\\n    ///\\n    /// This is UNSAFE because it can silently overflow or point beyond some\\n    /// data structure. The caller MUST ensure that this is a safe operation.\\n    ///\\n    /// Note that moving a pointer by some bytes offset is likely to unalign it\\n    /// with the 32 byte increments of the Solidity allocator.\\n    ///\\n    /// @param pointer The pointer to increase by `length`.\\n    /// @param length The number of bytes to increase the pointer by.\\n    /// @return The increased pointer.\\n    function unsafeAddBytes(Pointer pointer, uint256 length) internal pure returns (Pointer) {\\n        assembly (\\\"memory-safe\\\") {\\n            pointer := add(pointer, length)\\n        }\\n        return pointer;\\n    }\\n\\n    /// Increase some pointer by a single 32 byte word.\\n    ///\\n    /// This is UNSAFE because it can silently overflow or point beyond some\\n    /// data structure. The caller MUST ensure that this is a safe operation.\\n    ///\\n    /// If the original pointer is aligned to the Solidity allocator it will be\\n    /// aligned after the movement.\\n    ///\\n    /// @param pointer The pointer to increase by a single word.\\n    /// @return The increased pointer.\\n    function unsafeAddWord(Pointer pointer) internal pure returns (Pointer) {\\n        assembly (\\\"memory-safe\\\") {\\n            pointer := add(pointer, 0x20)\\n        }\\n        return pointer;\\n    }\\n\\n    /// Increase some pointer by multiple 32 byte words.\\n    ///\\n    /// This is UNSAFE because it can silently overflow or point beyond some\\n    /// data structure. The caller MUST ensure that this is a safe operation.\\n    ///\\n    /// If the original pointer is aligned to the Solidity allocator it will be\\n    /// aligned after the movement.\\n    ///\\n    /// @param pointer The pointer to increase.\\n    /// @param words The number of words to increase the pointer by.\\n    /// @return The increased pointer.\\n    function unsafeAddWords(Pointer pointer, uint256 words) internal pure returns (Pointer) {\\n        assembly (\\\"memory-safe\\\") {\\n            pointer := add(pointer, mul(0x20, words))\\n        }\\n        return pointer;\\n    }\\n\\n    /// Decrease some pointer by a single 32 byte word.\\n    ///\\n    /// This is UNSAFE because it can silently underflow or point below some\\n    /// data structure. The caller MUST ensure that this is a safe operation.\\n    ///\\n    /// If the original pointer is aligned to the Solidity allocator it will be\\n    /// aligned after the movement.\\n    ///\\n    /// @param pointer The pointer to decrease by a single word.\\n    /// @return The decreased pointer.\\n    function unsafeSubWord(Pointer pointer) internal pure returns (Pointer) {\\n        assembly (\\\"memory-safe\\\") {\\n            pointer := sub(pointer, 0x20)\\n        }\\n        return pointer;\\n    }\\n\\n    /// Decrease some pointer by multiple 32 byte words.\\n    ///\\n    /// This is UNSAFE because it can silently underflow or point below some\\n    /// data structure. The caller MUST ensure that this is a safe operation.\\n    ///\\n    /// If the original pointer is aligned to the Solidity allocator it will be\\n    /// aligned after the movement.\\n    ///\\n    /// @param pointer The pointer to decrease.\\n    /// @param words The number of words to decrease the pointer by.\\n    /// @return The decreased pointer.\\n    function unsafeSubWords(Pointer pointer, uint256 words) internal pure returns (Pointer) {\\n        assembly (\\\"memory-safe\\\") {\\n            pointer := sub(pointer, mul(0x20, words))\\n        }\\n        return pointer;\\n    }\\n\\n    /// Read the word at the pointer.\\n    ///\\n    /// This is UNSAFE because it can read outside any particular data stucture\\n    /// or even beyond allocated memory. The caller MUST ensure that this is a\\n    /// safe operation.\\n    ///\\n    /// @param pointer Pointer to read the word at.\\n    /// @return word The word read from the pointer.\\n    function unsafeReadWord(Pointer pointer) internal pure returns (uint256 word) {\\n        assembly (\\\"memory-safe\\\") {\\n            word := mload(pointer)\\n        }\\n    }\\n\\n    /// Write a word at the pointer.\\n    ///\\n    /// This is UNSAFE because it can write outside any particular data stucture\\n    /// or even beyond allocated memory. The caller MUST ensure that this is a\\n    /// safe operation.\\n    ///\\n    /// @param pointer Pointer to write the word at.\\n    /// @param word The word to write.\\n    function unsafeWriteWord(Pointer pointer, uint256 word) internal pure {\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(pointer, word)\\n        }\\n    }\\n\\n    /// Get the pointer to the end of all allocated memory.\\n    /// As per Solidity docs, there is no guarantee that the region of memory\\n    /// beyond this pointer is zeroed out, as assembly MAY write beyond allocated\\n    /// memory for temporary use if the scratch space is insufficient.\\n    /// @return pointer The pointer to the end of all allocated memory.\\n    function allocatedMemoryPointer() internal pure returns (Pointer pointer) {\\n        assembly (\\\"memory-safe\\\") {\\n            pointer := mload(0x40)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/rain.datacontract/lib/rain.solmem/src/lib/LibUint256Array.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\nimport \\\"./LibMemCpy.sol\\\";\\n\\n/// Thrown if a truncated length is longer than the array being truncated. It is\\n/// not possible to truncate something and increase its length as the memory\\n/// region after the array MAY be allocated for something else already.\\nerror OutOfBoundsTruncate(uint256 arrayLength, uint256 truncatedLength);\\n\\n/// @title Uint256Array\\n/// @notice Things we want to do carefully and efficiently with uint256 arrays\\n/// that Solidity doesn't give us native tools for.\\nlibrary LibUint256Array {\\n    using LibUint256Array for uint256[];\\n\\n    /// Pointer to the start (length prefix) of a `uint256[]`.\\n    /// @param array The array to get the start pointer of.\\n    /// @return pointer The pointer to the start of `array`.\\n    function startPointer(uint256[] memory array) internal pure returns (Pointer pointer) {\\n        assembly (\\\"memory-safe\\\") {\\n            pointer := array\\n        }\\n    }\\n\\n    /// Pointer to the data of a `uint256[]` NOT the length prefix.\\n    /// @param array The array to get the data pointer of.\\n    /// @return pointer The pointer to the data of `array`.\\n    function dataPointer(uint256[] memory array) internal pure returns (Pointer pointer) {\\n        assembly (\\\"memory-safe\\\") {\\n            pointer := add(array, 0x20)\\n        }\\n    }\\n\\n    /// Pointer to the end of the allocated memory of an array.\\n    /// @param array The array to get the end pointer of.\\n    /// @return pointer The pointer to the end of `array`.\\n    function endPointer(uint256[] memory array) internal pure returns (Pointer pointer) {\\n        assembly (\\\"memory-safe\\\") {\\n            pointer := add(array, add(0x20, mul(0x20, mload(array))))\\n        }\\n    }\\n\\n    /// Cast a `Pointer` to `uint256[]` without modification or safety checks.\\n    /// The caller MUST ensure the pointer is to a valid region of memory for\\n    /// some `uint256[]`.\\n    /// @param pointer The pointer to cast to `uint256[]`.\\n    /// @return array The cast `uint256[]`.\\n    function unsafeAsUint256Array(Pointer pointer) internal pure returns (uint256[] memory array) {\\n        assembly (\\\"memory-safe\\\") {\\n            array := pointer\\n        }\\n    }\\n\\n    /// Building arrays from literal components is a common task that introduces\\n    /// boilerplate that is either inefficient or error prone.\\n    /// @param a A single integer to build an array around.\\n    /// @return array The newly allocated array including `a` as a single item.\\n    function arrayFrom(uint256 a) internal pure returns (uint256[] memory array) {\\n        assembly (\\\"memory-safe\\\") {\\n            array := mload(0x40)\\n            mstore(array, 1)\\n            mstore(add(array, 0x20), a)\\n            mstore(0x40, add(array, 0x40))\\n        }\\n    }\\n\\n    /// Building arrays from literal components is a common task that introduces\\n    /// boilerplate that is either inefficient or error prone.\\n    /// @param a The first integer to build an array around.\\n    /// @param b The second integer to build an array around.\\n    /// @return array The newly allocated array including `a` and `b` as the only\\n    /// items.\\n    function arrayFrom(uint256 a, uint256 b) internal pure returns (uint256[] memory array) {\\n        assembly (\\\"memory-safe\\\") {\\n            array := mload(0x40)\\n            mstore(array, 2)\\n            mstore(add(array, 0x20), a)\\n            mstore(add(array, 0x40), b)\\n            mstore(0x40, add(array, 0x60))\\n        }\\n    }\\n\\n    /// Building arrays from literal components is a common task that introduces\\n    /// boilerplate that is either inefficient or error prone.\\n    /// @param a The first integer to build an array around.\\n    /// @param b The second integer to build an array around.\\n    /// @param c The third integer to build an array around.\\n    /// @return array The newly allocated array including `a`, `b` and `c` as the\\n    /// only items.\\n    function arrayFrom(uint256 a, uint256 b, uint256 c) internal pure returns (uint256[] memory array) {\\n        assembly (\\\"memory-safe\\\") {\\n            array := mload(0x40)\\n            mstore(array, 3)\\n            mstore(add(array, 0x20), a)\\n            mstore(add(array, 0x40), b)\\n            mstore(add(array, 0x60), c)\\n            mstore(0x40, add(array, 0x80))\\n        }\\n    }\\n\\n    /// Building arrays from literal components is a common task that introduces\\n    /// boilerplate that is either inefficient or error prone.\\n    /// @param a The first integer to build an array around.\\n    /// @param b The second integer to build an array around.\\n    /// @param c The third integer to build an array around.\\n    /// @param d The fourth integer to build an array around.\\n    /// @return array The newly allocated array including `a`, `b`, `c` and `d` as the\\n    /// only items.\\n    function arrayFrom(uint256 a, uint256 b, uint256 c, uint256 d) internal pure returns (uint256[] memory array) {\\n        assembly (\\\"memory-safe\\\") {\\n            array := mload(0x40)\\n            mstore(array, 4)\\n            mstore(add(array, 0x20), a)\\n            mstore(add(array, 0x40), b)\\n            mstore(add(array, 0x60), c)\\n            mstore(add(array, 0x80), d)\\n            mstore(0x40, add(array, 0xA0))\\n        }\\n    }\\n\\n    /// Building arrays from literal components is a common task that introduces\\n    /// boilerplate that is either inefficient or error prone.\\n    /// @param a The first integer to build an array around.\\n    /// @param b The second integer to build an array around.\\n    /// @param c The third integer to build an array around.\\n    /// @param d The fourth integer to build an array around.\\n    /// @param e The fifth integer to build an array around.\\n    /// @return array The newly allocated array including `a`, `b`, `c`, `d` and\\n    /// `e` as the only items.\\n    function arrayFrom(uint256 a, uint256 b, uint256 c, uint256 d, uint256 e)\\n        internal\\n        pure\\n        returns (uint256[] memory array)\\n    {\\n        assembly (\\\"memory-safe\\\") {\\n            array := mload(0x40)\\n            mstore(array, 5)\\n            mstore(add(array, 0x20), a)\\n            mstore(add(array, 0x40), b)\\n            mstore(add(array, 0x60), c)\\n            mstore(add(array, 0x80), d)\\n            mstore(add(array, 0xA0), e)\\n            mstore(0x40, add(array, 0xC0))\\n        }\\n    }\\n\\n    /// Building arrays from literal components is a common task that introduces\\n    /// boilerplate that is either inefficient or error prone.\\n    /// @param a The first integer to build an array around.\\n    /// @param b The second integer to build an array around.\\n    /// @param c The third integer to build an array around.\\n    /// @param d The fourth integer to build an array around.\\n    /// @param e The fifth integer to build an array around.\\n    /// @param f The sixth integer to build an array around.\\n    /// @return array The newly allocated array including `a`, `b`, `c`, `d`, `e`\\n    /// and `f` as the only items.\\n    function arrayFrom(uint256 a, uint256 b, uint256 c, uint256 d, uint256 e, uint256 f)\\n        internal\\n        pure\\n        returns (uint256[] memory array)\\n    {\\n        assembly (\\\"memory-safe\\\") {\\n            array := mload(0x40)\\n            mstore(array, 6)\\n            mstore(add(array, 0x20), a)\\n            mstore(add(array, 0x40), b)\\n            mstore(add(array, 0x60), c)\\n            mstore(add(array, 0x80), d)\\n            mstore(add(array, 0xA0), e)\\n            mstore(add(array, 0xC0), f)\\n            mstore(0x40, add(array, 0xE0))\\n        }\\n    }\\n\\n    /// Building arrays from literal components is a common task that introduces\\n    /// boilerplate that is either inefficient or error prone.\\n    /// @param a The head of the new array.\\n    /// @param tail The tail of the new array.\\n    /// @return array The new array.\\n    function arrayFrom(uint256 a, uint256[] memory tail) internal pure returns (uint256[] memory array) {\\n        assembly (\\\"memory-safe\\\") {\\n            let length := add(mload(tail), 1)\\n            let outputCursor := mload(0x40)\\n            array := outputCursor\\n            let outputEnd := add(outputCursor, add(0x20, mul(length, 0x20)))\\n            mstore(0x40, outputEnd)\\n\\n            mstore(outputCursor, length)\\n            mstore(add(outputCursor, 0x20), a)\\n\\n            for {\\n                outputCursor := add(outputCursor, 0x40)\\n                let inputCursor := add(tail, 0x20)\\n            } lt(outputCursor, outputEnd) {\\n                outputCursor := add(outputCursor, 0x20)\\n                inputCursor := add(inputCursor, 0x20)\\n            } { mstore(outputCursor, mload(inputCursor)) }\\n        }\\n    }\\n\\n    /// Building arrays from literal components is a common task that introduces\\n    /// boilerplate that is either inefficient or error prone.\\n    /// @param a The first item of the new array.\\n    /// @param b The second item of the new array.\\n    /// @param tail The tail of the new array.\\n    /// @return array The new array.\\n    function arrayFrom(uint256 a, uint256 b, uint256[] memory tail) internal pure returns (uint256[] memory array) {\\n        assembly (\\\"memory-safe\\\") {\\n            let length := add(mload(tail), 2)\\n            let outputCursor := mload(0x40)\\n            array := outputCursor\\n            let outputEnd := add(outputCursor, add(0x20, mul(length, 0x20)))\\n            mstore(0x40, outputEnd)\\n\\n            mstore(outputCursor, length)\\n            mstore(add(outputCursor, 0x20), a)\\n            mstore(add(outputCursor, 0x40), b)\\n\\n            for {\\n                outputCursor := add(outputCursor, 0x60)\\n                let inputCursor := add(tail, 0x20)\\n            } lt(outputCursor, outputEnd) {\\n                outputCursor := add(outputCursor, 0x20)\\n                inputCursor := add(inputCursor, 0x20)\\n            } { mstore(outputCursor, mload(inputCursor)) }\\n        }\\n    }\\n\\n    /// Solidity provides no way to change the length of in-memory arrays but\\n    /// it also does not deallocate memory ever. It is always safe to shrink an\\n    /// array that has already been allocated, with the caveat that the\\n    /// truncated items will effectively become inaccessible regions of memory.\\n    /// That is to say, we deliberately \\\"leak\\\" the truncated items, but that is\\n    /// no worse than Solidity's native behaviour of leaking everything always.\\n    /// The array is MUTATED in place so there is no return value and there is\\n    /// no new allocation or copying of data either.\\n    /// @param array The array to truncate.\\n    /// @param newLength The new length of the array after truncation.\\n    function truncate(uint256[] memory array, uint256 newLength) internal pure {\\n        if (newLength > array.length) {\\n            revert OutOfBoundsTruncate(array.length, newLength);\\n        }\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(array, newLength)\\n        }\\n    }\\n\\n    /// Extends `base_` with `extend_` by allocating only an additional\\n    /// `extend_.length` words onto `base_` and copying only `extend_` if\\n    /// possible. If `base_` is large this MAY be significantly more efficient\\n    /// than allocating `base_.length + extend_.length` for an entirely new array\\n    /// and copying both `base_` and `extend_` into the new array one item at a\\n    /// time in Solidity.\\n    ///\\n    /// The efficient version of extension is only possible if the free memory\\n    /// pointer sits at the end of the base array at the moment of extension. If\\n    /// there is allocated memory after the end of base then extension will\\n    /// require copying both the base and extend arays to a new region of memory.\\n    /// The caller is responsible for optimising code paths to avoid additional\\n    /// allocations.\\n    ///\\n    /// This function is UNSAFE because the base array IS MUTATED DIRECTLY by\\n    /// some code paths AND THE FINAL RETURN ARRAY MAY POINT TO THE SAME REGION\\n    /// OF MEMORY. It is NOT POSSIBLE to reliably see this behaviour from the\\n    /// caller in all cases as the Solidity compiler optimisations may switch the\\n    /// caller between the allocating and non-allocating logic due to subtle\\n    /// optimisation reasons. To use this function safely THE CALLER MUST NOT USE\\n    /// THE BASE ARRAY AND MUST USE THE RETURNED ARRAY ONLY. It is safe to use\\n    /// the extend array after calling this function as it is never mutated, it\\n    /// is only copied from.\\n    ///\\n    /// @param b The base integer array that will be extended by `e`.\\n    /// @param e The extend integer array that extends `b`.\\n    /// @return extended The extended array of `b` extended by `e`.\\n    function unsafeExtend(uint256[] memory b, uint256[] memory e) internal pure returns (uint256[] memory extended) {\\n        assembly (\\\"memory-safe\\\") {\\n            // Slither doesn't recognise assembly function names as mixed case\\n            // even if they are.\\n            // https://github.com/crytic/slither/issues/1815\\n            //slither-disable-next-line naming-convention\\n            function extendInline(base, extend) -> baseAfter {\\n                let outputCursor := mload(0x40)\\n                let baseLength := mload(base)\\n                let baseEnd := add(base, add(0x20, mul(baseLength, 0x20)))\\n\\n                // If base is NOT the last thing in allocated memory, allocate,\\n                // copy and recurse.\\n                switch eq(outputCursor, baseEnd)\\n                case 0 {\\n                    let newBase := outputCursor\\n                    let newBaseEnd := add(newBase, sub(baseEnd, base))\\n                    mstore(0x40, newBaseEnd)\\n                    for { let inputCursor := base } lt(outputCursor, newBaseEnd) {\\n                        inputCursor := add(inputCursor, 0x20)\\n                        outputCursor := add(outputCursor, 0x20)\\n                    } { mstore(outputCursor, mload(inputCursor)) }\\n\\n                    baseAfter := extendInline(newBase, extend)\\n                }\\n                case 1 {\\n                    let totalLength_ := add(baseLength, mload(extend))\\n                    let outputEnd_ := add(base, add(0x20, mul(totalLength_, 0x20)))\\n                    mstore(base, totalLength_)\\n                    mstore(0x40, outputEnd_)\\n                    for { let inputCursor := add(extend, 0x20) } lt(outputCursor, outputEnd_) {\\n                        inputCursor := add(inputCursor, 0x20)\\n                        outputCursor := add(outputCursor, 0x20)\\n                    } { mstore(outputCursor, mload(inputCursor)) }\\n\\n                    baseAfter := base\\n                }\\n            }\\n\\n            extended := extendInline(b, e)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/rain.factory/src/interface/ICloneableV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\n/// @dev This hash MUST be returned when an `ICloneableV2` is successfully\\n/// initialized.\\nbytes32 constant ICLONEABLE_V2_SUCCESS = keccak256(\\\"ICloneableV2.initialize\\\");\\n\\n/// @title ICloneableV2\\n/// @notice Interface for cloneable contracts that support initialization.\\ninterface ICloneableV2 {\\n    /// Overloaded initialize function MUST revert with this error.\\n    error InitializeSignatureFn();\\n\\n    /// Initialize is intended to work like constructors but for cloneable\\n    /// proxies. The `ICloneableV2` contract MUST ensure that initialize can NOT\\n    /// be called more than once. The `ICloneableV2` contract is designed to be\\n    /// deployed by an `ICloneableFactoryV2` but MUST NOT assume that it will be.\\n    /// It is possible for someone to directly deploy an `ICloneableV2` and fail\\n    /// to call initialize before other functions are called, and end users MAY\\n    /// NOT realise or know how to confirm a safe deployment state. The\\n    /// `ICloneableV2` MUST take appropriate measures to ensure that functions\\n    /// called before initialize are safe to do so, or revert.\\n    ///\\n    /// To be fully generic, `initilize` accepts `bytes` and so MUST ABI decode\\n    /// within the initialize function. This allows a single factory to service\\n    /// arbitrary cloneable proxies but also erases the type of the\\n    /// initialization config from the ABI. As tooling will inevitably require\\n    /// the ABI to be known, it is RECOMMENDED that the `ICloneableV2` contract\\n    /// implements a typed `initialize` function that overloads the generic\\n    /// `initialize(bytes)` function. This overloaded function MUST revert with\\n    /// `InitializeSignatureFn` always, so that it is NEVER accidentally called.\\n    /// This avoids complex and expensive delegate call style patterns where a\\n    /// typed overload has to call back to itself and preserve the sender,\\n    /// instead we force the caller to know the correct signature and call the\\n    /// correct function directly with encoded bytes.\\n    ///\\n    /// If initialization is successful the `ICloneableV2` MUST return the\\n    /// keccak256 hash of the string \\\"ICloneableV2.initialize\\\". This avoids false\\n    /// positives where a contract building a proxy, such as an\\n    /// `ICloneableFactoryV2`, may incorrectly believe that the clone has been\\n    /// initialized but the implementation doesn't support `ICloneableV2`.\\n    ///\\n    /// @dev The `ICloneableV2` interface is identical to `ICloneableV1` except\\n    /// that it returns a `bytes32` success hash.\\n    /// @param data The initialization data.\\n    /// @return success keccak256(\\\"ICloneableV2.initialize\\\") if successful.\\n    function initialize(bytes calldata data) external returns (bytes32 success);\\n}\\n\"\r\n    },\r\n    \"lib/rain.interpreter/src/abstract/DeployerDiscoverableMetaV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\nimport \\\"rain.metadata/IMetaV1.sol\\\";\\nimport \\\"rain.metadata/LibMeta.sol\\\";\\nimport \\\"../lib/caller/LibDeployerDiscoverable.sol\\\";\\n\\n/// Construction config for `DeployerDiscoverableMetaV1`.\\n/// @param deployer Deployer the calling contract will be discoverable under.\\n/// @param meta MetaV1 data to emit before touching the deployer.\\nstruct DeployerDiscoverableMetaV1ConstructionConfig {\\n    address deployer;\\n    bytes meta;\\n}\\n\\n/// @title DeployerDiscoverableMetaV1\\n/// @notice Upon construction, checks metadata against a known hash, emits it\\n/// then touches the deployer (deploy an empty expression). This allows indexers\\n/// to discover the metadata of the `DeployerDiscoverableMetaV1` contract by\\n/// indexing the deployer. In this way the deployer acts as a pseudo-registry by\\n/// virtue of it being a natural hub for interactions with calling contracts.\\nabstract contract DeployerDiscoverableMetaV1 is IMetaV1 {\\n    constructor(bytes32 metaHash, DeployerDiscoverableMetaV1ConstructionConfig memory config) {\\n        LibMeta.checkMetaHashed(metaHash, config.meta);\\n        emit MetaV1(msg.sender, uint256(uint160(address(this))), config.meta);\\n        LibDeployerDiscoverable.touchDeployerV1(config.deployer);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/rain.interpreter/src/interface/IExpressionDeployerV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\nimport \\\"./IInterpreterV1.sol\\\";\\n\\nstring constant IERC1820_NAME_IEXPRESSION_DEPLOYER_V1 = \\\"IExpressionDeployerV1\\\";\\n\\n/// @title IExpressionDeployerV1\\n/// @notice Companion to `IInterpreterV1` responsible for onchain static code\\n/// analysis and deploying expressions. Each `IExpressionDeployerV1` is tightly\\n/// coupled at the bytecode level to some interpreter that it knows how to\\n/// analyse and deploy expressions for. The expression deployer can perform an\\n/// integrity check \\\"dry run\\\" of candidate source code for the intepreter. The\\n/// critical analysis/transformation includes:\\n///\\n/// - Enforcement of no out of bounds memory reads/writes\\n/// - Calculation of memory required to eval the stack with a single allocation\\n/// - Replacing index based opcodes with absolute interpreter function pointers\\n/// - Enforcement that all opcodes and operands used exist and are valid\\n///\\n/// This analysis is highly sensitive to the specific implementation and position\\n/// of all opcodes and function pointers as compiled into the interpreter. This\\n/// is what makes the coupling between an interpreter and expression deployer\\n/// so tight. Ideally all responsibilities would be handled by a single contract\\n/// but this introduces code size issues quickly by roughly doubling the compiled\\n/// logic of each opcode (half for the integrity check and half for evaluation).\\n///\\n/// Interpreters MUST assume that expression deployers are malicious and fail\\n/// gracefully if the integrity check is corrupt/bypassed and/or function\\n/// pointers are incorrect, etc. i.e. the interpreter MUST always return a stack\\n/// from `eval` in a read only way or error. I.e. it is the expression deployer's\\n/// responsibility to do everything it can to prevent undefined behaviour in the\\n/// interpreter, and the interpreter's responsibility to handle the expression\\n/// deployer completely failing to do so.\\ninterface IExpressionDeployerV1 {\\n    /// This is the literal InterpreterOpMeta bytes to be used offchain to make\\n    /// sense of the opcodes in this interpreter deployment, as a human. For\\n    /// formats like json that make heavy use of boilerplate, repetition and\\n    /// whitespace, some kind of compression is recommended.\\n    /// @param sender The `msg.sender` providing the op meta.\\n    /// @param opMeta The raw binary data of the op meta. Maybe compressed data\\n    /// etc. and is intended for offchain consumption.\\n    event DISpair(address sender, address deployer, address interpreter, address store, bytes opMeta);\\n\\n    /// Expressions are expected to be deployed onchain as immutable contract\\n    /// code with a first class address like any other contract or account.\\n    /// Technically this is optional in the sense that all the tools required to\\n    /// eval some expression and define all its opcodes are available as\\n    /// libraries.\\n    ///\\n    /// In practise there are enough advantages to deploying the sources directly\\n    /// onchain as contract data and loading them from the interpreter at eval:\\n    ///\\n    /// - Loading and storing binary data is gas efficient as immutable contract\\n    ///   data\\n    /// - Expressions need to be immutable between their deploy time integrity\\n    ///   check and runtime evaluation\\n    /// - Passing the address of an expression through calldata to an interpreter\\n    ///   is cheaper than passing an entire expression through calldata\\n    /// - Conceptually a very simple approach, even if implementations like\\n    ///   SSTORE2 are subtle under the hood\\n    ///\\n    /// The expression deployer MUST perform an integrity check of the source\\n    /// code before it puts the expression onchain at a known address. The\\n    /// integrity check MUST at a minimum (it is free to do additional static\\n    /// analysis) calculate the memory required to be allocated for the stack in\\n    /// total, and that no out of bounds memory reads/writes occur within this\\n    /// stack. A simple example of an invalid source would be one that pushes one\\n    /// value to the stack then attempts to pops two values, clearly we cannot\\n    /// remove more values than we added. The `IExpressionDeployerV1` MUST revert\\n    /// in the case of any integrity failure, all integrity checks MUST pass in\\n    /// order for the deployment to complete.\\n    ///\\n    /// Once the integrity check is complete the `IExpressionDeployerV1` MUST do\\n    /// any additional processing required by its paired interpreter.\\n    /// For example, the `IExpressionDeployerV1` MAY NEED to replace the indexed\\n    /// opcodes in the `ExpressionConfig` sources with real function pointers\\n    /// from the corresponding interpreter.\\n    ///\\n    /// @param sources Sources verbatim. These sources MUST be provided in their\\n    /// sequential/index opcode form as the deployment process will need to index\\n    /// into BOTH the integrity check and the final runtime function pointers.\\n    /// This will be emitted in an event for offchain processing to use the\\n    /// indexed opcode sources. The first N sources are considered entrypoints\\n    /// and will be integrity checked by the expression deployer against a\\n    /// starting stack height of 0. Non-entrypoint sources MAY be provided for\\n    /// internal use such as the `call` opcode but will NOT be integrity checked\\n    /// UNLESS entered by an opcode in an entrypoint.\\n    /// @param constants Constants verbatim. Constants are provided alongside\\n    /// sources rather than inline as it allows us to avoid variable length\\n    /// opcodes and can be more memory efficient if the same constant is\\n    /// referenced several times from the sources.\\n    /// @param minOutputs The first N sources on the state config are entrypoints\\n    /// to the expression where N is the length of the `minOutputs` array. Each\\n    /// item in the `minOutputs` array specifies the number of outputs that MUST\\n    /// be present on the final stack for an evaluation of each entrypoint. The\\n    /// minimum output for some entrypoint MAY be zero if the expectation is that\\n    /// the expression only applies checks and error logic. Non-entrypoint\\n    /// sources MUST NOT have a minimum outputs length specified.\\n    /// @return interpreter The interpreter the deployer believes it is qualified\\n    /// to perform integrity checks on behalf of.\\n    /// @return store The interpreter store the deployer believes is compatible\\n    /// with the interpreter.\\n    /// @return expression The address of the deployed onchain expression. MUST\\n    /// be valid according to all integrity checks the deployer is aware of.\\n    function deployExpression(bytes[] memory sources, uint256[] memory constants, uint256[] memory minOutputs)\\n        external\\n        returns (IInterpreterV1 interpreter, IInterpreterStoreV1 store, address expression);\\n}\\n\"\r\n    },\r\n    \"lib/rain.interpreter/src/interface/IInterpreterCallerV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\n/// Typed embodiment of some context data with associated signer and signature.\\n/// The signature MUST be over the packed encoded bytes of the context array,\\n/// i.e. the context array concatenated as bytes without the length prefix, then\\n/// hashed, then handled as per EIP-191 to produce a final hash to be signed.\\n///\\n/// The calling contract (likely with the help of `LibContext`) is responsible\\n/// for ensuring the authenticity of the signature, but not authorizing _who_ can\\n/// sign. IN ADDITION to authorisation of the signer to known-good entities the\\n/// expression is also responsible for:\\n///\\n/// - Enforcing the context is the expected data (e.g. with a domain separator)\\n/// - Tracking and enforcing nonces if signed contexts are only usable one time\\n/// - Tracking and enforcing uniqueness of signed data if relevant\\n/// - Checking and enforcing expiry times if present and relevant in the context\\n/// - Many other potential constraints that expressions may want to enforce\\n///\\n/// EIP-1271 smart contract signatures are supported in addition to EOA\\n/// signatures via. the Open Zeppelin `SignatureChecker` library, which is\\n/// wrapped by `LibContext.build`. As smart contract signatures are checked\\n/// onchain they CAN BE REVOKED AT ANY MOMENT as the smart contract can simply\\n/// return `false` when it previously returned `true`.\\n///\\n/// @param signer The account that produced the signature for `context`. The\\n/// calling contract MUST authenticate that the signer produced the signature.\\n/// @param context The signed data in a format that can be merged into a\\n/// 2-dimensional context matrix as-is.\\n/// @param signature The cryptographic signature for `context`. The calling\\n/// contract MUST authenticate that the signature is valid for the `signer` and\\n/// `context`.\\nstruct SignedContextV1 {\\n    // The ordering of these fields is important and used in assembly offset\\n    // calculations and hashing.\\n    address signer;\\n    uint256[] context;\\n    bytes signature;\\n}\\n\\nuint256 constant SIGNED_CONTEXT_SIGNER_OFFSET = 0;\\nuint256 constant SIGNED_CONTEXT_CONTEXT_OFFSET = 0x20;\\nuint256 constant SIGNED_CONTEXT_SIGNATURE_OFFSET = 0x40;\\n\\n/// @title IInterpreterCallerV2\\n/// @notice A contract that calls an `IInterpreterV1` via. `eval`. There are near\\n/// zero requirements on a caller other than:\\n///\\n/// - Emit some meta about itself upon construction so humans know what the\\n///   contract does\\n/// - Provide the context, which can be built in a standard way by `LibContext`\\n/// - Handle the stack array returned from `eval`\\n/// - OPTIONALLY emit the `Context` event\\n/// - OPTIONALLY set state on the `IInterpreterStoreV1` returned from eval.\\ninterface IInterpreterCallerV2 {\\n    /// Calling contracts SHOULD emit `Context` before calling `eval` if they\\n    /// are able. Notably `eval` MAY be called within a static call which means\\n    /// that events cannot be emitted, in which case this does not apply. It MAY\\n    /// NOT be useful to emit this multiple times for several eval calls if they\\n    /// all share a common context, in which case a single emit is sufficient.\\n    /// @param sender `msg.sender` building the context.\\n    /// @param context The context that was built.\\n    event Context(address sender, uint256[][] context);\\n}\\n\"\r\n    },\r\n    \"lib/rain.interpreter/src/interface/IInterpreterStoreV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\nimport \\\"./IInterpreterV1.sol\\\";\\n\\n/// A fully qualified namespace includes the interpreter's own namespacing logic\\n/// IN ADDITION to the calling contract's requested `StateNamespace`. Typically\\n/// this involves hashing the `msg.sender` into the `StateNamespace` so that each\\n/// caller operates within its own disjoint state universe. Intepreters MUST NOT\\n/// allow either the caller nor any expression/word to modify this directly on\\n/// pain of potential key collisions on writes to the interpreter's own storage.\\ntype FullyQualifiedNamespace is uint256;\\n\\nIInterpreterStoreV1 constant NO_STORE = IInterpreterStoreV1(address(0));\\n\\n/// @title IInterpreterStoreV1\\n/// @notice Tracks state changes on behalf of an interpreter. A single store can\\n/// handle state changes for many calling contracts, many interpreters and many\\n/// expressions. The store is responsible for ensuring that applying these state\\n/// changes is safe from key collisions with calls to `set` from different\\n/// `msg.sender` callers. I.e. it MUST NOT be possible for a caller to modify the\\n/// state changes associated with some other caller.\\n///\\n/// The store defines the shape of its own state changes, which is opaque to the\\n/// calling contract. For example, some store may treat the list of state changes\\n/// as a pairwise key/value set, and some other store may treat it as a literal\\n/// list to be stored as-is.\\n///\\n/// Each interpreter decides for itself which store to use based on the\\n/// compatibility of its own opcodes.\\n///\\n/// The store MUST assume the state changes have been corrupted by the calling\\n/// contract due to bugs or malicious intent, and enforce state isolation between\\n/// callers despite arbitrarily invalid state changes. The store MUST revert if\\n/// it can detect invalid state changes, such as a key/value list having an odd\\n/// number of items, but this MAY NOT be possible if the corruption is\\n/// undetectable.\\ninterface IInterpreterStoreV1 {\\n    /// Mutates the interpreter store in bulk. The bulk values are provided in\\n    /// the form of a `uint256[]` which can be treated e.g. as pairwise keys and\\n    /// values to be stored in a Solidity mapping. The `IInterpreterStoreV1`\\n    /// defines the meaning of the `uint256[]` for its own storage logic.\\n    ///\\n    /// @param namespace The unqualified namespace for the set that MUST be\\n    /// fully qualified by the `IInterpreterStoreV1` to prevent key collisions\\n    /// between callers. The fully qualified namespace forms a compound key with\\n    /// the keys for each value to set.\\n    /// @param kvs The list of changes to apply to the store's internal state.\\n    function set(StateNamespace namespace, uint256[] calldata kvs) external;\\n\\n    /// Given a fully qualified namespace and key, return the associated value.\\n    /// Ostensibly the interpreter can use this to implement opcodes that read\\n    /// previously set values. The interpreter MUST apply the same qualification\\n    /// logic as the store that it uses to guarantee consistent round tripping of\\n    /// data and prevent malicious behaviours. Technically also allows onchain\\n    /// reads of any set value from any contract, not just interpreters, but in\\n    /// this case readers MUST be aware and handle inconsistencies between get\\n    /// and set while the state changes are still in memory in the calling\\n    /// context and haven't yet been persisted to the store.\\n    ///\\n    /// `IInterpreterStoreV1` uses the same fallback behaviour for unset keys as\\n    /// Solidity. Specifically, any UNSET VALUES SILENTLY FALLBACK TO `0`.\\n    /// @param namespace The fully qualified namespace to get a single value for.\\n    /// @param key The key to get the value for within the namespace.\\n    /// @return The value OR ZERO IF NOT SET.\\n    function get(FullyQualifiedNamespace namespace, uint256 key) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"lib/rain.interpreter/src/interface/IInterpreterV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\nimport \\\"./IInterpreterStoreV1.sol\\\";\\n\\n/// @dev The index of a source within a deployed expression that can be evaluated\\n/// by an `IInterpreterV1`. MAY be an entrypoint or the index of a source called\\n/// internally such as by the `call` opcode.\\ntype SourceIndex is uint16;\\n\\n/// @dev Encoded information about a specific evaluation including the expression\\n/// address onchain, entrypoint and expected return values.\\ntype EncodedDispatch is uint256;\\n\\n/// @dev The namespace for state changes as requested by the calling contract.\\n/// The interpreter MUST apply this namespace IN ADDITION to namespacing by\\n/// caller etc.\\ntype StateNamespace is uint256;\\n\\n/// @dev Additional bytes that can be used to configure a single opcode dispatch.\\n/// Commonly used to specify the number of inputs to a variadic function such\\n/// as addition or multiplication.\\ntype Operand is uint256;\\n\\n/// @dev The default state namespace MUST be used when a calling contract has no\\n/// particular opinion on or need for dynamic namespaces.\\nStateNamespace constant DEFAULT_STATE_NAMESPACE = StateNamespace.wrap(0);\\n\\n/// @title IInterpreterV1\\n/// Interface into a standard interpreter that supports:\\n///\\n/// - evaluating `view` logic deployed onchain by an `IExpressionDeployerV1`\\n/// - receiving arbitrary `uint256[][]` supporting context to be made available\\n///   to the evaluated logic\\n/// - handling subsequent state changes in bulk in response to evaluated logic\\n/// - namespacing state changes according to the caller's preferences to avoid\\n///   unwanted key collisions\\n/// - exposing its internal function pointers to support external precompilation\\n///   of logic for more gas efficient runtime evaluation by the interpreter\\n///\\n/// The interface is designed to be stable across many versions and\\n/// implementations of an interpreter, balancing minimalism with features\\n/// required for a general purpose onchain interpreted compute environment.\\n///\\n/// The security model of an interpreter is that it MUST be resilient to\\n/// malicious expressions even if they dispatch arbitrary internal function\\n/// pointers during an eval. The interpreter MAY return garbage or exhibit\\n/// undefined behaviour or error during an eval, _provided that no state changes\\n/// are persisted_ e.g. in storage, such that only the caller that specifies the\\n/// malicious expression can be negatively impacted by the result. In turn, the\\n/// caller must guard itself against arbitrarily corrupt/malicious reverts and\\n/// return values from any interpreter that it requests an expression from. And\\n/// so on and so forth up to the externally owned account (EOA) who signs the\\n/// transaction and agrees to a specific combination of contracts, expressions\\n/// and interpreters, who can presumably make an informed decision about which\\n/// ones to trust to get the job done.\\n///\\n/// The state changes for an interpreter are expected to be produces by an `eval`\\n/// and passed to the `IInterpreterStoreV1` returned by the eval, as-is by the\\n/// caller, after the caller has had an opportunity to apply their own\\n/// intermediate logic such as reentrancy defenses against malicious\\n/// interpreters. The interpreter is free to structure the state changes however\\n/// it wants but MUST guard against the calling contract corrupting the changes\\n/// between `eval` and `set`. For example a store could sandbox storage writes\\n/// per-caller so that a malicious caller can only damage their own state\\n/// changes, while honest callers respect, benefit from and are protected by the\\n/// interpreter store's state change handling.\\n///\\n/// The two step eval-state model allows eval to be read-only which provides\\n/// security guarantees for the caller such as no stateful reentrancy, either\\n/// from the interpreter or some contract interface used by some word, while\\n/// still allowing for storage writes. As the storage writes happen on the\\n/// interpreter rather than the caller (c.f. delegate call) the caller DOES NOT\\n/// need to trust the interpreter, which allows for permissionless selection of\\n/// interpreters by end users. Delegate call always implies an admin key on the\\n/// caller because the delegatee contract can write arbitrarily to the state of\\n/// the delegator, which severely limits the generality of contract composition.\\ninterface IInterpreterV1 {\\n    /// Exposes the function pointers as `uint16` values packed into a single\\n    /// `bytes` in the same order as they would be indexed into by opcodes. For\\n    /// example, if opcode `2` should dispatch function at position `0x1234` then\\n    /// the start of the returned bytes would be `0xXXXXXXXX1234` where `X` is\\n    /// a placeholder for the function pointers of opcodes `0` and `1`.\\n    ///\\n    /// `IExpressionDeployerV1` contracts use these function pointers to\\n    /// \\\"compile\\\" the expression into something that an interpreter can dispatch\\n    /// directly without paying gas to lookup the same at runtime. As the\\n    /// validity of any integrity check and subsequent dispatch is highly\\n    /// sensitive to both the function pointers and overall bytecode of the\\n    /// interpreter, `IExpressionDeployerV1` contracts SHOULD implement guards\\n    /// against accidentally being deployed onchain paired against an unknown\\n    /// interpreter. It is very easy for an apparent compatible pairing to be\\n    /// subtly and critically incompatible due to addition/removal/reordering of\\n    /// opcodes and compiler optimisations on the interpreter bytecode.\\n    ///\\n    /// This MAY return different values during construction vs. all other times\\n    /// after the interpreter has been successfully deployed onchain. DO NOT rely\\n    /// on function pointers reported during contract construction.\\n    function functionPointers() external view returns (bytes memory);\\n\\n    /// The raison d'etre for an interpreter. Given some expression and per-call\\n    /// additional contextual data, produce a stack of results and a set of state\\n    /// changes that the caller MAY OPTIONALLY pass back to be persisted by a\\n    /// call to `IInterpreterStoreV1.set`.\\n    /// @param store The storage contract that the returned key/value pairs\\n    /// MUST be passed to IF the calling contract is in a non-static calling\\n    /// context. Static calling contexts MUST pass `address(0)`.\\n    /// @param namespace The state namespace that will be fully qualified by the\\n    /// interpreter at runtime in order to perform gets on the underlying store.\\n    /// MUST be the same namespace passed to the store by the calling contract\\n    /// when sending the resulting key/value items to storage.\\n    /// @param dispatch All the information required for the interpreter to load\\n    /// an expression, select an entrypoint and return the values expected by the\\n    /// caller. The interpreter MAY encode dispatches differently to\\n    /// `LibEncodedDispatch` but this WILL negatively impact compatibility for\\n    /// calling contracts that hardcode the encoding logic.\\n    /// @param context A 2-dimensional array of data that can be indexed into at\\n    /// runtime by the interpreter. The calling contract is responsible for\\n    /// ensuring the authenticity and completeness of context data. The\\n    /// interpreter MUST revert at runtime if an expression attempts to index\\n    /// into some context value that is not provided by the caller. This implies\\n    /// that context reads cannot be checked for out of bounds reads at deploy\\n    /// time, as the runtime context MAY be provided in a different shape to what\\n    /// the expression is expecting.\\n    /// Same as `eval` but allowing the caller to specify a namespace under which\\n    /// the state changes will be applied. The interpeter MUST ensure that keys\\n    /// will never collide across namespaces, even if, for example:\\n    ///\\n    /// - The calling contract is malicious and attempts to craft a collision\\n    ///   with state changes from another contract\\n    /// - The expression is malicious and attempts to craft a collision with\\n    ///   other expressions evaluated by the same calling contract\\n    ///\\n    /// A malicious entity MAY have access to significant offchain resources to\\n    /// attempt to precompute key collisions through brute force. The collision\\n    /// resistance of namespaces should be comparable or equivalent to the\\n    /// collision resistance of the hashing algorithms employed by the blockchain\\n    /// itself, such as the design of `mapping` in Solidity that hashes each\\n    /// nested key to produce a collision resistant compound key.\\n    /// @return stack The list of values produced by evaluating the expression.\\n    /// MUST NOT be longer than the maximum length specified by `dispatch`, if\\n    /// applicable.\\n    /// @return kvs A list of pairwise key/value items to be saved in the store.\\n    function eval(\\n        IInterpreterStoreV1 store,\\n        StateNamespace namespace,\\n        EncodedDispatch dispatch,\\n        uint256[][] calldata context\\n    ) external view returns (uint256[] memory stack, uint256[] memory kvs);\\n}\\n\"\r\n    },\r\n    \"lib/rain.interpreter/src/lib/caller/LibContext.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\nimport \\\"rain.solmem/lib/LibUint256Array.sol\\\";\\nimport \\\"rain.lib.hash/LibHashNoAlloc.sol\\\";\\n\\nimport {SignatureChecker} from \\\"openzeppelin-contracts/contracts/utils/cryptography/SignatureChecker.sol\\\";\\nimport {ECDSA} from \\\"openzeppelin-contracts/contracts/utils/cryptography/ECDSA.sol\\\";\\n\\nimport \\\"../../interface/IInterpreterCallerV2.sol\\\";\\n\\n/// Thrown when the ith signature from a list of signed contexts is invalid.\\nerror InvalidSignature(uint256 i);\\n\\n/// @title LibContext\\n/// @notice Conventions for working with context as a calling contract. All of\\n/// this functionality is OPTIONAL but probably useful for the majority of use\\n/// cases. By building and authenticating onchain, caller provided and signed\\n/// contexts all in a standard way the overall usability of context is greatly\\n/// improved for expression authors and readers. Any calling contract that can\\n/// match the context expectations of an existing expression is one large step\\n/// closer to compatibility and portability, inheriting network effects of what\\n/// has already been authored elsewhere.\\nlibrary LibContext {\\n    using LibUint256Array for uint256[];\\n\\n    /// The base context is the `msg.sender` and address of the calling contract.\\n    /// As the interpreter itself is called via an external interface and may be\\n    /// statically calling itself, it MAY NOT have any ability to inspect either\\n    /// of these values. Even if this were not the case the calling contract\\n    /// cannot assume the existence of some opcode(s) in the interpreter that\\n    /// inspect the caller, so providing these two values as context is\\n    /// sufficient to decouple the calling contract from the interpreter. It is\\n    /// STRONGLY RECOMMENDED that even if the calling contract has \\\"no context\\\"\\n    /// that it still provides this base to every `eval`.\\n    ///\\n    /// Calling contracts DO NOT need to call this directly. It is built and\\n    /// merged automatically into the standard context built by `build`.\\n    ///\\n    /// @return The `msg.sender` and address of the calling contract using this\\n    /// library, as a context-compatible array.\\n    function base() internal view returns (uint256[] memory) {\\n        return LibUint256Array.arrayFrom(uint256(uint160(msg.sender)), uint256(uint160(address(this))));\\n    }\\n\\n    /// Standard hashing process over a single `SignedContextV1`. Notably used\\n    /// to hash a list as `SignedContextV1[]` but could also be used to hash a\\n    /// single `SignedContextV1` in isolation. Avoids allocating memory by\\n    /// hashing each struct field in sequence within the memory scratch space.\\n    /// @param signedContext The signed context to hash.\\n    /// @param hashed The hashed signed context.\\n    function hash(SignedContextV1 memory signedContext) internal pure returns (bytes32 hashed) {\\n        uint256 signerOffset = SIGNED_CONTEXT_SIGNER_OFFSET;\\n        uint256 contextOffset = SIGNED_CONTEXT_CONTEXT_OFFSET;\\n        uint256 signatureOffset = SIGNED_CONTEXT_SIGNATURE_OFFSET;\\n\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(0, keccak256(add(signedContext, signerOffset), 0x20))\\n\\n            let context_ := mload(add(signedContext, contextOffset))\\n            mstore(0x20, keccak256(add(context_, 0x20), mul(mload(context_), 0x20)))\\n\\n            mstore(0, keccak256(0, 0x40))\\n\\n            let signature_ := mload(add(signedContext, signatureOffset))\\n            mstore(0x20, keccak256(add(signature_, 0x20), mload(signature_)))\\n\\n            hashed := keccak256(0, 0x40)\\n        }\\n    }\\n\\n    /// Standard hashing process over a list of signed contexts. Situationally\\n    /// useful if the calling contract wants to record that it has seen a set of\\n    /// signed data then later compare it against some input (e.g. to ensure that\\n    /// many calls of some function all share the same input values). Note that\\n    /// unlike the internals of `build`, this hashes over the signer and the\\n    /// signature, to ensure that some data cannot be re-signed and used under\\n    /// a different provenance later.\\n    /// @param signedContexts The list of signed contexts to hash over.\\n    /// @return hashed The hash of the signed contexts.\\n    function hash(SignedContextV1[] memory signedContexts) internal pure returns (bytes32 hashed) {\\n        uint256 cursor;\\n        uint256 end;\\n        bytes32 hashNil = HASH_NIL;\\n        assembly (\\\"memory-safe\\\") {\\n            cursor := add(signedContexts, 0x20)\\n            end := add(cursor, mul(mload(signedContexts), 0x20))\\n            mstore(0, hashNil)\\n        }\\n\\n        SignedContextV1 memory signedContext;\\n        bytes32 mem0;\\n        while (cursor < end) {\\n            assembly (\\\"memory-safe\\\") {\\n                signedContext := mload(cursor)\\n                // Subhash will write to 0 for its own hashing so keep a copy\\n                // before it gets overwritten.\\n                mem0 := mload(0)\\n            }\\n            bytes32 subHash = hash(signedContext);\\n            assembly (\\\"memory-safe\\\") {\\n                mstore(0, mem0)\\n                mstore(0x20, subHash)\\n                mstore(0, keccak256(0, 0x40))\\n                cursor := add(cursor, 0x20)\\n            }\\n        }\\n        assembly (\\\"memory-safe\\\") {\\n            hashed := mload(0)\\n        }\\n    }\\n\\n    /// Builds a standard 2-dimensional context array from base, calling and\\n    /// signed contexts. Note that \\\"columns\\\" of a context array refer to each\\n    /// `uint256[]` and each item within a `uint256[]` is a \\\"row\\\".\\n    ///\\n    /// @param baseContext Anything the calling contract can provide which MAY\\n    /// include input from the `msg.sender` of the calling contract. The default\\n    /// base context from `LibContext.base()` DOES NOT need to be provided by the\\n    /// caller, this matrix MAY be empty and will be simply merged into the final\\n    /// context. The base context matrix MUST contain a consistent number of\\n    /// columns from the calling contract so that the expression can always\\n    /// predict how many unsigned columns there will be when it runs.\\n    /// @param signedContexts Signed contexts are provided by the `msg.sender`\\n    /// but signed by a third party. The expression (author) defines _who_ may\\n    /// sign and the calling contract authenticates the signature over the\\n    /// signed data. Technically `build` handles all the authentication inline\\n    /// for the calling contract so if some context builds it can be treated as\\n    /// authentic. The builder WILL REVERT if any of the signatures are invalid.\\n    /// Note two things about the structure of the final built context re: signed\\n    /// contexts:\\n    /// - The first column is a list of the signers in order of what they signed\\n    /// - The `msg.sender` can provide an arbitrary number of signed contexts so\\n    ///   expressions DO NOT know exactly how many columns there are.\\n    /// The expression is responsible for defining e.g. a domain separator in a\\n    /// position that would force signed context to be provided in the \\\"correct\\\"\\n    /// order, rather than relying on the `msg.sender` to honestly present data\\n    /// in any particular structure/order.\\n    function build(uint256[][] memory baseContext, SignedContextV1[] memory signedContexts)\\n        internal\\n        view\\n        returns (uint256[][] memory)\\n    {\\n        unchecked {\\n            uint256[] memory signers = new uint256[](signedContexts.length);\\n\\n            // - LibContext.base() + whatever we are provided.\\n            // - signed contexts + signers if they exist else nothing.\\n            uint256 contextLength = 1 + baseContext.length + (signedContexts.length > 0 ? signedContexts.length + 1 : 0);\\n\\n            uint256[][] memory context = new uint256[][](contextLength);\\n            uint256 offset = 0;\\n            context[offset] = LibContext.base();\\n\\n            for (uint256 i = 0; i < baseContext.length; i++) {\\n                offset++;\\n                context[offset] = baseContext[i];\\n            }\\n\\n            if (signedContexts.length > 0) {\\n                offset++;\\n                context[offset] = signers;\\n\\n                for (uint256 i = 0; i < signedContexts.length; i++) {\\n                    if (\\n                        // Unlike `LibContext.hash` we can only hash over\\n                        // the context as it's impossible for a signature\\n                        // to sign itself.\\n                        // Note the use of encodePacked here over a\\n                        // single array, not including the length. This\\n                        // would be a security issue if multiple dynamic\\n                        // length values were hashed over together as\\n                        // then many possible inputs could collide with\\n                        // a single encoded output.\\n                        !SignatureChecker.isValidSignatureNow(\\n                            signedContexts[i].signer,\\n                            ECDSA.toEthSignedMessageHash(LibHashNoAlloc.hashWords(signedContexts[i].context)),\\n                            signedContexts[i].signature\\n                        )\\n                    ) {\\n                        revert InvalidSignature(i);\\n                    }\\n\\n                    signers[i] = uint256(uint160(signedContexts[i].signer));\\n                    offset++;\\n                    context[offset] = signedContexts[i].context;\\n                }\\n            }\\n\\n            return context;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/rain.interpreter/src/lib/caller/LibDeployerDiscoverable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\nimport \\\"../../interface/IExpressionDeployerV1.sol\\\";\\n\\nlibrary LibDeployerDiscoverable {\\n    /// Hack so that some deployer will emit an event with the sender as the\\n    /// caller of `touchDeployer`. This MAY be needed by indexers such as\\n    /// subgraph that can only index events from the first moment they are aware\\n    /// of some contract. The deployer MUST be registered in ERC1820 registry\\n    /// before it is touched, THEN the caller meta MUST be emitted after the\\n    /// deployer is touched. This allows indexers such as subgraph to index the\\n    /// deployer, then see the caller, then see the caller's meta emitted in the\\n    /// same transaction.\\n    /// This is NOT required if ANY other expression is deployed in the same\\n    /// transaction as the caller meta, there only needs to be one expression on\\n    /// ANY deployer known to ERC1820.\\n    function touchDeployerV1(address deployer) internal {\\n        (IInterpreterV1 interpreter, IInterpreterStoreV1 store, address expression) =\\n            IExpressionDeployerV1(deployer).deployExpression(new bytes[](0), new uint256[](0), new uint256[](0));\\n        (interpreter);\\n        (store);\\n        (expression);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/rain.interpreter/src/lib/caller/LibEncodedDispatch.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\nimport \\\"../../interface/IInterpreterV1.sol\\\";\\n\\n/// @title LibEncodedDispatch\\n/// @notice Establishes and implements a convention for encoding an interpreter\\n/// dispatch. Handles encoding of several things required for efficient dispatch.\\nlibrary LibEncodedDispatch {\\n    /// Builds an `EncodedDispatch` from its constituent parts.\\n    /// @param expression The onchain address of the expression to run.\\n    /// @param sourceIndex The index of the source to run within the expression\\n    /// as an entrypoint.\\n    /// @param maxOutputs The maximum outputs the caller can meaningfully use.\\n    /// If the interpreter returns a larger stack than this it is merely wasting\\n    /// gas across the external call boundary.\\n    /// @return The encoded dispatch.\\n    function encode(address expression, SourceIndex sourceIndex, uint16 maxOutputs)\\n        internal\\n        pure\\n        returns (EncodedDispatch)\\n    {\\n        return EncodedDispatch.wrap(\\n            (uint256(uint160(expression)) << 32) | (uint256(SourceIndex.unwrap(sourceIndex)) << 16) | maxOutputs\\n        );\\n    }\\n\\n    /// Decodes an `EncodedDispatch` to its constituent parts.\\n    /// @param dispatch_ The `EncodedDispatch` to decode.\\n    /// @return The expression, source index, and max outputs as per `encode`.\\n    function decode(EncodedDispatch dispatch_) internal pure returns (address, SourceIndex, uint16) {\\n        return (\\n            address(uint160(EncodedDispatch.unwrap(dispatch_) >> 32)),\\n            SourceIndex.wrap(uint16(EncodedDispatch.unwrap(dispatch_) >> 16)),\\n            uint16(EncodedDispatch.unwrap(dispatch_))\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/rain.interpreter/src/lib/caller/LibEvaluable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\nimport \\\"../../interface/IExpressionDeployerV1.sol\\\";\\nimport \\\"../../interface/IInterpreterStoreV1.sol\\\";\\nimport \\\"../../interface/IInterpreterV1.sol\\\";\\n\\n/// Standard struct that can be embedded in ABIs in a consistent format for\\n/// tooling to read/write. MAY be useful to bundle up the data required to call\\n/// `IExpressionDeployerV1` but is NOT mandatory.\\n/// @param deployer Will deploy the expression from sources and constants.\\n/// @param sources Will be deployed to an expression address for use in\\n/// `Evaluable`.\\n/// @param constants Will be available to the expression at runtime.\\nstruct EvaluableConfig {\\n    IExpressionDeployerV1 deployer;\\n    bytes[] sources;\\n    uint256[] constants;\\n}\\n\\n/// Struct over the return of `IExpressionDeployerV1.deployExpression`\\n/// which MAY be more convenient to work with than raw addresses.\\n/// @param interpreter Will evaluate the expression.\\n/// @param store Will store state changes due to evaluation of the expression.\\n/// @param expression Will be evaluated by the interpreter.\\nstruct Evaluable {\\n    IInterpreterV1 interpreter;\\n    IInterpreterStoreV1 store;\\n    address expression;\\n}\\n\\n/// @title LibEvaluable\\n/// @notice Common logic to provide consistent implementations of common tasks\\n/// that could be arbitrarily/ambiguously implemented, but work much better if\\n/// consistently implemented.\\nlibrary LibEvaluable {\\n    /// Hashes an `Evaluable`, ostensibly so that only the hash need be stored,\\n    /// thus only storing a single `uint256` instead of 3x `uint160`.\\n    /// @param evaluable_ The evaluable to hash.\\n    /// @return hash_ Standard hash of the evaluable.\\n    function hash(Evaluable memory evaluable_) internal pure returns (bytes32 hash_) {\\n        // `Evaluable` does NOT contain any dynamic types so it is safe to encode\\n        // packed for hashing, and is preferable due to the smaller/simpler\\n        // in-memory structure. It also makes it easier to replicate the logic\\n        // offchain as a simple concatenation of bytes.\\n        assembly (\\\"memory-safe\\\") {\\n            hash_ := keccak256(evaluable_, 0x60)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/rain.lib.memkv/lib/rain.lib.hash/src/LibHashNoAlloc.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\nbytes32 constant HASH_NIL = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n\\n/// @title LibHashNoAlloc\\n/// @notice When producing hashes of just about anything that isn't already bytes\\n/// the common suggestions look something like `keccak256(abi.encode(...))` or\\n/// `keccak256(abi.encodePacked(...))` with the main differentiation being\\n/// whether dynamic data types are being hashed. If they are then there is a hash\\n/// collision risk in the packed case as `\\\"abc\\\" + \\\"def\\\"` and `\\\"ab\\\" + \\\"cdef\\\"` will\\n/// pack and therefore hash to the same values, the suggested fix commonly being\\n/// to use abi.encode, which includes the lengths disambiguating dynamic data.\\n/// Something like `3\\\"abc\\\" + 3\\\"def\\\"` with the length prefixes won't collide with\\n/// `2\\\"ab\\\" + 4\\\"cdef\\\"` but note that ABI provides neither a strong guarantee to\\n/// be collision resitant on inputs (as far as I know, it's a coincidence that\\n/// this works), nor an efficient solution.\\n///\\n/// - Abi encoding is a complex algorithm that is easily 1k+ gas for simple\\n///   structs with just one or two dynamic typed fields.\\n/// - Abi encoding requires allocating and copying all the data plus a header to\\n///   a new region of memory, which gives it non-linearly increasing costs due to\\n///   memory expansion.\\n/// - Abi encoding can't easily be reproduced offchain without specialised tools,\\n///   it's not simply a matter of length prefixing some byte string and hashing\\n///   with keccak256, the heads and tails all need to be produced recursively\\n///   https://docs.soliditylang.org/en/develop/abi-spec.html#formal-specification-of-the-encoding\\n///\\n/// Consider that `hash(hash(\\\"abc\\\") + hash(\\\"def\\\"))` won't collide with\\n/// `hash(hash(\\\"ab\\\") + hash(\\\"cdef\\\"))`. It should be easier to convince ourselves\\n/// this is true for all possible pairs of byte strings than it is to convince\\n/// ourselves that the ABI serialization is never ambigious. Inductively we can\\n/// scale this to all possible data structures that are ordered compositions of\\n/// byte strings. Even better, the native behaviour of `keccak256` in the EVM\\n/// requires no additional allocation of memory. Worst case scenario is that we\\n/// want to hash several hashes together like `hash(hash0, hash1, ...)`, in which\\n/// case we can write the words after the free memory pointer, hash them, but\\n/// leave the pointer. This way we pay for memory expansion but can re-use that\\n/// region of memory for subsequent logic, which may effectively make the\\n/// expansion free as we would have needed to pay for it anyway. Given that hash\\n/// checks often occur early in real world logic due to\\n/// checks-effects-interactions, this is not an unreasonable assumption to call\\n/// this kind of expansion \\\"no alloc\\\".\\n///\\n/// One problem is that the gas saving for trivial abi encoding,\\n/// e.g. ~1-3 uint256 values, can be lost by the overhead of jumps and stack\\n/// manipulation due to function calls.\\n///\\n/// ```\\n/// struct Foo {\\n///   uint256 a;\\n///   address b;\\n///   uint32 c;\\n/// }\\n/// ```\\n/// The simplest way to hash `Foo` is to just hash it (crazy, i know!).\\n///\\n/// ```\\n/// assembly (\\\"memory-safe\\\") {\\n///   hash_ := keccak256(foo_, 0x60)\\n/// }\\n/// ```\\n/// Every struct field is 0x20 bytes in memory so 3 fields = 0x60 bytes to hash\\n/// always, with the exception of dynamic types. This costs about 70 gas vs.\\n/// about 350 gas for an abi encoding based approach.\\nlibrary LibHashNoAlloc {\\n    function hashBytes(bytes memory data_) internal pure returns (bytes32 hash_) {\\n        assembly (\\\"memory-safe\\\") {\\n            hash_ := keccak256(add(data_, 0x20), mload(data_))\\n        }\\n    }\\n\\n    function hashWords(bytes32[] memory words_) internal pure returns (bytes32 hash_) {\\n        assembly (\\\"memory-safe\\\") {\\n            hash_ := keccak256(add(words_, 0x20), mul(mload(words_), 0x20))\\n        }\\n    }\\n\\n    function hashWords(uint256[] memory words_) internal pure returns (bytes32 hash_) {\\n        assembly (\\\"memory-safe\\\") {\\n            hash_ := keccak256(add(words_, 0x20), mul(mload(words_), 0x20))\\n        }\\n    }\\n\\n    function combineHashes(bytes32 a_, bytes32 b_) internal pure returns (bytes32 hash_) {\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(0, a_)\\n            mstore(0x20, b_)\\n            hash_ := keccak256(0, 0x40)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/rain.metadata/src/IMetaV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\n/// Thrown when hashed metadata does NOT match the expected hash.\\n/// @param expectedHash The hash expected by the `IMetaV1` contract.\\n/// @param actualHash The hash of the metadata seen by the `IMetaV1` contract.\\nerror UnexpectedMetaHash(bytes32 expectedHash, bytes32 actualHash);\\n\\n/// Thrown when some bytes are expected to be rain meta and are not.\\n/// @param unmeta the bytes that are not meta.\\nerror NotRainMetaV1(bytes unmeta);\\n\\n/// @dev Randomly generated magic number with first bytes oned out.\\n/// https://github.com/rainprotocol/specs/blob/main/metadata-v1.md\\nuint64 constant META_MAGIC_NUMBER_V1 = 0xff0a89c674ee7874;\\n\\n/// @title IMetaV1\\ninterface IMetaV1 {\\n    /// An onchain wrapper to carry arbitrary Rain metadata. Assigns the sender\\n    /// to the metadata so that tooling can easily drop/ignore data from unknown\\n    /// sources. As metadata is about something, the subject MUST be provided.\\n    /// @param sender The msg.sender.\\n    /// @param subject The entity that the metadata is about. MAY be the address\\n    /// of the emitting contract (as `uint256`) OR anything else. The\\n    /// interpretation of the subject is context specific, so will often be a\\n    /// hash of some data/thing that this metadata is about.\\n    /// @param meta Rain metadata V1 compliant metadata bytes.\\n    /// https://github.com/rainprotocol/specs/blob/main/metadata-v1.md\\n    event MetaV1(address sender, uint256 subject, bytes meta);\\n}\\n\"\r\n    },\r\n    \"lib/rain.metadata/src/LibMeta.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\nimport \\\"./IMetaV1.sol\\\";\\n\\n/// @title LibMeta\\n/// @notice Need a place to put data that can be handled offchain like ABIs that\\n/// IS NOT etherscan.\\nlibrary LibMeta {\\n    /// Returns true if the metadata bytes are prefixed by the Rain meta magic\\n    /// number. DOES NOT attempt to validate the body of the metadata as offchain\\n    /// tooling will be required for this.\\n    /// @param meta_ The data that may be rain metadata.\\n    /// @return True if `meta_` is metadata, false otherwise.\\n    function isRainMetaV1(bytes memory meta_) internal pure returns (bool) {\\n        if (meta_.length < 8) return false;\\n        uint256 mask_ = type(uint64).max;\\n        uint256 magicNumber_ = META_MAGIC_NUMBER_V1;\\n        assembly (\\\"memory-safe\\\") {\\n            magicNumber_ := and(mload(add(meta_, 8)), mask_)\\n        }\\n        return magicNumber_ == META_MAGIC_NUMBER_V1;\\n    }\\n\\n    /// Reverts if the provided `meta_` is NOT metadata according to\\n    /// `isRainMetaV1`.\\n    /// @param meta_ The metadata bytes to check.\\n    function checkMetaUnhashed(bytes memory meta_) internal pure {\\n        if (!isRainMetaV1(meta_)) {\\n            revert NotRainMetaV1(meta_);\\n        }\\n    }\\n\\n    /// Reverts if the provided `meta_` is NOT metadata according to\\n    /// `isRainMetaV1` OR it does not match the expected hash of its data.\\n    /// @param meta_ The metadata to check.\\n    function checkMetaHashed(bytes32 expectedHash_, bytes memory meta_) internal pure {\\n        bytes32 actualHash_ = keccak256(meta_);\\n        if (expectedHash_ != actualHash_) {\\n            revert UnexpectedMetaHash(expectedHash_, actualHash_);\\n        }\\n        checkMetaUnhashed(meta_);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/abstract/OrderBookFlashBorrower.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.19;\\n\\nimport {ERC165, IERC165} from \\\"openzeppelin-contracts/contracts/utils/introspection/ERC165.sol\\\";\\nimport {SafeERC20} from \\\"openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport {Address} from \\\"openzeppelin-contracts/contracts/utils/Address.sol\\\";\\nimport {IERC20} from \\\"openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\\\";\\nimport {ReentrancyGuard} from \\\"openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\\\";\\nimport {Initializable} from \\\"openzeppelin-contracts/contracts/proxy/utils/Initializable.sol\\\";\\nimport {\\n    DeployerDiscoverableMetaV1,\\n    DeployerDiscoverableMetaV1ConstructionConfig,\\n    LibMeta\\n} from \\\"rain.interpreter/abstract/DeployerDiscoverableMetaV1.sol\\\";\\n\\nimport \\\"../interface/IOrderBookV2.sol\\\";\\nimport \\\"rain.factory/src/interface/ICloneableV2.sol\\\";\\nimport \\\"rain.interpreter/lib/caller/LibEncodedDispatch.sol\\\";\\nimport \\\"rain.interpreter/lib/caller/LibContext.sol\\\";\\n\\n/// Thrown when the lender is not the trusted `OrderBook`.\\n/// @param badLender The untrusted lender calling `onFlashLoan`.\\nerror BadLender(address badLender);\\n\\n/// Thrown when the initiator is not `ZeroExOrderBookFlashBorrower`.\\n/// @param badInitiator The untrusted initiator of the flash loan.\\nerror BadInitiator(address badInitiator);\\n\\n/// Thrown when the flash loan fails somehow.\\nerror FlashLoanFailed();\\n\\n/// Thrown when calling functions while the contract is still initializing.\\nerror Initializing();\\n\\n/// Thrown when the swap fails.\\nerror SwapFailed();\\n\\n/// Thrown when the minimum output for the sender is not met after the arb.\\n/// @param minimum The minimum output expected by the sender.\\n/// @param actual The actual output that would be received by the sender.\\nerror MinimumOutput(uint256 minimum, uint256 actual);\\n\\n/// Thrown when the stack is not empty after the access control dispatch.\\nerror NonZeroBeforeArbStack();\\n\\n/// Config for `OrderBookFlashBorrower` to initialize.\\n/// @param orderBook The `OrderBook` contract to arb against.\\n/// @param evaluableConfig The config to eval for access control to arb.\\n/// @param implementationData Arbitrary bytes to pass to the implementation in\\n/// the `beforeInitialize` hook.\\nstruct OrderBookFlashBorrowerConfig {\\n    address orderBook;\\n    EvaluableConfig evaluableConfig;\\n    bytes implementationData;\\n}\\n\\n/// @dev \\\"Before arb\\\" is evaluated before the flash loan is taken. Ostensibly\\n/// allows for some kind of access control to the arb.\\nSourceIndex constant BEFORE_ARB_SOURCE_INDEX = SourceIndex.wrap(0);\\n/// @dev \\\"Before arb\\\" has no outputs.\\nuint256 constant BEFORE_ARB_MIN_OUTPUTS = 0;\\n/// @dev \\\"Before arb\\\" has no outputs.\\nuint16 constant BEFORE_ARB_MAX_OUTPUTS = 0;\\n\\n/// @title OrderBookFlashBorrower\\n/// @notice Abstract contract that liq-source specifialized contracts can inherit\\n/// to provide flash loan based arbitrage against external liquidity sources to\\n/// fill orderbook orders.\\n///\\n/// For example consider a simple order:\\n///\\n/// input = DAI\\n/// output = USDT\\n/// IORatio = 1.01e18\\n/// Order amount = 100e18\\n///\\n/// Assume external liq is offering 102 DAI per USDT so it exceeds the IO ratio\\n/// but the order itself has no way to interact with the external contract.\\n/// The `OrderBookFlashBorrower` can:\\n///\\n/// - Flash loan 100 USDT from `Orderbook`\\n/// - Sell the 100 USDT for 102 DAI on external liq\\n/// - Take the order, giving 101 DAI and paying down 100 USDT loan\\n/// - Keep 1 DAI profit\\n///\\n/// As this contract is expected to be cloned using a minimal proxy there will\\n/// be many copies of it in the wild. Each copy can be access gated by a Rain\\n/// expression that is evaluated before anything else happens in `arb`. There\\n/// are many reasons why this might be desirable:\\n/// - Regulatory reasons that restrict how an arb bot operator can interact with\\n///   orders and/or external liq.\\n/// - The arb operator wants to attempt to prevent front running by other bots.\\n/// - The arb operator may prefer a dedicated instance of the contract to make\\n///   it easier to track profits, etc.\\nabstract contract OrderBookFlashBorrower is\\n    IERC3156FlashBorrower,\\n    ICloneableV2,\\n    ReentrancyGuard,\\n    Initializable,\\n    DeployerDiscoverableMetaV1,\\n    ERC165\\n{\\n    using Address for address;\\n    using SafeERC20 for IERC20;\\n\\n    /// Emitted when the contract is initialized. Contains the\\n    /// OrderBookFlashBorrowerConfig struct to ensure the type appears in the\\n    /// ABI.\\n    event Initialize(address sender, OrderBookFlashBorrowerConfig config);\\n\\n    /// `OrderBook` contract to lend and arb against.\\n    IOrderBookV2 public sOrderBook;\\n\\n    /// The encoded dispatch that will run for access control to `arb`.\\n    EncodedDispatch public sI9rDispatch;\\n    /// The interpreter that will eval access control to `arb`.\\n    IInterpreterV1 public sI9r;\\n    /// The associated store for the interpreter.\\n    IInterpreterStoreV1 public sI9rStore;\\n\\n    constructor(bytes32 metaHash, DeployerDiscoverableMetaV1ConstructionConfig memory config)\\n        DeployerDiscoverableMetaV1(metaHash, config)\\n    {\\n        // Arb contracts are expected to be cloned proxies so allowing\\n        // initialization of the implementation is a security risk.\\n        _disableInitializers();\\n    }\\n\\n    /// @inheritdoc IERC165\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC3156FlashBorrower).interfaceId || interfaceId == type(ICloneableV2).interfaceId\\n            || super.supportsInterface(interfaceId);\\n    }\\n\\n    /// Hook called before initialize happens. Inheriting contracts can perform\\n    /// internal state maintenance before any external contract calls are made.\\n    /// @param data Arbitrary bytes the child may use to initialize.\\n    //slither-disable-next-line dead-code\\n    function _beforeInitialize(bytes memory data) internal virtual {}\\n\\n    /// Type hints for the input encoding for the `initialize` function.\\n    /// Reverts ALWAYS with `InitializeSignatureFn` as per ICloneableV2.\\n    function initialize(OrderBookFlashBorrowerConfig memory) external pure returns (bytes32) {\\n        revert InitializeSignatureFn();\\n    }\\n\\n    /// @inheritdoc ICloneableV2\\n    function initialize(bytes memory data) external initializer nonReentrant returns (bytes32) {\\n        (OrderBookFlashBorrowerConfig memory config) = abi.decode(data, (OrderBookFlashBorrowerConfig));\\n\\n        // Dispatch the hook before any external calls are made.\\n        _beforeInitialize(config.implementationData);\\n\\n        // @todo This could be paramaterised on `arb`.\\n        sOrderBook = IOrderBookV2(config.orderBook);\\n\\n        // Emit events before any external calls are made.\\n        emit Initialize(msg.sender, config);\\n\\n        // If there are sources to eval then initialize the dispatch, otherwise\\n        // it will remain 0 and we can skip evaluation on `arb`.\\n        if (config.evaluableConfig.sources.length > 0 && config.evaluableConfig.sources[0].length > 0) {\\n            address expression;\\n\\n            uint256[] memory entrypoints = new uint256[](1);\\n            entrypoints[SourceIndex.unwrap(BEFORE_ARB_SOURCE_INDEX)] = BEFORE_ARB_MIN_OUTPUTS;\\n\\n            // We have to trust the deployer because it produces the expression\\n            // address for the dispatch anyway.\\n            // All external functions on this contract have `onlyNotInitializing`\\n            // modifier on them so can't be reentered here anyway.\\n            //slither-disable-next-line reentrancy-benign\\n            (sI9r, sI9rStore, expression) = config.evaluableConfig.deployer.deployExpression(\\n                config.evaluableConfig.sources, config.evaluableConfig.constants, entrypoints\\n            );\\n            sI9rDispatch = LibEncodedDispatch.encode(expression, BEFORE_ARB_SOURCE_INDEX, BEFORE_ARB_MAX_OUTPUTS);\\n        }\\n\\n        return ICLONEABLE_V2_SUCCESS;\\n    }\\n\\n    /// Ensure the contract is not initializing.\\n    modifier onlyNotInitializing() {\\n        if (_isInitializing()) {\\n            revert Initializing();\\n        }\\n        _;\\n    }\\n\\n    /// Hook that inheriting contracts MUST implement in order to achieve\\n    /// anything other than raising the ambient temperature of the room.\\n    /// `_exchange` is responsible for converting the flash loaned assets into\\n    /// the assets required to fill the orders. Generally this can only be\\n    /// achieved by interacting with an external liquidity source that is\\n    /// offering a better price than the orders require.\\n    /// @param takeOrders As per `arb`.\\n    /// @param exchangeData As per `arb`.\\n    //slither-disable-next-line dead-code\\n    function _exchange(TakeOrdersConfig memory takeOrders, bytes memory exchangeData) internal virtual {}\\n\\n    /// @inheritdoc IERC3156FlashBorrower\\n    function onFlashLoan(address initiator, address, uint256, uint256, bytes calldata data)\\n        external\\n        onlyNotInitializing\\n        returns (bytes32)\\n    {\\n        // As per reference implementation.\\n        if (msg.sender != address(sOrderBook)) {\\n            revert BadLender(msg.sender);\\n        }\\n        // As per reference implementation.\\n        if (initiator != address(this)) {\\n            revert BadInitiator(initiator);\\n        }\\n\\n        (TakeOrdersConfig memory takeOrders, bytes memory exchangeData) = abi.decode(data, (TakeOrdersConfig, bytes));\\n\\n        // Dispatch the `_exchange` hook to ensure we have the correct asset\\n        // type and amount to fill the orders.\\n        _exchange(takeOrders, exchangeData);\\n\\n        // At this point `exchange` should have sent the tokens required to match\\n        // the orders so take orders now.\\n        // We don't do anything with the total input/output amounts here because\\n        // the flash loan itself will take back what it needs, and we simply\\n        // keep anything left over according to active balances.\\n        (uint256 totalInput, uint256 totalOutput) = sOrderBook.takeOrders(takeOrders);\\n        (totalInput, totalOutput);\\n\\n        return ON_FLASH_LOAN_CALLBACK_SUCCESS;\\n    }\\n\\n    /// Primary function to process arbitrage opportunities.\\n    /// Firstly the access gate is evaluated to ensure the sender is allowed to\\n    /// submit arbitrage. If there is no access control the sender should expect\\n    /// to be front run on the arb for any sufficiently profitable opportunity.\\n    /// This may be desirable in some cases, as the sender may simply want to\\n    /// be clearing the orderbook and they are expecting profit/utility from the\\n    /// orderbook strategies themselves somehow.\\n    ///\\n    /// Secondly the flash loan is taken and the `_exchange` hook is called to\\n    /// allow the inheriting contract to convert the flash loaned assets into\\n    /// the assets required to fill the orders.\\n    ///\\n    /// Finally the orders are taken and the remaining assets are sent to the\\n    /// sender.\\n    ///\\n    /// @param takeOrders As per `IOrderBookV2.takeOrders`.\\n    /// @param minimumSenderOutput The minimum output that must be sent to the\\n    /// sender by the end of the arb call. This, in combination with the\\n    /// orderbook's own asset handling, is expected to REPLACE the standard\\n    /// slippage protection that would be provided by a DEX. The sender is\\n    /// expected to calculate absolute values based on prevailing conditions\\n    /// such as gas price and the risk of holding the assets any arb profit is\\n    /// denominated in.\\n    /// @param exchangeData Arbitrary bytes that will be passed to `_exchange`\\n    /// after the flash loan is taken. The inheriting contract is responsible\\n    /// for decoding this data and defining how it controls interactions with\\n    /// the external liquidity. For example, `GenericPoolOrderBookFlashBorrower`\\n    /// uses this data as a literal encoded external call.\\n    function arb(TakeOrdersConfig calldata takeOrders, uint256 minimumSenderOutput, bytes calldata exchangeData)\\n        external\\n        nonReentrant\\n        onlyNotInitializing\\n    {\\n        // Encode everything that will be used by the flash loan callback.\\n        bytes memory data = abi.encode(takeOrders, exchangeData);\\n        // The token we receive from taking the orders is what we will use to\\n        // repay the flash loan.\\n        address flashLoanToken = takeOrders.input;\\n        // We can't repay more than the minimum that the orders are going to\\n        // give us and there's no reason to borrow less.\\n        uint256 flashLoanAmount = takeOrders.minimumInput;\\n\\n        // Run the access control dispatch if it is set.\\n        EncodedDispatch dispatch = sI9rDispatch;\\n        if (EncodedDispatch.unwrap(dispatch) > 0) {\\n            (uint256[] memory stack, uint256[] memory kvs) = sI9r.eval(\\n                sI9rStore,\\n                DEFAULT_STATE_NAMESPACE,\\n                dispatch,\\n                LibContext.build(new uint256[][](0), new SignedContextV1[](0))\\n            );\\n            // This can only happen if the interpreter is broken.\\n            if (stack.length > 0) {\\n                revert NonZeroBeforeArbStack();\\n            }\\n            // Persist any state changes from the expression.\\n            if (kvs.length > 0) {\\n                sI9rStore.set(DEFAULT_STATE_NAMESPACE, kvs);\\n            }\\n        }\\n\\n        // Take the flash loan, which will in turn call `onFlashLoan`, which is\\n        // expected to process an exchange against external liq to pay back the\\n        // flash loan, cover the orders and remain in profit.\\n        IERC20(takeOrders.output).safeApprove(address(sOrderBook), 0);\\n        IERC20(takeOrders.output).safeApprove(address(sOrderBook), type(uint256).max);\\n        if (!sOrderBook.flashLoan(this, flashLoanToken, flashLoanAmount, data)) {\\n            revert FlashLoanFailed();\\n        }\\n        IERC20(takeOrders.output).safeApprove(address(sOrderBook), 0);\\n\\n        // Send all unspent input tokens to the sender.\\n        uint256 inputBalance = IERC20(takeOrders.input).balanceOf(address(this));\\n        if (inputBalance > 0) {\\n            IERC20(takeOrders.input).safeTransfer(msg.sender, inputBalance);\\n        }\\n        // Send all unspent output tokens to the sender.\\n        uint256 outputBalance = IERC20(takeOrders.output).balanceOf(address(this));\\n        if (outputBalance < minimumSenderOutput) {\\n            revert MinimumOutput(minimumSenderOutput, outputBalance);\\n        }\\n        if (outputBalance > 0) {\\n            IERC20(takeOrders.output).safeTransfer(msg.sender, outputBalance);\\n        }\\n\\n        // Send any remaining gas to the sender.\\n        // Slither false positive here. We want to send everything to the sender\\n        // because the borrower contract should be empty of all gas and tokens\\n        // between uses. Anyone who sends tokens or gas to an arb contract\\n        // without calling `arb` is going to lose their tokens/gas.\\n        // See https://github.com/crytic/slither/issues/1658\\n        Address.sendValue(payable(msg.sender), address(this).balance);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/concrete/GenericPoolOrderBookFlashBorrower.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.19;\\n\\nimport \\\"src/interface/ierc3156/IERC3156FlashLender.sol\\\";\\nimport \\\"src/interface/ierc3156/IERC3156FlashBorrower.sol\\\";\\n\\nimport \\\"src/abstract/OrderBookFlashBorrower.sol\\\";\\n\\n/// @dev Metadata hash for `DeployerDiscoverableMetaV1`.\\n/// - ABI for GenericPoolOrderBookFlashBorrower\\n/// - Interpreter caller metadata V1 for GenericPoolOrderBookFlashBorrower\\nbytes32 constant CALLER_META_HASH = bytes32(0xa62ee776c94e335a2d59a5fa7d87ae282b35af1370107165adafe3464270a852);\\n\\n/// @title GenericPoolOrderBookFlashBorrower\\n/// Implements the OrderBookFlashBorrower interface for a external liquidity\\n/// source that behaves vaguely like a standard AMM. The `exchangeData` from\\n/// `arb` is decoded into a spender, pool and callData. The `callData` is\\n/// literally the encoded function call to the pool. This allows the `arb`\\n/// caller to process a trade against any liquidity source that can swap tokens\\n/// within a single function call.\\n/// The `spender` is the address that will be approved to spend the input token\\n/// on `takeOrders`, which is almost always going to be the pool itself. If you\\n/// are unsure, simply set it to the pool address.\\ncontract GenericPoolOrderBookFlashBorrower is OrderBookFlashBorrower {\\n    using SafeERC20 for IERC20;\\n    using Address for address;\\n\\n    constructor(DeployerDiscoverableMetaV1ConstructionConfig memory config)\\n        OrderBookFlashBorrower(CALLER_META_HASH, config)\\n    {}\\n\\n    /// @inheritdoc OrderBookFlashBorrower\\n    function _exchange(TakeOrdersConfig memory takeOrders, bytes memory exchangeData) internal virtual override {\\n        (address spender, address pool, bytes memory encodedFunctionCall) =\\n            abi.decode(exchangeData, (address, address, bytes));\\n\\n        IERC20(takeOrders.input).safeApprove(spender, 0);\\n        IERC20(takeOrders.input).safeApprove(spender, type(uint256).max);\\n        bytes memory returnData = pool.functionCallWithValue(encodedFunctionCall, address(this).balance);\\n        // Nothing can be done with returnData as 3156 does not support it.\\n        (returnData);\\n        IERC20(takeOrders.input).safeApprove(spender, 0);\\n    }\\n\\n    /// Allow receiving gas.\\n    fallback() external onlyNotInitializing {}\\n}\\n\"\r\n    },\r\n    \"src/interface/IOrderBookV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\nimport \\\"./ierc3156/IERC3156FlashLender.sol\\\";\\nimport \\\"rain.interpreter/lib/caller/LibEvaluable.sol\\\";\\nimport \\\"rain.interpreter/interface/IInterpreterCallerV2.sol\\\";\\n\\n/// Configuration for a deposit. All deposits are processed by and for\\n/// `msg.sender` so the vaults are unambiguous here.\\n/// @param token The token to deposit.\\n/// @param vaultId The vault ID for the token to deposit.\\n/// @param amount The amount of the token to deposit.\\nstruct DepositConfig {\\n    address token;\\n    uint256 vaultId;\\n    uint256 amount;\\n}\\n\\n/// Configuration for a withdrawal. All withdrawals are processed by and for\\n/// `msg.sender` so the vaults are unambiguous here.\\n/// @param token The token to withdraw.\\n/// @param vaultId The vault ID for the token to withdraw.\\n/// @param amount The amount of the token to withdraw.\\nstruct WithdrawConfig {\\n    address token;\\n    uint256 vaultId;\\n    uint256 amount;\\n}\\n\\n/// Configuration for a single input or output on an `Order`.\\n/// @param token The token to either send from the owner as an output or receive\\n/// from the counterparty to the owner as an input. The tokens are not moved\\n/// during an order, only internal vault balances are updated, until a separate\\n/// withdraw step.\\n/// @param decimals The decimals to use for internal scaling calculations for\\n/// `token`. This is provided directly in IO to save gas on external lookups and\\n/// to respect the ERC20 spec that mandates NOT assuming or using the `decimals`\\n/// method for onchain calculations. Ostensibly the decimals exists so that all\\n/// calculate order entrypoints can treat amounts and ratios as 18 decimal fixed\\n/// point values. Order max amounts MUST be rounded down and IO ratios rounded up\\n/// to compensate for any loss of precision during decimal rescaling.\\n/// @param vaultId The vault ID that tokens will move into if this is an input\\n/// or move out from if this is an output.\\nstruct IO {\\n    address token;\\n    uint8 decimals;\\n    uint256 vaultId;\\n}\\n\\n/// Config the order owner may provide to define their order. The `msg.sender`\\n/// that adds an order cannot modify the owner nor bypass the integrity check of\\n/// the expression deployer that they specify. However they MAY specify a\\n/// deployer with a corrupt integrity check, so counterparties and clearers MUST\\n/// check the DISpair of the order and avoid untrusted pairings.\\n/// @param validInputs As per `validInputs` on the `Order`.\\n/// @param validOutputs As per `validOutputs` on the `Order`.\\n/// @param evaluableConfig Standard `EvaluableConfig` used to produce the\\n/// `Evaluable` on the order.\\n/// @param meta Arbitrary bytes that will NOT be used in the order evaluation\\n/// but MUST be emitted as a Rain `MetaV1` when the order is placed so can be\\n/// used by offchain processes.\\nstruct OrderConfig {\\n    IO[] validInputs;\\n    IO[] validOutputs;\\n    EvaluableConfig evaluableConfig;\\n    bytes meta;\\n}\\n\\n/// Defines a fully deployed order ready to evaluate by Orderbook.\\n/// @param owner The owner of the order is the `msg.sender` that added the order.\\n/// @param handleIO true if there is a \\\"handle IO\\\" entrypoint to run. If false\\n/// the order book MAY skip calling the interpreter to save gas.\\n/// @param evaluable Standard `Evaluable` with entrypoints for both\\n/// \\\"calculate order\\\" and \\\"handle IO\\\". The latter MAY be empty bytes, in which\\n/// case it will be skipped at runtime to save gas.\\n/// @param validInputs A list of input tokens that are economically equivalent\\n/// for the purpose of processing this order. Inputs are relative to the order\\n/// so these tokens will be sent to the owners vault.\\n/// @param validOutputs A list of output tokens that are economically equivalent\\n/// for the purpose of processing this order. Outputs are relative to the order\\n/// so these tokens will be sent from the owners vault.\\nstruct Order {\\n    address owner;\\n    bool handleIO;\\n    Evaluable evaluable;\\n    IO[] validInputs;\\n    IO[] validOutputs;\\n}\\n\\n/// Config for a list of orders to take sequentially as part of a `takeOrders`\\n/// call.\\n/// @param output Output token from the perspective of the order taker.\\n/// @param input Input token from the perspective of the order taker.\\n/// @param minimumInput Minimum input from the perspective of the order taker.\\n/// @param maximumInput Maximum input from the perspective of the order taker.\\n/// @param maximumIORatio Maximum IO ratio as calculated by the order being\\n/// taken. The input is from the perspective of the order so higher ratio means\\n/// worse deal for the order taker.\\n/// @param orders Ordered list of orders that will be taken until the limit is\\n/// hit. Takers are expected to prioritise orders that appear to be offering\\n/// better deals i.e. lower IO ratios. This prioritisation and sorting MUST\\n/// happen offchain, e.g. via. some simulator.\\nstruct TakeOrdersConfig {\\n    address output;\\n    address input;\\n    uint256 minimumInput;\\n    uint256 maximumInput;\\n    uint256 maximumIORatio;\\n    TakeOrderConfig[] orders;\\n}\\n\\n/// Config for an individual take order from the overall list of orders in a\\n/// call to `takeOrders`.\\n/// @param order The order being taken this iteration.\\n/// @param inputIOIndex The index of the input token in `order` to match with the\\n/// take order output.\\n/// @param outputIOIndex The index of the output token in `order` to match with\\n/// the take order input.\\n/// @param signedContext Optional additional signed context relevant to the\\n/// taken order.\\nstruct TakeOrderConfig {\\n    Order order;\\n    uint256 inputIOIndex;\\n    uint256 outputIOIndex;\\n    SignedContextV1[] signedContext;\\n}\\n\\n/// Additional config to a `clear` that allows two orders to be fully matched to\\n/// a specific token moment. Also defines the bounty for the clearer.\\n/// @param aliceInputIOIndex The index of the input token in order A.\\n/// @param aliceOutputIOIndex The index of the output token in order A.\\n/// @param bobInputIOIndex The index of the input token in order B.\\n/// @param bobOutputIOIndex The index of the output token in order B.\\n/// @param aliceBountyVaultId The vault ID that the bounty from order A should\\n/// move to for the clearer.\\n/// @param bobBountyVaultId The vault ID that the bounty from order B should move\\n/// to for the clearer.\\nstruct ClearConfig {\\n    uint256 aliceInputIOIndex;\\n    uint256 aliceOutputIOIndex;\\n    uint256 bobInputIOIndex;\\n    uint256 bobOutputIOIndex;\\n    uint256 aliceBountyVaultId;\\n    uint256 bobBountyVaultId;\\n}\\n\\n/// Summary of the vault state changes due to clearing an order. NOT the state\\n/// changes sent to the interpreter store, these are the LOCAL CHANGES in vault\\n/// balances. Note that the difference in inputs/outputs overall between the\\n/// counterparties is the bounty paid to the entity that cleared the order.\\n/// @param aliceOutput Amount of counterparty A's output token that moved out of\\n/// their vault.\\n/// @param bobOutput Amount of counterparty B's output token that moved out of\\n/// their vault.\\n/// @param aliceInput Amount of counterparty A's input token that moved into\\n/// their vault.\\n/// @param bobInput Amount of counterparty B's input token that moved into their\\n/// vault.\\nstruct ClearStateChange {\\n    uint256 aliceOutput;\\n    uint256 bobOutput;\\n    uint256 aliceInput;\\n    uint256 bobInput;\\n}\\n\\n/// @title IOrderBookV2\\n/// @notice An orderbook that deploys _strategies_ represented as interpreter\\n/// expressions rather than individual orders. The order book contract itself\\n/// behaves similarly to an `ERC4626` vault but with much more fine grained\\n/// control over how tokens are allocated and moved internally by their owners,\\n/// and without any concept of \\\"shares\\\". Token owners MAY deposit and withdraw\\n/// their tokens under arbitrary vault IDs on a per-token basis, then define\\n/// orders that specify how tokens move between vaults according to an expression.\\n/// The expression returns a maximum amount and a token input/output ratio from\\n/// the perpective of the order. When two expressions intersect, as in their\\n/// ratios are the inverse of each other, then tokens can move between vaults.\\n///\\n/// For example, consider order A with input TKNA and output TKNB with a constant\\n/// ratio of 100:1. This order in isolation has no ability to move tokens. If\\n/// an order B appears with input TKNB and output TKNA and a ratio of 1:100 then\\n/// this is a perfect match with order A. In this case 100 TKNA will move from\\n/// order B to order A and 1 TKNB will move from order A to order B.\\n///\\n/// IO ratios are always specified as input:output and are 18 decimal fixed point\\n/// values. The maximum amount that can be moved in the current clearance is also\\n/// set by the order expression as an 18 decimal fixed point value.\\n///\\n/// Typically orders will not clear when their match is exactly 1:1 as the\\n/// clearer needs to pay gas to process the match. Each order will get exactly\\n/// the ratio it calculates when it does clear so if there is _overlap_ in the\\n/// ratios then the clearer keeps the difference. In our above example, consider\\n/// order B asking a ratio of 1:110 instead of 1:100. In this case 100 TKNA will\\n/// move from order B to order A and 10 TKNA will move to the clearer's vault and\\n/// 1 TKNB will move from order A to order B. In the case of fixed prices this is\\n/// not very interesting as order B could more simply take order A directly for\\n/// cheaper rather than involving a third party. Indeed, Orderbook supports a\\n/// direct \\\"take orders\\\" method that works similar to a \\\"market buy\\\". In the case\\n/// of dynamic expression based ratios, it allows both order A and order B to\\n/// clear non-interactively according to their strategy, trading off active\\n/// management, dealing with front-running, MEV, etc. for zero-gas and\\n/// exact-ratio clearance.\\n///\\n/// The general invariant for clearing and take orders is:\\n///\\n/// ```\\n/// ratioA = InputA / OutputA\\n/// ratioB = InputB / OutputB\\n/// ratioA * ratioB = ( InputA * InputB ) / ( OutputA * OutputB )\\n/// OutputA >= InputB\\n/// OutputB >= InputA\\n///\\n/// \u2234 ratioA * ratioB <= 1\\n/// ```\\n///\\n/// Orderbook is `IERC3156FlashLender` compliant with a 0 fee flash loan\\n/// implementation to allow external liquidity from other onchain DEXes to match\\n/// against orderbook expressions. All deposited tokens across all vaults are\\n/// available for flashloan, the flashloan MAY BE REPAID BY CALLING TAKE ORDER\\n/// such that Orderbook's liability to its vaults is decreased by an incoming\\n/// trade from the flashloan borrower. See `ZeroExOrderBookFlashBorrower` for\\n/// an example of how this works in practise.\\n///\\n/// Orderbook supports many to many input/output token relationship, for example\\n/// some order can specify an array of stables it would be willing to accept in\\n/// return for some ETH. This removes the need for a combinatorial explosion of\\n/// order strategies between like assets but introduces the issue of token\\n/// decimal handling. End users understand that \\\"one\\\" USDT is roughly equal to\\n/// \\\"one\\\" DAI, but onchain this is incorrect by _12 orders of magnitude_. This\\n/// is because \\\"one\\\" DAI is `1e18` tokens and \\\"one\\\" USDT is `1e6` tokens. The\\n/// orderbook is allowing orders to deploy expressions that define _economic\\n/// equivalence_ but this doesn't map 1:1 with numeric equivalence in a many to\\n/// many setup behind token decimal convensions. The solution is to require that\\n/// end users who place orders provide the decimals of each token they include\\n/// in their valid IO lists, and to calculate all amounts and ratios in their\\n/// expressions _as though they were 18 decimal fixed point values_. Orderbook\\n/// will then automatically rescale the expression values before applying the\\n/// final vault movements. If an order provides the \\\"wrong\\\" decimal values for\\n/// some token then it will simply calculate its own ratios and amounts\\n/// incorrectly which will either lead to no matching orders or a very bad trade\\n/// for the order owner. There is no way that misrepresenting decimals can attack\\n/// some other order by a counterparty. Orderbook DOES NOT read decimals from\\n/// tokens onchain because A. this would be gas for an external call to a cold\\n/// token contract and B. the ERC20 standard specifically states NOT to read\\n/// decimals from the interface onchain.\\n///\\n/// Token amounts and ratios returned by calculate order MUST be 18 decimal fixed\\n/// point values. Token amounts input to handle IO MUST be the exact absolute\\n/// values that move between the vaults, i.e. NOT rescaled to 18 decimals. The\\n/// author of the handle IO expression MUST use the token decimals and amounts to\\n/// rescale themselves if they want that logic, notably the expression author\\n/// will need to specify the desired rounding behaviour in the rescaling process.\\n///\\n/// When two orders clear there are NO TOKEN MOVEMENTS, only internal vault\\n/// balances are updated from the input and output vaults. Typically this results\\n/// in less gas per clear than calling external token transfers and also avoids\\n/// issues with reentrancy, allowances, external balances etc. This also means\\n/// that REBASING TOKENS AND TOKENS WITH DYNAMIC BALANCE ARE NOT SUPPORTED.\\n/// Orderbook ONLY WORKS IF TOKEN BALANCES ARE 1:1 WITH ADDITION/SUBTRACTION PER\\n/// VAULT MOVEMENT.\\n///\\n/// Dust due to rounding errors always favours the order. Output max is rounded\\n/// down and IO ratios are rounded up. Input and output amounts are always\\n/// converted to absolute values before applying to vault balances such that\\n/// orderbook always retains fully collateralised inventory of underlying token\\n/// balances to support withdrawals, with the caveat that dynamic token balanes\\n/// are not supported.\\n///\\n/// When an order clears it is NOT removed. Orders remain active until the owner\\n/// deactivates them. This is gas efficient as order owners MAY deposit more\\n/// tokens in a vault with an order against it many times and the order strategy\\n/// will continue to be clearable according to its expression. As vault IDs are\\n/// `uint256` values there are effectively infinite possible vaults for any token\\n/// so there is no limit to how many active orders any address can have at one\\n/// time. This also allows orders to be daisy chained arbitrarily where output\\n/// vaults for some order are the input vaults for some other order.\\n///\\n/// Expression storage is namespaced by order owner, so gets and sets are unique\\n/// to each onchain address. Order owners MUST TAKE CARE not to override their\\n/// storage sets globally across all their orders, which they can do most simply\\n/// by hashing the order hash into their get/set keys inside the expression. This\\n/// gives maximum flexibility for shared state across orders without allowing\\n/// order owners to attack and overwrite values stored by orders placed by their\\n/// counterparty.\\n///\\n/// Note that each order specifies its own interpreter and deployer so the\\n/// owner is responsible for not corrupting their own calculations with bad\\n/// interpreters. This also means the Orderbook MUST assume the interpreter, and\\n/// notably the interpreter's store, is malicious and guard against reentrancy\\n/// etc.\\n///\\n/// As Orderbook supports any expression that can run on any `IInterpreterV1` and\\n/// counterparties are available to the order, order strategies are free to\\n/// implement KYC/membership, tracking, distributions, stock, buybacks, etc. etc.\\ninterface IOrderBookV2 is IERC3156FlashLender, IInterpreterCallerV2 {\\n    /// Some tokens have been deposited to a vault.\\n    /// @param sender `msg.sender` depositing tokens. Delegated deposits are NOT\\n    /// supported.\\n    /// @param config All config sent to the `deposit` call.\\n    event Deposit(address sender, DepositConfig config);\\n\\n    /// Some tokens have been withdrawn from a vault.\\n    /// @param sender `msg.sender` withdrawing tokens. Delegated withdrawals are\\n    /// NOT supported.\\n    /// @param config All config sent to the `withdraw` call.\\n    /// @param amount The amount of tokens withdrawn, can be less than the\\n    /// config amount if the vault does not have the funds available to cover\\n    /// the config amount. For example an active order might move tokens before\\n    /// the withdraw completes.\\n    event Withdraw(address sender, WithdrawConfig config, uint256 amount);\\n\\n    /// An order has been added to the orderbook. The order is permanently and\\n    /// always active according to its expression until/unless it is removed.\\n    /// @param sender `msg.sender` adding the order and is owner of the order.\\n    /// @param expressionDeployer The expression deployer that ran the integrity\\n    /// check for this order. This is NOT included in the `Order` itself but is\\n    /// important for offchain processes to ignore untrusted deployers before\\n    /// interacting with them.\\n    /// @param order The newly added order. MUST be handed back as-is when\\n    /// clearing orders and contains derived information in addition to the order\\n    /// config that was provided by the order owner.\\n    /// @param orderHash The hash of the order as it is recorded onchain. Only\\n    /// the hash is stored in Orderbook storage to avoid paying gas to store the\\n    /// entire order.\\n    event AddOrder(address sender, IExpressionDeployerV1 expressionDeployer, Order order, uint256 orderHash);\\n\\n    /// An order has been removed from the orderbook. This effectively\\n    /// deactivates it. Orders can be added again after removal.\\n    /// @param sender `msg.sender` removing the order and is owner of the order.\\n    /// @param order The removed order.\\n    /// @param orderHash The hash of the removed order.\\n    event RemoveOrder(address sender, Order order, uint256 orderHash);\\n\\n    /// Some order has been taken by `msg.sender`. This is the same as them\\n    /// placing inverse orders then immediately clearing them all, but costs less\\n    /// gas and is more convenient and reliable. Analogous to a market buy\\n    /// against the specified orders. Each order that is matched within a the\\n    /// `takeOrders` loop emits its own individual event.\\n    /// @param sender `msg.sender` taking the orders.\\n    /// @param config All config defining the orders to attempt to take.\\n    /// @param input The input amount from the perspective of sender.\\n    /// @param output The output amount from the perspective of sender.\\n    event TakeOrder(address sender, TakeOrderConfig config, uint256 input, uint256 output);\\n\\n    /// Emitted when attempting to match an order that either never existed or\\n    /// was removed. An event rather than an error so that we allow attempting\\n    /// many orders in a loop and NOT rollback on \\\"best effort\\\" basis to clear.\\n    /// @param sender `msg.sender` clearing the order that wasn't found.\\n    /// @param owner Owner of the order that was not found.\\n    /// @param orderHash Hash of the order that was not found.\\n    event OrderNotFound(address sender, address owner, uint256 orderHash);\\n\\n    /// Emitted when an order evaluates to a zero amount. An event rather than an\\n    /// error so that we allow attempting many orders in a loop and NOT rollback\\n    /// on a \\\"best effort\\\" basis to clear.\\n    /// @param sender `msg.sender` clearing the order that had a 0 amount.\\n    /// @param owner Owner of the order that evaluated to a 0 amount.\\n    /// @param orderHash Hash of the order that evaluated to a 0 amount.\\n    event OrderZeroAmount(address sender, address owner, uint256 orderHash);\\n\\n    /// Emitted when an order evaluates to a ratio exceeding the counterparty's\\n    /// maximum limit. An error rather than an error so that we allow attempting\\n    /// many orders in a loop and NOT rollback on a \\\"best effort\\\" basis to clear.\\n    /// @param sender `msg.sender` clearing the order that had an excess ratio.\\n    /// @param owner Owner of the order that had an excess ratio.\\n    /// @param orderHash Hash of the order that had an excess ratio.\\n    event OrderExceedsMaxRatio(address sender, address owner, uint256 orderHash);\\n\\n    /// Emitted before two orders clear. Covers both orders and includes all the\\n    /// state before anything is calculated.\\n    /// @param sender `msg.sender` clearing both orders.\\n    /// @param alice One of the orders.\\n    /// @param bob The other order.\\n    /// @param clearConfig Additional config required to process the clearance.\\n    event Clear(address sender, Order alice, Order bob, ClearConfig clearConfig);\\n\\n    /// Emitted after two orders clear. Includes all final state changes in the\\n    /// vault balances, including the clearer's vaults.\\n    /// @param sender `msg.sender` clearing the order.\\n    /// @param clearStateChange The final vault state changes from the clearance.\\n    event AfterClear(address sender, ClearStateChange clearStateChange);\\n\\n    /// Get the current balance of a vault for a given owner, token and vault ID.\\n    /// @param owner The owner of the vault.\\n    /// @param token The token the vault is for.\\n    /// @param id The vault ID to read.\\n    /// @return balance The current balance of the vault.\\n    function vaultBalance(address owner, address token, uint256 id) external view returns (uint256 balance);\\n\\n    /// `msg.sender` deposits tokens according to config. The config specifies\\n    /// the vault to deposit tokens under. Delegated depositing is NOT supported.\\n    /// Depositing DOES NOT mint shares (unlike ERC4626) so the overall vaulted\\n    /// experience is much simpler as there is always a 1:1 relationship between\\n    /// deposited assets and vault balances globally and individually. This\\n    /// mitigates rounding/dust issues, speculative behaviour on derived assets,\\n    /// possible regulatory issues re: whether a vault share is a security, code\\n    /// bloat on the vault, complex mint/deposit/withdraw/redeem 4-way logic,\\n    /// the need for preview functions, etc. etc.\\n    /// At the same time, allowing vault IDs to be specified by the depositor\\n    /// allows much more granular and direct control over token movements within\\n    /// Orderbook than either ERC4626 vault shares or mere contract-level ERC20\\n    /// allowances can facilitate.\\n    /// @param config All config for the deposit.\\n    function deposit(DepositConfig calldata config) external;\\n\\n    /// Allows the sender to withdraw any tokens from their own vaults. If the\\n    /// withrawer has an active flash loan debt denominated in the same token\\n    /// being withdrawn then Orderbook will merely reduce the debt and NOT send\\n    /// the amount of tokens repaid to the flashloan debt.\\n    /// @param config All config required to withdraw. Notably if the amount\\n    /// is less than the current vault balance then the vault will be cleared\\n    /// to 0 rather than the withdraw transaction reverting.\\n    function withdraw(WithdrawConfig calldata config) external;\\n\\n    /// Given an order config, deploys the expression and builds the full `Order`\\n    /// for the config, then records it as an active order. Delegated adding an\\n    /// order is NOT supported. The `msg.sender` that adds an order is ALWAYS\\n    /// the owner and all resulting vault movements are their own.\\n    /// @param config All config required to build an `Order`.\\n    function addOrder(OrderConfig calldata config) external;\\n\\n    /// Order owner can remove their own orders. Delegated order removal is NOT\\n    /// supported and will revert. Removing an order multiple times or removing\\n    /// an order that never existed are valid, the event will be emitted and the\\n    /// transaction will complete with that order hash definitely, redundantly\\n    /// not live.\\n    /// @param order The `Order` data exactly as it was added.\\n    function removeOrder(Order calldata order) external;\\n\\n    /// Allows `msg.sender` to attempt to fill a list of orders in sequence\\n    /// without needing to place their own order and clear them. This works like\\n    /// a market buy but against a specific set of orders. Every order will\\n    /// looped over and calculated individually then filled maximally until the\\n    /// request input is reached for the `msg.sender`. The `msg.sender` is\\n    /// responsible for selecting the best orders at the time according to their\\n    /// criteria and MAY specify a maximum IO ratio to guard against an order\\n    /// spiking the ratio beyond what the `msg.sender` expected and is\\n    /// comfortable with. As orders may be removed and calculate their ratios\\n    /// dynamically, all issues fulfilling an order other than misconfiguration\\n    /// by the `msg.sender` are no-ops and DO NOT revert the transaction. This\\n    /// allows the `msg.sender` to optimistically provide a list of orders that\\n    /// they aren't sure will completely fill at a good price, and fallback to\\n    /// more reliable orders further down their list. Misconfiguration such as\\n    /// token mismatches are errors that revert as this is known and static at\\n    /// all times to the `msg.sender` so MUST be provided correctly. `msg.sender`\\n    /// MAY specify a minimum input that MUST be reached across all orders in the\\n    /// list, otherwise the transaction will revert, this MAY be set to zero.\\n    ///\\n    /// Exactly like withdraw, if there is an active flash loan for `msg.sender`\\n    /// they will have their outstanding loan reduced by the final input amount\\n    /// preferentially before sending any tokens. Notably this allows arb bots\\n    /// implemented as flash loan borrowers to connect orders against external\\n    /// liquidity directly by paying back the loan with a `takeOrders` call and\\n    /// outputting the result of the external trade.\\n    ///\\n    /// Rounding errors always favour the order never the `msg.sender`.\\n    ///\\n    /// @param config The constraints and list of orders to take, orders are\\n    /// processed sequentially in order as provided, there is NO ATTEMPT onchain\\n    /// to predict/filter/sort these orders other than evaluating them as\\n    /// provided. Inputs and outputs are from the perspective of `msg.sender`\\n    /// except for values specified by the orders themselves which are the from\\n    /// the perspective of that order.\\n    /// @return totalInput Total tokens sent to `msg.sender`, taken from order\\n    /// vaults processed.\\n    /// @return totalOutput Total tokens taken from `msg.sender` and distributed\\n    /// between vaults.\\n    function takeOrders(TakeOrdersConfig calldata config) external returns (uint256 totalInput, uint256 totalOutput);\\n\\n    /// Allows `msg.sender` to match two live orders placed earlier by\\n    /// non-interactive parties and claim a bounty in the process. The clearer is\\n    /// free to select any two live orders on the order book for matching and as\\n    /// long as they have compatible tokens, ratios and amounts, the orders will\\n    /// clear. Clearing the orders DOES NOT remove them from the orderbook, they\\n    /// remain live until explicitly removed by their owner. Even if the input\\n    /// vault balances are completely emptied, the orders remain live until\\n    /// removed. This allows order owners to deploy a strategy over a long period\\n    /// of time and periodically top up the input vaults. Clearing two orders\\n    /// from the same owner is disallowed.\\n    ///\\n    /// Any mismatch in the ratios between the two orders will cause either more\\n    /// inputs than there are available outputs (transaction will revert) or less\\n    /// inputs than there are available outputs. In the latter case the excess\\n    /// outputs are given to the `msg.sender` of clear, to the vaults they\\n    /// specify in the clear config. This not only incentivises \\\"automatic\\\" clear\\n    /// calls for both alice and bob, but incentivises _prioritising greater\\n    /// ratio differences_ with a larger bounty. The second point is important\\n    /// because it implicitly prioritises orders that are further from the\\n    /// current market price, thus putting constant increasing pressure on the\\n    /// entire system the further it drifts from the norm, no matter how esoteric\\n    /// the individual order expressions and sizings might be.\\n    ///\\n    /// All else equal there are several factors that would impact how reliably\\n    /// some order clears relative to the wider market, such as:\\n    ///\\n    /// - Bounties are effectively percentages of cleared amounts so larger\\n    ///   orders have larger bounties and cover gas costs more easily\\n    /// - High gas on the network means that orders are harder to clear\\n    ///   profitably so the negative spread of the ratios will need to be larger\\n    /// - Complex and stateful expressions cost more gas to evalulate so the\\n    ///   negative spread will need to be larger\\n    /// - Erratic behavior of the order owner could reduce the willingness of\\n    ///   third parties to interact if it could result in wasted gas due to\\n    ///   orders suddently being removed before clearance etc.\\n    /// - Dynamic and highly volatile words used in the expression could be\\n    ///   ignored or low priority by clearers who want to be sure that they can\\n    ///   accurately predict the ratios that they include in their clearance\\n    /// - Geopolitical issues such as sanctions and regulatory restrictions could\\n    ///   cause issues for certain owners and clearers\\n    ///\\n    /// @param alice Some order to clear.\\n    /// @param bob Another order to clear.\\n    /// @param clearConfig Additional configuration for the clearance such as\\n    /// how to handle the bounty payment for the `msg.sender`.\\n    /// @param aliceSignedContext Optional signed context that is relevant to A.\\n    /// @param bobSignedContext Optional signed context that is relevant to B.\\n    function clear(\\n        Order memory alice,\\n        Order memory bob,\\n        ClearConfig calldata clearConfig,\\n        SignedContextV1[] memory aliceSignedContext,\\n        SignedContextV1[] memory bobSignedContext\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"src/interface/ierc3156/IERC3156FlashBorrower.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CC0\\n// Alberto Cuesta Ca\u00f1ada, Fiona Kobayashi, fubuloubu, Austin Williams, \\\"EIP-3156: Flash Loans,\\\" Ethereum Improvement Proposals, no. 3156, November 2020. [Online serial]. Available: https://eips.ethereum.org/EIPS/eip-3156.\\npragma solidity ^0.8.18;\\n\\n/// @dev The ERC3156 spec mandates this hash be returned by `onFlashLoan` if it\\n/// succeeds.\\nbytes32 constant ON_FLASH_LOAN_CALLBACK_SUCCESS = keccak256(\\\"ERC3156FlashBorrower.onFlashLoan\\\");\\n\\ninterface IERC3156FlashBorrower {\\n    /**\\n     * @dev Receive a flash loan.\\n     * @param initiator The initiator of the loan.\\n     * @param token The loan currency.\\n     * @param amount The amount of tokens lent.\\n     * @param fee The additional amount of tokens to repay.\\n     * @param data Arbitrary data structure, intended to contain user-defined parameters.\\n     * @return The keccak256 hash of \\\"ERC3156FlashBorrower.onFlashLoan\\\"\\n     */\\n    function onFlashLoan(address initiator, address token, uint256 amount, uint256 fee, bytes calldata data)\\n        external\\n        returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"src/interface/ierc3156/IERC3156FlashLender.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CC0\\n// Alberto Cuesta Ca\u00f1ada, Fiona Kobayashi, fubuloubu, Austin Williams, \\\"EIP-3156: Flash Loans,\\\" Ethereum Improvement Proposals, no. 3156, November 2020. [Online serial]. Available: https://eips.ethereum.org/EIPS/eip-3156.\\npragma solidity ^0.8.18;\\n\\nimport \\\"./IERC3156FlashBorrower.sol\\\";\\n\\ninterface IERC3156FlashLender {\\n    /**\\n     * @dev The amount of currency available to be lent.\\n     * @param token The loan currency.\\n     * @return The amount of `token` that can be borrowed.\\n     */\\n    function maxFlashLoan(address token) external view returns (uint256);\\n\\n    /**\\n     * @dev The fee to be charged for a given loan.\\n     * @param token The loan currency.\\n     * @param amount The amount of tokens lent.\\n     * @return The amount of `token` to be charged for the loan, on top of the returned principal.\\n     */\\n    function flashFee(address token, uint256 amount) external view returns (uint256);\\n\\n    /**\\n     * @dev Initiate a flash loan.\\n     * @param receiver The receiver of the tokens in the loan, and the receiver of the callback.\\n     * @param token The loan currency.\\n     * @param amount The amount of tokens lent.\\n     * @param data Arbitrary data structure, intended to contain user-defined parameters.\\n     */\\n    function flashLoan(IERC3156FlashBorrower receiver, address token, uint256 amount, bytes calldata data)\\n        external\\n        returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"caller/=lib/rain.interpreter/src/lib/caller/\",\r\n      \"compile/=lib/rain.interpreter/src/lib/compile/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"eval/=lib/rain.interpreter/src/lib/eval/\",\r\n      \"extern/=lib/rain.interpreter/src/lib/extern/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"integrity/=lib/rain.interpreter/src/lib/integrity/\",\r\n      \"ns/=lib/rain.interpreter/src/lib/ns/\",\r\n      \"op/=lib/rain.interpreter/src/lib/op/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"openzeppelin/=lib/openzeppelin-contracts/contracts/\",\r\n      \"parse/=lib/rain.interpreter/src/lib/parse/\",\r\n      \"rain.chainlink/=lib/rain.interpreter/lib/rain.chainlink/src/\",\r\n      \"rain.datacontract/=lib/rain.datacontract/src/\",\r\n      \"rain.erc1820/=lib/rain.erc1820/src/\",\r\n      \"rain.extrospection/=lib/rain.factory/lib/rain.extrospection/\",\r\n      \"rain.factory/=lib/rain.factory/\",\r\n      \"rain.interpreter/=lib/rain.interpreter/src/\",\r\n      \"rain.lib.hash/=lib/rain.lib.memkv/lib/rain.lib.hash/src/\",\r\n      \"rain.lib.memkv/=lib/rain.lib.memkv/src/\",\r\n      \"rain.lib.typecast/=lib/rain.interpreter/lib/rain.lib.typecast/src/\",\r\n      \"rain.math.fixedpoint/=lib/rain.math.fixedpoint/src/\",\r\n      \"rain.math.saturating/=lib/rain.math.fixedpoint/lib/rain.math.saturating/src/\",\r\n      \"rain.metadata/=lib/rain.metadata/src/\",\r\n      \"rain.solmem/=lib/rain.datacontract/lib/rain.solmem/src/\",\r\n      \"sol.lib.memory/=lib/rain.interpreter/lib/sol.lib.memory/src/\",\r\n      \"state/=lib/rain.interpreter/src/lib/state/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000000\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\",\r\n      \"appendCBOR\": false\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"deployer\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"meta\",\"type\":\"bytes\"}],\"internalType\":\"struct DeployerDiscoverableMetaV1ConstructionConfig\",\"name\":\"config\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"badInitiator\",\"type\":\"address\"}],\"name\":\"BadInitiator\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"badLender\",\"type\":\"address\"}],\"name\":\"BadLender\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FlashLoanFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InitializeSignatureFn\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Initializing\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"}],\"name\":\"InvalidSignature\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"minimum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"actual\",\"type\":\"uint256\"}],\"name\":\"MinimumOutput\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NonZeroBeforeArbStack\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"unmeta\",\"type\":\"bytes\"}],\"name\":\"NotRainMetaV1\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"expectedHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"actualHash\",\"type\":\"bytes32\"}],\"name\":\"UnexpectedMetaHash\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"orderBook\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"contract IExpressionDeployerV1\",\"name\":\"deployer\",\"type\":\"address\"},{\"internalType\":\"bytes[]\",\"name\":\"sources\",\"type\":\"bytes[]\"},{\"internalType\":\"uint256[]\",\"name\":\"constants\",\"type\":\"uint256[]\"}],\"internalType\":\"struct EvaluableConfig\",\"name\":\"evaluableConfig\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"implementationData\",\"type\":\"bytes\"}],\"indexed\":false,\"internalType\":\"struct OrderBookFlashBorrowerConfig\",\"name\":\"config\",\"type\":\"tuple\"}],\"name\":\"Initialize\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"subject\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"meta\",\"type\":\"bytes\"}],\"name\":\"MetaV1\",\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"output\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"input\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minimumInput\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maximumInput\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maximumIORatio\",\"type\":\"uint256\"},{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"handleIO\",\"type\":\"bool\"},{\"components\":[{\"internalType\":\"contract IInterpreterV1\",\"name\":\"interpreter\",\"type\":\"address\"},{\"internalType\":\"contract IInterpreterStoreV1\",\"name\":\"store\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"expression\",\"type\":\"address\"}],\"internalType\":\"struct Evaluable\",\"name\":\"evaluable\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"}],\"internalType\":\"struct IO[]\",\"name\":\"validInputs\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"}],\"internalType\":\"struct IO[]\",\"name\":\"validOutputs\",\"type\":\"tuple[]\"}],\"internalType\":\"struct Order\",\"name\":\"order\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"inputIOIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outputIOIndex\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"context\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct SignedContextV1[]\",\"name\":\"signedContext\",\"type\":\"tuple[]\"}],\"internalType\":\"struct TakeOrderConfig[]\",\"name\":\"orders\",\"type\":\"tuple[]\"}],\"internalType\":\"struct TakeOrdersConfig\",\"name\":\"takeOrders\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"minimumSenderOutput\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"exchangeData\",\"type\":\"bytes\"}],\"name\":\"arb\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"orderBook\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"contract IExpressionDeployerV1\",\"name\":\"deployer\",\"type\":\"address\"},{\"internalType\":\"bytes[]\",\"name\":\"sources\",\"type\":\"bytes[]\"},{\"internalType\":\"uint256[]\",\"name\":\"constants\",\"type\":\"uint256[]\"}],\"internalType\":\"struct EvaluableConfig\",\"name\":\"evaluableConfig\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"implementationData\",\"type\":\"bytes\"}],\"internalType\":\"struct OrderBookFlashBorrowerConfig\",\"name\":\"\",\"type\":\"tuple\"}],\"name\":\"initialize\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"initialize\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"initiator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"onFlashLoan\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sI9r\",\"outputs\":[{\"internalType\":\"contract IInterpreterV1\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sI9rDispatch\",\"outputs\":[{\"internalType\":\"EncodedDispatch\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sI9rStore\",\"outputs\":[{\"internalType\":\"contract IInterpreterStoreV1\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sOrderBook\",\"outputs\":[{\"internalType\":\"contract IOrderBookV2\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "GenericPoolOrderBookFlashBorrower", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "1000000", "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000db2e78cbbe7ffb38908acbdf5273b6c6c8b82f0e0000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000056aff0a89c674ee7874a500590400ed58c96edb3010fd95c0675f922e4873abb3a002921a88d31c1af8404b6387b5440a5c1cbb45febda4564aa2162a095aa0bd49e26c9ce5cd8c1e7e4d3089a5e09333f5e8d328a60448f68a890046507877886172364141c080f3c9744250a43f041087f4004c7d115592e769837b751060f0462050c9971e3e2fa7752e2e98f4c5d145a6e902739fee80a15508374ac2fdf13925290da6443daff1a6d4e1e7ef991621e310122d5c20013752a0150eb138a83342498c0e5a6e49efe7b229cb6e5478aacf352b1478040b8c346fd33dcb8270662504c646e9bc061240afc23a95455b497f1522fe784d11b94238846020577aa710ff8405de102424832be2ca8bc9c6cd2552bd9f7cf858ba0497fcf9d9b3a968a7d40485852f54166182231959544efb99912f240a3bcdbd49e5cfa550260df4e5574abe03a3335853069fd96a2190bf75bb67ad7025692bdd42a5b84598a4e53942d5bb935219ec63f005045f540ed6542ab236943125a47e6de12f8dfe467255daee2a79693952287188a854c6af51c8615abd4b007b5520e55177b9f2b65a9d3a0331654ad28cd2ed18690ae504536e3af22ef7b1e651489ae36d12c0d168ffb0346e4b25f3933c12558af6e230d9132846fa06f50ad1225afbc6a52a70a941bdde1aa07150ed11bdfd0b478a2e523e45baf35ca0b66ed699139995f33c7c09d6cea8cab72760c3bb5903738ddcdd29135f9cbbdad5a7a525aa01eb24a986e2d46e4af0dab638d5d1807b555098cbd50f85026d10de296ce0809383791d1e0be70c9b4d940de14a63790d515d91a3d64c3a4abac19b681dc4dad62abdaa04977e19a1fd2b4998dfea12b6cba879d3d5b94f64285c521a967c8f8804217873237df4b90b947bfa40a1b9a862382e3f0fb2cb2a70a1465530a572fd615c0e41d172ec436b0fac5b00dd06e58e7113740b6470629f9a2dd2c791028706320e48c71d92a1f002fb0468778337375b6432cb7a2912547d9075d97fc70be9886c73c3b2b307d726aa01534173e3d001f0e69eee15e3702985e44e118e91e46ac11958f0f6d14bc05e5807afde31893777abbe5d5faf63109ca75aef8f2b43a479e412dd3bb48524c2e95065ca4c22ed942a85305e1fd14471322675b2a6b848e699fa96d791413597c3de570d64036d3369be18b1953aa559a5243be3c0c94392e46fcb4b278fff3bcbdfbab38cdf513ab6136c6e2765daf56ff0f6bdbd99ab710565dab2b4db434177cdbcf91d5ceaad7f3c6fffff3860321b37d88f6b796360ae275494143f2eff78ac4aabb8f789759bd33bc2dbe7e4a6793b0c4f6e86a99feb3112fe63b78197c4a7010406717b105fc9b045b65fb8baadb1a8bc91efe6462b1b6463c1707ff236c6d9b3fc7d6d115c231fcc593b2332aa88cb38a64c702f27efa9a5ca1a5b5f5f9d6eb3fc0d011bffe5ffb4a3ff2cde02706170706c69636174696f6e2f6a736f6e03676465666c6174650462656ea5005901069d50bd52c3300c7e159de7a60fc0d60e3015b8ebc875506c25f1d5b18ce5003d2eef8e6d52daac6c92fcfdf8fbbe95c791d4837a224fd16a08cc0e381a8ad0329fa17328431e63e44f8a6aa3b0b5cf2bca6b66bc14c23ee31f0b7c7f431b129da13be817fdb51ea40113243c938063f4025de411d0df7f01bd019d4fc253d404f495287a74e0ecfb648d4d972be9022d4af660af07b41e7687c36f9ec4a0f9a3da51f5a99a1248dbaee08b57b5aa936ce13885c03149360b91442cfba24d0650ebbc438fc9fa7e5bfa701625475c0236c5b0a93a4d916c6ae0e6aec091d2c02653defeca9734b5ab6a97c3d2de316fc5cafa30a5ff1003a6e1fa389f36ea96aaa89de6d3fc03011bffc21bbf86cc199b02706170706c69636174696f6e2f6a736f6e03676465666c6174650462656e00000000000000000000000000000000000000000000", "EVMVersion": "london", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}