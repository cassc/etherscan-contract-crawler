{"SourceCode": "// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   * @notice Renouncing to ownership will leave the contract without an owner.\r\n   * It will not be possible to call the functions with the `onlyOwner`\r\n   * modifier anymore.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\n// File: contracts/WhiteList.sol\r\n\r\npragma solidity ^0.4.18;\r\n\r\ncontract WhiteList is Ownable {\r\n    mapping(address => uint8) public whitelist;\r\n    bool public presaleNeedWhitelist = true;\r\n    bool public publicsaleNeedWhitelist = true;\r\n\r\n    event ImportList(address indexed owner, address[] users, uint8 flag);\r\n    event UpdatePresaleWhitelistStatus(address indexed owner, bool flag);\r\n    event UpdatePublicSaleWhitelistStatus(address indexed owner, bool flag);\r\n\r\n    /**\r\n     * @dev Function to import user's address into whitelist, only user who in the whitelist can purchase token.\r\n     *      Whitelist\u306b\u30e6\u30fc\u30b6\u30fc\u30a2\u30c9\u30ec\u30b9\u3092\u8a18\u9332\u3002sale\u671f\u9593\u306b\u3001Whitelist\u306b\u8a18\u9332\u3057\u305f\u30e6\u30fc\u30b6\u30fc\u305f\u3061\u3057\u304b\u30c8\u30fc\u30af\u30f3\u3092\u8cfc\u5165\u3067\u304d\u306a\u3044\r\n     * @param _users The address list that can purchase token when sale period.\r\n     * @param _flag The flag for record different lv user, 1: pre sale user, 2: public sale user.\r\n     * @return A bool that indicates if the operation was successful.\r\n     */\r\n    function importList(address[] _users, uint8 _flag)\r\n        public\r\n        onlyOwner\r\n        returns (bool)\r\n    {\r\n        require(_users.length > 0);\r\n\r\n        for (uint256 i = 0; i < _users.length; i++) {\r\n            whitelist[_users[i]] = _flag;\r\n        }\r\n\r\n        emit ImportList(msg.sender, _users, _flag);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Function check the current user can purchase token or not.\r\n     * \u30e6\u30fc\u30b6\u30fc\u30a2\u30c9\u30ec\u30b9\u306fWhitelist\u306b\u8a18\u9332\u304b\u3069\u3046\u304b\u30c1\u30a7\u30c3\u30af\r\n     * @param _user The user address that can purchase token or not when public salse.\r\n     * @return A bool that indicates if the operation was successful.\r\n     */\r\n    function checkList(address _user) public view returns (uint8) {\r\n        return whitelist[_user];\r\n    }\r\n\r\n    /**\r\n     * @dev Function get whitelist able status in presale\r\n     * @return A bool that indicates if the operation was successful.\r\n     */\r\n    function getPresaleWhitelistStatus() public view returns (bool) {\r\n        return presaleNeedWhitelist;\r\n    }\r\n\r\n    /**\r\n     * @dev Function get whitelist able status in public sale\r\n     * @return A bool that indicates if the operation was successful.\r\n     */\r\n    function getPublicSaleWhitelistStatus() public view returns (bool) {\r\n        return publicsaleNeedWhitelist;\r\n    }\r\n\r\n    /**\r\n     * @dev Function update whitelist able status in presale\r\n     * @param _flag bool whitelist status\r\n     * @return A bool that indicates if the operation was successful.\r\n     */\r\n    function updatePresaleWhitelistStatus(bool _flag)\r\n        public\r\n        onlyOwner\r\n        returns (bool)\r\n    {\r\n        presaleNeedWhitelist = _flag;\r\n\r\n        emit UpdatePresaleWhitelistStatus(msg.sender, _flag);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Function update whitelist able status in public sale\r\n     * @param _flag bool whitelist status\r\n     * @return A bool that indicates if the operation was successful.\r\n     */\r\n    function updatePublicSaleWhitelistStatus(bool _flag)\r\n        public\r\n        onlyOwner\r\n        returns (bool)\r\n    {\r\n        publicsaleNeedWhitelist = _flag;\r\n\r\n        emit UpdatePublicSaleWhitelistStatus(msg.sender, _flag);\r\n\r\n        return true;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (_a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = _a * _b;\r\n    assert(c / _a == _b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    // assert(_b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = _a / _b;\r\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n    return _a / _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    assert(_b <= _a);\r\n    return _a - _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    c = _a + _b;\r\n    assert(c >= _a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// File: contracts/GroupLockup.sol\r\n\r\npragma solidity ^0.4.18;\r\n\r\n\r\ncontract GroupLockup is Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    mapping(address => uint256) public lockupList; //users lockup list\r\n    mapping(uint256 => bool) public lockupListFlag;\r\n    address[] public userList; //users address list\r\n\r\n    event UpdateLockupList(\r\n        address indexed owner,\r\n        address indexed userAddress,\r\n        uint256 lockupDate\r\n    );\r\n    event UpdateLockupTime(\r\n        address indexed owner,\r\n        uint256 indexed oldLockupDate,\r\n        uint256 newLockupDate\r\n    );\r\n    event LockupTimeList(uint256 indexed lockupDate, bool active);\r\n\r\n    /**\r\n     * @dev Function to get lockup list\r\n     * @param userAddress address\r\n     * @return A uint256 that indicates if the operation was successful.\r\n     */\r\n    function getLockupTime(address userAddress) public view returns (uint256) {\r\n        return lockupList[userAddress];\r\n    }\r\n\r\n    /**\r\n     * @dev Function to check token locked date that is reach or not\r\n     * @param lockupDate uint256\r\n     * @return A bool that indicates if the operation was successful.\r\n     */\r\n    function isLockup(uint256 lockupDate) public view returns (bool) {\r\n        return (now < lockupDate);\r\n    }\r\n\r\n    /**\r\n     * @dev Function get user's lockup status\r\n     * @param userAddress address\r\n     * @return A bool that indicates if the operation was successful.\r\n     */\r\n    function inLockupList(address userAddress) public view returns (bool) {\r\n        if (lockupList[userAddress] == 0) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Function update lockup status for purchaser, if user in the lockup list, they can only transfer token after lockup date\r\n     * @param userAddress address\r\n     * @param lockupDate uint256 this user's token time\r\n     * @return A bool that indicates if the operation was successful.\r\n     */\r\n    function updateLockupList(address userAddress, uint256 lockupDate)\r\n        public\r\n        onlyOwner\r\n        returns (bool)\r\n    {\r\n        if (lockupDate == 0) {\r\n            delete lockupList[userAddress];\r\n\r\n            for (\r\n                uint256 userListIndex = 0;\r\n                userListIndex < userList.length;\r\n                userListIndex++\r\n            ) {\r\n                if (userList[userListIndex] == userAddress) {\r\n                    //Swap and pop the array instead of deleting by index,\r\n                    //so that we do not leave a gap in the array. (Storage and gas efficiency.)\r\n                    //delete userList[userListIndex];\r\n                    userList[userListIndex] = userList[userList.length - 1];\r\n                    delete userList[userList.length - 1];\r\n                    userList.length--;\r\n                    break;\r\n                }\r\n            }\r\n        } else {\r\n            bool userIsExist = inLockupList(userAddress);\r\n\r\n            if (!userIsExist) {\r\n                userList.push(userAddress);\r\n            }\r\n            //Limit the userList size to prevent gas exhaustion.\r\n            uint8 maxUserListLength = 100;\r\n            require(userList.length <= maxUserListLength, \"user list too large\");\r\n\r\n            lockupList[userAddress] = lockupDate;\r\n\r\n            //insert lockup time into lockup time list, if this lockup time is the new one\r\n            if (!lockupListFlag[lockupDate]) {\r\n                lockupListFlag[lockupDate] = true;\r\n                emit LockupTimeList(lockupDate, true);\r\n            }\r\n        }\r\n        emit UpdateLockupList(msg.sender, userAddress, lockupDate);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Function update lockup time\r\n     * @param oldLockupDate uint256 old group lockup time\r\n     * @param newLockupDate uint256 new group lockup time\r\n     * @return A bool that indicates if the operation was successful.\r\n     */\r\n    function updateLockupTime(uint256 oldLockupDate, uint256 newLockupDate)\r\n        public\r\n        onlyOwner\r\n        returns (bool)\r\n    {\r\n        require(oldLockupDate != 0);\r\n        require(newLockupDate != 0);\r\n        require(newLockupDate != oldLockupDate);\r\n\r\n        address userAddress;\r\n        uint256 userLockupTime;\r\n\r\n        //update the user's lockup time who was be setted as old lockup time\r\n        for (\r\n            uint256 userListIndex = 0;\r\n            userListIndex < userList.length;\r\n            userListIndex++\r\n        ) {\r\n            if (userList[userListIndex] != 0) {\r\n                userAddress = userList[userListIndex];\r\n                userLockupTime = getLockupTime(userAddress);\r\n                if (userLockupTime == oldLockupDate) {\r\n                    lockupList[userAddress] = newLockupDate;\r\n                    emit UpdateLockupList(\r\n                        msg.sender,\r\n                        userAddress,\r\n                        newLockupDate\r\n                    );\r\n                }\r\n            }\r\n        }\r\n\r\n        //delete the old lockup time from lockup time list, if this old lockup time is existing in the lockup time list\r\n        if (lockupListFlag[oldLockupDate]) {\r\n            lockupListFlag[oldLockupDate] = false;\r\n            emit LockupTimeList(oldLockupDate, false);\r\n        }\r\n\r\n        //insert lockup time into lockup time list, if this lockup time is the new one\r\n        if (!lockupListFlag[newLockupDate]) {\r\n            lockupListFlag[newLockupDate] = true;\r\n            emit LockupTimeList(newLockupDate, true);\r\n        }\r\n\r\n        emit UpdateLockupTime(msg.sender, oldLockupDate, newLockupDate);\r\n        return true;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * See https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address _who) public view returns (uint256);\r\n  function transfer(address _to, uint256 _value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/BasicToken.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n/**\r\n * @title Basic token\r\n * @dev Basic version of StandardToken, with no allowances.\r\n */\r\ncontract BasicToken is ERC20Basic {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) internal balances;\r\n\r\n  uint256 internal totalSupply_;\r\n\r\n  /**\r\n  * @dev Total number of tokens in existence\r\n  */\r\n  function totalSupply() public view returns (uint256) {\r\n    return totalSupply_;\r\n  }\r\n\r\n  /**\r\n  * @dev Transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n    require(_value <= balances[msg.sender]);\r\n    require(_to != address(0));\r\n\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    emit Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _owner) public view returns (uint256) {\r\n    return balances[_owner];\r\n  }\r\n\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address _owner, address _spender)\r\n    public view returns (uint256);\r\n\r\n  function transferFrom(address _from, address _to, uint256 _value)\r\n    public returns (bool);\r\n\r\n  function approve(address _spender, uint256 _value) public returns (bool);\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/StandardToken.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * https://github.com/ethereum/EIPs/issues/20\r\n * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n */\r\ncontract StandardToken is ERC20, BasicToken {\r\n\r\n  mapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n\r\n  /**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint256 the amount of tokens to be transferred\r\n   */\r\n  function transferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _value\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    require(_value <= balances[_from]);\r\n    require(_value <= allowed[_from][msg.sender]);\r\n    require(_to != address(0));\r\n\r\n    balances[_from] = balances[_from].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n    emit Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   */\r\n  function approve(address _spender, uint256 _value) public returns (bool) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    emit Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\n   */\r\n  function allowance(\r\n    address _owner,\r\n    address _spender\r\n   )\r\n    public\r\n    view\r\n    returns (uint256)\r\n  {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n  /**\r\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n   * approve should be called when allowed[_spender] == 0. To increment\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _addedValue The amount of tokens to increase the allowance by.\r\n   */\r\n  function increaseApproval(\r\n    address _spender,\r\n    uint256 _addedValue\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    allowed[msg.sender][_spender] = (\r\n      allowed[msg.sender][_spender].add(_addedValue));\r\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n   * approve should be called when allowed[_spender] == 0. To decrement\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\r\n   */\r\n  function decreaseApproval(\r\n    address _spender,\r\n    uint256 _subtractedValue\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    uint256 oldValue = allowed[msg.sender][_spender];\r\n    if (_subtractedValue >= oldValue) {\r\n      allowed[msg.sender][_spender] = 0;\r\n    } else {\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n    }\r\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/MintableToken.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n/**\r\n * @title Mintable token\r\n * @dev Simple ERC20 Token example, with mintable token creation\r\n * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol\r\n */\r\ncontract MintableToken is StandardToken, Ownable {\r\n  event Mint(address indexed to, uint256 amount);\r\n  event MintFinished();\r\n\r\n  bool public mintingFinished = false;\r\n\r\n\r\n  modifier canMint() {\r\n    require(!mintingFinished);\r\n    _;\r\n  }\r\n\r\n  modifier hasMintPermission() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to mint tokens\r\n   * @param _to The address that will receive the minted tokens.\r\n   * @param _amount The amount of tokens to mint.\r\n   * @return A boolean that indicates if the operation was successful.\r\n   */\r\n  function mint(\r\n    address _to,\r\n    uint256 _amount\r\n  )\r\n    public\r\n    hasMintPermission\r\n    canMint\r\n    returns (bool)\r\n  {\r\n    totalSupply_ = totalSupply_.add(_amount);\r\n    balances[_to] = balances[_to].add(_amount);\r\n    emit Mint(_to, _amount);\r\n    emit Transfer(address(0), _to, _amount);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to stop minting new tokens.\r\n   * @return True if the operation was successful.\r\n   */\r\n  function finishMinting() public onlyOwner canMint returns (bool) {\r\n    mintingFinished = true;\r\n    emit MintFinished();\r\n    return true;\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/BurnableToken.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n/**\r\n * @title Burnable Token\r\n * @dev Token that can be irreversibly burned (destroyed).\r\n */\r\ncontract BurnableToken is BasicToken {\r\n\r\n  event Burn(address indexed burner, uint256 value);\r\n\r\n  /**\r\n   * @dev Burns a specific amount of tokens.\r\n   * @param _value The amount of token to be burned.\r\n   */\r\n  function burn(uint256 _value) public {\r\n    _burn(msg.sender, _value);\r\n  }\r\n\r\n  function _burn(address _who, uint256 _value) internal {\r\n    require(_value <= balances[_who]);\r\n    // no need to require value <= totalSupply, since that would imply the\r\n    // sender's balance is greater than the totalSupply, which *should* be an assertion failure\r\n\r\n    balances[_who] = balances[_who].sub(_value);\r\n    totalSupply_ = totalSupply_.sub(_value);\r\n    emit Burn(_who, _value);\r\n    emit Transfer(_who, address(0), _value);\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/StandardBurnableToken.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n/**\r\n * @title Standard Burnable Token\r\n * @dev Adds burnFrom method to ERC20 implementations\r\n */\r\ncontract StandardBurnableToken is BurnableToken, StandardToken {\r\n\r\n  /**\r\n   * @dev Burns a specific amount of tokens from the target address and decrements allowance\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _value uint256 The amount of token to be burned\r\n   */\r\n  function burnFrom(address _from, uint256 _value) public {\r\n    require(_value <= allowed[_from][msg.sender]);\r\n    // Should https://github.com/OpenZeppelin/zeppelin-solidity/issues/707 be accepted,\r\n    // this function needs to emit an event with the updated approval.\r\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n    _burn(_from, _value);\r\n  }\r\n}\r\n\r\n// File: contracts/ERC20Token.sol\r\n\r\npragma solidity ^0.4.18;\r\n\r\n\r\n\r\n\r\ncontract ERC20Token is MintableToken, StandardBurnableToken {\r\n    using SafeMath for uint256;\r\n\r\n    string public constant name = \"Kinka\";\r\n    string public constant symbol = \"XNK\";\r\n    uint8 public constant decimals = 18;\r\n    uint256 public constant INITIAL_SUPPLY =\r\n        482 * (10**uint256(decimals));\r\n    uint256 public constant INITIAL_SALE_SUPPLY =\r\n        482 * (10**uint256(decimals));\r\n    uint256 public constant INITIAL_UNSALE_SUPPLY =\r\n        INITIAL_SUPPLY - INITIAL_SALE_SUPPLY;\r\n\r\n    address public ownerWallet;\r\n    address public unsaleOwnerWallet;\r\n\r\n    GroupLockup public groupLockup;\r\n\r\n    event BatchTransferFail(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 value,\r\n        string msg\r\n    );\r\n\r\n    /**\r\n     * @dev Constructor that gives msg.sender all of existing tokens.\r\n     */\r\n    constructor(\r\n        address _saleOwnerWallet,\r\n        address _unsaleOwnerWallet,\r\n        GroupLockup _groupLockup\r\n    ) public {\r\n        groupLockup = _groupLockup;\r\n        ownerWallet = _saleOwnerWallet;\r\n        unsaleOwnerWallet = _unsaleOwnerWallet;\r\n\r\n        mint(ownerWallet, INITIAL_SALE_SUPPLY);\r\n        mint(unsaleOwnerWallet, INITIAL_UNSALE_SUPPLY);\r\n    }\r\n\r\n    /**\r\n     * @dev transfer token for a specified address\r\n     * @param _to The address to transfer to.\r\n     * @param _value The amount to be transferred.\r\n     */\r\n    function sendTokens(address _to, uint256 _value)\r\n        public\r\n        onlyOwner\r\n        returns (bool)\r\n    {\r\n        require(_to != address(0));\r\n        require(_value <= balances[ownerWallet]);\r\n\r\n        // SafeMath.sub will throw if there is not enough balance.\r\n        balances[ownerWallet] = balances[ownerWallet].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n\r\n        emit Transfer(ownerWallet, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev transfer token for a specified address\r\n     * @param _to The address to transfer to.\r\n     * @param _value The amount to be transferred.\r\n     */\r\n    function transfer(address _to, uint256 _value) public returns (bool) {\r\n        require(_to != address(0));\r\n        require(_value <= balances[msg.sender]);\r\n        require(_value > 0);\r\n\r\n        bool inLockupList = groupLockup.inLockupList(msg.sender);\r\n\r\n        //if user in the lockup list, they can only transfer token after lockup date\r\n        if (inLockupList) {\r\n            uint256 lockupTime = groupLockup.getLockupTime(msg.sender);\r\n            require(groupLockup.isLockup(lockupTime) == false);\r\n        }\r\n\r\n        // SafeMath.sub will throw if there is not enough balance.\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n\r\n        emit Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n  /**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint256 the amount of tokens to be transferred\r\n   */\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _value\r\n    ) public returns (bool) {\r\n        require(_value <= balances[_from]);\r\n        require(_value <= allowed[_from][msg.sender]);\r\n        require(_to != address(0));\r\n\r\n        //Validate the lockup time about the `from` address.\r\n        bool inLockupList = groupLockup.inLockupList(_from);\r\n        //if user in the lockup list, they can only transfer token after lockup date\r\n        if (inLockupList) {\r\n            uint256 lockupTime = groupLockup.getLockupTime(_from);\r\n            require(groupLockup.isLockup(lockupTime) == false);\r\n        }\r\n\r\n        balances[_from] = balances[_from].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n        emit Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev transfer token to mulitipule user\r\n     * @param _from which wallet's token will be taken.\r\n     * @param _users The address list to transfer to.\r\n     * @param _values The amount list to be transferred.\r\n     */\r\n    function batchTransfer(\r\n        address _from,\r\n        address[] _users,\r\n        uint256[] _values\r\n    ) public onlyOwner returns (bool) {\r\n        address to;\r\n        uint256 value;\r\n        bool isUserAddress;\r\n        bool canTransfer;\r\n        string memory transferFailMsg;\r\n\r\n        for (uint256 i = 0; i < _users.length; i++) {\r\n            to = _users[i];\r\n            value = _values[i];\r\n            isUserAddress = false;\r\n            canTransfer = false;\r\n            transferFailMsg = \"\";\r\n\r\n            // can not send token to contract address\r\n            //\u30b3\u30f3\u30c8\u30e9\u30af\u30c8\u30a2\u30c9\u30ec\u30b9\u306b\u30c8\u30fc\u30af\u30f3\u3092\u767a\u9001\u3067\u304d\u306a\u3044\u691c\u8a3c\r\n            assembly {\r\n                isUserAddress := iszero(extcodesize(to))\r\n            }\r\n\r\n            //data check\r\n            if (!isUserAddress) {\r\n                transferFailMsg = \"try to send token to contract\";\r\n            } else if (value <= 0) {\r\n                transferFailMsg = \"try to send wrong token amount\";\r\n            } else if (to == address(0)) {\r\n                transferFailMsg = \"try to send token to empty address\";\r\n            } else if (value > balances[_from]) {\r\n                transferFailMsg = \"token amount is larger than giver holding\";\r\n            } else {\r\n                canTransfer = true;\r\n            }\r\n\r\n            if (canTransfer) {\r\n                balances[_from] = balances[_from].sub(value);\r\n                balances[to] = balances[to].add(value);\r\n                emit Transfer(_from, to, value);\r\n            } else {\r\n                emit BatchTransferFail(_from, to, value, transferFailMsg);\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Burns msg.sender's token.\r\n     * @param _value The amount to burn.\r\n     */\r\n    function burn(uint256 _value) public onlyOwner {\r\n        super.burn(_value);\r\n    }\r\n\r\n    /**\r\n     * @dev Burns token of an address.\r\n     * @param _from The address to burn token from.\r\n     * @param _value The amount to burn.\r\n     */\r\n    function burnFrom(address _from, uint256 _value) public onlyOwner {\r\n        super.burnFrom(_from, _value);\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/SaleInfo.sol\r\n\r\npragma solidity ^0.4.18;\r\n\r\ncontract SaleInfo {\r\n    using SafeMath for uint256;\r\n\r\n    uint256 public privateOpeningTime;\r\n    uint256 public privateClosingTime;\r\n    uint256 public publicOpeningTime;\r\n    uint256 public publicClosingTime;\r\n    address public adminWallet;\r\n    address public saleOwnerWallet;\r\n    address public unsaleOwnerWallet;\r\n    address public ethManagementWallet;\r\n\r\n    constructor(\r\n        uint256 _privateOpeningTime,\r\n        uint256 _privateClosingTime,\r\n        uint256 _publicOpeningTime,\r\n        uint256 _publicClosingTime,\r\n        address _adminWallet,\r\n        address _saleOwnerWallet,\r\n        address _unsaleOwnerWallet,\r\n        address _ethManagementWallet\r\n    ) public {\r\n        privateOpeningTime = _privateOpeningTime;\r\n        privateClosingTime = _privateClosingTime;\r\n        publicOpeningTime = _publicOpeningTime;\r\n        publicClosingTime = _publicClosingTime;\r\n        adminWallet = _adminWallet;\r\n        saleOwnerWallet = _saleOwnerWallet;\r\n        unsaleOwnerWallet = _unsaleOwnerWallet;\r\n        ethManagementWallet = _ethManagementWallet;\r\n    }\r\n\r\n    /**\r\n     * @dev get admin wallet\r\n     */\r\n    function getAdminAddress() public view returns (address) {\r\n        return adminWallet;\r\n    }\r\n\r\n    /**\r\n     * @dev get owner wallet\r\n     */\r\n    function getSaleOwnerAddress() public view returns (address) {\r\n        return saleOwnerWallet;\r\n    }\r\n\r\n    /**\r\n     * @dev get unsale owner wallet\r\n     */\r\n    function getUnsaleOwnerAddress() public view returns (address) {\r\n        return unsaleOwnerWallet;\r\n    }\r\n\r\n    /**\r\n     * @dev get eth management owner wallet\r\n     */\r\n    function getEtherManagementAddress() public view returns (address) {\r\n        return ethManagementWallet;\r\n    }\r\n\r\n    /**\r\n     * @dev get start date for presale\r\n     */\r\n    function getPresaleOpeningDate() public view returns (uint256) {\r\n        return privateOpeningTime;\r\n    }\r\n\r\n    /**\r\n     * @dev get end date for presale\r\n     */\r\n    function getPresaleClosingDate() public view returns (uint256) {\r\n        return privateClosingTime;\r\n    }\r\n\r\n    /**\r\n     * @dev get start date for public sale\r\n     */\r\n    function getPublicsaleOpeningDate() public view returns (uint256) {\r\n        return publicOpeningTime;\r\n    }\r\n\r\n    /**\r\n     * @dev get end date for public sale\r\n     */\r\n    function getPublicsaleClosingDate() public view returns (uint256) {\r\n        return publicClosingTime;\r\n    }\r\n\r\n    /**\r\n     * @dev current time is in presale period or not\r\n     */\r\n    function inPresalePeriod() public view returns (bool) {\r\n        return ((now >= privateOpeningTime) && (now <= privateClosingTime));\r\n    }\r\n\r\n    /**\r\n     * @dev current time is in public sale period or not\r\n     */\r\n    function inPublicsalePeriod() public view returns (bool) {\r\n        return ((now >= publicOpeningTime) && (now <= publicClosingTime));\r\n    }\r\n}\r\n\r\n// File: contracts/BatchTransferable.sol\r\n\r\npragma solidity ^0.4.18;\r\n\r\n/**\r\n * @title BatchTransferable\r\n * @dev Base contract which allows children to run batch transfer token.\r\n */\r\ncontract BatchTransferable is Ownable {\r\n    event BatchTransferStop();\r\n\r\n    bool public batchTransferStopped = false;\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is do batch transfer token.\r\n     */\r\n    modifier whenBatchTransferNotStopped() {\r\n        require(!batchTransferStopped);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev called by the owner to stop, triggers stopped state\r\n     */\r\n    function batchTransferStop() public onlyOwner whenBatchTransferNotStopped {\r\n        batchTransferStopped = true;\r\n        emit BatchTransferStop();\r\n    }\r\n\r\n    /**\r\n     * @dev called to check that can do batch transfer or not\r\n     */\r\n    function isBatchTransferStop() public view returns (bool) {\r\n        return batchTransferStopped;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n  function safeTransfer(\r\n    ERC20Basic _token,\r\n    address _to,\r\n    uint256 _value\r\n  )\r\n    internal\r\n  {\r\n    require(_token.transfer(_to, _value));\r\n  }\r\n\r\n  function safeTransferFrom(\r\n    ERC20 _token,\r\n    address _from,\r\n    address _to,\r\n    uint256 _value\r\n  )\r\n    internal\r\n  {\r\n    require(_token.transferFrom(_from, _to, _value));\r\n  }\r\n\r\n  function safeApprove(\r\n    ERC20 _token,\r\n    address _spender,\r\n    uint256 _value\r\n  )\r\n    internal\r\n  {\r\n    require(_token.approve(_spender, _value));\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/crowdsale/Crowdsale.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n\r\n/**\r\n * @title Crowdsale\r\n * @dev Crowdsale is a base contract for managing a token crowdsale,\r\n * allowing investors to purchase tokens with ether. This contract implements\r\n * such functionality in its most fundamental form and can be extended to provide additional\r\n * functionality and/or custom behavior.\r\n * The external interface represents the basic interface for purchasing tokens, and conform\r\n * the base architecture for crowdsales. They are *not* intended to be modified / overridden.\r\n * The internal interface conforms the extensible and modifiable surface of crowdsales. Override\r\n * the methods to add functionality. Consider using 'super' where appropriate to concatenate\r\n * behavior.\r\n */\r\ncontract Crowdsale {\r\n  using SafeMath for uint256;\r\n  using SafeERC20 for ERC20;\r\n\r\n  // The token being sold\r\n  ERC20 public token;\r\n\r\n  // Address where funds are collected\r\n  address public wallet;\r\n\r\n  // How many token units a buyer gets per wei.\r\n  // The rate is the conversion between wei and the smallest and indivisible token unit.\r\n  // So, if you are using a rate of 1 with a DetailedERC20 token with 3 decimals called TOK\r\n  // 1 wei will give you 1 unit, or 0.001 TOK.\r\n  uint256 public rate;\r\n\r\n  // Amount of wei raised\r\n  uint256 public weiRaised;\r\n\r\n  /**\r\n   * Event for token purchase logging\r\n   * @param purchaser who paid for the tokens\r\n   * @param beneficiary who got the tokens\r\n   * @param value weis paid for purchase\r\n   * @param amount amount of tokens purchased\r\n   */\r\n  event TokenPurchase(\r\n    address indexed purchaser,\r\n    address indexed beneficiary,\r\n    uint256 value,\r\n    uint256 amount\r\n  );\r\n\r\n  /**\r\n   * @param _rate Number of token units a buyer gets per wei\r\n   * @param _wallet Address where collected funds will be forwarded to\r\n   * @param _token Address of the token being sold\r\n   */\r\n  constructor(uint256 _rate, address _wallet, ERC20 _token) public {\r\n    require(_rate > 0);\r\n    require(_wallet != address(0));\r\n    require(_token != address(0));\r\n\r\n    rate = _rate;\r\n    wallet = _wallet;\r\n    token = _token;\r\n  }\r\n\r\n  // -----------------------------------------\r\n  // Crowdsale external interface\r\n  // -----------------------------------------\r\n\r\n  /**\r\n   * @dev fallback function ***DO NOT OVERRIDE***\r\n   */\r\n  function () external payable {\r\n    buyTokens(msg.sender);\r\n  }\r\n\r\n  /**\r\n   * @dev low level token purchase ***DO NOT OVERRIDE***\r\n   * @param _beneficiary Address performing the token purchase\r\n   */\r\n  function buyTokens(address _beneficiary) public payable {\r\n\r\n    uint256 weiAmount = msg.value;\r\n    _preValidatePurchase(_beneficiary, weiAmount);\r\n\r\n    // calculate token amount to be created\r\n    uint256 tokens = _getTokenAmount(weiAmount);\r\n\r\n    // update state\r\n    weiRaised = weiRaised.add(weiAmount);\r\n\r\n    _processPurchase(_beneficiary, tokens);\r\n    emit TokenPurchase(\r\n      msg.sender,\r\n      _beneficiary,\r\n      weiAmount,\r\n      tokens\r\n    );\r\n\r\n    _updatePurchasingState(_beneficiary, weiAmount);\r\n\r\n    _forwardFunds();\r\n    _postValidatePurchase(_beneficiary, weiAmount);\r\n  }\r\n\r\n  // -----------------------------------------\r\n  // Internal interface (extensible)\r\n  // -----------------------------------------\r\n\r\n  /**\r\n   * @dev Validation of an incoming purchase. Use require statements to revert state when conditions are not met. Use `super` in contracts that inherit from Crowdsale to extend their validations.\r\n   * Example from CappedCrowdsale.sol's _preValidatePurchase method:\r\n   *   super._preValidatePurchase(_beneficiary, _weiAmount);\r\n   *   require(weiRaised.add(_weiAmount) <= cap);\r\n   * @param _beneficiary Address performing the token purchase\r\n   * @param _weiAmount Value in wei involved in the purchase\r\n   */\r\n  function _preValidatePurchase(\r\n    address _beneficiary,\r\n    uint256 _weiAmount\r\n  )\r\n    internal\r\n  {\r\n    require(_beneficiary != address(0));\r\n    require(_weiAmount != 0);\r\n  }\r\n\r\n  /**\r\n   * @dev Validation of an executed purchase. Observe state and use revert statements to undo rollback when valid conditions are not met.\r\n   * @param _beneficiary Address performing the token purchase\r\n   * @param _weiAmount Value in wei involved in the purchase\r\n   */\r\n  function _postValidatePurchase(\r\n    address _beneficiary,\r\n    uint256 _weiAmount\r\n  )\r\n    internal\r\n  {\r\n    // optional override\r\n  }\r\n\r\n  /**\r\n   * @dev Source of tokens. Override this method to modify the way in which the crowdsale ultimately gets and sends its tokens.\r\n   * @param _beneficiary Address performing the token purchase\r\n   * @param _tokenAmount Number of tokens to be emitted\r\n   */\r\n  function _deliverTokens(\r\n    address _beneficiary,\r\n    uint256 _tokenAmount\r\n  )\r\n    internal\r\n  {\r\n    token.safeTransfer(_beneficiary, _tokenAmount);\r\n  }\r\n\r\n  /**\r\n   * @dev Executed when a purchase has been validated and is ready to be executed. Not necessarily emits/sends tokens.\r\n   * @param _beneficiary Address receiving the tokens\r\n   * @param _tokenAmount Number of tokens to be purchased\r\n   */\r\n  function _processPurchase(\r\n    address _beneficiary,\r\n    uint256 _tokenAmount\r\n  )\r\n    internal\r\n  {\r\n    _deliverTokens(_beneficiary, _tokenAmount);\r\n  }\r\n\r\n  /**\r\n   * @dev Override for extensions that require an internal state to check for validity (current user contributions, etc.)\r\n   * @param _beneficiary Address receiving the tokens\r\n   * @param _weiAmount Value in wei involved in the purchase\r\n   */\r\n  function _updatePurchasingState(\r\n    address _beneficiary,\r\n    uint256 _weiAmount\r\n  )\r\n    internal\r\n  {\r\n    // optional override\r\n  }\r\n\r\n  /**\r\n   * @dev Override to extend the way in which ether is converted to tokens.\r\n   * @param _weiAmount Value in wei to be converted into tokens\r\n   * @return Number of tokens that can be purchased with the specified _weiAmount\r\n   */\r\n  function _getTokenAmount(uint256 _weiAmount)\r\n    internal view returns (uint256)\r\n  {\r\n    return _weiAmount.mul(rate);\r\n  }\r\n\r\n  /**\r\n   * @dev Determines how ETH is stored/forwarded on purchases.\r\n   */\r\n  function _forwardFunds() internal {\r\n    wallet.transfer(msg.value);\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/crowdsale/validation/TimedCrowdsale.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n/**\r\n * @title TimedCrowdsale\r\n * @dev Crowdsale accepting contributions only within a time frame.\r\n */\r\ncontract TimedCrowdsale is Crowdsale {\r\n  using SafeMath for uint256;\r\n\r\n  uint256 public openingTime;\r\n  uint256 public closingTime;\r\n\r\n  /**\r\n   * @dev Reverts if not in crowdsale time range.\r\n   */\r\n  modifier onlyWhileOpen {\r\n    // solium-disable-next-line security/no-block-members\r\n    require(block.timestamp >= openingTime && block.timestamp <= closingTime);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Constructor, takes crowdsale opening and closing times.\r\n   * @param _openingTime Crowdsale opening time\r\n   * @param _closingTime Crowdsale closing time\r\n   */\r\n  constructor(uint256 _openingTime, uint256 _closingTime) public {\r\n    // solium-disable-next-line security/no-block-members\r\n    require(_openingTime >= block.timestamp);\r\n    require(_closingTime >= _openingTime);\r\n\r\n    openingTime = _openingTime;\r\n    closingTime = _closingTime;\r\n  }\r\n\r\n  /**\r\n   * @dev Checks whether the period in which the crowdsale is open has already elapsed.\r\n   * @return Whether crowdsale period has elapsed\r\n   */\r\n  function hasClosed() public view returns (bool) {\r\n    // solium-disable-next-line security/no-block-members\r\n    return block.timestamp > closingTime;\r\n  }\r\n\r\n  /**\r\n   * @dev Extend parent behavior requiring to be within contributing period\r\n   * @param _beneficiary Token purchaser\r\n   * @param _weiAmount Amount of wei contributed\r\n   */\r\n  function _preValidatePurchase(\r\n    address _beneficiary,\r\n    uint256 _weiAmount\r\n  )\r\n    internal\r\n    onlyWhileOpen\r\n  {\r\n    super._preValidatePurchase(_beneficiary, _weiAmount);\r\n  }\r\n\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/lifecycle/Pausable.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() public onlyOwner whenNotPaused {\r\n    paused = true;\r\n    emit Pause();\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() public onlyOwner whenPaused {\r\n    paused = false;\r\n    emit Unpause();\r\n  }\r\n}\r\n\r\n// File: contracts/ERC20TokenCrowdsale.sol\r\n\r\npragma solidity ^0.4.18;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract ERC20TokenCrowdsale is\r\n    TimedCrowdsale,\r\n    Ownable,\r\n    Pausable,\r\n    BatchTransferable\r\n{\r\n    using SafeMath for uint256;\r\n\r\n    address public adminWallet; //wallet to controll system\r\n    address public saleOwnerWallet;\r\n    address public unsaleOwnerWallet;\r\n    address public ethManagementWallet; //wallet to reveive eth\r\n\r\n    uint256 public minimumWeiAmount;\r\n    uint256 private rateDigit;\r\n\r\n    ERC20Token public erc20Token;\r\n    SaleInfo public saleInfo;\r\n    WhiteList public whiteList;\r\n    GroupLockup public groupLockup;\r\n\r\n    event PresalePurchase(address indexed purchaser, uint256 value);\r\n    event PublicsalePurchase(\r\n        address indexed purchaser,\r\n        uint256 value,\r\n        uint256 amount,\r\n        uint256 rate\r\n    );\r\n    event UpdateRate(address indexed updater, uint256 rate);\r\n    event UpdateMinimumAmount(\r\n        address indexed updater,\r\n        uint256 minimumWeiAmount\r\n    );\r\n    event GiveToken(\r\n        address indexed purchaser,\r\n        uint256 amount,\r\n        uint256 lockupTime\r\n    );\r\n\r\n    constructor(\r\n        uint256 _openingTime,\r\n        uint256 _closingTime,\r\n        uint256 _rate,\r\n        uint256 _rateDigit,\r\n        uint256 _minimumWeiAmount,\r\n        address _adminWallet,\r\n        address _saleOwnerWallet,\r\n        address _unsaleOwnerWallet,\r\n        address _ethManagementWallet,\r\n        ERC20Token _erc20,\r\n        SaleInfo _saleInfo,\r\n        WhiteList _whiteList,\r\n        GroupLockup _groupLockup\r\n    )\r\n        public\r\n        Crowdsale(_rate, _ethManagementWallet, _erc20)\r\n        TimedCrowdsale(_openingTime, _closingTime)\r\n    {\r\n        adminWallet = _adminWallet;\r\n        saleOwnerWallet = _saleOwnerWallet;\r\n        unsaleOwnerWallet = _unsaleOwnerWallet;\r\n        ethManagementWallet = _ethManagementWallet;\r\n        erc20Token = _erc20;\r\n        saleInfo = _saleInfo;\r\n        whiteList = _whiteList;\r\n        groupLockup = _groupLockup;\r\n        rateDigit = _rateDigit;\r\n        minimumWeiAmount = _minimumWeiAmount;\r\n\r\n        emit UpdateRate(msg.sender, _rate);\r\n        emit UpdateMinimumAmount(msg.sender, _minimumWeiAmount);\r\n    }\r\n\r\n    /**\r\n     * @dev low level token purchase ***DO NOT OVERRIDE***\r\n     * @param _beneficiary Address performing the token purchase\r\n     */\r\n    function buyTokens(address _beneficiary)\r\n        public\r\n        payable\r\n        onlyWhileOpen\r\n        whenNotPaused\r\n    {\r\n        uint256 weiAmount = msg.value;\r\n        _preValidatePurchase(_beneficiary, weiAmount);\r\n\r\n        // calculate token amount to be created\r\n        uint256 tokens = _getTokenAmount(weiAmount.div(rateDigit));\r\n\r\n        // update state\r\n        weiRaised = weiRaised.add(weiAmount);\r\n\r\n        _processPurchase(_beneficiary, tokens);\r\n        emit TokenPurchase(msg.sender, _beneficiary, weiAmount, tokens);\r\n\r\n        _updatePurchasingState(_beneficiary, weiAmount);\r\n\r\n        _forwardFunds();\r\n        _postValidatePurchase(_beneficiary, weiAmount);\r\n    }\r\n\r\n    /**\r\n     * @dev Validation of an incoming purchase. Use require statemens to revert state when conditions are not met. Use super to concatenate validations.\r\n     * @param _beneficiary Address performing the token purchase\r\n     * @param _weiAmount Value in wei involved in the purchase\r\n     */\r\n    function _preValidatePurchase(address _beneficiary, uint256 _weiAmount)\r\n        internal\r\n    {\r\n        require(_beneficiary != address(0));\r\n        require(_weiAmount != 0);\r\n        require(_weiAmount % rateDigit == 0);\r\n\r\n        //minimum ether check\r\n        require(_weiAmount >= minimumWeiAmount);\r\n\r\n        //owner can not purchase token\r\n        require(_beneficiary != adminWallet);\r\n        require(_beneficiary != saleOwnerWallet);\r\n        require(_beneficiary != unsaleOwnerWallet);\r\n        require(_beneficiary != ethManagementWallet);\r\n\r\n        require(saleInfo.inPresalePeriod() || saleInfo.inPublicsalePeriod());\r\n\r\n        //whitelist check\r\n        //whitelist status:1-presale user, 2-public sale user\r\n        uint8 inWhitelist = whiteList.checkList(_beneficiary);\r\n\r\n        if (saleInfo.inPresalePeriod()) {\r\n            //if need to check whitelist status in presale period\r\n            if (whiteList.getPresaleWhitelistStatus()) {\r\n                require(inWhitelist == 1);\r\n            }\r\n        } else {\r\n            //if need to check whitelist status in public sale period\r\n            if (whiteList.getPublicSaleWhitelistStatus()) {\r\n                require((inWhitelist == 1) || (inWhitelist == 2));\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Source of tokens. Override this method to modify the way in which the crowdsale ultimately gets and sends its tokens.\r\n     * @param _beneficiary Address performing the token purchase\r\n     * @param _tokenAmount Number of tokens to be emitted\r\n     */\r\n    function _deliverTokens(address _beneficiary, uint256 _tokenAmount)\r\n        internal\r\n    {\r\n        //will not send token directly when purchaser purchase the token in presale\r\n        if (saleInfo.inPresalePeriod()) {\r\n            emit PresalePurchase(_beneficiary, msg.value);\r\n        } else {\r\n            require(erc20Token.sendTokens(_beneficiary, _tokenAmount));\r\n            emit PublicsalePurchase(\r\n                _beneficiary,\r\n                msg.value,\r\n                _tokenAmount,\r\n                rate\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev send token and set token lockup status to specific user\r\n     *  file format:\r\n     *          [\r\n     *                  [<address>, <token amount>, <lockup time>],\r\n     *                  [<address>, <token amount>, <lockup time>],...\r\n     *          ]\r\n     * @param _beneficiary Address\r\n     * @param _tokenAmount token amount\r\n     * @param _lockupTime uint256 this address's lockup time\r\n     * @return A bool that indicates if the operation was successful.\r\n     */\r\n    function giveToken(\r\n        address _beneficiary,\r\n        uint256 _tokenAmount,\r\n        uint256 _lockupTime\r\n    ) public onlyOwner returns (bool) {\r\n        require(_beneficiary != address(0));\r\n\r\n        require(_tokenAmount > 0);\r\n\r\n        if (_lockupTime != 0) {\r\n            //add this account in to lockup list\r\n            require(updateLockupList(_beneficiary, _lockupTime));\r\n        }\r\n\r\n        require(erc20Token.sendTokens(_beneficiary, _tokenAmount));\r\n\r\n        emit GiveToken(_beneficiary, _tokenAmount, _lockupTime);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev send token to mulitple user\r\n     * @param _from token provider address\r\n     * @param _users user address list\r\n     * @param _values the token amount list that want to deliver\r\n     * @return A bool the operation was successful.\r\n     */\r\n    function batchTransfer(\r\n        address _from,\r\n        address[] _users,\r\n        uint256[] _values\r\n    ) public onlyOwner whenBatchTransferNotStopped returns (bool) {\r\n        require(\r\n            _users.length > 0 &&\r\n                _values.length > 0 &&\r\n                _users.length == _values.length,\r\n            \"list error\"\r\n        );\r\n\r\n        require(\r\n            _from != address(0),\r\n            \"token giver wallet is not the correct address\"\r\n        );\r\n\r\n        require(erc20Token.batchTransfer(_from, _users, _values), \"batch transfer failed\");\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev set lockup status to mulitple user\r\n     * @param _users user address list\r\n     * @param _lockupDates uint256 user lockup time\r\n     * @return A bool the operation was successful.\r\n     */\r\n    function batchUpdateLockupList(address[] _users, uint256[] _lockupDates)\r\n        public\r\n        onlyOwner\r\n        returns (bool)\r\n    {\r\n        require(\r\n            _users.length > 0 &&\r\n                _lockupDates.length > 0 &&\r\n                _users.length == _lockupDates.length,\r\n            \"list error\"\r\n        );\r\n\r\n        address user;\r\n        uint256 lockupDate;\r\n\r\n        for (uint256 i = 0; i < _users.length; i++) {\r\n            user = _users[i];\r\n            lockupDate = _lockupDates[i];\r\n\r\n            updateLockupList(user, lockupDate);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Function update lockup status for purchaser\r\n     * @param _add address\r\n     * @param _lockupDate uint256 this user's lockup time\r\n     * @return A bool that indicates if the operation was successful.\r\n     */\r\n    function updateLockupList(address _add, uint256 _lockupDate)\r\n        public\r\n        onlyOwner\r\n        returns (bool)\r\n    {\r\n        return groupLockup.updateLockupList(_add, _lockupDate);\r\n    }\r\n\r\n    /**\r\n     * @dev Function update lockup time\r\n     * @param _oldLockupDate uint256\r\n     * @param _newLockupDate uint256\r\n     * @return A bool that indicates if the operation was successful.\r\n     */\r\n    function updateLockupTime(uint256 _oldLockupDate, uint256 _newLockupDate)\r\n        public\r\n        onlyOwner\r\n        returns (bool)\r\n    {\r\n        return groupLockup.updateLockupTime(_oldLockupDate, _newLockupDate);\r\n    }\r\n\r\n    /**\r\n     * @dev called for get status of pause.\r\n     */\r\n    function ispause() public view returns (bool) {\r\n        return paused;\r\n    }\r\n\r\n    /**\r\n     * @dev Function update rate\r\n     * @param _newRate rate\r\n     * @return A bool that indicates if the operation was successful.\r\n     */\r\n    function updateRate(int256 _newRate) public onlyOwner returns (bool) {\r\n        require(_newRate >= 1);\r\n\r\n        rate = uint256(_newRate);\r\n\r\n        emit UpdateRate(msg.sender, rate);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Function get rate\r\n     * @return A uint256 that indicates if the operation was successful.\r\n     */\r\n    function getRate() public view returns (uint256) {\r\n        return rate;\r\n    }\r\n\r\n    /**\r\n     * @dev Function get minimum wei amount\r\n     * @return A uint256 that indicates if the operation was successful.\r\n     */\r\n    function getMinimumAmount() public view returns (uint256) {\r\n        return minimumWeiAmount;\r\n    }\r\n\r\n    /**\r\n     * @dev Function update minimum wei amount\r\n     * @return A uint256 that indicates if the operation was successful.\r\n     */\r\n    function updateMinimumAmount(int256 _newMnimumWeiAmount)\r\n        public\r\n        onlyOwner\r\n        returns (bool)\r\n    {\r\n        require(_newMnimumWeiAmount >= 0);\r\n\r\n        minimumWeiAmount = uint256(_newMnimumWeiAmount);\r\n\r\n        emit UpdateMinimumAmount(msg.sender, minimumWeiAmount);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Function mint token\r\n     * @param _add user wallet\r\n     * @param _amount amount want to mint\r\n     * @return A bool that indicates if the operation was successful.\r\n     */\r\n    function mint(address _add, int256 _amount)\r\n        public\r\n        onlyOwner\r\n        returns (bool)\r\n    {\r\n        require(_add != address(0), \"user wallet is not the correct address\");\r\n\r\n        require(_amount > 0, \"invalid amount\");\r\n\r\n        uint256 amount = uint256(_amount);\r\n\r\n        erc20Token.mint(_add, amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Function mint stop\r\n     * @return A bool that indicates if the operation was successful.\r\n     */\r\n    function finishMinting() public onlyOwner returns (bool) {\r\n        erc20Token.finishMinting();\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Function burn token\r\n     * @param _amount amount to burn.\r\n     * @return A bool that indicates if the operation was successful.\r\n     */\r\n    function burn(int256 _amount)\r\n        public\r\n        onlyOwner\r\n        returns (bool)\r\n    {\r\n        require(_amount > 0, \"invalid amount\");\r\n\r\n        uint256 amount = uint256(_amount);\r\n        erc20Token.burn(amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Function burn token\r\n     * @param _add address to burn token from\r\n     * @param _amount amount to burn.\r\n     * @return A bool that indicates if the operation was successful.\r\n     */\r\n    function burnFrom(address _add, int256 _amount)\r\n        public\r\n        onlyOwner\r\n        returns (bool)\r\n    {\r\n        require(_add != address(0), \"user wallet is not the correct address\");\r\n        require(_amount > 0, \"invalid amount\");\r\n\r\n        uint256 amount = uint256(_amount);\r\n        erc20Token.burnFrom(_add, amount);\r\n\r\n        return true;\r\n    }\r\n}", "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"sendTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mintingFinished\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_users\",\"type\":\"address[]\"},{\"name\":\"_values\",\"type\":\"uint256[]\"}],\"name\":\"batchTransfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"unsaleOwnerWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"INITIAL_SUPPLY\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"INITIAL_UNSALE_SUPPLY\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burnFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finishMinting\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ownerWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"groupLockup\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"INITIAL_SALE_SUPPLY\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_saleOwnerWallet\",\"type\":\"address\"},{\"name\":\"_unsaleOwnerWallet\",\"type\":\"address\"},{\"name\":\"_groupLockup\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"msg\",\"type\":\"string\"}],\"name\":\"BatchTransferFail\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"MintFinished\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"burner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]", "ContractName": "ERC20Token", "CompilerVersion": "v0.4.26+commit.4563c3fc", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000b88e8407aaf69382994234e4d64f5933a89541b80000000000000000000000005ec59b6ea0b67b90c732e5efa7f78c441adc0838000000000000000000000000b7a1070179f4b093e1fc391a8221afdb681ddead", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://99f1fc96d91e9ad993885232b0a055a1bf18c8c136e5e639835bcd8d0c92329c"}