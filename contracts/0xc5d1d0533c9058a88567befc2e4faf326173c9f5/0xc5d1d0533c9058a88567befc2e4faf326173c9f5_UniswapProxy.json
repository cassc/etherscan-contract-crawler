{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 999999999\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"contracts/UniswapProxy.sol\": {\r\n      \"content\": \"pragma solidity =0.8.0;\\r\\npragma abicoder v2;\\r\\n\\r\\n// UNISWAP V2\\r\\ninterface IUniswapV2Router01 {\\r\\n\\tfunction factory() external pure returns (address);\\r\\n\\tfunction WETH() external pure returns (address);\\r\\n\\r\\n\\tfunction addLiquidity(\\r\\n\\t\\taddress tokenA,\\r\\n\\t\\taddress tokenB,\\r\\n\\t\\tuint amountADesired,\\r\\n\\t\\tuint amountBDesired,\\r\\n\\t\\tuint amountAMin,\\r\\n\\t\\tuint amountBMin,\\r\\n\\t\\taddress to,\\r\\n\\t\\tuint deadline\\r\\n\\t) external returns (uint amountA, uint amountB, uint liquidity);\\r\\n\\tfunction addLiquidityETH(\\r\\n\\t\\taddress token,\\r\\n\\t\\tuint amountTokenDesired,\\r\\n\\t\\tuint amountTokenMin,\\r\\n\\t\\tuint amountETHMin,\\r\\n\\t\\taddress to,\\r\\n\\t\\tuint deadline\\r\\n\\t) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\r\\n\\tfunction removeLiquidity(\\r\\n\\t\\taddress tokenA,\\r\\n\\t\\taddress tokenB,\\r\\n\\t\\tuint liquidity,\\r\\n\\t\\tuint amountAMin,\\r\\n\\t\\tuint amountBMin,\\r\\n\\t\\taddress to,\\r\\n\\t\\tuint deadline\\r\\n\\t) external returns (uint amountA, uint amountB);\\r\\n\\tfunction removeLiquidityETH(\\r\\n\\t\\taddress token,\\r\\n\\t\\tuint liquidity,\\r\\n\\t\\tuint amountTokenMin,\\r\\n\\t\\tuint amountETHMin,\\r\\n\\t\\taddress to,\\r\\n\\t\\tuint deadline\\r\\n\\t) external returns (uint amountToken, uint amountETH);\\r\\n\\tfunction removeLiquidityWithPermit(\\r\\n\\t\\taddress tokenA,\\r\\n\\t\\taddress tokenB,\\r\\n\\t\\tuint liquidity,\\r\\n\\t\\tuint amountAMin,\\r\\n\\t\\tuint amountBMin,\\r\\n\\t\\taddress to,\\r\\n\\t\\tuint deadline,\\r\\n\\t\\tbool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n\\t) external returns (uint amountA, uint amountB);\\r\\n\\tfunction removeLiquidityETHWithPermit(\\r\\n\\t\\taddress token,\\r\\n\\t\\tuint liquidity,\\r\\n\\t\\tuint amountTokenMin,\\r\\n\\t\\tuint amountETHMin,\\r\\n\\t\\taddress to,\\r\\n\\t\\tuint deadline,\\r\\n\\t\\tbool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n\\t) external returns (uint amountToken, uint amountETH);\\r\\n\\tfunction swapExactTokensForTokens(\\r\\n\\t\\tuint amountIn,\\r\\n\\t\\tuint amountOutMin,\\r\\n\\t\\taddress[] calldata path,\\r\\n\\t\\taddress to,\\r\\n\\t\\tuint deadline\\r\\n\\t) external returns (uint[] memory amounts);\\r\\n\\tfunction swapTokensForExactTokens(\\r\\n\\t\\tuint amountOut,\\r\\n\\t\\tuint amountInMax,\\r\\n\\t\\taddress[] calldata path,\\r\\n\\t\\taddress to,\\r\\n\\t\\tuint deadline\\r\\n\\t) external returns (uint[] memory amounts);\\r\\n\\tfunction swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\r\\n\\t\\texternal\\r\\n\\t\\tpayable\\r\\n\\t\\treturns (uint[] memory amounts);\\r\\n\\tfunction swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\r\\n\\t\\texternal\\r\\n\\t\\treturns (uint[] memory amounts);\\r\\n\\tfunction swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\r\\n\\t\\texternal\\r\\n\\t\\treturns (uint[] memory amounts);\\r\\n\\tfunction swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\r\\n\\t\\texternal\\r\\n\\t\\tpayable\\r\\n\\t\\treturns (uint[] memory amounts);\\r\\n\\r\\n\\tfunction quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\r\\n\\tfunction getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\r\\n\\tfunction getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\r\\n\\tfunction getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\r\\n\\tfunction getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\r\\n}\\r\\n\\r\\ninterface IUniswapV2Router is IUniswapV2Router01 {\\r\\n\\tfunction removeLiquidityETHSupportingFeeOnTransferTokens(\\r\\n\\t\\taddress token,\\r\\n\\t\\tuint liquidity,\\r\\n\\t\\tuint amountTokenMin,\\r\\n\\t\\tuint amountETHMin,\\r\\n\\t\\taddress to,\\r\\n\\t\\tuint deadline\\r\\n\\t) external returns (uint amountETH);\\r\\n\\tfunction removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\r\\n\\t\\taddress token,\\r\\n\\t\\tuint liquidity,\\r\\n\\t\\tuint amountTokenMin,\\r\\n\\t\\tuint amountETHMin,\\r\\n\\t\\taddress to,\\r\\n\\t\\tuint deadline,\\r\\n\\t\\tbool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n\\t) external returns (uint amountETH);\\r\\n\\r\\n\\tfunction swapExactTokensForTokensSupportingFeeOnTransferTokens(\\r\\n\\t\\tuint amountIn,\\r\\n\\t\\tuint amountOutMin,\\r\\n\\t\\taddress[] calldata path,\\r\\n\\t\\taddress to,\\r\\n\\t\\tuint deadline\\r\\n\\t) external;\\r\\n\\tfunction swapExactETHForTokensSupportingFeeOnTransferTokens(\\r\\n\\t\\tuint amountOutMin,\\r\\n\\t\\taddress[] calldata path,\\r\\n\\t\\taddress to,\\r\\n\\t\\tuint deadline\\r\\n\\t) external payable;\\r\\n\\tfunction swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n\\t\\tuint amountIn,\\r\\n\\t\\tuint amountOutMin,\\r\\n\\t\\taddress[] calldata path,\\r\\n\\t\\taddress to,\\r\\n\\t\\tuint deadline\\r\\n\\t) external;\\r\\n}\\r\\n\\r\\n\\r\\n// UNISWAP V3\\r\\ninterface IMulticall {\\r\\n\\tfunction multicall(bytes[] calldata data) external payable returns (bytes[] memory results);\\r\\n}\\r\\n\\r\\ninterface IMulticallExtended is IMulticall {\\r\\n\\tfunction multicall(uint256 deadline, bytes[] calldata data) external payable returns (bytes[] memory results);\\r\\n\\r\\n\\tfunction multicall(bytes32 previousBlockhash, bytes[] calldata data)\\r\\n\\t\\texternal\\r\\n\\t\\tpayable\\r\\n\\t\\treturns (bytes[] memory results);\\r\\n}\\r\\n\\r\\ninterface ISelfPermit {\\r\\n\\tfunction selfPermit(\\r\\n\\t\\taddress token,\\r\\n\\t\\tuint256 value,\\r\\n\\t\\tuint256 deadline,\\r\\n\\t\\tuint8 v,\\r\\n\\t\\tbytes32 r,\\r\\n\\t\\tbytes32 s\\r\\n\\t) external payable;\\r\\n\\r\\n\\tfunction selfPermitIfNecessary(\\r\\n\\t\\taddress token,\\r\\n\\t\\tuint256 value,\\r\\n\\t\\tuint256 deadline,\\r\\n\\t\\tuint8 v,\\r\\n\\t\\tbytes32 r,\\r\\n\\t\\tbytes32 s\\r\\n\\t) external payable;\\r\\n\\r\\n\\tfunction selfPermitAllowed(\\r\\n\\t\\taddress token,\\r\\n\\t\\tuint256 nonce,\\r\\n\\t\\tuint256 expiry,\\r\\n\\t\\tuint8 v,\\r\\n\\t\\tbytes32 r,\\r\\n\\t\\tbytes32 s\\r\\n\\t) external payable;\\r\\n\\r\\n\\tfunction selfPermitAllowedIfNecessary(\\r\\n\\t\\taddress token,\\r\\n\\t\\tuint256 nonce,\\r\\n\\t\\tuint256 expiry,\\r\\n\\t\\tuint8 v,\\r\\n\\t\\tbytes32 r,\\r\\n\\t\\tbytes32 s\\r\\n\\t) external payable;\\r\\n}\\r\\n\\r\\ninterface IApproveAndCall {\\r\\n\\tenum ApprovalType {NOT_REQUIRED, MAX, MAX_MINUS_ONE, ZERO_THEN_MAX, ZERO_THEN_MAX_MINUS_ONE}\\r\\n\\r\\n\\tfunction getApprovalType(address token, uint256 amount) external returns (ApprovalType);\\r\\n\\r\\n\\tfunction approveMax(address token) external payable;\\r\\n\\r\\n\\tfunction approveMaxMinusOne(address token) external payable;\\r\\n\\r\\n\\tfunction approveZeroThenMax(address token) external payable;\\r\\n\\r\\n\\tfunction approveZeroThenMaxMinusOne(address token) external payable;\\r\\n\\r\\n\\tfunction callPositionManager(bytes memory data) external payable returns (bytes memory result);\\r\\n\\r\\n\\tstruct MintParams {\\r\\n\\t\\taddress token0;\\r\\n\\t\\taddress token1;\\r\\n\\t\\tuint24 fee;\\r\\n\\t\\tint24 tickLower;\\r\\n\\t\\tint24 tickUpper;\\r\\n\\t\\tuint256 amount0Min;\\r\\n\\t\\tuint256 amount1Min;\\r\\n\\t\\taddress recipient;\\r\\n\\t}\\r\\n\\r\\n\\tfunction mint(MintParams calldata params) external payable returns (bytes memory result);\\r\\n\\r\\n\\tstruct IncreaseLiquidityParams {\\r\\n\\t\\taddress token0;\\r\\n\\t\\taddress token1;\\r\\n\\t\\tuint256 tokenId;\\r\\n\\t\\tuint256 amount0Min;\\r\\n\\t\\tuint256 amount1Min;\\r\\n\\t}\\r\\n\\r\\n\\tfunction increaseLiquidity(IncreaseLiquidityParams calldata params) external payable returns (bytes memory result);\\r\\n}\\r\\n\\r\\ninterface IUniswapV3SwapCallback {\\r\\n\\tfunction uniswapV3SwapCallback(\\r\\n\\t\\tint256 amount0Delta,\\r\\n\\t\\tint256 amount1Delta,\\r\\n\\t\\tbytes calldata data\\r\\n\\t) external;\\r\\n}\\r\\n\\r\\ninterface IV3SwapRouter is IUniswapV3SwapCallback {\\r\\n\\tstruct ExactInputSingleParams {\\r\\n\\t\\taddress tokenIn;\\r\\n\\t\\taddress tokenOut;\\r\\n\\t\\tuint24 fee;\\r\\n\\t\\taddress recipient;\\r\\n\\t\\tuint256 amountIn;\\r\\n\\t\\tuint256 amountOutMinimum;\\r\\n\\t\\tuint160 sqrtPriceLimitX96;\\r\\n\\t}\\r\\n\\r\\n\\tfunction exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\\r\\n\\r\\n\\tstruct ExactInputParams {\\r\\n\\t\\tbytes path;\\r\\n\\t\\taddress recipient;\\r\\n\\t\\tuint256 amountIn;\\r\\n\\t\\tuint256 amountOutMinimum;\\r\\n\\t}\\r\\n\\r\\n\\tfunction exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);\\r\\n\\r\\n\\tstruct ExactOutputSingleParams {\\r\\n\\t\\taddress tokenIn;\\r\\n\\t\\taddress tokenOut;\\r\\n\\t\\tuint24 fee;\\r\\n\\t\\taddress recipient;\\r\\n\\t\\tuint256 amountOut;\\r\\n\\t\\tuint256 amountInMaximum;\\r\\n\\t\\tuint160 sqrtPriceLimitX96;\\r\\n\\t}\\r\\n\\r\\n\\tfunction exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);\\r\\n\\r\\n\\tstruct ExactOutputParams {\\r\\n\\t\\tbytes path;\\r\\n\\t\\taddress recipient;\\r\\n\\t\\tuint256 amountOut;\\r\\n\\t\\tuint256 amountInMaximum;\\r\\n\\t}\\r\\n\\r\\n\\tfunction exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);\\r\\n}\\r\\n\\r\\ninterface IV2SwapRouter {\\r\\n\\tfunction swapExactTokensForTokens(\\r\\n\\t\\tuint256 amountIn,\\r\\n\\t\\tuint256 amountOutMin,\\r\\n\\t\\taddress[] calldata path,\\r\\n\\t\\taddress to\\r\\n\\t) external payable returns (uint256 amountOut);\\r\\n\\r\\n\\tfunction swapTokensForExactTokens(\\r\\n\\t\\tuint256 amountOut,\\r\\n\\t\\tuint256 amountInMax,\\r\\n\\t\\taddress[] calldata path,\\r\\n\\t\\taddress to\\r\\n\\t) external payable returns (uint256 amountIn);\\r\\n}\\r\\n\\r\\ninterface ISwapRouter02 is IV2SwapRouter, IV3SwapRouter, IApproveAndCall, IMulticallExtended, ISelfPermit {\\r\\n\\r\\n}\\r\\n\\r\\ninterface IPeripheryPayments {\\r\\n\\tfunction unwrapWETH9(uint256 amountMinimum, address recipient) external payable;\\r\\n\\r\\n\\tfunction refundETH() external payable;\\r\\n\\r\\n\\tfunction sweepToken(\\r\\n\\t\\taddress token,\\r\\n\\t\\tuint256 amountMinimum,\\r\\n\\t\\taddress recipient\\r\\n\\t) external payable;\\r\\n}\\r\\n\\r\\n\\r\\n// UTILS\\r\\ninterface IERC20 {\\r\\n\\tevent Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n\\tevent Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n\\r\\n\\tfunction totalSupply() external view returns (uint256);\\r\\n\\r\\n\\tfunction balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n\\tfunction transfer(address to, uint256 amount) external returns (bool);\\r\\n\\r\\n\\tfunction allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n\\tfunction approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n\\tfunction transferFrom(\\r\\n\\t\\taddress from,\\r\\n\\t\\taddress to,\\r\\n\\t\\tuint256 amount\\r\\n\\t) external returns (bool);\\r\\n}\\r\\n\\r\\nabstract contract Context {\\r\\n\\tfunction _msgSender() internal view virtual returns (address) {\\r\\n\\t\\treturn msg.sender;\\r\\n\\t}\\r\\n\\r\\n\\tfunction _msgData() internal view virtual returns (bytes calldata) {\\r\\n\\t\\treturn msg.data;\\r\\n\\t}\\r\\n}\\r\\n\\r\\nabstract contract Owned is Context\\r\\n{\\r\\n\\tevent OwnershipTransfered(address indexed previousOwner, address indexed newOwner);\\r\\n\\t\\r\\n\\taddress private _owner;\\r\\n\\r\\n\\t/**\\r\\n\\t* @dev Initializes the contract, setting owner.\\r\\n\\t*/\\r\\n\\tconstructor()\\r\\n\\t{\\r\\n\\t\\t_setOwner(msg.sender);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t* @dev Returns the address of the current owner.\\r\\n\\t*/\\r\\n\\tfunction owner() public view returns (address)\\r\\n\\t{ return _owner; }\\r\\n\\r\\n\\t/**\\r\\n\\t* @dev Transfers owner permissions to a new account (`newOwner`).\\r\\n\\t* Can only be called by owner.\\r\\n\\t*/\\r\\n\\tfunction setOwner(address newOwner) external onlyOwner\\r\\n\\t{\\r\\n\\t\\trequire(newOwner != address(0), \\\"Owned: new owner can't be zero address\\\");\\r\\n\\t\\t_setOwner(newOwner);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t* @dev Throws if called by any account other than the owner.\\r\\n\\t*/\\r\\n\\tmodifier onlyOwner()\\r\\n\\t{\\r\\n\\t\\trequire(_msgSender() == _owner, \\\"Owned: caller is not the owner\\\");\\r\\n\\t\\t_;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t* @dev Transfers owner permissions to a new account (`newOwner`).\\r\\n\\t* Internal function without access restriction.\\r\\n\\t*/\\r\\n\\tfunction _setOwner(address newOwner) internal\\r\\n\\t{\\r\\n\\t\\taddress oldOwner = _owner;\\r\\n\\t\\t_owner = newOwner;\\r\\n\\t\\temit OwnershipTransfered(oldOwner, newOwner);\\r\\n\\t}\\r\\n}\\r\\n\\r\\ncontract UniswapProxy is Owned\\r\\n{\\r\\n\\tuint256 MAX_INT = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\\r\\n\\taddress public WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\r\\n\\t// address public WETH = 0xc778417E063141139Fce010982780140Aa0cD5Ab; // ROPSTEN\\r\\n\\r\\n\\taddress u2address = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\\r\\n\\tIUniswapV2Router u2router = IUniswapV2Router(u2address);\\r\\n\\r\\n\\taddress u3address = 0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45;\\r\\n\\tISwapRouter02 u3router = ISwapRouter02(u3address);\\r\\n\\r\\n\\treceive() external payable {}\\r\\n\\r\\n\\t// transfer all ETH of this contract to owner\\r\\n\\tfunction withdrawETH() external onlyOwner\\r\\n\\t{\\r\\n\\t\\trequire(address(this).balance > 0, \\\"Can't transfer 0 ETH\\\");\\r\\n\\t\\tpayable(owner()).transfer(address(this).balance);\\r\\n\\t}\\r\\n\\r\\n\\t// transfer all token_address tokens of this contract to owner\\r\\n\\tfunction withdrawToken(address token_address) external onlyOwner\\r\\n\\t{\\r\\n\\t\\tIERC20 token = IERC20(token_address);\\r\\n\\t\\trequire(token.balanceOf(address(this)) > 0, \\\"Can't transfer 0 tokens\\\");\\r\\n\\r\\n\\t\\ttoken.transfer(owner(), token.balanceOf(address(this)));\\r\\n\\t}\\r\\n\\r\\n\\t// transfer specific tokens of this contract to a specific address\\r\\n\\tfunction withdraw(address token_address, address recipient, uint256 amount) external onlyOwner\\r\\n\\t{\\r\\n\\t\\tif(token_address == WETH)\\r\\n\\t\\t{\\r\\n\\t\\t\\tpayable(recipient).transfer(amount);\\r\\n\\t\\t\\treturn;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tIERC20 token = IERC20(token_address);\\r\\n\\t\\ttoken.transfer(recipient, amount);\\r\\n\\t}\\r\\n\\r\\n\\tfunction _checkAndApprove(address token_address, address approval_address, uint256 amount) internal\\r\\n\\t{\\r\\n\\t\\tIERC20 token = IERC20(token_address); // the token we are trading\\r\\n\\r\\n\\t\\trequire(token.balanceOf(address(this)) >= amount, \\\"Not enough balance\\\"); // check if there's enough balance of the token\\r\\n\\r\\n\\t\\tif(token.allowance(address(this), approval_address) < amount) // check if uniswap (approval_address) does not have enough allowance\\r\\n\\t\\t\\ttoken.approve(approval_address, MAX_INT); // approve uniswap (approval_address) to spend this contract's tokens\\r\\n\\t}\\r\\n\\r\\n\\t// UNISWAP v2\\r\\n\\r\\n\\tfunction v2ETHforExactTokens(address token_address, uint amount_in_max, uint amount_out, address to, uint deadline) external onlyOwner\\r\\n\\t{\\r\\n\\t\\trequire(address(this).balance >= amount_in_max, \\\"Not enough ETH balance for swap\\\");\\r\\n\\r\\n\\t\\taddress[] memory path = new address[](2);\\r\\n\\t\\tpath[0] = WETH;\\r\\n\\t\\tpath[1] = token_address;\\r\\n\\r\\n\\t\\tu2router.swapETHForExactTokens{value:amount_in_max}(amount_out, path, to, deadline);\\r\\n\\t}\\r\\n\\r\\n\\tfunction v2ExactTokensForETH(address token_address, uint amount_in, uint amount_out_min, address to, uint deadline) external onlyOwner\\r\\n\\t{\\r\\n\\t\\t_checkAndApprove(token_address, u2address, amount_in);\\r\\n\\r\\n\\t\\taddress[] memory path = new address[](2);\\r\\n\\t\\tpath[0] = token_address;\\r\\n\\t\\tpath[1] = WETH;\\r\\n\\r\\n\\t\\tu2router.swapExactTokensForETH(amount_in, amount_out_min, path, to, deadline);\\r\\n\\t}\\r\\n\\r\\n\\tfunction v2TokensForExactTokens(address token_in, address token_out, uint amount_in_max, uint amount_out, address to, uint deadline) external onlyOwner\\r\\n\\t{\\r\\n\\t\\t_checkAndApprove(token_in, u2address, amount_in_max);\\r\\n\\r\\n\\t\\taddress[] memory path = new address[](2);\\r\\n\\t\\tpath[0] = token_in;\\r\\n\\t\\tpath[1] = token_out;\\r\\n\\r\\n\\t\\tu2router.swapTokensForExactTokens(amount_out, amount_in_max, path, to, deadline);\\r\\n\\t}\\r\\n\\r\\n\\tfunction v2ExactTokensForTokens(address token_in, address token_out, uint amount_in, uint amount_out_min, address to, uint deadline) external onlyOwner\\r\\n\\t{\\r\\n\\t\\t_checkAndApprove(token_in, u2address, amount_in);\\r\\n\\r\\n\\t\\taddress[] memory path = new address[](2);\\r\\n\\t\\tpath[0] = token_in;\\r\\n\\t\\tpath[1] = token_out;\\r\\n\\r\\n\\t\\tu2router.swapExactTokensForTokens(amount_in, amount_out_min, path, to, deadline);\\r\\n\\t}\\r\\n\\r\\n\\t// UNISWAP v3\\r\\n\\r\\n\\tfunction v3ExactOutput(address token_in, address token_out, uint amount_in_max, uint amount_out, uint24 fee, address to, uint deadline) external onlyOwner\\r\\n\\t{\\r\\n\\t\\tuint value = token_in == WETH ? amount_in_max : 0;\\r\\n\\t\\trequire(address(this).balance >= value, \\\"not enough balance\\\");\\r\\n\\r\\n\\t\\tif(token_in != WETH) // approve uniswap to use input token, if it's not ETH\\r\\n\\t\\t\\t_checkAndApprove(token_in, u3address, amount_in_max);\\r\\n\\r\\n\\t\\tIV3SwapRouter.ExactOutputSingleParams memory params = \\r\\n\\t\\t\\tIV3SwapRouter.ExactOutputSingleParams({\\r\\n\\t\\t\\t\\ttokenIn: token_in,\\r\\n\\t\\t\\t\\ttokenOut: token_out,\\r\\n\\t\\t\\t\\tamountInMaximum: amount_in_max,\\r\\n\\t\\t\\t\\tamountOut: amount_out,\\r\\n\\t\\t\\t\\tfee: fee,\\r\\n\\t\\t\\t\\trecipient: token_out == WETH ? u3address : to,\\r\\n\\t\\t\\t\\tsqrtPriceLimitX96: 0\\r\\n\\t\\t\\t});\\r\\n\\t\\t\\r\\n\\t\\tbytes[] memory data = new bytes[]((token_in == WETH || token_out == WETH) ? 2 : 1); // no need for refund/unwrapping when not trading ETH\\r\\n\\t\\tdata[0] = abi.encodeWithSelector(IV3SwapRouter.exactOutputSingle.selector, params);\\r\\n\\r\\n\\t\\tif(params.tokenIn == WETH) // if input token is ETH, add refundETH to be called after swap\\r\\n\\t\\t{\\r\\n\\t\\t\\tdata[1] = abi.encodeWithSelector(IPeripheryPayments.refundETH.selector);\\r\\n\\t\\t}\\r\\n\\t\\telse if(params.tokenOut == WETH) // if output token is ETH, send WETH from swap to router and then unwrapWETH to a 'to' address;\\r\\n\\t\\t{ \\r\\n\\t\\t\\tdata[1] = abi.encodeWithSelector(IPeripheryPayments.unwrapWETH9.selector, 0, to);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tu3router.multicall{value:value}(deadline, data);\\r\\n\\t}\\r\\n\\r\\n\\tfunction v3ExactInput(address token_in, address token_out, uint amount_in, uint amount_out_min, uint24 fee, address to, uint deadline) external onlyOwner\\r\\n\\t{\\r\\n\\t\\tuint value = token_in == WETH ? amount_in : 0;\\r\\n\\t\\trequire(address(this).balance >= value, \\\"not enough balance\\\");\\r\\n\\r\\n\\t\\tif(token_in != WETH) // approve uniswap to use input token, if it's not ETH\\r\\n\\t\\t\\t_checkAndApprove(token_in, u3address, amount_in);\\r\\n\\r\\n\\t\\tIV3SwapRouter.ExactInputSingleParams memory params = \\r\\n\\t\\t\\tIV3SwapRouter.ExactInputSingleParams({\\r\\n\\t\\t\\t\\ttokenIn: token_in,\\r\\n\\t\\t\\t\\ttokenOut: token_out,\\r\\n\\t\\t\\t\\tfee: fee,\\r\\n\\t\\t\\t\\trecipient: token_out == WETH ? u3address : to,\\r\\n\\t\\t\\t\\tamountIn: amount_in,\\r\\n\\t\\t\\t\\tamountOutMinimum: amount_out_min,\\r\\n\\t\\t\\t\\tsqrtPriceLimitX96: 0\\r\\n\\t\\t\\t});\\r\\n\\r\\n\\t\\tbytes[] memory data = new bytes[](token_out == WETH ? 2 : 1); // no need for unwrapping, if WETH is not output token\\r\\n\\t\\tdata[0] = abi.encodeWithSelector(IV3SwapRouter.exactInputSingle.selector, params);\\r\\n\\r\\n\\t\\tif(token_out == WETH) // if output token is ETH, unwrapWETH to a 'to' address;\\r\\n\\t\\t{\\r\\n\\t\\t\\tdata[1] = abi.encodeWithSelector(IPeripheryPayments.unwrapWETH9.selector, 0, to);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tu3router.multicall{value:value}(deadline, data);\\r\\n\\t}\\r\\n}\"\r\n    }\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransfered\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"WETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token_address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount_in_max\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount_out\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"v2ETHforExactTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token_address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount_in\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount_out_min\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"v2ExactTokensForETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token_in\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token_out\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount_in\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount_out_min\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"v2ExactTokensForTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token_in\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token_out\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount_in_max\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount_out\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"v2TokensForExactTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token_in\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token_out\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount_in\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount_out_min\",\"type\":\"uint256\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"v3ExactInput\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token_in\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token_out\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount_in_max\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount_out\",\"type\":\"uint256\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"v3ExactOutput\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token_address\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token_address\",\"type\":\"address\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "UniswapProxy", "CompilerVersion": "v0.8.0+commit.c7dfd78e", "OptimizationUsed": "1", "Runs": "999999999", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://616dc5181426df7e4dd6152a442da9f810b27a823f1d77fcf8be6d5fa964a5aa"}