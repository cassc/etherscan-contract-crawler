{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/T/TMath.sol\": {\r\n      \"content\": \"// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.6.12;\\n\\nimport \\\"../base/Math.sol\\\";\\nimport \\\"../base/Num.sol\\\";\\n\\n// Contract to wrap internal functions for testing\\n\\ncontract TMath is Math {\\n    function calc_btoi(uint a) external pure returns (uint) {\\n        return btoi(a);\\n    }\\n\\n    function calc_bfloor(uint a) external pure returns (uint) {\\n        return bfloor(a);\\n    }\\n\\n    function calc_badd(uint a, uint b) external pure returns (uint) {\\n        return badd(a, b);\\n    }\\n\\n    function calc_bsub(uint a, uint b) external pure returns (uint) {\\n        return bsub(a, b);\\n    }\\n\\n    function calc_bsubSign(uint a, uint b) external pure returns (uint, bool) {\\n        return bsubSign(a, b);\\n    }\\n\\n    function calc_bmul(uint a, uint b) external pure returns (uint) {\\n        return bmul(a, b);\\n    }\\n\\n    function calc_bdiv(uint a, uint b) external pure returns (uint) {\\n        return bdiv(a, b);\\n    }\\n\\n    function calc_bpowi(uint a, uint n) external pure returns (uint) {\\n        return bpowi(a, n);\\n    }\\n\\n    function calc_bpow(uint base, uint exp) external pure returns (uint) {\\n        return bpow(base, exp);\\n    }\\n\\n    function calc_bpowApprox(\\n        uint base,\\n        uint exp,\\n        uint precision\\n    ) external pure returns (uint) {\\n        return bpowApprox(base, exp, precision);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/base/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"./Num.sol\\\";\\n\\ncontract Math is BBronze, Const, Num {\\n    /**********************************************************************************************\\n    // calcSpotPrice                                                                             //\\n    // sP = spotPrice                                                                            //\\n    // bI = tokenBalanceIn                ( bI / wI )         1                                  //\\n    // bO = tokenBalanceOut         sP =  -----------  *  ----------                             //\\n    // wI = tokenWeightIn                 ( bO / wO )     ( 1 - sF )                             //\\n    // wO = tokenWeightOut                                                                       //\\n    // sF = swapFee                                                                              //\\n    **********************************************************************************************/\\n    function calcSpotPrice(\\n        uint tokenBalanceIn,\\n        uint tokenWeightIn,\\n        uint tokenBalanceOut,\\n        uint tokenWeightOut,\\n        uint swapFee\\n    ) external pure returns (uint spotPrice) {\\n        uint numer = bdiv(tokenBalanceIn, tokenWeightIn);\\n        uint denom = bdiv(tokenBalanceOut, tokenWeightOut);\\n        uint ratio = bdiv(numer, denom);\\n        uint scale = bdiv(BONE, bsub(BONE, swapFee));\\n        return (spotPrice = bmul(ratio, scale));\\n    }\\n\\n    /**********************************************************************************************\\n    // calcOutGivenIn                                                                            //\\n    // aO = tokenAmountOut                                                                       //\\n    // bO = tokenBalanceOut                                                                      //\\n    // bI = tokenBalanceIn              /      /            bI             \\\\    (wI / wO) \\\\      //\\n    // aI = tokenAmountIn    aO = bO * |  1 - | --------------------------  | ^            |     //\\n    // wI = tokenWeightIn               \\\\      \\\\ ( bI + ( aI * ( 1 - sF )) /              /      //\\n    // wO = tokenWeightOut                                                                       //\\n    // sF = swapFee                                                                              //\\n    **********************************************************************************************/\\n    function calcOutGivenIn(\\n        uint tokenBalanceIn,\\n        uint tokenWeightIn,\\n        uint tokenBalanceOut,\\n        uint tokenWeightOut,\\n        uint tokenAmountIn,\\n        uint swapFee\\n    ) external pure returns (uint tokenAmountOut) {\\n        uint weightRatio = bdiv(tokenWeightIn, tokenWeightOut);\\n        uint adjustedIn = bsub(BONE, swapFee);\\n        adjustedIn = bmul(tokenAmountIn, adjustedIn);\\n        uint y = bdiv(tokenBalanceIn, badd(tokenBalanceIn, adjustedIn));\\n        uint foo = bpow(y, weightRatio);\\n        uint bar = bsub(BONE, foo);\\n        tokenAmountOut = bmul(tokenBalanceOut, bar);\\n        return tokenAmountOut;\\n    }\\n\\n    /**********************************************************************************************\\n    // calcInGivenOut                                                                            //\\n    // aI = tokenAmountIn                                                                        //\\n    // bO = tokenBalanceOut               /  /     bO      \\\\    (wO / wI)      \\\\                 //\\n    // bI = tokenBalanceIn          bI * |  | ------------  | ^            - 1  |                //\\n    // aO = tokenAmountOut    aI =        \\\\  \\\\ ( bO - aO ) /                   /                 //\\n    // wI = tokenWeightIn           --------------------------------------------                 //\\n    // wO = tokenWeightOut                          ( 1 - sF )                                   //\\n    // sF = swapFee                                                                              //\\n    **********************************************************************************************/\\n    function calcInGivenOut(\\n        uint tokenBalanceIn,\\n        uint tokenWeightIn,\\n        uint tokenBalanceOut,\\n        uint tokenWeightOut,\\n        uint tokenAmountOut,\\n        uint swapFee\\n    ) external pure returns (uint tokenAmountIn) {\\n        uint weightRatio = bdiv(tokenWeightOut, tokenWeightIn);\\n        uint diff = bsub(tokenBalanceOut, tokenAmountOut);\\n        uint y = bdiv(tokenBalanceOut, diff);\\n        uint foo = bpow(y, weightRatio);\\n        foo = bsub(foo, BONE);\\n        tokenAmountIn = bsub(BONE, swapFee);\\n        tokenAmountIn = bdiv(bmul(tokenBalanceIn, foo), tokenAmountIn);\\n        return tokenAmountIn;\\n    }\\n\\n    /**********************************************************************************************\\n    // calcPoolOutGivenSingleIn                                                                  //\\n    // pAo = poolAmountOut         /                                              \\\\              //\\n    // tAi = tokenAmountIn        ///      /     //    wI \\\\      \\\\\\\\       \\\\     wI \\\\             //\\n    // wI = tokenWeightIn        //| tAi *| 1 - || 1 - --  | * sF || + tBi \\\\    --  \\\\            //\\n    // tW = totalWeight     pAo=||  \\\\      \\\\     \\\\\\\\    tW /      //         | ^ tW   | * pS - pS //\\n    // tBi = tokenBalanceIn      \\\\\\\\  ------------------------------------- /        /            //\\n    // pS = poolSupply            \\\\\\\\                    tBi               /        /             //\\n    // sF = swapFee                \\\\                                              /              //\\n    **********************************************************************************************/\\n    function calcPoolOutGivenSingleIn(\\n        uint tokenBalanceIn,\\n        uint tokenWeightIn,\\n        uint poolSupply,\\n        uint totalWeight,\\n        uint tokenAmountIn,\\n        uint swapFee\\n    ) external pure returns (uint poolAmountOut) {\\n        // Charge the trading fee for the proportion of tokenAi\\n        //  which is implicitly traded to the other pool tokens.\\n        // That proportion is (1- weightTokenIn)\\n        // tokenAiAfterFee = tAi * (1 - (1-weightTi) * poolFee);\\n        uint normalizedWeight = bdiv(tokenWeightIn, totalWeight);\\n        uint zaz = bmul(bsub(BONE, normalizedWeight), swapFee);\\n        uint tokenAmountInAfterFee = bmul(tokenAmountIn, bsub(BONE, zaz));\\n\\n        uint newTokenBalanceIn = badd(tokenBalanceIn, tokenAmountInAfterFee);\\n        uint tokenInRatio = bdiv(newTokenBalanceIn, tokenBalanceIn);\\n\\n        // uint newPoolSupply = (ratioTi ^ weightTi) * poolSupply;\\n        uint poolRatio = bpow(tokenInRatio, normalizedWeight);\\n        uint newPoolSupply = bmul(poolRatio, poolSupply);\\n        poolAmountOut = bsub(newPoolSupply, poolSupply);\\n        return poolAmountOut;\\n    }\\n\\n    /**********************************************************************************************\\n    // calcSingleInGivenPoolOut                                                                  //\\n    // tAi = tokenAmountIn              //(pS + pAo)\\\\     /    1    \\\\\\\\                           //\\n    // pS = poolSupply                 || ---------  | ^ | --------- || * bI - bI                //\\n    // pAo = poolAmountOut              \\\\\\\\    pS    /     \\\\(wI / tW)//                           //\\n    // bI = balanceIn          tAi =  --------------------------------------------               //\\n    // wI = weightIn                              /      wI  \\\\                                   //\\n    // tW = totalWeight                          |  1 - ----  |  * sF                            //\\n    // sF = swapFee                               \\\\      tW  /                                   //\\n    **********************************************************************************************/\\n    function calcSingleInGivenPoolOut(\\n        uint tokenBalanceIn,\\n        uint tokenWeightIn,\\n        uint poolSupply,\\n        uint totalWeight,\\n        uint poolAmountOut,\\n        uint swapFee\\n    ) external pure returns (uint tokenAmountIn) {\\n        uint normalizedWeight = bdiv(tokenWeightIn, totalWeight);\\n        uint newPoolSupply = badd(poolSupply, poolAmountOut);\\n        uint poolRatio = bdiv(newPoolSupply, poolSupply);\\n\\n        //uint newBalTi = poolRatio^(1/weightTi) * balTi;\\n        uint boo = bdiv(BONE, normalizedWeight);\\n        uint tokenInRatio = bpow(poolRatio, boo);\\n        uint newTokenBalanceIn = bmul(tokenInRatio, tokenBalanceIn);\\n        uint tokenAmountInAfterFee = bsub(newTokenBalanceIn, tokenBalanceIn);\\n        // Do reverse order of fees charged in joinswap_ExternAmountIn, this way\\n        //     ``` pAo == joinswap_ExternAmountIn(Ti, joinswap_PoolAmountOut(pAo, Ti)) ```\\n        //uint tAi = tAiAfterFee / (1 - (1-weightTi) * swapFee) ;\\n        uint zar = bmul(bsub(BONE, normalizedWeight), swapFee);\\n        tokenAmountIn = bdiv(tokenAmountInAfterFee, bsub(BONE, zar));\\n        return tokenAmountIn;\\n    }\\n\\n    /**********************************************************************************************\\n    // calcSingleOutGivenPoolIn                                                                  //\\n    // tAo = tokenAmountOut            /      /                                             \\\\\\\\   //\\n    // bO = tokenBalanceOut           /      // pS - (pAi * (1 - eF)) \\\\     /    1    \\\\      \\\\\\\\  //\\n    // pAi = poolAmountIn            | bO - || ----------------------- | ^ | --------- | * b0 || //\\n    // ps = poolSupply                \\\\      \\\\\\\\          pS           /     \\\\(wO / tW)/      //  //\\n    // wI = tokenWeightIn      tAo =   \\\\      \\\\                                             //   //\\n    // tW = totalWeight                    /     /      wO \\\\       \\\\                             //\\n    // sF = swapFee                    *  | 1 - |  1 - ---- | * sF  |                            //\\n    // eF = exitFee                        \\\\     \\\\      tW /       /                             //\\n    **********************************************************************************************/\\n    function calcSingleOutGivenPoolIn(\\n        uint tokenBalanceOut,\\n        uint tokenWeightOut,\\n        uint poolSupply,\\n        uint totalWeight,\\n        uint poolAmountIn,\\n        uint swapFee\\n    ) external pure returns (uint tokenAmountOut) {\\n        uint normalizedWeight = bdiv(tokenWeightOut, totalWeight);\\n        // charge exit fee on the pool token side\\n        // pAiAfterExitFee = pAi*(1-exitFee)\\n        uint poolAmountInAfterExitFee = bmul(poolAmountIn, bsub(BONE, EXIT_FEE));\\n        uint newPoolSupply = bsub(poolSupply, poolAmountInAfterExitFee);\\n        uint poolRatio = bdiv(newPoolSupply, poolSupply);\\n\\n        // newBalTo = poolRatio^(1/weightTo) * balTo;\\n        uint tokenOutRatio = bpow(poolRatio, bdiv(BONE, normalizedWeight));\\n        uint newTokenBalanceOut = bmul(tokenOutRatio, tokenBalanceOut);\\n\\n        uint tokenAmountOutBeforeSwapFee = bsub(tokenBalanceOut, newTokenBalanceOut);\\n\\n        // charge swap fee on the output token side\\n        //uint tAo = tAoBeforeSwapFee * (1 - (1-weightTo) * swapFee)\\n        uint zaz = bmul(bsub(BONE, normalizedWeight), swapFee);\\n        tokenAmountOut = bmul(tokenAmountOutBeforeSwapFee, bsub(BONE, zaz));\\n        return tokenAmountOut;\\n    }\\n\\n    /**********************************************************************************************\\n    // calcPoolInGivenSingleOut                                                                  //\\n    // pAi = poolAmountIn               // /               tAo             \\\\\\\\     / wO \\\\     \\\\   //\\n    // bO = tokenBalanceOut            // | bO - -------------------------- |\\\\   | ---- |     \\\\  //\\n    // tAo = tokenAmountOut      pS - ||   \\\\     1 - ((1 - (tO / tW)) * sF)/  | ^ \\\\ tW /  * pS | //\\n    // ps = poolSupply                 \\\\\\\\ -----------------------------------/                /  //\\n    // wO = tokenWeightOut  pAi =       \\\\\\\\               bO                 /                /   //\\n    // tW = totalWeight           -------------------------------------------------------------  //\\n    // sF = swapFee                                        ( 1 - eF )                            //\\n    // eF = exitFee                                                                              //\\n    **********************************************************************************************/\\n    function calcPoolInGivenSingleOut(\\n        uint tokenBalanceOut,\\n        uint tokenWeightOut,\\n        uint poolSupply,\\n        uint totalWeight,\\n        uint tokenAmountOut,\\n        uint swapFee\\n    ) external pure returns (uint poolAmountIn) {\\n        // charge swap fee on the output token side\\n        uint normalizedWeight = bdiv(tokenWeightOut, totalWeight);\\n        //uint tAoBeforeSwapFee = tAo / (1 - (1-weightTo) * swapFee) ;\\n        uint zoo = bsub(BONE, normalizedWeight);\\n        uint zar = bmul(zoo, swapFee);\\n        uint tokenAmountOutBeforeSwapFee = bdiv(tokenAmountOut, bsub(BONE, zar));\\n\\n        uint newTokenBalanceOut = bsub(tokenBalanceOut, tokenAmountOutBeforeSwapFee);\\n        uint tokenOutRatio = bdiv(newTokenBalanceOut, tokenBalanceOut);\\n\\n        //uint newPoolSupply = (ratioTo ^ weightTo) * poolSupply;\\n        uint poolRatio = bpow(tokenOutRatio, normalizedWeight);\\n        uint newPoolSupply = bmul(poolRatio, poolSupply);\\n        uint poolAmountInAfterExitFee = bsub(poolSupply, newPoolSupply);\\n\\n        // charge exit fee on the pool token side\\n        // pAi = pAiAfterExitFee/(1-exitFee)\\n        poolAmountIn = bdiv(poolAmountInAfterExitFee, bsub(BONE, EXIT_FEE));\\n        return poolAmountIn;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/base/Num.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.6.12;\\n\\nimport \\\"./Const.sol\\\";\\n\\n// Core contract; can't be changed. So disable solhint (reminder for v2)\\n\\n/* solhint-disable private-vars-leading-underscore */\\n\\ncontract Num is Const {\\n    function btoi(uint a) internal pure returns (uint) {\\n        return a / BONE;\\n    }\\n\\n    function bfloor(uint a) internal pure returns (uint) {\\n        return btoi(a) * BONE;\\n    }\\n\\n    function badd(uint a, uint b) internal pure returns (uint) {\\n        uint c = a + b;\\n        require(c >= a, \\\"ERR_ADD_OVERFLOW\\\");\\n        return c;\\n    }\\n\\n    function bsub(uint a, uint b) internal pure returns (uint) {\\n        (uint c, bool flag) = bsubSign(a, b);\\n        require(!flag, \\\"ERR_SUB_UNDERFLOW\\\");\\n        return c;\\n    }\\n\\n    function bsubSign(uint a, uint b) internal pure returns (uint, bool) {\\n        if (a >= b) {\\n            return (a - b, false);\\n        } else {\\n            return (b - a, true);\\n        }\\n    }\\n\\n    function bmul(uint a, uint b) internal pure returns (uint) {\\n        uint c0 = a * b;\\n        require(a == 0 || c0 / a == b, \\\"ERR_MUL_OVERFLOW\\\");\\n        uint c1 = c0 + (BONE / 2);\\n        require(c1 >= c0, \\\"ERR_MUL_OVERFLOW\\\");\\n        uint c2 = c1 / BONE;\\n        return c2;\\n    }\\n\\n    function bdiv(uint a, uint b) internal pure returns (uint) {\\n        require(b != 0, \\\"ERR_DIV_ZERO\\\");\\n        uint c0 = a * BONE;\\n        require(a == 0 || c0 / a == BONE, \\\"ERR_DIV_INTERNAL\\\"); // bmul overflow\\n        uint c1 = c0 + (b / 2);\\n        require(c1 >= c0, \\\"ERR_DIV_INTERNAL\\\"); //  badd require\\n        uint c2 = c1 / b;\\n        return c2;\\n    }\\n\\n    // DSMath.wpow\\n    function bpowi(uint a, uint n) internal pure returns (uint) {\\n        uint z = n % 2 != 0 ? a : BONE;\\n\\n        for (n /= 2; n != 0; n /= 2) {\\n            a = bmul(a, a);\\n\\n            if (n % 2 != 0) {\\n                z = bmul(z, a);\\n            }\\n        }\\n        return z;\\n    }\\n\\n    // Compute b^(e.w) by splitting it into (b^e)*(b^0.w).\\n    // Use `bpowi` for `b^e` and `bpowK` for k iterations\\n    // of approximation of b^0.w\\n    function bpow(uint base, uint exp) internal pure returns (uint) {\\n        require(base >= MIN_BPOW_BASE, \\\"ERR_BPOW_BASE_TOO_LOW\\\");\\n        require(base <= MAX_BPOW_BASE, \\\"ERR_BPOW_BASE_TOO_HIGH\\\");\\n\\n        uint whole = bfloor(exp);\\n        uint remain = bsub(exp, whole);\\n\\n        uint wholePow = bpowi(base, btoi(whole));\\n\\n        if (remain == 0) {\\n            return wholePow;\\n        }\\n\\n        uint partialResult = bpowApprox(base, remain, BPOW_PRECISION);\\n        return bmul(wholePow, partialResult);\\n    }\\n\\n    function bpowApprox(\\n        uint base,\\n        uint exp,\\n        uint precision\\n    ) internal pure returns (uint) {\\n        // term 0:\\n        uint a = exp;\\n        (uint x, bool xneg) = bsubSign(base, BONE);\\n        uint term = BONE;\\n        uint sum = term;\\n        bool negative = false;\\n\\n        // term(k) = numer / denom\\n        //         = (product(a - i - 1, i=1-->k) * x^k) / (k!)\\n        // each iteration, multiply previous term by (a-(k-1)) * x / k\\n        // continue until term is less than precision\\n        for (uint i = 1; term >= precision; i++) {\\n            uint bigK = i * BONE;\\n            (uint c, bool cneg) = bsubSign(a, bsub(bigK, BONE));\\n            term = bmul(term, bmul(c, x));\\n            term = bdiv(term, bigK);\\n            if (term == 0) break;\\n\\n            if (xneg) negative = !negative;\\n            if (cneg) negative = !negative;\\n            if (negative) {\\n                sum = bsub(sum, term);\\n            } else {\\n                sum = badd(sum, term);\\n            }\\n        }\\n\\n        return sum;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/base/Const.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.6.12;\\n\\nimport \\\"./Color.sol\\\";\\n\\ncontract Const is BBronze {\\n    uint public constant BONE = 10**18;\\n\\n    uint public constant MIN_BOUND_TOKENS = 1;\\n    uint public constant MAX_BOUND_TOKENS = 16;\\n\\n    uint public constant MIN_FEE = BONE / 10**6;\\n    uint public constant MAX_FEE = BONE / 10;\\n    uint public constant EXIT_FEE = 0;\\n\\n    uint public constant MIN_WEIGHT = BONE;\\n    uint public constant MAX_WEIGHT = BONE * 50;\\n    uint public constant MAX_TOTAL_WEIGHT = BONE * 50;\\n    uint public constant MIN_BALANCE = 0;\\n\\n    uint public constant INIT_POOL_SUPPLY = BONE * 100;\\n\\n    uint public constant MIN_BPOW_BASE = 1 wei;\\n    uint public constant MAX_BPOW_BASE = (2 * BONE) - 1 wei;\\n    uint public constant BPOW_PRECISION = BONE / 10**10;\\n\\n    uint public constant MAX_IN_RATIO = BONE / 2;\\n    uint public constant MAX_OUT_RATIO = (BONE / 3) + 1 wei;\\n}\\n\"\r\n    },\r\n    \"contracts/base/Color.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.6.12;\\n\\n// abstract contract BColor {\\n//     function getColor()\\n//         external view virtual\\n//         returns (bytes32);\\n// }\\n\\ncontract BBronze {\\n    function getColor() external pure returns (bytes32) {\\n        return bytes32(\\\"BRONZE\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/deploy/DesynChainlinkOracle.sol\": {\r\n      \"content\": \"pragma solidity 0.6.12;\\n\\nimport \\\"../base/Num.sol\\\";\\nimport \\\"../interfaces/IERC20.sol\\\";\\nimport \\\"../interfaces/AggregatorV2V3Interface.sol\\\";\\nimport \\\"../interfaces/IUniswapOracle.sol\\\";\\n\\nlibrary SafeMath {\\n    function add(uint a, uint b) internal pure returns (uint) {\\n        uint c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    function sub(uint a, uint b) internal pure returns (uint) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    function sub(\\n        uint a,\\n        uint b,\\n        string memory errorMessage\\n    ) internal pure returns (uint) {\\n        require(b <= a, errorMessage);\\n        uint c = a - b;\\n\\n        return c;\\n    }\\n\\n    function mul(uint a, uint b) internal pure returns (uint) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    function div(uint a, uint b) internal pure returns (uint) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    function div(\\n        uint a,\\n        uint b,\\n        string memory errorMessage\\n    ) internal pure returns (uint) {\\n        require(b > 0, errorMessage);\\n        uint c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    function mod(uint a, uint b) internal pure returns (uint) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    function mod(\\n        uint a,\\n        uint b,\\n        string memory errorMessage\\n    ) internal pure returns (uint) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n\\n    function abs(uint a, uint b) internal pure returns(uint result, bool isFirstBigger) {\\n        if(a > b){\\n            result = a - b;\\n            isFirstBigger = true;\\n        } else {\\n            result = b - a;\\n            isFirstBigger = false;\\n        }\\n    }\\n}\\n\\ncontract DesynChainlinkOracle is Num {\\n    address public admin;\\n    using SafeMath for uint;\\n    IUniswapOracle public twapOracle;\\n    mapping(address => uint) internal prices;\\n    mapping(bytes32 => AggregatorV2V3Interface) internal feeds;\\n    event PricePosted(address asset, uint previousPriceMantissa, uint requestedPriceMantissa, uint newPriceMantissa);\\n    event NewAdmin(address oldAdmin, address newAdmin);\\n    event FeedSet(address feed, string symbol);\\n\\n    constructor(address twapOracle_) public {\\n        admin = msg.sender;\\n        twapOracle = IUniswapOracle(twapOracle_);\\n    }\\n\\n    function getPrice(address tokenAddress) public returns (uint price) {\\n        IERC20 token = IERC20(tokenAddress);\\n        AggregatorV2V3Interface feed = getFeed(token.symbol());\\n        if (prices[address(token)] != 0) {\\n            price = prices[address(token)];\\n        } else if (address(feed) != address(0)) {\\n            price = getChainlinkPrice(feed);\\n        } else {\\n            try twapOracle.update(address(token)) {} catch {}\\n            price = getUniswapPrice(tokenAddress);\\n        }\\n\\n        (uint decimalDelta, bool isUnderFlow18) = uint(18).abs(uint(token.decimals()));\\n\\n        if(isUnderFlow18){\\n            return price.mul(10**decimalDelta);\\n        }\\n\\n        if(!isUnderFlow18){\\n            return price.div(10**decimalDelta);\\n        }\\n    }\\n\\n    function getAllPrice(address[] calldata poolTokens, uint[] calldata actualAmountsOut) external returns (uint fundAll) {\\n        require(poolTokens.length == actualAmountsOut.length, \\\"Invalid Length\\\");\\n        \\n        for (uint i = 0; i < poolTokens.length; i++) {\\n            address t = poolTokens[i];\\n            uint tokenAmountOut = actualAmountsOut[i];\\n            fundAll = badd(fundAll, bmul(getPrice(t), tokenAmountOut));\\n        }\\n    }\\n\\n    function getChainlinkPrice(AggregatorV2V3Interface feed) internal view returns (uint) {\\n        // Chainlink USD-denominated feeds store answers at 8 decimals\\n        uint decimalDelta = bsub(uint(18), feed.decimals());\\n        // Ensure that we don't multiply the result by 0\\n        if (decimalDelta > 0) {\\n            return uint(feed.latestAnswer()).mul(10**decimalDelta);\\n        } else {\\n            return uint(feed.latestAnswer());\\n        }\\n    }\\n\\n    function getUniswapPrice(address tokenAddress) internal view returns (uint) {\\n        IERC20 token = IERC20(tokenAddress);\\n        uint price = twapOracle.consult(tokenAddress, uint(10) ** token.decimals());\\n        return price;\\n    }\\n\\n    function setDirectPrice(address asset, uint price) external onlyAdmin {\\n        emit PricePosted(asset, prices[asset], price, price);\\n        prices[asset] = price;\\n    }\\n\\n    function setFeed(string calldata symbol, address feed) external onlyAdmin {\\n        require(feed != address(0) && feed != address(this), \\\"invalid feed address\\\");\\n        emit FeedSet(feed, symbol);\\n        feeds[keccak256(abi.encodePacked(symbol))] = AggregatorV2V3Interface(feed);\\n    }\\n\\n    function getFeed(string memory symbol) public view returns (AggregatorV2V3Interface) {\\n        return feeds[keccak256(abi.encodePacked(symbol))];\\n    }\\n\\n    function assetPrices(address asset) external view returns (uint) {\\n        return prices[asset];\\n    }\\n\\n    function compareStrings(string memory a, string memory b) internal pure returns (bool) {\\n        return (keccak256(abi.encodePacked((a))) == keccak256(abi.encodePacked((b))));\\n    }\\n\\n    function setAdmin(address newAdmin) external onlyAdmin {\\n        require(newAdmin != address(0),\\\"ERR_ZERO_ADDRESS\\\");\\n        address oldAdmin = admin;\\n        admin = newAdmin;\\n\\n        emit NewAdmin(oldAdmin, newAdmin);\\n    }\\n\\n    modifier onlyAdmin() {\\n        require(msg.sender == admin, \\\"only admin may call\\\");\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.6.12;\\n\\n// Interface declarations\\n\\n/* solhint-disable func-order */\\n\\ninterface IERC20 {\\n    // Emitted when the allowance of a spender for an owner is set by a call to approve.\\n    // Value is the new allowance\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n\\n    // Emitted when value tokens are moved from one account (from) to another (to).\\n    // Note that value may be zero\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    // Returns the amount of tokens in existence\\n    function totalSupply() external view returns (uint);\\n\\n    // Returns the amount of tokens owned by account\\n    function balanceOf(address account) external view returns (uint);\\n\\n    // Returns the decimals of tokens\\n    function decimals() external view returns (uint8);\\n\\n    function symbol() external view returns (string memory);\\n\\n    // Returns the remaining number of tokens that spender will be allowed to spend on behalf of owner\\n    // through transferFrom. This is zero by default\\n    // This value changes when approve or transferFrom are called\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    // Sets amount as the allowance of spender over the caller\u2019s tokens\\n    // Returns a boolean value indicating whether the operation succeeded\\n    // Emits an Approval event.\\n    function approve(address spender, uint amount) external returns (bool);\\n\\n    // Moves amount tokens from the caller\u2019s account to recipient\\n    // Returns a boolean value indicating whether the operation succeeded\\n    // Emits a Transfer event.\\n    function transfer(address recipient, uint amount) external returns (bool);\\n\\n    // Moves amount tokens from sender to recipient using the allowance mechanism\\n    // Amount is then deducted from the caller\u2019s allowance\\n    // Returns a boolean value indicating whether the operation succeeded\\n    // Emits a Transfer event\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/AggregatorV2V3Interface.sol\": {\r\n      \"content\": \"pragma solidity 0.6.12;\\n\\n/**\\n * @title The V2 & V3 Aggregator Interface\\n * @notice Solidity V0.5 does not allow interfaces to inherit from other\\n * interfaces so this contract is a combination of v0.5 AggregatorInterface.sol\\n * and v0.5 AggregatorV3Interface.sol.\\n */\\ninterface AggregatorV2V3Interface {\\n    //\\n    // V2 Interface:\\n    //\\n    function latestAnswer() external view returns (int);\\n\\n    function latestTimestamp() external view returns (uint);\\n\\n    function latestRound() external view returns (uint);\\n\\n    function getAnswer(uint roundId) external view returns (int);\\n\\n    function getTimestamp(uint roundId) external view returns (uint);\\n\\n    event AnswerUpdated(int indexed current, uint indexed roundId, uint timestamp);\\n    event NewRound(uint indexed roundId, address indexed startedBy, uint startedAt);\\n\\n    //\\n    // V3 Interface:\\n    //\\n    function decimals() external view returns (uint8);\\n\\n    function description() external view returns (string memory);\\n\\n    function version() external view returns (uint);\\n\\n    // getRoundData and latestRoundData should both raise \\\"No data present\\\"\\n    // if they do not have data to report, instead of returning unset values\\n    // which could be misinterpreted as actual reported values.\\n    function getRoundData(uint80 _roundId)\\n        external\\n        view\\n        returns (\\n            uint80 roundId,\\n            int answer,\\n            uint startedAt,\\n            uint updatedAt,\\n            uint80 answeredInRound\\n        );\\n\\n    function latestRoundData()\\n        external\\n        view\\n        returns (\\n            uint80 roundId,\\n            int answer,\\n            uint startedAt,\\n            uint updatedAt,\\n            uint80 answeredInRound\\n        );\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IUniswapOracle.sol\": {\r\n      \"content\": \"pragma solidity 0.6.12;\\n\\ninterface IUniswapOracle {\\n    function update(address token) external;\\n\\n    function consult(address token, uint amountIn) external view returns (uint amountOut);\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/SmartPoolManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.6.12;\\n\\n// Needed to pass in structs\\npragma experimental ABIEncoderV2;\\n\\n// Imports\\n\\nimport \\\"../interfaces/IERC20.sol\\\";\\nimport \\\"../interfaces/IConfigurableRightsPool.sol\\\";\\nimport \\\"../interfaces/IBFactory.sol\\\"; // unused\\nimport \\\"./DesynSafeMath.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\n// import \\\"./SafeApprove.sol\\\";\\nimport \\\"../libraries/SafeERC20.sol\\\";\\n\\n/**\\n * @author Desyn Labs\\n * @title Factor out the weight updates\\n */\\nlibrary SmartPoolManager {\\n    // using SafeApprove for IERC20;\\n    using DesynSafeMath for uint;\\n    using SafeMath for uint;\\n    using SafeERC20 for IERC20;\\n\\n    //kol pool params\\n    struct levelParams {\\n        uint level;\\n        uint ratio;\\n    }\\n\\n    struct feeParams {\\n        levelParams firstLevel;\\n        levelParams secondLevel;\\n        levelParams thirdLevel;\\n        levelParams fourLevel;\\n    }\\n    \\n    struct KolPoolParams {\\n        feeParams managerFee;\\n        feeParams issueFee;\\n        feeParams redeemFee;\\n        feeParams perfermanceFee;\\n    }\\n\\n    // Type declarations\\n    enum Etypes {\\n        OPENED,\\n        CLOSED\\n    }\\n\\n    enum Period {\\n        DAY90,\\n        DAY180,\\n        DAY360,\\n        DAY1,\\n        DAY3,\\n        DAY7,\\n        DAY14,\\n        DAY30\\n    }\\n\\n    struct Fund {\\n        uint etfAmount;\\n        uint fundAmount;\\n        uint snapshotTime;\\n        address[] tokens;\\n        uint[] tokensAmount;\\n    }\\n\\n    // updateWeight and pokeWeights are unavoidably long\\n    /* solhint-disable function-max-lines */\\n    struct Status {\\n        uint collectPeriod;\\n        uint collectEndTime;\\n        uint closurePeriod;\\n        uint closureEndTime;\\n        uint upperCap;\\n        uint floorCap;\\n        uint managerFee;\\n        uint redeemFee;\\n        uint issueFee;\\n        uint perfermanceFee;\\n        uint startClaimFeeTime;\\n    }\\n\\n    struct PoolParams {\\n        // Desyn Pool Token (representing shares of the pool)\\n        string poolTokenSymbol;\\n        string poolTokenName;\\n        // Tokens inside the Pool\\n        address[] constituentTokens;\\n        uint[] tokenBalances;\\n        uint[] tokenWeights;\\n        uint managerFee;\\n        uint redeemFee;\\n        uint issueFee;\\n        uint perfermanceFee;\\n        Etypes etype;\\n    }\\n\\n    struct PoolTokenRange {\\n        uint bspFloor;\\n        uint bspCap;\\n    }\\n\\n    function initRequire(\\n        uint managerFee,\\n        uint issueFee,\\n        uint redeemFee,\\n        uint perfermanceFee,\\n        uint tokenBalancesLength,\\n        uint tokenWeightsLength,\\n        uint constituentTokensLength,\\n        bool initBool\\n    ) external pure {\\n        // We don't have a pool yet; check now or it will fail later (in order of likelihood to fail)\\n        // (and be unrecoverable if they don't have permission set to change it)\\n        // Most likely to fail, so check first\\n        require(!initBool, \\\"Init fail\\\");\\n        require(managerFee >= DesynConstants.MANAGER_MIN_FEE, \\\"ERR_INVALID_MANAGER_FEE\\\");\\n        require(managerFee <= DesynConstants.MANAGER_MAX_FEE, \\\"ERR_INVALID_MANAGER_FEE\\\");\\n        require(issueFee >= DesynConstants.ISSUE_MIN_FEE, \\\"ERR_INVALID_ISSUE_MIN_FEE\\\");\\n        require(issueFee <= DesynConstants.ISSUE_MAX_FEE, \\\"ERR_INVALID_ISSUE_MAX_FEE\\\");\\n        require(redeemFee >= DesynConstants.REDEEM_MIN_FEE, \\\"ERR_INVALID_REDEEM_MIN_FEE\\\");\\n        require(redeemFee <= DesynConstants.REDEEM_MAX_FEE, \\\"ERR_INVALID_REDEEM_MAX_FEE\\\");\\n        require(perfermanceFee >= DesynConstants.PERFERMANCE_MIN_FEE, \\\"ERR_INVALID_PERFERMANCE_MIN_FEE\\\");\\n        require(perfermanceFee <= DesynConstants.PERFERMANCE_MAX_FEE, \\\"ERR_INVALID_PERFERMANCE_MAX_FEE\\\");\\n\\n        // Arrays must be parallel\\n        require(tokenBalancesLength == constituentTokensLength, \\\"ERR_START_BALANCES_MISMATCH\\\");\\n        require(tokenWeightsLength == constituentTokensLength, \\\"ERR_START_WEIGHTS_MISMATCH\\\");\\n        // Cannot have too many or too few - technically redundant, since BPool.bind() would fail later\\n        // But if we don't check now, we could have a useless contract with no way to create a pool\\n\\n        require(constituentTokensLength >= DesynConstants.MIN_ASSET_LIMIT, \\\"ERR_TOO_FEW_TOKENS\\\");\\n        require(constituentTokensLength <= DesynConstants.MAX_ASSET_LIMIT, \\\"ERR_TOO_MANY_TOKENS\\\");\\n        // There are further possible checks (e.g., if they use the same token twice), but\\n        // we can let bind() catch things like that (i.e., not things that might reasonably work)\\n    }\\n\\n    /**\\n     * @notice Non ERC20-conforming tokens are problematic; don't allow them in pools\\n     * @dev Will revert if invalid\\n     * @param token - The prospective token to verify\\n     */\\n    function verifyTokenCompliance(address token) external {\\n        verifyTokenComplianceInternal(token);\\n    }\\n\\n    /**\\n     * @notice Non ERC20-conforming tokens are problematic; don't allow them in pools\\n     * @dev Will revert if invalid - overloaded to save space in the main contract\\n     * @param tokens - The prospective tokens to verify\\n     */\\n    function verifyTokenCompliance(address[] calldata tokens) external {\\n        for (uint i = 0; i < tokens.length; i++) {\\n            verifyTokenComplianceInternal(tokens[i]);\\n        }\\n    }\\n\\n    function createPoolInternalHandle(IBPool bPool, uint initialSupply) external view {\\n        require(initialSupply >= DesynConstants.MIN_POOL_SUPPLY, \\\"ERR_INIT_SUPPLY_MIN\\\");\\n        require(initialSupply <= DesynConstants.MAX_POOL_SUPPLY, \\\"ERR_INIT_SUPPLY_MAX\\\");\\n        require(bPool.EXIT_FEE() == 0, \\\"ERR_NONZERO_EXIT_FEE\\\");\\n        // EXIT_FEE must always be zero, or ConfigurableRightsPool._pushUnderlying will fail\\n        require(DesynConstants.EXIT_FEE == 0, \\\"ERR_NONZERO_EXIT_FEE\\\");\\n    }\\n\\n    function createPoolHandle(\\n        uint collectPeriod,\\n        uint upperCap,\\n        uint initialSupply\\n    ) external pure {\\n        require(collectPeriod <= DesynConstants.MAX_COLLECT_PERIOD, \\\"ERR_EXCEEDS_FUND_RAISING_PERIOD\\\");\\n        require(upperCap >= initialSupply, \\\"ERR_CAP_BIGGER_THAN_INITSUPPLY\\\");\\n    }\\n\\n    function exitPoolHandleA(\\n        IConfigurableRightsPool self,\\n        IBPool bPool,\\n        address poolToken,\\n        uint _tokenAmountOut,\\n        uint redeemFee\\n    )\\n        external\\n        returns (\\n            uint redeemAndPerformanceFeeReceived,\\n            uint finalAmountOut,\\n            uint redeemFeeReceived\\n        )\\n    {\\n        // redeem fee\\n        redeemFeeReceived = DesynSafeMath.bmul(_tokenAmountOut, redeemFee);\\n\\n        // performance fee\\n        uint performanceFeeReceived = 0;\\n        \\n        // redeem fee and performance fee\\n        redeemAndPerformanceFeeReceived = DesynSafeMath.badd(performanceFeeReceived, redeemFeeReceived);\\n\\n        // final amount the user got\\n        finalAmountOut = DesynSafeMath.bsub(_tokenAmountOut, redeemAndPerformanceFeeReceived);\\n\\n        _pushUnderlying(bPool, poolToken, msg.sender, finalAmountOut);\\n\\n        if (redeemFee != 0) {\\n            _pushUnderlying(bPool, poolToken, address(this), redeemAndPerformanceFeeReceived);\\n            IERC20(poolToken).safeApprove(self.vaultAddress(), 0);\\n            IERC20(poolToken).safeApprove(self.vaultAddress(), redeemAndPerformanceFeeReceived);\\n        }\\n    }\\n\\n    function exitPoolHandleB(\\n        IConfigurableRightsPool self,\\n        bool bools,\\n        bool isCompletedCollect,\\n        uint closureEndTime,\\n        uint collectEndTime,\\n        // uint _etfAmount,\\n        // uint _fundAmount,\\n        uint poolAmountIn\\n    ) external view returns (uint actualPoolAmountIn) {\\n        actualPoolAmountIn = poolAmountIn;\\n        if (bools) {\\n            bool isCloseEtfCollectEndWithFailure = isCompletedCollect == false && block.timestamp >= collectEndTime;\\n            bool isCloseEtfClosureEnd = block.timestamp >= closureEndTime;\\n            require(isCloseEtfCollectEndWithFailure || isCloseEtfClosureEnd, \\\"ERR_CLOSURE_TIME_NOT_ARRIVED!\\\");\\n\\n            actualPoolAmountIn = self.balanceOf(msg.sender);\\n        }\\n        // fundAmount = _fundAmount;\\n        // etfAmount = _etfAmount;\\n    }\\n\\n    function joinPoolHandle(\\n        bool canWhitelistLPs,\\n        bool isList,\\n        bool bools,\\n        uint collectEndTime\\n    ) external view {\\n        require(!canWhitelistLPs || isList, \\\"ERR_NOT_ON_WHITELIST\\\");\\n\\n        if (bools) {\\n            require(block.timestamp <= collectEndTime, \\\"ERR_COLLECT_PERIOD_FINISHED!\\\");\\n        }\\n    }\\n\\n    /**\\n     * @notice Join a pool\\n     * @param self - ConfigurableRightsPool instance calling the library\\n     * @param bPool - Core BPool the CRP is wrapping\\n     * @param poolAmountOut - number of pool tokens to receive\\n     * @param maxAmountsIn - Max amount of asset tokens to spend\\n     * @return actualAmountsIn - calculated values of the tokens to pull in\\n     */\\n    function joinPool(\\n        IConfigurableRightsPool self,\\n        IBPool bPool,\\n        uint poolAmountOut,\\n        uint[] calldata maxAmountsIn,\\n        uint issueFee\\n    ) external view returns (uint[] memory actualAmountsIn) {\\n        address[] memory tokens = bPool.getCurrentTokens();\\n\\n        require(maxAmountsIn.length == tokens.length, \\\"ERR_AMOUNTS_MISMATCH\\\");\\n\\n        uint poolTotal = self.totalSupply();\\n        // Subtract  1 to ensure any rounding errors favor the pool\\n        uint ratio = DesynSafeMath.bdiv(poolAmountOut, DesynSafeMath.bsub(poolTotal, 1));\\n\\n        require(ratio != 0, \\\"ERR_MATH_APPROX\\\");\\n\\n        // We know the length of the array; initialize it, and fill it below\\n        // Cannot do \\\"push\\\" in memory\\n        actualAmountsIn = new uint[](tokens.length);\\n\\n        // This loop contains external calls\\n        // External calls are to math libraries or the underlying pool, so low risk\\n        uint issueFeeRate = issueFee.bmul(1000);\\n        for (uint i = 0; i < tokens.length; i++) {\\n            address t = tokens[i];\\n            uint bal = bPool.getBalance(t);\\n            // Add 1 to ensure any rounding errors favor the pool\\n            uint base = bal.badd(1).bmul(poolAmountOut * uint(1000));\\n            uint tokenAmountIn = base.bdiv(poolTotal.bsub(1) * (uint(1000).bsub(issueFeeRate)));\\n\\n            require(tokenAmountIn != 0, \\\"ERR_MATH_APPROX\\\");\\n            require(tokenAmountIn <= maxAmountsIn[i], \\\"ERR_LIMIT_IN\\\");\\n\\n            actualAmountsIn[i] = tokenAmountIn;\\n        }\\n    }\\n\\n    /**\\n     * @notice Exit a pool - redeem pool tokens for underlying assets\\n     * @param self - ConfigurableRightsPool instance calling the library\\n     * @param bPool - Core BPool the CRP is wrapping\\n     * @param poolAmountIn - amount of pool tokens to redeem\\n     * @param minAmountsOut - minimum amount of asset tokens to receive\\n     * @return actualAmountsOut - calculated amounts of each token to pull\\n     */\\n    function exitPool(\\n        IConfigurableRightsPool self,\\n        IBPool bPool,\\n        uint poolAmountIn,\\n        uint[] calldata minAmountsOut\\n    ) external view returns (uint[] memory actualAmountsOut) {\\n        address[] memory tokens = bPool.getCurrentTokens();\\n\\n        require(minAmountsOut.length == tokens.length, \\\"ERR_AMOUNTS_MISMATCH\\\");\\n\\n        uint poolTotal = self.totalSupply();\\n\\n        uint ratio = DesynSafeMath.bdiv(poolAmountIn, DesynSafeMath.badd(poolTotal, 1));\\n\\n        require(ratio != 0, \\\"ERR_MATH_APPROX\\\");\\n\\n        actualAmountsOut = new uint[](tokens.length);\\n\\n        // This loop contains external calls\\n        // External calls are to math libraries or the underlying pool, so low risk\\n        for (uint i = 0; i < tokens.length; i++) {\\n            address t = tokens[i];\\n            uint bal = bPool.getBalance(t);\\n            // Subtract 1 to ensure any rounding errors favor the pool\\n            uint tokenAmountOut = DesynSafeMath.bmul(ratio, DesynSafeMath.bsub(bal, 1));\\n\\n            require(tokenAmountOut != 0, \\\"ERR_MATH_APPROX\\\");\\n            require(tokenAmountOut >= minAmountsOut[i], \\\"ERR_LIMIT_OUT\\\");\\n\\n            actualAmountsOut[i] = tokenAmountOut;\\n        }\\n    }\\n\\n    // Internal functions\\n    // Check for zero transfer, and make sure it returns true to returnValue\\n    function verifyTokenComplianceInternal(address token) internal {\\n        IERC20(token).safeTransfer(msg.sender, 0);\\n    }\\n\\n    function handleTransferInTokens(\\n        IConfigurableRightsPool self,\\n        IBPool bPool,\\n        address poolToken,\\n        uint actualAmountIn,\\n        uint _actualIssueFee\\n    ) external returns (uint issueFeeReceived) {\\n        issueFeeReceived = DesynSafeMath.bmul(actualAmountIn, _actualIssueFee);\\n        uint amount = DesynSafeMath.bsub(actualAmountIn, issueFeeReceived);\\n\\n        _pullUnderlying(bPool, poolToken, msg.sender, amount);\\n\\n        if (_actualIssueFee != 0) {\\n            IERC20(poolToken).safeTransferFrom(msg.sender, address(this), issueFeeReceived);\\n            IERC20(poolToken).safeApprove(self.vaultAddress(), 0);\\n            IERC20(poolToken).safeApprove(self.vaultAddress(), issueFeeReceived);\\n        }\\n    }\\n\\n    function handleClaim(\\n        IConfigurableRightsPool self,\\n        IBPool bPool,\\n        address[] calldata poolTokens,\\n        uint managerFee,\\n        uint timeElapsed,\\n        uint claimPeriod\\n    ) external returns (uint[] memory) {\\n        uint[] memory tokensAmount = new uint[](poolTokens.length);\\n        \\n        for (uint i = 0; i < poolTokens.length; i++) {\\n            address t = poolTokens[i];\\n            uint tokenBalance = bPool.getBalance(t);\\n            uint tokenAmountOut = tokenBalance.bmul(managerFee).mul(timeElapsed).div(claimPeriod).div(12);    \\n            _pushUnderlying(bPool, t, address(this), tokenAmountOut);\\n            IERC20(t).safeApprove(self.vaultAddress(), 0);\\n            IERC20(t).safeApprove(self.vaultAddress(), tokenAmountOut);\\n            tokensAmount[i] = tokenAmountOut;\\n        }\\n        \\n        return tokensAmount;\\n    }\\n\\n    function handleFeeClaim(\\n        IConfigurableRightsPool self,\\n        IBPool bPool,\\n        address[] calldata poolTokens,\\n        uint feeRatio,\\n        bool isPerfermance\\n    ) external {\\n        if (feeRatio != 0) {\\n            uint[] memory tokensAmount = new uint[](poolTokens.length);\\n\\n            for (uint i = 0; i < poolTokens.length; i++) {\\n                address t = poolTokens[i];\\n                uint currentAmount = bPool.getBalance(t);\\n                uint currentAmountFee = DesynSafeMath.bmul(currentAmount, feeRatio);\\n\\n                _pushUnderlying(bPool, t, address(this), currentAmountFee);\\n                tokensAmount[i] = currentAmountFee;\\n                IERC20(t).safeApprove(self.vaultAddress(), 0);\\n                IERC20(t).safeApprove(self.vaultAddress(), currentAmountFee);\\n            }\\n\\n            if(isPerfermance) {\\n                IVault(self.vaultAddress()).depositIssueRedeemPToken(poolTokens, tokensAmount, new uint[](poolTokens.length), isPerfermance);\\n            } else {\\n                IVault(self.vaultAddress()).depositIssueRedeemPToken(poolTokens, tokensAmount, tokensAmount, isPerfermance);\\n            }\\n            \\n        }\\n    }\\n\\n    function WhitelistHandle(\\n        bool bool1,\\n        bool bool2,\\n        address adr\\n    ) external pure {\\n        require(bool1, \\\"ERR_CANNOT_WHITELIST_LPS\\\");\\n        require(bool2, \\\"ERR_LP_NOT_WHITELISTED\\\");\\n        require(adr != address(0), \\\"ERR_INVALID_ADDRESS\\\");\\n    }\\n\\n    function _pullUnderlying(\\n        IBPool bPool,\\n        address erc20,\\n        address from,\\n        uint amount\\n    ) internal {\\n        uint tokenBalance = bPool.getBalance(erc20);\\n        uint tokenWeight = bPool.getDenormalizedWeight(erc20);\\n\\n        IERC20(erc20).safeTransferFrom(from, address(this), amount);\\n        bPool.rebind(erc20, DesynSafeMath.badd(tokenBalance, amount), tokenWeight);\\n    }\\n\\n    function _pushUnderlying(\\n        IBPool bPool,\\n        address erc20,\\n        address to,\\n        uint amount\\n    ) internal {\\n        uint tokenBalance = bPool.getBalance(erc20);\\n        uint tokenWeight = bPool.getDenormalizedWeight(erc20);\\n        bPool.rebind(erc20, DesynSafeMath.bsub(tokenBalance, amount), tokenWeight);\\n        IERC20(erc20).safeTransfer(to, amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IConfigurableRightsPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.6.12;\\n\\n// Interface declarations\\n\\n// Introduce to avoid circularity (otherwise, the CRP and SmartPoolManager include each other)\\n// Removing circularity allows flattener tools to work, which enables Etherscan verification\\ninterface IConfigurableRightsPool {\\n    function mintPoolShareFromLib(uint amount) external;\\n\\n    function pushPoolShareFromLib(address to, uint amount) external;\\n\\n    function pullPoolShareFromLib(address from, uint amount) external;\\n\\n    function burnPoolShareFromLib(uint amount) external;\\n\\n    function balanceOf(address account) external view returns (uint);\\n\\n    function totalSupply() external view returns (uint);\\n\\n    function adminList(address) external view returns (bool);\\n\\n    function getController() external view returns (address);\\n\\n    function vaultAddress() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IBFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.6.12;\\npragma experimental ABIEncoderV2;\\n\\ninterface IBPool {\\n    function rebind(\\n        address token,\\n        uint balance,\\n        uint denorm\\n    ) external;\\n\\n    function execute(\\n        address _target,\\n        uint _value,\\n        bytes calldata _data\\n    ) external returns (bytes memory _returnValue);\\n\\n    function bind(\\n        address token,\\n        uint balance,\\n        uint denorm\\n    ) external;\\n\\n    function unbind(address token) external;\\n\\n    function unbindPure(address token) external;\\n\\n    function isBound(address token) external view returns (bool);\\n\\n    function getBalance(address token) external view returns (uint);\\n\\n    function totalSupply() external view returns (uint);\\n\\n    function isPublicSwap() external view returns (bool);\\n\\n    function getDenormalizedWeight(address token) external view returns (uint);\\n\\n    function getTotalDenormalizedWeight() external view returns (uint);\\n\\n    function EXIT_FEE() external view returns (uint);\\n\\n    function getCurrentTokens() external view returns (address[] memory tokens);\\n\\n    function setController(address owner) external;\\n}\\n\\ninterface IBFactory {\\n    function newLiquidityPool() external returns (IBPool);\\n\\n    function setBLabs(address b) external;\\n\\n    function collect(IBPool pool) external;\\n\\n    function isBPool(address b) external view returns (bool);\\n\\n    function getBLabs() external view returns (address);\\n\\n    function getVault() external view returns (address);\\n\\n    function getUserVault() external view returns (address);\\n\\n    function getVaultAddress() external view returns (address);\\n\\n    function getOracleAddress() external view returns (address);\\n\\n    function isTokenWhitelistedForVerify(uint sort, address token) external view returns (bool);\\n\\n    function isTokenWhitelistedForVerify(address token) external view returns (bool);\\n\\n    function getModuleStatus(address etf, address module) external view returns (bool);\\n\\n    function isPaused() external view returns (bool);\\n}\\n\\ninterface IVault {\\n    function depositManagerToken(address[] calldata poolTokens, uint[] calldata tokensAmount) external;\\n\\n    function depositIssueRedeemPToken(\\n        address[] calldata poolTokens,\\n        uint[] calldata tokensAmount,\\n        uint[] calldata tokensAmountP,\\n        bool isPerfermance\\n    ) external;\\n\\n    function managerClaim(address pool) external;\\n\\n    function getManagerClaimBool(address pool) external view returns (bool);\\n}\\n\\ninterface IUserVault {\\n    function recordTokenInfo(\\n        address kol,\\n        address user,\\n        address[] calldata poolTokens,\\n        uint[] calldata tokensAmount\\n    ) external;\\n}\\n\\ninterface Oracles {\\n    function getPrice(address tokenAddress) external returns (uint price);\\n\\n    function getAllPrice(address[] calldata poolTokens, uint[] calldata tokensAmount) external returns (uint);\\n}\"\r\n    },\r\n    \"contracts/libraries/DesynSafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.6.12;\\n\\n// Imports\\n\\nimport \\\"./DesynConstants.sol\\\";\\n\\n/**\\n * @author Desyn Labs\\n * @title SafeMath - wrap Solidity operators to prevent underflow/overflow\\n * @dev badd and bsub are basically identical to OpenZeppelin SafeMath; mul/div have extra checks\\n */\\nlibrary DesynSafeMath {\\n    /**\\n     * @notice Safe addition\\n     * @param a - first operand\\n     * @param b - second operand\\n     * @dev if we are adding b to a, the resulting sum must be greater than a\\n     * @return - sum of operands; throws if overflow\\n     */\\n    function badd(uint a, uint b) internal pure returns (uint) {\\n        uint c = a + b;\\n        require(c >= a, \\\"ERR_ADD_OVERFLOW\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @notice Safe unsigned subtraction\\n     * @param a - first operand\\n     * @param b - second operand\\n     * @dev Do a signed subtraction, and check that it produces a positive value\\n     *      (i.e., a - b is valid if b <= a)\\n     * @return - a - b; throws if underflow\\n     */\\n    function bsub(uint a, uint b) internal pure returns (uint) {\\n        (uint c, bool negativeResult) = bsubSign(a, b);\\n        require(!negativeResult, \\\"ERR_SUB_UNDERFLOW\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @notice Safe signed subtraction\\n     * @param a - first operand\\n     * @param b - second operand\\n     * @dev Do a signed subtraction\\n     * @return - difference between a and b, and a flag indicating a negative result\\n     *           (i.e., a - b if a is greater than or equal to b; otherwise b - a)\\n     */\\n    function bsubSign(uint a, uint b) internal pure returns (uint, bool) {\\n        if (b <= a) {\\n            return (a - b, false);\\n        } else {\\n            return (b - a, true);\\n        }\\n    }\\n\\n    /**\\n     * @notice Safe multiplication\\n     * @param a - first operand\\n     * @param b - second operand\\n     * @dev Multiply safely (and efficiently), rounding down\\n     * @return - product of operands; throws if overflow or rounding error\\n     */\\n    function bmul(uint a, uint b) internal pure returns (uint) {\\n        // Gas optimization (see github.com/OpenZeppelin/openzeppelin-contracts/pull/522)\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // Standard overflow check: a/a*b=b\\n        uint c0 = a * b;\\n        require(c0 / a == b, \\\"ERR_MUL_OVERFLOW\\\");\\n\\n        // Round to 0 if x*y < BONE/2?\\n        uint c1 = c0 + (DesynConstants.BONE / 2);\\n        require(c1 >= c0, \\\"ERR_MUL_OVERFLOW\\\");\\n        uint c2 = c1 / DesynConstants.BONE;\\n        return c2;\\n    }\\n\\n    /**\\n     * @notice Safe division\\n     * @param dividend - first operand\\n     * @param divisor - second operand\\n     * @dev Divide safely (and efficiently), rounding down\\n     * @return - quotient; throws if overflow or rounding error\\n     */\\n    function bdiv(uint dividend, uint divisor) internal pure returns (uint) {\\n        require(divisor != 0, \\\"ERR_DIV_ZERO\\\");\\n\\n        // Gas optimization\\n        if (dividend == 0) {\\n            return 0;\\n        }\\n\\n        uint c0 = dividend * DesynConstants.BONE;\\n        require(c0 / dividend == DesynConstants.BONE, \\\"ERR_DIV_INTERNAL\\\"); // bmul overflow\\n\\n        uint c1 = c0 + (divisor / 2);\\n        require(c1 >= c0, \\\"ERR_DIV_INTERNAL\\\"); //  badd require\\n\\n        uint c2 = c1 / divisor;\\n        return c2;\\n    }\\n\\n    /**\\n     * @notice Safe unsigned integer modulo\\n     * @dev Returns the remainder of dividing two unsigned integers.\\n     *      Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * @param dividend - first operand\\n     * @param divisor - second operand -- cannot be zero\\n     * @return - quotient; throws if overflow or rounding error\\n     */\\n    function bmod(uint dividend, uint divisor) internal pure returns (uint) {\\n        require(divisor != 0, \\\"ERR_MODULO_BY_ZERO\\\");\\n\\n        return dividend % divisor;\\n    }\\n\\n    /**\\n     * @notice Safe unsigned integer max\\n     * @dev Returns the greater of the two input values\\n     *\\n     * @param a - first operand\\n     * @param b - second operand\\n     * @return - the maximum of a and b\\n     */\\n    function bmax(uint a, uint b) internal pure returns (uint) {\\n        return a >= b ? a : b;\\n    }\\n\\n    /**\\n     * @notice Safe unsigned integer min\\n     * @dev returns b, if b < a; otherwise returns a\\n     *\\n     * @param a - first operand\\n     * @param b - second operand\\n     * @return - the lesser of the two input values\\n     */\\n    function bmin(uint a, uint b) internal pure returns (uint) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @notice Safe unsigned integer average\\n     * @dev Guard against (a+b) overflow by dividing each operand separately\\n     *\\n     * @param a - first operand\\n     * @param b - second operand\\n     * @return - the average of the two values\\n     */\\n    function baverage(uint a, uint b) internal pure returns (uint) {\\n        // (a + b) / 2 can overflow, so we distribute\\n        return (a / 2) + (b / 2) + (((a % 2) + (b % 2)) / 2);\\n    }\\n\\n    /**\\n     * @notice Babylonian square root implementation\\n     * @dev (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\\n     * @param y - operand\\n     * @return z - the square root result\\n     */\\n    function sqrt(uint y) internal pure returns (uint z) {\\n        if (y > 3) {\\n            z = y;\\n            uint x = y / 2 + 1;\\n            while (x < z) {\\n                z = x;\\n                x = (y / x + x) / 2;\\n            }\\n        } else if (y != 0) {\\n            z = 1;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.6.12;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint a, uint b) internal pure returns (uint) {\\n        uint c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint a, uint b) internal pure returns (uint) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(\\n        uint a,\\n        uint b,\\n        string memory errorMessage\\n    ) internal pure returns (uint) {\\n        require(b <= a, errorMessage);\\n        uint c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint a, uint b) internal pure returns (uint) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint a, uint b) internal pure returns (uint) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(\\n        uint a,\\n        uint b,\\n        string memory errorMessage\\n    ) internal pure returns (uint) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, errorMessage);\\n        uint c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint a, uint b) internal pure returns (uint) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(\\n        uint a,\\n        uint b,\\n        string memory errorMessage\\n    ) internal pure returns (uint) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport {IERC20} from \\\"../interfaces/IERC20.sol\\\";\\nimport {SafeMath} from \\\"./SafeMath.sol\\\";\\nimport {Address} from \\\"./Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint;\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint value\\n    ) internal {\\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint value\\n    ) internal {\\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint value\\n    ) internal {\\n        require((value == 0) || (token.allowance(address(this), spender) == 0), \\\"SafeERC20: approve from non-zero to non-zero allowance\\\");\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\\n        require(address(token).isContract(), \\\"SafeERC20: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        require(success, \\\"SafeERC20: low-level call failed\\\");\\n\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/DesynConstants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.6.12;\\n\\n/**\\n * @author Desyn Labs\\n * @title Put all the constants in one place\\n */\\n\\nlibrary DesynConstants {\\n    // State variables (must be constant in a library)\\n\\n    // where numeric 1 = 10 ** 18\\n    uint public constant BONE = 10**18;\\n    uint public constant MIN_WEIGHT = BONE;\\n    uint public constant MAX_WEIGHT = BONE * 50;\\n    uint public constant MAX_TOTAL_WEIGHT = BONE * 50;\\n    uint public constant MIN_BALANCE = 0;\\n    uint public constant MAX_BALANCE = BONE * 10**12;\\n    uint public constant MIN_POOL_SUPPLY = BONE * 100;\\n    uint public constant MAX_POOL_SUPPLY = BONE * 10**9;\\n    uint public constant MIN_FEE = BONE / 10**6;\\n    uint public constant MAX_FEE = BONE / 10;\\n    //Fee Set\\n    uint public constant MANAGER_MIN_FEE = 0;\\n    uint public constant MANAGER_MAX_FEE = BONE / 10;\\n    uint public constant ISSUE_MIN_FEE = 0;\\n    uint public constant ISSUE_MAX_FEE = BONE / 10;\\n    uint public constant REDEEM_MIN_FEE = 0;\\n    uint public constant REDEEM_MAX_FEE = BONE / 10;\\n    uint public constant PERFERMANCE_MIN_FEE = 0;\\n    uint public constant PERFERMANCE_MAX_FEE = BONE / 2;\\n    // EXIT_FEE must always be zero, or ConfigurableRightsPool._pushUnderlying will fail\\n    uint public constant EXIT_FEE = 0;\\n    uint public constant MAX_IN_RATIO = BONE / 2;\\n    uint public constant MAX_OUT_RATIO = (BONE / 3) + 1 wei;\\n    // Must match BConst.MIN_BOUND_TOKENS and BConst.MAX_BOUND_TOKENS\\n    uint public constant MIN_ASSET_LIMIT = 1;\\n    uint public constant MAX_ASSET_LIMIT = 16;\\n    uint public constant MAX_UINT = uint(-1);\\n    uint public constant MAX_COLLECT_PERIOD = 60 days;\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.6.12;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\n        // for accounts without code, i.e. `keccak256('')`\\n        bytes32 codehash;\\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            codehash := extcodehash(account)\\n        }\\n        return (codehash != accountHash && codehash != 0x0);\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return _functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        return _functionCallWithValue(target, data, value, errorMessage);\\n    }\\n\\n    function _functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint weiValue,\\n        string memory errorMessage\\n    ) private returns (bytes memory) {\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{value: weiValue}(data);\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/deploy/Vault.sol\": {\r\n      \"content\": \"pragma solidity 0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../interfaces/IERC20.sol\\\";\\nimport \\\"../openzeppelin/Ownable.sol\\\";\\nimport \\\"../interfaces/IDSProxy.sol\\\";\\nimport \\\"../libraries/SafeMath.sol\\\";\\nimport \\\"../libraries/Address.sol\\\";\\nimport \\\"../libraries/SafeERC20.sol\\\";\\nimport \\\"../base/Logs.sol\\\";\\n\\ninterface ICRPPool {\\n    function getController() external view returns (address);\\n\\n    enum Etypes {\\n        OPENED,\\n        CLOSED\\n    }\\n\\n    function etype() external view returns (Etypes);\\n}\\n\\ninterface IDesynOwnable {\\n    function adminList(address adr) external view returns (bool);\\n    function getController() external view returns (address);\\n    function getOwners() external view returns (address[] memory);\\n    function getOwnerPercentage() external view returns (uint[] memory);\\n    function allOwnerPercentage() external view returns (uint);\\n}\\n\\ninterface IUserVault {\\n    function depositToken(\\n        address pool,\\n        uint types,\\n        address[] calldata poolTokens,\\n        uint[] calldata tokensAmount\\n    ) external;\\n}\\n\\ninterface ICRPFactory {\\n    function isCrp(address addr) external view returns (bool);\\n}\\n\\n/**\\n * @author Desyn Labs\\n * @title Vault managerFee\\n */\\ncontract Vault is Ownable, Logs {\\n    using SafeMath for uint;\\n    using Address for address;\\n    using SafeERC20 for IERC20;\\n\\n    ICRPFactory crpFactory;\\n    address public userVault;\\n\\n    event ManagersClaim(address indexed caller,address indexed pool, address token, uint amount, uint time);\\n    event ManagerClaim(address indexed caller, address indexed pool, address indexed manager, address token, uint amount, uint time);\\n\\n    // pool of tokens\\n    struct PoolTokens {\\n        address[] tokenList;\\n        uint[] managerAmount;\\n        uint[] issueAmount;\\n        uint[] redeemAmount;\\n        uint[] perfermanceAmount;\\n    }\\n\\n    struct PoolStatus {\\n        bool couldManagerClaim;\\n        bool isBlackList;\\n    }\\n    \\n    struct ClaimTokens {\\n        address[] tokens;\\n        uint[] amounts;\\n    }\\n\\n    // pool tokens\\n    mapping(address => PoolTokens) poolsTokens;\\n    mapping(address => PoolStatus) public poolsStatus;\\n\\n    mapping (address => ClaimTokens) manageHasClaimed;\\n\\n    // default ratio config\\n    uint public TOTAL_RATIO = 1000;\\n    uint public management_portion = 800;\\n    uint public issuance_portion = 800;\\n    uint public redemption_portion = 800;\\n    uint public performance_portion = 800;\\n\\n    receive() external payable {}\\n\\n    function depositManagerToken(address[] calldata tokensIn, uint[] calldata amountsIn) external {\\n        address pool = msg.sender;\\n        require(crpFactory.isCrp(pool), \\\"ERR_INVALID_POOL_ADDRESS\\\");\\n        require(tokensIn.length == amountsIn.length, \\\"ERR_TOKEN_LENGTH_NOT_MATCH\\\");\\n        _depositTokenIM(0, pool, tokensIn, amountsIn);\\n\\n        poolsStatus[pool].couldManagerClaim = true;\\n        \\n        if (_isClosePool(pool)) managerClaim(pool);\\n    }\\n\\n    function depositIssueRedeemPToken(\\n        address[] calldata tokensIn,\\n        uint[] calldata amountsIn,\\n        uint[] calldata tokensAmountIR,\\n        bool isPerfermance\\n    ) external {\\n        address pool = msg.sender;\\n        require(crpFactory.isCrp(pool), \\\"ERR_INVALID_POOL_ADDRESS\\\");\\n        require(tokensIn.length == amountsIn.length, \\\"ERR_TOKEN_LENGTH_NOT_MATCH\\\");\\n\\n        isPerfermance\\n                // I-issuce\uff1b M-mamager\uff1b R-redeem\uff1bp-performance\\n                ? _depositTokenRP(pool, tokensIn, amountsIn, tokensAmountIR)\\n                : _depositTokenIM(1, pool, tokensIn, amountsIn);\\n\\n        poolsStatus[pool].couldManagerClaim = true;\\n\\n        if (_isClosePool(pool)) managerClaim(pool);   \\n    }\\n\\n    function getManagerClaimBool(address pool) external view returns (bool) {\\n        return poolsStatus[pool].couldManagerClaim;\\n    }\\n\\n    function setBlackList(address pool, bool bools) external onlyOwner _logs_ {\\n        poolsStatus[pool].isBlackList = bools;\\n    }\\n\\n    function setUserVaultAdr(address adr) external onlyOwner _logs_ {\\n        require(adr != address(0), \\\"ERR_INVALID_USERVAULT_ADDRESS\\\");\\n        userVault = adr;\\n    }\\n\\n    function setCrpFactory(address adr) external onlyOwner _logs_ {\\n        crpFactory = ICRPFactory(adr);\\n    }\\n\\n    function claimToken(\\n        address token,\\n        address user,\\n        uint amount\\n    ) external onlyOwner {\\n        IERC20(token).safeTransfer(user, amount);\\n    }\\n\\n    function claimEther() external payable onlyOwner {\\n        msg.sender.transfer(address(this).balance);\\n    }\\n\\n    function setManagerRatio(uint amount) external onlyOwner _logs_ {\\n        require(amount <= TOTAL_RATIO, \\\"Maximum limit exceeded\\\");\\n        management_portion = amount;\\n    }\\n\\n    function setIssueRatio(uint amount) external onlyOwner _logs_ {\\n        require(amount <= TOTAL_RATIO, \\\"Maximum limit exceeded\\\");\\n        issuance_portion = amount;\\n    }\\n\\n    function setRedeemRatio(uint amount) external onlyOwner _logs_ {\\n        require(amount <= TOTAL_RATIO, \\\"Maximum limit exceeded\\\");\\n        redemption_portion = amount;\\n    }\\n\\n    function setPerfermanceRatio(uint amount) external onlyOwner _logs_{\\n        performance_portion = amount;\\n    }\\n\\n    function managerClaim(address pool) public {\\n        PoolStatus storage status = poolsStatus[pool];\\n\\n        if(status.couldManagerClaim){\\n            require(crpFactory.isCrp(pool), \\\"ERR_INVALID_POOL_ADDRESS\\\");\\n            address managerAddr = ICRPPool(pool).getController();\\n            bool isCloseETF = _isClosePool(pool);\\n\\n            PoolTokens memory tokens = poolsTokens[pool];\\n            address[] memory poolManageTokens = tokens.tokenList;\\n            uint len = poolManageTokens.length;\\n            require(!status.isBlackList, \\\"ERR_POOL_IS_BLACKLIST\\\");\\n            require(len > 0, \\\"ERR_NOT_MANGER_FEE\\\");\\n            require(status.couldManagerClaim, \\\"ERR_MANAGER_COULD_NOT_CLAIM\\\");\\n            status.couldManagerClaim = false;\\n\\n            uint[] memory managerTokenAmount = new uint[](len);\\n            uint[] memory issueTokenAmount = new uint[](len);\\n            uint[] memory redeemTokenAmount = new uint[](len);\\n            uint[] memory perfermanceTokenAmount = new uint[](len);\\n\\n            for (uint i; i < len; i++) {\\n                address t = poolManageTokens[i];\\n                uint b;\\n                (b, managerTokenAmount[i], issueTokenAmount[i], redeemTokenAmount[i], perfermanceTokenAmount[i]) = _computeBalance(i, pool);\\n                if(!isCloseETF) b = b.sub(_getManagerHasClaimed(pool,t));\\n                if(b != 0) _transferHandle(pool, managerAddr, t, b);\\n            }\\n            \\n            if (isCloseETF) {\\n                _recordUserVault(pool, poolManageTokens, managerTokenAmount, issueTokenAmount, redeemTokenAmount, perfermanceTokenAmount);\\n                _clearPool(pool);\\n            } \\n        }  \\n    }\\n\\n    function getManagerFeeTypes(address pool) external view returns(PoolTokens memory result){     \\n        PoolTokens memory tokens = poolsTokens[pool];\\n        address[] memory poolManageTokens = tokens.tokenList;\\n        uint len = poolManageTokens.length;\\n\\n        result.tokenList = tokens.tokenList;\\n        result.managerAmount = new uint[](len);\\n        result.issueAmount = new uint[](len);\\n        result.redeemAmount = new uint[](len);\\n        result.perfermanceAmount = new uint[](len);\\n\\n        for(uint i; i< len; i++){\\n            (,result.managerAmount[i],result.issueAmount[i],result.redeemAmount[i],result.perfermanceAmount[i]) = _computeBalance(i,pool);\\n        }\\n    }\\n\\n    function getUnManagerReward(address pool) external view returns (address[] memory tokensList, uint[] memory amounts) {\\n        PoolTokens memory tokens = poolsTokens[pool];\\n        address[] memory poolManageTokens = tokens.tokenList;\\n        uint len = poolManageTokens.length;\\n\\n        tokensList = new address[](len);\\n        amounts = new uint[](len);\\n\\n        for (uint i; i < len; i++) {\\n            address t = poolManageTokens[i];\\n            tokensList[i] = t;\\n            (amounts[i],,,,) = _computeBalance(i,pool);\\n            amounts[i] = amounts[i].sub(_getManagerHasClaimed(pool, t));\\n        }\\n    }\\n\\n    function _addTokenInPool(address pool, address tokenAddr) internal {\\n        PoolTokens storage tokens = poolsTokens[pool];\\n\\n        tokens.tokenList.push(tokenAddr);\\n        tokens.managerAmount.push(0);\\n        tokens.issueAmount.push(0);\\n        tokens.redeemAmount.push(0);\\n        tokens.perfermanceAmount.push(0);\\n    }\\n    // for old token\\n    function _updateTokenAmountInPool(uint types, address pool, uint tokenIndex, uint amount) internal {\\n        PoolTokens storage tokens = poolsTokens[pool];\\n\\n        if(types == 0) tokens.managerAmount[tokenIndex] = tokens.managerAmount[tokenIndex].add(amount);\\n        else if(types == 1) tokens.issueAmount[tokenIndex] = tokens.issueAmount[tokenIndex].add(amount);\\n        else if(types == 2) tokens.redeemAmount[tokenIndex] = tokens.redeemAmount[tokenIndex].add(amount);\\n        else if(types == 3) tokens.perfermanceAmount[tokenIndex] = tokens.perfermanceAmount[tokenIndex].add(amount);\\n    }\\n    // for new token\\n    function _updateTokenAmountInPool(uint types, address pool, uint amount) internal {\\n        PoolTokens storage tokens = poolsTokens[pool];\\n        uint tokenIndex = tokens.tokenList.length - 1;\\n\\n        if(types == 0) tokens.managerAmount[tokenIndex] = amount;\\n        else if(types == 1) tokens.issueAmount[tokenIndex] = amount;\\n        else if(types == 2) tokens.redeemAmount[tokenIndex] = amount;\\n        else if(types == 3) tokens.perfermanceAmount[tokenIndex] = amount;\\n    }\\n\\n    function _depositTokenIM(\\n        uint types,\\n        address pool,\\n        address[] memory tokensIn,\\n        uint[] memory amountsIn\\n    ) internal {\\n        PoolTokens memory tokens = poolsTokens[pool];\\n\\n        uint len = tokensIn.length;\\n        for (uint i; i < len; i++) {\\n            address t = tokensIn[i];\\n            uint b = amountsIn[i];\\n\\n            IERC20(t).safeTransferFrom(msg.sender, address(this), b);\\n            (bool isExit, uint index) = _arrIncludeAddr(tokens.tokenList,t);\\n            if (isExit) {\\n                _updateTokenAmountInPool(types,pool,index,b);\\n            } else { \\n                _addTokenInPool(pool,t); \\n                _updateTokenAmountInPool(types,pool,b);    \\n            }\\n        }\\n    }\\n\\n    function _arrIncludeAddr(address[] memory tokens, address target) internal pure returns(bool isInclude, uint index){\\n        for(uint i; i<tokens.length; i++){\\n            if(tokens[i] == target){ \\n                isInclude = true;\\n                index = i;\\n                break;\\n            }\\n        }\\n    }\\n\\n    function _depositTokenRP(\\n        address pool,\\n        address[] calldata tokenIns,\\n        uint[] calldata tokensAmount,\\n        uint[] calldata tokensAmountIR\\n    ) internal {\\n        address[] memory tokenList = poolsTokens[pool].tokenList;\\n\\n        uint len = tokensAmount.length;\\n        for (uint i; i < len; i++) {\\n            address t = tokenIns[i];\\n            uint b = tokensAmount[i];\\n            // uint bIR = tokensAmountIR[i];\\n            IERC20(t).safeTransferFrom(msg.sender, address(this), b);\\n\\n            (bool isExit,uint index) = _arrIncludeAddr(tokenList, t);\\n            if(isExit){\\n                _updateTokenAmountInPool(2, pool, index, tokensAmountIR[i]);\\n                _updateTokenAmountInPool(3, pool, index, b.sub(tokensAmountIR[i]));\\n            } else {\\n                _addTokenInPool(pool, t);\\n                _updateTokenAmountInPool(2,pool, tokensAmountIR[i]);\\n                _updateTokenAmountInPool(3, pool,b.sub(tokensAmountIR[i]));        \\n            }\\n        }\\n    }\\n\\n    function _isClosePool(address pool) internal view returns (bool) {\\n        return ICRPPool(pool).etype() == ICRPPool.Etypes.CLOSED;\\n    }\\n\\n    function _computeBalance(uint i, address pool)\\n        internal\\n        view\\n        returns (\\n            uint balance,\\n            uint bManagerAmount,\\n            uint bIssueAmount,\\n            uint bRedeemAmount,\\n            uint bPerfermanceAmount\\n        )\\n    {\\n        PoolTokens memory tokens = poolsTokens[pool];\\n\\n        if (tokens.tokenList.length != 0) {\\n            bManagerAmount = tokens.managerAmount[i].mul(management_portion).div(TOTAL_RATIO);\\n            bIssueAmount = tokens.issueAmount[i].mul(issuance_portion).div(TOTAL_RATIO);\\n            bRedeemAmount = tokens.redeemAmount[i].mul(redemption_portion).div(TOTAL_RATIO);\\n            bPerfermanceAmount = tokens.perfermanceAmount[i].mul(performance_portion).div(TOTAL_RATIO);\\n\\n            balance = bManagerAmount.add(bIssueAmount).add(bRedeemAmount).add(bPerfermanceAmount);\\n        }\\n    }\\n\\n    function _clearPool(address pool) internal {\\n        delete poolsTokens[pool];\\n    }\\n\\n    function _recordUserVault(\\n        address pool,\\n        address[] memory tokenList,\\n        uint[] memory managerTokenAmount,\\n        uint[] memory issueTokenAmount,\\n        uint[] memory redeemTokenAmount,\\n        uint[] memory perfermanceTokenAmount\\n    ) internal {\\n        if (tokenList.length != 0) {\\n            IUserVault(userVault).depositToken(pool, 0, tokenList, managerTokenAmount);\\n            IUserVault(userVault).depositToken(pool, 1, tokenList, issueTokenAmount);\\n            IUserVault(userVault).depositToken(pool, 2, tokenList, redeemTokenAmount);\\n            IUserVault(userVault).depositToken(pool, 3, tokenList, perfermanceTokenAmount);\\n        }\\n\\n    }\\n\\n    function _transferHandle(\\n        address pool,\\n        address managerAddr,\\n        address t,\\n        uint balance\\n    ) internal {\\n        require(balance != 0, \\\"ERR_ILLEGAL_BALANCE\\\");\\n        bool isCloseETF = _isClosePool(pool);\\n        bool isOpenETF = !isCloseETF;\\n\\n        if(isCloseETF){\\n            IERC20(t).safeTransfer(userVault, balance);\\n        }\\n\\n        // if(isOpenETF && isContractManager){\\n        if(isOpenETF) {\\n            address[] memory managerAddressList = IDesynOwnable(pool).getOwners();\\n            uint[] memory ownerPercentage = IDesynOwnable(pool).getOwnerPercentage();\\n            uint allOwnerPercentage = IDesynOwnable(pool).allOwnerPercentage();\\n\\n            for (uint k; k < managerAddressList.length; k++) {\\n                address reciver = address(managerAddressList[k]).isContract()? IDSProxy(managerAddressList[k]).owner(): managerAddressList[k];\\n                uint b = balance.mul(ownerPercentage[k]).div(allOwnerPercentage);\\n                IERC20(t).safeTransfer(reciver, b);\\n                emit ManagerClaim(msg.sender, pool, reciver,t,b,block.timestamp);\\n            }\\n            _updateManageHasClaimed(pool,t,balance);\\n            emit ManagersClaim(msg.sender, pool, t, balance, block.timestamp);\\n        }\\n    }\\n\\n    function _updateManageHasClaimed(address pool, address token, uint amount) internal {\\n        ClaimTokens storage claimInfo = manageHasClaimed[pool];\\n        (bool isExit, uint index) = _arrIncludeAddr(claimInfo.tokens, token);\\n\\n        if(isExit){\\n            claimInfo.amounts[index] = claimInfo.amounts[index].add(amount);\\n        } else{\\n            claimInfo.tokens.push(token);\\n            claimInfo.amounts.push(amount);\\n        }\\n    }\\n\\n    function _getManagerHasClaimed(address pool, address token) internal view returns(uint){\\n        require(!_isClosePool(pool),\\\"ERR_NOT_OPEN_POOL\\\");\\n\\n        ClaimTokens memory claimInfo = manageHasClaimed[pool];\\n        (bool isExit,uint index) = _arrIncludeAddr(claimInfo.tokens, token);\\n\\n        if(isExit) return claimInfo.amounts[index];\\n        if(!isExit) return 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin/Ownable.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.0 <0.8.0;\\n\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () internal {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\"\r\n    },\r\n    \"contracts/interfaces/IDSProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.6.12;\\n\\ninterface IDSProxy {\\n    function owner() external view returns(address);\\n}\"\r\n    },\r\n    \"contracts/base/Logs.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.6.12;\\n\\ncontract Logs {\\n    event LOG_CALL(bytes4 indexed sig, address indexed caller, bytes data) anonymous;\\n\\n    modifier _logs_() {\\n        emit LOG_CALL(msg.sig, msg.sender, msg.data);\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/deploy/UserVault.sol\": {\r\n      \"content\": \"pragma solidity 0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../interfaces/IERC20.sol\\\";\\nimport \\\"../interfaces/IDSProxy.sol\\\";\\nimport \\\"../openzeppelin/Ownable.sol\\\";\\nimport  \\\"../libraries/SmartPoolManager.sol\\\";\\nimport \\\"../libraries/EnumerableSet.sol\\\";\\nimport \\\"../libraries/SafeMath.sol\\\";\\nimport \\\"../libraries/Address.sol\\\";\\nimport \\\"../libraries/SafeERC20.sol\\\";\\nimport \\\"../base/Logs.sol\\\";\\n\\ninterface ICRPPool {\\n    function getController() external view returns (address);\\n\\n    enum Etypes {\\n        OPENED,\\n        CLOSED\\n    }\\n\\n    function etype() external view returns (Etypes);\\n\\n    function isCompletedCollect() external view returns (bool);\\n}\\n\\ninterface ICRPFactory {\\n    function isCrp(address addr) external view returns (bool);\\n}\\n\\ninterface IDesynOwnable {\\n    function adminList(address adr) external view returns (bool);\\n    function getController() external view returns (address);\\n    function getOwners() external view returns (address[] memory);\\n    function getOwnerPercentage() external view returns (uint[] memory);\\n    function allOwnerPercentage() external view returns (uint);\\n}\\n\\n/**\\n * @author Desyn Labs\\n * @title Vault managerFee\\n */\\ncontract UserVault is Ownable, Logs {\\n    using SafeMath for uint;\\n    using Address for address;\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n    using SafeERC20 for IERC20;\\n\\n    event ManagersClaim(address indexed caller,address indexed pool, address token, uint amount, uint time);\\n    event ManagerClaim(address indexed caller,address indexed pool, address indexed manager, address token, uint amount, uint time);\\n    event KolClaim(address indexed caller,address indexed kol, address token, uint amount, uint time);\\n\\n    event TypeAmountIn(address indexed pool, uint types, address caller, address token, uint balance);\\n\\n    ICRPFactory crpFactory;\\n    address vaultAddress;\\n\\n    // pool of tokens\\n    struct PoolTokens {\\n        address[] tokenList;\\n        uint[] managerAmount;\\n        uint[] issueAmount;\\n        uint[] redeemAmount;\\n        uint[] perfermanceAmount;\\n    }\\n\\n    struct PoolStatus {\\n        bool couldManagerClaim;\\n        bool isBlackList;\\n        bool isSetParams;\\n        SmartPoolManager.KolPoolParams kolPoolConfig;\\n    }\\n\\n    // kol list\\n    struct KolUserInfo {\\n        address userAdr;\\n        uint[] userAmount;\\n    }\\n\\n    struct UserKolInfo {\\n        address kol;\\n        uint index;\\n    }\\n\\n    struct ClaimTokens {\\n        address[] tokens;\\n        uint[] amounts;\\n    }\\n\\n    // pool => kol => KolUserInfo[]\\n    mapping(address => mapping(address => KolUserInfo[])) kolUserInfo;\\n\\n    // pool tokens\\n    mapping(address => PoolTokens) poolsTokens;\\n    mapping(address => PoolStatus) poolsStatus;\\n\\n    //pool => initTotalAmount[]\\n    mapping(address => uint) public poolInviteTotal;\\n\\n    //pool => kol[]\\n    mapping(address => EnumerableSet.AddressSet) kolsList;\\n\\n    //pool => kol => totalAmount[]\\n    mapping(address => mapping(address => uint[])) public kolTotalAmountList;\\n\\n    // pool => user => kol\\n    mapping(address => mapping(address => UserKolInfo)) public userKolList;\\n    \\n    // pool=>kol=>tokens\\n    mapping(address => mapping(address => ClaimTokens)) kolHasClaimed;\\n\\n    // pool=>manage=>tokens\\n    mapping (address => ClaimTokens) manageHasClaimed;\\n\\n    receive() external payable {}\\n\\n    uint constant RATIO_BASE = 100;\\n\\n    function getManagerClaimBool(address pool) external view returns(bool){\\n        return poolsStatus[pool].couldManagerClaim;\\n    }\\n\\n    // one type call and receiver token\\n    function depositToken(\\n        address pool,\\n        uint types,\\n        address[] calldata tokensIn,\\n        uint[] calldata amountsIn\\n    ) external onlyVault {\\n        require(tokensIn.length == amountsIn.length, \\\"ERR_TOKEN_LENGTH_NOT_MATCH\\\");\\n        _updatePool(pool, types, tokensIn, amountsIn);\\n        poolsStatus[pool].couldManagerClaim = true;\\n    }\\n\\n    // total tokens in pool\\n    function getPoolReward(address pool) external view returns (address[] memory tokenList, uint[] memory balances) {\\n        PoolTokens memory tokens = poolsTokens[pool];\\n        uint len = tokens.tokenList.length;\\n\\n        balances = new uint[](len);    \\n        tokenList = tokens.tokenList;\\n\\n        for(uint i; i<len ;i++){\\n            balances[i] = tokens.managerAmount[i]\\n                            .add(tokens.issueAmount[i])\\n                            .add(tokens.redeemAmount[i])\\n                            .add(tokens.perfermanceAmount[i]);\\n        }\\n    }\\n\\n    struct RewardVars {\\n        address pool;\\n        uint t0Ratio;\\n        uint t1Ratio;\\n        uint t2Ratio;\\n        uint t3Ratio;\\n        uint[] managementAmounts;\\n        uint[] issueAmounts;\\n        uint[] redemptionAmounts;\\n        uint[] performanceAmounts;\\n    }\\n\\n    // one kol total reward \\n    function getKolReward(\\n        address pool,\\n        address kol\\n    ) external view returns (address[] memory tokenList, uint[] memory balances) {\\n        uint contributionByCurKol = kolTotalAmountList[pool][kol].length > 0 ? kolTotalAmountList[pool][kol][0] : 0;\\n        uint allContributionByKol = poolInviteTotal[pool];\\n\\n        SmartPoolManager.KolPoolParams memory params = poolsStatus[pool].kolPoolConfig;\\n\\n        PoolTokens memory tokens = poolsTokens[pool];\\n        balances = new uint[](tokens.tokenList.length);\\n        tokenList = tokens.tokenList;\\n\\n        RewardVars memory vars = RewardVars(\\n            pool,\\n            _levelJudge(contributionByCurKol, params.managerFee),\\n            _levelJudge(contributionByCurKol, params.issueFee),\\n            _levelJudge(contributionByCurKol, params.redeemFee),\\n            _levelJudge(contributionByCurKol, params.perfermanceFee),\\n            tokens.managerAmount,\\n            tokens.issueAmount,\\n            tokens.redeemAmount,\\n            tokens.perfermanceAmount\\n        );\\n\\n        for(uint i; i < tokenList.length; i++){\\n             balances[i] = vars.managementAmounts[i].mul(vars.t0Ratio).div(RATIO_BASE)\\n                                .add(vars.issueAmounts[i].mul(vars.t1Ratio).div(RATIO_BASE))\\n                                .add(vars.redemptionAmounts[i].mul(vars.t2Ratio).div(RATIO_BASE))\\n                                .add(vars.performanceAmounts[i].mul(vars.t3Ratio).div(RATIO_BASE))\\n                                .mul(contributionByCurKol)\\n                                .div(allContributionByKol);\\n        }\\n    }\\n\\n    function kolClaim(address pool) external {\\n        if (_isClosePool(pool)) {\\n            require(crpFactory.isCrp(pool), \\\"ERR_INVALID_POOL_ADDRESS\\\");\\n            require(ICRPPool(pool).isCompletedCollect(), \\\"ERR_NOT_COMPLETED_COLLECT\\\");\\n            (address[] memory tokens, uint[] memory amounts) = this.getKolReward(pool, msg.sender);\\n\\n            ClaimTokens storage kolClaimedInfo = kolHasClaimed[pool][msg.sender];\\n\\n            // update length\\n            kolClaimedInfo.tokens = tokens;\\n            uint amountsLen = kolClaimedInfo.amounts.length;\\n            uint tokensLen = tokens.length;\\n\\n            if(amountsLen != tokensLen){\\n                uint delta = tokensLen - amountsLen;\\n                for(uint i; i < delta; i++){\\n                    kolClaimedInfo.amounts.push(0);\\n                }\\n            }\\n            \\n            address receiver = address(msg.sender).isContract()? IDSProxy(msg.sender).owner(): msg.sender;\\n            for(uint i; i< tokens.length; i++) {\\n                uint b = amounts[i] - kolClaimedInfo.amounts[i];\\n                if(b != 0){\\n                    IERC20(tokens[i]).safeTransfer(receiver, b);\\n                    kolClaimedInfo.amounts[i] = kolClaimedInfo.amounts[i].add(b);\\n                    emit KolClaim(msg.sender,receiver,tokens[i],b,block.timestamp);\\n                }\\n            }\\n        }\\n    }\\n\\n    // manager claim\\n    function managerClaim(address pool) external {\\n        // try  {} catch {}\\n        if (_isClosePool(pool) && poolsStatus[pool].couldManagerClaim) {\\n            bool isManager = IDesynOwnable(pool).adminList(msg.sender) || IDesynOwnable(pool).getController() == msg.sender;\\n            bool isCollectSuccee = ICRPPool(pool).isCompletedCollect();\\n            require(isCollectSuccee, \\\"ERR_NOT_COMPLETED_COLLECT\\\");\\n            require(isManager, \\\"ERR_NOT_MANAGER\\\");\\n            (address[] memory tokens, uint[] memory amounts) = this.getUnManagerReward(pool);\\n            poolsStatus[pool].couldManagerClaim = false;\\n\\n            ClaimTokens storage manageHasClimed = manageHasClaimed[pool];\\n\\n            // update length\\n            manageHasClimed.tokens = tokens;\\n            uint amountsLen = manageHasClimed.amounts.length;\\n            uint tokensLen = tokens.length;\\n\\n            if(amountsLen != tokensLen){\\n                uint delta = tokensLen - amountsLen;\\n                for(uint i; i < delta; i++){\\n                    manageHasClimed.amounts.push(0);\\n                }\\n            }\\n            // update tokens\\n            for(uint i; i< tokens.length; i++){\\n                address t = tokens[i];\\n                if(amounts[i]!=0){\\n                    _transferHandle(pool, t, amounts[i]);\\n                    manageHasClimed.amounts[i] = manageHasClimed.amounts[i].add(amounts[i]);\\n                }\\n            }\\n        }\\n    }\\n\\n    function getManagerReward(address pool) external view returns (address[] memory, uint[] memory) {\\n        (address[] memory totalTokens, uint[] memory totalFee) = this.getPoolReward(pool);\\n        (, uint[] memory kolFee) = this.getKolsReward(pool);\\n\\n        uint len = totalTokens.length;\\n        uint[] memory balances = new uint[](len);\\n\\n        for(uint i; i<len; i++){\\n            balances[i] = totalFee[i] - kolFee[i];\\n        }\\n\\n        return (totalTokens, balances);\\n    }\\n    // for all manager\\n    function getUnManagerReward(address pool) external returns (address[] memory, uint[] memory) {\\n        (address[] memory totalTokens, uint[] memory totalAmounts) = this.getManagerReward(pool);\\n        ClaimTokens storage manageHasClimed = manageHasClaimed[pool];\\n\\n        // update length\\n        manageHasClimed.tokens = totalTokens;\\n        uint amountsLen = manageHasClimed.amounts.length;\\n        uint tokensLen = totalTokens.length;\\n        if(amountsLen != tokensLen){\\n            uint delta = tokensLen - amountsLen;\\n            for(uint i; i < delta; i++){\\n                manageHasClimed.amounts.push(0);\\n            }\\n        }\\n\\n        uint len = totalTokens.length;\\n        uint[] memory balances = new uint[](len);\\n        for(uint i; i < totalTokens.length; i++){\\n            balances[i] = totalAmounts[i] - manageHasClimed.amounts[i];\\n        }        \\n\\n        return (totalTokens,balances);\\n    }\\n\\n    function getPoolFeeTypes(address pool) external view returns(PoolTokens memory result){      \\n        return poolsTokens[pool];\\n    }\\n    \\n    function getManagerFeeTypes(address pool) external view returns(PoolTokens memory result){     \\n        result = this.getPoolFeeTypes(pool);\\n        PoolTokens memory allKolFee = _getKolsFeeTypes(pool); \\n\\n        uint len = result.tokenList.length;\\n        for(uint i; i< len; i++){\\n            result.managerAmount[i] = result.managerAmount[i].sub(allKolFee.managerAmount[i]);\\n            result.issueAmount[i] = result.issueAmount[i].sub(allKolFee.issueAmount[i]);\\n            result.redeemAmount[i] = result.redeemAmount[i].sub(allKolFee.redeemAmount[i]);\\n            result.perfermanceAmount[i] = result.perfermanceAmount[i].sub(allKolFee.perfermanceAmount[i]);\\n        }\\n    }\\n  \\n    function _getKolsFeeTypes(address pool) internal view returns(PoolTokens memory result) {\\n        PoolTokens memory poolInfo = poolsTokens[pool];\\n        uint len = poolInfo.tokenList.length;\\n        result.tokenList = poolInfo.tokenList;\\n        \\n        EnumerableSet.AddressSet storage list = kolsList[pool];\\n        uint kolLen = list.length();\\n        // init result\\n        result.managerAmount = new uint[](len);\\n        result.issueAmount = new uint[](len);\\n        result.redeemAmount = new uint[](len);\\n        result.perfermanceAmount = new uint[](len);\\n\\n        for(uint types; types<4; types++){\\n            for(uint i; i<len; i++){ \\n                for (uint j; j < kolLen; j++) {\\n                    if(types == 0) result.managerAmount[i] = result.managerAmount[i].add(_computeKolTotalReward(pool, list.at(j), 0, i));\\n                    else if(types == 1) result.issueAmount[i] = result.issueAmount[i].add(_computeKolTotalReward(pool, list.at(j), 1, i));\\n                    else if(types == 2) result.redeemAmount[i] = result.redeemAmount[i].add(_computeKolTotalReward(pool, list.at(j), 2, i));\\n                    else if(types == 3) result.perfermanceAmount[i] = result.perfermanceAmount[i].add(_computeKolTotalReward(pool, list.at(j), 3, i));\\n                }    \\n            }      \\n        }\\n    }\\n\\n    function getKolFeeType(address pool, address kol) external view returns(PoolTokens memory result) {\\n        PoolTokens memory poolInfo = poolsTokens[pool];\\n        result.tokenList = poolInfo.tokenList;\\n        \\n        uint len = poolInfo.tokenList.length;\\n        // init result\\n        result.managerAmount = new uint[](len);\\n        result.issueAmount = new uint[](len);\\n        result.redeemAmount = new uint[](len);\\n        result.perfermanceAmount = new uint[](len);\\n        // more for to save gas\\n        for(uint i; i<len; i++){ \\n            result.managerAmount[i] = result.managerAmount[i].add(_computeKolTotalReward(pool, kol, 0, i));\\n            result.issueAmount[i] = result.issueAmount[i].add(_computeKolTotalReward(pool, kol, 1, i));\\n            result.redeemAmount[i] = result.redeemAmount[i].add(_computeKolTotalReward(pool, kol, 2, i));\\n            result.perfermanceAmount[i] = result.perfermanceAmount[i].add(_computeKolTotalReward(pool, kol, 3, i));\\n        }      \\n    }\\n\\n    function getKolsReward(address pool) external view returns (address[] memory, uint[] memory) {\\n        EnumerableSet.AddressSet storage list = kolsList[pool];\\n        uint len = list.length();\\n        address[] memory tokens = poolsTokens[pool].tokenList;\\n        uint[] memory balances = new uint[](tokens.length);\\n        for (uint i = 0; i < len; i++) {\\n            (, uint[] memory singleReward) = this.getKolReward(pool, list.at(i));\\n            for(uint k; k < singleReward.length; k++){\\n                balances[k] = balances[k] + singleReward[k];\\n            }\\n        }\\n\\n        return (tokens,balances);\\n    }\\n\\n    function getUnKolReward(address pool, address kol) external returns (address[] memory,uint[] memory) {\\n        (address[] memory totalTokens, uint[] memory totalReward) = this.getKolReward(pool, kol);\\n\\n        ClaimTokens storage singleKolHasReward = kolHasClaimed[pool][kol];\\n        // update length\\n        singleKolHasReward.tokens = totalTokens;\\n        uint amountsLen = singleKolHasReward.amounts.length;\\n        uint tokensLen = totalTokens.length;\\n        if(amountsLen != tokensLen){\\n            uint delta = tokensLen - amountsLen;\\n            for(uint i; i < delta; i++){\\n                singleKolHasReward.amounts.push(0);\\n            }\\n        }\\n\\n        uint len = totalTokens.length;\\n        uint[] memory balances = new uint[](len);\\n        for(uint i; i<len; i++){\\n            balances[i] = totalReward[i] - singleKolHasReward.amounts[i];\\n        }\\n\\n        return (totalTokens, balances);\\n    }\\n\\n    function recordTokenInfo(\\n        address kol,\\n        address user,\\n        address[] calldata poolTokens,\\n        uint[] calldata tokensAmount\\n    ) external {\\n        address pool = msg.sender;\\n        uint len = poolTokens.length;\\n        require(len == tokensAmount.length, \\\"ERR_TOKEN_LENGTH_NOT_MATCH\\\");\\n        require(crpFactory.isCrp(pool), \\\"ERR_INVALID_POOL_ADDRESS\\\");\\n        UserKolInfo storage userKolBind = userKolList[pool][user];\\n        \\n        if (userKolBind.kol == address(0)) {\\n            userKolBind.kol = kol;\\n            if (!kolsList[pool].contains(kol)) kolsList[pool].addValue(kol);\\n        }\\n        address newKol = userKolBind.kol;\\n        require(newKol != address(0), \\\"ERR_INVALID_KOL_ADDRESS\\\");\\n        //total amount record\\n        poolInviteTotal[pool] = poolInviteTotal[pool].add(tokensAmount[0]);\\n        uint[] memory totalAmounts = new uint[](len);\\n        for (uint i; i < len; i++) {\\n            bool kolHasInvitations = kolTotalAmountList[pool][newKol].length == 0;\\n            kolHasInvitations\\n                ? totalAmounts[i] = tokensAmount[i]\\n                : totalAmounts[i] = tokensAmount[i].add(kolTotalAmountList[pool][newKol][i]);\\n        }\\n        kolTotalAmountList[pool][newKol] = totalAmounts;\\n        //kol user info record\\n        KolUserInfo[] storage userInfoArray = kolUserInfo[pool][newKol];\\n        uint index = userKolBind.index;\\n        if (index == 0) {\\n            KolUserInfo memory userInfo;\\n            userInfo.userAdr = user;\\n            userInfo.userAmount = tokensAmount;\\n            userInfoArray.push(userInfo);\\n            userKolBind.index = userInfoArray.length;\\n        } else {\\n            KolUserInfo storage userInfo = kolUserInfo[pool][newKol][index - 1];\\n            for (uint a; a < userInfo.userAmount.length; a++) {\\n                userInfo.userAmount[a] = userInfo.userAmount[a].add(tokensAmount[a]);\\n            }\\n        }\\n    }\\n\\n    function setPoolParams(address pool, SmartPoolManager.KolPoolParams memory _poolParams) external onlyCrpFactory {\\n        PoolStatus storage status = poolsStatus[pool];\\n        require(crpFactory.isCrp(pool), \\\"ERR_INVALID_POOL_ADDRESS\\\");\\n        require(!status.isSetParams, \\\"ERR_HAS_SETED\\\");\\n\\n        status.isSetParams = true;\\n        status.kolPoolConfig = _poolParams;\\n    }\\n\\n    // function _getRatioTotal(address pool, uint types) internal view returns(uint){\\n    //     SmartPoolManager.KolPoolParams memory params = poolsStatus[pool].kolPoolConfig;\\n    //     if(types == 0) return params.managerFee.firstLevel.ratio.add(params.managerFee.secondLevel.ratio).add(params.managerFee.thirdLevel.ratio).add(params.managerFee.fourLevel.ratio);\\n    //     else if(types == 1) return params.issueFee.firstLevel.ratio.add(params.issueFee.secondLevel.ratio).add(params.issueFee.thirdLevel.ratio).add(params.issueFee.fourLevel.ratio);\\n    //     else if(types == 2) return params.redeemFee.firstLevel.ratio.add(params.redeemFee.secondLevel.ratio).add(params.redeemFee.thirdLevel.ratio).add(params.redeemFee.fourLevel.ratio);\\n    //     else if(types == 3) return params.perfermanceFee.firstLevel.ratio.add(params.perfermanceFee.secondLevel.ratio).add(params.perfermanceFee.thirdLevel.ratio).add(params.perfermanceFee.fourLevel.ratio);\\n    // }\\n\\n    function getKolsAdr(address pool) external view returns (address[] memory) {\\n        return kolsList[pool].values();\\n    }\\n\\n    function getPoolConfig(address pool) external view returns (SmartPoolManager.KolPoolParams memory) {\\n        return poolsStatus[pool].kolPoolConfig;\\n    }\\n\\n    function setBlackList(address pool, bool bools) external onlyOwner _logs_ {\\n        poolsStatus[pool].isBlackList = bools;\\n    }\\n\\n    function setCrpFactory(address adr) external onlyOwner _logs_ {\\n        crpFactory = ICRPFactory(adr);\\n    }\\n\\n    function claimToken(\\n        address token,\\n        address user,\\n        uint amount\\n    ) external onlyOwner {\\n        IERC20(token).safeTransfer(user, amount);\\n    }\\n\\n    function claimEther() external payable onlyOwner {\\n        msg.sender.transfer(address(this).balance);\\n    }\\n\\n    function setVaultAdr(address adr) external onlyOwner _logs_ {\\n        vaultAddress = adr;\\n    }\\n\\n    function getKolHasClaimed(address pool,address kol) external view returns(ClaimTokens memory) {\\n        return kolHasClaimed[pool][kol];\\n    }\\n        \\n    function getManageHasClaimed(address pool) external view returns(ClaimTokens memory) {\\n        return manageHasClaimed[pool];\\n    }\\n\\n    function getKolUserInfo(address pool, address kol) external view  returns (KolUserInfo[] memory) {\\n        return kolUserInfo[pool][kol];\\n    }\\n\\n    function getUserKolInfo(address pool, address user) external view  returns (UserKolInfo memory) {\\n        return userKolList[pool][user];\\n    }\\n\\n    function _updatePool(\\n        address pool,\\n        uint types,\\n        address[] memory tokenIn,\\n        uint[] memory amountIn\\n    ) internal {\\n        PoolTokens storage tokens = poolsTokens[pool];\\n\\n        for(uint i; i < tokenIn.length; i++){\\n            address t = tokenIn[i];\\n            uint b = amountIn[i];\\n\\n            (bool isExit,uint index) = _arrIncludeAddr(tokens.tokenList, t);\\n\\n            // update token and init value\\n            if(!isExit){\\n                tokens.tokenList.push(t);\\n                tokens.managerAmount.push(0);\\n                tokens.issueAmount.push(0);\\n                tokens.redeemAmount.push(0);\\n                tokens.perfermanceAmount.push(0);\\n                index = tokens.tokenList.length -1;\\n            }\\n\\n            // update valut\\n            if(b != 0){\\n                if(types == 0) tokens.managerAmount[index] = tokens.managerAmount[index].add(b);\\n                else if(types == 1) tokens.issueAmount[index] = tokens.issueAmount[index].add(b);\\n                else if(types == 2) tokens.redeemAmount[index] = tokens.redeemAmount[index].add(b);\\n                else if(types == 3) tokens.perfermanceAmount[index] = tokens.perfermanceAmount[index].add(b);\\n                emit TypeAmountIn(pool, types, msg.sender, t, b);\\n            }\\n        }\\n    }\\n\\n    function _arrIncludeAddr(address[] memory tokens, address target) internal pure returns(bool isInclude, uint index){\\n        for(uint i; i<tokens.length; i++){\\n            if(tokens[i] == target){ \\n                isInclude = true;\\n                index = i;\\n                break;\\n            }\\n        }\\n    }\\n\\n    function _transferHandle(\\n        address pool,\\n        address t,\\n        uint balance\\n    ) internal {\\n        require(balance != 0, \\\"ERR_ILLEGAL_BALANCE\\\");\\n        address[] memory managerAddressList = IDesynOwnable(pool).getOwners();\\n        uint[] memory ownerPercentage = IDesynOwnable(pool).getOwnerPercentage();\\n        uint allOwnerPercentage = IDesynOwnable(pool).allOwnerPercentage();\\n\\n        for (uint k = 0; k < managerAddressList.length; k++) {\\n            address reciver = address(managerAddressList[k]).isContract()? IDSProxy(managerAddressList[k]).owner(): managerAddressList[k];\\n            uint b = balance.mul(ownerPercentage[k]).div(allOwnerPercentage);\\n            IERC20(t).safeTransfer(reciver, b);\\n            emit ManagerClaim(msg.sender, pool, reciver,t,b,block.timestamp);\\n        }\\n        emit ManagersClaim(msg.sender,pool,t,balance,block.timestamp);\\n    }\\n\\n    function _levelJudge(uint amount, SmartPoolManager.feeParams memory _feeParams) internal pure returns (uint) {\\n        if (_feeParams.firstLevel.level <= amount && amount < _feeParams.secondLevel.level) return _feeParams.firstLevel.ratio;\\n        else if (_feeParams.secondLevel.level <= amount && amount < _feeParams.thirdLevel.level) return _feeParams.secondLevel.ratio;\\n        else if (_feeParams.thirdLevel.level <= amount && amount < _feeParams.fourLevel.level) return _feeParams.thirdLevel.ratio;\\n        else if (_feeParams.fourLevel.level <= amount) return _feeParams.fourLevel.ratio;\\n        return 0;\\n    }\\n\\n    function _isClosePool(address pool) internal view returns (bool) {\\n        return ICRPPool(pool).etype() == ICRPPool.Etypes.CLOSED;\\n    }\\n\\n    function _computeKolTotalReward(\\n        address pool,\\n        address kol,\\n        uint types,\\n        uint tokenIndex\\n    ) internal view returns (uint totalFee) {\\n        uint kolTotalAmount = kolTotalAmountList[pool][kol].length > 0 ? kolTotalAmountList[pool][kol][0] : 0;\\n        SmartPoolManager.KolPoolParams memory params = poolsStatus[pool].kolPoolConfig;\\n\\n        PoolTokens memory tokens = poolsTokens[pool];\\n\\n        if(kolTotalAmount == 0 || tokens.tokenList.length == 0) return 0;\\n\\n        uint allKolTotalAmount = poolInviteTotal[pool];\\n        if (types == 0) totalFee = tokens.managerAmount[tokenIndex].mul(_levelJudge(kolTotalAmount, params.managerFee)).div(RATIO_BASE);\\n        else if (types == 1) totalFee = tokens.issueAmount[tokenIndex].mul(_levelJudge(kolTotalAmount, params.issueFee)).div(RATIO_BASE);\\n        else if (types == 2) totalFee = tokens.redeemAmount[tokenIndex].mul(_levelJudge(kolTotalAmount, params.redeemFee)).div(RATIO_BASE);\\n        else if (types == 3) totalFee = tokens.perfermanceAmount[tokenIndex].mul(_levelJudge(kolTotalAmount, params.perfermanceFee)).div(RATIO_BASE);\\n        \\n        return totalFee.mul(kolTotalAmount).div(allKolTotalAmount);\\n    }\\n\\n    modifier onlyCrpFactory() {\\n        require(address(crpFactory) == msg.sender, \\\"ERR_NOT_CRP_FACTORY\\\");\\n        _;\\n    }\\n\\n    modifier onlyVault() {\\n        require(vaultAddress == msg.sender, \\\"ERR_NOT_CONTROLLER\\\");\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/EnumerableSet.sol\": {\r\n      \"content\": \"pragma solidity 0.6.12;\\n\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping(bytes32 => uint) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) {\\n            // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint toDeleteIndex = valueIndex - 1;\\n            uint lastIndex = set._values.length - 1;\\n\\n            if (lastIndex != toDeleteIndex) {\\n                bytes32 lastvalue = set._values[lastIndex];\\n\\n                // Move the last value to the index where the value to delete is\\n                set._values[toDeleteIndex] = lastvalue;\\n                // Update the index for the moved value\\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\\n            }\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint) {\\n        return set._values.length;\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function _at(Set storage set, uint index) private view returns (bytes32) {\\n        return set._values[index];\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function _values(Set storage set) private view returns (bytes32[] memory) {\\n        return set._values;\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function addValue(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(AddressSet storage set, uint index) internal view returns (address) {\\n        return address(uint160(uint(_at(set._inner, index))));\\n    }\\n    \\n    function values(AddressSet storage set) internal view returns (address[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        address[] memory result;\\n\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n}\"\r\n    },\r\n    \"contracts/deploy/CRPFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.6.12;\\nimport {RightsManager} from \\\"../libraries/RightsManager.sol\\\";\\nimport {SmartPoolManager} from \\\"../libraries/SmartPoolManager.sol\\\";\\nimport \\\"../base/Logs.sol\\\";\\n\\n// Needed to handle structures externally\\npragma experimental ABIEncoderV2;\\n\\n// Imports\\nabstract contract IConfigurableRightsPool {\\n    struct PoolParams {\\n        string poolTokenSymbol;\\n        string poolTokenName;\\n        address[] constituentTokens;\\n        uint[] tokenBalances;\\n        uint[] tokenWeights;\\n        uint managerFee;\\n        uint redeemFee;\\n        uint issueFee;\\n        uint perfermanceFee;\\n        SmartPoolManager.Etypes etype;\\n    }\\n\\n    struct CrpParams {\\n        uint initialSupply;\\n        uint collectPeriod;\\n        SmartPoolManager.Period period;\\n    }\\n\\n    function setController(address owner) external virtual;\\n\\n    function init(\\n        address factoryAddress,\\n        IConfigurableRightsPool.PoolParams calldata poolParams,\\n        RightsManager.Rights calldata rights\\n    ) external virtual;\\n\\n    function initHandle(address[] memory owners, uint[] memory ownerPercentage) external virtual;\\n}\\n\\ninterface IUserVault {\\n    function setPoolParams(address pool, SmartPoolManager.KolPoolParams memory kolPoolParams) external;\\n}\\n\\ninterface ICRPFactory {\\n    function isCrp(address addr) external view returns (bool);\\n}\\n// Contracts\\n\\n/**\\n * @author Desyn Labs\\n * @title Configurable Rights Pool Factory - create parameterized smart pools\\n * @dev Rights are held in a corresponding struct in ConfigurableRightsPool\\n *      Index values are as follows:\\n *                            by default, it is off on initialization and can only be turned on\\n *      4: canWhitelistLPs - if set, only whitelisted addresses can join pools\\n *                           (enables private pools with more than one LP)\\n *      5: canChangeCap - can change the BSP cap (max # of pool tokens)\\n */\\ncontract CRPFactory is Logs {\\n    // State variables\\n\\n    // Keep a list of all Configurable Rights Pools\\n    mapping(address => bool) private _isCrp;\\n\\n    // Event declarations\\n\\n    // Log the address of each new smart pool, and its creator\\n    event LogNewCrp(address indexed caller, address indexed pool);\\n    event LOG_USER_VAULT(address indexed vault, address indexed caller);\\n    event LOG_MIDDLEWARE(address indexed middleware, address indexed caller);\\n\\n    event AddCRPFactory(address caller, address indexed factory);\\n    event RemoveCRPFactory(address caller, address indexed factory);\\n\\n    uint private counters;\\n\\n    bytes public bytecodes;\\n    address private _blabs = msg.sender;\\n    address public userVault;\\n\\n    address[] public CRPFactorys;\\n\\n    // constructor(bytes memory _bytecode) public {\\n    //     bytecodes = _bytecode;\\n    //     _blabs = msg.sender;\\n    // }\\n\\n    function createPool(IConfigurableRightsPool.PoolParams calldata poolParams) internal returns (address base) {\\n        bytes memory bytecode = bytecodes;\\n        bytes memory deploymentData = abi.encodePacked(bytecode, abi.encode(poolParams.poolTokenSymbol, poolParams.poolTokenName));\\n        bytes32 salt = keccak256(abi.encodePacked(counters++));\\n        assembly {\\n            base := create2(0, add(deploymentData, 32), mload(deploymentData), salt)\\n            if iszero(extcodesize(base)) {\\n                revert(0, 0)\\n            }\\n        }\\n    }\\n\\n    // Function declarations\\n    /**\\n     * @notice Create a new CRP\\n     * @dev emits a LogNewCRP event\\n     * @param factoryAddress - the BFactory instance used to create the underlying pool\\n     * @param poolParams - struct containing the names, tokens, weights, balances, and swap fee\\n     * @param rights - struct of permissions, configuring this CRP instance (see above for definitions)\\n     */\\n    function newCrp(\\n        address factoryAddress,\\n        IConfigurableRightsPool.PoolParams calldata poolParams,\\n        RightsManager.Rights calldata rights,\\n        SmartPoolManager.KolPoolParams calldata kolPoolParams,\\n        address[] memory owners,\\n        uint[] memory ownerPercentage\\n    ) external returns (IConfigurableRightsPool) {\\n        // require(poolParams.constituentTokens.length >= DesynConstants.MIN_ASSET_LIMIT, \\\"ERR_TOO_FEW_TOKENS\\\");\\n\\n        // Arrays must be parallel\\n\\n        address crp = createPool(poolParams);\\n        emit LogNewCrp(msg.sender, crp);\\n\\n        _isCrp[crp] = true;\\n        IConfigurableRightsPool(crp).init(factoryAddress, poolParams, rights);\\n        IUserVault(userVault).setPoolParams(crp, kolPoolParams);\\n        // The caller is the controller of the CRP\\n        // The CRP will be the controller of the underlying Core BPool\\n        IConfigurableRightsPool(crp).setController(msg.sender);\\n        IConfigurableRightsPool(crp).initHandle(owners, ownerPercentage);\\n\\n        return IConfigurableRightsPool(crp);\\n    }\\n\\n    modifier onlyBlabs() {\\n        require(msg.sender == _blabs, \\\"ERR_NOT_BLABS\\\");\\n        _;\\n    }\\n\\n    function setUserVault(address newVault) external onlyBlabs {\\n        userVault = newVault;\\n        emit LOG_USER_VAULT(newVault, msg.sender);\\n    }\\n\\n    function setByteCodes(bytes memory _bytecodes) external onlyBlabs _logs_ {\\n        bytecodes = _bytecodes;\\n    }\\n\\n    /**\\n     * @notice Check to see if a given address is a CRP\\n     * @param addr - address to check\\n     * @return boolean indicating whether it is a CRP\\n     */\\n    function isCrp(address addr) external view returns (bool) {\\n        if(_isCrp[addr]) return _isCrp[addr];\\n        \\n        for(uint i=0; i<CRPFactorys.length; i++){\\n            if(ICRPFactory(CRPFactorys[i]).isCrp(addr)) return true;\\n        }\\n    }\\n\\n    /**\\n     * @notice add CRPFactory\\n     * @param _crpFactory CRPFactory address\\n     * @dev add CRPFactory\\n     */\\n    function addCRPFactory(address _crpFactory) external onlyBlabs {\\n        require(_crpFactory != address(this),\\\"ERR_CAN_NOT_ADD_SELF\\\");\\n        uint len = CRPFactorys.length;\\n\\n        for(uint i=0; i<len; i++){\\n            require(CRPFactorys[i] != _crpFactory, \\\"ERR_HAS_BEEN_ADDED\\\");\\n        }\\n        CRPFactorys.push(_crpFactory);\\n        emit AddCRPFactory(msg.sender, _crpFactory);\\n    }\\n\\n    /**\\n     * @notice remove CRPFactory\\n     * @param _crpFactory CRPFactory address\\n     * @dev remove CRPFactory\\n     */\\n    function removeCRPFactory(address _crpFactory) external onlyBlabs  {\\n        uint len = CRPFactorys.length;\\n        for(uint i=0; i<len; i++){\\n            if(CRPFactorys[i] == _crpFactory){\\n                CRPFactorys[i] = CRPFactorys[len-1];\\n                CRPFactorys.pop();\\n                emit RemoveCRPFactory(msg.sender, _crpFactory);\\n                break;\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/RightsManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.6.12;\\n\\n// Needed to handle structures externally\\npragma experimental ABIEncoderV2;\\n\\n/**\\n * @author Desyn Labs\\n * @title Manage Configurable Rights for the smart pool\\n *                         by default, it is off on initialization and can only be turned on\\n *      canWhitelistLPs - can limit liquidity providers to a given set of addresses\\n *      canChangeCap - can change the BSP cap (max # of pool tokens)\\n *      canChangeFloor - can change the BSP floor for Closure ETF (min # of pool tokens)\\n */\\nlibrary RightsManager {\\n    // Type declarations\\n\\n    enum Permissions {\\n        WHITELIST_LPS,\\n        TOKEN_WHITELISTS\\n    }\\n\\n    struct Rights {\\n        bool canWhitelistLPs;\\n        bool canTokenWhiteLists;\\n    }\\n\\n    // State variables (can only be constants in a library)\\n    bool public constant DEFAULT_CAN_WHITELIST_LPS = false;\\n    bool public constant DEFAULT_CAN_TOKEN_WHITELISTS = false;\\n\\n    // bool public constant DEFAULT_CAN_CHANGE_CAP = false;\\n    // bool public constant DEFAULT_CAN_CHANGE_FLOOR = false;\\n\\n    // Functions\\n\\n    /**\\n     * @notice create a struct from an array (or return defaults)\\n     * @dev If you pass an empty array, it will construct it using the defaults\\n     * @param a - array input\\n     * @return Rights struct\\n     */\\n    function constructRights(bool[] calldata a) external pure returns (Rights memory) {\\n        if (a.length < 2) {\\n            return\\n                Rights(\\n                    DEFAULT_CAN_WHITELIST_LPS,\\n                    DEFAULT_CAN_TOKEN_WHITELISTS\\n                );\\n        } else {\\n            // return Rights(a[0], a[1], a[2], a[3], a[4], a[5], a[6]);\\n            return Rights(a[0], a[1]);\\n        }\\n    }\\n\\n    /**\\n     * @notice Convert rights struct to an array (e.g., for events, GUI)\\n     * @dev avoids multiple calls to hasPermission\\n     * @param rights - the rights struct to convert\\n     * @return boolean array containing the rights settings\\n     */\\n    function convertRights(Rights calldata rights) external pure returns (bool[] memory) {\\n        bool[] memory result = new bool[](2);\\n\\n        result[0] = rights.canWhitelistLPs;\\n        result[1] = rights.canTokenWhiteLists;\\n\\n        return result;\\n    }\\n\\n    // Though it is actually simple, the number of branches triggers code-complexity\\n    /* solhint-disable code-complexity */\\n\\n    /**\\n     * @notice Externally check permissions using the Enum\\n     * @param self - Rights struct containing the permissions\\n     * @param permission - The permission to check\\n     * @return Boolean true if it has the permission\\n     */\\n    function hasPermission(Rights calldata self, Permissions permission) external pure returns (bool) {\\n        if (Permissions.WHITELIST_LPS == permission) {\\n            return self.canWhitelistLPs;\\n        } else if (Permissions.TOKEN_WHITELISTS == permission) {\\n            return self.canTokenWhiteLists;\\n        }\\n    }\\n\\n    /* solhint-enable code-complexity */\\n}\\n\"\r\n    },\r\n    \"contracts/deploy/Actions.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.6.12;\\n\\npragma experimental ABIEncoderV2;\\nimport {RightsManager} from \\\"../libraries/RightsManager.sol\\\";\\nimport {SmartPoolManager} from \\\"../libraries/SmartPoolManager.sol\\\";\\nimport {DesynSafeMath} from \\\"../libraries/DesynSafeMath.sol\\\";\\n\\nimport \\\"../libraries/SafeERC20.sol\\\";\\nimport \\\"../interfaces/IWETH.sol\\\";\\nimport \\\"../utils/DesynReentrancyGuard.sol\\\";\\n\\nabstract contract IAggregator {\\n    enum SwapType {\\n        UNISWAPV2,\\n        UNISWAPV3,\\n        ONEINCH,\\n        CURVE\\n    }\\n\\n    struct SwapInfoBase {\\n        address aggregator; // the swap router to use\\n        address rebalanceAdapter;\\n        SwapType swapType;\\n    }\\n\\n    struct SwapData {\\n        uint256 quantity;\\n        bytes data; // v3: (uint,uint256[]) v2: (uint256,address[])\\n    }\\n\\n    function swapExactTokensForTokens(uint256, uint256, address[] calldata, address, uint256) external virtual;\\n\\n    function uniswapV3Swap(uint256, uint256, uint256[] calldata) external virtual;\\n}\\n\\nabstract contract DesynOwnable {\\n    function setController(address controller) external virtual;\\n    function setManagersInfo(address[] memory _owners, uint[] memory _ownerPercentage) external virtual;\\n}\\n\\nabstract contract AbstractPool is IERC20, DesynOwnable {\\n    function setPublicSwap(bool public_) external virtual;\\n\\n    function joinPool(\\n        uint poolAmountOut,\\n        uint[] calldata maxAmountsIn,\\n        address kol,\\n        address user\\n    ) external virtual;\\n\\n    function exitPool(uint poolAmountIn, uint[] calldata minAmountsOut, address user) external virtual;\\n}\\n\\nabstract contract LiquidityPoolActions is AbstractPool {\\n    function finalize() external virtual;\\n\\n    function bind(\\n        address token,\\n        uint balance,\\n        uint denorm\\n    ) external virtual;\\n\\n    function rebind(\\n        address token,\\n        uint balance,\\n        uint denorm\\n    ) external virtual;\\n\\n    function unbind(address token) external virtual;\\n\\n    function isBound(address t) external view virtual returns (bool);\\n\\n    function getCurrentTokens() external view virtual returns (address[] memory);\\n\\n    function getFinalTokens() external view virtual returns (address[] memory);\\n\\n    function getBalance(address token) external view virtual returns (uint);\\n}\\n\\nabstract contract FactoryActions {\\n    function newLiquidityPool() external virtual returns (LiquidityPoolActions);\\n    function getModuleStatus(address etf, address module) external view virtual returns (bool);\\n    function isTokenWhitelistedForVerify(address token) external view virtual returns (bool);\\n}\\n\\nabstract contract RebalaceAdapter {\\n    enum SwapType {\\n        UNISWAPV2,\\n        UNISWAPV3,\\n        ONEINCH\\n    }\\n\\n    struct RebalanceInfo {\\n        address etf; // etf address\\n        address token0;\\n        address token1;\\n        address aggregator; // the swap router to use\\n        SwapType swapType;\\n        uint256 quantity;\\n        bytes data; // v3: (uint,uint256[]) v2: (uint256,address[])\\n    }\\n    function rebalance(RebalanceInfo calldata rebalanceInfo) external virtual;\\n    function approve(address etf, address token, address spender, uint256 amount) external virtual;\\n    function isRouterApproved(address router) external virtual returns (bool);\\n}\\n\\nabstract contract IConfigurableRightsPool is AbstractPool {\\n    struct PoolParams {\\n        string poolTokenSymbol;\\n        string poolTokenName;\\n        address[] constituentTokens;\\n        uint[] tokenBalances;\\n        uint[] tokenWeights;\\n        uint managerFee;\\n        uint redeemFee;\\n        uint issueFee;\\n        uint perfermanceFee;\\n        SmartPoolManager.Etypes etype;\\n    }\\n\\n    struct CrpParams {\\n        uint initialSupply;\\n        uint collectPeriod;\\n        SmartPoolManager.Period period;\\n    }\\n\\n    function createPool(\\n        address creator,\\n        uint initialSupply,\\n        uint collectPeriod,\\n        SmartPoolManager.Period period,\\n        SmartPoolManager.PoolTokenRange memory tokenRange\\n    ) external virtual;\\n\\n    function createPool(uint initialSupply) external virtual;\\n\\n    function setCap(uint newCap) external virtual;\\n\\n    function commitAddToken(\\n        address token,\\n        uint balance,\\n        uint denormalizedWeight\\n    ) external virtual;\\n\\n    function applyAddToken() external virtual;\\n\\n    function whitelistLiquidityProvider(address provider) external virtual;\\n\\n    function removeWhitelistedLiquidityProvider(address provider) external virtual;\\n\\n    function bPool() external view virtual returns (LiquidityPoolActions);\\n\\n    function addTokenToWhitelist(uint[] memory sort, address[] memory token) external virtual;\\n    function claimManagerFee() external virtual;\\n\\n    function etype() external virtual returns(SmartPoolManager.Etypes);\\n\\n    function vaultAddress() external virtual view returns(address);\\n\\n    function snapshotBeginAssets() external virtual;\\n\\n    function snapshotEndAssets() external virtual;\\n\\n    function etfStatus() external virtual returns(SmartPoolManager.Status memory);\\n}\\n\\nabstract contract ICRPFactory {\\n    function newCrp(\\n        address factoryAddress,\\n        IConfigurableRightsPool.PoolParams calldata params,\\n        RightsManager.Rights calldata rights,\\n        SmartPoolManager.KolPoolParams calldata kolPoolParams,\\n        address[] memory owners,\\n        uint[] memory ownerPercentage\\n    ) external virtual returns (IConfigurableRightsPool);\\n}\\n\\nabstract contract IVault {\\n    function userVault() external virtual returns(address);\\n}\\n\\nabstract contract IUserVault {\\n    function kolClaim(address pool) external virtual;\\n\\n    function managerClaim(address pool) external virtual;\\n\\n    function getManagerClaimBool(address pool) external view virtual returns(bool);\\n}\\n\\ninterface ICurve {\\n    function exchange_underlying(int128 i, int128 j, uint256 dx, uint256 min_dy) external;\\n\\n    function coins(uint i) external view returns(address);    \\n}\\n\\n/********************************** WARNING **********************************/\\n//                                                                           //\\n// This contract is only meant to be used in conjunction with ds-proxy.      //\\n// Calling this contract directly will lead to loss of funds.                //\\n//                                                                           //\\n/********************************** WARNING **********************************/\\n\\ncontract Actions is DesynReentrancyGuard {\\n    using SafeERC20 for IERC20;\\n    using DesynSafeMath for uint256;\\n    \\n    IERC20 public constant STBT = IERC20(0x530824DA86689C9C17CdC2871Ff29B058345b44a);\\n    address public constant FACTORY = 0x01a38B39BEddCD6bFEedBA14057E053cBF529cD2;\\n    address constant NATIVE_TOKEN = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n    address constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\n\\n    event SmartJoinPool(address caller, address token, uint amount, address shareReturn, uint amountReturn);\\n    event SmartExitPool(address caller, address share, uint shareAmount, address tokenReturn, uint amountReturn);\\n    \\n    // --- Pool Creation ---\\n\\n    function create(\\n        FactoryActions factory,\\n        address[] calldata tokens,\\n        uint[] calldata balances,\\n        uint[] calldata weights,\\n        bool finalize\\n    ) external returns (LiquidityPoolActions pool) {\\n        require(tokens.length == balances.length, \\\"ERR_LENGTH_MISMATCH\\\");\\n        require(tokens.length == weights.length, \\\"ERR_LENGTH_MISMATCH\\\");\\n\\n        pool = factory.newLiquidityPool();\\n\\n        for (uint i = 0; i < tokens.length; i++) {\\n            IERC20 token = IERC20(tokens[i]);\\n            token.safeTransferFrom(msg.sender, address(this), balances[i]);\\n            token.safeApprove(address(pool), 0);\\n            token.safeApprove(address(pool), balances[i]);\\n\\n            pool.bind(tokens[i], balances[i], weights[i]);\\n        }\\n\\n        if (finalize) {\\n            pool.finalize();\\n            require(pool.transfer(msg.sender, pool.balanceOf(address(this))), \\\"ERR_TRANSFER_FAILED\\\");\\n        } else {\\n            pool.setPublicSwap(true);\\n        }\\n    }\\n\\n    function createSmartPool(\\n        ICRPFactory factory,\\n        FactoryActions coreFactory,\\n        IConfigurableRightsPool.PoolParams calldata poolParams,\\n        IConfigurableRightsPool.CrpParams calldata crpParams,\\n        RightsManager.Rights calldata rights,\\n        SmartPoolManager.KolPoolParams calldata kolPoolParams,\\n        address[] memory owners,\\n        uint[] memory ownerPercentage,\\n        SmartPoolManager.PoolTokenRange memory tokenRange\\n    ) external returns (IConfigurableRightsPool crp) {\\n        require(poolParams.constituentTokens.length == poolParams.tokenBalances.length, \\\"ERR_LENGTH_MISMATCH\\\");\\n        require(poolParams.constituentTokens.length == poolParams.tokenWeights.length, \\\"ERR_LENGTH_MISMATCH\\\");\\n\\n        crp = factory.newCrp(address(coreFactory), poolParams, rights, kolPoolParams, owners, ownerPercentage);\\n\\n        for (uint i = 0; i < poolParams.constituentTokens.length; i++) {\\n            IERC20 token = IERC20(poolParams.constituentTokens[i]);\\n            token.safeTransferFrom(msg.sender, address(this), poolParams.tokenBalances[i]);\\n            token.safeApprove(address(crp), 0);\\n            token.safeApprove(address(crp), poolParams.tokenBalances[i]);\\n        }\\n\\n        crp.createPool(msg.sender,crpParams.initialSupply, crpParams.collectPeriod, crpParams.period, tokenRange);\\n        require(crp.transfer(msg.sender, crpParams.initialSupply), \\\"ERR_TRANSFER_FAILED\\\");\\n        crp.setController(msg.sender);\\n        // DSProxy instance keeps pool ownership to enable management\\n    }\\n\\n    // --- Joins ---\\n\\n    function joinPool(\\n        LiquidityPoolActions pool,\\n        uint poolAmountOut,   \\n        uint[] calldata maxAmountsIn\\n    ) external {\\n        address[] memory tokens = pool.getFinalTokens();\\n        _join(pool, tokens, poolAmountOut, maxAmountsIn, msg.sender);\\n    }\\n\\n    function autoExitSmartPool(\\n        IConfigurableRightsPool pool,\\n        uint poolAmountIn,\\n        uint[] memory minAmountsOut,\\n        uint minSwapReturn,\\n        address handleToken,\\n        IAggregator.SwapInfoBase calldata swapBase,\\n        IAggregator.SwapData[] memory swapDatas) external payable lock {\\n        address[] memory tokens = pool.bPool().getCurrentTokens();\\n        uint len = swapDatas.length;\\n        require(FactoryActions(FACTORY).isTokenWhitelistedForVerify(handleToken),\\\"ERR_TOKEN_NOT_WHITELISTED\\\");\\n        require(tokens.length == swapDatas.length,\\\"ERR_TOKENLENGTH_MISMATCH\\\");\\n        require(tokens.length == minAmountsOut.length,\\\"ERR_TOKENLENGTH_MISMATCH\\\");\\n\\n        IERC20 receiveToken = IERC20(handleToken);\\n        if (handleToken == NATIVE_TOKEN) {\\n            receiveToken = IERC20(WETH);\\n        }\\n        uint preReceiveAmount = receiveToken.balanceOf(address(this));\\n        uint[] memory initialAmounts = new uint[](len);\\n        for(uint i = 0; i < len; i++){\\n            initialAmounts[i] = IERC20(tokens[i]).balanceOf(address(this));\\n        }\\n\\n        _exit(pool, poolAmountIn, minAmountsOut, tokens, true);\\n\\n        for(uint j = 0; j < len; j++) {\\n            IAggregator.SwapData memory swapData = swapDatas[j];\\n            IERC20 swapToken = IERC20(tokens[j]);\\n            if(tokens[j] != address(receiveToken)){\\n                swapData.quantity = SafeMath.sub(swapToken.balanceOf(address(this)), initialAmounts[j]);\\n                swapToken.safeApprove(swapBase.aggregator, 0);\\n                swapToken.safeApprove(swapBase.aggregator, swapData.quantity);\\n                _makeSwap(swapBase, swapData, receiveToken);\\n            }\\n        }\\n        uint receiveAmount = SafeMath.sub(receiveToken.balanceOf(address(this)), preReceiveAmount);\\n        require(minSwapReturn <= receiveAmount,\\\"ERR_RECEIVE_AMOUNT_TO_SMALL\\\");\\n        if (handleToken == NATIVE_TOKEN) {\\n            IWETH(WETH).withdraw(receiveAmount);\\n            msg.sender.transfer(receiveAmount);\\n        } else {\\n            receiveToken.safeTransfer(msg.sender, receiveAmount);\\n        }\\n\\n        emit SmartExitPool(msg.sender, address(pool) ,poolAmountIn, handleToken, receiveAmount);\\n    }\\n\\n    function joinSmartPool(\\n        IConfigurableRightsPool pool,\\n        uint poolAmountOut,\\n        uint[] calldata maxAmountsIn,\\n        address kol\\n    ) external {\\n        address[] memory tokens = pool.bPool().getCurrentTokens();\\n        _join(pool, tokens, poolAmountOut, maxAmountsIn, kol);\\n    }\\n\\n    struct JoinVar {\\n        uint actualShareAmountOut;\\n        uint issueFee;\\n        uint totalPoolShares;\\n        LiquidityPoolActions bPool;\\n    }\\n\\n    function autoJoinSmartPool(\\n        IConfigurableRightsPool pool,\\n        address kol,\\n        uint issueAmount,\\n        uint minPoolAmountOut,\\n        address handleToken,\\n        IAggregator.SwapInfoBase calldata swapBase,\\n        IAggregator.SwapData[] memory swapDatas\\n    ) external payable lock {\\n        require(FactoryActions(FACTORY).isTokenWhitelistedForVerify(handleToken), \\\"ERR_TOKEN_NOT_WHITELISTED\\\");\\n        address[] memory poolTokens = pool.bPool().getCurrentTokens();\\n        require(poolTokens.length == swapDatas.length,\\\"ERR_TOKENLENGTH_MISMATCH\\\");\\n        uint[] memory maxAmountsIn = new uint[](poolTokens.length);\\n        address user = msg.sender;\\n\\n        // Transfer ETH into the contract and authorize the aggregator to operate\\n        IERC20 issueToken;\\n        if (handleToken == NATIVE_TOKEN) {\\n            require(msg.value > 0 && msg.value == issueAmount, 'ERROR_ETH');\\n            IWETH(WETH).deposit{value: msg.value}();\\n\\n            issueToken = IERC20(WETH);\\n        } else {\\n            issueToken = IERC20(handleToken);\\n            issueToken.safeTransferFrom(user, address(this), issueAmount);\\n        }\\n   \\n        issueToken.safeApprove(swapBase.aggregator, 0);\\n        issueToken.safeApprove(swapBase.aggregator, issueAmount);\\n\\n        JoinVar memory joinVar = JoinVar({\\n            actualShareAmountOut: type(uint).max,\\n            issueFee:pool.etfStatus().issueFee,\\n            totalPoolShares:pool.totalSupply(),\\n            bPool:pool.bPool()\\n        });\\n\\n        // Perform a swap and authorize the pool call\\n        for (uint i; i < poolTokens.length; i++) {\\n            IAggregator.SwapData memory swapData = swapDatas[i];\\n        \\n            poolTokens[i] == address(issueToken)\\n                ? maxAmountsIn[i] = swapData.quantity\\n                : maxAmountsIn[i] = _makeSwap(swapBase, swapData, IERC20(poolTokens[i]));\\n\\n            uint shareAmountOutPerToken = _calculateShare(joinVar.bPool,joinVar.totalPoolShares,joinVar.issueFee, poolTokens[i], maxAmountsIn[i]);\\n            if(shareAmountOutPerToken < joinVar.actualShareAmountOut) joinVar.actualShareAmountOut = shareAmountOutPerToken;\\n        \\n            IERC20(poolTokens[i]).safeApprove(address(pool), 0);\\n            IERC20(poolTokens[i]).safeApprove(address(pool), maxAmountsIn[i]);\\n        }\\n\\n        // Adding Tokens to a Pool\\n        require(minPoolAmountOut <= joinVar.actualShareAmountOut,\\\"ERR_SHARE_AMOUNT_TO_SMALL\\\");\\n        pool.joinPool(joinVar.actualShareAmountOut, maxAmountsIn, kol, user); \\n\\n        // Return excess funds to users\\n        for (uint i; i < poolTokens.length; i++) {\\n            IERC20 token = IERC20(poolTokens[i]);\\n            if (token.balanceOf(address(this)) > 0 && token != STBT) token.safeTransfer(user, token.balanceOf(address(this)));\\n        }\\n\\n        issueToken.safeTransfer(user, issueToken.balanceOf(address(this)));\\n        require(pool.transfer(user, pool.balanceOf(address(this))), \\\"ERR_TRANSFER_FAILED\\\");\\n        \\n        emit SmartJoinPool(msg.sender, handleToken, issueAmount, address(pool), joinVar.actualShareAmountOut);    \\n    }\\n\\n    function exitPool(\\n        IConfigurableRightsPool pool,\\n        uint poolAmountIn,\\n        uint[] memory minAmountsOut\\n    ) external {\\n        address[] memory tokens = pool.bPool().getCurrentTokens();\\n        _exit(pool, poolAmountIn, minAmountsOut, tokens, false);\\n    }\\n\\n    // --- Pool management (common) ---\\n    function setPublicSwap(AbstractPool pool, bool publicSwap) external {\\n        pool.setPublicSwap(publicSwap);\\n    }\\n\\n    function setController(AbstractPool pool, address newController) external {\\n        _beforeOwnerChange(address(pool));\\n        pool.setController(newController);\\n    }\\n\\n    function setManagersInfo(AbstractPool pool ,address[] memory _owners, uint[] memory _ownerPercentage) public {\\n        _beforeOwnerChange(address(pool));\\n        pool.setManagersInfo(_owners, _ownerPercentage);\\n    }\\n\\n    function _beforeOwnerChange(address pool) internal {\\n        claimManagementFee(IConfigurableRightsPool(pool));\\n        _claimManagersReward(pool);\\n    }\\n\\n    function snapshotBeginAssets(IConfigurableRightsPool pool) external virtual {\\n        pool.snapshotBeginAssets();\\n    }\\n\\n    function snapshotEndAssets(IConfigurableRightsPool pool) external virtual {\\n        pool.snapshotEndAssets();\\n    }\\n\\n    function approveUnderlying(RebalaceAdapter rebalanceAdapter, address etf, address token, address spender, uint amount) external {\\n        rebalanceAdapter.approve(etf, token, spender, amount);\\n    }\\n\\n    function rebalance(RebalaceAdapter rebalanceAdapter, RebalaceAdapter.RebalanceInfo calldata rebalanceInfo) external {\\n        rebalanceAdapter.rebalance(rebalanceInfo);\\n    }\\n\\n    // --- Private pool management ---\\n\\n    function finalize(LiquidityPoolActions pool) external {\\n        pool.finalize();\\n        require(pool.transfer(msg.sender, pool.balanceOf(address(this))), \\\"ERR_TRANSFER_FAILED\\\");\\n    }\\n\\n    // --- Smart pool management ---\\n    function setCap(IConfigurableRightsPool crp, uint newCap) external {\\n        crp.setCap(newCap);\\n    }\\n\\n    function whitelistLiquidityProvider(IConfigurableRightsPool crp, address provider) external {\\n        crp.whitelistLiquidityProvider(provider);\\n    }\\n\\n    function removeWhitelistedLiquidityProvider(IConfigurableRightsPool crp, address provider) external {\\n        crp.removeWhitelistedLiquidityProvider(provider);\\n    }\\n\\n    function addTokenToWhitelist(IConfigurableRightsPool crp, uint[] memory sort, address[] memory token) public {\\n        crp.addTokenToWhitelist(sort, token);\\n    }\\n\\n    function claimManagementFee(IConfigurableRightsPool crp) public {\\n         crp.claimManagerFee();\\n    }\\n    // --- Internals ---\\n\\n    function _safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint amount\\n    ) internal {\\n        if (token.allowance(address(this), spender) > 0) {\\n            token.approve(spender, 0);\\n        }\\n        token.approve(spender, amount);\\n    }\\n\\n    function _join(\\n        AbstractPool pool,\\n        address[] memory tokens,\\n        uint poolAmountOut,\\n        uint[] memory maxAmountsIn,\\n        address kol\\n    ) internal {\\n        require(maxAmountsIn.length == tokens.length, \\\"ERR_LENGTH_MISMATCH\\\");\\n\\n        for (uint i = 0; i < tokens.length; i++) {\\n            IERC20 token = IERC20(tokens[i]);\\n            token.safeTransferFrom(msg.sender, address(this), maxAmountsIn[i]);\\n\\n            token.safeApprove(address(pool), 0);\\n            token.safeApprove(address(pool), maxAmountsIn[i]);\\n        }\\n\\n        pool.joinPool(poolAmountOut, maxAmountsIn, kol, msg.sender);\\n\\n        for (uint i = 0; i < tokens.length; i++) {\\n            IERC20 token = IERC20(tokens[i]);\\n            if (token.balanceOf(address(this)) > 0) {\\n                token.safeTransfer(msg.sender, token.balanceOf(address(this)));\\n            }\\n        }\\n        require(pool.transfer(msg.sender, pool.balanceOf(address(this))), \\\"ERR_TRANSFER_FAILED\\\");\\n    }\\n\\n    function _exit(\\n        IConfigurableRightsPool pool,\\n        uint poolAmountIn,\\n        uint[] memory minAmountsOut,\\n        address[] memory tokens,\\n        bool isSmartMode\\n    ) internal {\\n        uint shareToBurn = poolAmountIn;\\n\\n        if (pool.etype() == SmartPoolManager.Etypes.CLOSED) {\\n            shareToBurn = pool.balanceOf(msg.sender);\\n        }\\n\\n        require(pool.transferFrom(msg.sender, address(this), shareToBurn), \\\"ERR_TRANSFER_FAILED\\\");\\n        // _safeApprove(pool, address(pool), shareToBurn);\\n        pool.exitPool(shareToBurn, minAmountsOut, msg.sender);\\n        if(!isSmartMode){\\n            for (uint i = 0; i < tokens.length; i++) {\\n                IERC20 token = IERC20(tokens[i]);\\n                if (token.balanceOf(address(this)) > 0) {\\n                    token.safeTransfer(msg.sender, token.balanceOf(address(this)));\\n                }\\n            }\\n        }\\n    }\\n\\n    function claimKolReward(address pool) public {\\n        address uservault = _getUserVault(pool);\\n        IUserVault(uservault).kolClaim(pool);\\n    }\\n\\n    function claimManagersReward(address vault_,address pool) external {\\n        IUserVault(vault_).managerClaim(pool);\\n    }\\n\\n    function _claimManagersReward(address pool) internal {\\n        address vault = _getVault(pool);\\n        address uservault = _getUserVault(pool);\\n\\n        bool vaultCanClaim = IUserVault(vault).getManagerClaimBool(pool);\\n        bool uservaultCanClaim = IUserVault(uservault).getManagerClaimBool(pool);\\n        SmartPoolManager.Etypes type_ = IConfigurableRightsPool(pool).etype();\\n\\n        if(type_ == SmartPoolManager.Etypes.OPENED && vaultCanClaim) IUserVault(vault).managerClaim(pool);\\n        if(type_ == SmartPoolManager.Etypes.CLOSED && uservaultCanClaim) IUserVault(uservault).managerClaim(pool);\\n    }\\n    \\n    function _makeSwap(IAggregator.SwapInfoBase calldata swapBase, IAggregator.SwapData memory swapData, IERC20 swapAcceptToken) internal returns (uint256 postSwap) {\\n        require(FactoryActions(FACTORY).getModuleStatus(address(0), swapBase.rebalanceAdapter), 'MODULE_ILLEGAL');\\n        require(RebalaceAdapter(swapBase.rebalanceAdapter).isRouterApproved(swapBase.aggregator), 'ROUTER_ILLEGAL');\\n\\n        uint preSwap = swapAcceptToken.balanceOf(address(this));\\n\\n        if (swapBase.swapType == IAggregator.SwapType.UNISWAPV3) {\\n            (uint256 minReturn, uint256[] memory pools) = abi.decode(swapData.data, (uint256, uint256[]));\\n            IAggregator(swapBase.aggregator).uniswapV3Swap(swapData.quantity, minReturn, pools);\\n        } else if (swapBase.swapType == IAggregator.SwapType.UNISWAPV2) {\\n            (uint256 minReturn, address[] memory paths) = abi.decode(swapData.data, (uint256, address[]));\\n            IAggregator(swapBase.aggregator).swapExactTokensForTokens(swapData.quantity, minReturn, paths, address(this), SafeMath.add(block.timestamp, 1800));\\n        } else if (swapBase.swapType == IAggregator.SwapType.ONEINCH){\\n            Address.functionCallWithValue(swapBase.aggregator, swapData.data, 0);\\n            // _validateData(swapBase.quantity, swapBase.data, address(this));\\n        } else if (swapBase.swapType == IAggregator.SwapType.CURVE){\\n            // only supports stbt/usdc/usdt/dai curve pool\\n            (int128 i, int128 j, uint256 dx, uint256 minDy) = abi.decode(swapData.data, (int128, int128, uint256, uint256));\\n            ICurve(swapBase.aggregator).exchange_underlying(i, j, dx, minDy);\\n        } else {\\n            revert(\\\"ERR_INVALID_SWAP_TYPE\\\");\\n        }\\n        \\n        postSwap = SafeMath.sub(swapAcceptToken.balanceOf(address(this)), preSwap);\\n    }\\n\\n    function _getVault(address pool) internal view  returns(address){\\n        return IConfigurableRightsPool(pool).vaultAddress();\\n    }\\n    function _getUserVault(address pool) internal  returns(address){\\n        address vault = _getVault(pool);\\n        return IVault(vault).userVault();\\n    }\\n\\n    function _calculateShare(LiquidityPoolActions bPool,uint totalPoolShares, uint issueFee, address t, uint actualTokenAmountIn) internal view returns(uint) {\\n        uint totalTokenBalance = bPool.getBalance(t);\\n        uint issueFeeRate = issueFee.bmul(1000);\\n        uint share = (totalPoolShares.bsub(1).bmul(actualTokenAmountIn) * (uint(1000).bsub(issueFeeRate))).bdiv((1000 * totalTokenBalance.badd(1)));\\n        return share;\\n    }\\n\\n    receive() external payable {}\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IWETH.sol\": {\r\n      \"content\": \"pragma solidity 0.6.12;\\n\\ninterface IWETH {\\n    function balanceOf(address account) external view returns (uint);\\n\\n    function deposit() external payable;\\n\\n    function withdraw(uint) external;\\n\\n    function approve(address guy, uint wad) external returns (bool);\\n\\n    function transferFrom(\\n        address src,\\n        address dst,\\n        uint wad\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/utils/DesynReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.6.12;\\n\\n/**\\n * @author Desyn Labs (and OpenZeppelin)\\n * @title Protect against reentrant calls (and also selectively protect view functions)\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {_lock_} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `_lock_` guard, functions marked as\\n * `_lock_` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `_lock_` entry\\n * points to them.\\n *\\n * Also adds a _lockview_ modifier, which doesn't create a lock, but fails\\n *   if another _lock_ call is in progress\\n */\\ncontract DesynReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint private constant _NOT_ENTERED = 1;\\n    uint private constant _ENTERED = 2;\\n\\n    uint private _status;\\n\\n    constructor() internal {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `_lock_` function from another `_lock_`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `_lock_` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier lock() {\\n        // On the first call to _lock_, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ERR_REENTRY\\\");\\n\\n        // Any calls to _lock_ after this point will fail\\n        _status = _ENTERED;\\n        _;\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Also add a modifier that doesn't create a lock, but protects functions that\\n     *      should not be called while a _lock_ function is running\\n     */\\n    modifier viewlock() {\\n        require(_status != _ENTERED, \\\"ERR_REENTRY_VIEW\\\");\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/base/ConfigurableRightsPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.6.12;\\n// Needed to handle structures externally\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./PCToken.sol\\\";\\nimport \\\"../utils/DesynReentrancyGuard.sol\\\";\\nimport \\\"../utils/DesynOwnable.sol\\\";\\nimport \\\"../interfaces/IBFactory.sol\\\";\\nimport {RightsManager} from \\\"../libraries/RightsManager.sol\\\";\\nimport \\\"../libraries/SmartPoolManager.sol\\\";\\nimport \\\"../libraries/SafeApprove.sol\\\";\\nimport \\\"./WhiteToken.sol\\\";\\nimport \\\"../libraries/SafeERC20.sol\\\";\\nimport '../libraries/Address.sol';\\n\\n/**\\n * @author Desyn Labs\\n * @title Smart Pool with customizable features\\n * @notice PCToken is the \\\"Desyn Smart Pool\\\" token (transferred upon finalization)\\n * @dev Rights are defined as follows (index values into the array)\\n * Note that functions called on bPool and bFactory may look like internal calls,\\n *   but since they are contracts accessed through an interface, they are really external.\\n * To make this explicit, we could write \\\"IBPool(address(bPool)).function()\\\" everywhere,\\n *   instead of \\\"bPool.function()\\\".\\n */\\ncontract ConfigurableRightsPool is PCToken, DesynOwnable, DesynReentrancyGuard, WhiteToken {\\n    using DesynSafeMath for uint;\\n    using SafeERC20 for IERC20;\\n    using Address for address;\\n\\n    // State variables\\n    IBFactory public bFactory;\\n    IBPool public bPool;\\n\\n    // Struct holding the rights configuration\\n    RightsManager.Rights public rights;\\n\\n    SmartPoolManager.Status public etfStatus;\\n    SmartPoolManager.Fund beginFund;\\n    SmartPoolManager.Fund endFund;\\n\\n    // Store the list of tokens in the pool, and balances\\n    // NOTE that the token list is *only* used to store the pool tokens between\\n    //   construction and createPool - thereafter, use the underlying BPool's list\\n    //   (avoids synchronization issues)\\n    address[] private _initialTokens;\\n    uint[] private _initialBalances;\\n    uint[] private _initialWeights;\\n\\n    // Whitelist of LPs (if configured)\\n    mapping(address => bool) private _liquidityProviderWhitelist;\\n\\n    uint public constant CLAIM_PERIOD = 30 days;\\n    address public vaultAddress;\\n\\n    bool hasSetWhiteTokens;\\n    bool initBool;\\n    bool public isCompletedCollect;\\n    bool public hasSetBeginFund;\\n    bool public hasSetEndFund;\\n    bool public hasClaimManageFee;\\n\\n    SmartPoolManager.Etypes public etype;\\n\\n    // Event declarations\\n    // Anonymous logger event - can only be filtered by contract address\\n    event LogCall(bytes4 indexed sig, address indexed caller, bytes data) anonymous;\\n    event LogJoin(address indexed caller, address indexed tokenIn, uint tokenAmountIn);\\n    event LogExit(address indexed caller, address indexed tokenOut, uint tokenAmountOut);\\n    event SizeChanged(address indexed caller, string indexed sizeType, uint oldSize, uint newSize);\\n    event PoolTokenInit(address indexed caller, address pool, address initToken, uint initTokenTotal, uint initShare);\\n    event SetManagerFee(uint indexed managerFee, uint indexed issueFee, uint indexed redeemFee, uint perfermanceFee);\\n\\n    // Modifiers\\n    modifier logs() {\\n        emit LogCall(msg.sig, msg.sender, msg.data);\\n        _;\\n    }\\n\\n    // Mark functions that require delegation to the underlying Pool\\n    modifier needsBPool() {\\n        require(address(bPool) != address(0), \\\"ERR_NOT_CREATED\\\");\\n        _;\\n    }\\n\\n    modifier notPaused() {\\n        require(!bFactory.isPaused(), \\\"!paused\\\");\\n        _;\\n    }\\n \\n    constructor(string memory tokenSymbol, string memory tokenName) public PCToken(tokenSymbol, tokenName) {}\\n\\n    /**\\n     * @notice Construct a new Configurable Rights Pool (wrapper around BPool)\\n     * @dev _initialTokens are only used for temporary storage between construction\\n     *      and create pool, and should not be used thereafter! _initialTokens is destroyed in\\n     *      createPool to prevent this is kept in sync (defensively), but\\n     *      should never be used except in this constructor and createPool()\\n     * @param factoryAddress - the BPoolFactory used to create the underlying pool\\n     * @param poolParams - struct containing pool parameters\\n     * @param rightsStruct - Set of permissions we are assigning to this smart pool\\n     */\\n\\n    function init(\\n        address factoryAddress,\\n        SmartPoolManager.PoolParams memory poolParams,\\n        RightsManager.Rights memory rightsStruct\\n    ) public {\\n        SmartPoolManager.initRequire(\\n            poolParams.managerFee,\\n            poolParams.issueFee,\\n            poolParams.redeemFee,\\n            poolParams.perfermanceFee,\\n            poolParams.tokenBalances.length,\\n            poolParams.tokenWeights.length,\\n            poolParams.constituentTokens.length,\\n            initBool\\n        );\\n        initBool = true;\\n        rights = rightsStruct;\\n        _initialTokens = poolParams.constituentTokens;\\n        _initialBalances = poolParams.tokenBalances;\\n        _initialWeights = poolParams.tokenWeights;\\n\\n        etfStatus = SmartPoolManager.Status({\\n            collectPeriod: 0,\\n            collectEndTime: 0,\\n            closurePeriod: 0,\\n            closureEndTime: 0,\\n            upperCap: DesynConstants.MAX_UINT,\\n            floorCap: 0,\\n            managerFee: poolParams.managerFee,\\n            redeemFee: poolParams.redeemFee,\\n            issueFee: poolParams.issueFee,\\n            perfermanceFee: poolParams.perfermanceFee,\\n            startClaimFeeTime: block.timestamp\\n        });\\n\\n        etype = poolParams.etype;\\n\\n        bFactory = IBFactory(factoryAddress);\\n        vaultAddress = bFactory.getVault();\\n        emit SetManagerFee(etfStatus.managerFee, etfStatus.issueFee, etfStatus.redeemFee, etfStatus.perfermanceFee);\\n    }\\n\\n    /**\\n     * @notice Set the cap (max # of pool tokens)\\n     * @dev _bspCap defaults in the constructor to unlimited\\n     *      Can set to 0 (or anywhere below the current supply), to halt new investment\\n     *      Prevent setting it before creating a pool, since createPool sets to intialSupply\\n     *      (it does this to avoid an unlimited cap window between construction and createPool)\\n     *      Therefore setting it before then has no effect, so should not be allowed\\n     * @param newCap - new value of the cap\\n     */\\n    function setCap(uint newCap) external logs lock needsBPool onlyOwner {\\n        require(etype == SmartPoolManager.Etypes.OPENED, \\\"ERR_MUST_OPEN_ETF\\\");\\n        emit SizeChanged(msg.sender, \\\"UPPER\\\", etfStatus.upperCap, newCap);\\n        etfStatus.upperCap = newCap;\\n    }\\n\\n    function execute(\\n        address _target,\\n        uint _value,\\n        bytes calldata _data,\\n        bool isUnderlying\\n    ) external logs lock needsBPool returns (bytes memory _returnValue) {\\n        require(bFactory.getModuleStatus(address(this), msg.sender), 'MODULE IS NOT REGISTER');\\n        if (isUnderlying) {\\n        _returnValue = bPool.execute(_target, _value, _data);\\n        } else {\\n        _returnValue = _target.functionCallWithValue(_data, _value);\\n        }\\n    }\\n\\n    function couldClaimManagerFee() public view returns(bool state,uint timePoint ,uint timeElapsed){\\n        bool isCloseETF = etype == SmartPoolManager.Etypes.CLOSED;\\n        timePoint = block.timestamp;\\n        if(isCloseETF && timePoint > etfStatus.closureEndTime) timePoint = etfStatus.closureEndTime;\\n        timeElapsed = DesynSafeMath.bsub(timePoint, etfStatus.startClaimFeeTime);\\n        if(timeElapsed >= CLAIM_PERIOD) state = true;\\n        if(isCloseETF && !isCompletedCollect) state = false;\\n    }\\n\\n    function claimManagerFee() public virtual logs lock onlyAdmin needsBPool {\\n        _claimManagerFee();\\n    }\\n\\n    function _claimManagerFee() internal {\\n        (bool state, uint timePoint ,uint timeElapsed) = couldClaimManagerFee();\\n        if(state){\\n            address[] memory poolTokens = bPool.getCurrentTokens();\\n            uint[] memory tokensAmount = SmartPoolManager.handleClaim(\\n                IConfigurableRightsPool(address(this)),\\n                bPool,\\n                poolTokens,\\n                etfStatus.managerFee,\\n                timeElapsed,\\n                CLAIM_PERIOD\\n            );\\n            IVault(vaultAddress).depositManagerToken(poolTokens, tokensAmount);\\n            etfStatus.startClaimFeeTime = timePoint;\\n        }\\n    }\\n\\n    /**\\n     * @notice Create a new Smart Pool\\n     * @dev Delegates to internal function\\n     * @param initialSupply starting token balance\\n     * @param closurePeriod the etf closure period\\n     */\\n    function createPool(\\n        address creator,\\n        uint initialSupply,\\n        uint collectPeriod,\\n        SmartPoolManager.Period closurePeriod,\\n        SmartPoolManager.PoolTokenRange memory tokenRange\\n    ) external virtual onlyOwner logs lock notPaused {\\n        if (etype == SmartPoolManager.Etypes.CLOSED) {\\n            SmartPoolManager.createPoolHandle(collectPeriod, etfStatus.upperCap, initialSupply);\\n\\n            uint oldCap = etfStatus.upperCap;\\n            uint oldFloor = etfStatus.floorCap;\\n            etfStatus.upperCap = initialSupply.bmul(tokenRange.bspCap).bdiv(_initialBalances[0]);\\n            etfStatus.floorCap = initialSupply.bmul(tokenRange.bspFloor).bdiv(_initialBalances[0]);\\n            emit PoolTokenInit(creator, address(this),_initialTokens[0], _initialBalances[0], initialSupply);\\n            emit SizeChanged(creator, \\\"UPPER\\\", oldCap, etfStatus.upperCap);\\n            emit SizeChanged(creator, \\\"FLOOR\\\", oldFloor, etfStatus.floorCap);\\n\\n            uint period;\\n            uint collectEndTime = block.timestamp + collectPeriod;\\n            if (closurePeriod == SmartPoolManager.Period.DAY90) {\\n                period = 90 days;\\n            } else if (closurePeriod == SmartPoolManager.Period.DAY1) {\\n                period = 1 days;\\n            } else if (closurePeriod == SmartPoolManager.Period.DAY3) {\\n                period = 3 days;\\n            } else if (closurePeriod == SmartPoolManager.Period.DAY7) {\\n                period = 7 days;\\n            } else if (closurePeriod == SmartPoolManager.Period.DAY14) {\\n                period = 14 days;\\n            } else if (closurePeriod == SmartPoolManager.Period.DAY30) {\\n                period = 30 days;\\n            } else if (closurePeriod == SmartPoolManager.Period.DAY180) {\\n                period = 180 days;\\n            } else {\\n                period = 360 days;\\n            }\\n            uint closureEndTime = collectEndTime + period;\\n\\n            etfStatus.collectPeriod = collectPeriod;\\n            etfStatus.collectEndTime = collectEndTime;\\n            etfStatus.closurePeriod = period;\\n            etfStatus.closureEndTime = closureEndTime;\\n\\n            IUserVault(bFactory.getUserVault()).recordTokenInfo(creator, creator, _initialTokens, _initialBalances);\\n        }\\n\\n        createPoolInternal(initialSupply);\\n    }\\n\\n    /**\\n     * @notice Join a pool\\n     * @dev Emits a LogJoin event (for each token)\\n     *      bPool is a contract interface; function calls on it are external\\n     * @param poolAmountOut - number of pool tokens to receive\\n     * @param maxAmountsIn - Max amount of asset tokens to spend\\n     */\\n    function joinPool(\\n        uint poolAmountOut,\\n        uint[] calldata maxAmountsIn,\\n        address kol,\\n        address user\\n    ) external logs lock needsBPool notPaused {\\n        SmartPoolManager.joinPoolHandle(rights.canWhitelistLPs, canProvideLiquidity(user), etype == SmartPoolManager.Etypes.CLOSED, etfStatus.collectEndTime);\\n        \\n        if(rights.canTokenWhiteLists) {\\n            require(_initWhiteTokenState(),\\\"ERR_SHOULD_SET_WHITETOKEN\\\");\\n        }\\n        // Delegate to library to save space\\n\\n        // Library computes actualAmountsIn, and does many validations\\n        // Cannot call the push/pull/min from an external library for\\n        // any of these pool functions. Since msg.sender can be anybody,\\n        // they must be internal\\n        uint[] memory actualAmountsIn = SmartPoolManager.joinPool(IConfigurableRightsPool(address(this)), bPool, poolAmountOut, maxAmountsIn, etfStatus.issueFee);\\n\\n        // After createPool, token list is maintained in the underlying BPool\\n        address[] memory poolTokens = bPool.getCurrentTokens();\\n        uint[] memory issueFeesReceived = new uint[](poolTokens.length);\\n\\n        uint _actualIssueFee = etfStatus.issueFee;\\n        if (etype == SmartPoolManager.Etypes.CLOSED) {\\n            IUserVault(bFactory.getUserVault()).recordTokenInfo(kol, user, poolTokens, actualAmountsIn);\\n            if (!isCompletedCollect) {\\n                _actualIssueFee = 0;\\n            }\\n        }\\n\\n        for (uint i = 0; i < poolTokens.length; i++) {\\n            uint issueFeeReceived = SmartPoolManager.handleTransferInTokens(\\n                IConfigurableRightsPool(address(this)),\\n                bPool,\\n                poolTokens[i],\\n                actualAmountsIn[i],\\n                _actualIssueFee\\n            );\\n\\n            emit LogJoin(user, poolTokens[i], actualAmountsIn[i]);\\n            issueFeesReceived[i] = issueFeeReceived;\\n        }\\n\\n        if (_actualIssueFee != 0) {\\n            IVault(vaultAddress).depositIssueRedeemPToken(poolTokens, issueFeesReceived, issueFeesReceived, false);\\n        }\\n        _mintPoolShare(poolAmountOut);\\n        _pushPoolShare(user, poolAmountOut);\\n\\n        // checkout the state that elose ETF collect completed and claime fee.\\n        bool isCompletedMoment = etype == SmartPoolManager.Etypes.CLOSED && varTotalSupply >= etfStatus.floorCap && !isCompletedCollect;\\n        if (isCompletedMoment) {\\n            isCompletedCollect = true;\\n            SmartPoolManager.handleFeeClaim(\\n                IConfigurableRightsPool(address(this)), bPool,\\n                poolTokens,\\n                etfStatus.issueFee,\\n                false\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @notice Exit a pool - redeem pool tokens for underlying assets\\n     * @dev Emits a LogExit event for each token\\n     *      bPool is a contract interface; function calls on it are external\\n     * @param poolAmountIn - amount of pool tokens to redeem\\n     * @param minAmountsOut - minimum amount of asset tokens to receive\\n     */\\n    function exitPool(uint poolAmountIn, uint[] calldata minAmountsOut, address user) external logs lock needsBPool notPaused {\\n        uint actualPoolAmountIn;\\n        bool isCloseEtfCollectEndWithFailure;\\n\\n        uint _actualRedeemFee = etfStatus.redeemFee;\\n        if(etype == SmartPoolManager.Etypes.CLOSED){\\n            isCloseEtfCollectEndWithFailure = !isCompletedCollect && block.timestamp >= etfStatus.collectEndTime;\\n            if(!isCloseEtfCollectEndWithFailure){\\n                if(!hasClaimManageFee) {\\n                    _claimManagerFee();\\n                    hasClaimManageFee = true;\\n                }\\n                if(hasSetBeginFund && !hasSetEndFund) snapshotEndAssets();\\n            }\\n            if(isCloseEtfCollectEndWithFailure) _actualRedeemFee = 0;\\n        }\\n\\n        actualPoolAmountIn = SmartPoolManager.exitPoolHandleB(\\n            IConfigurableRightsPool(address(this)),\\n            etype == SmartPoolManager.Etypes.CLOSED,\\n            isCompletedCollect,\\n            etfStatus.closureEndTime,\\n            etfStatus.collectEndTime,\\n            poolAmountIn\\n        );\\n        // Library computes actualAmountsOut, and does many validations\\n        uint[] memory actualAmountsOut = SmartPoolManager.exitPool(IConfigurableRightsPool(address(this)), bPool, actualPoolAmountIn, minAmountsOut);\\n        _pullPoolShare(msg.sender, actualPoolAmountIn);\\n        _burnPoolShare(actualPoolAmountIn);\\n\\n        // After createPool, token list is maintained in the underlying BPool\\n        address[] memory poolTokens = bPool.getCurrentTokens();\\n\\n        uint[] memory redeemFeesReceived = new uint[](poolTokens.length);\\n        for (uint i = 0; i < poolTokens.length; i++) {\\n            (, uint finalAmountOut, uint redeemFeeReceived) = SmartPoolManager.exitPoolHandleA(\\n                IConfigurableRightsPool(address(this)),\\n                bPool,\\n                poolTokens[i],\\n                actualAmountsOut[i],\\n                _actualRedeemFee\\n            );\\n            redeemFeesReceived[i] = redeemFeeReceived;\\n\\n            emit LogExit(user, poolTokens[i], finalAmountOut);\\n        }\\n\\n        if (_actualRedeemFee != 0) {\\n            IVault(vaultAddress).depositIssueRedeemPToken(poolTokens, redeemFeesReceived, redeemFeesReceived, true);\\n        }\\n    }\\n\\n    /**\\n     * @notice Add to the whitelist of liquidity providers (if enabled)\\n     * @param provider - address of the liquidity provider\\n     */\\n    function whitelistLiquidityProvider(address provider) external onlyOwner lock logs {\\n        SmartPoolManager.WhitelistHandle(rights.canWhitelistLPs, true, provider);\\n        _liquidityProviderWhitelist[provider] = true;\\n    }\\n\\n    /**\\n     * @notice Remove from the whitelist of liquidity providers (if enabled)\\n     * @param provider - address of the liquidity provider\\n     */\\n    function removeWhitelistedLiquidityProvider(address provider) external onlyOwner lock logs {\\n        SmartPoolManager.WhitelistHandle(rights.canWhitelistLPs, _liquidityProviderWhitelist[provider], provider);\\n        _liquidityProviderWhitelist[provider] = false;\\n    }\\n\\n    /**\\n     * @notice Check if an address is a liquidity provider\\n     * @dev If the whitelist feature is not enabled, anyone can provide liquidity (assuming finalized)\\n     * @return boolean value indicating whether the address can join a pool\\n     */\\n    function canProvideLiquidity(address provider) public view returns (bool) {\\n        if (rights.canWhitelistLPs) {\\n            return _liquidityProviderWhitelist[provider] || provider == getController() ;\\n        } else {\\n            // Probably don't strictly need this (could just return true)\\n            // But the null address can't provide funds\\n            return provider != address(0);\\n        }\\n    }\\n\\n    /**\\n     * @notice Getter for specific permissions\\n     * @dev value of the enum is just the 0-based index in the enumeration\\n     * @return token boolean true if we have the given permission\\n     */\\n    function hasPermission(RightsManager.Permissions permission) external view virtual returns (bool) {\\n        return RightsManager.hasPermission(rights, permission);\\n    }\\n\\n    /**\\n     * @notice Getter for the RightsManager contract\\n     * @dev Convenience function to get the address of the RightsManager library (so clients can check version)\\n     * @return address of the RightsManager library\\n     */\\n    function getRightsManagerVersion() external pure returns (address) {\\n        return address(RightsManager);\\n    }\\n\\n    /**\\n     * @notice Getter for the DesynSafeMath contract\\n     * @dev Convenience function to get the address of the DesynSafeMath library (so clients can check version)\\n     * @return address of the DesynSafeMath library\\n     */\\n    function getDesynSafeMathVersion() external pure returns (address) {\\n        return address(DesynSafeMath);\\n    }\\n\\n    /**\\n     * @notice Getter for the SmartPoolManager contract\\n     * @dev Convenience function to get the address of the SmartPoolManager library (so clients can check version)\\n     * @return address of the SmartPoolManager library\\n     */\\n    function getSmartPoolManagerVersion() external pure returns (address) {\\n        return address(SmartPoolManager);\\n    }\\n\\n    // \\\"Public\\\" versions that can safely be called from SmartPoolManager\\n    // Allows only the contract itself to call them (not the controller or any external account)\\n\\n    function mintPoolShareFromLib(uint amount) public {\\n        require(msg.sender == address(this), \\\"ERR_NOT_CONTROLLER\\\");\\n\\n        _mint(amount);\\n    }\\n\\n    function pushPoolShareFromLib(address to, uint amount) public {\\n        require(msg.sender == address(this), \\\"ERR_NOT_CONTROLLER\\\");\\n\\n        _push(to, amount);\\n    }\\n\\n    function pullPoolShareFromLib(address from, uint amount) public {\\n        require(msg.sender == address(this), \\\"ERR_NOT_CONTROLLER\\\");\\n\\n        _pull(from, amount);\\n    }\\n\\n    function burnPoolShareFromLib(uint amount) public {\\n        require(msg.sender == address(this), \\\"ERR_NOT_CONTROLLER\\\");\\n\\n        _burn(amount);\\n    }\\n\\n    /**\\n     * @notice Create a new Smart Pool\\n     * @dev Initialize the swap fee to the value provided in the CRP constructor\\n     * @param initialSupply starting token balance\\n     */\\n    function createPoolInternal(uint initialSupply) internal {\\n        require(address(bPool) == address(0), \\\"ERR_IS_CREATED\\\");\\n\\n        // To the extent possible, modify state variables before calling functions\\n        _mintPoolShare(initialSupply);\\n        _pushPoolShare(msg.sender, initialSupply);\\n\\n        // Deploy new BPool (bFactory and bPool are interfaces; all calls are external)\\n        bPool = bFactory.newLiquidityPool();\\n        // EXIT_FEE must always be zero, or ConfigurableRightsPool._pushUnderlying will fail\\n        SmartPoolManager.createPoolInternalHandle(bPool, initialSupply);\\n        for (uint i = 0; i < _initialTokens.length; i++) {\\n            address t = _initialTokens[i];\\n            uint bal = _initialBalances[i];\\n            uint denorm = _initialWeights[i];\\n\\n            _verifyWhiteToken(t);\\n            IERC20(t).safeTransferFrom(msg.sender, address(this), bal);\\n            IERC20(t).safeApprove(address(bPool), 0);\\n            IERC20(t).safeApprove(address(bPool), DesynConstants.MAX_UINT);\\n\\n            bPool.bind(t, bal, denorm);\\n        }\\n\\n        while (_initialTokens.length > 0) {\\n            // Modifying state variable after external calls here,\\n            // but not essential, so not dangerous\\n            _initialTokens.pop();\\n        }\\n    }\\n\\n    function addTokenToWhitelist(uint[] memory sort, address[] memory token) external onlyOwner {\\n        require(rights.canTokenWhiteLists && !hasSetWhiteTokens, \\\"ERR_NO_RIGHTS\\\");\\n        require(sort.length == token.length, \\\"ERR_SORT_TOKEN_MISMATCH\\\");\\n        for (uint i = 0; i < token.length; i++) {\\n            bool inRange = bFactory.isTokenWhitelistedForVerify(sort[i], token[i]);\\n            require(inRange, \\\"TOKEN_MUST_IN_WHITE_LISTS\\\");\\n            _addTokenToWhitelist(sort[i], token[i]);\\n        }\\n        hasSetWhiteTokens = true;\\n    }\\n\\n    function _verifyWhiteToken(address token) public view {\\n        require(bFactory.isTokenWhitelistedForVerify(token), \\\"ERR_NOT_WHITE_TOKEN\\\");\\n\\n        if (hasSetWhiteTokens) {\\n            require(_queryIsTokenWhitelisted(token), \\\"ERR_NOT_WHITE_TOKEN\\\");\\n        }\\n    }\\n\\n    // Rebind BPool and pull tokens from address\\n    // bPool is a contract interface; function calls on it are external\\n    function _pullUnderlying(\\n        address erc20,\\n        address from,\\n        uint amount\\n    ) internal needsBPool {\\n        // Gets current Balance of token i, Bi, and weight of token i, Wi, from BPool.\\n        uint tokenBalance = bPool.getBalance(erc20);\\n        uint tokenWeight = bPool.getDenormalizedWeight(erc20);\\n\\n        IERC20(erc20).safeTransferFrom(from, address(this), amount);\\n        bPool.rebind(erc20, DesynSafeMath.badd(tokenBalance, amount), tokenWeight);\\n    }\\n\\n    // Rebind BPool and push tokens to address\\n    // bPool is a contract interface; function calls on it are external\\n    function _pushUnderlying(\\n        address erc20,\\n        address to,\\n        uint amount\\n    ) internal needsBPool {\\n        // Gets current Balance of token i, Bi, and weight of token i, Wi, from BPool.\\n        uint tokenBalance = bPool.getBalance(erc20);\\n        uint tokenWeight = bPool.getDenormalizedWeight(erc20);\\n        bPool.rebind(erc20, DesynSafeMath.bsub(tokenBalance, amount), tokenWeight);\\n\\n        IERC20(erc20).safeTransfer(to, amount);\\n    }\\n\\n    // Wrappers around corresponding core functions\\n\\n    function _mint(uint amount) internal override {\\n        super._mint(amount);\\n        require(varTotalSupply <= etfStatus.upperCap, \\\"ERR_CAP_LIMIT_REACHED\\\");\\n    }\\n\\n    function _mintPoolShare(uint amount) internal {\\n        _mint(amount);\\n    }\\n\\n    function _pushPoolShare(address to, uint amount) internal {\\n        _push(to, amount);\\n    }\\n\\n    function _pullPoolShare(address from, uint amount) internal {\\n        _pull(from, amount);\\n    }\\n\\n    function _burnPoolShare(uint amount) internal {\\n        _burn(amount);\\n    }\\n\\n    // ================ SnapshotAssets ================\\n\\n    function snapshotBeginAssets() external logs {\\n        uint nowTime = block.timestamp;\\n        require(!hasSetBeginFund && isCompletedCollect && etype == SmartPoolManager.Etypes.CLOSED && nowTime <= (etfStatus.collectEndTime + 3 days) , \\\"ERR_CONDITIONS_NOT_MET\\\");\\n\\n        bool inT1 = nowTime <= (etfStatus.collectEndTime + 1 days);\\n        if(inT1) require(adminList[msg.sender] || msg.sender == _owner, \\\"onlyAdmin\\\");\\n\\n        beginFund = snapshotAssets();\\n        hasSetBeginFund = true;\\n\\n        if(nowTime < etfStatus.collectEndTime) etfStatus.collectEndTime = block.timestamp;\\n    }\\n\\n    function beginFundAssets() external view returns(SmartPoolManager.Fund memory){\\n        return beginFund;\\n    }\\n\\n    function endFundAssets() external view returns(SmartPoolManager.Fund memory){\\n        return endFund;\\n    }\\n\\n    function snapshotEndAssets() public logs {\\n        uint nowTime = block.timestamp;\\n        require(!hasSetEndFund && hasSetBeginFund && etype == SmartPoolManager.Etypes.CLOSED && nowTime >= etfStatus.closureEndTime, \\\"ERR_CONDITIONS_NOT_MET\\\");\\n\\n        bool inT1 = (etfStatus.closureEndTime + 1 days) >= nowTime;\\n        if(inT1) require(adminList[msg.sender] || msg.sender == _owner, \\\"onlyAdmin\\\");\\n\\n        endFund = snapshotAssets();\\n\\n        uint preShareValueEnd = endFund.fundAmount.bdiv(endFund.etfAmount);\\n        uint preShareValueBegin = beginFund.fundAmount.bdiv(beginFund.etfAmount);\\n      \\n        if(preShareValueEnd > preShareValueBegin){\\n            uint perfermanceRatio = etfStatus.perfermanceFee.bmul(preShareValueEnd-preShareValueBegin).bdiv(preShareValueEnd);\\n            // claim perfomance reward \\n            SmartPoolManager.handleFeeClaim(\\n                    IConfigurableRightsPool(address(this)), bPool,\\n                    bPool.getCurrentTokens(),\\n                    perfermanceRatio,\\n                    true);\\n        }\\n\\n        hasSetEndFund = true;\\n    }\\n\\n    function snapshotAssets() public returns(SmartPoolManager.Fund memory){\\n        SmartPoolManager.Fund memory tempFund;\\n        tempFund.etfAmount = varTotalSupply;\\n\\n        (tempFund.tokens, tempFund.tokensAmount) = _getPoolTokensInfo();\\n        tempFund.fundAmount = Oracles(bFactory.getOracleAddress()).getAllPrice(tempFund.tokens, tempFund.tokensAmount);\\n        tempFund.snapshotTime = block.timestamp;\\n        return tempFund;\\n    }\\n\\n    function _getPoolTokensInfo() internal view returns (address[] memory, uint[] memory) {\\n        address[] memory tokens = bPool.getCurrentTokens();\\n        uint[] memory totalBalances = new uint[](tokens.length);\\n        for(uint i; i < tokens.length ;i++) {\\n            totalBalances[i] = bPool.getBalance(tokens[i]);\\n        }\\n        return (tokens,totalBalances);\\n    }\\n}\"\r\n    },\r\n    \"contracts/base/PCToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.6.12;\\n\\n// Imports\\n\\nimport \\\"../libraries/DesynSafeMath.sol\\\";\\nimport \\\"../interfaces/IERC20.sol\\\";\\n\\n// Contracts\\n\\n/* solhint-disable func-order */\\n\\n/**\\n * @author Desyn Labs\\n * @title Highly opinionated token implementation\\n */\\ncontract PCToken is IERC20 {\\n    using DesynSafeMath for uint;\\n\\n    // State variables\\n    string public constant NAME = \\\"Desyn Smart Pool\\\";\\n    uint8 public constant DECIMALS = 18;\\n\\n    // No leading underscore per naming convention (non-private)\\n    // Cannot call totalSupply (name conflict)\\n    // solhint-disable-next-line private-vars-leading-underscore\\n    uint internal varTotalSupply;\\n\\n    mapping(address => uint) private _balance;\\n    mapping(address => mapping(address => uint)) private _allowance;\\n\\n    string private _symbol;\\n    string private _name;\\n\\n    // Event declarations\\n\\n    // See definitions above; must be redeclared to be emitted from this contract\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    // Function declarations\\n\\n    /**\\n     * @notice Base token constructor\\n     * @param tokenSymbol - the token symbol\\n     */\\n    constructor(string memory tokenSymbol, string memory tokenName) public {\\n        _symbol = tokenSymbol;\\n        _name = tokenName;\\n    }\\n\\n    // External functions\\n\\n    /**\\n     * @notice Getter for allowance: amount spender will be allowed to spend on behalf of owner\\n     * @param owner - owner of the tokens\\n     * @param spender - entity allowed to spend the tokens\\n     * @return uint - remaining amount spender is allowed to transfer\\n     */\\n    function allowance(address owner, address spender) external view override returns (uint) {\\n        return _allowance[owner][spender];\\n    }\\n\\n    /**\\n     * @notice Getter for current account balance\\n     * @param account - address we're checking the balance of\\n     * @return uint - token balance in the account\\n     */\\n    function balanceOf(address account) external view override returns (uint) {\\n        return _balance[account];\\n    }\\n\\n    /**\\n     * @notice Approve owner (sender) to spend a certain amount\\n     * @dev emits an Approval event\\n     * @param spender - entity the owner (sender) is approving to spend his tokens\\n     * @param amount - number of tokens being approved\\n     * @return bool - result of the approval (will always be true if it doesn't revert)\\n     */\\n    function approve(address spender, uint amount) external override returns (bool) {\\n        /* In addition to the increase/decreaseApproval functions, could\\n           avoid the \\\"approval race condition\\\" by only allowing calls to approve\\n           when the current approval amount is 0\\n        \\n           require(_allowance[msg.sender][spender] == 0, \\\"ERR_RACE_CONDITION\\\");\\n\\n           Some token contracts (e.g., KNC), already revert if you call approve \\n           on a non-zero allocation. To deal with these, we use the SafeApprove library\\n           and safeApprove function when adding tokens to the pool.\\n        */\\n\\n        _allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Increase the amount the spender is allowed to spend on behalf of the owner (sender)\\n     * @dev emits an Approval event\\n     * @param spender - entity the owner (sender) is approving to spend his tokens\\n     * @param amount - number of tokens being approved\\n     * @return bool - result of the approval (will always be true if it doesn't revert)\\n     */\\n    function increaseApproval(address spender, uint amount) external returns (bool) {\\n        _allowance[msg.sender][spender] = DesynSafeMath.badd(_allowance[msg.sender][spender], amount);\\n\\n        emit Approval(msg.sender, spender, _allowance[msg.sender][spender]);\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Decrease the amount the spender is allowed to spend on behalf of the owner (sender)\\n     * @dev emits an Approval event\\n     * @dev If you try to decrease it below the current limit, it's just set to zero (not an error)\\n     * @param spender - entity the owner (sender) is approving to spend his tokens\\n     * @param amount - number of tokens being approved\\n     * @return bool - result of the approval (will always be true if it doesn't revert)\\n     */\\n    function decreaseApproval(address spender, uint amount) external returns (bool) {\\n        uint oldValue = _allowance[msg.sender][spender];\\n        // Gas optimization - if amount == oldValue (or is larger), set to zero immediately\\n        if (amount >= oldValue) {\\n            _allowance[msg.sender][spender] = 0;\\n        } else {\\n            _allowance[msg.sender][spender] = DesynSafeMath.bsub(oldValue, amount);\\n        }\\n\\n        emit Approval(msg.sender, spender, _allowance[msg.sender][spender]);\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Transfer the given amount from sender (caller) to recipient\\n     * @dev _move emits a Transfer event if successful\\n     * @param recipient - entity receiving the tokens\\n     * @param amount - number of tokens being transferred\\n     * @return bool - result of the transfer (will always be true if it doesn't revert)\\n     */\\n    function transfer(address recipient, uint amount) external override returns (bool) {\\n        require(recipient != address(0), \\\"ERR_ZERO_ADDRESS\\\");\\n\\n        _move(msg.sender, recipient, amount);\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Transfer the given amount from sender to recipient\\n     * @dev _move emits a Transfer event if successful; may also emit an Approval event\\n     * @param sender - entity sending the tokens (must be caller or allowed to spend on behalf of caller)\\n     * @param recipient - recipient of the tokens\\n     * @param amount - number of tokens being transferred\\n     * @return bool - result of the transfer (will always be true if it doesn't revert)\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint amount\\n    ) external override returns (bool) {\\n        require(recipient != address(0), \\\"ERR_ZERO_ADDRESS\\\");\\n        require(msg.sender == sender || amount <= _allowance[sender][msg.sender], \\\"ERR_PCTOKEN_BAD_CALLER\\\");\\n\\n        _move(sender, recipient, amount);\\n\\n        // memoize for gas optimization\\n        uint oldAllowance = _allowance[sender][msg.sender];\\n\\n        // If the sender is not the caller, adjust the allowance by the amount transferred\\n        if (msg.sender != sender && oldAllowance != uint(-1)) {\\n            _allowance[sender][msg.sender] = DesynSafeMath.bsub(oldAllowance, amount);\\n\\n            emit Approval(sender, msg.sender, _allowance[sender][msg.sender]);\\n        }\\n\\n        return true;\\n    }\\n\\n    // public functions\\n\\n    /**\\n     * @notice Getter for the total supply\\n     * @dev declared external for gas optimization\\n     * @return uint - total number of tokens in existence\\n     */\\n    function totalSupply() external view override returns (uint) {\\n        return varTotalSupply;\\n    }\\n\\n    // Public functions\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     *      We allow the user to set this name (as well as the symbol).\\n     *      Alternatives are 1) A fixed string (original design)\\n     *                       2) A fixed string plus the user-defined symbol\\n     *                          return string(abi.encodePacked(NAME, \\\"-\\\", _symbol));\\n     */\\n    function name() external view returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() external view override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\\n     * called.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() external view override returns (uint8) {\\n        return DECIMALS;\\n    }\\n\\n    // internal functions\\n\\n    // Mint an amount of new tokens, and add them to the balance (and total supply)\\n    // Emit a transfer amount from the null address to this contract\\n    function _mint(uint amount) internal virtual {\\n        _balance[address(this)] = DesynSafeMath.badd(_balance[address(this)], amount);\\n        varTotalSupply = DesynSafeMath.badd(varTotalSupply, amount);\\n\\n        emit Transfer(address(0), address(this), amount);\\n    }\\n\\n    // Burn an amount of new tokens, and subtract them from the balance (and total supply)\\n    // Emit a transfer amount from this contract to the null address\\n    function _burn(uint amount) internal virtual {\\n        // Can't burn more than we have\\n        // Remove require for gas optimization - bsub will revert on underflow\\n        // require(_balance[address(this)] >= amount, \\\"ERR_INSUFFICIENT_BAL\\\");\\n\\n        _balance[address(this)] = DesynSafeMath.bsub(_balance[address(this)], amount);\\n        varTotalSupply = DesynSafeMath.bsub(varTotalSupply, amount);\\n\\n        emit Transfer(address(this), address(0), amount);\\n    }\\n\\n    // Transfer tokens from sender to recipient\\n    // Adjust balances, and emit a Transfer event\\n    function _move(\\n        address sender,\\n        address recipient,\\n        uint amount\\n    ) internal virtual {\\n        // Can't send more than sender has\\n        // Remove require for gas optimization - bsub will revert on underflow\\n        // require(_balance[sender] >= amount, \\\"ERR_INSUFFICIENT_BAL\\\");\\n\\n        _balance[sender] = DesynSafeMath.bsub(_balance[sender], amount);\\n        _balance[recipient] = DesynSafeMath.badd(_balance[recipient], amount);\\n\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    // Transfer from this contract to recipient\\n    // Emits a transfer event if successful\\n    function _push(address recipient, uint amount) internal {\\n        _move(address(this), recipient, amount);\\n    }\\n\\n    // Transfer from recipient to this contract\\n    // Emits a transfer event if successful\\n    function _pull(address sender, uint amount) internal {\\n        _move(sender, address(this), amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/DesynOwnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.6.12;\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\ncontract DesynOwnable {\\n    // State variables\\n    mapping(address => bool) public adminList;\\n    uint public allOwnerPercentage = 10000;\\n\\n    address _owner;\\n    address[] owners;\\n    uint[] ownerPercentage;\\n    bool initialized;\\n    // Event declarations\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n    event AddAdmin(address indexed newAdmin, uint indexed amount);\\n    event RemoveAdmin(address indexed oldAdmin, uint indexed amount);\\n\\n    // Modifiers\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(_owner == msg.sender, \\\"ERR_NOT_CONTROLLER\\\");\\n        _;\\n    }\\n\\n    modifier onlyAdmin() {\\n        require(adminList[msg.sender] || msg.sender == _owner, \\\"onlyAdmin\\\");\\n        _;\\n    }\\n\\n    // Function declarations\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() internal {\\n        _owner = msg.sender;\\n    }\\n\\n    function initHandle(address[] memory _owners, uint[] memory _ownerPercentage) external {\\n        require(_owners.length == _ownerPercentage.length, \\\"ownerP\\\");\\n        require(!initialized, \\\"initialized!\\\");\\n        \\n        _addAdmin(_owners);\\n\\n        owners = _owners;\\n        ownerPercentage = _ownerPercentage;\\n\\n        initialized = true;\\n        _ownerPercentageChecker();\\n    }\\n\\n    function setManagersInfo(address[] memory _owners, uint[] memory _ownerPercentage) external onlyOwner {\\n        _beforeControllerChange();\\n        _clearAdmin();\\n        _addAdmin(_owners);\\n        owners = _owners;\\n        ownerPercentage = _ownerPercentage;\\n        _ownerPercentageChecker();\\n    }\\n\\n    function _ownerPercentageChecker() internal view {\\n        uint totalPercentage;\\n        for (uint i; i < ownerPercentage.length; i++) {\\n            totalPercentage+=ownerPercentage[i];\\n        } \\n        require(totalPercentage == 10000, \\\"ERR_ILLEGAL_PERCENTAGE\\\"); \\n    }\\n\\n    function _addAdmin(address[] memory admins) internal {\\n        bool hasOwner;\\n        for (uint i; i < admins.length; i++) {\\n            adminList[admins[i]] = true;\\n            if(admins[i] == _owner) hasOwner = true;\\n        } \\n\\n        if(initialized) require(hasOwner, \\\"ERR_NEW_ADMINS_HAS_NO_OWNER\\\");    \\n    }\\n\\n    function _clearAdmin() internal {\\n        for(uint i; i < owners.length; i++) {\\n            delete adminList[owners[i]];\\n        }\\n    }\\n\\n    /**\\n     * @notice Transfers ownership of the contract to a new account (`newOwner`).\\n     *         Can only be called by the current owner\\n     * @dev external for gas optimization\\n     * @param newOwner - address of new owner\\n     */\\n    function setController(address newOwner) external onlyOwner {\\n        _beforeControllerChange();\\n        require(newOwner != address(0), \\\"ERR_ZERO_ADDRESS\\\");\\n\\n        emit OwnershipTransferred(_owner, newOwner);\\n\\n        for (uint i;i < owners.length; i++) {\\n            if (owners[i] == _owner) {\\n                owners[i] = newOwner;\\n            }\\n        }\\n\\n        adminList[_owner] = false;\\n        adminList[newOwner] = true;\\n        _owner = newOwner;\\n    }\\n\\n    // @dev Returns list of owners.\\n    // @return List of owner addresses.\\n    function getOwners() external view returns (address[] memory) {\\n        return owners;\\n    }\\n\\n    // @dev Returns list of owners.\\n    // @return List of owner addresses.\\n    function getOwnerPercentage() external view returns (uint[] memory) {\\n        return ownerPercentage;\\n    }\\n\\n    /**\\n     * @notice Returns the address of the current owner\\n     * @dev external for gas optimization\\n     * @return address - of the owner (AKA controller)\\n     */\\n    function getController() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    function _beforeControllerChange() internal virtual {}\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/SafeApprove.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.6.12;\\n\\n// Imports\\n\\nimport \\\"../interfaces/IERC20.sol\\\";\\n\\n// Libraries\\n\\n/**\\n * @author PieDAO (ported to Desyn Labs)\\n * @title SafeApprove - set approval for tokens that require 0 prior approval\\n * @dev Perhaps to address the known ERC20 race condition issue\\n *      See https://github.com/crytic/not-so-smart-contracts/tree/master/race_condition\\n *      Some tokens - notably KNC - only allow approvals to be increased from 0\\n */\\nlibrary SafeApprove {\\n    /**\\n     * @notice handle approvals of tokens that require approving from a base of 0\\n     * @param token - the token we're approving\\n     * @param spender - entity the owner (sender) is approving to spend his tokens\\n     * @param amount - number of tokens being approved\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint amount\\n    ) internal returns (bool) {\\n        uint currentAllowance = token.allowance(address(this), spender);\\n\\n        // Do nothing if allowance is already set to this value\\n        if (currentAllowance == amount) {\\n            return true;\\n        }\\n\\n        // If approval is not zero reset it to zero first\\n        if (currentAllowance != 0) {\\n            token.approve(spender, 0);\\n        }\\n\\n        // do the actual approval\\n        return token.approve(spender, amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/base/WhiteToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.6.12;\\n\\ncontract WhiteToken {\\n    // add token log\\n    event LOG_WHITELIST(address indexed spender, uint indexed sort, address indexed caller, address token);\\n    // del token log\\n    event LOG_DEL_WHITELIST(address indexed spender, uint indexed sort, address indexed caller, address token);\\n\\n    // record the number of whitelists.\\n    uint private _whiteTokenCount;\\n    // token address => is white token.\\n    mapping(address => bool) private _isTokenWhitelisted;\\n    // Multi level white token.\\n    // type => token address => is white token.\\n    mapping(uint => mapping(address => bool)) private _tokenWhitelistedInfo;\\n\\n    function _queryIsTokenWhitelisted(address token) internal view returns (bool) {\\n        return _isTokenWhitelisted[token];\\n    }\\n\\n    // for factory to verify\\n    function _isTokenWhitelistedForVerify(uint sort, address token) internal view returns (bool) {\\n        return _tokenWhitelistedInfo[sort][token];\\n    }\\n\\n    // add sort token\\n    function _addTokenToWhitelist(uint sort, address token) internal {\\n        require(token != address(0), \\\"ERR_INVALID_TOKEN_ADDRESS\\\");\\n        require(_queryIsTokenWhitelisted(token) == false, \\\"ERR_HAS_BEEN_ADDED_WHITE\\\");\\n\\n        _tokenWhitelistedInfo[sort][token] = true;\\n        _isTokenWhitelisted[token] = true;\\n        _whiteTokenCount++;\\n\\n        emit LOG_WHITELIST(address(this), sort, msg.sender, token);\\n    }\\n\\n    // remove sort token\\n    function _removeTokenFromWhitelist(uint sort, address token) internal {\\n        require(_queryIsTokenWhitelisted(token) == true, \\\"ERR_NOT_WHITE_TOKEN\\\");\\n\\n        require(_tokenWhitelistedInfo[sort][token], \\\"ERR_SORT_NOT_MATCHED\\\");\\n\\n        _tokenWhitelistedInfo[sort][token] = false;\\n        _isTokenWhitelisted[token] = false;\\n        _whiteTokenCount--;\\n        emit LOG_DEL_WHITELIST(address(this), sort, msg.sender, token);\\n    }\\n\\n    // already has init\\n    function _initWhiteTokenState() internal view returns (bool) {\\n        return _whiteTokenCount == 0 ?  false : true;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/deploy/Factory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is disstributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity 0.6.12;\\nimport \\\"../base/WhiteToken.sol\\\";\\nimport \\\"../interfaces/IBFactory.sol\\\";\\nimport \\\"../libraries/SafeERC20.sol\\\";\\n\\ncontract Factory is WhiteToken {\\n    using SafeERC20 for IERC20;\\n\\n    event LOG_NEW_POOL(address indexed caller, address indexed pool);\\n    event LOG_BLABS(address indexed caller, address indexed blabs);\\n    event LOG_ROUTER(address indexed caller, address indexed router);\\n    event LOG_VAULT(address indexed vault, address indexed caller);\\n    event LOG_USER_VAULT(address indexed vault, address indexed caller);\\n    event LOG_MANAGER(address indexed manager, address indexed caller);\\n    event LOG_ORACLE(address indexed caller, address indexed oracle);\\n    event SYSTEM_MODULE_CHANGED(address module, bool state);\\n    event MODULE_STATUS_CHANGE(address etf, address module, bool status);\\n    event PAUSED_STATUS(bool state);\\n\\n    mapping(address => bool) private _isLiquidityPool;\\n    mapping(address => bool) private _isSystemModule;\\n    mapping(address => mapping(address => bool)) private _isModuleRegistered;\\n    uint private counters;\\n    bytes private bytecodes;\\n    bool public isPaused;\\n\\n    address private _blabs;\\n    address private _oracle;\\n    address private _vaultAddress;\\n    address private _userVaultAddress;\\n\\n    constructor(\\n      address oracle,\\n      address vault,\\n      address userVault\\n    ) public {\\n        _blabs = msg.sender;\\n        _oracle = oracle;\\n        _vaultAddress = vault;\\n        _userVaultAddress = userVault;\\n    }\\n\\n    function addTokenToWhitelist(uint[] memory sort, address[] memory token) external onlyBlabs {\\n        require(sort.length == token.length, \\\"ERR_SORT_TOKEN_MISMATCH\\\");\\n        for (uint i = 0; i < sort.length; i++) {\\n            _addTokenToWhitelist(sort[i], token[i]);\\n        }\\n    }\\n\\n    function removeTokenFromWhitelist(uint[] memory sort, address[] memory token) external onlyBlabs {\\n        require(sort.length == token.length, \\\"ERR_SORT_TOKEN_MISMATCH\\\");\\n        for (uint i = 0; i < sort.length; i++) {\\n            _removeTokenFromWhitelist(sort[i], token[i]);\\n        }\\n    }\\n\\n    function isTokenWhitelistedForVerify(uint sort, address token) external view returns (bool) {\\n        return _isTokenWhitelistedForVerify(sort, token);\\n    }\\n\\n    function isTokenWhitelistedForVerify(address token) external view returns (bool) {\\n        return _queryIsTokenWhitelisted(token);\\n    }\\n\\n    function isLiquidityPool(address b) external view returns (bool) {\\n        return _isLiquidityPool[b];\\n    }\\n\\n    function createPool() internal returns (address base) {\\n        bytes memory bytecode = bytecodes;\\n        bytes32 salt = keccak256(abi.encodePacked(counters++));\\n\\n        assembly {\\n            base := create2(0, add(bytecode, 32), mload(bytecode), salt)\\n            if iszero(extcodesize(base)) {\\n                revert(0, 0)\\n            }\\n        }\\n        counters++;\\n    }\\n\\n    function newLiquidityPool() external returns (IBPool) {\\n        address lpool = createPool();\\n        _isLiquidityPool[lpool] = true;\\n        emit LOG_NEW_POOL(msg.sender, lpool);\\n        IBPool(lpool).setController(msg.sender);\\n        return IBPool(lpool);\\n    }\\n\\n    function getBLabs() external view returns (address) {\\n        return _blabs;\\n    }\\n\\n    function setBLabs(address b) external onlyBlabs {\\n        require(b != address(0), \\\"ERR_ZERO_ADDRESS\\\");\\n        emit LOG_BLABS(msg.sender, b);\\n        _blabs = b;\\n    }\\n\\n    function getModuleStatus(address etf, address module) external view returns (bool) {\\n        return _isSystemModule[module] || _isModuleRegistered[etf][module];\\n    }\\n\\n    function getOracleAddress() external view returns (address) {\\n        return _oracle;\\n    }\\n\\n    function setSystemModule(address module, bool state) external onlyBlabs {\\n        require(module != address(0), \\\"ZERO ADDRESS\\\");\\n\\n        _isSystemModule[module] = state;\\n\\n        emit SYSTEM_MODULE_CHANGED(module, state);\\n    }\\n\\n    function registerModule(address etf, address module) external onlyBlabs {\\n        require(etf != address(0), \\\"ZERO ETF ADDRESS\\\");\\n        require(module != address(0), \\\"ZERO ADDRESS\\\");\\n\\n        _isModuleRegistered[etf][module] = true;\\n\\n        emit MODULE_STATUS_CHANGE(etf, module, true);\\n    }\\n\\n    function removeModule(address etf, address module) external onlyBlabs {\\n        require(etf != address(0), \\\"ZERO ETF ADDRESS\\\");\\n        require(module != address(0), \\\"ZERO ADDRESS\\\");\\n\\n        _isModuleRegistered[etf][module] = false;\\n\\n        emit MODULE_STATUS_CHANGE(etf, module, false);\\n    }\\n\\n    function setOracle(address oracle) external onlyBlabs {\\n        require(oracle != address(0), \\\"ERR_ZERO_ADDRESS\\\");\\n        emit LOG_ORACLE(msg.sender, oracle);\\n        _oracle = oracle;\\n    }\\n\\n    function collect(IERC20 token) external onlyBlabs {\\n        uint collected = token.balanceOf(address(this));\\n        token.safeTransfer(_blabs, collected);\\n    }\\n\\n    function getVault() external view returns (address) {\\n        return _vaultAddress;\\n    }\\n\\n    function setVault(address newVault) external onlyBlabs {\\n        require(newVault != address(0), \\\"ERR_ZERO_ADDRESS\\\");\\n        _vaultAddress = newVault;\\n        emit LOG_VAULT(newVault, msg.sender);\\n    }\\n\\n    function getUserVault() external view returns (address) {\\n        return _userVaultAddress;\\n    }\\n\\n    function setUserVault(address newVault) external onlyBlabs {\\n        require(newVault != address(0), \\\"ERR_ZERO_ADDRESS\\\");\\n        _userVaultAddress = newVault;\\n        emit LOG_USER_VAULT(newVault, msg.sender);\\n    }\\n\\n    function setProtocolPaused(bool state) external onlyBlabs {\\n        isPaused = state;\\n        emit PAUSED_STATUS(state);\\n    }\\n\\n    function setByteCodes(bytes memory _bytecode) external onlyBlabs {\\n        bytecodes = _bytecode;\\n    }\\n\\n    modifier onlyBlabs() {\\n        require(msg.sender == _blabs, \\\"ERR_NOT_BLABS\\\");\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/base/LiquidityPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"./LpToken.sol\\\";\\nimport \\\"./Math.sol\\\";\\nimport \\\"../interfaces/IBFactory.sol\\\";\\nimport \\\"../interfaces/IConfigurableRightsPool.sol\\\";\\nimport \\\"../libraries/Address.sol\\\";\\nimport \\\"../libraries/SafeERC20.sol\\\";\\n\\ncontract LiquidityPool is BBronze, LpToken, Math {\\n    using Address for address;\\n    using SafeERC20 for IERC20;\\n\\n    struct Record {\\n        bool bound; // is token bound to pool\\n        uint index; // private\\n        uint denorm; // denormalized weight\\n        uint balance;\\n    }\\n\\n    event LOG_JOIN(address indexed caller, address indexed tokenIn, uint tokenAmountIn);\\n\\n    event LOG_EXIT(address indexed caller, address indexed tokenOut, uint tokenAmountOut);\\n\\n    event LOG_REBALANCE(address indexed tokenA, address indexed tokenB, uint newWeightA, uint newWeightB, uint newBalanceA, uint newBalanceB, bool isSoldout);\\n\\n    event LOG_CALL(bytes4 indexed sig, address indexed caller, bytes data) anonymous;\\n\\n    modifier _logs_() {\\n        emit LOG_CALL(msg.sig, msg.sender, msg.data);\\n        _;\\n    }\\n\\n    modifier _lock_() {\\n        require(!_mutex, \\\"ERR_REENTRY\\\");\\n        _mutex = true;\\n        _;\\n        _mutex = false;\\n    }\\n\\n    modifier _viewlock_() {\\n        require(!_mutex, \\\"ERR_REENTRY\\\");\\n        _;\\n    }\\n\\n    bool private _mutex;\\n\\n    IBFactory private _factory; // Factory address to push token exitFee to\\n    address private _controller; // has CONTROL role\\n    bool private _publicSwap; // true if PUBLIC can call SWAP functions\\n\\n    // `finalize` sets `PUBLIC can SWAP`, `PUBLIC can JOIN`\\n    bool private _finalized;\\n\\n    address[] private _tokens;\\n    mapping(address => Record) private _records;\\n    uint private _totalWeight;\\n\\n    constructor() public {\\n        _controller = msg.sender;\\n        _factory = IBFactory(msg.sender);\\n        _publicSwap = false;\\n        _finalized = false;\\n    }\\n\\n    function isPublicSwap() external view returns (bool) {\\n        return _publicSwap;\\n    }\\n\\n    function isFinalized() external view returns (bool) {\\n        return _finalized;\\n    }\\n\\n    function isBound(address t) external view returns (bool) {\\n        return _records[t].bound;\\n    }\\n\\n    function getNumTokens() external view returns (uint) {\\n        return _tokens.length;\\n    }\\n\\n    function getCurrentTokens() external view _viewlock_ returns (address[] memory tokens) {\\n        return _tokens;\\n    }\\n\\n    function getFinalTokens() external view _viewlock_ returns (address[] memory tokens) {\\n        require(_finalized, \\\"ERR_NOT_FINALIZED\\\");\\n        return _tokens;\\n    }\\n\\n    function getDenormalizedWeight(address token) external view _viewlock_ returns (uint) {\\n        // require(_records[token].bound, \\\"ERR_NOT_BOUND\\\");\\n        return _records[token].denorm;\\n    }\\n\\n    function getTotalDenormalizedWeight() external view _viewlock_ returns (uint) {\\n        return _totalWeight;\\n    }\\n\\n    function getNormalizedWeight(address token) external _viewlock_ returns (uint) {\\n        require(_records[token].bound, \\\"ERR_NOT_BOUND\\\");\\n        Oracles oracle = Oracles(_factory.getOracleAddress());\\n        uint denorm = _records[token].denorm;\\n        uint price = oracle.getPrice(token);\\n\\n        uint[] memory _balances = new uint[](_tokens.length);\\n        for (uint i = 0; i < _tokens.length; i++) {\\n            _balances[i] = getBalance(_tokens[i]);\\n        }\\n        uint totalValue = oracle.getAllPrice(_tokens, _balances);\\n        uint currentValue = bmul(price, getBalance(token));\\n        return bdiv(currentValue, totalValue);\\n    }\\n\\n    function getBalance(address token) public view _viewlock_ returns (uint) {\\n        // require(_records[token].bound, \\\"ERR_NOT_BOUND\\\");\\n        return _records[token].balance;\\n    }\\n\\n    function getController() external view _viewlock_ returns (address) {\\n        return _controller;\\n    }\\n\\n    function setController(address manager) external _logs_ _lock_ {\\n        require(msg.sender == _controller, \\\"ERR_NOT_CONTROLLER\\\");\\n        require(manager != address(0), \\\"ERR_ZERO_ADDRESS\\\");\\n        _controller = manager;\\n    }\\n\\n    function setPublicSwap(bool public_) external _logs_ _lock_ {\\n        require(!_finalized, \\\"ERR_IS_FINALIZED\\\");\\n        require(msg.sender == _controller, \\\"ERR_NOT_CONTROLLER\\\");\\n        _publicSwap = public_;\\n    }\\n\\n    function finalize() external _logs_ _lock_ {\\n        require(msg.sender == _controller, \\\"ERR_NOT_CONTROLLER\\\");\\n        require(!_finalized, \\\"ERR_IS_FINALIZED\\\");\\n        require(_tokens.length >= MIN_BOUND_TOKENS, \\\"ERR_MIN_TOKENS\\\");\\n\\n        _finalized = true;\\n        _publicSwap = true;\\n\\n        _mintPoolShare(INIT_POOL_SUPPLY);\\n        _pushPoolShare(msg.sender, INIT_POOL_SUPPLY);\\n    }\\n\\n    function bind(\\n        address token,\\n        uint balance,\\n        uint denorm\\n    )\\n        external\\n        _logs_ // _lock_  Bind does not lock because it jumps to `rebind`, which does\\n    {\\n        require(msg.sender == _controller, \\\"ERR_NOT_CONTROLLER\\\");\\n        require(!_records[token].bound, \\\"ERR_IS_BOUND\\\");\\n        require(!_finalized, \\\"ERR_IS_FINALIZED\\\");\\n\\n        require(_tokens.length < MAX_BOUND_TOKENS, \\\"ERR_MAX_TOKENS\\\");\\n\\n        _records[token] = Record({\\n            bound: true,\\n            index: _tokens.length,\\n            denorm: 0, // balance and denorm will be validated\\n            balance: 0 // and set by `rebind`\\n        });\\n        _tokens.push(token);\\n        rebind(token, balance, denorm);\\n    }\\n\\n    function rebind(\\n        address token,\\n        uint balance,\\n        uint denorm\\n    ) public _logs_ _lock_ {\\n        require(msg.sender == _controller, \\\"ERR_NOT_CONTROLLER\\\");\\n        require(_records[token].bound, \\\"ERR_NOT_BOUND\\\");\\n        require(!_finalized, \\\"ERR_IS_FINALIZED\\\");\\n\\n        require(denorm >= MIN_WEIGHT, \\\"ERR_MIN_WEIGHT\\\");\\n        require(denorm <= MAX_WEIGHT, \\\"ERR_MAX_WEIGHT\\\");\\n        require(balance >= MIN_BALANCE, \\\"ERR_MIN_BALANCE\\\");\\n\\n        // Adjust the denorm and totalWeight\\n        uint oldWeight = _records[token].denorm;\\n        if (denorm > oldWeight) {\\n            _totalWeight = badd(_totalWeight, bsub(denorm, oldWeight));\\n            require(_totalWeight <= MAX_TOTAL_WEIGHT, \\\"ERR_MAX_TOTAL_WEIGHT\\\");\\n        } else if (denorm < oldWeight) {\\n            _totalWeight = bsub(_totalWeight, bsub(oldWeight, denorm));\\n        }\\n        _records[token].denorm = denorm;\\n\\n        // Adjust the balance record and actual token balance\\n        uint oldBalance = _records[token].balance;\\n        _records[token].balance = balance;\\n        if (balance > oldBalance) {\\n            _pullUnderlying(token, msg.sender, bsub(balance, oldBalance));\\n        } else if (balance < oldBalance) {\\n            // In this case liquidity is being withdrawn, so charge EXIT_FEE\\n            uint tokenBalanceWithdrawn = bsub(oldBalance, balance);\\n            _pushUnderlying(token, msg.sender, tokenBalanceWithdrawn);\\n        }\\n    }\\n\\n    function execute(\\n        address _target,\\n        uint _value,\\n        bytes calldata _data\\n    ) external _logs_ _lock_ returns (bytes memory _returnValue) {\\n        require(msg.sender == _controller, \\\"ERR_NOT_CONTROLLER\\\");\\n        require(!_finalized, \\\"ERR_IS_FINALIZED\\\");\\n\\n        _returnValue = _target.functionCallWithValue(_data, _value);\\n\\n        return _returnValue;\\n    }\\n\\n    function unbind(address token) external _logs_ _lock_ {\\n        require(msg.sender == _controller, \\\"ERR_NOT_CONTROLLER\\\");\\n        require(_records[token].bound, \\\"ERR_NOT_BOUND\\\");\\n        require(!_finalized, \\\"ERR_IS_FINALIZED\\\");\\n\\n        uint tokenBalance = _records[token].balance;\\n\\n        _totalWeight = bsub(_totalWeight, _records[token].denorm);\\n\\n        // Swap the token-to-unbind with the last token,\\n        // then delete the last token\\n        uint index = _records[token].index;\\n        uint last = _tokens.length - 1;\\n        _tokens[index] = _tokens[last];\\n        _records[_tokens[index]].index = index;\\n        _tokens.pop();\\n        _records[token] = Record({bound: false, index: 0, denorm: 0, balance: 0});\\n\\n        _pushUnderlying(token, msg.sender, tokenBalance);\\n    }\\n\\n    function unbindPure(address token) external _logs_ _lock_ {\\n        require(msg.sender == _controller, \\\"ERR_NOT_CONTROLLER\\\");\\n        require(_records[token].bound, \\\"ERR_NOT_BOUND\\\");\\n        require(!_finalized, \\\"ERR_IS_FINALIZED\\\");\\n\\n        // Swap the token-to-unbind with the last token,\\n        // then delete the last token\\n        uint index = _records[token].index;\\n        uint last = _tokens.length - 1;\\n        _tokens[index] = _tokens[last];\\n        _records[_tokens[index]].index = index;\\n        _tokens.pop();\\n        _records[token] = Record({bound: false, index: 0, denorm: 0, balance: 0});\\n    }\\n\\n    function rebindPure(\\n        address token,\\n        uint balance,\\n        uint denorm,\\n        bool isBound\\n    ) public _logs_ _lock_ {\\n        require(msg.sender == _controller, \\\"ERR_NOT_CONTROLLER\\\");\\n\\n        if (!isBound) {\\n            require(_tokens.length < MAX_BOUND_TOKENS, \\\"ERR_MAX_TOKENS\\\");\\n\\n            _records[token] = Record({\\n                bound: true,\\n                index: _tokens.length,\\n                denorm: denorm,\\n                balance: balance\\n            });\\n            _tokens.push(token);\\n        } else {\\n            _records[token].denorm = denorm;\\n            _records[token].balance = balance;\\n        }\\n    }\\n\\n    // Absorb any tokens that have been sent to this contract into the pool\\n    function gulp(address token) external _logs_ _lock_ {\\n        require(IConfigurableRightsPool(_controller).adminList(msg.sender), 'NOT_ADMIN');\\n        require(_records[token].bound, \\\"ERR_NOT_BOUND\\\");\\n        _records[token].balance = IERC20(token).balanceOf(address(this));\\n    }\\n\\n    function joinPool(uint poolAmountOut, uint[] calldata maxAmountsIn) external _logs_ _lock_ {\\n        require(msg.sender == _controller, \\\"ERR_NOT_CONTROLLER\\\");\\n        require(_finalized, \\\"ERR_NOT_FINALIZED\\\");\\n\\n        uint poolTotal = this.totalSupply();\\n        uint ratio = bdiv(poolAmountOut, poolTotal);\\n        require(ratio != 0, \\\"ERR_MATH_APPROX\\\");\\n\\n        for (uint i = 0; i < _tokens.length; i++) {\\n            address t = _tokens[i];\\n            uint bal = _records[t].balance;\\n            uint tokenAmountIn = bmul(ratio, bal);\\n            require(tokenAmountIn != 0, \\\"ERR_MATH_APPROX\\\");\\n            require(tokenAmountIn <= maxAmountsIn[i], \\\"ERR_LIMIT_IN\\\");\\n            _records[t].balance = badd(_records[t].balance, tokenAmountIn);\\n            emit LOG_JOIN(msg.sender, t, tokenAmountIn);\\n            _pullUnderlying(t, msg.sender, tokenAmountIn);\\n        }\\n        _mintPoolShare(poolAmountOut);\\n        _pushPoolShare(msg.sender, poolAmountOut);\\n    }\\n\\n    function exitPool(uint poolAmountIn, uint[] calldata minAmountsOut) external _logs_ _lock_ {\\n        require(msg.sender == _controller, \\\"ERR_NOT_CONTROLLER\\\");\\n        require(_finalized, \\\"ERR_NOT_FINALIZED\\\");\\n\\n        uint poolTotal = this.totalSupply();\\n        uint ratio = bdiv(poolAmountIn, poolTotal);\\n        require(ratio != 0, \\\"ERR_MATH_APPROX\\\");\\n\\n        _pullPoolShare(msg.sender, poolAmountIn);\\n        _burnPoolShare(poolAmountIn);\\n\\n        for (uint i = 0; i < _tokens.length; i++) {\\n            address t = _tokens[i];\\n            uint bal = _records[t].balance;\\n            uint tokenAmountOut = bmul(ratio, bal);\\n            require(tokenAmountOut != 0, \\\"ERR_MATH_APPROX\\\");\\n            require(tokenAmountOut >= minAmountsOut[i], \\\"ERR_LIMIT_OUT\\\");\\n            _records[t].balance = bsub(_records[t].balance, tokenAmountOut);\\n            emit LOG_EXIT(msg.sender, t, tokenAmountOut);\\n            _pushUnderlying(t, msg.sender, tokenAmountOut);\\n        }\\n    }\\n\\n    function _pullUnderlying(\\n        address erc20,\\n        address from,\\n        uint amount\\n    ) internal {\\n        IERC20(erc20).safeTransferFrom(from, address(this), amount);\\n    }\\n\\n    function _pushUnderlying(\\n        address erc20,\\n        address to,\\n        uint amount\\n    ) internal {\\n        IERC20(erc20).safeTransfer(to, amount);\\n    }\\n\\n    function _pullPoolShare(address from, uint amount) internal {\\n        _pull(from, amount);\\n    }\\n\\n    function _pushPoolShare(address to, uint amount) internal {\\n        _push(to, amount);\\n    }\\n\\n    function _mintPoolShare(uint amount) internal {\\n        _mint(amount);\\n    }\\n\\n    function _burnPoolShare(uint amount) internal {\\n        _burn(amount);\\n    }\\n\\n    receive() external payable {}\\n}\\n\"\r\n    },\r\n    \"contracts/base/LpToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"./Num.sol\\\";\\nimport \\\"../interfaces/IERC20.sol\\\";\\n\\n// Highly opinionated token implementation\\n\\ncontract LpTokenBase is Num {\\n    mapping(address => uint) internal _balance;\\n    mapping(address => mapping(address => uint)) internal _allowance;\\n    uint internal _totalSupply;\\n\\n    event Approval(address indexed src, address indexed dst, uint amt);\\n    event Transfer(address indexed src, address indexed dst, uint amt);\\n\\n    function _mint(uint amt) internal {\\n        _balance[address(this)] = badd(_balance[address(this)], amt);\\n        _totalSupply = badd(_totalSupply, amt);\\n        emit Transfer(address(0), address(this), amt);\\n    }\\n\\n    function _burn(uint amt) internal {\\n        require(_balance[address(this)] >= amt, \\\"ERR_INSUFFICIENT_BAL\\\");\\n        _balance[address(this)] = bsub(_balance[address(this)], amt);\\n        _totalSupply = bsub(_totalSupply, amt);\\n        emit Transfer(address(this), address(0), amt);\\n    }\\n\\n    function _move(\\n        address src,\\n        address dst,\\n        uint amt\\n    ) internal {\\n        require(_balance[src] >= amt, \\\"ERR_INSUFFICIENT_BAL\\\");\\n        _balance[src] = bsub(_balance[src], amt);\\n        _balance[dst] = badd(_balance[dst], amt);\\n        emit Transfer(src, dst, amt);\\n    }\\n\\n    function _push(address to, uint amt) internal {\\n        _move(address(this), to, amt);\\n    }\\n\\n    function _pull(address from, uint amt) internal {\\n        _move(from, address(this), amt);\\n    }\\n}\\n\\ncontract LpToken is LpTokenBase, IERC20 {\\n    string private _name = \\\"Desyn Pool Token\\\";\\n    string private _symbol = \\\"DPT\\\";\\n    uint8 private _decimals = 18;\\n\\n    function name() external view returns (string memory) {\\n        return _name;\\n    }\\n\\n    function symbol() external view override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    function decimals() external view override returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    function allowance(address src, address dst) external view override returns (uint) {\\n        return _allowance[src][dst];\\n    }\\n\\n    function balanceOf(address whom) external view override returns (uint) {\\n        return _balance[whom];\\n    }\\n\\n    function totalSupply() external view override returns (uint) {\\n        return _totalSupply;\\n    }\\n\\n    function approve(address dst, uint amt) external override returns (bool) {\\n        _allowance[msg.sender][dst] = amt;\\n        emit Approval(msg.sender, dst, amt);\\n        return true;\\n    }\\n\\n    function increaseApproval(address dst, uint amt) external returns (bool) {\\n        _allowance[msg.sender][dst] = badd(_allowance[msg.sender][dst], amt);\\n        emit Approval(msg.sender, dst, _allowance[msg.sender][dst]);\\n        return true;\\n    }\\n\\n    function decreaseApproval(address dst, uint amt) external returns (bool) {\\n        uint oldValue = _allowance[msg.sender][dst];\\n        if (amt > oldValue) {\\n            _allowance[msg.sender][dst] = 0;\\n        } else {\\n            _allowance[msg.sender][dst] = bsub(oldValue, amt);\\n        }\\n        emit Approval(msg.sender, dst, _allowance[msg.sender][dst]);\\n        return true;\\n    }\\n\\n    function transfer(address dst, uint amt) external override returns (bool) {\\n        require(dst != address(0),\\\"ERR_BAD_RECIVER\\\");\\n        _move(msg.sender, dst, amt);\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address src,\\n        address dst,\\n        uint amt\\n    ) external override returns (bool) {\\n        require(dst != address(0),\\\"ERR_BAD_RECIVER\\\");\\n        require(msg.sender == src || amt <= _allowance[src][msg.sender], \\\"ERR_LPTOKEN_BAD_CALLER\\\");\\n        _move(src, dst, amt);\\n        if (msg.sender != src && _allowance[src][msg.sender] != uint(-1)) {\\n            _allowance[src][msg.sender] = bsub(_allowance[src][msg.sender], amt);\\n            emit Approval(src, msg.sender, _allowance[src][msg.sender]);\\n        }\\n        return true;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 20\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"share\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shareAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenReturn\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountReturn\",\"type\":\"uint256\"}],\"name\":\"SmartExitPool\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"shareReturn\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountReturn\",\"type\":\"uint256\"}],\"name\":\"SmartJoinPool\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"FACTORY\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"STBT\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IConfigurableRightsPool\",\"name\":\"crp\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"sort\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"token\",\"type\":\"address[]\"}],\"name\":\"addTokenToWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract RebalaceAdapter\",\"name\":\"rebalanceAdapter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"etf\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approveUnderlying\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IConfigurableRightsPool\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"poolAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"minAmountsOut\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"minSwapReturn\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"handleToken\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"aggregator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rebalanceAdapter\",\"type\":\"address\"},{\"internalType\":\"enum IAggregator.SwapType\",\"name\":\"swapType\",\"type\":\"uint8\"}],\"internalType\":\"struct IAggregator.SwapInfoBase\",\"name\":\"swapBase\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct IAggregator.SwapData[]\",\"name\":\"swapDatas\",\"type\":\"tuple[]\"}],\"name\":\"autoExitSmartPool\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IConfigurableRightsPool\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"kol\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"issueAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minPoolAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"handleToken\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"aggregator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rebalanceAdapter\",\"type\":\"address\"},{\"internalType\":\"enum IAggregator.SwapType\",\"name\":\"swapType\",\"type\":\"uint8\"}],\"internalType\":\"struct IAggregator.SwapInfoBase\",\"name\":\"swapBase\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct IAggregator.SwapData[]\",\"name\":\"swapDatas\",\"type\":\"tuple[]\"}],\"name\":\"autoJoinSmartPool\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"claimKolReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IConfigurableRightsPool\",\"name\":\"crp\",\"type\":\"address\"}],\"name\":\"claimManagementFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"claimManagersReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract FactoryActions\",\"name\":\"factory\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"balances\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"weights\",\"type\":\"uint256[]\"},{\"internalType\":\"bool\",\"name\":\"finalize\",\"type\":\"bool\"}],\"name\":\"create\",\"outputs\":[{\"internalType\":\"contract LiquidityPoolActions\",\"name\":\"pool\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ICRPFactory\",\"name\":\"factory\",\"type\":\"address\"},{\"internalType\":\"contract FactoryActions\",\"name\":\"coreFactory\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"poolTokenSymbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"poolTokenName\",\"type\":\"string\"},{\"internalType\":\"address[]\",\"name\":\"constituentTokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenBalances\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenWeights\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"managerFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"redeemFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"issueFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"perfermanceFee\",\"type\":\"uint256\"},{\"internalType\":\"enum SmartPoolManager.Etypes\",\"name\":\"etype\",\"type\":\"uint8\"}],\"internalType\":\"struct IConfigurableRightsPool.PoolParams\",\"name\":\"poolParams\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"initialSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collectPeriod\",\"type\":\"uint256\"},{\"internalType\":\"enum SmartPoolManager.Period\",\"name\":\"period\",\"type\":\"uint8\"}],\"internalType\":\"struct IConfigurableRightsPool.CrpParams\",\"name\":\"crpParams\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"canWhitelistLPs\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"canTokenWhiteLists\",\"type\":\"bool\"}],\"internalType\":\"struct RightsManager.Rights\",\"name\":\"rights\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"}],\"internalType\":\"struct SmartPoolManager.levelParams\",\"name\":\"firstLevel\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"}],\"internalType\":\"struct SmartPoolManager.levelParams\",\"name\":\"secondLevel\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"}],\"internalType\":\"struct SmartPoolManager.levelParams\",\"name\":\"thirdLevel\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"}],\"internalType\":\"struct SmartPoolManager.levelParams\",\"name\":\"fourLevel\",\"type\":\"tuple\"}],\"internalType\":\"struct SmartPoolManager.feeParams\",\"name\":\"managerFee\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"}],\"internalType\":\"struct SmartPoolManager.levelParams\",\"name\":\"firstLevel\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"}],\"internalType\":\"struct SmartPoolManager.levelParams\",\"name\":\"secondLevel\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"}],\"internalType\":\"struct SmartPoolManager.levelParams\",\"name\":\"thirdLevel\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"}],\"internalType\":\"struct SmartPoolManager.levelParams\",\"name\":\"fourLevel\",\"type\":\"tuple\"}],\"internalType\":\"struct SmartPoolManager.feeParams\",\"name\":\"issueFee\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"}],\"internalType\":\"struct SmartPoolManager.levelParams\",\"name\":\"firstLevel\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"}],\"internalType\":\"struct SmartPoolManager.levelParams\",\"name\":\"secondLevel\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"}],\"internalType\":\"struct SmartPoolManager.levelParams\",\"name\":\"thirdLevel\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"}],\"internalType\":\"struct SmartPoolManager.levelParams\",\"name\":\"fourLevel\",\"type\":\"tuple\"}],\"internalType\":\"struct SmartPoolManager.feeParams\",\"name\":\"redeemFee\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"}],\"internalType\":\"struct SmartPoolManager.levelParams\",\"name\":\"firstLevel\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"}],\"internalType\":\"struct SmartPoolManager.levelParams\",\"name\":\"secondLevel\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"}],\"internalType\":\"struct SmartPoolManager.levelParams\",\"name\":\"thirdLevel\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"}],\"internalType\":\"struct SmartPoolManager.levelParams\",\"name\":\"fourLevel\",\"type\":\"tuple\"}],\"internalType\":\"struct SmartPoolManager.feeParams\",\"name\":\"perfermanceFee\",\"type\":\"tuple\"}],\"internalType\":\"struct SmartPoolManager.KolPoolParams\",\"name\":\"kolPoolParams\",\"type\":\"tuple\"},{\"internalType\":\"address[]\",\"name\":\"owners\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"ownerPercentage\",\"type\":\"uint256[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"bspFloor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bspCap\",\"type\":\"uint256\"}],\"internalType\":\"struct SmartPoolManager.PoolTokenRange\",\"name\":\"tokenRange\",\"type\":\"tuple\"}],\"name\":\"createSmartPool\",\"outputs\":[{\"internalType\":\"contract IConfigurableRightsPool\",\"name\":\"crp\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IConfigurableRightsPool\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"poolAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"minAmountsOut\",\"type\":\"uint256[]\"}],\"name\":\"exitPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract LiquidityPoolActions\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"finalize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract LiquidityPoolActions\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"poolAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"maxAmountsIn\",\"type\":\"uint256[]\"}],\"name\":\"joinPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IConfigurableRightsPool\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"poolAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"maxAmountsIn\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"kol\",\"type\":\"address\"}],\"name\":\"joinSmartPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract RebalaceAdapter\",\"name\":\"rebalanceAdapter\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"etf\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"aggregator\",\"type\":\"address\"},{\"internalType\":\"enum RebalaceAdapter.SwapType\",\"name\":\"swapType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct RebalaceAdapter.RebalanceInfo\",\"name\":\"rebalanceInfo\",\"type\":\"tuple\"}],\"name\":\"rebalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IConfigurableRightsPool\",\"name\":\"crp\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"}],\"name\":\"removeWhitelistedLiquidityProvider\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IConfigurableRightsPool\",\"name\":\"crp\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"newCap\",\"type\":\"uint256\"}],\"name\":\"setCap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract AbstractPool\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"newController\",\"type\":\"address\"}],\"name\":\"setController\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract AbstractPool\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_owners\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_ownerPercentage\",\"type\":\"uint256[]\"}],\"name\":\"setManagersInfo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract AbstractPool\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"publicSwap\",\"type\":\"bool\"}],\"name\":\"setPublicSwap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IConfigurableRightsPool\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"snapshotBeginAssets\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IConfigurableRightsPool\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"snapshotEndAssets\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IConfigurableRightsPool\",\"name\":\"crp\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"}],\"name\":\"whitelistLiquidityProvider\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Actions", "CompilerVersion": "v0.6.12+commit.27d51765", "OptimizationUsed": "1", "Runs": "20", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}