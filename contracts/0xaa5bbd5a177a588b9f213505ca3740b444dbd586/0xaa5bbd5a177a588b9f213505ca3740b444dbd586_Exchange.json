{"SourceCode": "// Saturn Protocol\r\n\r\n// File: contracts/SafeMath.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// File: contracts/BytesLib.sol\r\n// from\r\n// https://github.com/GNSPS/solidity-bytes-utils/blob/master/contracts/BytesLib.sol\r\n\r\n\r\nlibrary BytesLib {\r\n  function toAddress(bytes _bytes, uint _start) internal pure returns (address) {\r\n    require(_bytes.length >= (_start + 20));\r\n    address tempAddress;\r\n\r\n    assembly {\r\n      tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\r\n    }\r\n\r\n    return tempAddress;\r\n  }\r\n\r\n  function toUint(bytes _bytes, uint _start) internal pure returns (uint256) {\r\n    require(_bytes.length >= (_start + 32));\r\n    uint256 tempUint;\r\n\r\n    assembly {\r\n      tempUint := mload(add(add(_bytes, 0x20), _start))\r\n    }\r\n\r\n    return tempUint;\r\n  }\r\n}\r\n\r\n// File: contracts/ERC223.sol\r\n\r\ncontract ERC223 {\r\n  uint public totalSupply;\r\n  function balanceOf(address who) constant public returns (uint);\r\n\r\n  function name() constant public returns (string _name);\r\n  function symbol() constant public returns (string _symbol);\r\n  function decimals() constant public returns (uint8 _decimals);\r\n  function totalSupply() constant public returns (uint256 _supply);\r\n\r\n  function transfer(address to, uint value) public returns (bool ok);\r\n  function transfer(address to, uint value, bytes data) public returns (bool ok);\r\n  event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n  event ERC223Transfer(address indexed _from, address indexed _to, uint256 _value, bytes _data);\r\n}\r\n\r\ncontract ContractReceiver {\r\n  function tokenFallback(address _from, uint _value, bytes _data) public;\r\n}\r\n\r\ncontract ERC223I is ERC223 {\r\n  using SafeMath for uint;\r\n\r\n  mapping(address => uint) balances;\r\n\r\n  string public name;\r\n  string public symbol;\r\n  uint8 public decimals;\r\n  uint256 public totalSupply;\r\n\r\n\r\n  function name() constant public returns (string _name) {\r\n    return name;\r\n  }\r\n  function symbol() constant public returns (string _symbol) {\r\n    return symbol;\r\n  }\r\n  function decimals() constant public returns (uint8 _decimals) {\r\n    return decimals;\r\n  }\r\n  function totalSupply() constant public returns (uint256 _totalSupply) {\r\n    return totalSupply;\r\n  }\r\n\r\n  function transfer(address _to, uint _value, bytes _data) public returns (bool success) {\r\n    if (isContract(_to)) {\r\n      return transferToContract(_to, _value, _data);\r\n    } else {\r\n      return transferToAddress(_to, _value, _data);\r\n    }\r\n  }\r\n\r\n  function transfer(address _to, uint _value) public returns (bool success) {\r\n    bytes memory empty;\r\n    if (isContract(_to)) {\r\n      return transferToContract(_to, _value, empty);\r\n    } else {\r\n      return transferToAddress(_to, _value, empty);\r\n    }\r\n  }\r\n\r\n  function isContract(address _addr) private view returns (bool is_contract) {\r\n    uint length;\r\n    assembly {\r\n      length := extcodesize(_addr)\r\n    }\r\n    return (length > 0);\r\n  }\r\n\r\n  function transferToAddress(address _to, uint _value, bytes _data) private returns (bool success) {\r\n    if (balanceOf(msg.sender) < _value) revert();\r\n    balances[msg.sender] = balanceOf(msg.sender).sub(_value);\r\n    balances[_to] = balanceOf(_to).add(_value);\r\n    Transfer(msg.sender, _to, _value);\r\n    ERC223Transfer(msg.sender, _to, _value, _data);\r\n    return true;\r\n  }\r\n\r\n  function transferToContract(address _to, uint _value, bytes _data) private returns (bool success) {\r\n    if (balanceOf(msg.sender) < _value) revert();\r\n    balances[msg.sender] = balanceOf(msg.sender).sub(_value);\r\n    balances[_to] = balanceOf(_to).add(_value);\r\n    ContractReceiver reciever = ContractReceiver(_to);\r\n    reciever.tokenFallback(msg.sender, _value, _data);\r\n    Transfer(msg.sender, _to, _value);\r\n    ERC223Transfer(msg.sender, _to, _value, _data);\r\n    return true;\r\n  }\r\n\r\n  function balanceOf(address _owner) constant public returns (uint balance) {\r\n    return balances[_owner];\r\n  }\r\n}\r\n\r\n// File: contracts/Exchange.sol\r\n\r\n// Saturn Protocol\r\n\r\ncontract ERC20 {\r\n    function totalSupply() public view returns (uint);\r\n    function balanceOf(address holder) public view returns (uint);\r\n    function allowance(address holder, address other) public view returns (uint);\r\n\r\n    function approve(address other, uint amount) public returns (bool);\r\n    function transfer(address to, uint amount) public returns (bool);\r\n    function transferFrom(\r\n        address from, address to, uint amount\r\n    ) public returns (bool);\r\n}\r\n\r\ncontract Exchange is ContractReceiver {\r\n  using SafeMath for uint256;\r\n  using BytesLib for bytes;\r\n\r\n  bool private rentrancy_lock = false;\r\n  modifier nonReentrant() {\r\n    require(!rentrancy_lock);\r\n    rentrancy_lock = true;\r\n    _;\r\n    rentrancy_lock = false;\r\n  }\r\n\r\n  struct Order {\r\n    address owner;\r\n    bool    active;\r\n    address sellToken;\r\n    address buyToken;\r\n    address ring;\r\n    uint256 amount;\r\n    uint256 priceMul;\r\n    uint256 priceDiv;\r\n  }\r\n\r\n  // person => token => balance\r\n  mapping(address => mapping(address => uint256)) private balances;\r\n  mapping(uint256 => Order) private orderBook;\r\n  uint256 public orderCount;\r\n  address private etherAddress = 0x0;\r\n\r\n  address private saturnToken;\r\n  address private admin;\r\n  uint256 public tradeMiningBalance;\r\n  address public treasury;\r\n\r\n  uint256 public feeMul;\r\n  uint256 public feeDiv;\r\n  uint256 public tradeMiningMul;\r\n  uint256 public tradeMiningDiv;\r\n\r\n  event NewOrder(\r\n    uint256 id,\r\n    address owner,\r\n    address sellToken,\r\n    address buyToken,\r\n    address ring,\r\n    uint256 amount,\r\n    uint256 priceMul,\r\n    uint256 priceDiv,\r\n    uint256 time\r\n  );\r\n\r\n  event OrderCancelled(\r\n    uint256 id,\r\n    uint256 time\r\n  );\r\n\r\n  event OrderFulfilled(\r\n    uint256 id,\r\n    uint256 time\r\n  );\r\n\r\n  event Trade(\r\n    address from,\r\n    address to,\r\n    uint256 orderId,\r\n    uint256 soldTokens,\r\n    uint256 boughtTokens,\r\n    uint256 feePaid,\r\n    uint256 time\r\n  );\r\n\r\n  event Mined(\r\n    address trader,\r\n    uint256 amount,\r\n    uint256 time\r\n  );\r\n\r\n  function Exchange(\r\n    address _saturnToken,\r\n    address _treasury,\r\n    uint256 _feeMul,\r\n    uint256 _feeDiv,\r\n    uint256 _tradeMiningMul,\r\n    uint256 _tradeMiningDiv\r\n  ) public {\r\n    saturnToken    = _saturnToken;\r\n    treasury       = _treasury;\r\n    feeMul         = _feeMul;\r\n    feeDiv         = _feeDiv;\r\n    tradeMiningMul = _tradeMiningMul;\r\n    tradeMiningDiv = _tradeMiningDiv;\r\n    admin          = msg.sender;\r\n  }\r\n\r\n  function() payable public { revert(); }\r\n\r\n  //////////////////\r\n  // public views //\r\n  //////////////////\r\n  // add views for prices too\r\n  // and for order owner too\r\n\r\n  function getBalance(address token, address user) view public returns(uint256) {\r\n    return balances[user][token];\r\n  }\r\n\r\n  function isOrderActive(uint256 orderId) view public returns(bool) {\r\n    return orderBook[orderId].active;\r\n  }\r\n\r\n  function remainingAmount(uint256 orderId) view public returns(uint256) {\r\n    return orderBook[orderId].amount;\r\n  }\r\n\r\n  function getBuyTokenAmount(uint256 desiredSellTokenAmount, uint256 orderId) public view returns(uint256 amount) {\r\n    require(desiredSellTokenAmount > 0);\r\n    Order storage order = orderBook[orderId];\r\n\r\n    if (order.sellToken == etherAddress || order.buyToken == etherAddress) {\r\n      uint256 feediff = feeDiv.sub(feeMul);\r\n      amount = desiredSellTokenAmount.mul(order.priceDiv).mul(feeDiv).div(order.priceMul).div(feediff);\r\n    } else {\r\n      amount = desiredSellTokenAmount.mul(order.priceDiv).div(order.priceMul);\r\n    }\r\n    require(amount > 0);\r\n  }\r\n\r\n  function calcFees(uint256 amount, uint256 orderId) public view returns(uint256 fees) {\r\n    Order storage order = orderBook[orderId];\r\n\r\n    if (order.sellToken == etherAddress) {\r\n      uint256 sellTokenAmount = amount.mul(order.priceMul).div(order.priceDiv);\r\n      fees = sellTokenAmount.mul(feeMul).div(feeDiv);\r\n    } else if (order.buyToken == etherAddress) {\r\n      fees = amount.mul(feeMul).div(feeDiv);\r\n    } else {\r\n      fees = 0;\r\n    }\r\n    return fees;\r\n  }\r\n\r\n  function tradeMiningAmount(uint256 fees, uint256 orderId) public view returns(uint256) {\r\n    if (fees == 0) { return 0; }\r\n    Order storage order = orderBook[orderId];\r\n    if (!order.active) { return 0; }\r\n    uint256 tokenAmount = fees.mul(tradeMiningMul).div(tradeMiningDiv);\r\n\r\n    if (tradeMiningBalance < tokenAmount) {\r\n      return tradeMiningBalance;\r\n    } else {\r\n      return tokenAmount;\r\n    }\r\n  }\r\n\r\n  ////////////////////\r\n  // public methods //\r\n  ////////////////////\r\n\r\n  function withdrawTradeMining() public {\r\n    if (msg.sender != admin) { revert(); }\r\n    require(tradeMiningBalance > 0);\r\n\r\n    uint toSend = tradeMiningBalance;\r\n    tradeMiningBalance = 0;\r\n    require(sendTokensTo(admin, toSend, saturnToken));\r\n  }\r\n\r\n  function changeTradeMiningPrice(uint256 newMul, uint256 newDiv) public {\r\n    if (msg.sender != admin) { revert(); }\r\n    require(newDiv != 0);\r\n    tradeMiningMul = newMul;\r\n    tradeMiningDiv = newDiv;\r\n  }\r\n\r\n  // handle incoming ERC223 tokens\r\n  function tokenFallback(address from, uint value, bytes data) public {\r\n    // depending on length of data\r\n    // this should be either an order creating transaction\r\n    // or an order taking transaction\r\n    // or a transaction allocating tokens for trade mining\r\n    if (data.length == 0 && msg.sender == saturnToken) {\r\n      _topUpTradeMining(value);\r\n    } else if (data.length == 84) {\r\n      _newOrder(from, msg.sender, data.toAddress(64), value, data.toUint(0), data.toUint(32), etherAddress);\r\n    } else if (data.length == 104) {\r\n      _newOrder(from, msg.sender, data.toAddress(64), value, data.toUint(0), data.toUint(32), data.toAddress(84));\r\n    } else if (data.length == 32) {\r\n      _executeOrder(from, data.toUint(0), msg.sender, value);\r\n    } else {\r\n      // unknown payload!\r\n      revert();\r\n    }\r\n  }\r\n\r\n  function sellEther(\r\n    address buyToken,\r\n    uint256 priceMul,\r\n    uint256 priceDiv\r\n  ) public payable returns(uint256 orderId) {\r\n    require(msg.value > 0);\r\n    return _newOrder(msg.sender, etherAddress, buyToken, msg.value, priceMul, priceDiv, etherAddress);\r\n  }\r\n\r\n  function sellEtherWithRing(\r\n    address buyToken,\r\n    uint256 priceMul,\r\n    uint256 priceDiv,\r\n    address ring\r\n  ) public payable returns(uint256 orderId) {\r\n    require(msg.value > 0);\r\n    return _newOrder(msg.sender, etherAddress, buyToken, msg.value, priceMul, priceDiv, ring);\r\n  }\r\n\r\n  function buyOrderWithEth(uint256 orderId) public payable {\r\n    require(msg.value > 0);\r\n    _executeOrder(msg.sender, orderId, etherAddress, msg.value);\r\n  }\r\n\r\n  function sellERC20Token(\r\n    address sellToken,\r\n    address buyToken,\r\n    uint256 amount,\r\n    uint256 priceMul,\r\n    uint256 priceDiv\r\n  ) public returns(uint256 orderId) {\r\n    require(amount > 0);\r\n    uint256 pulledAmount = pullTokens(sellToken, amount);\r\n    return _newOrder(msg.sender, sellToken, buyToken, pulledAmount, priceMul, priceDiv, etherAddress);\r\n  }\r\n\r\n  function sellERC20TokenWithRing(\r\n    address sellToken,\r\n    address buyToken,\r\n    uint256 amount,\r\n    uint256 priceMul,\r\n    uint256 priceDiv,\r\n    address ring\r\n  ) public returns(uint256 orderId) {\r\n    require(amount > 0);\r\n    uint256 pulledAmount = pullTokens(sellToken, amount);\r\n    return _newOrder(msg.sender, sellToken, buyToken, pulledAmount, priceMul, priceDiv, ring);\r\n  }\r\n\r\n  function buyOrderWithERC20Token(\r\n    uint256 orderId,\r\n    address token,\r\n    uint256 amount\r\n  ) public {\r\n    require(amount > 0);\r\n    require(pullTokens(token, amount) > 0);\r\n    _executeOrder(msg.sender, orderId, token, amount);\r\n  }\r\n\r\n  function cancelOrder(uint256 orderId) public nonReentrant {\r\n    Order storage order = orderBook[orderId];\r\n    require(order.amount > 0);\r\n    require(order.active);\r\n    require(msg.sender == order.owner);\r\n\r\n    balances[msg.sender][order.sellToken] = balances[msg.sender][order.sellToken].sub(order.amount);\r\n    require(sendTokensTo(order.owner, order.amount, order.sellToken));\r\n\r\n    // deleting the order refunds the caller some gas\r\n    // this also sets order.active to false\r\n    delete orderBook[orderId];\r\n    emit OrderCancelled(orderId, now);\r\n  }\r\n\r\n  /////////////////////\r\n  // private methods //\r\n  /////////////////////\r\n\r\n  function _newOrder(\r\n    address owner,\r\n    address sellToken,\r\n    address buyToken,\r\n    uint256 amount,\r\n    uint256 priceMul,\r\n    uint256 priceDiv,\r\n    address ring\r\n  ) private nonReentrant returns(uint256 orderId) {\r\n    /////////////////////////\r\n    // step 1. validations //\r\n    /////////////////////////\r\n    require(amount > 0);\r\n    require(priceMul > 0);\r\n    require(priceDiv > 0);\r\n    require(sellToken != buyToken);\r\n    ///////////////////////////////\r\n    // step 2. Update order book //\r\n    ///////////////////////////////\r\n    orderId = orderCount++;\r\n    orderBook[orderId] = Order(owner, true, sellToken, buyToken, ring, amount, priceMul, priceDiv);\r\n    balances[owner][sellToken] = balances[owner][sellToken].add(amount);\r\n\r\n    emit NewOrder(orderId, owner, sellToken, buyToken, ring, amount, priceMul, priceDiv, now);\r\n  }\r\n\r\n  function _executeBuyOrder(address trader, uint256 orderId, uint256 buyTokenAmount) private returns(uint256) {\r\n    // buytoken: tkn\r\n    // selltoken: ether\r\n    Order storage order = orderBook[orderId];\r\n    uint256 sellTokenAmount = buyTokenAmount.mul(order.priceMul).div(order.priceDiv);\r\n    uint256 fees = sellTokenAmount.mul(feeMul).div(feeDiv);\r\n\r\n    require(sellTokenAmount > 0);\r\n    require(sellTokenAmount <= order.amount);\r\n    order.amount = order.amount.sub(sellTokenAmount);\r\n    // send tokens to order owner\r\n    require(sendTokensTo(order.owner, buyTokenAmount, order.buyToken));\r\n    // send ether to trader\r\n    require(sendTokensTo(trader, sellTokenAmount.sub(fees), order.sellToken));\r\n\r\n    emit Trade(trader, order.owner, orderId, sellTokenAmount.sub(fees), buyTokenAmount, fees, now);\r\n    return fees;\r\n  }\r\n\r\n  function _executeSellOrder(address trader, uint256 orderId, uint256 buyTokenAmount) private returns(uint256) {\r\n    // buytoken: ether\r\n    // selltoken: tkn\r\n    Order storage order = orderBook[orderId];\r\n    uint256 fees = buyTokenAmount.mul(feeMul).div(feeDiv);\r\n    uint256 sellTokenAmount = buyTokenAmount.sub(fees).mul(order.priceMul).div(order.priceDiv);\r\n\r\n\r\n    require(sellTokenAmount > 0);\r\n    require(sellTokenAmount <= order.amount);\r\n    order.amount = order.amount.sub(sellTokenAmount);\r\n    // send ether to order owner\r\n    require(sendTokensTo(order.owner, buyTokenAmount.sub(fees), order.buyToken));\r\n    // send token to trader\r\n    require(sendTokensTo(trader, sellTokenAmount, order.sellToken));\r\n\r\n    emit Trade(trader, order.owner, orderId, sellTokenAmount, buyTokenAmount.sub(fees), fees, now);\r\n    return fees;\r\n  }\r\n\r\n  function _executeTokenSwap(address trader, uint256 orderId, uint256 buyTokenAmount) private returns(uint256) {\r\n    // no ether was exchanged\r\n    Order storage order = orderBook[orderId];\r\n    uint256 sellTokenAmount = buyTokenAmount.mul(order.priceMul).div(order.priceDiv);\r\n\r\n    require(sellTokenAmount > 0);\r\n    require(sellTokenAmount <= order.amount);\r\n    order.amount = order.amount.sub(sellTokenAmount);\r\n\r\n    require(sendTokensTo(order.owner, buyTokenAmount, order.buyToken));\r\n    require(order.active);\r\n    require(sendTokensTo(trader, sellTokenAmount, order.sellToken));\r\n\r\n    emit Trade(trader, order.owner, orderId, sellTokenAmount, buyTokenAmount, 0, now);\r\n    return 0;\r\n  }\r\n\r\n  function _executeOrder(address trader, uint256 orderId, address buyToken, uint256 buyTokenAmount) private nonReentrant {\r\n    /////////////////////////\r\n    // step 0. validations //\r\n    /////////////////////////\r\n    require(orderId < orderCount);\r\n    require(buyTokenAmount > 0);\r\n    Order storage order = orderBook[orderId];\r\n    require(order.active);\r\n    require(trader != order.owner);\r\n    require(buyToken == order.buyToken);\r\n\r\n    // enforce exclusivity\r\n    if (order.ring != etherAddress) { require(order.ring == tx.origin); }\r\n\r\n    ////////////////////////////\r\n    // step 1. token exchange //\r\n    ////////////////////////////\r\n    uint256 fees;\r\n    if (order.sellToken == etherAddress) {\r\n      // buy order: taker sends ether, gets tokens\r\n      fees = _executeBuyOrder(trader, orderId, buyTokenAmount);\r\n    } else if (order.buyToken == etherAddress) {\r\n      // sell order: taker sends tokens, gets ether\r\n      fees = _executeSellOrder(trader, orderId, buyTokenAmount);\r\n    } else {\r\n      fees = _executeTokenSwap(trader, orderId, buyTokenAmount);\r\n    }\r\n\r\n    ////////////////////////////\r\n    // step 2. fees & wrap up //\r\n    ////////////////////////////\r\n    // collect fees and issue trade mining\r\n    require(_tradeMiningAndFees(fees, trader));\r\n    // deleting the order refunds the caller some gas\r\n    if (orderBook[orderId].amount == 0) {\r\n      delete orderBook[orderId];\r\n      emit OrderFulfilled(orderId, now);\r\n    }\r\n  }\r\n\r\n  function _tradeMiningAndFees(uint256 fees, address trader) private returns(bool) {\r\n    if (fees == 0) { return true; }\r\n    // step one: send fees to the treasury\r\n    require(sendTokensTo(treasury, fees, etherAddress));\r\n    if (tradeMiningBalance == 0) { return true; }\r\n\r\n    // step two: calculate reward\r\n    uint256 tokenAmount = fees.mul(tradeMiningMul).div(tradeMiningDiv);\r\n    if (tokenAmount == 0) { return true; }\r\n    if (tokenAmount > tradeMiningBalance) { tokenAmount = tradeMiningBalance; }\r\n\r\n    // account for sent tokens\r\n    tradeMiningBalance = tradeMiningBalance.sub(tokenAmount);\r\n    // step three: send the reward to the trader\r\n    require(sendTokensTo(trader, tokenAmount, saturnToken));\r\n    emit Mined(trader, tokenAmount, now);\r\n    return true;\r\n  }\r\n\r\n  function sendTokensTo(\r\n    address destination,\r\n    uint256 amount,\r\n    address tkn\r\n  ) private returns(bool) {\r\n    if (tkn == etherAddress) {\r\n      destination.transfer(amount);\r\n    } else {\r\n      // works with both ERC223 and ERC20\r\n      ERC20(tkn).transfer(destination, amount);\r\n    }\r\n    return true;\r\n  }\r\n\r\n  // ERC20 fixture\r\n  function pullTokens(address token, uint256 amount) private nonReentrant returns(uint256) {\r\n    ERC20 tkn = ERC20(token);\r\n    // need to do this balance dance in order to account for deflationary tokens\r\n    uint256 balanceBefore = tkn.balanceOf(address(this));\r\n    tkn.transferFrom(msg.sender, address(this), amount);\r\n    uint256 balanceAfter = tkn.balanceOf(address(this));\r\n    return balanceAfter.sub(balanceBefore);\r\n  }\r\n\r\n  function _topUpTradeMining(uint256 amount) private returns(bool) {\r\n    tradeMiningBalance = tradeMiningBalance.add(amount);\r\n    return true;\r\n  }\r\n}", "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"sellToken\",\"type\":\"address\"},{\"name\":\"buyToken\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"priceMul\",\"type\":\"uint256\"},{\"name\":\"priceDiv\",\"type\":\"uint256\"},{\"name\":\"ring\",\"type\":\"address\"}],\"name\":\"sellERC20TokenWithRing\",\"outputs\":[{\"name\":\"orderId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"orderCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newMul\",\"type\":\"uint256\"},{\"name\":\"newDiv\",\"type\":\"uint256\"}],\"name\":\"changeTradeMiningPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"orderId\",\"type\":\"uint256\"}],\"name\":\"cancelOrder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feeMul\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"treasury\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tradeMiningMul\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"orderId\",\"type\":\"uint256\"}],\"name\":\"calcFees\",\"outputs\":[{\"name\":\"fees\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"orderId\",\"type\":\"uint256\"}],\"name\":\"remainingAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feeDiv\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"orderId\",\"type\":\"uint256\"}],\"name\":\"buyOrderWithEth\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"tokenFallback\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"fees\",\"type\":\"uint256\"},{\"name\":\"orderId\",\"type\":\"uint256\"}],\"name\":\"tradeMiningAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tradeMiningBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"buyToken\",\"type\":\"address\"},{\"name\":\"priceMul\",\"type\":\"uint256\"},{\"name\":\"priceDiv\",\"type\":\"uint256\"}],\"name\":\"sellEther\",\"outputs\":[{\"name\":\"orderId\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"orderId\",\"type\":\"uint256\"},{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"buyOrderWithERC20Token\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"orderId\",\"type\":\"uint256\"}],\"name\":\"isOrderActive\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"buyToken\",\"type\":\"address\"},{\"name\":\"priceMul\",\"type\":\"uint256\"},{\"name\":\"priceDiv\",\"type\":\"uint256\"},{\"name\":\"ring\",\"type\":\"address\"}],\"name\":\"sellEtherWithRing\",\"outputs\":[{\"name\":\"orderId\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sellToken\",\"type\":\"address\"},{\"name\":\"buyToken\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"priceMul\",\"type\":\"uint256\"},{\"name\":\"priceDiv\",\"type\":\"uint256\"}],\"name\":\"sellERC20Token\",\"outputs\":[{\"name\":\"orderId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawTradeMining\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tradeMiningDiv\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"desiredSellTokenAmount\",\"type\":\"uint256\"},{\"name\":\"orderId\",\"type\":\"uint256\"}],\"name\":\"getBuyTokenAmount\",\"outputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_saturnToken\",\"type\":\"address\"},{\"name\":\"_treasury\",\"type\":\"address\"},{\"name\":\"_feeMul\",\"type\":\"uint256\"},{\"name\":\"_feeDiv\",\"type\":\"uint256\"},{\"name\":\"_tradeMiningMul\",\"type\":\"uint256\"},{\"name\":\"_tradeMiningDiv\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"sellToken\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"buyToken\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ring\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"priceMul\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"priceDiv\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"NewOrder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"OrderCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"OrderFulfilled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"orderId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"soldTokens\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"boughtTokens\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"feePaid\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"Trade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"trader\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"Mined\",\"type\":\"event\"}]", "ContractName": "Exchange", "CompilerVersion": "v0.4.24+commit.e67f0147", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000b9440022a095343b440d590fcd2d7a3794bd76c800000000000000000000000092eeb915dafe3803f8a9d12000765c3b6af6d5fd00000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000190000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000002540be400", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://b0946e0e1d3d1e148149c2bb4e2cd4e7a7e4ff34839dd14ff5edcfedca71a0cb"}