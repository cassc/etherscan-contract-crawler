{"SourceCode": "// File: contracts/interfaces/IContractRegistry.sol\r\n\r\npragma solidity ^0.4.23;\r\n\r\n/*\r\n    Contract Registry interface\r\n*/\r\ncontract IContractRegistry {\r\n    function addressOf(bytes32 _contractName) public view returns (address);\r\n}\r\n\r\n// File: contracts/interfaces/IERC20Token.sol\r\n\r\npragma solidity ^0.4.23;\r\n\r\n/*\r\n    ERC20 Standard Token interface\r\n*/\r\ncontract IERC20Token {\r\n    // these functions aren't abstract since the compiler emits automatically generated getter functions as external\r\n    function name() public view returns (string) {}\r\n    function symbol() public view returns (string) {}\r\n    function decimals() public view returns (uint8) {}\r\n    function totalSupply() public view returns (uint256) {}\r\n    function balanceOf(address _owner) public view returns (uint256) { _owner; }\r\n    function allowance(address _owner, address _spender) public view returns (uint256) { _owner; _spender; }\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n    function approve(address _spender, uint256 _value) public returns (bool success);\r\n}\r\n\r\n// File: contracts/interfaces/IPegSettings.sol\r\n\r\npragma solidity ^0.4.23;\r\n\r\n\r\ncontract IPegSettings {\r\n\r\n    function authorized(address _address) public view returns (bool) { _address; }\r\n    \r\n    function authorize(address _address, bool _auth) public;\r\n    function transferERC20Token(IERC20Token _token, address _to, uint256 _amount) public;\r\n\r\n}\r\n\r\n// File: contracts/interfaces/IVault.sol\r\n\r\npragma solidity ^0.4.23;\r\n\r\n\r\n\r\ncontract IVault {\r\n\r\n    function registry() public view returns (IContractRegistry);\r\n\r\n    function auctions(address _borrower) public view returns (address) { _borrower; }\r\n    function vaultExists(address _vault) public view returns (bool) { _vault; }\r\n    function totalBorrowed(address _vault) public view returns (uint256) { _vault; }\r\n    function rawBalanceOf(address _vault) public view returns (uint256) { _vault; }\r\n    function rawDebt(address _vault) public view returns (uint256) { _vault; }\r\n    function rawTotalBalance() public view returns (uint256);\r\n    function rawTotalDebt() public view returns (uint256);\r\n    function collateralBorrowedRatio() public view returns (uint256);\r\n    function amountMinted() public view returns (uint256);\r\n\r\n    function debtScalePrevious() public view returns (uint256);\r\n    function debtScaleTimestamp() public view returns (uint256);\r\n    function debtScaleRate() public view returns (int256);\r\n    function balScalePrevious() public view returns (uint256);\r\n    function balScaleTimestamp() public view returns (uint256);\r\n    function balScaleRate() public view returns (int256);\r\n    \r\n    function liquidationRatio() public view returns (uint32);\r\n    function maxBorrowLTV() public view returns (uint32);\r\n\r\n    function borrowingEnabled() public view returns (bool);\r\n    function biddingTime() public view returns (uint);\r\n\r\n    function setType(bool _type) public;\r\n    function create(address _vault) public;\r\n    function setCollateralBorrowedRatio(uint _newRatio) public;\r\n    function setAmountMinted(uint _amountMinted) public;\r\n    function setLiquidationRatio(uint32 _liquidationRatio) public;\r\n    function setMaxBorrowLTV(uint32 _maxBorrowLTV) public;\r\n    function setDebtScalingRate(int256 _debtScalingRate) public;\r\n    function setBalanceScalingRate(int256 _balanceScalingRate) public;\r\n    function setBiddingTime(uint _biddingTime) public;\r\n    function setRawTotalDebt(uint _rawTotalDebt) public;\r\n    function setRawTotalBalance(uint _rawTotalBalance) public;\r\n    function setRawBalanceOf(address _borrower, uint _rawBalance) public;\r\n    function setRawDebt(address _borrower, uint _rawDebt) public;\r\n    function setTotalBorrowed(address _borrower, uint _totalBorrowed) public;\r\n    function debtScalingFactor() public view returns (uint256);\r\n    function balanceScalingFactor() public view returns (uint256);\r\n    function debtRawToActual(uint256 _raw) public view returns (uint256);\r\n    function debtActualToRaw(uint256 _actual) public view returns (uint256);\r\n    function balanceRawToActual(uint256 _raw) public view returns (uint256);\r\n    function balanceActualToRaw(uint256 _actual) public view returns (uint256);\r\n    function getVaults(address _vault, uint256 _balanceOf) public view returns(address[]);\r\n    function transferERC20Token(IERC20Token _token, address _to, uint256 _amount) public;\r\n    function oracleValue() public view returns(uint256);\r\n    function emitBorrow(address _borrower, uint256 _amount) public;\r\n    function emitRepay(address _borrower, uint256 _amount) public;\r\n    function emitDeposit(address _borrower, uint256 _amount) public;\r\n    function emitWithdraw(address _borrower, address _to, uint256 _amount) public;\r\n    function emitLiquidate(address _borrower) public;\r\n    function emitAuctionStarted(address _borrower) public;\r\n    function emitAuctionEnded(address _borrower, address _highestBidder, uint256 _highestBid) public;\r\n    function setAuctionAddress(address _borrower, address _auction) public;\r\n}\r\n\r\n// File: contracts/interfaces/IPegOracle.sol\r\n\r\npragma solidity ^0.4.23;\r\n\r\ncontract IPegOracle {\r\n    function getValue() public view returns (uint256);\r\n}\r\n\r\n// File: contracts/interfaces/IOwned.sol\r\n\r\npragma solidity ^0.4.23;\r\n\r\n/*\r\n    Owned contract interface\r\n*/\r\ncontract IOwned {\r\n    // this function isn't abstract since the compiler emits automatically generated getter functions as external\r\n    function owner() public view returns (address) {}\r\n\r\n    function transferOwnership(address _newOwner) public;\r\n    function acceptOwnership() public;\r\n    function setOwner(address _newOwner) public;\r\n}\r\n\r\n// File: contracts/interfaces/ISmartToken.sol\r\n\r\npragma solidity ^0.4.23;\r\n\r\n\r\n\r\n/*\r\n    Smart Token interface\r\n*/\r\ncontract ISmartToken is IOwned, IERC20Token {\r\n    function disableTransfers(bool _disable) public;\r\n    function issue(address _to, uint256 _amount) public;\r\n    function destroy(address _from, uint256 _amount) public;\r\n}\r\n\r\n// File: contracts/interfaces/IPegLogic.sol\r\n\r\npragma solidity ^0.4.23;\r\n\r\n\r\n\r\n\r\ncontract IPegLogic {\r\n\r\n    function adjustCollateralBorrowingRate() public;\r\n    function isInsolvent(IVault _vault, address _borrower) public view returns (bool);\r\n    function actualDebt(IVault _vault, address _address) public view returns(uint256);\r\n    function excessCollateral(IVault _vault, address _borrower) public view returns (int256);\r\n    function availableCredit(IVault _vault, address _borrower) public view returns (int256);\r\n    function getCollateralToken(IVault _vault) public view returns(IERC20Token);\r\n    function getDebtToken(IVault _vault) public view returns(ISmartToken);\r\n\r\n}\r\n\r\n// File: contracts/interfaces/IAuctionActions.sol\r\n\r\npragma solidity ^0.4.23;\r\n\r\n\r\ncontract IAuctionActions {\r\n\r\n    function startAuction(IVault _vault, address _borrower) public;\r\n    function endAuction(IVault _vault, address _borrower) public;\r\n\r\n}\r\n\r\n// File: contracts/ContractIds.sol\r\n\r\npragma solidity ^0.4.23;\r\n\r\ncontract ContractIds {\r\n    bytes32 public constant STABLE_TOKEN = \"StableToken\";\r\n    bytes32 public constant COLLATERAL_TOKEN = \"CollateralToken\";\r\n\r\n    bytes32 public constant PEGUSD_TOKEN = \"PEGUSD\";\r\n\r\n    bytes32 public constant VAULT_A = \"VaultA\";\r\n    bytes32 public constant VAULT_B = \"VaultB\";\r\n\r\n    bytes32 public constant PEG_LOGIC = \"PegLogic\";\r\n    bytes32 public constant PEG_LOGIC_ACTIONS = \"LogicActions\";\r\n    bytes32 public constant AUCTION_ACTIONS = \"AuctionActions\";\r\n\r\n    bytes32 public constant PEG_SETTINGS = \"PegSettings\";\r\n    bytes32 public constant ORACLE = \"Oracle\";\r\n    bytes32 public constant FEE_RECIPIENT = \"StabilityFeeRecipient\";\r\n}\r\n\r\n// File: contracts/Helpers.sol\r\n\r\npragma solidity ^0.4.23;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract Helpers is ContractIds {\r\n\r\n    IContractRegistry public registry;\r\n\r\n    constructor(IContractRegistry _registry) public {\r\n        registry = _registry;\r\n    }\r\n\r\n    modifier authOnly() {\r\n        require(settings().authorized(msg.sender));\r\n        _;\r\n    }\r\n\r\n    modifier validate(IVault _vault, address _borrower) {\r\n        require(address(_vault) == registry.addressOf(ContractIds.VAULT_A) || address(_vault) == registry.addressOf(ContractIds.VAULT_B));\r\n        _vault.create(_borrower);\r\n        _;\r\n    }\r\n\r\n    function stableToken() internal returns(ISmartToken) {\r\n        return ISmartToken(registry.addressOf(ContractIds.STABLE_TOKEN));\r\n    }\r\n\r\n    function collateralToken() internal returns(ISmartToken) {\r\n        return ISmartToken(registry.addressOf(ContractIds.COLLATERAL_TOKEN));\r\n    }\r\n\r\n    function PEGUSD() internal returns(IERC20Token) {\r\n        return IERC20Token(registry.addressOf(ContractIds.PEGUSD_TOKEN));\r\n    }\r\n\r\n    function vaultA() internal returns(IVault) {\r\n        return IVault(registry.addressOf(ContractIds.VAULT_A));\r\n    }\r\n\r\n    function vaultB() internal returns(IVault) {\r\n        return IVault(registry.addressOf(ContractIds.VAULT_B));\r\n    }\r\n\r\n    function oracle() internal returns(IPegOracle) {\r\n        return IPegOracle(registry.addressOf(ContractIds.ORACLE));\r\n    }\r\n\r\n    function settings() internal returns(IPegSettings) {\r\n        return IPegSettings(registry.addressOf(ContractIds.PEG_SETTINGS));\r\n    }\r\n\r\n    function pegLogic() internal returns(IPegLogic) {\r\n        return IPegLogic(registry.addressOf(ContractIds.PEG_LOGIC));\r\n    }\r\n\r\n    function auctionActions() internal returns(IAuctionActions) {\r\n        return IAuctionActions(registry.addressOf(ContractIds.AUCTION_ACTIONS));\r\n    }\r\n\r\n    function transferERC20Token(IERC20Token _token, address _to, uint256 _amount) public authOnly {\r\n        _token.transfer(_to, _amount);\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/library/SafeMath.sol\r\n\r\npragma solidity ^0.4.23;\r\n\r\nlibrary SafeMath {\r\n    function plus(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        uint256 c = _a + _b;\r\n        assert(c >= _a);\r\n        return c;\r\n    }\r\n\r\n    function plus(int256 _a, int256 _b) internal pure returns (int256) {\r\n        int256 c = _a + _b;\r\n        assert((_b >= 0 && c >= _a) || (_b < 0 && c < _a));\r\n        return c;\r\n    }\r\n\r\n    function minus(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        assert(_a >= _b);\r\n        return _a - _b;\r\n    }\r\n\r\n    function minus(int256 _a, int256 _b) internal pure returns (int256) {\r\n        int256 c = _a - _b;\r\n        assert((_b >= 0 && c <= _a) || (_b < 0 && c > _a));\r\n        return c;\r\n    }\r\n\r\n    function times(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        if (_a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = _a * _b;\r\n        assert(c / _a == _b);\r\n        return c;\r\n    }\r\n\r\n    function times(int256 _a, int256 _b) internal pure returns (int256) {\r\n        if (_a == 0) {\r\n            return 0;\r\n        }\r\n        int256 c = _a * _b;\r\n        assert(c / _a == _b);\r\n        return c;\r\n    }\r\n\r\n    function toInt256(uint256 _a) internal pure returns (int256) {\r\n        assert(_a <= 2 ** 255);\r\n        return int256(_a);\r\n    }\r\n\r\n    function toUint256(int256 _a) internal pure returns (uint256) {\r\n        assert(_a >= 0);\r\n        return uint256(_a);\r\n    }\r\n\r\n    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        return _a / _b;\r\n    }\r\n\r\n    function div(int256 _a, int256 _b) internal pure returns (int256) {\r\n        return _a / _b;\r\n    }\r\n}\r\n\r\n// File: contracts/LogicActions.sol\r\n\r\npragma solidity ^0.4.23;\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract LogicActions is Helpers {\r\n\r\n    using SafeMath for uint256;\r\n    using SafeMath for int256;\r\n\r\n    IContractRegistry public registry;\r\n\r\n    constructor(IContractRegistry _registry) public Helpers(_registry) {\r\n        registry = _registry;\r\n    }\r\n\r\n    function deposit(IVault _vault, uint256 _amount) public validate(_vault, msg.sender) {\r\n        IERC20Token vaultCollateralToken = pegLogic().getCollateralToken(_vault);\r\n        vaultCollateralToken.transferFrom(msg.sender, address(_vault), _amount);\r\n        _vault.setRawBalanceOf(\r\n            msg.sender,\r\n            _vault.rawBalanceOf(msg.sender).plus(_vault.balanceActualToRaw(_amount))\r\n        );\r\n        _vault.setRawTotalBalance(\r\n            _vault.rawTotalBalance().plus(_vault.balanceActualToRaw(_amount))\r\n        );\r\n        pegLogic().adjustCollateralBorrowingRate();\r\n        _vault.emitDeposit(msg.sender, _amount);\r\n    }\r\n\r\n    function withdraw(IVault _vault, address _to, uint256 _amount) public validate(_vault, msg.sender) {\r\n        IPegLogic ipegLogic = pegLogic();\r\n        require(_amount.toInt256() <= ipegLogic.excessCollateral(_vault, msg.sender), \"Insufficient collateral balance\");\r\n        _vault.setRawBalanceOf(\r\n            msg.sender,\r\n            _vault.rawBalanceOf(msg.sender).minus(_vault.balanceActualToRaw(_amount))\r\n        );\r\n        _vault.setRawTotalBalance(\r\n            _vault.rawTotalBalance().minus(_vault.balanceActualToRaw(_amount))\r\n        );\r\n        _vault.transferERC20Token(ipegLogic.getCollateralToken(_vault), _to, _amount);\r\n        if(_vault.rawTotalBalance() > 0)\r\n            ipegLogic.adjustCollateralBorrowingRate();\r\n        _vault.emitWithdraw(msg.sender, _to, _amount);\r\n    }\r\n\r\n    function borrow(IVault _vault, uint256 _amount) public validate(_vault, msg.sender) {\r\n        IPegLogic ipegLogic = pegLogic();\r\n        require(_amount.toInt256() <= ipegLogic.availableCredit(_vault, msg.sender), \"Not enough available credit\");\r\n        require(_vault.borrowingEnabled(), \"Borrowing disabled\");\r\n        address auctionAddress = _vault.auctions(msg.sender);\r\n        require(auctionAddress == address(0), \"Can't borrow when there's ongoing auction on your vault\");\r\n        _vault.setRawDebt(msg.sender, _vault.rawDebt(msg.sender).plus(_vault.debtActualToRaw(_amount)));\r\n        _vault.setTotalBorrowed(msg.sender, _vault.totalBorrowed(msg.sender).plus(_amount));\r\n        _vault.setRawTotalDebt(_vault.rawTotalDebt().plus(_vault.debtActualToRaw(_amount)));\r\n        if (address(_vault) == address(vaultA())) {\r\n            stableToken().issue(msg.sender, _amount);\r\n        } else {\r\n            vaultA().transferERC20Token(collateralToken(), msg.sender, _amount);\r\n        }\r\n        ipegLogic.adjustCollateralBorrowingRate();\r\n        _vault.emitBorrow(msg.sender, _amount);\r\n    }\r\n\r\n    function doPay(IVault _vault, address _payor, address _borrower, uint256 _amount, bool _all) internal {\r\n        ISmartToken vaultDebtToken = pegLogic().getDebtToken(_vault);\r\n        if (address(_vault) == address(vaultA())) {\r\n            vaultDebtToken.destroy(_payor, _amount);\r\n        } else {\r\n            vaultDebtToken.transferFrom(_payor, address(vaultA()), _amount);\r\n        }\r\n        _vault.setRawTotalDebt(_vault.rawTotalDebt().minus(_vault.debtActualToRaw(_amount)));\r\n\r\n        if(_all) {\r\n            _vault.setRawDebt(_borrower, 0);\r\n            _vault.setTotalBorrowed(_borrower, 0);\r\n        } else {\r\n            _vault.setRawDebt(_borrower, _vault.rawDebt(_borrower).minus(_vault.debtActualToRaw(_amount)));\r\n            _vault.setTotalBorrowed(_borrower, _vault.totalBorrowed(_borrower).minus(_amount));\r\n        }\r\n        pegLogic().adjustCollateralBorrowingRate();\r\n        _vault.emitRepay(_borrower, _amount);\r\n    }\r\n\r\n    function repay(IVault _vault, address _borrower, uint256 _amount) public validate(_vault, _borrower) {\r\n        doPay(_vault, msg.sender, _borrower, _amount, false);\r\n    }\r\n\r\n    function repayAuction(IVault _vault, address _borrower, uint256 _amount) public validate(_vault, _borrower)\r\n    {\r\n        require(_vault.auctions(_borrower) == msg.sender, \"Invalid auction\");\r\n        doPay(_vault, msg.sender, msg.sender, _amount, true);\r\n    }\r\n\r\n    function repayAll(IVault _vault, address _borrower) public validate(_vault, _borrower) {\r\n        uint256 _amount = pegLogic().actualDebt(_vault, _borrower);\r\n        doPay(_vault, msg.sender, _borrower, _amount, true);\r\n    }\r\n\r\n}", "ABI": "[{\"constant\":true,\"inputs\":[],\"name\":\"VAULT_B\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PEG_LOGIC_ACTIONS\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_vault\",\"type\":\"address\"},{\"name\":\"_borrower\",\"type\":\"address\"}],\"name\":\"repayAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_vault\",\"type\":\"address\"},{\"name\":\"_borrower\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"repay\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ORACLE\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_vault\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_vault\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"borrow\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"VAULT_A\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"STABLE_TOKEN\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"registry\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferERC20Token\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"AUCTION_ACTIONS\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PEG_SETTINGS\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_vault\",\"type\":\"address\"},{\"name\":\"_borrower\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"repayAuction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_vault\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PEG_LOGIC\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"FEE_RECIPIENT\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"COLLATERAL_TOKEN\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PEGUSD_TOKEN\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_registry\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]", "ContractName": "LogicActions", "CompilerVersion": "v0.4.23+commit.124ca40d", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000e68ebda2488c213cf4ba25a7a7da179f96ce0baf", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://6aee40a97b199836a6963f1c41ca9e671a72e2582d641f13740fd96d66c89555"}