{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/booststrap/BoostStrap.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {IVotingEscrow} from \\\"../interfaces/IVotingEscrow.sol\\\";\\nimport {IUnshethFarm} from \\\"../interfaces/IUnshethFarm.sol\\\";\\nimport {IWETH} from \\\"../interfaces/IWETH.sol\\\";\\nimport {ReentrancyGuard} from \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\n\\ncontract BoostStrap is ReentrancyGuard {\\n    // solhint-disable var-name-mixedcase\\n    IERC20 public immutable USH;\\n\\n    // USH-ETH Sushiswap LP Token\\n    IERC20 public immutable SUSHI_LPT;\\n    // address 80USH-20unshETH Balancer LP Token\\n    IERC20 public immutable BALANCER_LPT;\\n\\n    IERC20 public immutable UNSHETH;\\n    IERC20 public immutable WETH;\\n\\n    address public constant VD_USH = address(0xd027Ef82dB658805C9Ba8053196cD6ED1Dd407E4);\\n\\n    // TODO: confirm with unsheth team if this is the correct farm address\\n    // link to code: https://etherscan.io/address/0x33890B88F98a9D511678954AD8DB0510B6953Cfc#code\\n    // TODO: Should we make this a constant or a global variable that can be changed so if unsheth\\n    // team changes it we change as well?\\n    address public constant UNSHETH_FARM = address(0x33890B88F98a9D511678954AD8DB0510B6953Cfc);\\n\\n    // SafeVault\\n    address public safeVault;\\n\\n    uint256 public startTime;\\n    uint256 public endTime;\\n    uint256 public lockTime;\\n    uint256 public unshethFarmLockTime;\\n\\n    uint256 public recoverUserAssetsTime;\\n\\n    bool public successfulGusherLaunch;\\n\\n    mapping(address token => uint256 amount) public tokenContributions;\\n\\n    mapping(address user => mapping(address token => uint256 amount)) public userContributions;\\n\\n    event AssetsWithdrawnFromVotingEscrowToSafeVault();\\n    event LockTimeChanged(uint256 newLockTime);\\n    event SuccessfulGusherLaunchSet();\\n    event TokenDeposited(address indexed user, address token, uint256 amount);\\n    event TokenRecovered(address indexed user, address token, uint256 amount);\\n    event UnshethFarmLockTimeChanged(uint256 newUnshethFarmLockTime);\\n    event UnshethWithdrawnFromUnshethFarmToSafeVault();\\n\\n    error AssetStillLockedInVotingEscrow();\\n    error DepositedUnpermittedToken();\\n    error EndTimeTooEarly();\\n    error FarmLockTimeTooHigh();\\n    error FarmLockTimeTooLow();\\n    error GusherHasNotLaunchedYet();\\n    error GusherSuccessfullyLaunchedAssetsAreInProtocol();\\n    error InsufficientContribution();\\n    error LockTimeTooLow();\\n    error NoAssetsToRecover();\\n    error OnlySafeVault();\\n    error RecoverTimeHasNotStarted();\\n    error RecoverTimeTooEarly();\\n    error SafeVaultAddressZero();\\n    error SaleHasEnded();\\n    error SaleHasNotEnded();\\n    error SaleHasNotStarted();\\n    error StartTimeOver();\\n\\n    constructor(\\n        address _safeVault,\\n        uint256 _startTime,\\n        uint256 _endTime,\\n        uint256 _recoverUserAssetsTime,\\n        uint256 _lockTime,\\n        uint256 _unshethFarmLockTime\\n    ) {\\n        if (_safeVault == address(0)) revert SafeVaultAddressZero();\\n        if (_startTime < block.timestamp) revert StartTimeOver();\\n        if (_endTime <= _startTime) revert EndTimeTooEarly();\\n        if (_recoverUserAssetsTime <= _endTime) revert RecoverTimeTooEarly();\\n        if (_lockTime < IVotingEscrow(VD_USH).MINTIME()) revert LockTimeTooLow();\\n        if (_unshethFarmLockTime < IUnshethFarm(UNSHETH_FARM).lock_time_min()) {\\n            revert FarmLockTimeTooLow();\\n        }\\n        if (_unshethFarmLockTime > IUnshethFarm(UNSHETH_FARM).lock_time_for_max_multiplier()) {\\n            revert FarmLockTimeTooHigh();\\n        }\\n\\n        USH = IERC20(0xE60779CC1b2c1d0580611c526a8DF0E3f870EC48);\\n        WETH = IERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\\n        UNSHETH = IERC20(0x0Ae38f7E10A43B5b2fB064B42a2f4514cbA909ef);\\n        BALANCER_LPT = IERC20(0xd689ABc77B82803F22c49dE5C8A0049Cc74D11fD);\\n        SUSHI_LPT = IERC20(0xAAF448d30F01b429FB6e7F9AF6A8FF66e694F312);\\n\\n        safeVault = _safeVault;\\n\\n        startTime = _startTime;\\n        endTime = _endTime;\\n        recoverUserAssetsTime = _recoverUserAssetsTime;\\n\\n        lockTime = _lockTime;\\n        unshethFarmLockTime = _unshethFarmLockTime;\\n    }\\n\\n    modifier onlySafeVault() {\\n        if (msg.sender != safeVault) revert OnlySafeVault();\\n        _;\\n    }\\n\\n    modifier withinSaleTime() {\\n        if (block.timestamp < startTime) revert SaleHasNotStarted();\\n\\n        if (block.timestamp > endTime) revert SaleHasEnded();\\n        _;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                           EXTERNAL FUNCTIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    receive() external payable withinSaleTime nonReentrant {\\n        uint256 _amount = msg.value;\\n\\n        tokenContributions[address(WETH)] += _amount;\\n        userContributions[msg.sender][address(WETH)] += _amount;\\n\\n        IWETH(address(WETH)).deposit{value: _amount}();\\n\\n        emit TokenDeposited(msg.sender, address(WETH), _amount);\\n    }\\n\\n    /// @dev allows users to deposit whitelisted tokens into the contract. It issues a receipt token\\n    /// for the user\\n    /// @param token the token to deposit\\n    /// @param _amount the amount to deposit\\n    function depositIntoBooststrap(IERC20 token, uint256 _amount)\\n        public\\n        withinSaleTime\\n        nonReentrant\\n    {\\n        // allow only permitted tokens to be deposited\\n        if (\\n            address(token) != address(USH) && address(token) != address(WETH)\\n                && address(token) != address(UNSHETH) && address(token) != address(BALANCER_LPT)\\n                && address(token) != address(SUSHI_LPT)\\n        ) revert DepositedUnpermittedToken();\\n\\n        if (address(token) == address(UNSHETH)) {\\n            uint256 minContribUnshETH = 1e16; // 0.01 ETH in wei\\n            if (_amount < minContribUnshETH) revert InsufficientContribution();\\n        }\\n\\n        tokenContributions[address(token)] += _amount;\\n        userContributions[msg.sender][address(token)] += _amount;\\n\\n        token.transferFrom(msg.sender, address(this), _amount);\\n\\n        if (address(token) != address(UNSHETH) && address(token) != address(WETH)) {\\n            _depositInVD_USHContract(address(token), _amount);\\n        } else if (address(token) == address(UNSHETH)) {\\n            _stakeInUnshETHFarm(_amount);\\n        }\\n\\n        emit TokenDeposited(msg.sender, address(token), _amount);\\n    }\\n\\n    /// @dev find user contributions for all whitelisted tokens. Servers also as a pseudo user's\\n    /// receipt token balance\\n    function userTokenContributions(address contributor)\\n        external\\n        view\\n        returns (uint256, uint256, uint256, uint256, uint256)\\n    {\\n        uint256 ushContributions = userContributions[contributor][address(USH)];\\n        uint256 wethContributions = userContributions[contributor][address(WETH)];\\n        uint256 unshethContributions = userContributions[contributor][address(UNSHETH)];\\n        uint256 BALANCER_LPTContributions = userContributions[contributor][address(BALANCER_LPT)];\\n        uint256 SUSHI_LPTContributions = userContributions[contributor][address(SUSHI_LPT)];\\n\\n        return (\\n            ushContributions,\\n            wethContributions,\\n            unshethContributions,\\n            BALANCER_LPTContributions,\\n            SUSHI_LPTContributions\\n        );\\n    }\\n\\n    /// @dev allows users to recover their assets if Gusher doesn't launch on a timely manner\\n    /// @param token the token to recover\\n    function recoverFromBooststrap(IERC20 token) external nonReentrant {\\n        if (block.timestamp < recoverUserAssetsTime) revert RecoverTimeHasNotStarted();\\n\\n        if (successfulGusherLaunch) revert GusherSuccessfullyLaunchedAssetsAreInProtocol();\\n\\n        // withdraw from voting escrow if it is a token that was sent to it\\n        if (address(token) != address(UNSHETH) && address(token) != address(WETH)) {\\n            // if token is still locked in voting escrow revert with error\\n            if (block.timestamp <= IVotingEscrow(VD_USH).locked(address(this)).end) {\\n                revert AssetStillLockedInVotingEscrow();\\n            }\\n\\n            IVotingEscrow(VD_USH).withdraw();\\n        }\\n\\n        // add check that user has assets in contract or that there are assets to recover in\\n        // contract\\n        if (\\n            userContributions[msg.sender][address(token)] == 0\\n                || token.balanceOf(address(this)) == 0\\n        ) revert NoAssetsToRecover();\\n\\n        uint256 amountToRecover = userContributions[msg.sender][address(token)];\\n\\n        // update state\\n        userContributions[msg.sender][address(token)] = 0;\\n        tokenContributions[address(token)] -= amountToRecover;\\n\\n        // transfer assets to user\\n        token.transfer(msg.sender, amountToRecover);\\n\\n        emit TokenRecovered(msg.sender, address(token), amountToRecover);\\n    }\\n\\n    /// @dev allows the safeVault to withdraw all assets from unsheth VotingEscrow contract. Only\\n    /// SafeVault is allowed\\n    function withdrawAssetFromUnshethVotingEscrowAndIntoVault() external onlySafeVault {\\n        uint256 timeStampAllowedToWithdraw = IVotingEscrow(VD_USH).locked(address(this)).end;\\n        if (block.timestamp < timeStampAllowedToWithdraw) revert AssetStillLockedInVotingEscrow();\\n        IVotingEscrow(VD_USH).withdraw();\\n\\n        // transfer assets to safeVault\\n        USH.transfer(safeVault, USH.balanceOf(address(this)));\\n        WETH.transfer(safeVault, WETH.balanceOf(address(this)));\\n        BALANCER_LPT.transfer(safeVault, BALANCER_LPT.balanceOf(address(this)));\\n        SUSHI_LPT.transfer(safeVault, SUSHI_LPT.balanceOf(address(this)));\\n\\n        emit AssetsWithdrawnFromVotingEscrowToSafeVault();\\n    }\\n\\n    /// @dev allows the safeVault to withdraw all unsheth from unsheth farm contract\\n    function unstakeUnshethFromFarm() external onlySafeVault {\\n        if (!successfulGusherLaunch) revert GusherHasNotLaunchedYet();\\n        if (block.timestamp < endTime) revert SaleHasNotEnded();\\n\\n        IUnshethFarm.LockedStake[] memory lockedStakes =\\n            IUnshethFarm(UNSHETH_FARM).lockedStakesOf(address(this));\\n\\n        uint256 length = lockedStakes.length;\\n\\n        for (uint256 i; i < length;) {\\n            IUnshethFarm(UNSHETH_FARM).withdrawLocked(lockedStakes[i].kek_id);\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        // transfer assets to safeVault\\n        UNSHETH.transfer(safeVault, UNSHETH.balanceOf(address(this)));\\n\\n        emit UnshethWithdrawnFromUnshethFarmToSafeVault();\\n    }\\n\\n    /// @dev allows the safeVault to withdraw specific unsheth from unsheth farm contract\\n    /// @param kekId the kekId of the locked stake to withdraw\\n    function unstakeUnshethFromFarm(bytes32 kekId) external onlySafeVault {\\n        if (!successfulGusherLaunch) revert GusherHasNotLaunchedYet();\\n        if (block.timestamp < endTime) revert SaleHasNotEnded();\\n        IUnshethFarm(UNSHETH_FARM).withdrawLocked(kekId);\\n\\n        // transfer assets to safeVault\\n        UNSHETH.transfer(safeVault, UNSHETH.balanceOf(address(this)));\\n\\n        emit UnshethWithdrawnFromUnshethFarmToSafeVault();\\n    }\\n\\n    /// @dev allows the safeVault to get rewards from unsheth farm contract\\n    function getUnshethFarmReward() external onlySafeVault {\\n        IUnshethFarm(UNSHETH_FARM).getReward();\\n\\n        // rewards in unsheth farm are in USH\\n        USH.transfer(safeVault, USH.balanceOf(address(this)));\\n    }\\n\\n    /// @dev set successfulGusherLaunch to true. Only SafeVault is allowed\\n    function setSuccessfulGusherLaunch() external onlySafeVault {\\n        successfulGusherLaunch = true;\\n\\n        emit SuccessfulGusherLaunchSet();\\n    }\\n\\n    /// @dev change lock time for unsheth voting escrow. Only allowed by safeVault\\n    /// @param _lockTime the new lock time\\n    function changeLockTime(uint256 _lockTime) external onlySafeVault {\\n        if (_lockTime < IVotingEscrow(VD_USH).MINTIME()) revert LockTimeTooLow();\\n\\n        lockTime = _lockTime;\\n\\n        emit LockTimeChanged(_lockTime);\\n    }\\n\\n    /// @dev change lock time for unsheth farm contract\\n    /// @param _unshethFarmLockTime the new lock time\\n    function changeUnshethFarmLockTime(uint256 _unshethFarmLockTime) external onlySafeVault {\\n        if (_unshethFarmLockTime < IUnshethFarm(UNSHETH_FARM).lock_time_min()) {\\n            revert FarmLockTimeTooLow();\\n        }\\n\\n        if (_unshethFarmLockTime > IUnshethFarm(UNSHETH_FARM).lock_time_for_max_multiplier()) {\\n            revert FarmLockTimeTooHigh();\\n        }\\n\\n        unshethFarmLockTime = _unshethFarmLockTime;\\n\\n        emit UnshethFarmLockTimeChanged(_unshethFarmLockTime);\\n    }\\n\\n    /// @dev withdraw stuck assets in the contract. This may be stuck by accident\\n    /// @param token the token to withdraw\\n    function withdrawStuckAsset(IERC20 token) external onlySafeVault {\\n        token.transfer(safeVault, token.balanceOf(address(this)));\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                           PRIVATE FUNCTIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _depositInVD_USHContract(address token, uint256 amount) private {\\n        if (IVotingEscrow(VD_USH).locked(address(this)).amount == 0) {\\n            _depositInUnshethVotingEscrow(address(token), amount);\\n        } else {\\n            _incrementAmountInUnshethVotingEscrow(address(token), amount);\\n        }\\n    }\\n\\n    function _depositInUnshethVotingEscrow(address token, uint256 amount) private {\\n        IERC20(token).approve(VD_USH, amount);\\n\\n        if (address(token) == address(BALANCER_LPT)) {\\n            IVotingEscrow(VD_USH).create_lock(amount, 0, 0, block.timestamp + lockTime);\\n        } else if (address(token) == address(SUSHI_LPT)) {\\n            IVotingEscrow(VD_USH).create_lock(0, amount, 0, block.timestamp + lockTime);\\n        } else if (address(token) == address(USH)) {\\n            IVotingEscrow(VD_USH).create_lock(0, 0, amount, block.timestamp + lockTime);\\n        }\\n    }\\n\\n    function _incrementAmountInUnshethVotingEscrow(address token, uint256 amount) private {\\n        IERC20(token).approve(VD_USH, amount);\\n\\n        if (address(token) == address(BALANCER_LPT)) {\\n            IVotingEscrow(VD_USH).increase_amount(amount, 0, 0);\\n        } else if (address(token) == address(SUSHI_LPT)) {\\n            IVotingEscrow(VD_USH).increase_amount(0, amount, 0);\\n        } else if (address(token) == address(USH)) {\\n            IVotingEscrow(VD_USH).increase_amount(0, 0, amount);\\n        }\\n    }\\n\\n    function _stakeInUnshETHFarm(uint256 amount) private {\\n        IERC20(UNSHETH).approve(address(UNSHETH_FARM), amount);\\n\\n        IUnshethFarm(UNSHETH_FARM).stakeLocked(amount, unshethFarmLockTime);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IVotingEscrow.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\ninterface IVotingEscrow {\\n    struct LockedBalance {\\n        int128 amount; //weightedAmount\\n        uint256 amountA;\\n        uint256 amountB;\\n        uint256 amountC;\\n        uint256 end;\\n    }\\n\\n    function create_lock(uint256, uint256, uint256, uint256) external;\\n\\n    function increase_amount(uint256, uint256, uint256) external;\\n\\n    function add_to_whitelist(address) external;\\n\\n    function withdraw() external;\\n\\n    function MINTIME() external view returns (uint256);\\n\\n    function locked(address) external view returns (LockedBalance memory);\\n\\n    function unlocked() external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IUnshethFarm.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\ninterface IUnshethFarm {\\n    struct LockedStake {\\n        bytes32 kek_id;\\n        uint256 start_timestamp;\\n        uint256 liquidity;\\n        uint256 ending_timestamp;\\n        uint256 lock_multiplier; // 6 decimals of precision. 1x = 1000000\\n    }\\n\\n    function stakeLocked(uint256, uint256) external;\\n\\n    function getReward() external returns (uint256[] memory);\\n\\n    function withdrawLocked(bytes32 kek_id) external;\\n\\n    function lock_time_for_max_multiplier() external view returns (uint256);\\n    function lock_time_min() external view returns (uint256);\\n\\n    function lockedStakesOf(address) external view returns (LockedStake[] memory);\\n\\n    function sync() external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IWETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\ninterface IWETH {\\n    function deposit() external payable;\\n\\n    function withdraw(uint256) external;\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Returns true if the reentrancy guard is currently set to \\\"entered\\\", which indicates there is a\\n     * `nonReentrant` function in the call stack.\\n     */\\n    function _reentrancyGuardEntered() internal view returns (bool) {\\n        return _status == _ENTERED;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"openzeppelin/=lib/openzeppelin-contracts/contracts/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 10000000\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_safeVault\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_endTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_recoverUserAssetsTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lockTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_unshethFarmLockTime\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AssetStillLockedInVotingEscrow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DepositedUnpermittedToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"EndTimeTooEarly\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FarmLockTimeTooHigh\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FarmLockTimeTooLow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"GusherHasNotLaunchedYet\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"GusherSuccessfullyLaunchedAssetsAreInProtocol\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientContribution\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LockTimeTooLow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoAssetsToRecover\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlySafeVault\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RecoverTimeHasNotStarted\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RecoverTimeTooEarly\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SafeVaultAddressZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SaleHasEnded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SaleHasNotEnded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SaleHasNotStarted\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"StartTimeOver\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"AssetsWithdrawnFromVotingEscrowToSafeVault\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newLockTime\",\"type\":\"uint256\"}],\"name\":\"LockTimeChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"SuccessfulGusherLaunchSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenDeposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenRecovered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newUnshethFarmLockTime\",\"type\":\"uint256\"}],\"name\":\"UnshethFarmLockTimeChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"UnshethWithdrawnFromUnshethFarmToSafeVault\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BALANCER_LPT\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SUSHI_LPT\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"UNSHETH\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"UNSHETH_FARM\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"USH\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VD_USH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WETH\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_lockTime\",\"type\":\"uint256\"}],\"name\":\"changeLockTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_unshethFarmLockTime\",\"type\":\"uint256\"}],\"name\":\"changeUnshethFarmLockTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"depositIntoBooststrap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"endTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getUnshethFarmReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"recoverFromBooststrap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"recoverUserAssetsTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"safeVault\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setSuccessfulGusherLaunch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"successfulGusherLaunch\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"tokenContributions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unshethFarmLockTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"kekId\",\"type\":\"bytes32\"}],\"name\":\"unstakeUnshethFromFarm\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unstakeUnshethFromFarm\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"userContributions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contributor\",\"type\":\"address\"}],\"name\":\"userTokenContributions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawAssetFromUnshethVotingEscrowAndIntoVault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"withdrawStuckAsset\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "BoostStrap", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "10000000", "ConstructorArguments": "0000000000000000000000003af17e2149e556dac57661a0362ff0d2eccb71770000000000000000000000000000000000000000000000000000000065527230000000000000000000000000000000000000000000000000000000006579ff300000000000000000000000000000000000000000000000000000000065c914f700000000000000000000000000000000000000000000000000000000002506200000000000000000000000000000000000000000000000000000000000069780", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}