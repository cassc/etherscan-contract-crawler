// SPDX-License-Identifier: MIT
pragma solidity ^0.8.12;

/**
 * @title Turn NFT smart-contract
 * @author Julien Kuntz (on behalf of Diligence and ConsenSys)
 * @notice Tokenized binding contracts between service providers and their clients;
 *  The owner of a TURN NFT is entitled to receive a service described by the datas & metadatas embedded in it.
 */

import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol";
import "@openzeppelin/contracts/access/AccessControlEnumerable.sol";
import "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";
import "@openzeppelin/contracts/utils/cryptography/draft-EIP712.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "./EncodeSlot.sol";
import "./Auction.sol";


contract Turn is ERC721Enumerable, ERC721URIStorage, AccessControlEnumerable , EncodeSlot, EIP712, ReentrancyGuard {

  bytes32 public constant ADMIN_ROLE = keccak256("ADMIN_ROLE");
  bytes32 public constant MINTER_ROLE = keccak256("MINTER_ROLE");
  bytes32 public constant PROVIDER_ROLE = keccak256("PROVIDER_ROLE");
  string private constant SIGNING_DOMAIN = "Turn";
  string private constant SIGNATURE_VERSION = "4";

  /**
   * @notice a mapping of tokenIds ==> datas.
   * @dev 'datas' contains 7 UNIX-formated dates, and the current state of the token; taking 32 bits of memory each.
   * Dates are stored in UNIX time; uint32 should give enough room for 100+ years from now on.
   * They map tokenIds to their corresponding 'data' bundle.
   * For convenience, they are numbered as below (their numbering is used by the 'retriveSlot' function)
   * [----------------------UINT256-------------------------]
   * [-(0)-][-(1)-][-(2)-][-(3)-][-(4)-][-(5)-][-(6)-][-(7)-]
   * (0) - auctionStartsAt      : When the auction starts
   * (1) - auctionStopsAt       : When the auction stops (?)
   * (2) - transferLockStartsAt : When transfer stops
   * (3) - redeemStopsAt        : When redeem stops
   * (4) - workDuration         : duration of the service sold
   * (5) - workPeriodStart      : beginning of the period in which the service sold would take place
   * (6) - workPeriodEnd        : end of the period in which the service sold would take place
   * (7) - workState            : defines in which state the token is ('Started', 'Rejected', 'Finished', etc...) 
   * This ordering is subject to change, since left-most slots are harder to compute.
   * Datas used the most should be stored in the right-most slots to minimize gas costs.
   */
  mapping(uint256 => uint256) internal datas;
  mapping(address => bool) internal auctionContracts;
  mapping(bytes => bool) internal voucherUsed;

  /** 
   * @notice This data structure ('voucher') contains all the informations necessary to reconstruct the current state of an auction
   * @dev The last parameter ('signature') is generated by token providers following the EIP-712 (Typed Structured data hashing and signing)
   */
  struct RedeemVoucher {
    uint256 tokenAmount;
    address redeemerAddress;
    address auctionContract;
    uint128 tokenGroup;
    bytes signature;
  }

  // event used to signal a Work request has been made
  event Redeem(address from, uint256[] tokenIds, RedeemVoucher voucher);

  constructor(address _admin) ERC721("Turn", "TRN") EIP712(SIGNING_DOMAIN, SIGNATURE_VERSION) {
    _setupRole(ADMIN_ROLE, _admin);
    _setRoleAdmin(MINTER_ROLE, ADMIN_ROLE);
    // WARNING: The `ADMIN_ROLE` is also its own admin: it has permission to
    // grant and revoke this role. Extra precautions should be taken to secure
    // accounts that have been granted it.
    _setRoleAdmin(ADMIN_ROLE, ADMIN_ROLE);
  }

  /** 
   * @notice Returns the chain id of the current blockchain.
   * @dev This is used to workaround an issue with ganache returning different values from the on-chain chainid() function and
   * the eth_chainId RPC method. See https://github.com/protocol/nft-website/issues/121 for context.
   */
  function getChainID() public view returns (uint256) {
    uint256 id;
    assembly {
      id := chainid()
    }
    return id;
  }

  /** 
   * @notice fallback function; always reverts (prevents funds from being sent here inadvertently)
   * @dev doesn't prevents an external smart-contract to send funds through a self-destruct mechanism
   */
  fallback() external {
    revert("fallback: reverts");
  }

  /**
   * @dev See {IERC165-supportsInterface}.
   * @param interfaceId the interfaceId you want to know if that contracts supports (in bytes4 format)
   * @return bool true/false statement if the Turn smart-contract supports a given interface
   * (e.g. IERC721Enumerable, IAccessControlEnumerable or any of their respective parent classes)
   */
  function supportsInterface(bytes4 interfaceId)
    public
    view
    override(AccessControlEnumerable, ERC721Enumerable, ERC721)
    returns (bool)
  {
    return
      AccessControlEnumerable.supportsInterface(interfaceId) ||
      ERC721Enumerable.supportsInterface(interfaceId);
  }

  /**
   * @dev Hook that is called before any token transfer. This includes minting
   * and burning.
   *
   * Calling conditions:
   *
   * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be
   * transferred to `to`.
   * - When `from` is zero, `tokenId` will be minted for `to`.
   * - When `to` is zero, ``from``'s `tokenId` will be burned.
   * - `from` cannot be the zero address.
   * - `to` cannot be the zero address.
   *
   * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
   */
  function _beforeTokenTransfer(
    address from,
    address to,
    uint256 tokenId
  ) internal override(ERC721Enumerable, ERC721) {
    ERC721Enumerable._beforeTokenTransfer(from, to, tokenId);
  }

  /**
   * @notice burns a token.
   * @dev Destroys `tokenId`.
   * The approval is cleared when the token is burned.
   *
   * Requirements:
   *
   * - `tokenId` must exist.
   *
   * Emits a {Transfer} event.
   */
  function _burn(uint256 tokenId)
    internal
    virtual
    override(ERC721URIStorage, ERC721)
  {
    // clearing up datas since it's not handled by vanilla ERC721 implementation
    delete datas[tokenId];
    ERC721URIStorage._burn(tokenId);
  }

  /**
   * @dev See {IERC721Metadata-tokenURI}.
   */
  function tokenURI(uint256 tokenId)
    public
    view
    virtual
    override(ERC721URIStorage, ERC721)
    returns (string memory)
  {
    return ERC721URIStorage.tokenURI(tokenId);
  }

  /**
   * @notice Mints a token. WARNING: doesn't set datas, rendering the minted NFT basically useless. Use 'safeMint()' instead.
   * @param to the address receiving the NFT.
   * @param tokenId the tokenId of the NFT about to be minted.
   */
  function mint(address to, uint256 tokenId) external onlyRole(MINTER_ROLE) {
    _mint(to, tokenId);
  }

  /**
   * @notice Mint a token, using a NFTVoucher as input
   * @dev this should be the go-to method, but i'm not 100% that removing the 'mint()' above 
   * wouldn't break the ERC721 interface. Technically, we should remove the function 'mint()' and 
   * keep this one.
   * @custom:experimental I recently came across a modified version of the ERC721 standard, dubbed 'ERC721A'.
   * This new version claims to drastically reduce the price of batch-minting tokens, while retaining most, if not all of the properties of ERC721 NFTS.
   * It might be interesting to see how we could integrate that new version into TURN. Additional research required.
   * @param to the address receiving the NFT.
   * @param tokenId the tokenId of the NFT about to be minted.
   * @param data the data element containing dates and token state (which needs to be set to 0, e.g. tradeable, by the way)
   * @param uri the Unique Ressource Identifier, pointing to external metadatas (usually an IPFS hash).
   * @return bool returns a boolean stating if the minting process suceeded or not.
   */
  function safeMint(address to, uint256 tokenId, uint256 data, string memory uri) external onlyRole(MINTER_ROLE) returns(bool) {
    require(workStatus(data) == 0, "Work status is non-zero");
    _safeMint(to, tokenId);
    datas[tokenId] = data;
    _setTokenURI(tokenId, uri);
    if(_exists(tokenId)) return true;
    else return false;
  }

  /**
   * @dev Token info.
   * @param tokenId the tokenId of the NFT you're curious about.
   * @return data a data element containing a bunch of intrinsic infos on the NFT.
   * @return status the current status of the NFT ('tradable', 'locked', 'expired', 'redeemed') in string format.
   */
  function info(uint256 tokenId)
    external
    view
    returns (uint256, string memory)
  {
    require(_exists(tokenId), "Turn: token does not exit");

    string memory status;
    uint256 data = datas[tokenId];
    
    if(isRedeemed(tokenId)) {
      status = "redeemed";
    } else if (redeemStopsAt(data) < currentTime()) {
      status = "expired";
    } else if (transferLockStartAt(data) < currentTime()) {
      status = "locked";
    } else {
      status = "tradable";
    }

    return (data, status);
  }

  /**
   * @dev Check if the token exists.
   * @param tokenId the tokenId of the NFT you're curious about.
   * @return bool A boolean that states if the token exists or not.
   */
  function exists(uint256 tokenId) external view returns (bool) {
    return _exists(tokenId);
  }

  /**
   * @dev Transfer function
   */

  function transfer(
    address to, 
    uint256 tokenId
  ) external {
    require(currentTime()<transferLockStartAt(retrieveDates(tokenId)), "Cannot transfer locked token");
    require(!isRedeemed(tokenId), "Cannot transfer redeemed tokens");
    transferFrom(_msgSender(), to, tokenId);
  }

  /**
   * @dev See {IERC721-safeTransferFrom}.
   */
  function transferFrom(
    address from,
    address to,
    uint256 tokenId
  ) public override(ERC721, IERC721) {
    // since block's timestamp is also in UNIX format, we can do a simple check against tokenId's date value
    // timestamps can be manipulated to a certain extent, but should be reliable enough over long periods of time
    require(currentTime()<transferLockStartAt(retrieveDates(tokenId)), "Cannot transfer locked token");
    require(!isRedeemed(tokenId), "Cannot transfer redeemed tokens");
    super.transferFrom(from, to, tokenId);
  }

  /**
   * @dev See {IERC721-safeTransferFrom}.
   */
  function safeTransferFrom(
    address from,
    address to,
    uint256 tokenId
  ) public virtual override(ERC721, IERC721) {
    require(currentTime()<transferLockStartAt(retrieveDates(tokenId)), "Cannot transfer locked token");
    require(!isRedeemed(tokenId), "Cannot transfer redeemed tokens");
    super.safeTransferFrom(from, to, tokenId);
  }

  /**
   * @dev See {IERC721-safeTransferFrom}.
   */
  function safeTransferFrom(
    address from,
    address to,
    uint256 tokenId,
    bytes memory _data
  ) public virtual override(ERC721, IERC721) {
    require(currentTime()<transferLockStartAt(retrieveDates(tokenId)), "Cannot transfer locked token");
    require(!isRedeemed(tokenId), "Cannot transfer redeemed tokens");
    super.safeTransferFrom(from, to, tokenId, _data);
  }

  /**
   * @dev Batch transfer function (not optimized)
   */
  function transferBatch(
    address to, 
    uint256[] calldata tokenIds
  ) external {
    transferFromBatch(_msgSender(), to, tokenIds);
  }

  /**
   * @dev Batch transferFrom function (not optimized)
   */
  function transferFromBatch(
    address from,
    address to, 
    uint256[] calldata tokenIds
  ) public {

    // makes checks before going into the transfer routine, if not, it might revert after ouch-levels of gas used
    for(uint i=0; i < tokenIds.length; i++) {
      require(currentTime()<transferLockStartAt(retrieveDates(tokenIds[i])), "Cannot transfer locked token");
      require(_isApprovedOrOwner(from, tokenIds[i]), "ERC721: transfer caller is not owner nor approved");
      require(!isRedeemed(tokenIds[i]), "Cannot transfer redeemed tokens");
    }

    for(uint i = 0; i< tokenIds.length; i++) {
      transferFrom(from,to,tokenIds[i]);
    }
  }

  /**
   * @notice token redeemal process
   * @dev The function uses a service provider signature to allow the redeemal of tokens on-chain. *any* service provider can redeem *any* tokens, however.
   * It is not really an issue, as we still have some form of tracability on whom allowed the redeemal process to take place. This any -> any relationship has some nifty usecases,
   * such as a the sale of concert tickets on one hand, and the validation of a ticket, on-site, by a vetted third-party.
   * / Service provider claims that the service has been provided, user confirms that it's the case and sets the token state to 'completed') 
   * @param tokenIds an array of tokenIds one wish to redeem.
   * @param voucher a voucher signed by the service provider specifying the conditions necessary to redeem tokens (mainly, the amount and type of tokens required and the client's address)
   */
  function redeem(
    uint256[] calldata tokenIds,
    RedeemVoucher calldata voucher
  ) public {
    redeemFrom(_msgSender(), tokenIds, voucher);
  }

  /**
   * @notice token redeemal process
   * @dev @dev The function uses a service provider signature to allow the redeemal of tokens on-chain. *any* service provider can redeem *any* tokens, however.
   * It is not really an issue, as we still have some form of tracability on whom allowed the redeemal process to take place. This any -> any relationship has some nifty usecases,
   * such as a the sale of concert tickets on one hand, and the validation of a ticket, on-site, by a vetted third-party.
   * @param from the address you're redeeming tokens from.
   * @param tokenIds an array of tokenIds one wish to redeem.
   * @param voucher a voucher signed by the service provider specifying the conditions necessary to redeem tokens (mainly, the amount and type of tokens required and the client's address)
   */
  function redeemFrom(
    address from,
    uint256[] calldata tokenIds,
    RedeemVoucher calldata voucher
  ) public 
    nonReentrant() 
  {
    require(hasRole(MINTER_ROLE, voucher.auctionContract), "target contract is not a minter");
    require(TurnAuction(voucher.auctionContract).hasRole(PROVIDER_ROLE, verify(voucher)), "Signer is not a service provider");
    require(tokenIds.length == voucher.tokenAmount, "invalid amount of tokens");
    require(_msgSender() == voucher.redeemerAddress, "invalid redeemer");
    // makes checks before going into the transfer routine, if not, it might revert after ouch-levels of gas used
    for(uint i=0; i < tokenIds.length; i++) {
      require(currentTime()< redeemStopsAt(retrieveDates(tokenIds[i])), "Cannot start work with expired tokens");
      require(_isApprovedOrOwner(from, tokenIds[i]), "ERC721: transfer caller is not owner nor approved");
      require(_tokenGroup(tokenIds[i]) == _toTokenGroup256(voucher.tokenGroup), "invalid token group");
    }

    for(uint i = 0; i< tokenIds.length; i++) {
      _changeWorkStatus(tokenIds[i], 1);
    }
    emit Redeem(from, tokenIds, voucher);
  }

  /**
   * @notice checks if a token has been redeemed.
   * @param tokenId the tokenId of the NFT you're curious about.
   * @return bool the current state of the NFT.
   */
  function isRedeemed(uint256 tokenId) public view returns(bool) {
    if(workStatus(retrieveDates(tokenId)) != 0) return true;
    else return false;
  }

  /**
   * @notice returns all tokens owned by a user.
   * @dev it's actually hard to reconstruct that list from the Ethereum ledger, so we created that helper function.
   * @param user the address of the user you're curious about.
   * @return tokenIds an array of all the NFTs owned by that user.
   */
  function getAllTokens(address user) public view returns(uint256[] memory) {
    uint256 balanceOf = balanceOf(user);
    uint256[] memory tokens = new uint256[](balanceOf);
    for(uint i=0; i< balanceOf; i++) {
      tokens[i] = tokenOfOwnerByIndex(user, i);
    }

    return tokens;
  }

  /**
   * @notice filters tokens whether they're redeemed or not
   * @dev another helper function (because reconstructing data from the ledger is hard)
   * @param user the address of the user you're curious about.
   * @param countingRedeemed set to 'True' if you want the list of redeemed tokens, 'False' if you want the list of non-redeemed tokens.dev
   * @return tokenIds array of NFTs owned by that user and compliant with the 'countingRedeemed' parameter.
   */
  function _getFilteredTokens(address user, bool countingRedeemed) internal view returns (uint256[] memory) {
    uint256[] memory allTokens = getAllTokens(user);
    uint256 count = 0;

    // counting the amount of elements 
    for(uint i=0; i<allTokens.length; i++) {
      if(countingRedeemed) {
        if(isRedeemed(allTokens[i])) count++;
      }
      else {
        if(isRedeemed(allTokens[i])) {} 
        else count++;
      }
    }

    uint256[] memory filteredTokens = new uint256[](count);
    uint256 j = 0;

    for(uint i=0; i<allTokens.length; i++) {
      if(countingRedeemed) {
        if(isRedeemed(allTokens[i])) {
          filteredTokens[j] = allTokens[i];
          j++;
        }
      }
      else {
        if(isRedeemed(allTokens[i])) {} 
        else {
          filteredTokens[j] = allTokens[i];
          j++;
        }
      }
    }

    return filteredTokens;
  }

  /**
   * @notice returns a filtered version of the list in input, by tokenGroup
   * @param tokenList an array of tokenIds
   * @param tokenGroupId the tokenGroupId you want to filter the list with
   * @return tokenIds returns an array tokenIds that belongs to the the tokenGroup given in input.
   */
  function _getTokenGroupFilter(uint256[] memory tokenList, uint256 tokenGroupId) internal pure returns (uint256[] memory) {
    uint256 count = 0;

    // counting the amount of elements 
    for(uint i=0; i<tokenList.length; i++) {
      if(_tokenGroup(tokenList[i]) == tokenGroupId) count++;
    }

    uint256[] memory filteredTokens = new uint256[](count);
    uint256 j = 0;

    for(uint i=0; i<tokenList.length; i++) {
      if(_tokenGroup(tokenList[i]) == tokenGroupId) {
        filteredTokens[j] = tokenList[i];
        j++;
      }
    }

    return filteredTokens;
  }

  /**
   * @notice returns a list of all redeemed tokens by a user.
   * @dev helper function.
   * @param user the address of the user you're curious about.
   * @return tokenIds an array of tokenIds redeemed by that user.
   */
  function getRedeemTokens(address user) public view returns (uint256[] memory) {
    return _getFilteredTokens(user, true);
  }

  /**
   * @notice returns a list of all available tokens.
   * @dev helper function.
   * @param user the address of the user you're curious about.
   * @return tokenIds an array of tokenIds available for redeemal by that user.
   */
  function getAvailableTokens(address user) public view returns (uint256[] memory) {
    return _getFilteredTokens(user, false);
  }

  /**
   * @notice returns a list of all redeemed tokens for a given user and token group.
   * @dev helper function.
   * @param user the address of the user you're curious about.
   * @param tokenGroupId the tokenGroupId you want to filter your list with, in uint128 format.

   */
  function getRedeemTokensByGroup(address user, uint128 tokenGroupId) external view returns (uint256[] memory) {
    uint256[] memory tokenList = getRedeemTokens(user);
    // need to reformat groupId for internal usage
    uint256 tokenGroupId256 = _toTokenGroup256(tokenGroupId);
    return _getTokenGroupFilter(tokenList, tokenGroupId256);
  }

  /**
   * @notice returns a list of all available tokens for a given user and token group.
   * @dev helper function.
   * @param user the address of the user you're curious about.
   * @param tokenGroupId the tokenGroupId you want to filter your list with, in uint128 format.
   */
  function getAvailableTokensByGroup(address user, uint128 tokenGroupId) external view returns (uint256[] memory) {
    uint256[] memory tokenList = getAvailableTokens(user);
    // need to reformat groupId for internal usage
    uint256 tokenGroupId256 = _toTokenGroup256(tokenGroupId);
    return _getTokenGroupFilter(tokenList, tokenGroupId256);
  }

  /**
   * @notice Burn function. Only works for expired tokens.
   */
  function burn(
    uint256 tokenId
  ) external {
    require(_isApprovedOrOwner(_msgSender(), tokenId), "caller is not owner or approved");
    require(block.timestamp > workPeriodEnd(retrieveDates(tokenId)), "cannot burn non-expired tokens");
  
    _burn(tokenId);
  }

  /**
   * @notice Burn function. Only works for expired tokens.
   */
  function burnBatch(
    uint256[] memory tokenIds
  ) public {
    for(uint i=0; i<tokenIds.length; i++) {
      require(_isApprovedOrOwner(_msgSender(), tokenIds[i]), "caller is not owner or approved");
      require(block.timestamp > workPeriodEnd(retrieveDates(tokenIds[i])), "cannot burn non-expired tokens");
    }
    for(uint i=0; i<tokenIds.length; i++) {
      _burn(tokenIds[i]);
    }
  }

  /**
   * @notice retrieve datas for a given tokenIddev.
   * @dev getter function. I know that I could've just flagged 'datas' as a public mapping, but for some reasons I didn't.
   * @param tokenId the tokenId of the NFT you're curious about.
   * @return data the data element of said NFT.
   */
  function retrieveDates(uint256 tokenId) public view returns(uint256) {
    return datas[tokenId];
  }

  /**
   * @notice external version of _tokenGroup (in uint128 format)
   * @dev as Javascript/Typescript only handles variables of lengths up to 64 bits natively, one needs to use BigNumber classes to handle uint256s and uint128s.
   * In that regard, even though the token group is just the 126 first bits of a tokenId, it's actually hard to properly retrieve it from a BigNumber.
   * This function is here to easily get a properly formatted tokenGroup that you can directly use.
   * @param tokenId the tokenId of the NFT you're curious about.
   * @return tokenGroup the tokenGroup of said NFT, in uint128 format.
   */
  function tokenGroup(uint256 tokenId) external pure returns(uint128) {
    tokenId = tokenId >> 128; // erases the 128 last bits of tokenID 
    return uint128(tokenId);
  }

  /**
   * @notice returns the tokenGroup of a given NFT.
   * @param tokenId the tokenId of the NFT you're curious about.
   * @return tokenGroup the tokenGroup of said NFT, in uint256 format.
   */
  function _tokenGroup(uint256 tokenId) internal pure returns(uint256) {
    return (tokenId >> 128) << 128; // erases the 128 last bits of tokenID
  }

  /**
   * @notice Helper function to convert uint128 tokenGroups into its 256bit counterpart
   * @param groupId  the tokenGroup identifier in uint128 format
   * @return tokenGroup256 a left-padded version of that same tokenGroup
   */
  function _toTokenGroup256(uint128 groupId) internal pure returns(uint256) {
    return uint256(groupId) << 128;
  }

  /**
   * @notice internal method to change workStatus to non-zero value.
   * @param tokenId the tokenId of the NFT you want to change the status.
   * @param newStatus the new status you intend to apply to your NFT.
   */
  function _changeWorkStatus(uint256 tokenId, uint32 newStatus) internal {
    uint256 oldDatas = retrieveDates(tokenId);
    require(workStatus(oldDatas) == 0, "work status is non-zero");
    require(newStatus != 0, "cannot set work status to zero");
    // erasing the H slot directly (can be done this way only because it's the 'easiest' one to access)
    uint256 newDatas = ((oldDatas >> 32) << 32) + newStatus;
    datas[tokenId] = newDatas;
  }

  /** 
   * @notice Returns a hash of the given RedeemVoucher, prepared using EIP712 typed data hashing rules.
   * @dev This function is used by 'verify()' in order to retrieve the address of the voucher's signer.
   * @param voucher A RedeemVoucher to hash.
   * @return hash the hash of the RedeemVoucher in bytes32 format.
   */
  function _hash(RedeemVoucher calldata voucher) internal view returns (bytes32) {
    return
      _hashTypedDataV4(
        keccak256(
          abi.encode(
            keccak256(
              "NFTVoucher(uint256 tokenAmount,address redeemerAddress,address auctionContract,uint128 tokenGroup)"
            ),
            voucher.tokenAmount,
            voucher.redeemerAddress,
            voucher.auctionContract,
            voucher.tokenGroup
          )
        )
      );
  }

  /**
   * @notice Verifies the signature for a given RedeemVoucher, returning the address of the signer. Signature is based on the EIP712 standard.
   * @dev Will revert if the signature is invalid. Does not verify that the signer is an authorized service provider.
   * @param voucher A RedeemVoucher describing the auction you're curious about.
   * @return signer the address of the guy who signed that redeemal voucher.
   */
  function verify(RedeemVoucher calldata voucher)
    public
    view
    returns (address)
  {
    bytes32 digest = _hash(voucher);
    return ECDSA.recover(digest, voucher.signature);
  }

  /**
   * @notice returns the voucher's signer address. Signature is based on the EIP712 standard.
   * @dev similar to 'verify()', which is also a public function doing exactly the same thing.
   * Will revert if the signature is invalid. Does not verify that the signer is actually a service provider.
   * @param voucher An RedeemVoucher describing the auction you're curious about.
   * @return signer the address of the guy who signed that redeemal voucher.
   */
  function getVoucherSigner(RedeemVoucher calldata voucher)
    public
    view
    returns (address signer)
  {
    signer = verify(voucher);
  }

  /**
   * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each
   * token will be the concatenation of the `baseURI` and the `tokenId`. Empty
   * by default, can be overriden in child contracts.
   */
  function _baseURI() internal pure override returns (string memory) {
    return "https://ipfs.infura.io/ipfs/";
  }
}