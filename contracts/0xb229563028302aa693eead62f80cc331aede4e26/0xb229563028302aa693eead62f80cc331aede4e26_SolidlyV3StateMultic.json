{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/SolidlyV3StateMulticall.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: ISC\\npragma solidity 0.7.5;\\npragma abicoder v2;\\n\\nimport \\\"./interfaces/IUniswapV3Pool.sol\\\";\\nimport \\\"./interfaces/IUniswapV3Factory.sol\\\";\\nimport \\\"./interfaces/IUniswapV3StateMulticall.sol\\\";\\n\\ncontract SolidlyV3StateMulticall is IUniswapV3StateMulticall {\\n    function getFullState(\\n        IUniswapV3Factory factory,\\n        address tokenIn,\\n        address tokenOut,\\n        int24 tickSpacing,\\n        int16 tickBitmapStart,\\n        int16 tickBitmapEnd\\n    ) external view override returns (StateResult memory state) {\\n        require(tickBitmapEnd >= tickBitmapStart, \\\"tickBitmapEnd < tickBitmapStart\\\");\\n\\n        state = _fillStateWithoutTicks(factory, tokenIn, tokenOut, tickSpacing, tickBitmapStart, tickBitmapEnd);\\n        state.ticks = _calcTicksFromBitMap(factory, tokenIn, tokenOut, tickSpacing, state.tickBitmap);\\n    }\\n\\n    function getFullStateWithoutTicks(\\n        IUniswapV3Factory factory,\\n        address tokenIn,\\n        address tokenOut,\\n        int24 tickSpacing,\\n        int16 tickBitmapStart,\\n        int16 tickBitmapEnd\\n    ) external view override returns (StateResult memory state) {\\n        require(tickBitmapEnd >= tickBitmapStart, \\\"tickBitmapEnd < tickBitmapStart\\\");\\n\\n        return _fillStateWithoutTicks(factory, tokenIn, tokenOut, tickSpacing, tickBitmapStart, tickBitmapEnd);\\n    }\\n\\n    function getFullStateWithRelativeBitmaps(\\n        IUniswapV3Factory factory,\\n        address tokenIn,\\n        address tokenOut,\\n        int24 tickSpacing,\\n        int16 leftBitmapAmount,\\n        int16 rightBitmapAmount\\n    ) external view override returns (StateResult memory state) {\\n        require(leftBitmapAmount > 0, \\\"leftBitmapAmount <= 0\\\");\\n        require(rightBitmapAmount > 0, \\\"rightBitmapAmount <= 0\\\");\\n\\n        state = _fillStateWithoutBitmapsAndTicks(factory, tokenIn, tokenOut, tickSpacing);\\n        int16 currentBitmapIndex = _getBitmapIndexFromTick(state.slot0.tick / state.tickSpacing);\\n\\n        state.tickBitmap = _calcTickBitmaps(\\n            factory,\\n            tokenIn,\\n            tokenOut,\\n            tickSpacing,\\n            currentBitmapIndex - leftBitmapAmount,\\n            currentBitmapIndex + rightBitmapAmount\\n        );\\n        state.ticks = _calcTicksFromBitMap(factory, tokenIn, tokenOut, tickSpacing, state.tickBitmap);\\n    }\\n\\n    function getAdditionalBitmapWithTicks(\\n        IUniswapV3Factory factory,\\n        address tokenIn,\\n        address tokenOut,\\n        int24 tickSpacing,\\n        int16 tickBitmapStart,\\n        int16 tickBitmapEnd\\n    ) external view override returns (TickBitMapMappings[] memory tickBitmap, TickInfoMappings[] memory ticks) {\\n        require(tickBitmapEnd >= tickBitmapStart, \\\"tickBitmapEnd < tickBitmapStart\\\");\\n\\n        tickBitmap = _calcTickBitmaps(factory, tokenIn, tokenOut, tickSpacing, tickBitmapStart, tickBitmapEnd);\\n        ticks = _calcTicksFromBitMap(factory, tokenIn, tokenOut, tickSpacing, tickBitmap);\\n    }\\n\\n    function getAdditionalBitmapWithoutTicks(\\n        IUniswapV3Factory factory,\\n        address tokenIn,\\n        address tokenOut,\\n        int24 tickSpacing,\\n        int16 tickBitmapStart,\\n        int16 tickBitmapEnd\\n    ) external view override returns (TickBitMapMappings[] memory tickBitmap) {\\n        require(tickBitmapEnd >= tickBitmapStart, \\\"tickBitmapEnd < tickBitmapStart\\\");\\n\\n        return _calcTickBitmaps(factory, tokenIn, tokenOut, tickSpacing, tickBitmapStart, tickBitmapEnd);\\n    }\\n\\n    function _fillStateWithoutTicks(\\n        IUniswapV3Factory factory,\\n        address tokenIn,\\n        address tokenOut,\\n        int24 tickSpacing,\\n        int16 tickBitmapStart,\\n        int16 tickBitmapEnd\\n    ) internal view returns (StateResult memory state) {\\n        state = _fillStateWithoutBitmapsAndTicks(factory, tokenIn, tokenOut, tickSpacing);\\n        state.tickBitmap = _calcTickBitmaps(factory, tokenIn, tokenOut, tickSpacing, tickBitmapStart, tickBitmapEnd);\\n    }\\n\\n    function _fillStateWithoutBitmapsAndTicks(\\n        IUniswapV3Factory factory,\\n        address tokenIn,\\n        address tokenOut,\\n        int24 tickSpacing\\n    ) internal view returns (StateResult memory state) {\\n        IUniswapV3Pool pool = _getPool(factory, tokenIn, tokenOut, tickSpacing);\\n\\n        state.pool = pool;\\n        state.blockTimestamp = block.timestamp;\\n        state.liquidity = pool.liquidity();\\n        state.tickSpacing = pool.tickSpacing();\\n        state.maxLiquidityPerTick = pool.maxLiquidityPerTick();\\n\\n        (\\n            state.slot0.sqrtPriceX96,\\n            state.slot0.tick,\\n            state.slot0.fee,\\n            state.slot0.unlocked\\n        ) = pool.slot0();\\n    }\\n\\n    function _calcTickBitmaps(\\n        IUniswapV3Factory factory,\\n        address tokenIn,\\n        address tokenOut,\\n        int24 tickSpacing,\\n        int16 tickBitmapStart,\\n        int16 tickBitmapEnd\\n    ) internal view returns (TickBitMapMappings[] memory tickBitmap) {\\n        IUniswapV3Pool pool = _getPool(factory, tokenIn, tokenOut, tickSpacing);\\n\\n        uint256 numberOfPopulatedBitmaps = 0;\\n        for (int256 i = tickBitmapStart; i <= tickBitmapEnd; i++) {\\n            uint256 bitmap = pool.tickBitmap(int16(i));\\n            if (bitmap == 0) continue;\\n            numberOfPopulatedBitmaps++;\\n        }\\n\\n        tickBitmap = new TickBitMapMappings[](numberOfPopulatedBitmaps);\\n        uint256 globalIndex = 0;\\n        for (int256 i = tickBitmapStart; i <= tickBitmapEnd; i++) {\\n            int16 index = int16(i);\\n            uint256 bitmap = pool.tickBitmap(index);\\n            if (bitmap == 0) continue;\\n\\n            tickBitmap[globalIndex] = TickBitMapMappings({ index: index, value: bitmap });\\n            globalIndex++;\\n        }\\n    }\\n\\n    function _calcTicksFromBitMap(\\n        IUniswapV3Factory factory,\\n        address tokenIn,\\n        address tokenOut,\\n        int24 tickSpacing,\\n        TickBitMapMappings[] memory tickBitmap\\n    ) internal view returns (TickInfoMappings[] memory ticks) {\\n        IUniswapV3Pool pool = _getPool(factory, tokenIn, tokenOut, tickSpacing);\\n\\n        uint256 numberOfPopulatedTicks = 0;\\n        for (uint256 i = 0; i < tickBitmap.length; i++) {\\n            uint256 bitmap = tickBitmap[i].value;\\n\\n            for (uint256 j = 0; j < 256; j++) {\\n                if (bitmap & (1 << j) > 0) numberOfPopulatedTicks++;\\n            }\\n        }\\n\\n        ticks = new TickInfoMappings[](numberOfPopulatedTicks);\\n        int24 poolTickSpacing = pool.tickSpacing();\\n\\n        uint256 globalIndex = 0;\\n        for (uint256 i = 0; i < tickBitmap.length; i++) {\\n            uint256 bitmap = tickBitmap[i].value;\\n\\n            for (uint256 j = 0; j < 256; j++) {\\n                if (bitmap & (1 << j) > 0) {\\n                    int24 populatedTick = ((int24(tickBitmap[i].index) << 8) + int24(j)) * poolTickSpacing;\\n\\n                    ticks[globalIndex].index = populatedTick;\\n                    TickInfo memory newTickInfo = ticks[globalIndex].value;\\n\\n                    (\\n                        newTickInfo.liquidityGross,\\n                        newTickInfo.liquidityNet,\\n                        newTickInfo.initialized\\n                    ) = pool.ticks(populatedTick);\\n\\n                    globalIndex++;\\n                }\\n            }\\n        }\\n    }\\n\\n    function _getPool(\\n        IUniswapV3Factory factory,\\n        address tokenIn,\\n        address tokenOut,\\n        int24 tickSpacing\\n    ) internal view returns (IUniswapV3Pool pool) {\\n        pool = IUniswapV3Pool(factory.getPool(tokenIn, tokenOut, tickSpacing));\\n        require(address(pool) != address(0), \\\"Pool does not exist\\\");\\n    }\\n\\n    function _getBitmapIndexFromTick(int24 tick) internal pure returns (int16) {\\n        return int16(tick >> 8);\\n    }\\n}\"\r\n    },\r\n    \"src/interfaces/IUniswapV3Pool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: ISC\\npragma solidity 0.7.5;\\npragma abicoder v2;\\n\\nimport \\\"./pool/IUniswapV3PoolImmutables.sol\\\";\\nimport \\\"./pool/IUniswapV3PoolState.sol\\\";\\n\\n/// @title The interface for a Uniswap V3 Pool\\n/// @notice A Uniswap pool facilitates swapping and automated market making between any two assets that strictly conform\\n/// to the ERC20 specification\\n/// @dev The pool interface is broken up into many smaller pieces\\n// solhint-disable-next-line no-empty-blocks\\ninterface IUniswapV3Pool is IUniswapV3PoolImmutables, IUniswapV3PoolState {\\n\\n}\"\r\n    },\r\n    \"src/interfaces/IUniswapV3Factory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: ISC\\npragma solidity 0.7.5;\\npragma abicoder v2;\\n\\n/// @title The interface for the Uniswap V3 Factory\\n/// @notice The Uniswap V3 Factory facilitates creation of Uniswap V3 pools and control over the protocol fees\\ninterface IUniswapV3Factory {\\n    /// @notice Emitted when the owner of the factory is changed\\n    /// @param oldOwner The owner before the owner was changed\\n    /// @param newOwner The owner after the owner was changed\\n    event OwnerChanged(address indexed oldOwner, address indexed newOwner);\\n\\n    /// @notice Emitted when a pool is created\\n    /// @param token0 The first token of the pool by address sort order\\n    /// @param token1 The second token of the pool by address sort order\\n    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\\n    /// @param tickSpacing The minimum number of ticks between initialized ticks\\n    /// @param pool The address of the created pool\\n    event PoolCreated(\\n        address indexed token0,\\n        address indexed token1,\\n        uint24 indexed fee,\\n        int24 tickSpacing,\\n        address pool\\n    );\\n\\n    /// @notice Emitted when a new fee amount is enabled for pool creation via the factory\\n    /// @param fee The enabled fee, denominated in hundredths of a bip\\n    /// @param tickSpacing The minimum number of ticks between initialized ticks for pools created with the given fee\\n    event FeeAmountEnabled(uint24 indexed fee, int24 indexed tickSpacing);\\n\\n    /// @notice Returns the current owner of the factory\\n    /// @dev Can be changed by the current owner via setOwner\\n    /// @return The address of the factory owner\\n    function owner() external view returns (address);\\n\\n    /// @notice Returns the tick spacing for a given fee amount, if enabled, or 0 if not enabled\\n    /// @dev A fee amount can never be removed, so this value should be hard coded or cached in the calling context\\n    /// @param fee The enabled fee, denominated in hundredths of a bip. Returns 0 in case of unenabled fee\\n    /// @return The tick spacing\\n    function feeAmountTickSpacing(uint24 fee) external view returns (int24);\\n\\n    /// @notice Returns the pool address for a given pair of tokens and a fee, or address 0 if it does not exist\\n    /// @dev tokenA and tokenB may be passed in either token0/token1 or token1/token0 order\\n    /// @param tokenA The contract address of either token0 or token1\\n    /// @param tokenB The contract address of the other token\\n    /// @return pool The pool address\\n    function getPool(\\n        address tokenA,\\n        address tokenB,\\n        int24 tickSpacing\\n    ) external view returns (address pool);\\n\\n    /// @notice Creates a pool for the given two tokens and fee\\n    /// @param tokenA One of the two tokens in the desired pool\\n    /// @param tokenB The other of the two tokens in the desired pool\\n    /// @param fee The desired fee for the pool\\n    /// @dev tokenA and tokenB may be passed in either order: token0/token1 or token1/token0. tickSpacing is retrieved\\n    /// from the fee. The call will revert if the pool already exists, the fee is invalid, or the token arguments\\n    /// are invalid.\\n    /// @return pool The address of the newly created pool\\n    function createPool(\\n        address tokenA,\\n        address tokenB,\\n        uint24 fee\\n    ) external returns (address pool);\\n\\n    /// @notice Updates the owner of the factory\\n    /// @dev Must be called by the current owner\\n    /// @param _owner The new owner of the factory\\n    function setOwner(address _owner) external;\\n\\n    /// @notice Enables a fee amount with the given tickSpacing\\n    /// @dev Fee amounts may never be removed once enabled\\n    /// @param fee The fee amount to enable, denominated in hundredths of a bip (i.e. 1e-6)\\n    /// @param tickSpacing The spacing between ticks to be enforced for all pools created with the given fee amount\\n    function enableFeeAmount(uint24 fee, int24 tickSpacing) external;\\n}\"\r\n    },\r\n    \"src/interfaces/IUniswapV3StateMulticall.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: ISC\\npragma solidity 0.7.5;\\npragma abicoder v2;\\n\\nimport \\\"./IUniswapV3Pool.sol\\\";\\nimport \\\"./IUniswapV3Factory.sol\\\";\\n\\ninterface IUniswapV3StateMulticall {\\n    struct Slot0 {\\n        uint160 sqrtPriceX96;\\n        int24 tick;\\n        uint24 fee;\\n        bool unlocked;\\n    }\\n\\n    struct TickBitMapMappings {\\n        int16 index;\\n        uint256 value;\\n    }\\n\\n    struct TickInfo {\\n        uint128 liquidityGross;\\n        int128 liquidityNet;\\n        bool initialized;\\n    }\\n\\n    struct TickInfoMappings {\\n        int24 index;\\n        TickInfo value;\\n    }\\n\\n    struct StateResult {\\n        IUniswapV3Pool pool;\\n        uint256 blockTimestamp;\\n        Slot0 slot0;\\n        uint128 liquidity;\\n        int24 tickSpacing;\\n        uint128 maxLiquidityPerTick;\\n        TickBitMapMappings[] tickBitmap;\\n        TickInfoMappings[] ticks;\\n    }\\n\\n    function getFullState(\\n        IUniswapV3Factory factory,\\n        address tokenIn,\\n        address tokenOut,\\n        int24 tickSpacing,\\n        int16 tickBitmapStart,\\n        int16 tickBitmapEnd\\n    ) external view returns (StateResult memory state);\\n\\n    function getFullStateWithoutTicks(\\n        IUniswapV3Factory factory,\\n        address tokenIn,\\n        address tokenOut,\\n        int24 tickSpacing,\\n        int16 tickBitmapStart,\\n        int16 tickBitmapEnd\\n    ) external view returns (StateResult memory state);\\n\\n    function getFullStateWithRelativeBitmaps(\\n        IUniswapV3Factory factory,\\n        address tokenIn,\\n        address tokenOut,\\n        int24 tickSpacing,\\n        int16 leftBitmapAmount,\\n        int16 rightBitmapAmount\\n    ) external view returns (StateResult memory state);\\n\\n    function getAdditionalBitmapWithTicks(\\n        IUniswapV3Factory factory,\\n        address tokenIn,\\n        address tokenOut,\\n        int24 tickSpacing,\\n        int16 tickBitmapStart,\\n        int16 tickBitmapEnd\\n    ) external view returns (TickBitMapMappings[] memory tickBitmap, TickInfoMappings[] memory ticks);\\n\\n    function getAdditionalBitmapWithoutTicks(\\n        IUniswapV3Factory factory,\\n        address tokenIn,\\n        address tokenOut,\\n        int24 tickSpacing,\\n        int16 tickBitmapStart,\\n        int16 tickBitmapEnd\\n    ) external view returns (TickBitMapMappings[] memory tickBitmap);\\n}\"\r\n    },\r\n    \"src/interfaces/pool/IUniswapV3PoolImmutables.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: ISC\\npragma solidity 0.7.5;\\npragma abicoder v2;\\n\\n/// @title Pool state that never changes\\n/// @notice These parameters are fixed for a pool forever, i.e., the methods will always return the same values\\ninterface IUniswapV3PoolImmutables {\\n    /// @notice The contract that deployed the pool, which must adhere to the IUniswapV3Factory interface\\n    /// @return The contract address\\n    function factory() external view returns (address);\\n\\n    /// @notice The first of the two tokens of the pool, sorted by address\\n    /// @return The token contract address\\n    function token0() external view returns (address);\\n\\n    /// @notice The second of the two tokens of the pool, sorted by address\\n    /// @return The token contract address\\n    function token1() external view returns (address);\\n\\n    /// @notice The pool's fee in hundredths of a bip, i.e. 1e-6\\n    /// @return The fee\\n    function fee() external view returns (uint24);\\n\\n    /// @notice The pool tick spacing\\n    /// @dev Ticks can only be used at multiples of this value, minimum of 1 and always positive\\n    /// e.g.: a tickSpacing of 3 means ticks can be initialized every 3rd tick, i.e., ..., -6, -3, 0, 3, 6, ...\\n    /// This value is an int24 to avoid casting even though it is always positive.\\n    /// @return The tick spacing\\n    function tickSpacing() external view returns (int24);\\n\\n    /// @notice The maximum amount of position liquidity that can use any tick in the range\\n    /// @dev This parameter is enforced per tick to prevent liquidity from overflowing a uint128 at any point, and\\n    /// also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to a pool\\n    /// @return The max amount of liquidity per tick\\n    function maxLiquidityPerTick() external view returns (uint128);\\n}\"\r\n    },\r\n    \"src/interfaces/pool/IUniswapV3PoolState.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: ISC\\npragma solidity 0.7.5;\\npragma abicoder v2;\\n\\n/// @title Pool state that can change\\n/// @notice These methods compose the pool's state, and can change with any frequency including multiple times\\n/// per transaction\\ninterface IUniswapV3PoolState {\\n    /// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas\\n    /// when accessed externally.\\n    /// @return sqrtPriceX96 The current price of the pool as a sqrt(token1/token0) Q64.96 value\\n    /// tick The current tick of the pool, i.e. according to the last tick transition that was run.\\n    /// This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick\\n    /// boundary.\\n    /// feeProtocol The protocol fee for both tokens of the pool.\\n    /// Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0\\n    /// is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee.\\n    /// unlocked Whether the pool is currently locked to reentrancy\\n    function slot0()\\n    external\\n    view\\n    returns (\\n        uint160 sqrtPriceX96,\\n        int24 tick,\\n        uint24 fee,\\n        bool unlocked\\n    );\\n\\n    /// @notice The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool\\n    /// @dev This value can overflow the uint256\\n    function feeGrowthGlobal0X128() external view returns (uint256);\\n\\n    /// @notice The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool\\n    /// @dev This value can overflow the uint256\\n    function feeGrowthGlobal1X128() external view returns (uint256);\\n\\n    /// @notice The amounts of token0 and token1 that are owed to the protocol\\n    /// @dev Protocol fees will never exceed uint128 max in either token\\n    function protocolFees() external view returns (uint128 token0, uint128 token1);\\n\\n    /// @notice The currently in range liquidity available to the pool\\n    /// @dev This value has no relationship to the total liquidity across all ticks\\n    function liquidity() external view returns (uint128);\\n\\n    /// @notice Look up information about a specific tick in the pool\\n    /// @param tick The tick to look up\\n    /// @return liquidityGross the total amount of position liquidity that uses the pool either as tick lower or\\n    /// tick upper,\\n    /// liquidityNet how much liquidity changes when the pool price crosses the tick,\\n    /// feeGrowthOutside0X128 the fee growth on the other side of the tick from the current tick in token0,\\n    /// feeGrowthOutside1X128 the fee growth on the other side of the tick from the current tick in token1,\\n    /// tickCumulativeOutside the cumulative tick value on the other side of the tick from the current tick\\n    /// secondsPerLiquidityOutsideX128 the seconds spent per liquidity on the other side of the tick from the current tick,\\n    /// secondsOutside the seconds spent on the other side of the tick from the current tick,\\n    /// initialized Set to true if the tick is initialized, i.e. liquidityGross is greater than 0, otherwise equal to false.\\n    /// Outside values can only be used if the tick is initialized, i.e. if liquidityGross is greater than 0.\\n    /// In addition, these values are only relative and must be used only in comparison to previous snapshots for\\n    /// a specific position.\\n    function ticks(int24 tick)\\n    external\\n    view\\n    returns (\\n        uint128 liquidityGross,\\n        int128 liquidityNet,\\n        bool initialized\\n    );\\n\\n    /// @notice Returns 256 packed tick initialized boolean values. See TickBitmap for more information\\n    function tickBitmap(int16 wordPosition) external view returns (uint256);\\n\\n    /// @notice Returns the information about a position by the position's key\\n    /// @param key The position's key is a hash of a preimage composed by the owner, tickLower and tickUpper\\n    /// @return _liquidity The amount of liquidity in the position,\\n    /// Returns feeGrowthInside0LastX128 fee growth of token0 inside the tick range as of the last mint/burn/poke,\\n    /// Returns feeGrowthInside1LastX128 fee growth of token1 inside the tick range as of the last mint/burn/poke,\\n    /// Returns tokensOwed0 the computed amount of token0 owed to the position as of the last mint/burn/poke,\\n    /// Returns tokensOwed1 the computed amount of token1 owed to the position as of the last mint/burn/poke\\n    function positions(bytes32 key)\\n    external\\n    view\\n    returns (\\n        uint128 _liquidity,\\n        uint256 feeGrowthInside0LastX128,\\n        uint256 feeGrowthInside1LastX128,\\n        uint128 tokensOwed0,\\n        uint128 tokensOwed1\\n    );\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IUniswapV3Factory\",\"name\":\"factory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"int24\",\"name\":\"tickSpacing\",\"type\":\"int24\"},{\"internalType\":\"int16\",\"name\":\"tickBitmapStart\",\"type\":\"int16\"},{\"internalType\":\"int16\",\"name\":\"tickBitmapEnd\",\"type\":\"int16\"}],\"name\":\"getAdditionalBitmapWithTicks\",\"outputs\":[{\"components\":[{\"internalType\":\"int16\",\"name\":\"index\",\"type\":\"int16\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"internalType\":\"struct IUniswapV3StateMulticall.TickBitMapMappings[]\",\"name\":\"tickBitmap\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"int24\",\"name\":\"index\",\"type\":\"int24\"},{\"components\":[{\"internalType\":\"uint128\",\"name\":\"liquidityGross\",\"type\":\"uint128\"},{\"internalType\":\"int128\",\"name\":\"liquidityNet\",\"type\":\"int128\"},{\"internalType\":\"bool\",\"name\":\"initialized\",\"type\":\"bool\"}],\"internalType\":\"struct IUniswapV3StateMulticall.TickInfo\",\"name\":\"value\",\"type\":\"tuple\"}],\"internalType\":\"struct IUniswapV3StateMulticall.TickInfoMappings[]\",\"name\":\"ticks\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IUniswapV3Factory\",\"name\":\"factory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"int24\",\"name\":\"tickSpacing\",\"type\":\"int24\"},{\"internalType\":\"int16\",\"name\":\"tickBitmapStart\",\"type\":\"int16\"},{\"internalType\":\"int16\",\"name\":\"tickBitmapEnd\",\"type\":\"int16\"}],\"name\":\"getAdditionalBitmapWithoutTicks\",\"outputs\":[{\"components\":[{\"internalType\":\"int16\",\"name\":\"index\",\"type\":\"int16\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"internalType\":\"struct IUniswapV3StateMulticall.TickBitMapMappings[]\",\"name\":\"tickBitmap\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IUniswapV3Factory\",\"name\":\"factory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"int24\",\"name\":\"tickSpacing\",\"type\":\"int24\"},{\"internalType\":\"int16\",\"name\":\"tickBitmapStart\",\"type\":\"int16\"},{\"internalType\":\"int16\",\"name\":\"tickBitmapEnd\",\"type\":\"int16\"}],\"name\":\"getFullState\",\"outputs\":[{\"components\":[{\"internalType\":\"contract IUniswapV3Pool\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"blockTimestamp\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint160\",\"name\":\"sqrtPriceX96\",\"type\":\"uint160\"},{\"internalType\":\"int24\",\"name\":\"tick\",\"type\":\"int24\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"bool\",\"name\":\"unlocked\",\"type\":\"bool\"}],\"internalType\":\"struct IUniswapV3StateMulticall.Slot0\",\"name\":\"slot0\",\"type\":\"tuple\"},{\"internalType\":\"uint128\",\"name\":\"liquidity\",\"type\":\"uint128\"},{\"internalType\":\"int24\",\"name\":\"tickSpacing\",\"type\":\"int24\"},{\"internalType\":\"uint128\",\"name\":\"maxLiquidityPerTick\",\"type\":\"uint128\"},{\"components\":[{\"internalType\":\"int16\",\"name\":\"index\",\"type\":\"int16\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"internalType\":\"struct IUniswapV3StateMulticall.TickBitMapMappings[]\",\"name\":\"tickBitmap\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"int24\",\"name\":\"index\",\"type\":\"int24\"},{\"components\":[{\"internalType\":\"uint128\",\"name\":\"liquidityGross\",\"type\":\"uint128\"},{\"internalType\":\"int128\",\"name\":\"liquidityNet\",\"type\":\"int128\"},{\"internalType\":\"bool\",\"name\":\"initialized\",\"type\":\"bool\"}],\"internalType\":\"struct IUniswapV3StateMulticall.TickInfo\",\"name\":\"value\",\"type\":\"tuple\"}],\"internalType\":\"struct IUniswapV3StateMulticall.TickInfoMappings[]\",\"name\":\"ticks\",\"type\":\"tuple[]\"}],\"internalType\":\"struct IUniswapV3StateMulticall.StateResult\",\"name\":\"state\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IUniswapV3Factory\",\"name\":\"factory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"int24\",\"name\":\"tickSpacing\",\"type\":\"int24\"},{\"internalType\":\"int16\",\"name\":\"leftBitmapAmount\",\"type\":\"int16\"},{\"internalType\":\"int16\",\"name\":\"rightBitmapAmount\",\"type\":\"int16\"}],\"name\":\"getFullStateWithRelativeBitmaps\",\"outputs\":[{\"components\":[{\"internalType\":\"contract IUniswapV3Pool\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"blockTimestamp\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint160\",\"name\":\"sqrtPriceX96\",\"type\":\"uint160\"},{\"internalType\":\"int24\",\"name\":\"tick\",\"type\":\"int24\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"bool\",\"name\":\"unlocked\",\"type\":\"bool\"}],\"internalType\":\"struct IUniswapV3StateMulticall.Slot0\",\"name\":\"slot0\",\"type\":\"tuple\"},{\"internalType\":\"uint128\",\"name\":\"liquidity\",\"type\":\"uint128\"},{\"internalType\":\"int24\",\"name\":\"tickSpacing\",\"type\":\"int24\"},{\"internalType\":\"uint128\",\"name\":\"maxLiquidityPerTick\",\"type\":\"uint128\"},{\"components\":[{\"internalType\":\"int16\",\"name\":\"index\",\"type\":\"int16\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"internalType\":\"struct IUniswapV3StateMulticall.TickBitMapMappings[]\",\"name\":\"tickBitmap\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"int24\",\"name\":\"index\",\"type\":\"int24\"},{\"components\":[{\"internalType\":\"uint128\",\"name\":\"liquidityGross\",\"type\":\"uint128\"},{\"internalType\":\"int128\",\"name\":\"liquidityNet\",\"type\":\"int128\"},{\"internalType\":\"bool\",\"name\":\"initialized\",\"type\":\"bool\"}],\"internalType\":\"struct IUniswapV3StateMulticall.TickInfo\",\"name\":\"value\",\"type\":\"tuple\"}],\"internalType\":\"struct IUniswapV3StateMulticall.TickInfoMappings[]\",\"name\":\"ticks\",\"type\":\"tuple[]\"}],\"internalType\":\"struct IUniswapV3StateMulticall.StateResult\",\"name\":\"state\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IUniswapV3Factory\",\"name\":\"factory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"int24\",\"name\":\"tickSpacing\",\"type\":\"int24\"},{\"internalType\":\"int16\",\"name\":\"tickBitmapStart\",\"type\":\"int16\"},{\"internalType\":\"int16\",\"name\":\"tickBitmapEnd\",\"type\":\"int16\"}],\"name\":\"getFullStateWithoutTicks\",\"outputs\":[{\"components\":[{\"internalType\":\"contract IUniswapV3Pool\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"blockTimestamp\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint160\",\"name\":\"sqrtPriceX96\",\"type\":\"uint160\"},{\"internalType\":\"int24\",\"name\":\"tick\",\"type\":\"int24\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"bool\",\"name\":\"unlocked\",\"type\":\"bool\"}],\"internalType\":\"struct IUniswapV3StateMulticall.Slot0\",\"name\":\"slot0\",\"type\":\"tuple\"},{\"internalType\":\"uint128\",\"name\":\"liquidity\",\"type\":\"uint128\"},{\"internalType\":\"int24\",\"name\":\"tickSpacing\",\"type\":\"int24\"},{\"internalType\":\"uint128\",\"name\":\"maxLiquidityPerTick\",\"type\":\"uint128\"},{\"components\":[{\"internalType\":\"int16\",\"name\":\"index\",\"type\":\"int16\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"internalType\":\"struct IUniswapV3StateMulticall.TickBitMapMappings[]\",\"name\":\"tickBitmap\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"int24\",\"name\":\"index\",\"type\":\"int24\"},{\"components\":[{\"internalType\":\"uint128\",\"name\":\"liquidityGross\",\"type\":\"uint128\"},{\"internalType\":\"int128\",\"name\":\"liquidityNet\",\"type\":\"int128\"},{\"internalType\":\"bool\",\"name\":\"initialized\",\"type\":\"bool\"}],\"internalType\":\"struct IUniswapV3StateMulticall.TickInfo\",\"name\":\"value\",\"type\":\"tuple\"}],\"internalType\":\"struct IUniswapV3StateMulticall.TickInfoMappings[]\",\"name\":\"ticks\",\"type\":\"tuple[]\"}],\"internalType\":\"struct IUniswapV3StateMulticall.StateResult\",\"name\":\"state\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "SolidlyV3StateMulticall", "CompilerVersion": "v0.7.5+commit.eb77ed08", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "istanbul", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}