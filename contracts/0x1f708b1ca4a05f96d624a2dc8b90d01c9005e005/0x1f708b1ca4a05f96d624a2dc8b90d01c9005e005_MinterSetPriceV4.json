{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin-4.5/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin-4.7/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/v0.8.x/IAdminACLV0.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\n// Created By: Art Blocks Inc.\\n\\npragma solidity ^0.8.0;\\n\\ninterface IAdminACLV0 {\\n    /**\\n     * @notice Token ID `_tokenId` minted to `_to`.\\n     * @param previousSuperAdmin The previous superAdmin address.\\n     * @param newSuperAdmin The new superAdmin address.\\n     * @param genArt721CoreAddressesToUpdate Array of genArt721Core\\n     * addresses to update to the new superAdmin, for indexing purposes only.\\n     */\\n    event SuperAdminTransferred(\\n        address indexed previousSuperAdmin,\\n        address indexed newSuperAdmin,\\n        address[] genArt721CoreAddressesToUpdate\\n    );\\n\\n    /// Type of the Admin ACL contract, e.g. \\\"AdminACLV0\\\"\\n    function AdminACLType() external view returns (string memory);\\n\\n    /// super admin address\\n    function superAdmin() external view returns (address);\\n\\n    /**\\n     * @notice Calls transferOwnership on other contract from this contract.\\n     * This is useful for updating to a new AdminACL contract.\\n     * @dev this function should be gated to only superAdmin-like addresses.\\n     */\\n    function transferOwnershipOn(\\n        address _contract,\\n        address _newAdminACL\\n    ) external;\\n\\n    /**\\n     * @notice Calls renounceOwnership on other contract from this contract.\\n     * @dev this function should be gated to only superAdmin-like addresses.\\n     */\\n    function renounceOwnershipOn(address _contract) external;\\n\\n    /**\\n     * @notice Checks if sender `_sender` is allowed to call function with selector\\n     * `_selector` on contract `_contract`.\\n     */\\n    function allowed(\\n        address _sender,\\n        address _contract,\\n        bytes4 _selector\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/v0.8.x/IFilteredMinterV0.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\n// Created By: Art Blocks Inc.\\n\\npragma solidity ^0.8.0;\\n\\ninterface IFilteredMinterV0 {\\n    /**\\n     * @notice Price per token in wei updated for project `_projectId` to\\n     * `_pricePerTokenInWei`.\\n     */\\n    event PricePerTokenInWeiUpdated(\\n        uint256 indexed _projectId,\\n        uint256 indexed _pricePerTokenInWei\\n    );\\n\\n    /**\\n     * @notice Currency updated for project `_projectId` to symbol\\n     * `_currencySymbol` and address `_currencyAddress`.\\n     */\\n    event ProjectCurrencyInfoUpdated(\\n        uint256 indexed _projectId,\\n        address indexed _currencyAddress,\\n        string _currencySymbol\\n    );\\n\\n    /// togglePurchaseToDisabled updated\\n    event PurchaseToDisabledUpdated(\\n        uint256 indexed _projectId,\\n        bool _purchaseToDisabled\\n    );\\n\\n    // getter function of public variable\\n    function minterType() external view returns (string memory);\\n\\n    function genArt721CoreAddress() external returns (address);\\n\\n    function minterFilterAddress() external returns (address);\\n\\n    // Triggers a purchase of a token from the desired project, to the\\n    // TX-sending address.\\n    function purchase(\\n        uint256 _projectId\\n    ) external payable returns (uint256 tokenId);\\n\\n    // Triggers a purchase of a token from the desired project, to the specified\\n    // receiving address.\\n    function purchaseTo(\\n        address _to,\\n        uint256 _projectId\\n    ) external payable returns (uint256 tokenId);\\n\\n    // Toggles the ability for `purchaseTo` to be called directly with a\\n    // specified receiving address that differs from the TX-sending address.\\n    function togglePurchaseToDisabled(uint256 _projectId) external;\\n\\n    // Called to make the minter contract aware of the max invocations for a\\n    // given project.\\n    function setProjectMaxInvocations(uint256 _projectId) external;\\n\\n    // Gets if token price is configured, token price in wei, currency symbol,\\n    // and currency address, assuming this is project's minter.\\n    // Supersedes any defined core price.\\n    function getPriceInfo(\\n        uint256 _projectId\\n    )\\n        external\\n        view\\n        returns (\\n            bool isConfigured,\\n            uint256 tokenPriceInWei,\\n            string memory currencySymbol,\\n            address currencyAddress\\n        );\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/v0.8.x/IFilteredMinterV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\n// Created By: Art Blocks Inc.\\n\\nimport \\\"./IFilteredMinterV0.sol\\\";\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title This interface extends the IFilteredMinterV0 interface in order to\\n * add support for generic project minter configuration updates.\\n * @dev keys represent strings of finite length encoded in bytes32 to minimize\\n * gas.\\n * @author Art Blocks Inc.\\n */\\ninterface IFilteredMinterV1 is IFilteredMinterV0 {\\n    /// ANY\\n    /**\\n     * @notice Generic project minter configuration event. Removes key `_key`\\n     * for project `_projectId`.\\n     */\\n    event ConfigKeyRemoved(uint256 indexed _projectId, bytes32 _key);\\n\\n    /// BOOL\\n    /**\\n     * @notice Generic project minter configuration event. Sets value of key\\n     * `_key` to `_value` for project `_projectId`.\\n     */\\n    event ConfigValueSet(uint256 indexed _projectId, bytes32 _key, bool _value);\\n\\n    /// UINT256\\n    /**\\n     * @notice Generic project minter configuration event. Sets value of key\\n     * `_key` to `_value` for project `_projectId`.\\n     */\\n    event ConfigValueSet(\\n        uint256 indexed _projectId,\\n        bytes32 _key,\\n        uint256 _value\\n    );\\n\\n    /**\\n     * @notice Generic project minter configuration event. Adds value `_value`\\n     * to the set of uint256 at key `_key` for project `_projectId`.\\n     */\\n    event ConfigValueAddedToSet(\\n        uint256 indexed _projectId,\\n        bytes32 _key,\\n        uint256 _value\\n    );\\n\\n    /**\\n     * @notice Generic project minter configuration event. Removes value\\n     * `_value` to the set of uint256 at key `_key` for project `_projectId`.\\n     */\\n    event ConfigValueRemovedFromSet(\\n        uint256 indexed _projectId,\\n        bytes32 _key,\\n        uint256 _value\\n    );\\n\\n    /// ADDRESS\\n    /**\\n     * @notice Generic project minter configuration event. Sets value of key\\n     * `_key` to `_value` for project `_projectId`.\\n     */\\n    event ConfigValueSet(\\n        uint256 indexed _projectId,\\n        bytes32 _key,\\n        address _value\\n    );\\n\\n    /**\\n     * @notice Generic project minter configuration event. Adds value `_value`\\n     * to the set of addresses at key `_key` for project `_projectId`.\\n     */\\n    event ConfigValueAddedToSet(\\n        uint256 indexed _projectId,\\n        bytes32 _key,\\n        address _value\\n    );\\n\\n    /**\\n     * @notice Generic project minter configuration event. Removes value\\n     * `_value` to the set of addresses at key `_key` for project `_projectId`.\\n     */\\n    event ConfigValueRemovedFromSet(\\n        uint256 indexed _projectId,\\n        bytes32 _key,\\n        address _value\\n    );\\n\\n    /// BYTES32\\n    /**\\n     * @notice Generic project minter configuration event. Sets value of key\\n     * `_key` to `_value` for project `_projectId`.\\n     */\\n    event ConfigValueSet(\\n        uint256 indexed _projectId,\\n        bytes32 _key,\\n        bytes32 _value\\n    );\\n\\n    /**\\n     * @notice Generic project minter configuration event. Adds value `_value`\\n     * to the set of bytes32 at key `_key` for project `_projectId`.\\n     */\\n    event ConfigValueAddedToSet(\\n        uint256 indexed _projectId,\\n        bytes32 _key,\\n        bytes32 _value\\n    );\\n\\n    /**\\n     * @notice Generic project minter configuration event. Removes value\\n     * `_value` to the set of bytes32 at key `_key` for project `_projectId`.\\n     */\\n    event ConfigValueRemovedFromSet(\\n        uint256 indexed _projectId,\\n        bytes32 _key,\\n        bytes32 _value\\n    );\\n\\n    /**\\n     * @dev Strings not supported. Recommend conversion of (short) strings to\\n     * bytes32 to remain gas-efficient.\\n     */\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/v0.8.x/IFilteredMinterV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\n// Created By: Art Blocks Inc.\\n\\nimport \\\"./IFilteredMinterV1.sol\\\";\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title This interface extends the IFilteredMinterV1 interface in order to\\n * add support for manually setting project max invocations.\\n * @author Art Blocks Inc.\\n */\\ninterface IFilteredMinterV2 is IFilteredMinterV1 {\\n    /**\\n     * @notice Local max invocations for project `_projectId`, tied to core contract `_coreContractAddress`,\\n     * updated to `_maxInvocations`.\\n     */\\n    event ProjectMaxInvocationsLimitUpdated(\\n        uint256 indexed _projectId,\\n        uint256 _maxInvocations\\n    );\\n\\n    // Sets the local max invocations for a given project, checking that the provided max invocations is\\n    // less than or equal to the global max invocations for the project set on the core contract.\\n    // This does not impact the max invocations value defined on the core contract.\\n    function manuallyLimitProjectMaxInvocations(\\n        uint256 _projectId,\\n        uint256 _maxInvocations\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/v0.8.x/IGenArt721CoreContractV3_Base.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\n// Created By: Art Blocks Inc.\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IAdminACLV0.sol\\\";\\n/// use the Royalty Registry's IManifold interface for token royalties\\nimport \\\"./IManifold.sol\\\";\\n\\n/**\\n * @title This interface is intended to house interface items that are common\\n * across all GenArt721CoreContractV3 flagship and derivative implementations.\\n * This interface extends the IManifold royalty interface in order to\\n * add support the Royalty Registry by default.\\n * @author Art Blocks Inc.\\n */\\ninterface IGenArt721CoreContractV3_Base is IManifold {\\n    /**\\n     * @notice Token ID `_tokenId` minted to `_to`.\\n     */\\n    event Mint(address indexed _to, uint256 indexed _tokenId);\\n\\n    /**\\n     * @notice currentMinter updated to `_currentMinter`.\\n     * @dev Implemented starting with V3 core\\n     */\\n    event MinterUpdated(address indexed _currentMinter);\\n\\n    /**\\n     * @notice Platform updated on bytes32-encoded field `_field`.\\n     */\\n    event PlatformUpdated(bytes32 indexed _field);\\n\\n    /**\\n     * @notice Project ID `_projectId` updated on bytes32-encoded field\\n     * `_update`.\\n     */\\n    event ProjectUpdated(uint256 indexed _projectId, bytes32 indexed _update);\\n\\n    event ProposedArtistAddressesAndSplits(\\n        uint256 indexed _projectId,\\n        address _artistAddress,\\n        address _additionalPayeePrimarySales,\\n        uint256 _additionalPayeePrimarySalesPercentage,\\n        address _additionalPayeeSecondarySales,\\n        uint256 _additionalPayeeSecondarySalesPercentage\\n    );\\n\\n    event AcceptedArtistAddressesAndSplits(uint256 indexed _projectId);\\n\\n    // version and type of the core contract\\n    // coreVersion is a string of the form \\\"0.x.y\\\"\\n    function coreVersion() external view returns (string memory);\\n\\n    // coreType is a string of the form \\\"GenArt721CoreV3\\\"\\n    function coreType() external view returns (string memory);\\n\\n    // owner (pre-V3 was named admin) of contract\\n    // this is expected to be an Admin ACL contract for V3\\n    function owner() external view returns (address);\\n\\n    // Admin ACL contract for V3, will be at the address owner()\\n    function adminACLContract() external returns (IAdminACLV0);\\n\\n    // backwards-compatible (pre-V3) admin - equal to owner()\\n    function admin() external view returns (address);\\n\\n    /**\\n     * Function determining if _sender is allowed to call function with\\n     * selector _selector on contract `_contract`. Intended to be used with\\n     * peripheral contracts such as minters, as well as internally by the\\n     * core contract itself.\\n     */\\n    function adminACLAllowed(\\n        address _sender,\\n        address _contract,\\n        bytes4 _selector\\n    ) external returns (bool);\\n\\n    /// getter function of public variable\\n    function startingProjectId() external view returns (uint256);\\n\\n    // getter function of public variable\\n    function nextProjectId() external view returns (uint256);\\n\\n    // getter function of public mapping\\n    function tokenIdToProjectId(\\n        uint256 tokenId\\n    ) external view returns (uint256 projectId);\\n\\n    // @dev this is not available in V0\\n    function isMintWhitelisted(address minter) external view returns (bool);\\n\\n    function projectIdToArtistAddress(\\n        uint256 _projectId\\n    ) external view returns (address payable);\\n\\n    function projectIdToAdditionalPayeePrimarySales(\\n        uint256 _projectId\\n    ) external view returns (address payable);\\n\\n    function projectIdToAdditionalPayeePrimarySalesPercentage(\\n        uint256 _projectId\\n    ) external view returns (uint256);\\n\\n    function projectIdToSecondaryMarketRoyaltyPercentage(\\n        uint256 _projectId\\n    ) external view returns (uint256);\\n\\n    function projectURIInfo(\\n        uint256 _projectId\\n    ) external view returns (string memory projectBaseURI);\\n\\n    // @dev new function in V3\\n    function projectStateData(\\n        uint256 _projectId\\n    )\\n        external\\n        view\\n        returns (\\n            uint256 invocations,\\n            uint256 maxInvocations,\\n            bool active,\\n            bool paused,\\n            uint256 completedTimestamp,\\n            bool locked\\n        );\\n\\n    function projectDetails(\\n        uint256 _projectId\\n    )\\n        external\\n        view\\n        returns (\\n            string memory projectName,\\n            string memory artist,\\n            string memory description,\\n            string memory website,\\n            string memory license\\n        );\\n\\n    function projectScriptDetails(\\n        uint256 _projectId\\n    )\\n        external\\n        view\\n        returns (\\n            string memory scriptTypeAndVersion,\\n            string memory aspectRatio,\\n            uint256 scriptCount\\n        );\\n\\n    function projectScriptByIndex(\\n        uint256 _projectId,\\n        uint256 _index\\n    ) external view returns (string memory);\\n\\n    function tokenIdToHash(uint256 _tokenId) external view returns (bytes32);\\n\\n    // function to set a token's hash (must be guarded)\\n    function setTokenHash_8PT(uint256 _tokenId, bytes32 _hash) external;\\n\\n    // @dev gas-optimized signature in V3 for `mint`\\n    function mint_Ecf(\\n        address _to,\\n        uint256 _projectId,\\n        address _by\\n    ) external returns (uint256 tokenId);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/v0.8.x/IGenArt721CoreContractV3_Engine.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\n// Created By: Art Blocks Inc.\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IAdminACLV0.sol\\\";\\nimport \\\"./IGenArt721CoreContractV3_Base.sol\\\";\\n\\ninterface IGenArt721CoreContractV3_Engine is IGenArt721CoreContractV3_Base {\\n    // @dev new function in V3\\n    function getPrimaryRevenueSplits(\\n        uint256 _projectId,\\n        uint256 _price\\n    )\\n        external\\n        view\\n        returns (\\n            uint256 renderProviderRevenue_,\\n            address payable renderProviderAddress_,\\n            uint256 platformProviderRevenue_,\\n            address payable platformProviderAddress_,\\n            uint256 artistRevenue_,\\n            address payable artistAddress_,\\n            uint256 additionalPayeePrimaryRevenue_,\\n            address payable additionalPayeePrimaryAddress_\\n        );\\n\\n    // @dev The render provider primary sales payment address\\n    function renderProviderPrimarySalesAddress()\\n        external\\n        view\\n        returns (address payable);\\n\\n    // @dev The platform provider primary sales payment address\\n    function platformProviderPrimarySalesAddress()\\n        external\\n        view\\n        returns (address payable);\\n\\n    // @dev Percentage of primary sales allocated to the render provider\\n    function renderProviderPrimarySalesPercentage()\\n        external\\n        view\\n        returns (uint256);\\n\\n    // @dev Percentage of primary sales allocated to the platform provider\\n    function platformProviderPrimarySalesPercentage()\\n        external\\n        view\\n        returns (uint256);\\n\\n    // @dev The render provider secondary sales royalties payment address\\n    function renderProviderSecondarySalesAddress()\\n        external\\n        view\\n        returns (address payable);\\n\\n    // @dev The platform provider secondary sales royalties payment address\\n    function platformProviderSecondarySalesAddress()\\n        external\\n        view\\n        returns (address payable);\\n\\n    // @dev Basis points of secondary sales allocated to the render provider\\n    function renderProviderSecondarySalesBPS() external view returns (uint256);\\n\\n    // @dev Basis points of secondary sales allocated to the platform provider\\n    function platformProviderSecondarySalesBPS()\\n        external\\n        view\\n        returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/v0.8.x/IGenArt721CoreContractV3.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\n// Created By: Art Blocks Inc.\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IAdminACLV0.sol\\\";\\nimport \\\"./IGenArt721CoreContractV3_Base.sol\\\";\\n\\n/**\\n * @title This interface extends IGenArt721CoreContractV3_Base with functions\\n * that are part of the Art Blocks Flagship core contract.\\n * @author Art Blocks Inc.\\n */\\n// This interface extends IGenArt721CoreContractV3_Base with functions that are\\n// in part of the Art Blocks Flagship core contract.\\ninterface IGenArt721CoreContractV3 is IGenArt721CoreContractV3_Base {\\n    // @dev new function in V3\\n    function getPrimaryRevenueSplits(\\n        uint256 _projectId,\\n        uint256 _price\\n    )\\n        external\\n        view\\n        returns (\\n            uint256 artblocksRevenue_,\\n            address payable artblocksAddress_,\\n            uint256 artistRevenue_,\\n            address payable artistAddress_,\\n            uint256 additionalPayeePrimaryRevenue_,\\n            address payable additionalPayeePrimaryAddress_\\n        );\\n\\n    // @dev Art Blocks primary sales payment address\\n    function artblocksPrimarySalesAddress()\\n        external\\n        view\\n        returns (address payable);\\n\\n    /**\\n     * @notice Backwards-compatible (pre-V3) function returning Art Blocks\\n     * primary sales payment address (now called artblocksPrimarySalesAddress).\\n     */\\n    function artblocksAddress() external view returns (address payable);\\n\\n    // @dev Percentage of primary sales allocated to Art Blocks\\n    function artblocksPrimarySalesPercentage() external view returns (uint256);\\n\\n    /**\\n     * @notice Backwards-compatible (pre-V3) function returning Art Blocks\\n     * primary sales percentage (now called artblocksPrimarySalesPercentage).\\n     */\\n    function artblocksPercentage() external view returns (uint256);\\n\\n    // @dev Art Blocks secondary sales royalties payment address\\n    function artblocksSecondarySalesAddress()\\n        external\\n        view\\n        returns (address payable);\\n\\n    // @dev Basis points of secondary sales allocated to Art Blocks\\n    function artblocksSecondarySalesBPS() external view returns (uint256);\\n\\n    /**\\n     * @notice Backwards-compatible (pre-V3) function  that gets artist +\\n     * artist's additional payee royalty data for token ID `_tokenId`.\\n     * WARNING: Does not include Art Blocks portion of royalties.\\n     */\\n    function getRoyaltyData(\\n        uint256 _tokenId\\n    )\\n        external\\n        view\\n        returns (\\n            address artistAddress,\\n            address additionalPayee,\\n            uint256 additionalPayeePercentage,\\n            uint256 royaltyFeeByID\\n        );\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/v0.8.x/IManifold.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/// @dev Royalty Registry interface, used to support the Royalty Registry.\\n/// @dev Source: https://github.com/manifoldxyz/royalty-registry-solidity/blob/main/contracts/specs/IManifold.sol\\n\\n/// @author: manifold.xyz\\n\\n/**\\n * @dev Royalty interface for creator core classes\\n */\\ninterface IManifold {\\n    /**\\n     * @dev Get royalites of a token.  Returns list of receivers and basisPoints\\n     *\\n     *  bytes4(keccak256('getRoyalties(uint256)')) == 0xbb3bafd6\\n     *\\n     *  => 0xbb3bafd6 = 0xbb3bafd6\\n     */\\n    function getRoyalties(\\n        uint256 tokenId\\n    ) external view returns (address payable[] memory, uint256[] memory);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/v0.8.x/IMinterBaseV0.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\n// Created By: Art Blocks Inc.\\n\\nimport \\\"./IFilteredMinterV2.sol\\\";\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title This interface defines any events or functions required for a minter\\n * to conform to the MinterBase contract.\\n * @dev The MinterBase contract was not implemented from the beginning of the\\n * MinterSuite contract suite, therefore early versions of some minters may not\\n * conform to this interface.\\n * @author Art Blocks Inc.\\n */\\ninterface IMinterBaseV0 {\\n    // Function that returns if a minter is configured to integrate with a V3 flagship or V3 engine contract.\\n    // Returns true only if the minter is configured to integrate with an engine contract.\\n    function isEngine() external returns (bool isEngine);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/v0.8.x/IMinterFilterV0.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\n// Created By: Art Blocks Inc.\\n\\npragma solidity ^0.8.0;\\n\\ninterface IMinterFilterV0 {\\n    /**\\n     * @notice Emitted when contract is deployed to notify indexing services\\n     * of the new contract deployment.\\n     */\\n    event Deployed();\\n\\n    /**\\n     * @notice Approved minter `_minterAddress`.\\n     */\\n    event MinterApproved(address indexed _minterAddress, string _minterType);\\n\\n    /**\\n     * @notice Revoked approval for minter `_minterAddress`\\n     */\\n    event MinterRevoked(address indexed _minterAddress);\\n\\n    /**\\n     * @notice Minter `_minterAddress` of type `_minterType`\\n     * registered for project `_projectId`.\\n     */\\n    event ProjectMinterRegistered(\\n        uint256 indexed _projectId,\\n        address indexed _minterAddress,\\n        string _minterType\\n    );\\n\\n    /**\\n     * @notice Any active minter removed for project `_projectId`.\\n     */\\n    event ProjectMinterRemoved(uint256 indexed _projectId);\\n\\n    function genArt721CoreAddress() external returns (address);\\n\\n    function setMinterForProject(uint256, address) external;\\n\\n    function removeMinterForProject(uint256) external;\\n\\n    function mint(\\n        address _to,\\n        uint256 _projectId,\\n        address sender\\n    ) external returns (uint256);\\n\\n    function getMinterForProject(uint256) external view returns (address);\\n\\n    function projectHasMinter(uint256) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/minter-suite/Minters/MinterBase_v0_1_1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\n// Created By: Art Blocks Inc.\\n\\nimport \\\"../../interfaces/v0.8.x/IMinterBaseV0.sol\\\";\\nimport \\\"../../interfaces/v0.8.x/IGenArt721CoreContractV3_Base.sol\\\";\\nimport \\\"../../interfaces/v0.8.x/IGenArt721CoreContractV3.sol\\\";\\nimport \\\"../../interfaces/v0.8.x/IGenArt721CoreContractV3_Engine.sol\\\";\\n\\nimport \\\"@openzeppelin-4.7/contracts/token/ERC20/IERC20.sol\\\";\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Art Blocks Minter Base Class\\n * @notice A base class for Art Blocks minter contracts that provides common\\n * functionality used across minter contracts.\\n * This contract is not intended to be deployed directly, but rather to be\\n * inherited by other minter contracts.\\n * From a design perspective, this contract is intended to remain simple and\\n * easy to understand. It is not intended to cause a complex inheritance tree,\\n * and instead should keep minter contracts as readable as possible for\\n * collectors and developers.\\n * @dev Semantic versioning is used in the solidity file name, and is therefore\\n * controlled by contracts importing the appropriate filename version.\\n * @author Art Blocks Inc.\\n */\\nabstract contract MinterBase is IMinterBaseV0 {\\n    /// state variable that tracks whether this contract's associated core\\n    /// contract is an Engine contract, where Engine contracts have an\\n    /// additional revenue split for the platform provider\\n    bool public immutable isEngine;\\n\\n    // @dev we do not track an initialization state, as the only state variable\\n    // is immutable, which the compiler enforces to be assigned during\\n    // construction.\\n\\n    /**\\n     * @notice Initializes contract to ensure state variable `isEngine` is set\\n     * appropriately based on the minter's associated core contract address.\\n     * @param genArt721Address Art Blocks core contract address for\\n     * which this contract will be a minter.\\n     */\\n    constructor(address genArt721Address) {\\n        // set state variable isEngine\\n        isEngine = _getV3CoreIsEngine(genArt721Address);\\n    }\\n\\n    /**\\n     * @notice splits ETH funds between sender (if refund), providers,\\n     * artist, and artist's additional payee for a token purchased on\\n     * project `_projectId`.\\n     * WARNING: This function uses msg.value and msg.sender to determine\\n     * refund amounts, and therefore may not be applicable to all use cases\\n     * (e.g. do not use with Dutch Auctions with on-chain settlement).\\n     * @dev possible DoS during splits is acknowledged, and mitigated by\\n     * business practices, including end-to-end testing on mainnet, and\\n     * admin-accepted artist payment addresses.\\n     * @param projectId Project ID for which funds shall be split.\\n     * @param pricePerTokenInWei Current price of token, in Wei.\\n     */\\n    function splitFundsETH(\\n        uint256 projectId,\\n        uint256 pricePerTokenInWei,\\n        address genArt721CoreAddress\\n    ) internal {\\n        if (msg.value > 0) {\\n            bool success_;\\n            // send refund to sender\\n            uint256 refund = msg.value - pricePerTokenInWei;\\n            if (refund > 0) {\\n                (success_, ) = msg.sender.call{value: refund}(\\\"\\\");\\n                require(success_, \\\"Refund failed\\\");\\n            }\\n            // split revenues\\n            splitRevenuesETH(\\n                projectId,\\n                pricePerTokenInWei,\\n                genArt721CoreAddress\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @notice splits ETH revenues between providers, artist, and artist's\\n     * additional payee for revenue generated by project `_projectId`.\\n     * @dev possible DoS during splits is acknowledged, and mitigated by\\n     * business practices, including end-to-end testing on mainnet, and\\n     * admin-accepted artist payment addresses.\\n     * @param projectId Project ID for which funds shall be split.\\n     * @param valueInWei Value to be split, in Wei.\\n     */\\n    function splitRevenuesETH(\\n        uint256 projectId,\\n        uint256 valueInWei,\\n        address genArtCoreContract\\n    ) internal {\\n        if (valueInWei <= 0) {\\n            return; // return early\\n        }\\n        bool success;\\n        // split funds between platforms, artist, and artist's\\n        // additional payee\\n        uint256 renderProviderRevenue_;\\n        address payable renderProviderAddress_;\\n        uint256 artistRevenue_;\\n        address payable artistAddress_;\\n        uint256 additionalPayeePrimaryRevenue_;\\n        address payable additionalPayeePrimaryAddress_;\\n        if (isEngine) {\\n            // get engine splits\\n            uint256 platformProviderRevenue_;\\n            address payable platformProviderAddress_;\\n            (\\n                renderProviderRevenue_,\\n                renderProviderAddress_,\\n                platformProviderRevenue_,\\n                platformProviderAddress_,\\n                artistRevenue_,\\n                artistAddress_,\\n                additionalPayeePrimaryRevenue_,\\n                additionalPayeePrimaryAddress_\\n            ) = IGenArt721CoreContractV3_Engine(genArtCoreContract)\\n                .getPrimaryRevenueSplits(projectId, valueInWei);\\n            // Platform Provider payment (only possible if engine)\\n            if (platformProviderRevenue_ > 0) {\\n                (success, ) = platformProviderAddress_.call{\\n                    value: platformProviderRevenue_\\n                }(\\\"\\\");\\n                require(success, \\\"Platform Provider payment failed\\\");\\n            }\\n        } else {\\n            // get flagship splits\\n            (\\n                renderProviderRevenue_, // artblocks revenue\\n                renderProviderAddress_, // artblocks address\\n                artistRevenue_,\\n                artistAddress_,\\n                additionalPayeePrimaryRevenue_,\\n                additionalPayeePrimaryAddress_\\n            ) = IGenArt721CoreContractV3(genArtCoreContract)\\n                .getPrimaryRevenueSplits(projectId, valueInWei);\\n        }\\n        // Render Provider / Art Blocks payment\\n        if (renderProviderRevenue_ > 0) {\\n            (success, ) = renderProviderAddress_.call{\\n                value: renderProviderRevenue_\\n            }(\\\"\\\");\\n            require(success, \\\"Render Provider payment failed\\\");\\n        }\\n        // artist payment\\n        if (artistRevenue_ > 0) {\\n            (success, ) = artistAddress_.call{value: artistRevenue_}(\\\"\\\");\\n            require(success, \\\"Artist payment failed\\\");\\n        }\\n        // additional payee payment\\n        if (additionalPayeePrimaryRevenue_ > 0) {\\n            (success, ) = additionalPayeePrimaryAddress_.call{\\n                value: additionalPayeePrimaryRevenue_\\n            }(\\\"\\\");\\n            require(success, \\\"Additional Payee payment failed\\\");\\n        }\\n    }\\n\\n    /**\\n     * @notice splits ERC-20 funds between providers, artist, and artist's\\n     * additional payee, for a token purchased on project `_projectId`.\\n     * @dev possible DoS during splits is acknowledged, and mitigated by\\n     * business practices, including end-to-end testing on mainnet, and\\n     * admin-accepted artist payment addresses.\\n     */\\n    function splitFundsERC20(\\n        uint256 projectId,\\n        uint256 pricePerTokenInWei,\\n        address currencyAddress,\\n        address genArtCoreContract\\n    ) internal {\\n        IERC20 _projectCurrency = IERC20(currencyAddress);\\n        // split remaining funds between foundation, artist, and artist's\\n        // additional payee\\n        uint256 renderProviderRevenue_;\\n        address payable renderProviderAddress_;\\n        uint256 artistRevenue_;\\n        address payable artistAddress_;\\n        uint256 additionalPayeePrimaryRevenue_;\\n        address payable additionalPayeePrimaryAddress_;\\n        if (isEngine) {\\n            // get engine splits\\n            uint256 platformProviderRevenue_;\\n            address payable platformProviderAddress_;\\n            (\\n                renderProviderRevenue_,\\n                renderProviderAddress_,\\n                platformProviderRevenue_,\\n                platformProviderAddress_,\\n                artistRevenue_,\\n                artistAddress_,\\n                additionalPayeePrimaryRevenue_,\\n                additionalPayeePrimaryAddress_\\n            ) = IGenArt721CoreContractV3_Engine(genArtCoreContract)\\n                .getPrimaryRevenueSplits(projectId, pricePerTokenInWei);\\n            // Platform Provider payment (only possible if engine)\\n            if (platformProviderRevenue_ > 0) {\\n                _projectCurrency.transferFrom(\\n                    msg.sender,\\n                    platformProviderAddress_,\\n                    platformProviderRevenue_\\n                );\\n            }\\n        } else {\\n            // get flagship splits\\n            (\\n                renderProviderRevenue_, // artblocks revenue\\n                renderProviderAddress_, // artblocks address\\n                artistRevenue_,\\n                artistAddress_,\\n                additionalPayeePrimaryRevenue_,\\n                additionalPayeePrimaryAddress_\\n            ) = IGenArt721CoreContractV3(genArtCoreContract)\\n                .getPrimaryRevenueSplits(projectId, pricePerTokenInWei);\\n        }\\n        // Art Blocks payment\\n        if (renderProviderRevenue_ > 0) {\\n            _projectCurrency.transferFrom(\\n                msg.sender,\\n                renderProviderAddress_,\\n                renderProviderRevenue_\\n            );\\n        }\\n        // artist payment\\n        if (artistRevenue_ > 0) {\\n            _projectCurrency.transferFrom(\\n                msg.sender,\\n                artistAddress_,\\n                artistRevenue_\\n            );\\n        }\\n        // additional payee payment\\n        if (additionalPayeePrimaryRevenue_ > 0) {\\n            _projectCurrency.transferFrom(\\n                msg.sender,\\n                additionalPayeePrimaryAddress_,\\n                additionalPayeePrimaryRevenue_\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @notice Returns whether a V3 core contract is an Art Blocks Engine\\n     * contract or not. Return value of false indicates that the core is a\\n     * flagship contract.\\n     * @dev this function reverts if a core contract does not return the\\n     * expected number of return values from getPrimaryRevenueSplits() for\\n     * either a flagship or engine core contract.\\n     * @dev this function uses the length of the return data (in bytes) to\\n     * determine whether the core is an engine or not.\\n     * @param genArt721CoreV3 The address of the deployed core contract.\\n     */\\n    function _getV3CoreIsEngine(\\n        address genArt721CoreV3\\n    ) private returns (bool) {\\n        // call getPrimaryRevenueSplits() on core contract\\n        bytes memory payload = abi.encodeWithSignature(\\n            \\\"getPrimaryRevenueSplits(uint256,uint256)\\\",\\n            0,\\n            0\\n        );\\n        (bool success, bytes memory returnData) = genArt721CoreV3.call(payload);\\n        require(success, \\\"getPrimaryRevenueSplits() call failed\\\");\\n        // determine whether core is engine or not, based on return data length\\n        uint256 returnDataLength = returnData.length;\\n        if (returnDataLength == 6 * 32) {\\n            // 6 32-byte words returned if flagship (not engine)\\n            // @dev 6 32-byte words are expected because the non-engine core\\n            // contracts return a payout address and uint256 payment value for\\n            // the artist, and artist's additional payee, and Art Blocks.\\n            // also note that per Solidity ABI encoding, the address return\\n            // values are padded to 32 bytes.\\n            return false;\\n        } else if (returnDataLength == 8 * 32) {\\n            // 8 32-byte words returned if engine\\n            // @dev 8 32-byte words are expected because the engine core\\n            // contracts return a payout address and uint256 payment value for\\n            // the artist, artist's additional payee, render provider\\n            // typically Art Blocks, and platform provider (partner).\\n            // also note that per Solidity ABI encoding, the address return\\n            // values are padded to 32 bytes.\\n            return true;\\n        } else {\\n            // unexpected return value length\\n            revert(\\\"Unexpected revenue split bytes\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/minter-suite/Minters/MinterSetPriceV4.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\n// Created By: Art Blocks Inc.\\n\\nimport \\\"../../interfaces/v0.8.x/IGenArt721CoreContractV3_Base.sol\\\";\\nimport \\\"../../interfaces/v0.8.x/IMinterFilterV0.sol\\\";\\nimport \\\"../../interfaces/v0.8.x/IFilteredMinterV2.sol\\\";\\nimport \\\"./MinterBase_v0_1_1.sol\\\";\\n\\nimport \\\"@openzeppelin-4.5/contracts/security/ReentrancyGuard.sol\\\";\\n\\npragma solidity 0.8.19;\\n\\n/**\\n * @title Filtered Minter contract that allows tokens to be minted with ETH.\\n * This is designed to be used with GenArt721CoreContractV3 flagship or\\n * engine contracts.\\n * @author Art Blocks Inc.\\n * @notice Privileged Roles and Ownership:\\n * This contract is designed to be managed, with limited powers.\\n * Privileged roles and abilities are controlled by the project's artist, which\\n * can be modified by the core contract's Admin ACL contract. Both of these\\n * roles hold extensive power and can modify minter details.\\n * Care must be taken to ensure that the admin ACL contract and artist\\n * addresses are secure behind a multi-sig or other access control mechanism.\\n * ----------------------------------------------------------------------------\\n * The following functions are restricted to a project's artist:\\n * - updatePricePerTokenInWei\\n * - setProjectMaxInvocations\\n * - manuallyLimitProjectMaxInvocations\\n * ----------------------------------------------------------------------------\\n * Additional admin and artist privileged roles may be described on other\\n * contracts that this minter integrates with.\\n */\\ncontract MinterSetPriceV4 is ReentrancyGuard, MinterBase, IFilteredMinterV2 {\\n    /// Core contract address this minter interacts with\\n    address public immutable genArt721CoreAddress;\\n\\n    /// The core contract integrates with V3 contracts\\n    IGenArt721CoreContractV3_Base private immutable genArtCoreContract_Base;\\n\\n    /// Minter filter address this minter interacts with\\n    address public immutable minterFilterAddress;\\n\\n    /// Minter filter this minter may interact with.\\n    IMinterFilterV0 private immutable minterFilter;\\n\\n    /// minterType for this minter\\n    string public constant minterType = \\\"MinterSetPriceV4\\\";\\n\\n    /// minter version for this minter\\n    string public constant minterVersion = \\\"v4.1.0\\\";\\n\\n    uint256 constant ONE_MILLION = 1_000_000;\\n\\n    struct ProjectConfig {\\n        bool maxHasBeenInvoked;\\n        bool priceIsConfigured;\\n        uint24 maxInvocations;\\n        uint256 pricePerTokenInWei;\\n    }\\n\\n    mapping(uint256 => ProjectConfig) public projectConfig;\\n\\n    function _onlyArtist(uint256 _projectId) internal view {\\n        require(\\n            msg.sender ==\\n                genArtCoreContract_Base.projectIdToArtistAddress(_projectId),\\n            \\\"Only Artist\\\"\\n        );\\n    }\\n\\n    /**\\n     * @notice Initializes contract to be a Filtered Minter for\\n     * `_minterFilter`, integrated with Art Blocks core contract\\n     * at address `_genArt721Address`.\\n     * @param _genArt721Address Art Blocks core contract address for\\n     * which this contract will be a minter.\\n     * @param _minterFilter Minter filter for which this will be a\\n     * filtered minter.\\n     */\\n    constructor(\\n        address _genArt721Address,\\n        address _minterFilter\\n    ) ReentrancyGuard() MinterBase(_genArt721Address) {\\n        genArt721CoreAddress = _genArt721Address;\\n        // always populate immutable engine contracts, but only use appropriate\\n        // interface based on isEngine in the rest of the contract\\n        genArtCoreContract_Base = IGenArt721CoreContractV3_Base(\\n            _genArt721Address\\n        );\\n        minterFilterAddress = _minterFilter;\\n        minterFilter = IMinterFilterV0(_minterFilter);\\n        require(\\n            minterFilter.genArt721CoreAddress() == _genArt721Address,\\n            \\\"Illegal contract pairing\\\"\\n        );\\n    }\\n\\n    /**\\n     * @notice Syncs local maximum invocations of project `_projectId` based on\\n     * the value currently defined in the core contract.\\n     * @param _projectId Project ID to set the maximum invocations for.\\n     * @dev this enables gas reduction after maxInvocations have been reached -\\n     * core contracts shall still enforce a maxInvocation check during mint.\\n     */\\n    function setProjectMaxInvocations(uint256 _projectId) public {\\n        _onlyArtist(_projectId);\\n        uint256 maxInvocations;\\n        uint256 invocations;\\n        (invocations, maxInvocations, , , , ) = genArtCoreContract_Base\\n            .projectStateData(_projectId);\\n        // update storage with results\\n        projectConfig[_projectId].maxInvocations = uint24(maxInvocations);\\n\\n        // We need to ensure maxHasBeenInvoked is correctly set after manually syncing the\\n        // local maxInvocations value with the core contract's maxInvocations value.\\n        // This synced value of maxInvocations from the core contract will always be greater\\n        // than or equal to the previous value of maxInvocations stored locally.\\n        projectConfig[_projectId].maxHasBeenInvoked =\\n            invocations == maxInvocations;\\n\\n        emit ProjectMaxInvocationsLimitUpdated(_projectId, maxInvocations);\\n    }\\n\\n    /**\\n     * @notice Manually sets the local maximum invocations of project `_projectId`\\n     * with the provided `_maxInvocations`, checking that `_maxInvocations` is less\\n     * than or equal to the value of project `_project_id`'s maximum invocations that is\\n     * set on the core contract.\\n     * @dev Note that a `_maxInvocations` of 0 can only be set if the current `invocations`\\n     * value is also 0 and this would also set `maxHasBeenInvoked` to true, correctly short-circuiting\\n     * this minter's purchase function, avoiding extra gas costs from the core contract's maxInvocations check.\\n     * @param _projectId Project ID to set the maximum invocations for.\\n     * @param _maxInvocations Maximum invocations to set for the project.\\n     */\\n    function manuallyLimitProjectMaxInvocations(\\n        uint256 _projectId,\\n        uint256 _maxInvocations\\n    ) external {\\n        _onlyArtist(_projectId);\\n        // CHECKS\\n        // ensure that the manually set maxInvocations is not greater than what is set on the core contract\\n        uint256 maxInvocations;\\n        uint256 invocations;\\n        (invocations, maxInvocations, , , , ) = genArtCoreContract_Base\\n            .projectStateData(_projectId);\\n        require(\\n            _maxInvocations <= maxInvocations,\\n            \\\"Cannot increase project max invocations above core contract set project max invocations\\\"\\n        );\\n        require(\\n            _maxInvocations >= invocations,\\n            \\\"Cannot set project max invocations to less than current invocations\\\"\\n        );\\n\\n        // EFFECTS\\n        // update storage with results\\n        projectConfig[_projectId].maxInvocations = uint24(_maxInvocations);\\n        // We need to ensure maxHasBeenInvoked is correctly set after manually setting the\\n        // local maxInvocations value.\\n        projectConfig[_projectId].maxHasBeenInvoked =\\n            invocations == _maxInvocations;\\n\\n        emit ProjectMaxInvocationsLimitUpdated(_projectId, _maxInvocations);\\n    }\\n\\n    /**\\n     * @notice Warning: Disabling purchaseTo is not supported on this minter.\\n     * This method exists purely for interface-conformance purposes.\\n     */\\n    function togglePurchaseToDisabled(uint256 _projectId) external view {\\n        _onlyArtist(_projectId);\\n        revert(\\\"Action not supported\\\");\\n    }\\n\\n    /**\\n     * @notice projectId => has project reached its maximum number of\\n     * invocations? Note that this returns a local cache of the core contract's\\n     * state, and may be out of sync with the core contract. This is\\n     * intentional, as it only enables gas optimization of mints after a\\n     * project's maximum invocations has been reached. A false negative will\\n     * only result in a gas cost increase, since the core contract will still\\n     * enforce a maxInvocation check during minting. A false positive is not\\n     * possible because the V3 core contract only allows maximum invocations\\n     * to be reduced, not increased. Based on this rationale, we intentionally\\n     * do not do input validation in this method as to whether or not the input\\n     * `_projectId` is an existing project ID.\\n     */\\n    function projectMaxHasBeenInvoked(\\n        uint256 _projectId\\n    ) external view returns (bool) {\\n        return projectConfig[_projectId].maxHasBeenInvoked;\\n    }\\n\\n    /**\\n     * @notice projectId => project's maximum number of invocations.\\n     * Optionally synced with core contract value, for gas optimization.\\n     * Note that this returns a local cache of the core contract's\\n     * state, and may be out of sync with the core contract. This is\\n     * intentional, as it only enables gas optimization of mints after a\\n     * project's maximum invocations has been reached.\\n     * @dev A number greater than the core contract's project max invocations\\n     * will only result in a gas cost increase, since the core contract will\\n     * still enforce a maxInvocation check during minting. A number less than\\n     * the core contract's project max invocations is only possible when the\\n     * project's max invocations have not been synced on this minter, since the\\n     * V3 core contract only allows maximum invocations to be reduced, not\\n     * increased. When this happens, the minter will enable minting, allowing\\n     * the core contract to enforce the max invocations check. Based on this\\n     * rationale, we intentionally do not do input validation in this method as\\n     * to whether or not the input `_projectId` is an existing project ID.\\n     */\\n    function projectMaxInvocations(\\n        uint256 _projectId\\n    ) external view returns (uint256) {\\n        return uint256(projectConfig[_projectId].maxInvocations);\\n    }\\n\\n    /**\\n     * @notice Updates this minter's price per token of project `_projectId`\\n     * to be '_pricePerTokenInWei`, in Wei.\\n     * This price supersedes any legacy core contract price per token value.\\n     * @dev Note that it is intentionally supported here that the configured\\n     * price may be explicitly set to `0`.\\n     */\\n    function updatePricePerTokenInWei(\\n        uint256 _projectId,\\n        uint256 _pricePerTokenInWei\\n    ) external {\\n        _onlyArtist(_projectId);\\n        ProjectConfig storage _projectConfig = projectConfig[_projectId];\\n        _projectConfig.pricePerTokenInWei = _pricePerTokenInWei;\\n        _projectConfig.priceIsConfigured = true;\\n        emit PricePerTokenInWeiUpdated(_projectId, _pricePerTokenInWei);\\n\\n        // sync local max invocations if not initially populated\\n        // @dev if local max invocations and maxHasBeenInvoked are both\\n        // initial values, we know they have not been populated.\\n        if (\\n            _projectConfig.maxInvocations == 0 &&\\n            _projectConfig.maxHasBeenInvoked == false\\n        ) {\\n            setProjectMaxInvocations(_projectId);\\n        }\\n    }\\n\\n    /**\\n     * @notice Purchases a token from project `_projectId`.\\n     * @param _projectId Project ID to mint a token on.\\n     * @return tokenId Token ID of minted token\\n     */\\n    function purchase(\\n        uint256 _projectId\\n    ) external payable returns (uint256 tokenId) {\\n        tokenId = purchaseTo_do6(msg.sender, _projectId);\\n        return tokenId;\\n    }\\n\\n    /**\\n     * @notice gas-optimized version of purchase(uint256).\\n     */\\n    function purchase_H4M(\\n        uint256 _projectId\\n    ) external payable returns (uint256 tokenId) {\\n        tokenId = purchaseTo_do6(msg.sender, _projectId);\\n        return tokenId;\\n    }\\n\\n    /**\\n     * @notice Purchases a token from project `_projectId` and sets\\n     * the token's owner to `_to`.\\n     * @param _to Address to be the new token's owner.\\n     * @param _projectId Project ID to mint a token on.\\n     * @return tokenId Token ID of minted token\\n     */\\n    function purchaseTo(\\n        address _to,\\n        uint256 _projectId\\n    ) external payable returns (uint256 tokenId) {\\n        return purchaseTo_do6(_to, _projectId);\\n    }\\n\\n    /**\\n     * @notice gas-optimized version of purchaseTo(address, uint256).\\n     */\\n    function purchaseTo_do6(\\n        address _to,\\n        uint256 _projectId\\n    ) public payable nonReentrant returns (uint256 tokenId) {\\n        // CHECKS\\n        ProjectConfig storage _projectConfig = projectConfig[_projectId];\\n\\n        // Note that `maxHasBeenInvoked` is only checked here to reduce gas\\n        // consumption after a project has been fully minted.\\n        // `_projectConfig.maxHasBeenInvoked` is locally cached to reduce\\n        // gas consumption, but if not in sync with the core contract's value,\\n        // the core contract also enforces its own max invocation check during\\n        // minting.\\n        require(\\n            !_projectConfig.maxHasBeenInvoked,\\n            \\\"Maximum number of invocations reached\\\"\\n        );\\n\\n        // require artist to have configured price of token on this minter\\n        require(_projectConfig.priceIsConfigured, \\\"Price not configured\\\");\\n\\n        // load price of token into memory\\n        uint256 pricePerTokenInWei = _projectConfig.pricePerTokenInWei;\\n\\n        require(\\n            msg.value >= pricePerTokenInWei,\\n            \\\"Must send minimum value to mint!\\\"\\n        );\\n\\n        // EFFECTS\\n        tokenId = minterFilter.mint(_to, _projectId, msg.sender);\\n\\n        // invocation is token number plus one, and will never overflow due to\\n        // limit of 1e6 invocations per project. block scope for gas efficiency\\n        // (i.e. avoid an unnecessary var initialization to 0).\\n        unchecked {\\n            uint256 tokenInvocation = (tokenId % ONE_MILLION) + 1;\\n            uint256 localMaxInvocations = _projectConfig.maxInvocations;\\n            // handle the case where the token invocation == minter local max\\n            // invocations occurred on a different minter, and we have a stale\\n            // local maxHasBeenInvoked value returning a false negative.\\n            // @dev this is a CHECK after EFFECTS, so security was considered\\n            // in detail here.\\n            require(\\n                tokenInvocation <= localMaxInvocations,\\n                \\\"Maximum invocations reached\\\"\\n            );\\n            // in typical case, update the local maxHasBeenInvoked value\\n            // to true if the token invocation == minter local max invocations\\n            // (enables gas efficient reverts after sellout)\\n            if (tokenInvocation == localMaxInvocations) {\\n                _projectConfig.maxHasBeenInvoked = true;\\n            }\\n        }\\n\\n        // INTERACTIONS\\n        splitFundsETH(_projectId, pricePerTokenInWei, genArt721CoreAddress);\\n\\n        return tokenId;\\n    }\\n\\n    /**\\n     * @notice Gets if price of token is configured, price of minting a\\n     * token on project `_projectId`, and currency symbol and address to be\\n     * used as payment. Supersedes any core contract price information.\\n     * @param _projectId Project ID to get price information for.\\n     * @return isConfigured true only if token price has been configured on\\n     * this minter\\n     * @return tokenPriceInWei current price of token on this minter - invalid\\n     * if price has not yet been configured\\n     * @return currencySymbol currency symbol for purchases of project on this\\n     * minter. This minter always returns \\\"ETH\\\"\\n     * @return currencyAddress currency address for purchases of project on\\n     * this minter. This minter always returns null address, reserved for ether\\n     */\\n    function getPriceInfo(\\n        uint256 _projectId\\n    )\\n        external\\n        view\\n        returns (\\n            bool isConfigured,\\n            uint256 tokenPriceInWei,\\n            string memory currencySymbol,\\n            address currencyAddress\\n        )\\n    {\\n        ProjectConfig storage _projectConfig = projectConfig[_projectId];\\n        isConfigured = _projectConfig.priceIsConfigured;\\n        tokenPriceInWei = _projectConfig.pricePerTokenInWei;\\n        currencySymbol = \\\"ETH\\\";\\n        currencyAddress = address(0);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 25\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_genArt721Address\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_minterFilter\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_key\",\"type\":\"bytes32\"}],\"name\":\"ConfigKeyRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_key\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"ConfigValueAddedToSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_key\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_value\",\"type\":\"address\"}],\"name\":\"ConfigValueAddedToSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_key\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_value\",\"type\":\"bytes32\"}],\"name\":\"ConfigValueAddedToSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_key\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"ConfigValueRemovedFromSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_key\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_value\",\"type\":\"address\"}],\"name\":\"ConfigValueRemovedFromSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_key\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_value\",\"type\":\"bytes32\"}],\"name\":\"ConfigValueRemovedFromSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_key\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_value\",\"type\":\"bool\"}],\"name\":\"ConfigValueSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_key\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"ConfigValueSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_key\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_value\",\"type\":\"address\"}],\"name\":\"ConfigValueSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_key\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_value\",\"type\":\"bytes32\"}],\"name\":\"ConfigValueSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_pricePerTokenInWei\",\"type\":\"uint256\"}],\"name\":\"PricePerTokenInWeiUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_currencyAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_currencySymbol\",\"type\":\"string\"}],\"name\":\"ProjectCurrencyInfoUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_maxInvocations\",\"type\":\"uint256\"}],\"name\":\"ProjectMaxInvocationsLimitUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_purchaseToDisabled\",\"type\":\"bool\"}],\"name\":\"PurchaseToDisabledUpdated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"genArt721CoreAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"}],\"name\":\"getPriceInfo\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isConfigured\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"tokenPriceInWei\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"currencySymbol\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"currencyAddress\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isEngine\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxInvocations\",\"type\":\"uint256\"}],\"name\":\"manuallyLimitProjectMaxInvocations\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minterFilterAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minterType\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minterVersion\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"projectConfig\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"maxHasBeenInvoked\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"priceIsConfigured\",\"type\":\"bool\"},{\"internalType\":\"uint24\",\"name\":\"maxInvocations\",\"type\":\"uint24\"},{\"internalType\":\"uint256\",\"name\":\"pricePerTokenInWei\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"}],\"name\":\"projectMaxHasBeenInvoked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"}],\"name\":\"projectMaxInvocations\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"}],\"name\":\"purchase\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"}],\"name\":\"purchaseTo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"}],\"name\":\"purchaseTo_do6\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"}],\"name\":\"purchase_H4M\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"}],\"name\":\"setProjectMaxInvocations\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"}],\"name\":\"togglePurchaseToDisabled\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_pricePerTokenInWei\",\"type\":\"uint256\"}],\"name\":\"updatePricePerTokenInWei\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "MinterSetPriceV4", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "25", "ConstructorArguments": "000000000000000000000000e034bb2b1b9471e11cf1a0a9199a156fb227aa5d00000000000000000000000092ffaac31ddda4cd7e1b366e16b8382fc256921d", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}