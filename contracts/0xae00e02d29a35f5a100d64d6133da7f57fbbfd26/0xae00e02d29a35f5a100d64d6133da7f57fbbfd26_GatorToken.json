{"SourceCode": "{\"Gator.sol\":{\"content\":\"pragma solidity 0.4.24;\\n\\n// import \\\"./SafeMath.sol\\\";\\n// import \\\"./Ownable.sol\\\";\\n// import \\\"./ERC20Detailed.sol\\\";\\n\\n// import \\\"./SafeMathInt.sol\\\";\\n\\n\\nlibrary SafeMath {\\n\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b \\u003c= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b \\u003e 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n\\n        return c;\\n    }\\n\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\ncontract Context {\\n    function _msgSender() internal constant returns (address ) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal constant returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\\ncontract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n    \\n    constructor () public {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        \\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    function owner() public constant returns (address) {\\n        return _owner;\\n    }\\n\\n    modifier onlyOwner() {\\n        require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    function renounceOwnership() public onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    function transferOwnership(address newOwner) public onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\\nlibrary SafeMathInt {\\n    int256 private constant MIN_INT256 = int256(1) \\u003c\\u003c 255;\\n    int256 private constant MAX_INT256 = ~(int256(1) \\u003c\\u003c 255);\\n\\n    function mul(int256 a, int256 b)\\n        internal\\n        pure\\n        returns (int256)\\n    {\\n        int256 c = a * b;\\n\\n        // Detect overflow when multiplying MIN_INT256 with -1\\n        require(c != MIN_INT256 || (a \\u0026 MIN_INT256) != (b \\u0026 MIN_INT256));\\n        require((b == 0) || (c / b == a));\\n        return c;\\n    }\\n\\n    function div(int256 a, int256 b)\\n        internal\\n        pure\\n        returns (int256)\\n    {\\n        // Prevent overflow when dividing MIN_INT256 by -1\\n        require(b != -1 || a != MIN_INT256);\\n\\n        // Solidity already throws when dividing by 0.\\n        return a / b;\\n    }\\n\\n    function sub(int256 a, int256 b)\\n        internal\\n        pure\\n        returns (int256)\\n    {\\n        int256 c = a - b;\\n        require((b \\u003e= 0 \\u0026\\u0026 c \\u003c= a) || (b \\u003c 0 \\u0026\\u0026 c \\u003e a));\\n        return c;\\n    }\\n\\n    function add(int256 a, int256 b)\\n        internal\\n        pure\\n        returns (int256)\\n    {\\n        int256 c = a + b;\\n        require((b \\u003e= 0 \\u0026\\u0026 c \\u003e= a) || (b \\u003c 0 \\u0026\\u0026 c \\u003c a));\\n        return c;\\n    }\\n\\n    function abs(int256 a)\\n        internal\\n        pure\\n        returns (int256)\\n    {\\n        require(a != MIN_INT256);\\n        return a \\u003c 0 ? -a : a;\\n    }\\n}\\n\\ninterface IERC20 {\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address who) external view returns (uint256);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\\ncontract ERC20 is IERC20 {\\n    using SafeMath for uint256;\\n\\n    mapping (address =\\u003e uint256) private _balances;\\n\\n    mapping (address =\\u003e mapping (address =\\u003e uint256)) private _allowed;\\n\\n    uint256 private _totalSupply;\\n\\n    function totalSupply() public view returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    function balanceOf(address owner) public view returns (uint256) {\\n        return _balances[owner];\\n    }\\n\\n    function allowance(address owner, address spender) public view returns (uint256) {\\n        return _allowed[owner][spender];\\n    }\\n\\n    function transfer(address to, uint256 value) public returns (bool) {\\n        _transfer(msg.sender, to, value);\\n        return true;\\n    }\\n\\n    function approve(address spender, uint256 value) public returns (bool) {\\n        require(spender != address(0));\\n\\n        _allowed[msg.sender][spender] = value;\\n        emit Approval(msg.sender, spender, value);\\n        return true;\\n    }\\n\\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\\n        require(from != address(0));\\n        require(to != address(0));\\n        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\\n        _transfer(from, to, value);\\n        emit Approval(from, msg.sender, _allowed[from][msg.sender]);\\n        return true;\\n    }\\n\\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\\n        require(spender != address(0));\\n\\n        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].add(addedValue);\\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\\n        return true;\\n    }\\n\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\\n        require(spender != address(0));\\n\\n        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].sub(subtractedValue);\\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\\n        return true;\\n    }\\n\\n    function _transfer(address from, address to, uint256 value) internal {\\n        require(to != address(0), \\\"invalid to address\\\");\\n        require(from != address(0), \\\"invalid from address\\\");\\n\\n        _balances[from] = _balances[from].sub(value);\\n        _balances[to] = _balances[to].add(value);\\n        emit Transfer(from, to, value);\\n    }\\n\\n    function _mint(address account, uint256 value) internal {\\n        require(account != address(0));\\n\\n        _totalSupply = _totalSupply.add(value);\\n        _balances[account] = _balances[account].add(value);\\n        emit Transfer(address(0), account, value);\\n    }\\n\\n    function _burn(address account, uint256 value) internal {\\n        require(account != address(0));\\n\\n        _totalSupply = _totalSupply.sub(value);\\n        _balances[account] = _balances[account].sub(value);\\n        emit Transfer(account, address(0), value);\\n    }\\n\\n    function _burnFrom(address account, uint256 value) internal {\\n        require(account != address(0));\\n        _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(value);\\n        _burn(account, value);\\n        emit Approval(account, msg.sender, _allowed[account][msg.sender]);\\n    }\\n}\\n\\ncontract ERC20Detailed is ERC20 {\\n    string private _name;\\n    string private _symbol;\\n    uint8 private _decimals;\\n    \\n    constructor(string name, string symbol, uint8 decimals) public {\\n        _name = name;\\n        _symbol = symbol;\\n        _decimals = decimals;\\n    }\\n\\n    function name() public view returns (string) {\\n        return _name;\\n    }\\n\\n    function symbol() public view returns (string) {\\n        return _symbol;\\n    }\\n\\n    function decimals() public view returns (uint8) {\\n        return _decimals;\\n    }\\n}\\n\\ncontract GatorToken is ERC20Detailed {\\n\\n    using SafeMath for uint256;\\n    using SafeMathInt for int256;\\n    address private _owner;\\n\\n    event LogRebase(uint256 indexed epoch, uint256 totalSupply);\\n    event LogMonetaryPolicyUpdated(address monetaryPolicy);\\n\\n    // Used for authentication\\n    address public monetaryPolicy;\\n\\n    modifier onlyMonetaryPolicy() {\\n        require(msg.sender == monetaryPolicy);\\n        _;\\n    }\\n\\n    modifier validRecipient(address to) {\\n        require(to != address(0));\\n        require(to != address(this));\\n        _;\\n    }\\n\\n    uint256 public constant DECIMALS = 18;\\n    uint256 private constant MAX_UINT256 = ~uint256(0);\\n    \\n    uint256 private constant INITIAL_FRAGMENTS_SUPPLY = 350000*10**DECIMALS;\\n\\n    // uint256 private constant MAX_SUPPLY = 300000*10**DECIMALS;  // (2^128) - 1\\n    uint256 private constant TOTAL_GONS = MAX_UINT256 - (MAX_UINT256 % INITIAL_FRAGMENTS_SUPPLY);\\n    uint256 private _totalSupply;\\n    uint256 private _gonsPerFragment;\\n    mapping(address =\\u003e uint256) private _balances;\\n\\n    mapping (address =\\u003e mapping (address =\\u003e uint256)) private _allowedFragments;\\n\\n    function owner() public constant returns (address) {\\n        return _owner;\\n    }\\n\\n    modifier onlyOwner() {\\n        require(_owner == msg.sender, \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n    function renounceOwnership() public onlyOwner {\\n        _owner = address(0);\\n    }\\n\\n    function transferOwnership(address newOwner) public onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _owner = newOwner;\\n    }\\n\\n    function setMonetaryPolicy(address monetaryPolicy_)\\n        external\\n        onlyOwner\\n    {\\n        require(monetaryPolicy_ != address(0), \\\"empty monetaryPolicy address\\\");\\n        \\n        monetaryPolicy = monetaryPolicy_;\\n        emit LogMonetaryPolicyUpdated(monetaryPolicy_);\\n    }\\n\\n    function rebase(uint256 epoch, int256 supplyDelta)\\n        external\\n        onlyMonetaryPolicy\\n        returns (uint256)\\n    {   \\n\\n        if (supplyDelta == 0) {\\n            emit LogRebase(epoch, _totalSupply);\\n            return _totalSupply;\\n        }\\n        uint256 _supplyDelta = uint256(supplyDelta);\\n\\n        _totalSupply = _totalSupply.div(_gonsPerFragment);\\n\\n        if (supplyDelta \\u003e= 0) {\\n            _totalSupply = _totalSupply.add(_supplyDelta);\\n        }\\n        _gonsPerFragment = TOTAL_GONS.div(_totalSupply);\\n\\n        _totalSupply = _totalSupply.mul(_gonsPerFragment);\\n\\n        emit LogRebase(epoch, _totalSupply);\\n        return _totalSupply;\\n    }\\n\\n    constructor() ERC20Detailed(\\\"GATOR\\\", \\\"GATR\\\", uint8(DECIMALS))\\n        public\\n    {\\n        _owner = msg.sender;\\n        \\n        _totalSupply = INITIAL_FRAGMENTS_SUPPLY;\\n        _gonsPerFragment = TOTAL_GONS.div(_totalSupply);\\n        _totalSupply = INITIAL_FRAGMENTS_SUPPLY.mul(_gonsPerFragment);\\n        _balances[_owner] = INITIAL_FRAGMENTS_SUPPLY.mul(_gonsPerFragment);\\n\\n        emit Transfer(address(0), _owner, _totalSupply);\\n    }\\n\\n    function totalSupply()\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return _totalSupply.div(_gonsPerFragment);\\n    }\\n\\n    function balanceOf(address who)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return _balances[who].div(_gonsPerFragment);\\n    }\\n\\n    function transfer(address to, uint256 value)\\n        public\\n        validRecipient(to)\\n        returns (bool)\\n    {\\n        require(to != address(0));\\n        uint256 gonValue = value.mul(_gonsPerFragment);\\n        _balances[msg.sender] = _balances[msg.sender].sub(gonValue);\\n        _balances[to] = _balances[to].add(gonValue);\\n        emit Transfer(msg.sender, to, value);\\n        return true;\\n    }\\n\\n    function allowance(address owner_, address spender)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return _allowedFragments[owner_][spender];\\n    }\\n\\n    function transferFrom(address from, address to, uint256 value)\\n        public\\n        validRecipient(to)\\n        returns (bool)\\n    {\\n        require(from != address(0));\\n        _allowedFragments[from][msg.sender] = _allowedFragments[from][msg.sender].sub(value);\\n\\n        uint256 gonValue = value.mul(_gonsPerFragment);\\n        _balances[from] = _balances[from].sub(gonValue);\\n        _balances[to] = _balances[to].add(gonValue);\\n        emit Transfer(from, to, value);\\n\\n        return true;\\n    }\\n\\n    function approve(address spender, uint256 value)\\n        public\\n        returns (bool)\\n    {\\n        require(spender != address(0));\\n        _allowedFragments[msg.sender][spender] = value;\\n        emit Approval(msg.sender, spender, value);\\n        return true;\\n    }\\n\\n    function increaseAllowance(address spender, uint256 addedValue)\\n        public\\n        returns (bool)\\n    {\\n        require(spender != address(0));\\n        _allowedFragments[msg.sender][spender] =\\n            _allowedFragments[msg.sender][spender].add(addedValue);\\n        emit Approval(msg.sender, spender, _allowedFragments[msg.sender][spender]);\\n        return true;\\n    }\\n\\n    function decreaseAllowance(address spender, uint256 subtractedValue)\\n        public\\n        returns (bool)\\n    {\\n        require(spender != address(0));\\n        uint256 oldValue = _allowedFragments[msg.sender][spender];\\n        if (subtractedValue \\u003e= oldValue) {\\n            _allowedFragments[msg.sender][spender] = 0;\\n        } else {\\n            _allowedFragments[msg.sender][spender] = oldValue.sub(subtractedValue);\\n        }\\n        emit Approval(msg.sender, spender, _allowedFragments[msg.sender][spender]);\\n        return true;\\n    }\\n    \\n    /*\\n    function mint(address account, uint256 amount)\\n    public\\n    onlyOwner\\n    {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n        amount = amount.mul(10**DECIMALS);\\n        _totalSupply = _totalSupply.div(_gonsPerFragment);\\n        _totalSupply = _totalSupply.add(amount);\\n        _balances[account] = _balances[account].div(_gonsPerFragment);\\n        _gonsPerFragment = TOTAL_GONS.div(_totalSupply);\\n\\n        _totalSupply = _totalSupply.mul(_gonsPerFragment);\\n\\n        _balances[account] = _balances[account].add(amount);\\n        _balances[account] = _balances[account].mul(_gonsPerFragment);\\n\\n        emit Transfer(address(0), account, amount);\\n    }\\n    */\\n}\"},\"GatorPolicy.sol\":{\"content\":\"pragma solidity 0.4.24;\\n\\nimport \\\"./Gator.sol\\\";\\n\\nlibrary UInt256Lib {\\n    \\n    uint256 private constant MAX_INT256 = (2**255)-1;\\n\\n    /**\\n     * @dev Safely converts a uint256 to an int256.\\n     */\\n    function toInt256Safe(uint256 a)\\n        internal\\n        pure\\n        returns (int256)\\n    {\\n        require(a \\u003c= MAX_INT256, \\\"SafeCast: value doesn\\u0027t fit in an int256\\\");\\n        return int256(a);\\n    }\\n}\\n\\ncontract GatorPolicy is Ownable {\\n    using SafeMath for uint256;\\n    using SafeMathInt for int256;\\n    using UInt256Lib for uint256;\\n\\n    event LogRebase(\\n        uint256 indexed epoch,\\n        uint256 exchangeRate,\\n        uint256 cpi,\\n        int256 requestedSupplyAdjustment,\\n        uint256 timestampSec\\n    );\\n\\n    GatorToken public uFrags;\\n\\n    // CPI value at the time of launch, as an 18 decimal fixed point number.\\n    // uint256 private baseCpi;\\n\\n    uint256 public deviationThreshold;\\n\\n    // The actual token price, will update only if deviationThreshold crossed\\n    uint256 public token_price;\\n\\n    // The rebase lag parameter, used to dampen the applied supply adjustment by 1 / rebaseLag\\n    // Check setRebaseLag comments for more details.\\n    // Natural number, no decimal places.\\n    //uint256 public rebaseLag;\\n\\n    // More than this much time must pass between rebase operations.\\n    uint256 public minRebaseTimeIntervalSec;\\n\\n    // Block timestamp of last rebase operation\\n    uint256 public lastRebaseTimestampSec;\\n\\n    // The rebase window begins this many seconds into the minRebaseTimeInterval period.\\n    // For example if minRebaseTimeInterval is 24hrs, it represents the time of day in seconds.\\n    //uint256 public rebaseWindowOffsetSec;\\n\\n    // The length of the time window where a rebase operation is allowed to execute, in seconds.\\n    //uint256 public rebaseWindowLengthSec;\\n\\n    // The number of rebase cycles since inception\\n    uint256 public epoch;\\n\\n    uint256 private constant DECIMALS = 18;\\n\\n    // Due to the expression in computeSupplyDelta(), MAX_RATE * MAX_SUPPLY must fit into an int256.\\n    // Both are 18 decimals fixed point numbers.\\n    uint256 private constant MAX_RATE = 10**6*10**DECIMALS;\\n    // MAX_SUPPLY = MAX_INT256 / MAX_RATE\\n    uint256 private constant MAX_SUPPLY = ~(uint256(1) \\u003c\\u003c 255) / MAX_RATE;\\n\\n    // This module orchestrates the rebase execution and downstream notification.\\n    address public orchestrator;\\n\\n    modifier onlyOrchestrator() {\\n        require(msg.sender == orchestrator);\\n        _;\\n    }\\n\\n    function rebase(uint256 wei_token_price) external\\n    onlyOrchestrator\\n    {\\n        //sets the epoch\\n        epoch = epoch.add(1);\\n        \\n        //compute supply delta    \\n        int256 supplyDelta = computeSupplyDelta(wei_token_price);\\n        \\n        if(supplyDelta == 0) {\\n            //require that 24 hours has passed and then set the current token price without rebasing supply\\n            require(lastRebaseTimestampSec + 24 hours \\u003c now, \\\"24 hours has not passed since the last rebase\\\");\\n\\n            //set the price and return\\n            token_price = wei_token_price;\\n            \\n            // Snap the rebase time after changes are made\\n            lastRebaseTimestampSec = now;\\n        } else {\\n            \\n            // This comparison also ensures there is no reentrancy.\\n            require(lastRebaseTimestampSec.add(minRebaseTimeIntervalSec) \\u003c now , \\\"30 minutes has not passed since last rebase\\\");\\n            \\n            //to continue from here, the price must have increased past the old price\\n            require(supplyDelta != 0,\\\"not a 5% increase\\\");\\n            \\n            //this sets the total_supply to max_supply\\n            if (supplyDelta \\u003e 0 \\u0026\\u0026 uFrags.totalSupply().add(uint256(supplyDelta)) \\u003e MAX_SUPPLY) {\\n                supplyDelta = (MAX_SUPPLY.sub(uFrags.totalSupply())).toInt256Safe();\\n            }\\n            \\n            //only repegs up\\n            uint old_token_price = token_price;\\n            require(wei_token_price \\u003e old_token_price, \\\"new token price is not greater than old\\\");\\n            \\n            //split the difference b/w old and new\\n            uint actual_new_token_price = old_token_price + uint(wei_token_price - old_token_price).div(2);\\n            int256 actual_rebase_price_delta = computeSupplyDelta(actual_new_token_price);\\n            \\n            //update totals\\n            uFrags.rebase(epoch, actual_rebase_price_delta);\\n            \\n            // Snap the rebase time to the start of this window. Ensures 30 minutes passed since last rebase call\\n            lastRebaseTimestampSec = now;\\n            \\n            token_price = actual_new_token_price;\\n        }\\n            \\n    }\\n        \\n    function setOrchestrator(address orchestrator_)\\n        external\\n        onlyOwner\\n    {\\n        require(orchestrator_ != address(0));\\n        orchestrator = orchestrator_;\\n    }\\n\\n    function setTokenPrice(uint256 _token_price)\\n        external\\n        onlyOwner\\n    {   \\n        //set in wei\\n        token_price = _token_price;\\n    }\\n\\n    function setDeviationThreshold(uint256 deviationThreshold_)\\n        external\\n        onlyOwner\\n    {\\n        // deviationThreshold = 0.05e18 = 5e16 5%\\n        deviationThreshold = deviationThreshold_;\\n    }\\n\\n    function setRebaseTimingParameters(\\n        uint256 minRebaseTimeIntervalSec_,\\n        uint256 rebaseWindowOffsetSec_)\\n        external\\n        onlyOwner\\n    {\\n        require(minRebaseTimeIntervalSec_ \\u003e 0);\\n        require(rebaseWindowOffsetSec_ \\u003c minRebaseTimeIntervalSec_);\\n\\n        minRebaseTimeIntervalSec = minRebaseTimeIntervalSec_;\\n    }\\n\\n    constructor(GatorToken uFrags_, uint256 _token_price)\\n        public\\n    {\\n        \\n        token_price = _token_price;\\n\\n        // deviationThreshold = 0.05e18 = 5e16\\n        deviationThreshold = 5 * 10 ** (DECIMALS-2); // 5%\\n\\n        minRebaseTimeIntervalSec = 30 minutes;\\n        lastRebaseTimestampSec = now;\\n        epoch = 0;\\n\\n        uFrags = uFrags_;\\n\\n    }\\n\\n    function computeSupplyDelta(uint256 new_price)\\n        public\\n        view\\n        returns (int256)\\n    {\\n        if (withinDeviationThreshold(new_price, token_price)) {\\n            return 0;\\n        }\\n        if (new_price \\u003c token_price) {\\n            return 0;\\n        }\\n\\n        // supplyDelta = totalSupply * (rate - targetRate) / targetRate\\n        int256 targetRateSigned = token_price.toInt256Safe();\\n\\n        return uFrags.totalSupply().toInt256Safe()\\n            .mul(new_price.toInt256Safe().sub(targetRateSigned))\\n            .div(targetRateSigned);\\n    }\\n\\n\\n    function withinDeviationThreshold(uint256 new_price, uint256 old_price)\\n        public\\n        view\\n        returns (bool)\\n    {\\n        uint256 absoluteDeviationThreshold = old_price.mul(deviationThreshold).div(10**DECIMALS);\\n        \\n        return (new_price \\u003e= old_price \\u0026\\u0026 new_price.sub(old_price) \\u003c absoluteDeviationThreshold)\\n            || (new_price \\u003c old_price \\u0026\\u0026 old_price.sub(new_price) \\u003c absoluteDeviationThreshold);\\n    }\\n}\\n\"},\"Orchestrator.sol\":{\"content\":\"pragma solidity 0.4.24;\\n\\nimport \\\"./GatorPolicy.sol\\\";\\n\\n/**\\n * @title Orchestrator\\n * @notice The orchestrator is the main entry point for rebase operations. It coordinates the policy\\n * actions with external consumers.\\n */\\ncontract Orchestrator is Ownable {\\n\\n    struct Transaction {\\n        bool enabled;\\n        address destination;\\n        bytes data;\\n    }\\n\\n    event TransactionFailed(address indexed destination, uint index, bytes data);\\n    event TransactionSent(address indexed destination, uint index, bytes data);\\n    /*event TransactionRemoved(address indexed destination, uint index, bytes data);*/\\n    \\n    // Stable ordering is not guaranteed.\\n    Transaction[] public transactions;\\n\\n    GatorPolicy public policy;\\n\\n    /**\\n     * @param policy_ Address of the UFragments policy.\\n     */\\n    constructor(address policy_) public {\\n        require(policy_ != address(0), \\\"policy is not set correctly\\\");\\n        policy = GatorPolicy(policy_);\\n    }\\n\\n    /**\\n     * @notice Main entry point to initiate a rebase operation.\\n     *         The Orchestrator calls rebase on the policy and notifies downstream applications.\\n     *         Contracts are guarded from calling, to avoid flash loan attacks on liquidity\\n     *         providers.\\n     *         If a transaction in the transaction list reverts, it is swallowed and the remaining\\n     *         transactions are executed.\\n     */\\n\\n    function rebase(uint256 wei_token_price)\\n    onlyOwner\\n    external\\n    {\\n        \\n       // require(msg.sender == tx.origin);  // solhint-disable-line avoid-tx-origin\\n        policy.rebase(wei_token_price);\\n\\n        for (uint i = 0; i \\u003c transactions.length; i++) {\\n            Transaction storage t = transactions[i];\\n            if (t.enabled) {\\n                emit TransactionSent(t.destination, i, t.data);\\n                bool result =\\n                    externalCall(t.destination, t.data);\\n                if (!result) {\\n                    //commented out due to revert.. \\n                    //emit TransactionFailed(t.destination, i, t.data);\\n                    revert(\\\"Transaction Failed\\\");\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Adds a transaction that gets called for a downstream receiver of rebases\\n     * @param destination Address of contract destination\\n     * @param data Transaction data payload\\n     */\\n    function addTransaction(address destination, bytes data)\\n        external\\n        onlyOwner\\n    {\\n        require(destination != address(0));\\n        transactions.push(Transaction({\\n            enabled: true,\\n            destination: destination,\\n            data: data\\n        }));\\n    }\\n\\n    /**\\n     * @param index Index of transaction to remove.\\n     *              Transaction ordering may have changed since adding.\\n     */\\n     /*\\n    function removeTransaction(uint index)\\n        external\\n        onlyOwner\\n    {\\n        require(index \\u003c transactions.length, \\\"index out of bounds\\\");\\n        \\n        emit TransactionRemoved(transactions[index].destination, index, transactions[index].data);\\n        \\n        if (index \\u003c transactions.length - 1) {\\n            transactions[index] = transactions[transactions.length - 1];\\n        }\\n\\n        transactions.length--;\\n    }\\n    */\\n    \\n\\n    /**\\n     * @param index Index of transaction. Transaction ordering may have changed since adding.\\n     * @param enabled True for enabled, false for disabled.\\n     */\\n    function setTransactionEnabled(uint index, bool enabled)\\n        external\\n        onlyOwner\\n    {\\n        require(index \\u003c transactions.length, \\\"index must be in range of stored tx list\\\");\\n        transactions[index].enabled = enabled;\\n    }\\n\\n    /**\\n     * @return Number of transactions, both enabled and disabled, in transactions list.\\n     */\\n    function transactionsSize()\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        return transactions.length;\\n    }\\n\\n    /**\\n     * @dev wrapper to call the encoded transactions on downstream consumers.\\n     * @param destination Address of destination contract.\\n     * @param data The encoded data payload.\\n     * @return True on success\\n     */\\n    function externalCall(address destination, bytes data)\\n        internal\\n        returns (bool)\\n    {\\n        require(destination != address(0));\\n        bool result;\\n        assembly {  // solhint-disable-line no-inline-assembly\\n            // \\\"Allocate\\\" memory for output\\n            // (0x40 is where \\\"free memory\\\" pointer is stored by convention)\\n            let outputAddress := mload(0x40)\\n\\n            // First 32 bytes are the padded length of data, so exclude that\\n            let dataAddress := add(data, 32)\\n\\n            result := call(\\n                // 34710 is the value that solidity is currently emitting\\n                // It includes callGas (700) + callVeryLow (3, to pay for SUB)\\n                // + callValueTransferGas (9000) + callNewAccountGas\\n                // (25000, in case the destination address does not exist and needs creating)\\n                sub(gas, 34710),\\n\\n                destination,\\n                0, // transfer value in wei\\n                dataAddress,\\n                mload(data),  // Size of the input, in bytes. Stored in position 0 of the array.\\n                outputAddress,\\n                0  // Output is ignored, therefore the output size is zero\\n            )\\n        }\\n        return result;\\n    }\\n}\"}}", "ABI": "[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DECIMALS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"who\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"epoch\",\"type\":\"uint256\"},{\"name\":\"supplyDelta\",\"type\":\"int256\"}],\"name\":\"rebase\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"monetaryPolicy_\",\"type\":\"address\"}],\"name\":\"setMonetaryPolicy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"monetaryPolicy\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner_\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"epoch\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"totalSupply\",\"type\":\"uint256\"}],\"name\":\"LogRebase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"monetaryPolicy\",\"type\":\"address\"}],\"name\":\"LogMonetaryPolicyUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]", "ContractName": "GatorToken", "CompilerVersion": "v0.4.24+commit.e67f0147", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://a848b1df84512eb3f57ac65be568e954856e6addd0a9b91a150981f8bbf0709c"}