{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/producers/editions/Editions.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.10;\\n\\nimport {Ownable} from \\\"../../lib/Ownable.sol\\\";\\nimport {Pausable} from \\\"../../lib/Pausable.sol\\\";\\nimport {Reentrancy} from \\\"../../lib/Reentrancy.sol\\\";\\nimport {ERC721, IERC721, IERC165} from \\\"../../lib/ERC721/ERC721.sol\\\";\\nimport {IERC721Metadata} from \\\"../../lib/ERC721/interface/IERC721.sol\\\";\\nimport {IERC2309} from \\\"../../lib/ERC2309/interface/IERC2309.sol\\\";\\nimport {IERC2981} from \\\"../../lib/ERC2981/interface/IERC2981.sol\\\";\\nimport {IEditions, IEditionsEvents} from \\\"./interface/IEditions.sol\\\";\\n\\nimport {IRenderer} from \\\"./interface/IRenderer.sol\\\";\\n\\nimport {ITreasuryConfig} from \\\"../../treasury/interface/ITreasuryConfig.sol\\\";\\nimport {IMirrorTreasury} from \\\"../../treasury/interface/IMirrorTreasury.sol\\\";\\nimport {IMirrorFeeConfig} from \\\"../../fee-config/MirrorFeeConfig.sol\\\";\\n\\n/**\\n * @title Editions\\n * @author MirrorXYZ\\n */\\ncontract Editions is\\n    Ownable,\\n    Pausable,\\n    Reentrancy,\\n    ERC721,\\n    IERC721Metadata,\\n    IERC2309,\\n    IERC2981,\\n    IEditions,\\n    IEditionsEvents\\n{\\n    // ============ Deployment ============\\n\\n    /// @notice Address that deploys and initializes clones\\n    address public immutable override factory;\\n\\n    // ============ Fee Configuration ============\\n\\n    /// @notice Address for Mirror fee configuration.\\n    address public immutable override feeConfig;\\n\\n    /// @notice Address for Mirror treasury configuration.\\n    address public immutable override treasuryConfig;\\n\\n    // ============ ERC721 Metadata ============\\n\\n    /// @notice Edition name\\n    string public override name;\\n\\n    /// @notice Ediiton symbol\\n    string public override symbol;\\n\\n    // ============ Edition Data ============\\n\\n    /// @notice Last tokenId that was minted\\n    uint256 internal currentTokenId;\\n\\n    /// @notice Edition contractURI\\n    string internal _contractURI;\\n\\n    /// @notice Edition contentURI\\n    string internal contentURI;\\n\\n    /// @notice Edition price\\n    uint256 public override price;\\n\\n    /// @notice Edition limit\\n    uint256 public override limit;\\n\\n    /// @notice Edition contentHash\\n    bytes32 public override contentHash;\\n\\n    // ============ Royalty Info (ERC2981) ============\\n\\n    /// @notice Account that will receive royalties\\n    /// @dev set address(0) to avoid royalties\\n    address public override royaltyRecipient;\\n\\n    /// @notice Royalty Basis Points\\n    uint256 public override royaltyBPS;\\n\\n    // ============ Rendering ============\\n\\n    /// @notice Rendering contract\\n    address public override renderer;\\n\\n    // ============ Pre allocation ============\\n\\n    /// @notice Allocation recipient (consecutive transfer)\\n    address internal allocationRecipient;\\n\\n    /// @notice Allocation count (consecutive transfer)\\n    uint256 internal allocationCount;\\n\\n    // ============ Constructor ============\\n    constructor(\\n        address factory_,\\n        address feeConfig_,\\n        address treasuryConfig_\\n    ) Ownable(address(0)) Pausable(false) {\\n        factory = factory_;\\n        feeConfig = feeConfig_;\\n        treasuryConfig = treasuryConfig_;\\n    }\\n\\n    // ============ Initializing ============\\n\\n    /// @notice Initialize metadata\\n    /// @param owner_ the clone owner\\n    /// @param name_ the name for the edition clone\\n    /// @param symbol_ the symbol for the edition clone\\n    /// @param contentURI_ the contentURI for the edition clone\\n    /// @param contractURI_ the contractURI for the edition clone\\n    /// @param edition_ the parameters for the edition sale\\n    /// @param paused_ the pause state for the edition sale\\n    function initialize(\\n        address owner_,\\n        string memory name_,\\n        string memory symbol_,\\n        string memory contentURI_,\\n        string memory contractURI_,\\n        Edition memory edition_,\\n        bool paused_\\n    ) external override {\\n        require(msg.sender == factory, \\\"unauthorized caller\\\");\\n\\n        // store erc721 metadata\\n        name = name_;\\n        symbol = symbol_;\\n\\n        // store edition data\\n        contentURI = contentURI_;\\n        _contractURI = contractURI_;\\n        price = edition_.price;\\n        limit = edition_.limit;\\n        contentHash = edition_.contentHash;\\n\\n        // set pause status\\n        if (paused_) {\\n            _pause();\\n        }\\n\\n        // store owner\\n        _setOwner(address(0), owner_);\\n\\n        // set royalty defaults to owner and 10%\\n        royaltyRecipient = owner_;\\n        royaltyBPS = 1000;\\n    }\\n\\n    // ============ Pause Methods ============\\n\\n    /// @notice Unpause edition sale\\n    function unpause() external override onlyOwner {\\n        _unpause();\\n    }\\n\\n    /// @notice Pause edition sale\\n    function pause() external override onlyOwner {\\n        _pause();\\n    }\\n\\n    // ============ Allocation ============\\n\\n    /// @notice Allocates `count` editions to `recipient`\\n    /// @dev Throws if an edition has been purchased already or `count` exceeds limit\\n    /// @param recipient the account to receive tokens\\n    /// @param count the number of tokens to mint to `recipient`\\n    function allocate(address recipient, uint256 count)\\n        external\\n        override\\n        onlyOwner\\n    {\\n        // check that no purchases have happened and count does not exceed limit\\n        require(\\n            currentTokenId == 0 && (limit == 0 || count <= limit),\\n            \\\"cannot allocate\\\"\\n        );\\n\\n        // set allocation recipient\\n        allocationRecipient = recipient;\\n        allocationCount = count;\\n\\n        // update tokenId\\n        currentTokenId = count;\\n\\n        // update balance\\n        _balances[recipient] = count;\\n\\n        // emit transfer\\n        emit ConsecutiveTransfer(\\n            // fromTokenId\\n            1,\\n            // toTokenId\\n            count,\\n            // fromAddress\\n            address(0),\\n            // toAddress\\n            recipient\\n        );\\n    }\\n\\n    /// @notice Finds the owner of a token\\n    /// @dev this method takes into account allocation\\n    function ownerOf(uint256 tokenId) public view override returns (address) {\\n        address _owner = _owners[tokenId];\\n\\n        // if there is not owner set,\\n        // and the tokenId is within the allocation count\\n        // the allocationRecipient owns it\\n        if (_owner == address(0) && tokenId < allocationCount) {\\n            return allocationRecipient;\\n        }\\n\\n        require(_owner != address(0), \\\"ERC721: query for nonexistent token\\\");\\n\\n        return _owner;\\n    }\\n\\n    // ============ Purchase ============\\n\\n    /// @notice Purchase an edition\\n    /// @dev throws if sale is paused or incorrect value is sent\\n    /// @param recipient the account to receive the edition\\n    function purchase(address recipient)\\n        external\\n        payable\\n        override\\n        whenNotPaused\\n        returns (uint256 tokenId)\\n    {\\n        require(msg.value == price, \\\"incorrect value\\\");\\n\\n        return _purchase(recipient);\\n    }\\n\\n    // ============ Minting ============\\n\\n    /// @notice Mint an edition\\n    /// @dev throws if called by a non-owner\\n    /// @param recipient the account to receive the edition\\n    function mint(address recipient)\\n        external\\n        override\\n        onlyOwner\\n        returns (uint256 tokenId)\\n    {\\n        tokenId = _getTokenIdAndMint(recipient);\\n    }\\n\\n    /// @notice Allows the owner to set a global limit on the total supply\\n    /// @dev throws if attempting to increase the limit\\n    function setLimit(uint256 limit_) external override onlyOwner {\\n        // enforce that the limit should only ever decrease once set\\n        require(\\n            limit == 0 || limit_ < limit,\\n            \\\"limit must be < than current limit\\\"\\n        );\\n\\n        // announce the change in limit\\n        emit EditionLimitSet(\\n            // oldLimit\\n            limit,\\n            // newLimit\\n            limit_\\n        );\\n\\n        // update the limit.\\n        limit = limit_;\\n    }\\n\\n    // ============ ERC2981 Methods ============\\n\\n    /// @notice Called with the sale price to determine how much royalty\\n    //  is owed and to whom\\n    /// @param _tokenId - the NFT asset queried for royalty information\\n    /// @param _salePrice - the sale price of the NFT asset specified by _tokenId\\n    /// @return receiver - address of who should be sent the royalty payment\\n    /// @return royaltyAmount - the royalty payment amount for _salePrice\\n    function royaltyInfo(uint256 _tokenId, uint256 _salePrice)\\n        external\\n        view\\n        override\\n        returns (address receiver, uint256 royaltyAmount)\\n    {\\n        receiver = royaltyRecipient;\\n\\n        royaltyAmount = (_salePrice * royaltyBPS) / 10_000;\\n    }\\n\\n    /// @param royaltyRecipient_ the address that will receive royalties\\n    /// @param royaltyBPS_ the royalty amount in basis points (bps)\\n    function setRoyaltyInfo(\\n        address payable royaltyRecipient_,\\n        uint256 royaltyBPS_\\n    ) external override onlyOwner {\\n        require(\\n            royaltyBPS_ <= 10_000,\\n            \\\"bps must be less than or equal to 10,000\\\"\\n        );\\n\\n        emit RoyaltyChange(\\n            // oldRoyaltyRecipient\\n            royaltyRecipient,\\n            // oldRoyaltyBPS\\n            royaltyBPS,\\n            // newRoyaltyRecipient\\n            royaltyRecipient_,\\n            // newRoyaltyBPS\\n            royaltyBPS_\\n        );\\n\\n        royaltyRecipient = royaltyRecipient_;\\n        royaltyBPS = royaltyBPS_;\\n    }\\n\\n    // ============ Rendering Methods ============\\n\\n    /// @notice Set the renderer address\\n    /// @dev Throws if renderer is not the zero address\\n    function setRenderer(address renderer_) external override onlyOwner {\\n        require(renderer == address(0), \\\"renderer already set\\\");\\n\\n        renderer = renderer_;\\n\\n        emit RendererSet(\\n            // renderer\\n            renderer_\\n        );\\n    }\\n\\n    /// @notice Get contract metadata\\n    /// @dev If a renderer is set, return the renderer's metadata\\n    function contractURI() external view override returns (string memory) {\\n        if (renderer != address(0)) {\\n            return IRenderer(renderer).contractURI();\\n        }\\n\\n        return _contractURI;\\n    }\\n\\n    /// @notice Get `tokenId` URI or data\\n    /// @dev If a renderer is set, call renderer's tokenURI\\n    /// @param tokenId The tokenId used to request data\\n    function tokenURI(uint256 tokenId)\\n        public\\n        view\\n        override\\n        returns (string memory)\\n    {\\n        require(_exists(tokenId), \\\"ERC721: query for nonexistent token\\\");\\n\\n        if (renderer != address(0)) {\\n            return IRenderer(renderer).tokenURI(tokenId);\\n        }\\n\\n        return string(abi.encodePacked(contentURI, _toString(tokenId)));\\n    }\\n\\n    // ============ Withdrawal ============\\n\\n    /// @notice Set the price\\n    function setPrice(uint256 price_) external override onlyOwner {\\n        price = price_;\\n\\n        emit PriceSet(\\n            // price\\n            price_\\n        );\\n    }\\n\\n    function withdraw(uint16 feeBPS, address fundingRecipient)\\n        external\\n        onlyOwner\\n        nonReentrant\\n    {\\n        require(fundingRecipient != address(0), \\\"must set fundingRecipient\\\");\\n\\n        _withdraw(feeBPS, fundingRecipient);\\n    }\\n\\n    // ============ IERC165 Method ============\\n\\n    function supportsInterface(bytes4 interfaceId)\\n        public\\n        pure\\n        override\\n        returns (bool)\\n    {\\n        return\\n            interfaceId == type(IERC721).interfaceId ||\\n            interfaceId == type(IERC721Metadata).interfaceId ||\\n            interfaceId == type(IERC165).interfaceId ||\\n            interfaceId == type(IERC2981).interfaceId;\\n    }\\n\\n    // ============ Internal Methods ============\\n    function _withdraw(uint16 feeBPS, address fundingRecipient) internal {\\n        // assert that the fee is valid\\n        require(IMirrorFeeConfig(feeConfig).isFeeValid(feeBPS), \\\"invalid fee\\\");\\n\\n        // calculate the fee on the current balance, using the fee percentage\\n        uint256 fee = _feeAmount(address(this).balance, feeBPS);\\n\\n        // if the fee is not zero, attempt to send it to the treasury\\n        if (fee != 0) {\\n            _sendEther(ITreasuryConfig(treasuryConfig).treasury(), fee);\\n        }\\n\\n        // broadcast the withdrawal event \u2013 with balance and fee\\n        emit Withdrawal(\\n            // recipient\\n            fundingRecipient,\\n            // amount\\n            address(this).balance,\\n            // fee\\n            fee\\n        );\\n\\n        // transfer the remaining balance to the fundingRecipient\\n        _sendEther(payable(fundingRecipient), address(this).balance);\\n    }\\n\\n    function _sendEther(address payable recipient_, uint256 amount) internal {\\n        // ensure sufficient balance\\n        require(address(this).balance >= amount, \\\"insufficient balance\\\");\\n        // send the value\\n        (bool success, ) = recipient_.call{value: amount, gas: gasleft()}(\\\"\\\");\\n        require(success, \\\"recipient reverted\\\");\\n    }\\n\\n    function _feeAmount(uint256 amount, uint16 fee)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return (amount * fee) / 10_000;\\n    }\\n\\n    /// @dev ensure token has an owner, or token is within the allocation\\n    function _exists(uint256 tokenId) internal view override returns (bool) {\\n        return _owners[tokenId] != address(0) || tokenId < allocationCount;\\n    }\\n\\n    /// @dev Mints token and emits purchase event\\n    function _purchase(address recipient) internal returns (uint256 tokenId) {\\n        // mint the token, get a tokenId\\n        tokenId = _getTokenIdAndMint(recipient);\\n\\n        emit EditionPurchased(\\n            // tokenId\\n            tokenId,\\n            // nftRecipient\\n            recipient,\\n            // amountPaid\\n            msg.value\\n        );\\n    }\\n\\n    /// @dev Mints and returns tokenId\\n    function _getTokenIdAndMint(address recipient)\\n        internal\\n        returns (uint256 tokenId)\\n    {\\n        // increment currentTokenId and store tokenId\\n        tokenId = ++currentTokenId;\\n\\n        // check that there are still tokens available to purchase\\n        require(limit == 0 || tokenId < limit + 1, \\\"sold out\\\");\\n\\n        // mint a new token for the recipient, using the `tokenId`.\\n        _mint(recipient, tokenId);\\n    }\\n\\n    // From https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Strings.sol\\n    function _toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.10;\\n\\ninterface IOwnableEvents {\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n}\\n\\ncontract Ownable is IOwnableEvents {\\n    address public owner;\\n    address private nextOwner;\\n\\n    // modifiers\\n\\n    modifier onlyOwner() {\\n        require(isOwner(), \\\"caller is not the owner.\\\");\\n        _;\\n    }\\n\\n    modifier onlyNextOwner() {\\n        require(isNextOwner(), \\\"current owner must set caller as next owner.\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Initialize contract by setting transaction submitter as initial owner.\\n     */\\n    constructor(address owner_) {\\n        owner = owner_;\\n        emit OwnershipTransferred(address(0), owner);\\n    }\\n\\n    /**\\n     * @dev Initiate ownership transfer by setting nextOwner.\\n     */\\n    function transferOwnership(address nextOwner_) external onlyOwner {\\n        require(nextOwner_ != address(0), \\\"Next owner is the zero address.\\\");\\n\\n        nextOwner = nextOwner_;\\n    }\\n\\n    /**\\n     * @dev Cancel ownership transfer by deleting nextOwner.\\n     */\\n    function cancelOwnershipTransfer() external onlyOwner {\\n        delete nextOwner;\\n    }\\n\\n    /**\\n     * @dev Accepts ownership transfer by setting owner.\\n     */\\n    function acceptOwnership() external onlyNextOwner {\\n        delete nextOwner;\\n\\n        owner = msg.sender;\\n\\n        emit OwnershipTransferred(owner, msg.sender);\\n    }\\n\\n    /**\\n     * @dev Renounce ownership by setting owner to zero address.\\n     */\\n    function renounceOwnership() external onlyOwner {\\n        _renounceOwnership();\\n    }\\n\\n    /**\\n     * @dev Returns true if the caller is the current owner.\\n     */\\n    function isOwner() public view returns (bool) {\\n        return msg.sender == owner;\\n    }\\n\\n    /**\\n     * @dev Returns true if the caller is the next owner.\\n     */\\n    function isNextOwner() public view returns (bool) {\\n        return msg.sender == nextOwner;\\n    }\\n\\n    function _setOwner(address previousOwner, address newOwner) internal {\\n        owner = newOwner;\\n        emit OwnershipTransferred(previousOwner, owner);\\n    }\\n\\n    function _renounceOwnership() internal {\\n        emit OwnershipTransferred(owner, address(0));\\n\\n        owner = address(0);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.10;\\n\\ninterface IPausableEvents {\\n    /// @notice Emitted when the pause is triggered by `account`.\\n    event Paused(address account);\\n\\n    /// @notice Emitted when the pause is lifted by `account`.\\n    event Unpaused(address account);\\n}\\n\\ninterface IPausable {\\n    function paused() external returns (bool);\\n}\\n\\ncontract Pausable is IPausable, IPausableEvents {\\n    bool public override paused;\\n\\n    // Modifiers\\n\\n    modifier whenNotPaused() {\\n        require(!paused, \\\"Pausable: paused\\\");\\n        _;\\n    }\\n\\n    modifier whenPaused() {\\n        require(paused, \\\"Pausable: not paused\\\");\\n        _;\\n    }\\n\\n    /// @notice Initializes the contract in unpaused state.\\n    constructor(bool paused_) {\\n        paused = paused_;\\n    }\\n\\n    // ============ Internal Functions ============\\n\\n    function _pause() internal whenNotPaused {\\n        paused = true;\\n\\n        emit Paused(msg.sender);\\n    }\\n\\n    function _unpause() internal whenPaused {\\n        paused = false;\\n\\n        emit Unpaused(msg.sender);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/Reentrancy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.10;\\n\\ncontract Reentrancy {\\n    // ============ Constants ============\\n\\n    uint256 internal constant REENTRANCY_NOT_ENTERED = 1;\\n    uint256 internal constant REENTRANCY_ENTERED = 2;\\n\\n    // ============ Mutable Storage ============\\n\\n    uint256 internal reentrancyStatus;\\n\\n    // ============ Modifiers ============\\n\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(reentrancyStatus != REENTRANCY_ENTERED, \\\"Reentrant call\\\");\\n        // Any calls to nonReentrant after this point will fail\\n        reentrancyStatus = REENTRANCY_ENTERED;\\n        _;\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip2200)\\n        reentrancyStatus = REENTRANCY_NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/ERC721/ERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.10;\\n\\nimport {IERC721, IERC721Events, IERC721Metadata, IERC721Receiver} from \\\"./interface/IERC721.sol\\\";\\nimport {IERC165} from \\\"../ERC165/interface/IERC165.sol\\\";\\n\\nabstract contract ERC165 is IERC165 {\\n    function supportsInterface(bytes4 interfaceId)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (bool)\\n    {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\\n/**\\n * Based on: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/ERC721.sol\\n */\\ncontract ERC721 is ERC165, IERC721, IERC721Events {\\n    mapping(uint256 => address) internal _owners;\\n    mapping(address => uint256) internal _balances;\\n    mapping(uint256 => address) private _tokenApprovals;\\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\\n\\n    function supportsInterface(bytes4 interfaceId)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (bool)\\n    {\\n        return\\n            interfaceId == type(IERC721).interfaceId ||\\n            interfaceId == type(IERC721Metadata).interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n    function balanceOf(address owner)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (uint256)\\n    {\\n        require(\\n            owner != address(0),\\n            \\\"ERC721: balance query for the zero address\\\"\\n        );\\n        return _balances[owner];\\n    }\\n\\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\\n        address owner = _owners[tokenId];\\n        require(\\n            owner != address(0),\\n            \\\"ERC721: owner query for nonexistent token\\\"\\n        );\\n        return owner;\\n    }\\n\\n    /**\\n     * @dev Base URI for computing {tokenURI}. Empty by default, can be overriden\\n     * in child contracts.\\n     */\\n    function _baseURI() internal view virtual returns (string memory) {\\n        return \\\"\\\";\\n    }\\n\\n    function approve(address to, uint256 tokenId) public virtual override {\\n        address owner = ownerOf(tokenId);\\n        require(to != owner, \\\"ERC721: approval to current owner\\\");\\n\\n        require(\\n            msg.sender == owner || isApprovedForAll(owner, msg.sender),\\n            \\\"ERC721: approve caller is not owner nor approved for all\\\"\\n        );\\n\\n        _approve(to, tokenId);\\n    }\\n\\n    function getApproved(uint256 tokenId)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (address)\\n    {\\n        require(\\n            _exists(tokenId),\\n            \\\"ERC721: approved query for nonexistent token\\\"\\n        );\\n\\n        return _tokenApprovals[tokenId];\\n    }\\n\\n    function setApprovalForAll(address operator, bool approved)\\n        public\\n        virtual\\n        override\\n    {\\n        require(operator != msg.sender, \\\"ERC721: approve to caller\\\");\\n\\n        _operatorApprovals[msg.sender][operator] = approved;\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    function isApprovedForAll(address owner, address operator)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (bool)\\n    {\\n        return _operatorApprovals[owner][operator];\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public virtual override {\\n        //solhint-disable-next-line max-line-length\\n        require(\\n            _isApprovedOrOwner(msg.sender, tokenId),\\n            \\\"ERC721: transfer caller is not owner nor approved\\\"\\n        );\\n\\n        _transfer(from, to, tokenId);\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public virtual override {\\n        safeTransferFrom(from, to, tokenId, \\\"\\\");\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) public virtual override {\\n        require(\\n            _isApprovedOrOwner(msg.sender, tokenId),\\n            \\\"ERC721: transfer caller is not owner nor approved\\\"\\n        );\\n        _safeTransfer(from, to, tokenId, _data);\\n    }\\n\\n    function _safeTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) internal virtual {\\n        _transfer(from, to, tokenId);\\n        require(\\n            _checkOnERC721Received(from, to, tokenId, _data),\\n            \\\"ERC721: transfer to non ERC721Receiver implementer\\\"\\n        );\\n    }\\n\\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\\n        return _owners[tokenId] != address(0);\\n    }\\n\\n    function _isApprovedOrOwner(address spender, uint256 tokenId)\\n        internal\\n        view\\n        virtual\\n        returns (bool)\\n    {\\n        require(\\n            _exists(tokenId),\\n            \\\"ERC721: operator query for nonexistent token\\\"\\n        );\\n        address owner = ownerOf(tokenId);\\n        return (spender == owner ||\\n            getApproved(tokenId) == spender ||\\n            isApprovedForAll(owner, spender));\\n    }\\n\\n    function _safeMint(address to, uint256 tokenId) internal virtual {\\n        _safeMint(to, tokenId, \\\"\\\");\\n    }\\n\\n    function _safeMint(\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) internal virtual {\\n        _mint(to, tokenId);\\n        require(\\n            _checkOnERC721Received(address(0), to, tokenId, _data),\\n            \\\"ERC721: transfer to non ERC721Receiver implementer\\\"\\n        );\\n    }\\n\\n    function _mint(address to, uint256 tokenId) internal virtual {\\n        require(to != address(0), \\\"ERC721: mint to the zero address\\\");\\n        require(!_exists(tokenId), \\\"ERC721: token already minted\\\");\\n\\n        _balances[to] += 1;\\n        _owners[tokenId] = to;\\n\\n        emit Transfer(address(0), to, tokenId);\\n    }\\n\\n    function _burn(uint256 tokenId) internal virtual {\\n        address owner = ownerOf(tokenId);\\n\\n        // Clear approvals\\n        _approve(address(0), tokenId);\\n\\n        _balances[owner] -= 1;\\n        delete _owners[tokenId];\\n\\n        emit Transfer(owner, address(0), tokenId);\\n    }\\n\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual {\\n        require(\\n            ownerOf(tokenId) == from,\\n            \\\"ERC721: transfer of token that is not own\\\"\\n        );\\n        require(to != address(0), \\\"ERC721: transfer to the zero address\\\");\\n\\n        // Clear approvals from the previous owner\\n        _approve(address(0), tokenId);\\n\\n        _balances[from] -= 1;\\n        _balances[to] += 1;\\n        _owners[tokenId] = to;\\n\\n        emit Transfer(from, to, tokenId);\\n    }\\n\\n    function _approve(address to, uint256 tokenId) internal virtual {\\n        _tokenApprovals[tokenId] = to;\\n        emit Approval(ownerOf(tokenId), to, tokenId);\\n    }\\n\\n    function _checkOnERC721Received(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) private returns (bool) {\\n        if (isContract(to)) {\\n            try\\n                IERC721Receiver(to).onERC721Received(\\n                    msg.sender,\\n                    from,\\n                    tokenId,\\n                    _data\\n                )\\n            returns (bytes4 retval) {\\n                return retval == IERC721Receiver(to).onERC721Received.selector;\\n            } catch (bytes memory reason) {\\n                if (reason.length == 0) {\\n                    revert(\\n                        \\\"ERC721: transfer to non ERC721Receiver implementer\\\"\\n                    );\\n                } else {\\n                    // solhint-disable-next-line no-inline-assembly\\n                    assembly {\\n                        revert(add(32, reason), mload(reason))\\n                    }\\n                }\\n            }\\n        } else {\\n            return true;\\n        }\\n    }\\n\\n    // https://github.com/OpenZeppelin/openzeppelin-contracts/blob/7f6a1666fac8ecff5dd467d0938069bc221ea9e0/contracts/utils/Address.sol\\n    function isContract(address account) internal view returns (bool) {\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/ERC721/interface/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.10;\\n\\ninterface IERC721 {\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    function approve(address to, uint256 tokenId) external;\\n\\n    function getApproved(uint256 tokenId)\\n        external\\n        view\\n        returns (address operator);\\n\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    function isApprovedForAll(address owner, address operator)\\n        external\\n        view\\n        returns (bool);\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n}\\n\\ninterface IERC721Events {\\n    event Transfer(\\n        address indexed from,\\n        address indexed to,\\n        uint256 indexed tokenId\\n    );\\n    event Approval(\\n        address indexed owner,\\n        address indexed approved,\\n        uint256 indexed tokenId\\n    );\\n    event ApprovalForAll(\\n        address indexed owner,\\n        address indexed operator,\\n        bool approved\\n    );\\n}\\n\\ninterface IERC721Metadata {\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\\ninterface IERC721Burnable is IERC721 {\\n    function burn(uint256 tokenId) external;\\n}\\n\\ninterface IERC721Receiver {\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\\ninterface IERC721Royalties {\\n    function getFeeRecipients(uint256 id)\\n        external\\n        view\\n        returns (address payable[] memory);\\n\\n    function getFeeBps(uint256 id) external view returns (uint256[] memory);\\n}\\n\"\r\n    },\r\n    \"contracts/lib/ERC2309/interface/IERC2309.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.10;\\n\\ninterface IERC2309 {\\n    event ConsecutiveTransfer(\\n        uint256 indexed fromTokenId,\\n        uint256 toTokenId,\\n        address indexed fromAddress,\\n        address indexed toAddress\\n    );\\n}\\n\"\r\n    },\r\n    \"contracts/lib/ERC2981/interface/IERC2981.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.10;\\n\\n/**\\n * @title IERC2981\\n * @notice Interface for the NFT Royalty Standard\\n */\\ninterface IERC2981 {\\n    // / bytes4(keccak256(\\\"royaltyInfo(uint256,uint256)\\\")) == 0x2a55205a\\n\\n    /**\\n     * @notice Called with the sale price to determine how much royalty\\n     *         is owed and to whom.\\n     * @param _tokenId - the NFT asset queried for royalty information\\n     * @param _salePrice - the sale price of the NFT asset specified by _tokenId\\n     * @return receiver - address of who should be sent the royalty payment\\n     * @return royaltyAmount - the royalty payment amount for _salePrice\\n     */\\n    function royaltyInfo(uint256 _tokenId, uint256 _salePrice)\\n        external\\n        view\\n        returns (address receiver, uint256 royaltyAmount);\\n}\\n\"\r\n    },\r\n    \"contracts/producers/editions/interface/IEditions.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.10;\\n\\ninterface IEditionsEvents {\\n    event EditionPurchased(\\n        uint256 indexed tokenId,\\n        address indexed nftRecipient,\\n        uint256 amountPaid\\n    );\\n\\n    event RoyaltyChange(\\n        address indexed oldRoyaltyRecipient,\\n        uint256 oldRoyaltyBPS,\\n        address indexed newRoyaltyRecipient,\\n        uint256 newRoyaltyBPS\\n    );\\n\\n    event RendererSet(address indexed renderer);\\n\\n    event EditionLimitSet(uint256 oldLimit, uint256 newLimit);\\n\\n    event Withdrawal(address indexed recipient, uint256 amount, uint256 fee);\\n\\n    event FundingRecipientSet(\\n        address indexed oldFundingRecipient,\\n        address indexed newFundingRecipient\\n    );\\n\\n    event PriceSet(uint256 price);\\n}\\n\\ninterface IEditions {\\n    struct Edition {\\n        // Edition price\\n        uint256 price;\\n        // Edition supply limit\\n        uint256 limit;\\n        // Edition contentHash\\n        bytes32 contentHash;\\n    }\\n\\n    // ============ Authorization ============\\n\\n    function factory() external returns (address);\\n\\n    // ============ Fee Configuration ============\\n\\n    function feeConfig() external returns (address);\\n\\n    function treasuryConfig() external returns (address);\\n\\n    // ============ Edition Data ============\\n\\n    function price() external returns (uint256);\\n\\n    function limit() external returns (uint256);\\n\\n    function contentHash() external returns (bytes32);\\n\\n    // ============ Royalty Info (ERC2981) ============\\n\\n    function royaltyRecipient() external returns (address);\\n\\n    function royaltyBPS() external returns (uint256);\\n\\n    // ============ Rendering ============\\n\\n    function renderer() external view returns (address);\\n\\n    // ============ Initializing ============\\n\\n    function initialize(\\n        address owner_,\\n        string memory name_,\\n        string memory symbol_,\\n        string memory contentURI_,\\n        string memory contractURI_,\\n        Edition memory edition_,\\n        bool paused_\\n    ) external;\\n\\n    // ============ Pause Methods ============\\n\\n    function unpause() external;\\n\\n    function pause() external;\\n\\n    // ============ Allocation ============\\n\\n    function allocate(address recipient, uint256 count) external;\\n\\n    // ============ Purchase ============\\n\\n    function purchase(address recipient)\\n        external\\n        payable\\n        returns (uint256 tokenId);\\n\\n    // ============ Minting ============\\n\\n    function mint(address recipient) external returns (uint256 tokenId);\\n\\n    function setLimit(uint256 limit_) external;\\n\\n    // ============ ERC2981 Methods ============\\n\\n    function setRoyaltyInfo(\\n        address payable royaltyRecipient_,\\n        uint256 royaltyPercentage_\\n    ) external;\\n\\n    // ============ Rendering Methods ============\\n\\n    function setRenderer(address renderer_) external;\\n\\n    function contractURI() external view returns (string memory);\\n\\n    // ============ Withdrawal ============\\n\\n    function setPrice(uint256 price_) external;\\n\\n    function withdraw(uint16 feeBPS, address fundingRecipient) external;\\n}\\n\"\r\n    },\r\n    \"contracts/producers/editions/interface/IRenderer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.10;\\n\\ninterface IRenderer {\\n    function tokenURI(uint256 tokenId) external view returns (string calldata);\\n\\n    function contractURI() external view returns (string calldata);\\n}\\n\"\r\n    },\r\n    \"contracts/treasury/interface/ITreasuryConfig.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.10;\\n\\ninterface ITreasuryConfig {\\n    function treasury() external returns (address payable);\\n\\n    function distributionModel() external returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/treasury/interface/IMirrorTreasury.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.10;\\n\\ninterface IMirrorTreasury {\\n    function transferFunds(address payable to, uint256 value) external;\\n\\n    function transferERC20(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) external;\\n\\n    function contributeWithTributary(address tributary) external payable;\\n\\n    function contribute(uint256 amount) external payable;\\n}\\n\"\r\n    },\r\n    \"contracts/fee-config/MirrorFeeConfig.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.10;\\n\\nimport {Ownable} from \\\"../lib/Ownable.sol\\\";\\n\\ninterface IMirrorFeeConfig {\\n    function maxFee() external returns (uint16);\\n\\n    function minFee() external returns (uint16);\\n\\n    function isFeeValid(uint16) external view returns (bool);\\n\\n    function updateMaxFee(uint16 newFee) external;\\n\\n    function updateMinFee(uint16 newFee) external;\\n}\\n\\n/**\\n * @title MirrorFeeConfig\\n * @author MirrorXYZ\\n */\\ncontract MirrorFeeConfig is IMirrorFeeConfig, Ownable {\\n    uint16 public override maxFee = 500;\\n    uint16 public override minFee = 250;\\n\\n    constructor(address owner_) Ownable(owner_) {}\\n\\n    function updateMaxFee(uint16 newFee) external override onlyOwner {\\n        maxFee = newFee;\\n    }\\n\\n    function updateMinFee(uint16 newFee) external override onlyOwner {\\n        minFee = newFee;\\n    }\\n\\n    function isFeeValid(uint16 fee)\\n        external\\n        view\\n        returns (bool isBeweenMinAndMax)\\n    {\\n        isBeweenMinAndMax = (minFee <= fee) && (fee <= maxFee);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/ERC165/interface/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.10;\\n\\ninterface IERC165 {\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\\nabstract contract ERC165 is IERC165 {\\n    function supportsInterface(bytes4 interfaceId)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (bool)\\n    {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 2000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"factory_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"feeConfig_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"treasuryConfig_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"fromTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"toTokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"fromAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"toAddress\",\"type\":\"address\"}],\"name\":\"ConsecutiveTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldLimit\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newLimit\",\"type\":\"uint256\"}],\"name\":\"EditionLimitSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"nftRecipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountPaid\",\"type\":\"uint256\"}],\"name\":\"EditionPurchased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldFundingRecipient\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newFundingRecipient\",\"type\":\"address\"}],\"name\":\"FundingRecipientSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"PriceSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"renderer\",\"type\":\"address\"}],\"name\":\"RendererSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldRoyaltyRecipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldRoyaltyBPS\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newRoyaltyRecipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newRoyaltyBPS\",\"type\":\"uint256\"}],\"name\":\"RoyaltyChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"Withdrawal\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"name\":\"allocate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cancelOwnershipTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contentHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeConfig\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"name_\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol_\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"contentURI_\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"contractURI_\",\"type\":\"string\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"contentHash\",\"type\":\"bytes32\"}],\"internalType\":\"struct IEditions.Edition\",\"name\":\"edition_\",\"type\":\"tuple\"},{\"internalType\":\"bool\",\"name\":\"paused_\",\"type\":\"bool\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isNextOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"limit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"price\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"purchase\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renderer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"royaltyBPS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_salePrice\",\"type\":\"uint256\"}],\"name\":\"royaltyInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"royaltyAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"royaltyRecipient\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"limit_\",\"type\":\"uint256\"}],\"name\":\"setLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"price_\",\"type\":\"uint256\"}],\"name\":\"setPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"renderer_\",\"type\":\"address\"}],\"name\":\"setRenderer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"royaltyRecipient_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"royaltyBPS_\",\"type\":\"uint256\"}],\"name\":\"setRoyaltyInfo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nextOwner_\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasuryConfig\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"feeBPS\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"fundingRecipient\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Editions", "CompilerVersion": "v0.8.10+commit.fc410830", "OptimizationUsed": "1", "Runs": "2000", "ConstructorArguments": "0000000000000000000000006ef0f6be2556cfaff90bf0d572d7e38a13d715ad0000000000000000000000002b27d7a2b62d532e8d34fb8b35a41c75eb90a85400000000000000000000000021a93be569666527dae0fdbfbe7715299dec1202", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}