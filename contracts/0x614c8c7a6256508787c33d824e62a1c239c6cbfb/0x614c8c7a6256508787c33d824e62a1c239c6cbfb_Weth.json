{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/BaseModule.sol\": {\r\n      \"content\": \"import \\\"./interfaces/IExternalStore.sol\\\";\\n\\npragma solidity >=0.8.19;\\n\\n// SPDX-License-Identifier: MIT\\n\\ninterface IDiamondStore {\\n    function owner() external view returns (address owner);\\n\\n    function checkAdmin(address user) external view returns (bool isAdmin);\\n\\n    function getUserFromWallet(\\n        address wallet\\n    ) external view returns (address owner);\\n\\n    function store(\\n        address user,\\n        bytes32 namespace,\\n        uint slot,\\n        bytes memory data\\n    ) external;\\n\\n    function getStore(\\n        address user,\\n        bytes32 namespace,\\n        uint slot\\n    ) external view returns (bytes memory);\\n\\n    function store(bytes32 namespace, uint slot, bytes memory data) external;\\n\\n    function getStore(\\n        bytes32 namespace,\\n        uint slot\\n    ) external view returns (bytes memory);\\n}\\n\\nabstract contract BaseModule {\\n    /*\\n        @dev order of import matters! ALWAYS import BaseModule FIRST\\n        @dev storage will always take up the first slot\\n        \\n        Example of storing data        \\n        contractStore[userProxy][NAMESPACE][0]=abi.encode(user, token, amount, poolAddress);\\n\\n        Example of retrieving data\\n        (address user, uint token, uint amount, address poolAddress = abi.decode(contractStore[userProxy][NAMESPACE][0], (address,uint,uint address));\\n    */\\n\\n    /// @dev to set when diamond has been minted\\n\\n    address internal immutable diamond =\\n        0x98738F824BDbA894F42f3c70B3e13C73cd8f7a3C;\\n\\n    address internal immutable _this;\\n\\n    /*\\n        @dev Determines the namespace for storing data\\n        @dev Data will be stored in caller contract (Smart Wallet)\\n\\n        example of storing data \\n\\n\\n    */\\n    bytes32 internal immutable NAMESPACE;\\n\\n    /// @dev used only for reading directly from the contract. This variable will not return correct data in the event of a delegatecall\\n    string public name;\\n\\n    event Event(bytes4 fnSig, uint256 eventIndex, bytes eventData);\\n\\n    error BaseModuleUnauthorized();\\n\\n    // Generic error struct\\n    error FacetError(bytes4 funcSig, uint index);\\n\\n    struct TokenAmt {\\n        address token;\\n        uint amt;\\n    }\\n\\n    constructor(string memory name_) {\\n        _this = address(this);\\n        name = name_;\\n        /// @dev we avoid using address(this) as a namespace to cater for upgrades\\n        NAMESPACE = keccak256(abi.encodePacked(block.chainid, name));\\n    }\\n\\n    modifier onlyDiamondOwner() {\\n        if (msg.sender != IDiamondStore(diamond).owner())\\n            revert BaseModuleUnauthorized();\\n        _;\\n    }\\n\\n    modifier onlyDiamondAdmin() {\\n        if (!IDiamondStore(diamond).checkAdmin(msg.sender)) {\\n            if (msg.sender != IDiamondStore(diamond).owner())\\n                revert BaseModuleUnauthorized();\\n        }\\n        _;\\n    }\\n\\n    modifier onlyWalletOwner() {\\n        if (\\n            msg.sender !=\\n            IDiamondStore(diamond).getUserFromWallet((address(this)))\\n        ) revert BaseModuleUnauthorized();\\n        _;\\n    }\\n\\n    modifier onlySmartWallet() virtual {\\n        if (\\n            IDiamondStore(diamond).getUserFromWallet(address(this)) ==\\n            address(0)\\n        ) revert BaseModuleUnauthorized();\\n        _;\\n    }\\n\\n    function _store(address user, uint slot, bytes memory data) internal {\\n        IDiamondStore(diamond).store(user, NAMESPACE, slot, data);\\n    }\\n\\n    function _getStore(\\n        address user,\\n        bytes32 namespace,\\n        uint slot\\n    ) internal view returns (bytes memory) {\\n        return IDiamondStore(diamond).getStore(user, namespace, slot);\\n    }\\n\\n    function _store(uint slot, bytes memory data) internal {\\n        IDiamondStore(diamond).store(NAMESPACE, slot, data);\\n    }\\n\\n    function _getStore(\\n        bytes32 namespace,\\n        uint slot\\n    ) internal view returns (bytes memory) {\\n        return IDiamondStore(diamond).getStore(namespace, slot);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/DezyModules/Common/Weth.sol\": {\r\n      \"content\": \"import \\\"../../BaseModule.sol\\\";\\npragma solidity 0.8.19;\\n\\n// SPDX-License-Identifier: MIT\\n\\ninterface IWETH {\\n    function withdraw(uint amount) external;\\n    function approve(address spender, uint amount) external;\\n    function transfer(address to, uint amount) external;\\n}\\n\\ncontract Weth is BaseModule{\\n    address public immutable weth;\\n\\n    constructor(address weth_)BaseModule(\\\"Weth\\\") {\\n        weth = weth_;\\n    }\\n\\n\\n    /// @notice Wraps ether\\n    /// @custom:version 1\\n    /// @custom:in 1\\n    /// @custom:out wEth\\n    /// @custom:equal false\\n    /// @custom:override oWethWrap\\n    /// @custom:event uint256 amount\\n    /// @custom:mirror oWethUnwrap\\n    /// @custom:getter none\\n    function wethWrap(uint amount) public payable returns (TokenAmt[] memory) {\\n        (bool success, ) = weth.call{value: amount}(\\\"\\\");\\n        if (!success) revert FacetError(this.wethWrap.selector, 0);\\n        TokenAmt[] memory tokenAmts = new TokenAmt[](1);\\n        tokenAmts[0] = TokenAmt({token: weth, amt: amount});\\n        emit Event(this.wethWrap.selector, 0, abi.encode(amount));\\n        return tokenAmts;\\n    }\\n\\n    /// @notice Unwraps Ether\\n    /// @custom:version 1\\n    /// @custom:in 1\\n    /// @custom:out Eth\\n    /// @custom:equal false\\n    /// @custom:override oWethUnwrap\\n    /// @custom:event uint256 amount\\n    /// @custom:mirror none\\n    /// @custom:getter none\\n    function wethUnwrap(uint amount) public payable returns (TokenAmt[] memory) {\\n        IWETH(weth).approve(weth, amount);\\n        IWETH(weth).withdraw(amount);\\n        TokenAmt[] memory tokenAmts = new TokenAmt[](1);\\n        tokenAmts[0] = TokenAmt({token: address(0), amt: amount});\\n        emit Event(this.wethUnwrap.selector, 0, abi.encode(amount));\\n        return tokenAmts;\\n    }\\n\\n    function oWethWrap(bytes memory, TokenAmt[] memory tokenAmts) public pure returns(bytes memory){\\n        /// @dev only 1 input expected\\n        return abi.encode(tokenAmts[0].amt);\\n    }\\n    function oWethUnwrap(bytes memory, TokenAmt[] memory tokenAmts) public pure returns(bytes memory){\\n        /// @dev only 1 input expected\\n        return abi.encode(tokenAmts[0].amt);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IExternalStore.sol\": {\r\n      \"content\": \"pragma solidity 0.8.19;\\n\\n// SPDX-License-Identifier: MIT\\n\\ninterface IExternalStore {\\n    function store(\\n        address user,\\n        bytes32 namespace,\\n        uint slot,\\n        bytes memory data\\n    ) external;\\n\\n    function getStore(\\n        address user,\\n        bytes32 namespace,\\n        uint slot\\n    ) external view returns (bytes memory);\\n\\n    function store(bytes32 namespace, uint slot, bytes memory data) external;\\n\\n    function getStore(\\n        bytes32 namespace,\\n        uint slot\\n    ) external view returns (bytes memory);\\n\\n    function owner() external view returns(address);\\n    function getOwner() external view returns(address);\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"viaIR\": true,\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"weth_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"BaseModuleUnauthorized\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"funcSig\",\"type\":\"bytes4\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"FacetError\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes4\",\"name\":\"fnSig\",\"type\":\"bytes4\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"eventIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"eventData\",\"type\":\"bytes\"}],\"name\":\"Event\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"internalType\":\"struct BaseModule.TokenAmt[]\",\"name\":\"tokenAmts\",\"type\":\"tuple[]\"}],\"name\":\"oWethUnwrap\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"internalType\":\"struct BaseModule.TokenAmt[]\",\"name\":\"tokenAmts\",\"type\":\"tuple[]\"}],\"name\":\"oWethWrap\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"weth\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"wethUnwrap\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"internalType\":\"struct BaseModule.TokenAmt[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"wethWrap\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"internalType\":\"struct BaseModule.TokenAmt[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"}]", "ContractName": "Weth", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}