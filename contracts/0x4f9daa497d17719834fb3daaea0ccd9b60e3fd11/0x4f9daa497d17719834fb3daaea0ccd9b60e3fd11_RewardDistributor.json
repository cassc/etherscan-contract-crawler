{"SourceCode": "// File: IVRFv2DirectFundingConsumer.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.21;\r\ninterface IVRFv2DirectFundingConsumer{\r\n        function getRequestStatus(uint256 _requestId) external view returns (uint256 paid, bool fulfilled, uint256[] memory randomWords);\r\n        function requestRandomWords(uint32 numWords) external returns (uint256 requestId);\r\n}\r\n// File: IRoleRegistry.sol\r\n\r\npragma solidity ^0.8.21;\r\n\r\n\r\ninterface IRoleRegistry{\r\n    function getRouter() external view returns(address);\r\n    function getOwner() external view returns(address);\r\n    function getController() external view returns(address);\r\n    function getRewardDistributor() external view returns(address);\r\n    function getOperator() external view returns(address);\r\n    function getVRF() external view returns(address);\r\n    function getReserveAddress() external view returns(address);\r\n}\r\n// File: IMutualPool.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.21;\r\n\r\n\r\n\r\n\r\ninterface IMutualPool{\r\n    event rewardPortionUpdated(uint256 first, uint256 second, uint256 third);\r\n    event OwnershipTransferred(address oldOwner, address newOwner);\r\n    event ControllerRoleTransferred(address oldController, address newController);\r\n    event changedRouter(address oldRouter, address newRouter);\r\n\r\n\r\n    struct PrizeDetails{\r\n        address winner;\r\n        uint256 prizeAmount;\r\n        bool claimed;\r\n    }\r\n    struct EpochResult{\r\n        PrizeDetails first;\r\n        PrizeDetails second;\r\n        PrizeDetails third;\r\n        bool finalized;\r\n        uint256 totalPrize;\r\n        uint256 duration;\r\n        uint256 createdTimeStamp;\r\n        uint256 totalParticipant;\r\n    }\r\n\r\n    struct rewardAllocation{\r\n        uint256 first;\r\n        uint256 second;\r\n        uint256 third;\r\n    }\r\n    struct userInfo{\r\n        address userAddress;\r\n        uint256 DepositAmount;\r\n        uint256 registeredDate;\r\n        uint256 Lastupdated;\r\n        //uint256 depositTimeStamp;\r\n    }\r\n    struct ChangeArray{\r\n        uint256 oldAmount;\r\n        uint256 newAmount;\r\n        uint256 updatedBlock;\r\n    }\r\n    struct userChangeHistory{\r\n        bool changedwithinEpoch;\r\n        ChangeArray[] historyArray;\r\n    }\r\n    struct rewardHistory{\r\n        uint256 EpochNumber;\r\n        uint256 position;\r\n        uint256 PrizeAmount;\r\n    }\r\n    struct claimableRewardInfo{\r\n        uint256 claimable;\r\n        rewardHistory[] rewardHistoryArray;\r\n    }\r\n\r\n\r\n    function initialize(address registryAddress) external;\r\n    function changeRegistryContractAddr(address registryAddress) external;\r\n\r\n    /*Only Router functions */\r\n    function depositFor(address user, uint256 amount) external;\r\n    function withdrawFor(address user, uint256 amount) external;\r\n    function claimRewardsFor(address user) external returns(uint256);\r\n\r\n\r\n    /*View Area*/\r\n    function getPoolTVL() external view returns(uint256);\r\n    function getCurrentEpochReward() external view returns(uint256);\r\n    function getClaimable(address user) external view returns(uint256);\r\n    \r\n    function getWinningHistory(address user) external view returns(rewardHistory[] memory);\r\n    function getBalanceChangeHistory(address user, uint256 epochNumber) external view returns(userChangeHistory memory);\r\n    function getUserID(address user) external view returns(uint256);\r\n\r\n    function getUserAmount() external view returns(uint256);\r\n    function getuserByID(uint256 userID) external view returns(address);\r\n    function getUserDepositInfo(address user) external view returns(userInfo memory);\r\n    function getAccumulatedTicketwithoutDecimal(uint256 epochNumber, address user) external view returns(uint256);\r\n    function getTicketAmount(uint256 epochNumber, address user) external view returns(uint256);\r\n    function getTokenUsing() external view returns(address);\r\n    function getLatestEpoch() external view returns(uint256);\r\n    function getEpochLength() external view returns(uint256);\r\n    function getEpochInfo(uint256 epochNumber) external view returns(EpochResult memory);\r\n    function getRewardAllocationPercentage() external view returns(rewardAllocation memory);\r\n    function getMinAmountToDeposit() external view returns(uint256);\r\n\r\n    \r\n    function setToken(address token) external;\r\n    function setTicketDecimal(uint256 decimal) external;\r\n    function setStakePoolAddress(address StakePoolAdd) external;\r\n    function setEpochDuration(uint256 duration) external;\r\n    function setMinAmounttoDeposit(uint256 amount) external;\r\n    function setRewardRatio(uint256 firstP, uint256 secondP, uint256 thirdP, uint256 percentageSUM) external;\r\n    \r\n    function finalizeEpochTicketandParticipantInfo(uint256 epochNumber) external;\r\n    function finalizeEpoch(uint256 epochNumber, address firstWinner, address secondWinner, address thirdWinner, uint256 totalPrize) external;\r\n\r\n    function createNewEpoch() external;\r\n    function claimRewardFromPool() external returns(uint256);\r\n    \r\n\r\n}\r\n\r\n\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\r\n}\r\n\r\n// File: RewardDistributor.sol\r\n\r\npragma solidity ^0.8.21;\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract RewardDistributor{\r\n\r\n    struct RandomnessRequest{\r\n        address poolAddress;\r\n        uint256 epochNumber;\r\n        uint256 DrawRequestID;\r\n        uint256 thisDrawTicketAmount;\r\n        uint32 randomWordsAmount;\r\n        bool fulfilled;\r\n        uint256[] results;\r\n    }\r\n    address registryContract;\r\n    bool initialized;\r\n    uint256 currentDrawRequestID;\r\n    uint256 thisDrawTicketAmount;\r\n    RandomnessRequest[] randomnessHistory;\r\n    modifier onlyOwner(){\r\n        address role = IRoleRegistry(registryContract).getOwner();\r\n        require(msg.sender == role, \"Invalid caller\");\r\n        _;\r\n    }\r\n\r\n    \r\n\r\n    modifier onlyOperator(){\r\n        address role = IRoleRegistry(registryContract).getOperator();\r\n        require(msg.sender == role, \"Invalid caller\");\r\n        _;\r\n    }\r\n\r\n    function initialize(address registryAddress) external{\r\n        require(initialized == false, \"Contract is initialized already\");\r\n        _transferRegistryAddr(registryAddress);\r\n        initialized = true;\r\n    }\r\n\r\n    function _transferRegistryAddr(address registryAddress) internal{\r\n        registryContract = registryAddress;\r\n    }\r\n\r\n    function changeRegistryContractAddr(address registryAddress) external onlyOwner{\r\n        _transferRegistryAddr(registryAddress);\r\n    }\r\n\r\n    function genesisEpochInitialize(address poolAddress) external onlyOperator{\r\n        IMutualPool(poolAddress).createNewEpoch();\r\n    }\r\n\r\n    function SumUpandClaimPrizeEpoch(address poolAddress, uint256 epochNumber, bool manualClaimreward) external onlyOperator returns(uint256){\r\n        uint256 rewardclaimed;\r\n        IMutualPool(poolAddress).finalizeEpochTicketandParticipantInfo(epochNumber);\r\n        if(manualClaimreward){\r\n            rewardclaimed = IMutualPool(poolAddress).claimRewardFromPool();\r\n        }\r\n        else{\r\n            rewardclaimed = IMutualPool(poolAddress).getCurrentEpochReward();\r\n        }\r\n        return rewardclaimed;\r\n\r\n    }\r\n\r\n    function requestRandomness(address poolAddress,uint256 epochNumber, uint256 TotalTicketAmount,uint32 randomWordsAmount) external onlyOperator returns(uint256){\r\n\r\n        address VRFAddress = IRoleRegistry(registryContract).getVRF();\r\n        uint256 requestID = IVRFv2DirectFundingConsumer(VRFAddress).requestRandomWords(randomWordsAmount);\r\n\r\n        randomnessHistory.push(RandomnessRequest({\r\n            poolAddress: poolAddress,\r\n            epochNumber: epochNumber,\r\n            DrawRequestID: requestID,\r\n            thisDrawTicketAmount: TotalTicketAmount,\r\n            randomWordsAmount: randomWordsAmount,\r\n            fulfilled: false,\r\n            results: new uint256[](3)\r\n        }));\r\n\r\n\r\n        uint256 result = randomnessHistory.length - 1;\r\n        return result;\r\n    }\r\n\r\n\r\n    \r\n    function comeupwithThisDrawLuckyUsers(uint256 requestHistoryID) external onlyOperator returns(uint256[] memory){\r\n        \r\n        uint256 requestID = randomnessHistory[requestHistoryID].DrawRequestID;\r\n        uint256 totalTicketAmount = randomnessHistory[requestHistoryID].thisDrawTicketAmount;\r\n        address VRFAddress = IRoleRegistry(registryContract).getVRF();\r\n        (, bool fulfilled, uint256[] memory randomWords) = IVRFv2DirectFundingConsumer(VRFAddress).getRequestStatus(requestID);\r\n        require(fulfilled,\"The randomness request is not fulfilled, please wait a bit more\");\r\n        for(uint i = 0;i<randomWords.length;i++){\r\n            randomnessHistory[requestHistoryID].results[i] = randomWords[i] % totalTicketAmount;\r\n        }\r\n        randomnessHistory[requestHistoryID].fulfilled = true;\r\n\r\n        return randomnessHistory[requestHistoryID].results;\r\n    }\r\n    \r\n\r\n    function FinalizeAndCreateNewEpoch(address poolAddress, uint256 epochNumber, address firstWinner, address secondWinner, address thirdWinner, uint256 totalPrize)  external onlyOperator{\r\n        IMutualPool(poolAddress).finalizeEpoch(epochNumber,firstWinner,secondWinner,thirdWinner,totalPrize);\r\n        IMutualPool(poolAddress).createNewEpoch();\r\n    }\r\n\r\n    function getRandomnessHistory(uint256 requestHistoryID) public view returns(RandomnessRequest memory) {\r\n        RandomnessRequest memory result = randomnessHistory[requestHistoryID];\r\n        return result;\r\n    }\r\n    \r\n\r\n\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"poolAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"epochNumber\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"firstWinner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"secondWinner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"thirdWinner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalPrize\",\"type\":\"uint256\"}],\"name\":\"FinalizeAndCreateNewEpoch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"poolAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"epochNumber\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"manualClaimreward\",\"type\":\"bool\"}],\"name\":\"SumUpandClaimPrizeEpoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"registryAddress\",\"type\":\"address\"}],\"name\":\"changeRegistryContractAddr\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"requestHistoryID\",\"type\":\"uint256\"}],\"name\":\"comeupwithThisDrawLuckyUsers\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"poolAddress\",\"type\":\"address\"}],\"name\":\"genesisEpochInitialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"requestHistoryID\",\"type\":\"uint256\"}],\"name\":\"getRandomnessHistory\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"poolAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"epochNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"DrawRequestID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"thisDrawTicketAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"randomWordsAmount\",\"type\":\"uint32\"},{\"internalType\":\"bool\",\"name\":\"fulfilled\",\"type\":\"bool\"},{\"internalType\":\"uint256[]\",\"name\":\"results\",\"type\":\"uint256[]\"}],\"internalType\":\"struct RewardDistributor.RandomnessRequest\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"registryAddress\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"poolAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"epochNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"TotalTicketAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"randomWordsAmount\",\"type\":\"uint32\"}],\"name\":\"requestRandomness\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "RewardDistributor", "CompilerVersion": "v0.8.22+commit.4fc1097e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://e1431099641a9a250f173cab3fabe8447e996ccf1ce5515255c6f293371846b4"}