{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.19;\r\n\r\ninterface IERC20 {\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n}\r\n\r\ncontract BLACKHOLEGAME {\r\n    struct Round {\r\n        uint32 isOpen;\r\n        uint32 additionalTime;\r\n        uint32 startTime;\r\n        address lastPlayer;\r\n        uint256 entryTokens;\r\n    }\r\n\r\n    Round[] public Rounds;\r\n\r\n    uint256 public entryTokens;\r\n    uint256 public additionalTime;\r\n\r\n    address public owner;\r\n\r\n    IERC20 public blackholeToken;\r\n\r\n    event NewEntry(uint256 indexed roundNumber, address indexed account);\r\n\r\n    event RoundEnded(uint256 indexed roundNumber, address indexed account, uint256 totalPot);\r\n\r\n    event RoundSkipped(address indexed account, uint256 totalPot);\r\n\r\n    event NewRound(uint256 roundNumber);\r\n    \r\n    event BLACKHOLE();\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    constructor () {\r\n        owner = msg.sender;\r\n\r\n        Rounds.push(Round(0, 100, 0, address(0xdead), 100 * 10 ** 18));\r\n    }\r\n\r\n    function play() external {\r\n        require(msg.sender == tx.origin, \"No bots allowed\");\r\n\r\n        uint256 roundNumber = Rounds.length - 1;\r\n        Round storage round = Rounds[roundNumber];\r\n\r\n        require(round.isOpen == 1, \"Game has not started yet!\");\r\n\r\n        if (round.startTime + round.additionalTime > block.timestamp) {\r\n            try blackholeToken.transferFrom(msg.sender, address(this), round.entryTokens) {\r\n                round.startTime = uint32(block.timestamp);\r\n                round.lastPlayer = msg.sender;\r\n\r\n                emit NewEntry(roundNumber, msg.sender);\r\n            }\r\n            catch {\r\n                revert(\"Please approve the usage of BLACKHOLE to the game contract to play and check if you have enough tokens\");\r\n            }\r\n        }\r\n        else {\r\n            uint256 gameBalance = blackholeToken.balanceOf(address(this));\r\n\r\n            blackholeToken.transfer(round.lastPlayer, gameBalance * 50 / 100);\r\n            blackholeToken.transfer(address(0xdead), gameBalance * 20 / 100);\r\n\r\n            emit RoundEnded(roundNumber, round.lastPlayer, gameBalance);\r\n\r\n            Rounds.push(Round(1, uint32(additionalTime), uint32(block.timestamp), msg.sender, entryTokens));\r\n\r\n            emit NewRound(roundNumber + 1);\r\n\r\n            if (round.startTime + round.additionalTime + additionalTime < block.timestamp) {\r\n                /*\r\n                    this is the case when 2x additionalTime has passed since the end of the first round\r\n                    meaning that while there was no tx to renew the round, the next round time has actually already passed\r\n                    so the passed round will be skipped but the participant will receive some reward\r\n                */\r\n\r\n                gameBalance = blackholeToken.balanceOf(address(this));\r\n\r\n                blackholeToken.transfer(msg.sender, gameBalance * 5 / 100);\r\n\r\n                emit RoundSkipped(msg.sender, gameBalance);\r\n            }\r\n        }\r\n    }\r\n\r\n    function startTheGame() external onlyOwner {\r\n        require(Rounds[0].isOpen == 0);\r\n        Rounds[0].isOpen = 1;\r\n\r\n        require(additionalTime > 0 && entryTokens > 0);\r\n        Rounds[0].additionalTime = uint32(additionalTime);\r\n        Rounds[0].startTime = uint32(block.timestamp);\r\n        Rounds[0].entryTokens = entryTokens;\r\n\r\n        require(blackholeToken.balanceOf(address(this)) > 0);\r\n\r\n        emit BLACKHOLE();\r\n    }\r\n\r\n    function setBlackholeAddress(address blackholeAddress) external onlyOwner {\r\n        require(address(blackholeToken) == address(0));\r\n\r\n        blackholeToken = IERC20(blackholeAddress);\r\n    }\r\n\r\n    function changeNextRoundAdditionalTime(uint32 newAdditionalTime) external onlyOwner {\r\n        require(newAdditionalTime <= 1 hours);\r\n\r\n        additionalTime = newAdditionalTime;\r\n    }\r\n\r\n    function changeNextRoundEntryTokens(uint256 newEntryTokens) external onlyOwner {\r\n        require(newEntryTokens <= 100);\r\n\r\n        // apply 18 decimals here\r\n        entryTokens = newEntryTokens * 10 ** 18;\r\n    }\r\n\r\n    //////////////////////////////////////////////////////////////////////////////////////\r\n    // view functions for dapp //\r\n    //////////////////////////////////////////////////////////////////////////////////////\r\n\r\n    function getData() external view returns(Round memory, uint256, uint256, uint256, uint256) {\r\n        uint256 roundNumber = Rounds.length - 1;\r\n        Round memory round = Rounds[roundNumber];\r\n\r\n        uint256 endTime = round.startTime + round.additionalTime;\r\n        uint256 remainingTime;\r\n        if (endTime > block.timestamp) {\r\n            remainingTime = endTime - block.timestamp;\r\n        }\r\n        else {\r\n            remainingTime = 0;\r\n        }\r\n\r\n        return (round, roundNumber, remainingTime, block.timestamp, blackholeToken.balanceOf(address(this)));\r\n    }\r\n\r\n    function getDataForAccount(address account) external view returns(Round memory, uint256, uint256, uint256, uint256, uint256, uint256) {\r\n        uint256 roundNumber = Rounds.length - 1;\r\n        Round memory round = Rounds[roundNumber];\r\n\r\n        uint256 endTime = round.startTime + round.additionalTime;\r\n        uint256 remainingTime;\r\n        if (endTime > block.timestamp) {\r\n            remainingTime = endTime - block.timestamp;\r\n        }\r\n        else {\r\n            remainingTime = 0;\r\n        }\r\n\r\n        uint256 balance = blackholeToken.balanceOf(account);\r\n        uint256 allowance = blackholeToken.allowance(account, address(this));\r\n\r\n        return (round, roundNumber, remainingTime, block.timestamp, blackholeToken.balanceOf(address(this)), balance, allowance);\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"BLACKHOLE\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"roundNumber\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"NewEntry\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"roundNumber\",\"type\":\"uint256\"}],\"name\":\"NewRound\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"roundNumber\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalPot\",\"type\":\"uint256\"}],\"name\":\"RoundEnded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalPot\",\"type\":\"uint256\"}],\"name\":\"RoundSkipped\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"Rounds\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"isOpen\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"additionalTime\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"startTime\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"lastPlayer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"entryTokens\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"additionalTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"blackholeToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"newAdditionalTime\",\"type\":\"uint32\"}],\"name\":\"changeNextRoundAdditionalTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newEntryTokens\",\"type\":\"uint256\"}],\"name\":\"changeNextRoundEntryTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"entryTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getData\",\"outputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"isOpen\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"additionalTime\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"startTime\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"lastPlayer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"entryTokens\",\"type\":\"uint256\"}],\"internalType\":\"struct BLACKHOLEGAME.Round\",\"name\":\"\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getDataForAccount\",\"outputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"isOpen\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"additionalTime\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"startTime\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"lastPlayer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"entryTokens\",\"type\":\"uint256\"}],\"internalType\":\"struct BLACKHOLEGAME.Round\",\"name\":\"\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"play\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"blackholeAddress\",\"type\":\"address\"}],\"name\":\"setBlackholeAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startTheGame\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "BLACKHOLEGAME", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "999999", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://5a9cd9c5a1e75ec29056da211874b2233d8a54a9ba2a300292fcb42a60c047ef"}