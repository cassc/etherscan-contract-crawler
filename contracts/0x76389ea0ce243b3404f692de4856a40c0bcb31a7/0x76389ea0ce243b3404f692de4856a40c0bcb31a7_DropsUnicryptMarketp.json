{"SourceCode": "{\"Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    function _contextSuffixLength() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n}\\n\"},\"DropsUnicryptMarketplace.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\n\\n/*\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800.\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\\n\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28fe\u28f7\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\\n\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2880\u28fc\u28ff\u28ff\u28e7\u2840\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\\n\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2880\u28fe\u28ff\u28ff\u28ff\u28ff\u28f7\u2840\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\\n\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2880\u28fe\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28f7\u2840\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\\n\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2880\u28fe\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28f7\u2840\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\\n\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28a0\u28fe\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28f7\u2844\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\\n\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28a0\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2844\u2800\u2800\u2800\u2800\u2800\u2800\u2800\\n\u2800\u2800\u2800\u2800\u2800\u2800\u28a0\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2844\u2800\u2800\u2800\u2800\u2800\u2800\\n\u2800\u2800\u2800\u2800\u2800\u2800\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2800\u2800\u2800\u2800\u2800\u2800\\n\u2800\u2800\u2800\u2800\u2800\u2800\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2800\u2800\u2800\u2800\u2800\u2800\\n\u2800\u2800\u2800\u2800\u2800\u2800\u28bb\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u285f\u2800\u2800\u2800\u2800\u2800\u2800\\n\u2800\u2800\u2800\u2800\u2800\u2800\u2808\u28bb\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u285f\u2801\u2800\u2800\u2800\u2800\\n\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2819\u283b\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u281f\u280b\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\\n\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2809\u2819\u281b\u281b\u281b\u281b\u280b\u2809\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800 \\n\\nDrops Lock Marketplace is the first locked liquidity marketplace.\\nThis smart contract is our Unicrypt LP lock marketplace.\\n\\nhttps://drops.site\\nhttps://t.me/dropserc\\nhttps://x.com/dropserc\\n\\n$DROPS token address -\\u003e 0xA562912e1328eEA987E04c2650EfB5703757850C\\n\\n*/\\n\\npragma solidity ^0.8.0;\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./ReentrancyGuard.sol\\\";\\n\\ninterface IUniswapV2Locker {\\n    // Getter function to fetch details about a specific lock for a user\\n    function getUserLockForTokenAtIndex(\\n        address user,\\n        address lpAddress,\\n        uint256 index\\n    )\\n        external\\n        view\\n        returns (uint256, uint256, uint256, uint256, uint256, address);\\n\\n    function tokenLocks(\\n        address lpAddress,\\n        uint256 lockID\\n    )\\n        external\\n        view\\n        returns (uint256, uint256, uint256, uint256, uint256, address);\\n\\n    // Function to transfer the ownership of a lock\\n    function transferLockOwnership(\\n        address lpAddress,\\n        uint256 index,\\n        uint256 lockID,\\n        address payable newOwner\\n    ) external;\\n\\n    function getUserNumLocksForToken(\\n        address _user,\\n        address _lpAddress\\n    ) external view returns (uint256);\\n}\\n\\n/// @title Marketplace for LP Token Lock Ownership\\n/// @notice This contract allows users to list and sell their Uniswap V2 LP token lock ownerships locked through Unicrypt.\\ncontract DropsUnicryptMarketplace is Ownable, ReentrancyGuard {\\n    // Unicrypt V2 Locker address\\n    IUniswapV2Locker public uniswapV2Locker;\\n\\n    // Native Drops token address\\n    IERC20 public dropsToken;\\n    address payable public feeWallet;\\n    uint256 public listingCount;\\n    address public marketplaceOwner;\\n    uint256 public activeListings;\\n    uint256 public listedLPsCount;\\n    uint256 public totalValueListedInDrops;\\n    uint256 public totalValueList;\\n    uint256 public ethFee;\\n    uint256 public referralBonus;\\n\\n    // Zero address constant\\n    address zeroAddress = 0x0000000000000000000000000000000000000000;\\n\\n    // Relevant listing info\\n    struct Listing {\\n        uint256 lockID;\\n        uint256 listingID;\\n        uint256 listingIndex;\\n        address payable seller;\\n        address lpAddress;\\n        uint256 priceInETH;\\n        uint256 priceInDrops;\\n        uint256 listDate;\\n        bool isActive;\\n        bool isSold;\\n        address payable referral;\\n        bool isVerified;\\n    }\\n\\n    struct ListingDetail {\\n        uint256 lockID;\\n        address lpAddress;\\n    }\\n\\n    // lpAddress + lockID -\\u003e returns Listing\\n    mapping(address =\\u003e mapping(uint256 =\\u003e Listing)) public lpToLockID;\\n    mapping(uint256 =\\u003e ListingDetail) public listingDetail;\\n    mapping(address =\\u003e bool) public isLPListed;\\n\\n    // Relevant events\\n    event LockPurchasedWithETH(\\n        address lpToken,\\n        uint256 lockID,\\n        uint256 profitInETH,\\n        uint256 feeETH\\n    );\\n    event LockPurchasedWithDrops(\\n        address lpToken,\\n        uint256 lockID,\\n        uint256 profitInDrops\\n    );\\n    event ListingInitiated(\\n        address lpToken, \\n        uint256 lockID, \\n        address seller);\\n    event NewActiveListing(\\n        address lpToken,\\n        uint256 lockID,\\n        uint256 priceInETH,\\n        uint256 priceInDrops\\n    );\\n    event LockVerified(\\n        address lpToken, \\n        uint256 lockID, \\n        bool status);\\n    event ListingRedacted(\\n        address lpToken,\\n        uint256 lockID,\\n        address seller\\n    );\\n    event ListingWithdrawn(address lpToken, uint256 lockID);\\n    event DropsAddressUpdated(address _dropsAddress);\\n    event FeeAddressUpdated(address _feeWallet);\\n    event LockerAddressUpdated(address _lockerAddress);\\n    event ChangedETHFee(uint256 _ethFee);\\n\\n    /// @notice Initialize the contract with Uniswap V2 Locker, Fee Wallet, and Drops Token addresses\\n    /// @dev Sets the contract\\u0027s dependencies and the owner upon deployment\\n    /// @param _uniswapV2Locker Address of the Uniswap V2 Locker contract\\n    /// @param _feeWallet Address of the wallet where fees will be collected\\n    /// @param _dropsTokenAddress Address of the Drops token contract\\n    constructor(\\n        address _uniswapV2Locker,\\n        address payable _feeWallet,\\n        address _dropsTokenAddress\\n    ) Ownable(msg.sender) {\\n        uniswapV2Locker = IUniswapV2Locker(_uniswapV2Locker);\\n        feeWallet = _feeWallet;\\n        marketplaceOwner = msg.sender;\\n        dropsToken = IERC20(_dropsTokenAddress);\\n        ethFee = 10;\\n        referralBonus = 3;\\n    }\\n\\n    /// @notice Set the eth fee (in percentage)\\n    /// @dev This function can only be called by the contract owner\\n    /// @param _ethFee Fee percentage for buyLockWithETH\\n    function setETHFee(uint256 _ethFee) external onlyOwner {\\n        require(_ethFee \\u003c 10, \\\"Maximum fee is 10%\\\");\\n        require(ethFee != _ethFee, \\\"You must change the fee\\\");\\n        ethFee = _ethFee;\\n        emit ChangedETHFee(_ethFee);\\n    }\\n\\n    /// @notice Set the address of the Drops token\\n    /// @dev This function can only be called by the contract owner\\n    /// @param _dropsTokenAddress The address of the Drops token contract\\n    function setDropsToken(address _dropsTokenAddress) external onlyOwner {\\n        require(\\n            address(dropsToken) != _dropsTokenAddress,\\n            \\\"Must input different contract address\\\"\\n        );\\n        require(\\n            _dropsTokenAddress != zeroAddress,\\n            \\\"Cant set drops address as zero address\\\"\\n        );\\n        dropsToken = IERC20(_dropsTokenAddress);\\n        emit DropsAddressUpdated(_dropsTokenAddress);\\n    }\\n\\n    /// @notice Set the address of the fee wallet\\n    /// @dev This function can only be called by the contract owner\\n    /// @param _feeWallet The address of the new fee wallet\\n    function setFeeWallet(address payable _feeWallet) external onlyOwner {\\n        require(feeWallet != _feeWallet, \\\"Same wallet\\\");\\n        require(\\n            _feeWallet != zeroAddress,\\n            \\\"Cant set fee wallet as zero address\\\"\\n        );\\n        feeWallet = _feeWallet;\\n        emit FeeAddressUpdated(_feeWallet);\\n    }\\n\\n    /// @notice Set the address of the liquidity locker\\n    /// @dev This function can only be called by the contract owner\\n    /// @param _uniswapV2Locker The address of the new liquidity locker\\n    function setLockerAddress(address _uniswapV2Locker) external onlyOwner {\\n        require(\\n            address(uniswapV2Locker) != _uniswapV2Locker,\\n            \\\"Must input different contract address\\\"\\n        );\\n        require(\\n            _uniswapV2Locker != zeroAddress,\\n            \\\"Cant set locker address as zero address\\\"\\n        );\\n        uniswapV2Locker = IUniswapV2Locker(_uniswapV2Locker);\\n        emit LockerAddressUpdated(_uniswapV2Locker);\\n    }\\n\\n    /// @notice List an LP token lock for sale\\n    /// @dev The seller must be the owner of the lock and approve this contract to manage the lock\\n    /// @param _lpAddress Address of the LP token\\n    /// @param _lockID The ID of the lock\\n    /// @param _priceInETH The selling price in ETH\\n    /// @param _priceInDrops The selling price in Drops tokens\\n    function initiateListing(\\n        address _lpAddress,\\n        uint256 _lockID,\\n        uint256 _priceInETH,\\n        uint256 _priceInDrops,\\n        address payable _referral\\n    ) external {\\n        (, , , , , address owner) = uniswapV2Locker.tokenLocks(\\n            _lpAddress,\\n            _lockID\\n        );\\n        require(msg.sender == owner, \\\"You dont own that lock.\\\");\\n        require(\\n            (_priceInETH \\u003e 0) || (_priceInDrops \\u003e 0),\\n            \\\"You must set a price in Drops or ETH\\\"\\n        );\\n        Listing memory tempListing = lpToLockID[_lpAddress][_lockID];\\n        (bool lockFound, uint256 index) = _getIndexForUserLock(\\n            _lpAddress,\\n            _lockID,\\n            _msgSender()\\n        );\\n        require(lockFound, \\\"Lock not found!\\\");\\n\\n        if (tempListing.listingID == 0) {\\n            listingCount++;\\n            listingDetail[listingCount] = ListingDetail(_lockID, _lpAddress);\\n        }\\n        lpToLockID[_lpAddress][_lockID] = Listing(\\n            _lockID,\\n            listingCount,\\n            index,\\n            payable(msg.sender),\\n            _lpAddress,\\n            _priceInETH,\\n            _priceInDrops,\\n            block.timestamp,\\n            false,\\n            false,\\n            _referral,\\n            false\\n        );\\n        if (!isLPListed[_lpAddress]) {\\n            isLPListed[_lpAddress] = true;\\n            listedLPsCount++;\\n        }\\n        emit ListingInitiated(_lpAddress, _lockID, msg.sender);\\n    }\\n\\n    /// @notice Activate an initiated listing\\n    /// @dev The seller must have transfered lock ownership to address(this)\\n    /// @param lpAddress Address of the LP token\\n    /// @param lockID Unique lockID (per lpAddress) of the lock\\n    function activateListing(address lpAddress, uint256 lockID) external {\\n        Listing memory tempListing = lpToLockID[lpAddress][lockID];\\n        require(tempListing.seller == msg.sender, \\\"Lock doesnt belong to you.\\\");\\n        require(!tempListing.isActive, \\\"Listing already active.\\\");\\n        require(!tempListing.isSold, \\\"Listing already sold.\\\");\\n        (, , , , , address owner) = uniswapV2Locker.tokenLocks(\\n            lpAddress,\\n            lockID\\n        );\\n        require(owner == address(this), \\\"Lock ownership not yet transferred.\\\");\\n        lpToLockID[lpAddress][lockID].isActive = true;\\n        activeListings++;\\n        emit NewActiveListing(\\n            tempListing.lpAddress,\\n            tempListing.lockID,\\n            tempListing.priceInETH,\\n            tempListing.priceInDrops\\n        );\\n    }\\n\\n    function fetchListing(\\n        address lpAddress,\\n        uint256 lockID\\n    ) external view returns (Listing memory) {\\n        return (lpToLockID[lpAddress][lockID]);\\n    }\\n\\n    /// @notice Purchase a listed LP token lock with ETH\\n    /// @param lpAddress Address of the LP token\\n    /// @param lockID The ID of the lock\\n    function buyLockWithETH(\\n        address lpAddress,\\n        uint256 lockID\\n    ) external payable nonReentrant {\\n        Listing memory tempListing = lpToLockID[lpAddress][lockID];\\n        require(tempListing.isActive, \\\"Listing must be active.\\\");\\n        require(tempListing.priceInETH \\u003e 0, \\\"Listing not for sale in ETH.\\\");\\n        require(\\n            msg.value == tempListing.priceInETH,\\n            \\\"Incorrect amount of ETH.\\\"\\n        );\\n\\n        (bool lockFound, uint256 index) = _getIndex(lpAddress, tempListing);\\n\\n        require(lockFound, \\\"Mismatch in inputs\\\");\\n\\n        uint256 feeAmount = msg.value / ethFee;\\n        uint256 toPay = msg.value - feeAmount;\\n\\n        if (tempListing.referral != zeroAddress) {\\n            uint256 feeForReferral = (feeAmount * referralBonus) / ethFee;\\n            feeAmount = feeAmount - feeForReferral;\\n            tempListing.referral.transfer(feeForReferral);\\n            feeWallet.transfer(feeAmount);\\n        } else {\\n            feeWallet.transfer(feeAmount);\\n        }\\n\\n        payable(tempListing.seller).transfer(toPay);\\n\\n        lpToLockID[lpAddress][lockID].isActive = false;\\n        lpToLockID[lpAddress][lockID].isSold = true;\\n        activeListings--;\\n\\n        uniswapV2Locker.transferLockOwnership(\\n            lpAddress,\\n            index,\\n            lockID,\\n            payable(msg.sender)\\n        );\\n\\n        emit LockPurchasedWithETH(\\n            tempListing.lpAddress,\\n            tempListing.lockID,\\n            toPay,\\n            feeAmount\\n        );\\n    }\\n\\n    /// @notice Purchase a listed LP token lock with Drops tokens\\n    /// @dev Requires approval to transfer Drops tokens to cover the purchase price\\n    /// @param lpAddress Address of the LP token\\n    /// @param lockID The ID of the lock\\n    function buyLockWithDrops(\\n        address lpAddress,\\n        uint256 lockID\\n    ) external payable nonReentrant {\\n        Listing memory tempListing = lpToLockID[lpAddress][lockID];\\n\\n        require(tempListing.isActive, \\\"Listing must be active.\\\");\\n        require(tempListing.priceInDrops \\u003e 0, \\\"Listing not for sale in Drops.\\\");\\n        require(\\n            dropsToken.balanceOf(msg.sender) \\u003e tempListing.priceInDrops,\\n            \\\"Insufficient drops.\\\"\\n        );\\n\\n        (bool lockFound, uint256 index) = _getIndex(lpAddress, tempListing);\\n\\n        require(lockFound, \\\"Mismatch in inputs.\\\");\\n        require(\\n            dropsToken.transferFrom(\\n                msg.sender,\\n                tempListing.seller,\\n                tempListing.priceInDrops\\n            )\\n        );\\n\\n        lpToLockID[lpAddress][lockID].isActive = false;\\n        lpToLockID[lpAddress][lockID].isSold = true;\\n        activeListings--;\\n\\n        uniswapV2Locker.transferLockOwnership(\\n            lpAddress,\\n            index,\\n            lockID,\\n            payable(msg.sender)\\n        );\\n\\n        emit LockPurchasedWithDrops(\\n            tempListing.lpAddress,\\n            tempListing.lockID,\\n            tempListing.priceInDrops\\n        );\\n    }\\n\\n    function getIndex(\\n        address _user,\\n        address _lpAddress,\\n        uint256 _lockID\\n    ) external view returns (bool, uint256) {\\n        return _getIndexForUserLock(_lpAddress, _lockID, _user);\\n    }\\n\\n    /// @notice Find unique (per lpAddress) lock index in order to transfer lock ownership\\n    /// @param _lpAddress Address of the LP token\\n    /// @param _listing Listing in question\\n    function _getIndex(\\n        address _lpAddress,\\n        Listing memory _listing\\n    ) internal view returns (bool, uint256) {\\n        uint256 index;\\n        uint256 numLocksAtAddress = uniswapV2Locker.getUserNumLocksForToken(\\n            address(this),\\n            _lpAddress\\n        );\\n        bool lockFound = false;\\n\\n        if (numLocksAtAddress == 1) {\\n            index = 0;\\n            lockFound = true;\\n        } else {\\n            for (index = 0; index \\u003c numLocksAtAddress; index++) {\\n                (, , , , uint256 _lockID, ) = uniswapV2Locker\\n                    .getUserLockForTokenAtIndex(\\n                        address(this),\\n                        _lpAddress,\\n                        index\\n                    );\\n                if (_lockID == _listing.lockID) {\\n                    lockFound = true;\\n                    break;\\n                }\\n            }\\n        }\\n        return (lockFound, index);\\n    }\\n\\n    function _getIndexForUserLock(\\n        address _lpAddress,\\n        uint256 _lockID,\\n        address user\\n    ) internal view returns (bool, uint256) {\\n        uint256 index;\\n        uint256 numLocksAtAddress = uniswapV2Locker.getUserNumLocksForToken(\\n            user,\\n            _lpAddress\\n        );\\n        bool lockFound = false;\\n        if (numLocksAtAddress == 1) {\\n            index = 0;\\n            lockFound = true;\\n        } else {\\n            for (index = 0; index \\u003c numLocksAtAddress; index++) {\\n                (, , , , uint256 _tempLockID, ) = uniswapV2Locker\\n                    .getUserLockForTokenAtIndex(user, _lpAddress, index);\\n                if (_tempLockID == _lockID) {\\n                    lockFound = true;\\n                    break;\\n                }\\n            }\\n        }\\n        return (lockFound, index);\\n    }\\n\\n    /// @notice Withdraw a listed LP token lock\\n    /// @dev Only the seller can withdraw the listing\\n    /// @param lpAddress Address of the LP token\\n    /// @param lockID The ID of the lock\\n    function withdrawListing(\\n        address lpAddress,\\n        uint256 lockID\\n    ) external nonReentrant {\\n        Listing memory tempListing = lpToLockID[lpAddress][lockID];\\n        require(\\n            tempListing.seller == msg.sender,\\n            \\\"This listing does not belong to you.\\\"\\n        );\\n\\n        (, , , , , address owner) = uniswapV2Locker.tokenLocks(\\n            lpAddress,\\n            lockID\\n        );\\n        require(owner == address(this), \\\"Marketplace does not own your lock\\\");\\n\\n        (bool lockFound, uint256 index) = _getIndex(lpAddress, tempListing);\\n\\n        require(lockFound, \\\"Mismatch in inputs.\\\");\\n\\n        if (tempListing.isActive) {\\n            lpToLockID[lpAddress][lockID].isActive = false;\\n            activeListings--;\\n        }\\n\\n        uniswapV2Locker.transferLockOwnership(\\n            lpAddress,\\n            index,\\n            lockID,\\n            payable(msg.sender)\\n        );\\n\\n        emit ListingWithdrawn(lpAddress, lockID);\\n    }\\n\\n    /// @notice Verify a listing as safe\\n    /// @dev Only dev can verify listings\\n    /// @param lpAddress Address of the LP token\\n    /// @param lockID Unique lock ID (per lpAdress) of the lock\\n    /// @param status Status of verification\\n    function verifyListing(\\n        address lpAddress, \\n        uint256 lockID,\\n        bool status) external onlyOwner {\\n            Listing storage tempListing = lpToLockID[lpAddress][lockID];\\n            require(status != tempListing.isVerified, \\\"Must change listing status\\\");\\n            tempListing.isVerified = true;\\n            emit LockVerified(lpAddress, lockID, status);\\n    }\\n\\n    /// @notice Change the ETH price of a listing\\n    /// @dev Only seller can change price\\n    /// @param lpAddress Address of the LP token\\n    /// @param lockID Unique lock ID (per lpAddress) of the lock\\n    /// @param newPriceInETH Updated ETH price of listing\\n    function changePriceInETH(\\n        address lpAddress,\\n        uint256 lockID,\\n        uint256 newPriceInETH\\n    ) external nonReentrant {\\n        Listing storage tempListing = lpToLockID[lpAddress][lockID];\\n        require(\\n            tempListing.seller == msg.sender,\\n            \\\"This listing does not belong to you.\\\"\\n        );\\n        tempListing.priceInETH = newPriceInETH;\\n    }\\n\\n    /// @notice Change the price of a listing in Drops\\n    /// @dev Only seller can change price\\n    /// @param lpAddress Address of the LP token\\n    /// @param lockID Unique lock ID (per lpAddress) of the lock\\n    /// @param newPriceInDrops Updated Drops price of listing\\n    function changePriceInDrops(\\n        address lpAddress,\\n        uint256 lockID,\\n        uint256 newPriceInDrops\\n    ) external nonReentrant {\\n        Listing storage tempListing = lpToLockID[lpAddress][lockID];\\n        require(\\n            tempListing.seller == msg.sender,\\n            \\\"This listing does not belong to you.\\\"\\n        );\\n        tempListing.priceInDrops = newPriceInDrops;\\n    }\\n\\n    /// @notice Return ownership of a lock to the original seller and remove the listing\\n    /// @dev Only the contract owner can call this function\\n    /// @param lpAddress Address of the LP token associated with the lock\\n    /// @param lockID The ID of the lock to be redacted\\n    function redactListing(address lpAddress, uint256 lockID) external onlyOwner {\\n        Listing storage listing = lpToLockID[lpAddress][lockID];\\n\\n        require(listing.seller != address(0), \\\"Listing does not exist.\\\");\\n\\n        (bool lockFound, uint256 index) = _getIndex(lpAddress, listing);\\n        require(lockFound, \\\"Lock not found.\\\");\\n\\n        uniswapV2Locker.transferLockOwnership(lpAddress, index, lockID, listing.seller);\\n        \\n        if (listing.isActive) {\\n            listing.isActive = false;\\n            activeListings--;\\n        }\\n\\n        delete lpToLockID[lpAddress][lockID];\\n        emit ListingRedacted(lpAddress, lockID, listing.seller);\\n    }\\n\\n}\\n\"},\"IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC-20 standard as defined in the ERC.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the value of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the value of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller\\u0027s account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller\\u0027s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\n     * allowance mechanism. `value` is then deducted from the caller\\u0027s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\"},\"Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Context} from \\\"./Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * The initial owner is set to the address provided by the deployer. This can\\n * later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    /**\\n     * @dev The caller account is not authorized to perform an operation.\\n     */\\n    error OwnableUnauthorizedAccount(address account);\\n\\n    /**\\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\\n     */\\n    error OwnableInvalidOwner(address owner);\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\\n     */\\n    constructor(address initialOwner) {\\n        if (initialOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(initialOwner);\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        if (owner() != _msgSender()) {\\n            revert OwnableUnauthorizedAccount(_msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        if (newOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"},\"ReentrancyGuard.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot\\u0027s contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler\\u0027s defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction\\u0027s gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant NOT_ENTERED = 1;\\n    uint256 private constant ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    /**\\n     * @dev Unauthorized reentrant call.\\n     */\\n    error ReentrancyGuardReentrantCall();\\n\\n    constructor() {\\n        _status = NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\\n        if (_status == ENTERED) {\\n            revert ReentrancyGuardReentrantCall();\\n        }\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Returns true if the reentrancy guard is currently set to \\\"entered\\\", which indicates there is a\\n     * `nonReentrant` function in the call stack.\\n     */\\n    function _reentrancyGuardEntered() internal view returns (bool) {\\n        return _status == ENTERED;\\n    }\\n}\\n\"}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_uniswapV2Locker\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_feeWallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_dropsTokenAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnableInvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnableUnauthorizedAccount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ReentrancyGuardReentrantCall\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_ethFee\",\"type\":\"uint256\"}],\"name\":\"ChangedETHFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_dropsAddress\",\"type\":\"address\"}],\"name\":\"DropsAddressUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_feeWallet\",\"type\":\"address\"}],\"name\":\"FeeAddressUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"lpToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lockID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"}],\"name\":\"ListingInitiated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"lpToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lockID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"}],\"name\":\"ListingRedacted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"lpToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lockID\",\"type\":\"uint256\"}],\"name\":\"ListingWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"lpToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lockID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"profitInDrops\",\"type\":\"uint256\"}],\"name\":\"LockPurchasedWithDrops\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"lpToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lockID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"profitInETH\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"feeETH\",\"type\":\"uint256\"}],\"name\":\"LockPurchasedWithETH\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"lpToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lockID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"LockVerified\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_lockerAddress\",\"type\":\"address\"}],\"name\":\"LockerAddressUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"lpToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lockID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"priceInETH\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"priceInDrops\",\"type\":\"uint256\"}],\"name\":\"NewActiveListing\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lpAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"lockID\",\"type\":\"uint256\"}],\"name\":\"activateListing\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"activeListings\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lpAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"lockID\",\"type\":\"uint256\"}],\"name\":\"buyLockWithDrops\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lpAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"lockID\",\"type\":\"uint256\"}],\"name\":\"buyLockWithETH\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lpAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"lockID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newPriceInDrops\",\"type\":\"uint256\"}],\"name\":\"changePriceInDrops\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lpAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"lockID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newPriceInETH\",\"type\":\"uint256\"}],\"name\":\"changePriceInETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dropsToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ethFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeWallet\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lpAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"lockID\",\"type\":\"uint256\"}],\"name\":\"fetchListing\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"lockID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"listingID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"listingIndex\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"seller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"lpAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"priceInETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"priceInDrops\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"listDate\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isSold\",\"type\":\"bool\"},{\"internalType\":\"address payable\",\"name\":\"referral\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isVerified\",\"type\":\"bool\"}],\"internalType\":\"struct DropsUnicryptMarketplace.Listing\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_lpAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_lockID\",\"type\":\"uint256\"}],\"name\":\"getIndex\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lpAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_lockID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_priceInETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_priceInDrops\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"_referral\",\"type\":\"address\"}],\"name\":\"initiateListing\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isLPListed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"listedLPsCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"listingCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"listingDetail\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"lockID\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"lpAddress\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"lpToLockID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"lockID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"listingID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"listingIndex\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"seller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"lpAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"priceInETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"priceInDrops\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"listDate\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isSold\",\"type\":\"bool\"},{\"internalType\":\"address payable\",\"name\":\"referral\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isVerified\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketplaceOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lpAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"lockID\",\"type\":\"uint256\"}],\"name\":\"redactListing\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"referralBonus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_dropsTokenAddress\",\"type\":\"address\"}],\"name\":\"setDropsToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_ethFee\",\"type\":\"uint256\"}],\"name\":\"setETHFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_feeWallet\",\"type\":\"address\"}],\"name\":\"setFeeWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_uniswapV2Locker\",\"type\":\"address\"}],\"name\":\"setLockerAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalValueList\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalValueListedInDrops\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Locker\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Locker\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lpAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"lockID\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"verifyListing\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lpAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"lockID\",\"type\":\"uint256\"}],\"name\":\"withdrawListing\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "DropsUnicryptMarketplace", "CompilerVersion": "v0.8.24+commit.e11b9ed9", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000663a5c229c09b049e36dcc11a9b0d4a8eb9db214000000000000000000000000cdb94d75b5522b0440f638a17be7f8d70a7745f6000000000000000000000000a562912e1328eea987e04c2650efb5703757850c", "EVMVersion": "istanbul", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://6f2bfd35d3d8982ea015f6b7f71e30d8fc91c17bdf909e9b263c54c046c89193"}