{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/PaymentSender.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\r\\n// solhint-disable-next-line\\r\\npragma solidity 0.8.12;\\r\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\r\\n\\r\\n/// @notice Contract to receive and distribute payments on ETH or ERC20 tokens\\r\\n\\r\\ncontract PaymentSender is\\r\\n  ERC1155Holder,\\r\\n  IERC721Receiver,\\r\\n  Ownable,\\r\\n  ReentrancyGuard\\r\\n{\\r\\n  /// @notice ETH amount still not distributed\\r\\n  uint256 public reserveBalance;\\r\\n  /// @notice ETH amount for contributions (coming from taxes)\\r\\n  uint256 public contributionsBalance;\\r\\n  /// @notice Perc of taxes to take on deposits\\r\\n  uint256 public taxesPerc;\\r\\n  /// @notice Address of the wallet that signs messages\\r\\n  address public secret;\\r\\n\\r\\n  /// @notice Mapping of ETH balances for each wallet address\\r\\n  mapping(address => uint256) public ethBalance;\\r\\n\\r\\n  /// @notice Mapping of used signatures\\r\\n  mapping(bytes => bool) public usedSignatures;\\r\\n  /// @notice Mapping of allowed wallets\\r\\n  mapping(address => bool) public isAllowed;\\r\\n\\r\\n  /// @notice Event emitted when ETH is deposited to reserve balance\\r\\n  event Deposit(uint256 amount, address operator);\\r\\n  /// @notice Event emitted when ETH is deposited to contributions balance\\r\\n  event Contribution(uint256 amount, address operator);\\r\\n  /// @notice Event emitted when ETH is distributed\\r\\n  event Distribute(uint256[] amounts, address[] recipients, address operator);\\r\\n  /// @notice Event emitted ETH is sent\\r\\n  event SendETH(uint256[] amounts, address[] recipients, address operator);\\r\\n  /// @notice Event emitted when someone withdraws ETH\\r\\n  event WithdrawETH(uint256 amount, address recipient, address operator);\\r\\n\\r\\n  /// @notice Event emitted when someone withdraws ERC20 tokens\\r\\n  event WithdrawERC20(\\r\\n    address token,\\r\\n    uint256 amount,\\r\\n    address recipient,\\r\\n    address operator\\r\\n  );\\r\\n\\r\\n  /// @notice Event emitted when someone withdraws ERC721 or ERC1155 tokens\\r\\n  event WithdrawNFT(\\r\\n    address token,\\r\\n    uint256 tokenId,\\r\\n    uint256 amount,\\r\\n    address recipient,\\r\\n    address operator\\r\\n  );\\r\\n\\r\\n  /// @notice Event emitted when a new signer is set\\r\\n  event SetSigner(address signer);\\r\\n\\r\\n  /// @notice Event emitted when a new allowed wallet is set\\r\\n  event SetAllowed(address wallet, bool allowed);\\r\\n\\r\\n  /// @notice Event emitted when a signature is marked as used without withdrawing anything\\r\\n  event UseSignature(bytes signature);\\r\\n\\r\\n  /// @notice Event emitted when ETH is unassigned from a recipient\\r\\n  event UnassignETH(uint256 amount, address recipient);\\r\\n\\r\\n  /// @notice Event emitted when taxes percentage is set\\r\\n  event SetTaxesPerc(uint256 taxesPerc);\\r\\n\\r\\n  constructor() {}\\r\\n\\r\\n  /// @notice Fall back function to receive ETH\\r\\n  receive() external payable {\\r\\n    depositToReserve(msg.value, taxesPerc);\\r\\n  }\\r\\n\\r\\n  /// @notice modifier of wallets allowed to use restricted functions\\r\\n  modifier onlyAllowed() {\\r\\n    require(\\r\\n      isAllowed[msg.sender] || msg.sender == owner(),\\r\\n      \\\"onlyAllowed: Not allowed\\\"\\r\\n    );\\r\\n    _;\\r\\n  }\\r\\n\\r\\n  /// @notice Function to deposit ETH and distribute it to recipients\\r\\n  /// @param amounts Amounts of ETH to distribute\\r\\n  /// @param recipients Addresses to distribute ETH to\\r\\n  /// @dev Only assign the ETH to the recipients, doesn't send it, use sendFunds for that\\r\\n  function distribute(\\r\\n    uint256[] memory amounts,\\r\\n    address[] memory recipients,\\r\\n    uint256 taxToTake,\\r\\n    bool fromContributions\\r\\n  ) external payable onlyAllowed nonReentrant {\\r\\n    _handleFunds(amounts, recipients, true, taxToTake, fromContributions);\\r\\n\\r\\n    emit Distribute(amounts, recipients, msg.sender);\\r\\n  }\\r\\n\\r\\n  /// @notice Function to send ETH to recipients\\r\\n  /// @param amounts Amounts of ETH to send\\r\\n  /// @param recipients Addresses to send ETH to\\r\\n  /// @dev Only send the ETH to the recipients, doesn't assign it, use distribute for that\\r\\n  function sendFunds(\\r\\n    uint256[] memory amounts,\\r\\n    address[] memory recipients,\\r\\n    uint256 taxToTake,\\r\\n    bool fromContributions\\r\\n  ) external payable onlyAllowed nonReentrant {\\r\\n    _handleFunds(amounts, recipients, false, taxToTake, fromContributions);\\r\\n\\r\\n    emit SendETH(amounts, recipients, msg.sender);\\r\\n  }\\r\\n\\r\\n  /// @notice Function to withdraw ETH\\r\\n  /// @param amount Amount of ETH to withdraw\\r\\n  /// @param recipient Address to withdraw ETH to\\r\\n  /// @dev Withdraw from the ETH balance of the sender\\r\\n  function withdrawETH(uint256 amount, address payable recipient) external {\\r\\n    require(amount > 0, \\\"withdraw: Amount must be greater than 0\\\");\\r\\n    require(\\r\\n      ethBalance[msg.sender] >= amount,\\r\\n      \\\"withdraw: Not enough ETH in your balance to withdraw\\\"\\r\\n    );\\r\\n\\r\\n    ethBalance[msg.sender] -= amount;\\r\\n\\r\\n    recipient.transfer(amount);\\r\\n\\r\\n    emit WithdrawETH(amount, recipient, msg.sender);\\r\\n  }\\r\\n\\r\\n  /// @notice use a signature to withdraw ETH without having any assigned\\r\\n  /// @param amount Amount of ETH to withdraw\\r\\n  /// @param recipient Address to withdraw ETH to\\r\\n  /// @param checkId Id to check if the signature was used\\r\\n  /// @param signature Signature to use\\r\\n  function withdrawETHWithSignature(\\r\\n    uint256 amount,\\r\\n    address recipient,\\r\\n    uint256 checkId,\\r\\n    bytes memory signature\\r\\n  ) external {\\r\\n    require(\\r\\n      amount <= reserveBalance,\\r\\n      \\\"withdrawETHWithSignature: Not enough ETH in reserve to withdraw\\\"\\r\\n    );\\r\\n\\r\\n    bytes32 hash = keccak256(\\r\\n      abi.encode(recipient, amount, checkId, \\\"withdrawETHWithSignature\\\")\\r\\n    );\\r\\n\\r\\n    _handleSignature(hash, signature);\\r\\n\\r\\n    reserveBalance -= amount;\\r\\n\\r\\n    payable(recipient).transfer(amount);\\r\\n\\r\\n    emit WithdrawETH(amount, recipient, msg.sender);\\r\\n  }\\r\\n\\r\\n  /// @notice use a signature to withdraw ERC20 tokens\\r\\n  /// @param token Address of the ERC20 token\\r\\n  /// @param amount Amount of ERC20 tokens to withdraw\\r\\n  /// @param recipient Address to withdraw ERC20 tokens to\\r\\n  /// @param checkId Id to check if the signature was used\\r\\n  /// @param signature Signature to use\\r\\n  function withdrawERC20WithSignature(\\r\\n    address token,\\r\\n    uint256 amount,\\r\\n    address recipient,\\r\\n    uint256 checkId,\\r\\n    bytes memory signature\\r\\n  ) external {\\r\\n    require(\\r\\n      amount <= IERC20(token).balanceOf(address(this)),\\r\\n      \\\"withdrawERC20WithSignature: Not enough ERC20 tokens in reserve to withdraw\\\"\\r\\n    );\\r\\n\\r\\n    bytes32 hash = keccak256(\\r\\n      abi.encode(\\r\\n        token,\\r\\n        recipient,\\r\\n        amount,\\r\\n        checkId,\\r\\n        \\\"withdrawERC20WithSignature\\\"\\r\\n      )\\r\\n    );\\r\\n\\r\\n    _handleSignature(hash, signature);\\r\\n\\r\\n    IERC20(token).transfer(recipient, amount);\\r\\n\\r\\n    emit WithdrawERC20(token, amount, recipient, msg.sender);\\r\\n  }\\r\\n\\r\\n  /// @notice use a signature to withdraw ERC721 or ERC1155 tokens\\r\\n  /// @param token Address of the ERC721 or ERC1155 token\\r\\n  /// @param tokenId Id of the ERC721 or ERC1155 token\\r\\n  /// @param amount Amount of ERC1155 token to withdraw (ERC721 = 0, amount not required)\\r\\n  /// @param recipient Address to withdraw ERC721 or ERC1155 tokens to\\r\\n  /// @param checkId Id to check if the signature was used\\r\\n  /// @param signature Signature to use\\r\\n  function withdrawNFTWithSignature(\\r\\n    address token,\\r\\n    uint256 tokenId,\\r\\n    uint256 amount,\\r\\n    address recipient,\\r\\n    uint256 checkId,\\r\\n    bytes memory signature\\r\\n  ) external {\\r\\n    bytes32 hash = keccak256(\\r\\n      abi.encode(\\r\\n        token,\\r\\n        tokenId,\\r\\n        recipient,\\r\\n        amount,\\r\\n        checkId,\\r\\n        \\\"withdrawNFTWithSignature\\\"\\r\\n      )\\r\\n    );\\r\\n\\r\\n    _handleSignature(hash, signature);\\r\\n\\r\\n    if (amount == 0) {\\r\\n      require(\\r\\n        IERC721(token).ownerOf(tokenId) == address(this),\\r\\n        \\\"withdrawNFTWithSignature: Not enough ERC721 tokens in reserve to withdraw\\\"\\r\\n      );\\r\\n\\r\\n      IERC721(token).safeTransferFrom(address(this), recipient, tokenId);\\r\\n    } else {\\r\\n      require(\\r\\n        amount <= IERC1155(token).balanceOf(address(this), tokenId),\\r\\n        \\\"withdrawNFTWithSignature: Not enough ERC1155 tokens in reserve to withdraw\\\"\\r\\n      );\\r\\n\\r\\n      IERC1155(token).safeTransferFrom(\\r\\n        address(this),\\r\\n        recipient,\\r\\n        tokenId,\\r\\n        amount,\\r\\n        \\\"\\\"\\r\\n      );\\r\\n    }\\r\\n\\r\\n    emit WithdrawNFT(token, tokenId, amount, recipient, msg.sender);\\r\\n  }\\r\\n\\r\\n  /// INTERNAL FUNCTIONS\\r\\n\\r\\n  /// @notice Helper function to deposit ETH\\r\\n  function depositToReserve(uint256 amount, uint256 taxToTake) internal {\\r\\n    if (taxToTake > 0) {\\r\\n      uint256 taxes = (amount * taxToTake) / 10000;\\r\\n      contributionsBalance += taxes;\\r\\n      amount -= taxes;\\r\\n      emit Contribution(taxes, msg.sender);\\r\\n    }\\r\\n\\r\\n    reserveBalance += amount;\\r\\n\\r\\n    emit Deposit(amount, msg.sender);\\r\\n  }\\r\\n\\r\\n  function _handleSignature(bytes32 hash, bytes memory signature) internal {\\r\\n    require(\\r\\n      _verifyHashSignature(hash, signature),\\r\\n      \\\"handleSignature: Invalid signature\\\"\\r\\n    );\\r\\n\\r\\n    require(\\r\\n      !usedSignatures[signature],\\r\\n      \\\"handleSignature: Signature already used\\\"\\r\\n    );\\r\\n\\r\\n    usedSignatures[signature] = true;\\r\\n  }\\r\\n\\r\\n  /// @notice Function to deposit ETH and distribute it to recipients\\r\\n  /// @param amounts Amounts of ETH to handle\\r\\n  /// @param recipients Addresses to handle ETH for\\r\\n  /// @param isDistribute Whether to distribute (true) or send (false)\\r\\n  function _handleFunds(\\r\\n    uint256[] memory amounts,\\r\\n    address[] memory recipients,\\r\\n    bool isDistribute,\\r\\n    uint256 taxToTake,\\r\\n    bool fromContributions\\r\\n  ) internal {\\r\\n    require(\\r\\n      amounts.length == recipients.length,\\r\\n      \\\"handleFunds: Arrays must have the same length\\\"\\r\\n    );\\r\\n\\r\\n    if (msg.value > 0) {\\r\\n      depositToReserve(msg.value, taxToTake);\\r\\n    }\\r\\n\\r\\n    uint256 totalAmount;\\r\\n\\r\\n    for (uint256 i = 0; i < amounts.length; i++) {\\r\\n      uint256 amount = amounts[i];\\r\\n      totalAmount += amount;\\r\\n\\r\\n      if (isDistribute) {\\r\\n        ethBalance[recipients[i]] += amount;\\r\\n      } else {\\r\\n        payable(recipients[i]).transfer(amount);\\r\\n      }\\r\\n    }\\r\\n\\r\\n    if (fromContributions) {\\r\\n      require(\\r\\n        totalAmount <= contributionsBalance,\\r\\n        \\\"handleFunds: Not enough ETH in contributions balance\\\"\\r\\n      );\\r\\n\\r\\n      contributionsBalance -= totalAmount;\\r\\n    } else {\\r\\n      require(\\r\\n        totalAmount <= reserveBalance,\\r\\n        \\\"handleFunds: Not enough ETH in reserve balance\\\"\\r\\n      );\\r\\n\\r\\n      reserveBalance -= totalAmount;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /// OWNER FUNCTIONS\\r\\n\\r\\n  /// @notice Function to set a new signer\\r\\n  /// @param newSigner: Address of the new signer\\r\\n  /// @dev Only the owner can set a new signer\\r\\n  function setSigner(address newSigner) external onlyOwner {\\r\\n    require(newSigner != address(0), \\\"Invalid address\\\");\\r\\n    secret = newSigner;\\r\\n\\r\\n    emit SetSigner(newSigner);\\r\\n  }\\r\\n\\r\\n  /// @notice Function to set a new allowed wallet\\r\\n  /// @param wallet: Address of the new allowed wallet\\r\\n  /// @param allowed: Boolean to set if the wallet is allowed or not\\r\\n  /// @dev Only the owner can set a new allowed wallet\\r\\n  function setAllowed(address wallet, bool allowed) external onlyOwner {\\r\\n    require(wallet != address(0), \\\"Invalid address\\\");\\r\\n    isAllowed[wallet] = allowed;\\r\\n\\r\\n    emit SetAllowed(wallet, allowed);\\r\\n  }\\r\\n\\r\\n  /// @notice Function to set the taxes percentage\\r\\n  /// @param _taxesPerc: New taxes percentage\\r\\n  /// @dev Only the owner can set the taxes percentage\\r\\n  function setTaxesPerc(uint256 _taxesPerc) external onlyOwner {\\r\\n    require(_taxesPerc <= 10000, \\\"setTaxesPerc: Taxes percentage too high\\\");\\r\\n\\r\\n    taxesPerc = _taxesPerc;\\r\\n\\r\\n    emit SetTaxesPerc(_taxesPerc);\\r\\n  }\\r\\n\\r\\n  /// @notice Mark a signature as used without withdrawing anything\\r\\n  /// @param signature Signature to use\\r\\n  function useSignature(bytes memory signature) external nonReentrant {\\r\\n    require(!usedSignatures[signature], \\\"useSignature: Signature already used\\\");\\r\\n\\r\\n    usedSignatures[signature] = true;\\r\\n\\r\\n    emit UseSignature(signature);\\r\\n  }\\r\\n\\r\\n  /// @notice Unassign ETH from a recipient\\r\\n  /// @param amount Amount of ETH to unassign\\r\\n  /// @param recipient Address to unassign ETH from\\r\\n  function unassignETH(uint256 amount, address recipient) external onlyOwner {\\r\\n    require(\\r\\n      ethBalance[recipient] >= amount,\\r\\n      \\\"unassignETH: Not enough ETH in recipient balance\\\"\\r\\n    );\\r\\n\\r\\n    ethBalance[recipient] -= amount;\\r\\n\\r\\n    reserveBalance += amount;\\r\\n\\r\\n    emit UnassignETH(amount, recipient);\\r\\n  }\\r\\n\\r\\n  /// EMERGENCY FUNCTIONS\\r\\n\\r\\n  /// @notice Emergency function to withdraw ETH\\r\\n  function emergencyWithdrawETH() external onlyOwner {\\r\\n    uint256 contractBalance = address(this).balance;\\r\\n\\r\\n    payable(msg.sender).transfer(reserveBalance);\\r\\n\\r\\n    emit WithdrawETH(contractBalance, msg.sender, msg.sender);\\r\\n  }\\r\\n\\r\\n  /// @notice Emergency function to withdraw ERC20 tokens\\r\\n  /// @param token Address of the ERC20 token\\r\\n  function emergencyWithdrawERC20(address token) external onlyOwner {\\r\\n    uint256 contractBalance = IERC20(token).balanceOf(address(this));\\r\\n\\r\\n    require(\\r\\n      contractBalance > 0,\\r\\n      \\\"emergencyWithdrawERC20: No tokens to withdraw\\\"\\r\\n    );\\r\\n\\r\\n    IERC20(token).transfer(msg.sender, contractBalance);\\r\\n\\r\\n    emit WithdrawERC20(token, contractBalance, msg.sender, msg.sender);\\r\\n  }\\r\\n\\r\\n  /// @notice Emergency function to withdraw ERC721 or ERC1155 tokens\\r\\n  /// @param token Address of the ERC721 or ERC1155 token\\r\\n  /// @param tokenId Id of the ERC721 or ERC1155 token\\r\\n  /// @param amount Amount of ERC1155 token to withdraw (ERC721 = 0, amount not required)\\r\\n  function emergencyWithdrawNFT(\\r\\n    address token,\\r\\n    uint256 tokenId,\\r\\n    uint256 amount\\r\\n  ) external onlyOwner {\\r\\n    if (amount == 0) {\\r\\n      IERC721(token).safeTransferFrom(address(this), msg.sender, tokenId);\\r\\n    } else {\\r\\n      IERC1155(token).safeTransferFrom(\\r\\n        address(this),\\r\\n        msg.sender,\\r\\n        tokenId,\\r\\n        amount,\\r\\n        \\\"\\\"\\r\\n      );\\r\\n    }\\r\\n\\r\\n    emit WithdrawNFT(token, tokenId, amount, msg.sender, msg.sender);\\r\\n  }\\r\\n\\r\\n  /// @notice Internal function to check if a signature is valid\\r\\n  /// @param freshHash: Hash to check\\r\\n  /// @param signature: Signature to check\\r\\n  function _verifyHashSignature(\\r\\n    bytes32 freshHash,\\r\\n    bytes memory signature\\r\\n  ) internal view returns (bool) {\\r\\n    bytes32 hash = keccak256(\\r\\n      abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", freshHash)\\r\\n    );\\r\\n\\r\\n    bytes32 r;\\r\\n    bytes32 s;\\r\\n    uint8 v;\\r\\n\\r\\n    if (signature.length != 65) {\\r\\n      return false;\\r\\n    }\\r\\n    assembly {\\r\\n      r := mload(add(signature, 32))\\r\\n      s := mload(add(signature, 64))\\r\\n      v := byte(0, mload(add(signature, 96)))\\r\\n    }\\r\\n\\r\\n    if (v < 27) {\\r\\n      v += 27;\\r\\n    }\\r\\n\\r\\n    address signer = address(0);\\r\\n    if (v == 27 || v == 28) {\\r\\n      // solium-disable-next-line arg-overflow\\r\\n      signer = ecrecover(hash, v, r, s);\\r\\n    }\\r\\n    return secret == signer;\\r\\n  }\\r\\n\\r\\n  // TODO: if we want to support ERC721, we need to implement this function\\r\\n  function onERC721Received(\\r\\n    address,\\r\\n    address,\\r\\n    uint256,\\r\\n    bytes memory\\r\\n  ) external virtual override returns (bytes4) {\\r\\n    return this.onERC721Received.selector;\\r\\n  }\\r\\n}\\r\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/utils/ERC1155Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC1155Receiver.sol\\\";\\nimport \\\"../../../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev _Available since v3.1._\\n */\\nabstract contract ERC1155Receiver is ERC165, IERC1155Receiver {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\\n        return interfaceId == type(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/utils/ERC1155Holder.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ERC1155Receiver.sol\\\";\\n\\n/**\\n * Simple implementation of `ERC1155Receiver` that will allow a contract to hold ERC1155 tokens.\\n *\\n * IMPORTANT: When inheriting this contract, you must include a way to use the received tokens, otherwise they will be\\n * stuck.\\n *\\n * @dev _Available since v3.1._\\n */\\ncontract ERC1155Holder is ERC1155Receiver {\\n    function onERC1155Received(\\n        address,\\n        address,\\n        uint256,\\n        uint256,\\n        bytes memory\\n    ) public virtual override returns (bytes4) {\\n        return this.onERC1155Received.selector;\\n    }\\n\\n    function onERC1155BatchReceived(\\n        address,\\n        address,\\n        uint256[] memory,\\n        uint256[] memory,\\n        bytes memory\\n    ) public virtual override returns (bytes4) {\\n        return this.onERC1155BatchReceived.selector;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev _Available since v3.1._\\n */\\ninterface IERC1155Receiver is IERC165 {\\n    /**\\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\\n     *\\n     * NOTE: To accept the transfer, this must return\\n     * `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\n     * (i.e. 0xf23a6e61, or its own function selector).\\n     *\\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\\n     * @param from The address which previously owned the token\\n     * @param id The ID of the token being transferred\\n     * @param value The amount of tokens being transferred\\n     * @param data Additional data with no specified format\\n     * @return `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))` if transfer is allowed\\n     */\\n    function onERC1155Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        uint256 value,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n\\n    /**\\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\\n     * been updated.\\n     *\\n     * NOTE: To accept the transfer(s), this must return\\n     * `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\n     * (i.e. 0xbc197c81, or its own function selector).\\n     *\\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\\n     * @param from The address which previously owned the token\\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\\n     * @param data Additional data with no specified format\\n     * @return `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))` if transfer is allowed\\n     */\\n    function onERC1155BatchReceived(\\n        address operator,\\n        address from,\\n        uint256[] calldata ids,\\n        uint256[] calldata values,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC1155/IERC1155.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155 is IERC165 {\\n    /**\\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\\n     */\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n    /**\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n     * transfers.\\n     */\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] values\\n    );\\n\\n    /**\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\n     * `approved`.\\n     */\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\n     *\\n     * If an {URI} event was emitted for `id`, the standard\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\n     * returned by {IERC1155MetadataURI-uri}.\\n     */\\n    event URI(string value, uint256 indexed id);\\n\\n    /**\\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(\\n        address[] calldata accounts,\\n        uint256[] calldata ids\\n    ) external view returns (uint256[] memory);\\n\\n    /**\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `operator` cannot be the caller.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Returns true if the reentrancy guard is currently set to \\\"entered\\\", which indicates there is a\\n     * `nonReentrant` function in the call stack.\\n     */\\n    function _reentrancyGuardEntered() internal view returns (bool) {\\n        return _status == _ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"Contribution\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"recipients\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"Distribute\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"recipients\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"SendETH\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"allowed\",\"type\":\"bool\"}],\"name\":\"SetAllowed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"}],\"name\":\"SetSigner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"taxesPerc\",\"type\":\"uint256\"}],\"name\":\"SetTaxesPerc\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"UnassignETH\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"UseSignature\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"WithdrawERC20\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"WithdrawETH\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"WithdrawNFT\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"contributionsBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"recipients\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"taxToTake\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"fromContributions\",\"type\":\"bool\"}],\"name\":\"distribute\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"emergencyWithdrawERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emergencyWithdrawETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"emergencyWithdrawNFT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"ethBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isAllowed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155BatchReceived\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reserveBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"secret\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"recipients\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"taxToTake\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"fromContributions\",\"type\":\"bool\"}],\"name\":\"sendFunds\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"allowed\",\"type\":\"bool\"}],\"name\":\"setAllowed\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newSigner\",\"type\":\"address\"}],\"name\":\"setSigner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_taxesPerc\",\"type\":\"uint256\"}],\"name\":\"setTaxesPerc\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"taxesPerc\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"unassignETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"useSignature\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"usedSignatures\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"checkId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"withdrawERC20WithSignature\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"withdrawETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"checkId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"withdrawETHWithSignature\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"checkId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"withdrawNFTWithSignature\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "PaymentSender", "CompilerVersion": "v0.8.12+commit.f00d7308", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "london", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}