{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"error/errorMirror.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\nimport \\\"error/DN404mirror.sol\\\";\\r\\n\\r\\ncontract errorMirror is DN404Mirror  {\\r\\n    constructor() DN404Mirror(tx.origin) {}\\r\\n}\"\r\n    },\r\n    \"error/DN404mirror.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\n/// @dev Note:\\r\\n/// - The ERC721 data is stored in the base DN404 contract.\\r\\ncontract DN404Mirror {\\r\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\r\\n    /*                           EVENTS                           */\\r\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\r\\n\\r\\n    /// @dev Emitted when token `id` is transferred from `from` to `to`.\\r\\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\\r\\n\\r\\n    /// @dev Emitted when `owner` enables `account` to manage the `id` token.\\r\\n    event Approval(address indexed owner, address indexed account, uint256 indexed id);\\r\\n\\r\\n    /// @dev Emitted when `owner` enables or disables `operator` to manage all of their tokens.\\r\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool isApproved);\\r\\n\\r\\n    /// @dev `keccak256(bytes(\\\"Transfer(address,address,uint256)\\\"))`.\\r\\n    uint256 private constant _TRANSFER_EVENT_SIGNATURE =\\r\\n        0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef;\\r\\n\\r\\n    /// @dev `keccak256(bytes(\\\"Approval(address,address,uint256)\\\"))`.\\r\\n    uint256 private constant _APPROVAL_EVENT_SIGNATURE =\\r\\n        0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925;\\r\\n\\r\\n    /// @dev `keccak256(bytes(\\\"ApprovalForAll(address,address,bool)\\\"))`.\\r\\n    uint256 private constant _APPROVAL_FOR_ALL_EVENT_SIGNATURE =\\r\\n        0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31;\\r\\n\\r\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\r\\n    /*                        CUSTOM ERRORS                       */\\r\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\r\\n\\r\\n    /// @dev Thrown when a call for an NFT function did not originate\\r\\n    /// from the base DN404 contract.\\r\\n    error SenderNotBase();\\r\\n\\r\\n    /// @dev Thrown when a call for an NFT function did not originate from the deployer.\\r\\n    error SenderNotDeployer();\\r\\n\\r\\n    /// @dev Thrown when transferring an NFT to a contract address that\\r\\n    /// does not implement ERC721Receiver.\\r\\n    error TransferToNonERC721ReceiverImplementer();\\r\\n\\r\\n    /// @dev Thrown when linking to the DN404 base contract and the\\r\\n    /// DN404 supportsInterface check fails or the call reverts.\\r\\n    error CannotLink();\\r\\n\\r\\n    /// @dev Thrown when a linkMirrorContract call is received and the\\r\\n    /// NFT mirror contract has already been linked to a DN404 base contract.\\r\\n    error AlreadyLinked();\\r\\n\\r\\n    /// @dev Thrown when retrieving the base DN404 address when a link has not\\r\\n    /// been established.\\r\\n    error NotLinked();\\r\\n\\r\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\r\\n    /*                          STORAGE                           */\\r\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\r\\n\\r\\n    /// @dev Struct contain the NFT mirror contract storage.\\r\\n    struct DN404NFTStorage {\\r\\n        address baseERC20;\\r\\n        address deployer;\\r\\n    }\\r\\n\\r\\n    /// @dev Returns a storage pointer for DN404NFTStorage.\\r\\n    function _getDN404NFTStorage() internal pure virtual returns (DN404NFTStorage storage $) {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            // `uint72(bytes9(keccak256(\\\"DN404_MIRROR_STORAGE\\\")))`.\\r\\n            $.slot := 0x3602298b8c10b01230 // Truncate to 9 bytes to reduce bytecode size.\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\r\\n    /*                        CONSTRUCTOR                         */\\r\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\r\\n\\r\\n    constructor(address deployer) {\\r\\n        // For non-proxies, we will store the deployer so that only the deployer can\\r\\n        // link the base contract.\\r\\n        _getDN404NFTStorage().deployer = deployer;\\r\\n    }\\r\\n\\r\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\r\\n    /*                     ERC721 OPERATIONS                      */\\r\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\r\\n\\r\\n    /// @dev Returns the token collection name from the base DN404 contract.\\r\\n    function name() public view virtual returns (string memory result) {\\r\\n        address base = baseERC20();\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            result := mload(0x40)\\r\\n            mstore(0x00, 0x06fdde03) // `name()`.\\r\\n            if iszero(staticcall(gas(), base, 0x1c, 0x04, 0x00, 0x00)) {\\r\\n                returndatacopy(result, 0x00, returndatasize())\\r\\n                revert(result, returndatasize())\\r\\n            }\\r\\n            returndatacopy(0x00, 0x00, 0x20)\\r\\n            returndatacopy(result, mload(0x00), 0x20)\\r\\n            returndatacopy(add(result, 0x20), add(mload(0x00), 0x20), mload(result))\\r\\n            mstore(0x40, add(add(result, 0x20), mload(result)))\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns the token collection symbol from the base DN404 contract.\\r\\n    function symbol() public view virtual returns (string memory result) {\\r\\n        address base = baseERC20();\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            result := mload(0x40)\\r\\n            mstore(0x00, 0x95d89b41) // `symbol()`.\\r\\n            if iszero(staticcall(gas(), base, 0x1c, 0x04, 0x00, 0x00)) {\\r\\n                returndatacopy(result, 0x00, returndatasize())\\r\\n                revert(result, returndatasize())\\r\\n            }\\r\\n            returndatacopy(0x00, 0x00, 0x20)\\r\\n            returndatacopy(result, mload(0x00), 0x20)\\r\\n            returndatacopy(add(result, 0x20), add(mload(0x00), 0x20), mload(result))\\r\\n            mstore(0x40, add(add(result, 0x20), mload(result)))\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns the Uniform Resource Identifier (URI) for token `id` from\\r\\n    /// the base DN404 contract.\\r\\n    function tokenURI(uint256 id) public view virtual returns (string memory result) {\\r\\n        address base = baseERC20();\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            result := mload(0x40)\\r\\n            mstore(0x20, id)\\r\\n            mstore(0x00, 0xc87b56dd) // `tokenURI()`.\\r\\n            if iszero(staticcall(gas(), base, 0x1c, 0x24, 0x00, 0x00)) {\\r\\n                returndatacopy(result, 0x00, returndatasize())\\r\\n                revert(result, returndatasize())\\r\\n            }\\r\\n            returndatacopy(0x00, 0x00, 0x20)\\r\\n            returndatacopy(result, mload(0x00), 0x20)\\r\\n            returndatacopy(add(result, 0x20), add(mload(0x00), 0x20), mload(result))\\r\\n            mstore(0x40, add(add(result, 0x20), mload(result)))\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns the total NFT supply from the base DN404 contract.\\r\\n    function totalSupply() public view virtual returns (uint256 result) {\\r\\n        address base = baseERC20();\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            mstore(0x00, 0xe2c79281) // `totalNFTSupply()`.\\r\\n            if iszero(\\r\\n                and(gt(returndatasize(), 0x1f), staticcall(gas(), base, 0x1c, 0x04, 0x00, 0x20))\\r\\n            ) {\\r\\n                returndatacopy(mload(0x40), 0x00, returndatasize())\\r\\n                revert(mload(0x40), returndatasize())\\r\\n            }\\r\\n            result := mload(0x00)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns the number of NFT tokens owned by `owner` from the base DN404 contract.\\r\\n    ///\\r\\n    /// Requirements:\\r\\n    /// - `owner` must not be the zero address.\\r\\n    function balanceOf(address owner) public view virtual returns (uint256 result) {\\r\\n        address base = baseERC20();\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            mstore(0x20, shr(96, shl(96, owner)))\\r\\n            mstore(0x00, 0xf5b100ea) // `balanceOfNFT(address)`.\\r\\n            if iszero(\\r\\n                and(gt(returndatasize(), 0x1f), staticcall(gas(), base, 0x1c, 0x24, 0x00, 0x20))\\r\\n            ) {\\r\\n                returndatacopy(mload(0x40), 0x00, returndatasize())\\r\\n                revert(mload(0x40), returndatasize())\\r\\n            }\\r\\n            result := mload(0x00)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns the owner of token `id` from the base DN404 contract.\\r\\n    ///\\r\\n    /// Requirements:\\r\\n    /// - Token `id` must exist.\\r\\n    function ownerOf(uint256 id) public view virtual returns (address result) {\\r\\n        address base = baseERC20();\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            mstore(0x00, 0x6352211e) // `ownerOf(uint256)`.\\r\\n            mstore(0x20, id)\\r\\n            if iszero(\\r\\n                and(gt(returndatasize(), 0x1f), staticcall(gas(), base, 0x1c, 0x24, 0x00, 0x20))\\r\\n            ) {\\r\\n                returndatacopy(mload(0x40), 0x00, returndatasize())\\r\\n                revert(mload(0x40), returndatasize())\\r\\n            }\\r\\n            result := shr(96, mload(0x0c))\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Sets `spender` as the approved account to manage token `id` in\\r\\n    /// the base DN404 contract.\\r\\n    ///\\r\\n    /// Requirements:\\r\\n    /// - Token `id` must exist.\\r\\n    /// - The caller must be the owner of the token,\\r\\n    ///   or an approved operator for the token owner.\\r\\n    ///\\r\\n    /// Emits an {Approval} event.\\r\\n    function approve(address spender, uint256 id) public virtual {\\r\\n        address base = baseERC20();\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            spender := shr(96, shl(96, spender))\\r\\n            let m := mload(0x40)\\r\\n            mstore(0x00, 0xd10b6e0c) // `approveNFT(address,uint256,address)`.\\r\\n            mstore(0x20, spender)\\r\\n            mstore(0x40, id)\\r\\n            mstore(0x60, caller())\\r\\n            if iszero(\\r\\n                and(\\r\\n                    gt(returndatasize(), 0x1f),\\r\\n                    call(gas(), base, callvalue(), 0x1c, 0x64, 0x00, 0x20)\\r\\n                )\\r\\n            ) {\\r\\n                returndatacopy(m, 0x00, returndatasize())\\r\\n                revert(m, returndatasize())\\r\\n            }\\r\\n            mstore(0x40, m) // Restore the free memory pointer.\\r\\n            mstore(0x60, 0) // Restore the zero pointer.\\r\\n            // Emit the {Approval} event.\\r\\n            log4(codesize(), 0x00, _APPROVAL_EVENT_SIGNATURE, shr(96, mload(0x0c)), spender, id)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns the account approved to manage token `id` from\\r\\n    /// the base DN404 contract.\\r\\n    ///\\r\\n    /// Requirements:\\r\\n    /// - Token `id` must exist.\\r\\n    function getApproved(uint256 id) public view virtual returns (address result) {\\r\\n        address base = baseERC20();\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            mstore(0x00, 0x081812fc) // `getApproved(uint256)`.\\r\\n            mstore(0x20, id)\\r\\n            if iszero(\\r\\n                and(gt(returndatasize(), 0x1f), staticcall(gas(), base, 0x1c, 0x24, 0x00, 0x20))\\r\\n            ) {\\r\\n                returndatacopy(mload(0x40), 0x00, returndatasize())\\r\\n                revert(mload(0x40), returndatasize())\\r\\n            }\\r\\n            result := shr(96, mload(0x0c))\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Sets whether `operator` is approved to manage the tokens of the caller in\\r\\n    /// the base DN404 contract.\\r\\n    ///\\r\\n    /// Emits an {ApprovalForAll} event.\\r\\n    function setApprovalForAll(address operator, bool approved) public virtual {\\r\\n        address base = baseERC20();\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            operator := shr(96, shl(96, operator))\\r\\n            let m := mload(0x40)\\r\\n            mstore(0x00, 0x813500fc) // `setApprovalForAll(address,bool,address)`.\\r\\n            mstore(0x20, operator)\\r\\n            mstore(0x40, iszero(iszero(approved)))\\r\\n            mstore(0x60, caller())\\r\\n            if iszero(\\r\\n                and(eq(mload(0x00), 1), call(gas(), base, callvalue(), 0x1c, 0x64, 0x00, 0x20))\\r\\n            ) {\\r\\n                returndatacopy(m, 0x00, returndatasize())\\r\\n                revert(m, returndatasize())\\r\\n            }\\r\\n            // Emit the {ApprovalForAll} event.\\r\\n            log3(0x40, 0x20, _APPROVAL_FOR_ALL_EVENT_SIGNATURE, caller(), operator)\\r\\n            mstore(0x40, m) // Restore the free memory pointer.\\r\\n            mstore(0x60, 0) // Restore the zero pointer.\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns whether `operator` is approved to manage the tokens of `owner` from\\r\\n    /// the base DN404 contract.\\r\\n    function isApprovedForAll(address owner, address operator)\\r\\n        public\\r\\n        view\\r\\n        virtual\\r\\n        returns (bool result)\\r\\n    {\\r\\n        address base = baseERC20();\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            let m := mload(0x40)\\r\\n            mstore(0x40, operator)\\r\\n            mstore(0x2c, shl(96, owner))\\r\\n            mstore(0x0c, 0xe985e9c5000000000000000000000000) // `isApprovedForAll(address,address)`.\\r\\n            if iszero(\\r\\n                and(gt(returndatasize(), 0x1f), staticcall(gas(), base, 0x1c, 0x44, 0x00, 0x20))\\r\\n            ) {\\r\\n                returndatacopy(m, 0x00, returndatasize())\\r\\n                revert(m, returndatasize())\\r\\n            }\\r\\n            mstore(0x40, m) // Restore the free memory pointer.\\r\\n            result := iszero(iszero(mload(0x00)))\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Transfers token `id` from `from` to `to`.\\r\\n    ///\\r\\n    /// Requirements:\\r\\n    ///\\r\\n    /// - Token `id` must exist.\\r\\n    /// - `from` must be the owner of the token.\\r\\n    /// - `to` cannot be the zero address.\\r\\n    /// - The caller must be the owner of the token, or be approved to manage the token.\\r\\n    ///\\r\\n    /// Emits a {Transfer} event.\\r\\n    function transferFrom(address from, address to, uint256 id) public virtual {\\r\\n        address base = baseERC20();\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            from := shr(96, shl(96, from))\\r\\n            to := shr(96, shl(96, to))\\r\\n            let m := mload(0x40)\\r\\n            mstore(m, 0xe5eb36c8) // `transferFromNFT(address,address,uint256,address)`.\\r\\n            mstore(add(m, 0x20), from)\\r\\n            mstore(add(m, 0x40), to)\\r\\n            mstore(add(m, 0x60), id)\\r\\n            mstore(add(m, 0x80), caller())\\r\\n            if iszero(\\r\\n                and(eq(mload(m), 1), call(gas(), base, callvalue(), add(m, 0x1c), 0x84, m, 0x20))\\r\\n            ) {\\r\\n                returndatacopy(m, 0x00, returndatasize())\\r\\n                revert(m, returndatasize())\\r\\n            }\\r\\n            // Emit the {Transfer} event.\\r\\n            log4(codesize(), 0x00, _TRANSFER_EVENT_SIGNATURE, from, to, id)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Equivalent to `safeTransferFrom(from, to, id, \\\"\\\")`.\\r\\n    function safeTransferFrom(address from, address to, uint256 id) public payable virtual {\\r\\n        transferFrom(from, to, id);\\r\\n\\r\\n        if (_hasCode(to)) _checkOnERC721Received(from, to, id, \\\"\\\");\\r\\n    }\\r\\n\\r\\n    /// @dev Transfers token `id` from `from` to `to`.\\r\\n    ///\\r\\n    /// Requirements:\\r\\n    ///\\r\\n    /// - Token `id` must exist.\\r\\n    /// - `from` must be the owner of the token.\\r\\n    /// - `to` cannot be the zero address.\\r\\n    /// - The caller must be the owner of the token, or be approved to manage the token.\\r\\n    /// - If `to` refers to a smart contract, it must implement\\r\\n    ///   {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\r\\n    ///\\r\\n    /// Emits a {Transfer} event.\\r\\n    function safeTransferFrom(address from, address to, uint256 id, bytes calldata data)\\r\\n        public\\r\\n        virtual\\r\\n    {\\r\\n        transferFrom(from, to, id);\\r\\n\\r\\n        if (_hasCode(to)) _checkOnERC721Received(from, to, id, data);\\r\\n    }\\r\\n\\r\\n    /// @dev Returns true if this contract implements the interface defined by `interfaceId`.\\r\\n    /// See: https://eips.ethereum.org/EIPS/eip-165\\r\\n    /// This function call must use less than 30000 gas.\\r\\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool result) {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            let s := shr(224, interfaceId)\\r\\n            // ERC165: 0x01ffc9a7, ERC721: 0x80ac58cd, ERC721Metadata: 0x5b5e139f.\\r\\n            result := or(or(eq(s, 0x01ffc9a7), eq(s, 0x80ac58cd)), eq(s, 0x5b5e139f))\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\r\\n    /*                     MIRROR OPERATIONS                      */\\r\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\r\\n\\r\\n    /// @dev Returns the address of the base DN404 contract.\\r\\n    function baseERC20() public view virtual returns (address base) {\\r\\n        base = _getDN404NFTStorage().baseERC20;\\r\\n        if (base == address(0)) revert NotLinked();\\r\\n    }\\r\\n\\r\\n    /// @dev Fallback modifier to execute calls from the base DN404 contract.\\r\\n    modifier DN404NFTFallback() virtual {\\r\\n        DN404NFTStorage storage $ = _getDN404NFTStorage();\\r\\n\\r\\n        uint256 fnSelector = _calldataload(0x00) >> 224;\\r\\n\\r\\n        // `logTransfer(uint256[])`.\\r\\n        if (fnSelector == 0x263c69d6) {\\r\\n            if (msg.sender != $.baseERC20) revert SenderNotBase();\\r\\n            /// @solidity memory-safe-assembly\\r\\n            assembly {\\r\\n                // When returndatacopy copies 1 or more out-of-bounds bytes, it reverts.\\r\\n                returndatacopy(0x00, returndatasize(), lt(calldatasize(), 0x20))\\r\\n                let o := add(0x24, calldataload(0x04)) // Packed logs offset.\\r\\n                returndatacopy(0x00, returndatasize(), lt(calldatasize(), o))\\r\\n                let end := add(o, shl(5, calldataload(sub(o, 0x20))))\\r\\n                returndatacopy(0x00, returndatasize(), lt(calldatasize(), end))\\r\\n\\r\\n                for {} iszero(eq(o, end)) { o := add(0x20, o) } {\\r\\n                    let d := calldataload(o) // Entry in the packed logs.\\r\\n                    let a := shr(96, d) // The address.\\r\\n                    let b := and(1, d) // Whether it is a burn.\\r\\n                    log4(\\r\\n                        codesize(),\\r\\n                        0x00,\\r\\n                        _TRANSFER_EVENT_SIGNATURE,\\r\\n                        mul(a, b),\\r\\n                        mul(a, iszero(b)),\\r\\n                        shr(168, shl(160, d))\\r\\n                    )\\r\\n                }\\r\\n                mstore(0x00, 0x01)\\r\\n                return(0x00, 0x20)\\r\\n            }\\r\\n        }\\r\\n        // `linkMirrorContract(address)`.\\r\\n        if (fnSelector == 0x0f4599e5) {\\r\\n            if ($.deployer != address(0)) {\\r\\n                if (address(uint160(_calldataload(0x04))) != $.deployer) {\\r\\n                    revert SenderNotDeployer();\\r\\n                }\\r\\n            }\\r\\n            if ($.baseERC20 != address(0)) revert AlreadyLinked();\\r\\n            $.baseERC20 = msg.sender;\\r\\n            /// @solidity memory-safe-assembly\\r\\n            assembly {\\r\\n                mstore(0x00, 0x01)\\r\\n                return(0x00, 0x20)\\r\\n            }\\r\\n        }\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /// @dev Fallback function for calls from base DN404 contract.\\r\\n    fallback() external payable virtual DN404NFTFallback {}\\r\\n\\r\\n    receive() external payable virtual {}\\r\\n\\r\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\r\\n    /*                      PRIVATE HELPERS                       */\\r\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\r\\n\\r\\n    /// @dev Returns the calldata value at `offset`.\\r\\n    function _calldataload(uint256 offset) private pure returns (uint256 value) {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            value := calldataload(offset)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns if `a` has bytecode of non-zero length.\\r\\n    function _hasCode(address a) private view returns (bool result) {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            result := extcodesize(a) // Can handle dirty upper bits.\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Perform a call to invoke {IERC721Receiver-onERC721Received} on `to`.\\r\\n    /// Reverts if the target does not support the function correctly.\\r\\n    function _checkOnERC721Received(address from, address to, uint256 id, bytes memory data)\\r\\n        private\\r\\n    {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            // Prepare the calldata.\\r\\n            let m := mload(0x40)\\r\\n            let onERC721ReceivedSelector := 0x150b7a02\\r\\n            mstore(m, onERC721ReceivedSelector)\\r\\n            mstore(add(m, 0x20), caller()) // The `operator`, which is always `msg.sender`.\\r\\n            mstore(add(m, 0x40), shr(96, shl(96, from)))\\r\\n            mstore(add(m, 0x60), id)\\r\\n            mstore(add(m, 0x80), 0x80)\\r\\n            let n := mload(data)\\r\\n            mstore(add(m, 0xa0), n)\\r\\n            if n { pop(staticcall(gas(), 4, add(data, 0x20), n, add(m, 0xc0), n)) }\\r\\n            // Revert if the call reverts.\\r\\n            if iszero(call(gas(), to, 0, add(m, 0x1c), add(n, 0xa4), m, 0x20)) {\\r\\n                if returndatasize() {\\r\\n                    // Bubble up the revert if the call reverts.\\r\\n                    returndatacopy(m, 0x00, returndatasize())\\r\\n                    revert(m, returndatasize())\\r\\n                }\\r\\n            }\\r\\n            // Load the returndata and compare it.\\r\\n            if iszero(eq(mload(m), shl(224, onERC721ReceivedSelector))) {\\r\\n                mstore(0x00, 0xd1a57ed6) // `TransferToNonERC721ReceiverImplementer()`.\\r\\n                revert(0x1c, 0x04)\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AlreadyLinked\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CannotLink\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotLinked\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SenderNotBase\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SenderNotDeployer\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferToNonERC721ReceiverImplementer\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isApproved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseERC20\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"base\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"result\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"result\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"result\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"result\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"result\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"result\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"result\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "errorMirror", "CompilerVersion": "v0.8.24+commit.e11b9ed9", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}