{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/TLCreatorContractFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\nimport {Ownable} from \\\"openzeppelin/access/Ownable.sol\\\";\\nimport {Clones} from \\\"openzeppelin/proxy/Clones.sol\\\";\\n\\n/*//////////////////////////////////////////////////////////////////////////\\n                          InitializableInterface\\n//////////////////////////////////////////////////////////////////////////*/\\ninterface InitializableInterface {\\n    function initialize(\\n        string memory name,\\n        string memory symbol,\\n        address defaultRoyaltyRecipient,\\n        uint256 defaultRoyaltyPercentage,\\n        address initOwner,\\n        address[] memory admins,\\n        bool enableStory,\\n        address blockListRegistry\\n    ) external;\\n}\\n\\n/*//////////////////////////////////////////////////////////////////////////\\n                          TLCreatorContractFactory\\n//////////////////////////////////////////////////////////////////////////*/\\n\\n/// @title TLCreatorContractFactory\\n/// @notice Contract factory for TL creator contracts\\n/// @dev deploys any contract compatible with the InitializableInterface above\\n/// @author transientlabs.xyz\\n/// @custom:version 2.6.2\\ncontract TLCreatorContractFactory is Ownable {\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                    Structs\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    struct ContractType {\\n        string name;\\n        address[] implementations;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                State Variables\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    ContractType[] private _contractTypes;\\n\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                    Events\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /// @dev event emitted whenever a contract type is added\\n    event ContractTypeAdded(uint256 indexed contractTypeId, address indexed firstImplementation, string name);\\n\\n    /// @dev event emitted whenever an implementation is added for a contract type\\n    event ImplementationAdded(uint256 indexed contractTypeId, address indexed implementation);\\n\\n    /// @dev event emitted whenever a contract is deployed\\n    event ContractDeployed(address indexed contractAddress, address indexed implementationAddress, address indexed sender);\\n\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                  Constructor\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    constructor() Ownable() {}\\n\\n    /*//////////////////////////////////////////////////////////////////////////\\n                              Ownership Functions  \\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Function to add a contract type\\n    /// @dev only callable by the factory owner\\n    /// @param name The new contract type name\\n    /// @param implementation The first implementation address to add\\n    function addContractType(string memory name, address implementation) external onlyOwner {\\n        address[] memory implementations = new address[](1);\\n        implementations[0] = implementation;\\n\\n        _contractTypes.push(ContractType(name, implementations));\\n        uint256 contractTypeId = _contractTypes.length - 1;\\n\\n        emit ContractTypeAdded(contractTypeId, implementation, name);\\n    }\\n\\n    /// @notice Function to add an implementation contract for a type\\n    /// @dev only callable by the factory owner\\n    /// @param contractTypeId The contract type id\\n    /// @param implementation The new implementation address to add\\n    function addContractImplementation(uint256 contractTypeId, address implementation) external onlyOwner {\\n        ContractType storage contractType = _contractTypes[contractTypeId];\\n        contractType.implementations.push(implementation);\\n\\n        emit ImplementationAdded(contractTypeId, implementation);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////////////////\\n                           Contract Creation Functions\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Function to deploy the latest implementation contract for a contract type\\n    /// @param contractTypeId The contract type id\\n    /// @param contractName The deployed contract name\\n    /// @param contractSymbol The deployed contract symbol\\n    /// @param defaultRoyaltyRecipient The default royalty recipient\\n    /// @param defaultRoyaltyPercentage The default royalty percentage\\n    /// @param initOwner The initial owner of the deployed contract\\n    /// @param admins The intial admins on the contract\\n    /// @param enableStory The initial state of story inscriptions on the deployed contract\\n    /// @param blockListRegistry The blocklist registry\\n    /// @return contractAddress The deployed contract address\\n    function deployLatestImplementation(\\n        uint256 contractTypeId,\\n        string memory contractName,\\n        string memory contractSymbol,\\n        address defaultRoyaltyRecipient,\\n        uint256 defaultRoyaltyPercentage,\\n        address initOwner,\\n        address[] memory admins,\\n        bool enableStory,\\n        address blockListRegistry\\n    ) external returns (address contractAddress) {\\n        ContractType memory contractType = _contractTypes[contractTypeId];\\n        address implementation = contractType.implementations[contractType.implementations.length - 1];\\n        return _deployContract(\\n            implementation,\\n            contractName,\\n            contractSymbol,\\n            defaultRoyaltyRecipient,\\n            defaultRoyaltyPercentage,\\n            initOwner,\\n            admins,\\n            enableStory,\\n            blockListRegistry\\n        );\\n    }\\n\\n    /// @notice Function to deploy a specific implementation contract for a contract type\\n    /// @param contractTypeId The contract type id\\n    /// @param implementationIndex The index specifying the implementation contract\\n    /// @param contractName The deployed contract name\\n    /// @param contractSymbol The deployed contract symbol\\n    /// @param defaultRoyaltyRecipient The default royalty recipient\\n    /// @param defaultRoyaltyPercentage The default royalty percentage\\n    /// @param initOwner The initial owner of the deployed contract\\n    /// @param admins The intial admins on the contract\\n    /// @param enableStory The initial state of story inscriptions on the deployed contract\\n    /// @param blockListRegistry The blocklist registry\\n    /// @return contractAddress The deployed contract address\\n    function deployImplementation(\\n        uint256 contractTypeId,\\n        uint256 implementationIndex,\\n        string memory contractName,\\n        string memory contractSymbol,\\n        address defaultRoyaltyRecipient,\\n        uint256 defaultRoyaltyPercentage,\\n        address initOwner,\\n        address[] memory admins,\\n        bool enableStory,\\n        address blockListRegistry\\n    ) external returns (address contractAddress) {\\n        ContractType memory contractType = _contractTypes[contractTypeId];\\n        address implementation = contractType.implementations[implementationIndex];\\n        return _deployContract(\\n            implementation,\\n            contractName,\\n            contractSymbol,\\n            defaultRoyaltyRecipient,\\n            defaultRoyaltyPercentage,\\n            initOwner,\\n            admins,\\n            enableStory,\\n            blockListRegistry\\n        );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                View Functions\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Function to get all contract types\\n    /// @return contractTypes A list of contract type structs\\n    function getContractTypes() external view returns (ContractType[] memory contractTypes) {\\n        return _contractTypes;\\n    }\\n\\n    /// @notice Function to get contract type info by id\\n    /// @param contractTypeId The contract type id\\n    /// @return contractType A contract type struct\\n    function getContractType(uint256 contractTypeId) external view returns (ContractType memory contractType) {\\n        return _contractTypes[contractTypeId];\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////////////////\\n                               Internal Functions\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Internal function to deploy a contract\\n    /// @param implementation The implementation address\\n    /// @param contractName The deployed contract name\\n    /// @param contractSymbol The deployed contract symbol\\n    /// @param defaultRoyaltyRecipient The default royalty recipient\\n    /// @param defaultRoyaltyPercentage The default royalty percentage\\n    /// @param initOwner The initial owner of the deployed contract\\n    /// @param admins The intial admins on the contract\\n    /// @param enableStory The initial state of story inscriptions on the deployed contract\\n    /// @param blockListRegistry The blocklist registry\\n    /// @return contractAddress The deployed contract address\\n    function _deployContract(\\n        address implementation,\\n        string memory contractName,\\n        string memory contractSymbol,\\n        address defaultRoyaltyRecipient,\\n        uint256 defaultRoyaltyPercentage,\\n        address initOwner,\\n        address[] memory admins,\\n        bool enableStory,\\n        address blockListRegistry\\n    ) private returns (address contractAddress) {\\n        contractAddress = Clones.clone(implementation);\\n        InitializableInterface(contractAddress).initialize(\\n            contractName,\\n            contractSymbol,\\n            defaultRoyaltyRecipient,\\n            defaultRoyaltyPercentage,\\n            initOwner,\\n            admins,\\n            enableStory,\\n            blockListRegistry\\n        );\\n\\n        emit ContractDeployed(contractAddress, implementation, msg.sender);\\n\\n        return contractAddress;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/proxy/Clones.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (proxy/Clones.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\\n * deploying minimal proxy contracts, also known as \\\"clones\\\".\\n *\\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\\n *\\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\\n * deterministic method.\\n *\\n * _Available since v3.4._\\n */\\nlibrary Clones {\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create opcode, which should never revert.\\n     */\\n    function clone(address implementation) internal returns (address instance) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\\n            // of the `implementation` address with the bytecode before the address.\\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\\n            instance := create(0, 0x09, 0x37)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create failed\\\");\\n    }\\n\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\\n     * the clones cannot be deployed twice at the same address.\\n     */\\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\\n            // of the `implementation` address with the bytecode before the address.\\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\\n            instance := create2(0, 0x09, 0x37, salt)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create2 failed\\\");\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(\\n        address implementation,\\n        bytes32 salt,\\n        address deployer\\n    ) internal pure returns (address predicted) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(add(ptr, 0x38), deployer)\\n            mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)\\n            mstore(add(ptr, 0x14), implementation)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)\\n            mstore(add(ptr, 0x58), salt)\\n            mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))\\n            predicted := keccak256(add(ptr, 0x43), 0x55)\\n        }\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(address implementation, bytes32 salt)\\n        internal\\n        view\\n        returns (address predicted)\\n    {\\n        return predictDeterministicAddress(implementation, salt, address(this));\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"blocklist/=lib/blocklist/src/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"openzeppelin-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/\",\r\n      \"openzeppelin/=lib/openzeppelin-contracts/contracts/\",\r\n      \"sstore2/=lib/sstore2/contracts/\",\r\n      \"story-contract/=lib/story-contract/src/\",\r\n      \"tl-blocklist/=lib/blocklist/src/\",\r\n      \"tl-creator-contracts/=src/\",\r\n      \"tl-sol-tools/=lib/tl-sol-tools/src/\",\r\n      \"tl-story/=lib/story-contract/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 20000\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"implementationAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"ContractDeployed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"contractTypeId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"firstImplementation\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"name\":\"ContractTypeAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"contractTypeId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"ImplementationAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"contractTypeId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"addContractImplementation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"addContractType\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"contractTypeId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"implementationIndex\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"contractName\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"contractSymbol\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"defaultRoyaltyRecipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"defaultRoyaltyPercentage\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"initOwner\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"admins\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"enableStory\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"blockListRegistry\",\"type\":\"address\"}],\"name\":\"deployImplementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"contractTypeId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"contractName\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"contractSymbol\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"defaultRoyaltyRecipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"defaultRoyaltyPercentage\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"initOwner\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"admins\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"enableStory\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"blockListRegistry\",\"type\":\"address\"}],\"name\":\"deployLatestImplementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"contractTypeId\",\"type\":\"uint256\"}],\"name\":\"getContractType\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"address[]\",\"name\":\"implementations\",\"type\":\"address[]\"}],\"internalType\":\"struct TLCreatorContractFactory.ContractType\",\"name\":\"contractType\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getContractTypes\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"address[]\",\"name\":\"implementations\",\"type\":\"address[]\"}],\"internalType\":\"struct TLCreatorContractFactory.ContractType[]\",\"name\":\"contractTypes\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "TLCreatorContractFactory", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "20000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}