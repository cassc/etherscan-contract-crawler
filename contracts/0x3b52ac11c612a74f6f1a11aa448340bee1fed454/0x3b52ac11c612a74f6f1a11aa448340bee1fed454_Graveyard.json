{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"Graveyard.sol\": {\r\n      \"content\": \"// * \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014 *\\n// |                                                                                   |\\n// |    SSSSS K    K EEEEEE L      EEEEEE PPPPP  H    H U    U N     N K    K  SSSSS   |\\n// |   S      K   K  E      L      E      P    P H    H U    U N N   N K   K  S        |\\n// |    SSSS  KKKK   EEE    L      EEE    PPPPP  HHHHHH U    U N  N  N KKKK    SSSS    |\\n// |        S K   K  E      L      E      P      H    H U    U N   N N K   K       S   |\\n// |   SSSSS  K    K EEEEEE LLLLLL EEEEEE P      H    H  UUUU  N     N K    K SSSSS    |\\n// |                                                                                   |\\n// | * AN ETHEREUM-BASED INDENTITY PLATFORM BROUGHT TO YOU BY NEUROMANTIC INDUSTRIES * |\\n// |                                                                                   |\\n// |                             @@@@@@@@@@@@@@@@@@@@@@@@                              |\\n// |                             @@@@@@@@@@@@@@@@@@@@@@@@                              |\\n// |                          @@@,,,,,,,,,,,,,,,,,,,,,,,,@@@                           |\\n// |                       @@@,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,@@@                        |\\n// |                       @@@,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,@@@                        |\\n// |                       @@@,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,@@@                        |\\n// |                       @@@,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,@@@                        |\\n// |                       @@@@@@@@@@,,,,,,,,,,@@@@@@,,,,,,,@@@                        |\\n// |                       @@@@@@@@@@,,,,,,,,,,@@@@@@,,,,,,,@@@                        |\\n// |                       @@@@@@@@@@,,,,,,,,,,@@@@@@,,,,,,,@@@                        |\\n// |                       @@@,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,@@@                        |\\n// |                       @@@,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,@@@                        |\\n// |                       @@@,,,,,,,@@@@@@,,,,,,,,,,,,,,,,,@@@                        |\\n// |                       @@@,,,,,,,@@@@@@,,,,,,,,,,,,,,,,,@@@                        |\\n// |                          @@@,,,,,,,,,,,,,,,,,,,,,,,,@@@                           |\\n// |                          @@@,,,,,,,,,,,,,,,,,,,,@@@@@@@                           |\\n// |                             @@@@@@@@@@@@@@@@@@@@@@@@@@@                           |\\n// |                             @@@@@@@@@@@@@@@@@@@@@@@@@@@                           |\\n// |                             @@@@,,,,,,,,,,,,,,,,@@@@,,,@@@                        |\\n// |                                 @@@@@@@@@@@@@@@@,,,,@@@                           |\\n// |                                           @@@,,,,,,,,,,@@@                        |\\n// |                                           @@@,,,,,,,,,,@@@                        |\\n// |                                              @@@,,,,@@@                           |\\n// |                                           @@@,,,,,,,,,,@@@                        |\\n// |                                                                                   |\\n// |                                                                                   |\\n// |   for more information visit skelephunks.com  |  follow @skelephunks on twitter   |\\n// |                                                                                   |\\n// * \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014 *\\n   \\n   \\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////\\n    //                                           |  The Graveyard is a place you can send a Skelephunk    //\\n    //  The Skelephunks Graveyard Contract       |  and get back a fresh mint from the \\\"Crypt\\\" reserves.  //\\n    //  By Autopsyop,for Neuromantic Industries  |  This is called \\\"burying\\\" instead of burning a token.  //\\n    //  Part of the Skelephunks Platform         |  Once a token is buried it can also be purchased at    //\\n    //                                           |  mint price or reserved to swap in for your next bury  //                                                 //  \\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////                                    \\n\\n\\n// SPDX-License-Identifier: MIT\\n// ************************* ERROR CODES ***************************/\\n// aa: already authorized\\n// na: must be authorized\\n// oa: must be owner or authorized address\\n// ns: address supplied for skelephunksContract does not return \\\"SKELE\\\" from a call to symbol()\\n// as: skelephunksContract is already set to that value\\n// rs: no skelephunks contract linked\\n// os: you can only send skelephunks to the Graveyard\\n// ap: Paused already set to that value\\n// ao: minterOnlyReminting already set to that value\\n// ar: allowReminting already set to that value\\n// am: already reminted more than that\\n// ge: the graveyard is empty\\n// aw: per-wallet maximum already set to that value\\n// au: useSnapshot is already set to that value\\n// nb: token is not buried\\n// tr: token is reserved\\n// al: allowReservations is already set to that value\\n// nr: reservations are not currently allowed\\n// ur: address has nothing reserved\\n// nm: no mints left in crypt\\n// mr: maximum remints already granted\\n// mx: wallet has already max reminted\\n// sn: token was minted after _snapshot\\n// cb: the graveyard cannot bury your skelephunk at this time\\n// nc: contracts are not allowed to send tokens to the graveyard\\n// a$: allowPurchasing is already set to that value\\n// a@: _purchasePrice already set to that value\\n// np: purchasing not currently allowed\\n// pr: Poor\\n// cf: could not forward payment to the skelephunks contract\\n// no: no overpayments to refund for your wallet\\n// *****************************************************************/\\n\\npragma solidity ^0.8.0;\\n\\n\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\ninterface ISkelephunks is IERC721 {\\n    function mintedAt(uint256 tokenId) external view returns (uint256);\\n    function minterOf(uint256 tokenId) external view returns (address);\\n    function getGenderAndDirection(uint256 tokenId) external view returns (uint256);\\n    function tokenOfOwnerByIndex( address owner, uint256 index) external view returns (uint256);\\n    function numMintedReserve() external view returns (uint256);\\n    function maxReserveSupply() external view returns (uint256);\\n    function mintReserve(address to, uint256 quantity, uint256 genderDirection) external;\\n    function mintPrice () external view returns (uint256);\\n    function owner () external view returns (address);\\n    function symbol () external view returns (string memory);\\n}\\n\\n/// @title Skelephunks Graveyard\\n/// @author Neuromantic Industries \\n/// @notice You can use this contract to exchange (bury) Skelephunks for different tokens\\n/// @notice Different exchange options can be enabled: Reserve, Random, Remint from Crypt\\n/// @notice Purchases can also be enabled for buying buried tokens\\n/// @dev Requires linkage to the Skelephunks contract for Crypt Remints\\ncontract Graveyard is IERC721Receiver, Ownable {\\n// packed storage variables\\n    uint256 private _snapshot;\\n\\n    uint64 private _purchasePrice;\\n    uint16 public totalRemints;\\n    uint16 public totalBurials;\\n    uint16 private _maxRemints;\\n    uint16 private _maxRemintsPerWallet;\\n    uint8 public holdLengthMinutes;// max 256 minutes \\n    bool public paused;\\n    bool public minterOnlyReminting;\\n    bool public allowReminting;\\n    bool public useSnapshot;\\n    bool public allowReservations;\\n    bool public allowPurchasing;\\n\\n    ISkelephunks public skelephunksContract;\\n\\n    mapping (address => bool) private authorizedAddresses;\\n\\n    mapping (address => uint16) private totalRemintsByWallet;\\n\\n    mapping ( address => uint16 ) private reservations;\\n    mapping ( uint16 => address ) private reservers;\\n\\n    mapping ( uint16 => uint256 ) private expirations;\\n    mapping (address=> uint256) private overpayments;\\n\\n\\n    constructor () {\\n        setSkelephunksContract(0x7db8cD89308A295bb2D7F809B05DB6389e9a6d88);// MAINNET\\n        // setSkelephunksContract(0xbaC6C9F6b0d7be7a46EDb82237991Fb990459748);// GOERLI\\n        paused = false;\\n\\n        allowReminting = true;\\n        minterOnlyReminting = false;\\n        _maxRemints = 0;//no limit\\n        _maxRemintsPerWallet = 0;//no per-wallet limit\\n\\n        useSnapshot = true;//no reminting remints\\n        _snapshot = block.timestamp;// or new mints after this contract is deployed\\n\\n        allowPurchasing = true;// initially graveyard is just for remints\\n\\n        allowReservations = false;// initially graveyard is just for remints\\n        holdLengthMinutes = 60;//1 hour hold for reservations (can be expanded to 4 hours)\\n\\n        transferOwnership( skelephunksContract.owner() );\\n    }\\n\\n    /// @notice Set authorization for a (contract) address to exhume buried skelephunks\\n    /// @dev Does not currently restrict input to contract addresses\\n    /// @param addr The address to update authorization\\n    /// @param state The new authorization state for the address\\n    function setAuthorization( \\n        address addr,\\n        bool state\\n    ) public onlyOwner {\\n        require(authorizedAddresses[addr]!=state,\\\"aa\\\");\\n        authorizedAddresses[addr] = state;\\n\\n    }\\n\\n    /// @notice Determine the authorization state of an address\\n    /// @param addr The address to check for authorization\\n    /// @return bool The authorization state for the address\\n    function isAuthorized(\\n        address addr\\n    ) public view returns (bool){\\n        return authorizedAddresses[addr];\\n    }\\n\\n    /// @notice Require authorization to use the modified function\\n    modifier onlyAuthorized{\\n        require(authorizedAddresses[msg.sender],\\\"na\\\");\\n        _;\\n    }\\n\\n    /// @notice Require ownership or authorization to use the modified function\\n    modifier ownerOrAuthorized{\\n        require( owner() == msg.sender || isAuthorized(msg.sender), \\\"oa\\\");\\n        _;\\n    }\\n\\n    /// @notice Link the Skelephunks contract to enanble remints from the Crypt\\n    /// @dev Will soft-confirm the contract by symbol to help ensure correctness\\n    /// @param addr The address of the Skelephunks contract\\n    function setSkelephunksContract( \\n        address addr \\n    ) public onlyOwner {\\n        require(address(skelephunksContract)!= addr, \\\"as\\\");\\n        ISkelephunks skele = ISkelephunks(addr);\\n        require( keccak256(abi.encodePacked(skele.symbol())) == keccak256(abi.encodePacked(\\\"SKELE\\\")),\\\"ns\\\");\\n        skelephunksContract = skele;\\n    }\\n\\n    /// @notice Require the Skelephunks contract to be linked to use the modified function\\n    modifier requiresSkelephunks {\\n        require( ISkelephunks(address(0)) != skelephunksContract , \\\"rs\\\" );\\n        _;\\n    }\\n\\n    /// @notice Get the number of mints this contract can access from the Crypt for reminting\\n    /// @dev Reserving 666 mints for other purposes\\n    /// @return The number of mints left in the Crypt, minus 666\\n    function maxCryptMints(\\n    ) private view requiresSkelephunks returns (uint16){\\n        return  uint16(skelephunksContract.maxReserveSupply() - skelephunksContract.numMintedReserve() - 666);\\n    }\\n\\n    /// @notice Determine if Crypt has more mints to offer for remints\\n    /// @return True if mints remain\\n    function cryptHasMints(\\n    ) private view returns (bool){\\n        return maxCryptMints() != 0;\\n    }\\n    \\n    /// @notice Get the number of mints this contract can access from the Crypt for reminting\\n    /// @dev Reserving 666 mints for other purposes\\n    /// @param state The new paused state for the contract\\n    function setPaused(\\n        bool state\\n    ) public onlyOwner {\\n        require( paused != state, \\\"ap\\\" );\\n        paused = state;\\n    }\\n\\n    /// @notice Require the contract to not be paused in order to use the modified function\\n    modifier pausable {\\n      require(!paused);\\n      _;\\n   }\\n\\n    /// @notice Set whether or not only token minters can remint them from the Crypt\\n    /// @param state Whether only minters should be able to remint\\n    function setMinterOnlyReminting( \\n        bool state \\n    ) public onlyOwner {\\n        require( minterOnlyReminting != state, \\\"ao\\\" );\\n        minterOnlyReminting = state;\\n    }\\n\\n\\n    /// @notice Set whehther or not anyone can remint from the Crypt\\n    /// @param state Whether anyone should be able to remint\\n    function setAllowReminting( \\n        bool state \\n    ) public onlyOwner {\\n        require( allowReminting != state, \\\"ar\\\" );\\n        allowReminting = state;\\n    }\\n\\n    /// @notice Determine if a token is buried\\n    /// @dev A buried token is any Skelephunk owned by this contract\\n    /// @param tokenId The id of the token to check if buried\\n    function isBuried(\\n        uint16 tokenId\\n    ) public view requiresSkelephunks returns ( bool ){\\n        return skelephunksContract.ownerOf(uint256(tokenId)) == address(this);\\n    }\\n\\n    /// @notice Set the maximum number of remints that can be provided by the Graveyard\\n    /// @dev Setting to 0 lifts any constraint, to prevent remints use setAllowRemintings()\\n    /// @param max The lifetime maximum number of remints, must be higher than totalRemints\\n    function setMaxRemints( \\n        uint16 max \\n    ) public onlyOwner {\\n        require( max == 0 || max > totalRemints, \\\"am\\\" );\\n        _maxRemints = max;\\n    }\\n  \\n    /// @notice The number of tokens currently owned by the Graveyard\\n    /// @dev Setting to 0 lifts any constraint, to prevent remints use setAllowRemintings()\\n    /// @return The number of tokens currently owned by the Graveyard\\n    function numBuried(\\n    ) public view requiresSkelephunks returns ( uint16 ){\\n        return uint16(skelephunksContract.balanceOf( address( this ) ));\\n    }\\n  \\n    /// @notice Requires the Graveyard to have buried tokens to use the modified function\\n    modifier notEmpty {\\n        require(0 < numBuried(), \\\"ge\\\");\\n        _;\\n    }\\n\\n    /// @notice The maximum number of remints allowed to any given wallet all-time\\n    /// @dev Setting to 0 lifts any constraint, to prevent remints use setAllowRemintings()\\n    /// @return The maximum number of remints allowed to any given wallet all-time\\n    function maxRemintsPerWallet(\\n    )public view returns (uint16){\\n        if(_maxRemintsPerWallet == 0){\\n            return remainingRemints();\\n        }\\n        return _maxRemintsPerWallet;\\n    }\\n\\n    /// @notice Set the maximum number of remints allowed to any given wallet all-time\\n    /// @dev Setting to 0 lifts any constraint, to prevent remints use setAllowRemintings()\\n    /// @param max The maximum number of remints allowed to any given wallet all-time\\n    function setMaxRemintsPerWallet( \\n        uint16 max \\n    ) public onlyOwner {\\n        require(_maxRemintsPerWallet != max, \\\"aw\\\");\\n        _maxRemintsPerWallet = max;\\n    }\\n\\n    /// @notice Get the remaining number of remints the Graveyard can provide\\n    /// @dev Returns 0 when reminting is disabled for easier state query\\n    /// @return The remaining number of available remints\\n    function remainingRemints(\\n    ) public view returns (uint16) {\\n        if (!cryptHasMints() || !allowReminting){\\n            return 0;\\n        }\\n        if (_maxRemints == 0){\\n            return maxCryptMints();\\n        }\\n        return _maxRemints - totalRemints;\\n    }\\n\\n    /// @notice Get the remaining number of remints available to a given wallet\\n    /// @dev Returns 0 when reminting is disabled for easier state query\\n    /// @dev Returns total remaining remints if _maxRemintsPerWallet is 0 (untracked)\\n    /// @return The remaining number of available remints\\n    function remainingRemintsForWallet(\\n        address wallet\\n    ) public view returns(uint16){\\n        if (!cryptHasMints() || !allowReminting){\\n            return 0;\\n        }\\n        if (_maxRemintsPerWallet == 0){\\n            return remainingRemints();\\n        }\\n        return _maxRemintsPerWallet - totalRemintsByWallet[wallet];\\n    }\\n\\n    /// @notice Prevent reminting tokens minted after an updatable timeatamp\\n    /// @dev The _snapshot set on contract deploy prevents remints from being reminted\\n    /// @param state Whether or not to use the stored snapahot to prevent remints\\n    function setUseSnapshot(\\n        bool state\\n    ) public onlyOwner {\\n        require (useSnapshot != state, \\\"au\\\" );\\n        useSnapshot = state;\\n    }\\n\\n    /// @notice Get current snapshot timestamp value\\n    /// @dev If _snapshot is 0, return current timestamp\\n    /// @return Tiume before which mints cant be reminted\\n    function snapshot( \\n    ) public view returns (uint256){\\n        if(useSnapshot){\\n            return _snapshot;\\n        }\\n        return block.timestamp;\\n    }\\n\\n    /// @notice Update the snapshot timestamp to the current second\\n    function takeSnapshot( \\n    ) public onlyOwner {\\n        useSnapshot = true;\\n        _snapshot = block.timestamp;\\n    }\\n\\n    /// @notice Update the snapshot timestamp to the current second\\n    /// @param timestamp The UNIX timestamp after which mints cant be reminted\\n    function setSnapshot(\\n        uint256 timestamp \\n    ) public onlyOwner {\\n\\n    }\\n\\n    /// @notice Update the hold length (in minutes) for reservations\\n    /// @param mins The number of minutes to hold a reservation\\n    function setHoldLengthMinutes(\\n        uint8 mins\\n    ) public onlyOwner {\\n        holdLengthMinutes = mins;\\n    }\\n\\n    /// @notice Determine whether a token is available (buried but not reserved)\\n    /// @param tokenId The token to check for avilability\\n    /// @return Whether the token is available\\n    function tokenIsAvailable(\\n        uint16 tokenId\\n    ) private view returns (bool) {\\n        return isBuried(tokenId) && !isReserved(tokenId);\\n    }\\n\\n    /// @notice Require that a given tokenId is available or revert\\n    /// @param tokenId The token ID that must be available\\n    function requireAvailable(\\n        uint16 tokenId\\n    ) private view {\\n        require(isBuried(tokenId), \\\"nb\\\");\\n        require(!isReserved(tokenId) || reservations[msg.sender] == tokenId, \\\"tr\\\");\\n\\n    }\\n\\n    /// @notice Set whether reserved redemption are allowed\\n    /// @param state The new state of the reservations system\\n    function setAllowReservations(\\n        bool state\\n    )public onlyOwner{\\n        require(allowReservations != state, \\\"al\\\");\\n        allowReservations = state;\\n    }\\n\\n    /// @notice Determine whether a token is available (buried but not reserved)\\n    /// @param tokenId The token to check for avilability\\n    /// @return Whether the token is available\\n    function isReserved(\\n        uint16 tokenId\\n    ) public view returns (bool){\\n        return block.timestamp < expirations[ tokenId ];\\n    }\\n\\n    /// @notice Reserve a token for exchange upon your next burial\\n    /// @param tokenId The token to reserve\\n    function reserveToken( \\n        uint16 tokenId \\n    ) public pausable notEmpty{\\n        require(allowReservations, \\\"nr\\\");\\n        requireAvailable(tokenId);\\n        if(hasReservation(msg.sender)){\\n            clearReservationFrom(msg.sender);\\n        }\\n        reservations[msg.sender] = tokenId;\\n        reservers[tokenId] = msg.sender;\\n        lockToken(tokenId);\\n    }\\n\\n    /// @notice Determine which wallet reserved a given token\\n    /// @dev A value of 0 means the token isn't reserved\\n    /// @param tokenId The token to check for reservation\\n    /// @return The address of the wallet that reserved the token\\n    function reserverOf(\\n        uint16 tokenId\\n    ) public view returns (address){\\n        return reservers[tokenId];\\n    }\\n\\n    /// @notice Determine which token is reserved by a given wallet\\n    /// @dev A value of 0 means the  wallet has no reservation\\n    /// @param wallet The wallet to check for reservation\\n    /// @return The token id reserved by the wallet\\n    function reservationForWallet(\\n        address wallet\\n    ) public view returns (uint16) {\\n        return reservations[wallet];\\n    }\\n\\n    /// @notice Lock up a token for holdLengthMinutes minutes (cannot be purchased or reserved)\\n    /// @param tokenId The token id to lock\\n    function lockToken (\\n        uint16 tokenId\\n    ) private {\\n        expirations[tokenId] = block.timestamp + uint256(holdLengthMinutes) * 60;\\n    }\\n\\n\\n    /// @notice Unlock a token (can now be purchased or reserved)\\n    /// @param tokenId The token id to lock\\n    function unlockToken(\\n        uint16 tokenId\\n    ) private{\\n        delete expirations[tokenId];\\n    }\\n\\n\\n    /// @notice Clear any reservation from your wallet\\n    function clearMyReservation(\\n    ) public {\\n        clearReservationFrom(msg.sender);\\n    }\\n\\n    /// @notice Clear any reservation from a given  wallet\\n    /// @param wallet The wallet to clear\\n    function clearReservationFrom(\\n        address wallet\\n    ) private {\\n        uint16 token = reservationForWallet( wallet );\\n        require( token != 0, \\\"ur\\\" );\\n        unlockToken(token);\\n        delete reservers[token];\\n        delete reservations[wallet];\\n    }\\n\\n    /// @notice Get the id of the nth buried token\\n    /// @dev Indexed from 0 to numBuried -1\\n    /// @param index The index of the buried token\\n    /// @return The token id of the buried token\\n    function buriedTokenByIndex(\\n        uint16 index\\n    ) public view requiresSkelephunks returns (uint16) {\\n        return uint16(skelephunksContract.tokenOfOwnerByIndex(address(this), index));\\n    }\\n\\n\\n    /// @notice Transfer a buried token from the Graveyard to a wallet\\n    /// @param wallet The wallet to send the token to\\n    /// @param tokenId The id of the token to send\\n    function exhumeToken(\\n        address wallet, \\n        uint16 tokenId\\n    ) private notEmpty requiresSkelephunks {\\n        skelephunksContract.safeTransferFrom(address(this), wallet, uint256(tokenId));\\n    }\\n\\n    /// @notice Transfer an available token from the Graveyard to a wallet\\n    /// @param wallet The wallet to send the token to\\n    /// @param tokenId The id of the token to send\\n    function exhumeTo(\\n        address wallet,\\n        uint16 tokenId\\n    ) public ownerOrAuthorized {\\n        requireAvailable(tokenId);\\n        exhumeToken(wallet,tokenId);\\n    }\\n\\n    /// @notice Exhume all tokens to a single address\\n    /// @param wallet The wallet to send the tokens to\\n    function exhumeAllTo(\\n        address wallet\\n    ) public onlyOwner notEmpty {\\n        uint16 num = numBuried();\\n        if( num != 0 ){\\n            for (uint16 i = 0; i<num; i++ ){\\n                exhumeToken( wallet, buriedTokenByIndex(0));\\n            }\\n        }\\n    }\\n\\n    /// @notice Exhume a reserved token to its reserving wallet\\n    /// @param wallet The wallet to send the token to\\n    function exhumeReserved(\\n        address wallet\\n    ) private notEmpty{\\n        uint16 token = reservationForWallet(wallet) ;\\n        require(token != 0, \\\"ur\\\" );\\n        exhumeToken(wallet,token);\\n        clearReservationFrom(wallet);\\n    }\\n    \\n    /// @notice Exhume a randome token to a wallet\\n    /// @param wallet The wallet to send the token to\\n    function exhumeRandom(\\n        address wallet\\n    ) public requiresSkelephunks notEmpty{\\n        uint16 num = numBuried();\\n        uint16 index;\\n        if(num == 1){\\n            index = 0;\\n        } else{\\n            uint256 random = uint256(\\n                keccak256(\\n                    abi.encode(\\n                        wallet,\\n                        tx.gasprice,\\n                        block.number,\\n                        block.timestamp,\\n                        block.prevrandao,\\n                        blockhash(block.number - 1),\\n                        address(this),\\n                        numBuried()\\n                    )\\n                )\\n            );\\n            index = uint16(random % uint256(numBuried() - 1)); // max index was just buried\\n        }\\n        uint16 token = buriedTokenByIndex(index);\\n        exhumeToken(wallet,token);\\n    }\\n\\n    /// @notice Mint a new token from the Crypt to a  wallet\\n    /// @param wallet The wallet to send the token to\\n    /// @param gad The starting gender and direction code for the new mint\\n    function remintFromCrypt(\\n        address wallet, \\n        uint8 gad\\n    ) private requiresSkelephunks {\\n        require( cryptHasMints(),\\\"nm\\\");\\n        require( totalRemints < remainingRemints(), \\\"mr\\\" );\\n        require( 0 < remainingRemintsForWallet(wallet), \\\"mx\\\");\\n        skelephunksContract.mintReserve(wallet, 1, gad);\\n        totalRemints++;\\n        totalRemintsByWallet[ wallet ]++;\\n    }\\n\\n    /// @notice Check if a Wallet has a reservation\\n    /// @param wallet The wallet to check for a reservation\\n    function hasReservation(\\n        address wallet\\n    ) private view returns (bool){\\n        return reservationForWallet(wallet) != 0;\\n    }\\n\\n    /// @notice Register a received Skelephunk token as buried\\n    /// @param tokenId The sid of the token to bury\\n    /// @param wallet The wallet burying the token\\n    function burySkelephunk(\\n        uint16 tokenId, \\n        address wallet \\n    ) private requiresSkelephunks{\\n        require( !useSnapshot || 0 == _snapshot || skelephunksContract.mintedAt( tokenId ) < _snapshot, \\\"sn\\\" );\\n    \\n        if(wallet == owner()){\\n            // contract owner can send without reward to populate the graveyard\\n        }else if(hasReservation(wallet)){ // settle reservations first\\n            exhumeReserved(wallet); \\n        }else if (// if remints are available and allowed, send a new mint from the crypt\\n            allowReminting &&\\n            cryptHasMints() && \\n            0 < remainingRemints() && \\n            0 < remainingRemintsForWallet(wallet) && \\n            (!minterOnlyReminting || skelephunksContract.minterOf( tokenId ) == wallet)\\n        ){\\n            remintFromCrypt(wallet,uint8(skelephunksContract.getGenderAndDirection(tokenId)));\\n        }else if(0 < numBuried()){// otherwise, send a random buried token\\n            exhumeRandom(wallet);\\n        }else{\\n            revert(\\\"cb\\\");\\n        }\\n        totalBurials++;\\n    }\\n\\n    /// @notice Respond to being sent a Skelphunks token by burying it\\n    /// @dev see https://docs.openzeppelin.com/contracts/2.x/api/token/erc721#IERC721Receiver\\n    function onERC721Received(\\n        address, \\n        address from, \\n        uint256 tokenId, \\n        bytes calldata \\n    ) external returns (bytes4) {\\n        uint16 id = uint16(tokenId);\\n        require(msg.sender == address(skelephunksContract),\\\"foh yoinker\\\");\\n        require(from == tx.origin, \\\"nc\\\");//skelephunks is for the people\\n        burySkelephunk(id, from);\\n        require(isBuried(id),\\\"nb\\\");\\n        return this.onERC721Received.selector;\\n    }\\n\\n    /// @notice Allow buried tokens to be purchased\\n    /// @param state Whether or not to allow purchases\\n    function setAllowPurchasing (\\n        bool state\\n    ) public onlyOwner{\\n        require(allowPurchasing !=state, \\\"a$\\\");\\n        allowPurchasing = state;\\n    }\\n\\n    /// @notice Override the purchae price of buried tokens (vs. using mintPrice)\\n    /// @dev Set to 0 to use Skelephunks mint price\\n    /// @param price The price (in Wei)to buy buried tokens\\n    function setPurchasePrice(\\n        uint64 price\\n    ) public onlyOwner {\\n        require(_purchasePrice != price, \\\"a@\\\");\\n        _purchasePrice = price;\\n    }\\n\\n    /// @notice Get current purchase price for buried tokens\\n    /// @return The price (in Wei) to buy buried tokens\\n    function purchasePrice(\\n    )public view returns (uint64){\\n        if(_purchasePrice == 0){\\n            return uint64(skelephunksContract.mintPrice());\\n        }else{\\n            return _purchasePrice;\\n        }\\n    }\\n\\n\\n    /// @notice buy a buried Skelephunk for thet purchase price\\n    /// @dev Overpayment can be withdrawn any time\\n    /// @param tokenId The id of the token to buy\\n    function buyBuriedSkelephunk (\\n        uint16 tokenId\\n    ) public payable pausable requiresSkelephunks{\\n        uint256 price = uint256(purchasePrice());\\n        require( allowPurchasing, \\\"np\\\");\\n        require( price <= msg.value, \\\"pr\\\");\\n        requireAvailable(tokenId);\\n        (bool outcome,) = address(skelephunksContract).call{value: price}(\\\"\\\");\\n        require(outcome,\\\"cf\\\");\\n        exhumeToken(msg.sender,tokenId);\\n        uint256 refund = msg.value - price;\\n        overpayments[msg.sender] += refund;\\n\\n    }\\n\\n    /// @notice Get the cumulative overpayment for purchased tokens by a wallet\\n    /// @param wallet The wallet to check for overpayment balance\\n    function refundAmountForWallet(\\n        address wallet\\n     ) public view returns (uint256){\\n         return overpayments[wallet];\\n     }\\n\\n    /// @notice Withdraw any accumulated overpayment for your wallet\\n     function withdrawRefund(\\n     ) public {\\n        require(overpayments[msg.sender] !=0, \\\"no\\\");\\n        payable(msg.sender).transfer(overpayments[msg.sender]);\\n        overpayments[msg.sender] = 0;\\n     }\\n\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"allowPurchasing\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allowReminting\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allowReservations\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"index\",\"type\":\"uint16\"}],\"name\":\"buriedTokenByIndex\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"tokenId\",\"type\":\"uint16\"}],\"name\":\"buyBuriedSkelephunk\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"clearMyReservation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"exhumeAllTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"exhumeRandom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"tokenId\",\"type\":\"uint16\"}],\"name\":\"exhumeTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"holdLengthMinutes\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"isAuthorized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"tokenId\",\"type\":\"uint16\"}],\"name\":\"isBuried\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"tokenId\",\"type\":\"uint16\"}],\"name\":\"isReserved\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxRemintsPerWallet\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minterOnlyReminting\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numBuried\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"purchasePrice\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"refundAmountForWallet\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"remainingRemints\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"remainingRemintsForWallet\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"reservationForWallet\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"tokenId\",\"type\":\"uint16\"}],\"name\":\"reserveToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"tokenId\",\"type\":\"uint16\"}],\"name\":\"reserverOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"setAllowPurchasing\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"setAllowReminting\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"setAllowReservations\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"setAuthorization\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"mins\",\"type\":\"uint8\"}],\"name\":\"setHoldLengthMinutes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"max\",\"type\":\"uint16\"}],\"name\":\"setMaxRemints\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"max\",\"type\":\"uint16\"}],\"name\":\"setMaxRemintsPerWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"setMinterOnlyReminting\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"setPaused\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"price\",\"type\":\"uint64\"}],\"name\":\"setPurchasePrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setSkelephunksContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"setSnapshot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"setUseSnapshot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"skelephunksContract\",\"outputs\":[{\"internalType\":\"contract ISkelephunks\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"snapshot\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"takeSnapshot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalBurials\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalRemints\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"useSnapshot\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawRefund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Graveyard", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}