{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/lib/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.10;\\n\\nimport {Ownable} from \\\"../../lib/Ownable.sol\\\";\\nimport {IERC20Events, IERC20} from \\\"./interface/IERC20.sol\\\";\\n\\n/**\\n * @title ERC20\\n * @notice EIP-20 (https://eips.ethereum.org/EIPS/eip-20) implementation with EIP-2612\\n * (https://eips.ethereum.org/EIPS/eip-2612) support, as well as mint and burn functionality.\\n * @author MirrorXYZ\\n */\\ncontract ERC20 is Ownable, IERC20, IERC20Events {\\n    /// @notice Separator used for permit\\n    /// @dev keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\")\\n    bytes32 public constant override PERMIT_TYPEHASH =\\n        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\\n\\n    /// @notice Token total supply\\n    uint256 public override totalSupply;\\n\\n    /// @notice Token name\\n    string public override name;\\n\\n    /// @notice Token symbol\\n    string public override symbol;\\n\\n    /// @notice Token decimals\\n    uint8 public override decimals;\\n\\n    /// @notice Token balance\\n    mapping(address => uint256) public override balanceOf;\\n\\n    /// @notice Token allowance\\n    mapping(address => mapping(address => uint256)) public override allowance;\\n\\n    /// @notice Separator used on permit\\n    bytes32 public override DOMAIN_SEPARATOR;\\n\\n    /// @notice Nonces used on permit\\n    mapping(address => uint256) public override nonces;\\n\\n    /// @notice Token burn status\\n    bool public burnable;\\n\\n    /// @notice Factory that deploys clones\\n    address public immutable factory;\\n\\n    modifier ifBurnable() {\\n        require(burnable, \\\"ERC20: cannot burn\\\");\\n        _;\\n    }\\n\\n    /// @dev Ownable parameter is irrelevant since this is a logic file.\\n    constructor(address factory_) Ownable(address(0)) {\\n        factory = factory_;\\n    }\\n\\n    /// @notice Set initial parameters, mint initial supply to owner and set the owner.\\n    /// @dev Only callable by the factory\\n    /// @param owner_ The owner of the token contract\\n    /// @param name_ The name of the token\\n    /// @param symbol_ The symbol of the token\\n    /// @param totalSupply_ The totalSupply of the token\\n    /// @param decimals_ The decimals of the token\\n    function initialize(\\n        address owner_,\\n        string memory name_,\\n        string memory symbol_,\\n        uint256 totalSupply_,\\n        uint8 decimals_\\n    ) external override returns (address) {\\n        // ensure that this function is only callable by the factory\\n        require(msg.sender == factory, \\\"unauthorized caller\\\");\\n\\n        // set owner\\n        _setOwner(address(0), owner_);\\n\\n        // set metadata\\n        name = name_;\\n        symbol = symbol_;\\n        decimals = decimals_;\\n\\n        // mint initial supply\\n        _mint(owner_, totalSupply_);\\n\\n        // generate domain separator\\n        DOMAIN_SEPARATOR = keccak256(\\n            abi.encode(\\n                keccak256(\\n                    \\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"\\n                ),\\n                keccak256(bytes(name_)),\\n                keccak256(bytes(\\\"1\\\")),\\n                block.chainid,\\n                address(this)\\n            )\\n        );\\n\\n        // set burn status\\n        burnable = false;\\n\\n        return address(this);\\n    }\\n\\n    /// @notice Change burn status, only callable by the owner.\\n    /// @param canBurn The burn status of the token\\n    function setBurnable(bool canBurn) external override onlyOwner {\\n        burnable = canBurn;\\n    }\\n\\n    // ============ ERC-20 Methods ============\\n\\n    /// @notice Approve `spender` to transfer up to `value` from `msg.sender`\\n    /// @dev This will overwrite the approval value for `spender`\\n    ///  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\\n    /// @param spender The address of the account which may transfer tokens\\n    /// @param value The number of tokens that are approved\\n    /// @return Whether or not the approval succeeded\\n    function approve(address spender, uint256 value)\\n        external\\n        override\\n        returns (bool)\\n    {\\n        _approve(msg.sender, spender, value);\\n\\n        return true;\\n    }\\n\\n    /// @notice Transfer `value` tokens from `msg.sender` to `to`\\n    /// @param to The address of the destination account\\n    /// @param value The number of tokens to transfer\\n    /// @return Whether or not the transfer succeeded\\n    function transfer(address to, uint256 value)\\n        external\\n        override\\n        returns (bool)\\n    {\\n        _transfer(msg.sender, to, value);\\n\\n        return true;\\n    }\\n\\n    /// @notice Transfer `value` tokens from `from` to `to`\\n    /// @param from The address of the source account\\n    /// @param to The address of the destination account\\n    /// @param value The number of tokens to transfer\\n    /// @return Whether or not the transfer succeeded\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external override returns (bool) {\\n        if (allowance[from][msg.sender] != type(uint256).max) {\\n            allowance[from][msg.sender] -= value;\\n        }\\n\\n        _transfer(from, to, value);\\n\\n        return true;\\n    }\\n\\n    /// @notice Triggers an approval from `_owner` to `spender`\\n    /// @param _owner The address to approve from\\n    /// @param spender The address to be approved\\n    /// @param value The number of tokens that are approved (2^256-1 means infinite)\\n    /// @param deadline The time at which to expire the signature\\n    /// @param v The recovery byte of the signature\\n    /// @param r Half of the ECDSA signature pair\\n    /// @param s Half of the ECDSA signature pair\\n    function permit(\\n        address _owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external override {\\n        require(deadline >= block.timestamp, \\\"ERC20: EXPIRED\\\");\\n\\n        bytes32 digest = keccak256(\\n            abi.encodePacked(\\n                \\\"\\\\x19\\\\x01\\\",\\n                DOMAIN_SEPARATOR,\\n                keccak256(\\n                    abi.encode(\\n                        PERMIT_TYPEHASH,\\n                        _owner,\\n                        spender,\\n                        value,\\n                        nonces[_owner]++,\\n                        deadline\\n                    )\\n                )\\n            )\\n        );\\n\\n        address recoveredAddress = ecrecover(digest, v, r, s);\\n\\n        require(\\n            recoveredAddress != address(0) && recoveredAddress == _owner,\\n            \\\"ERC20: INVALID_SIGNATURE\\\"\\n        );\\n\\n        _approve(_owner, spender, value);\\n    }\\n\\n    /// @notice Burn `value` from `msg.sender`'s balance\\n    /// @dev Throws when the token is not burnable\\n    /// @param value The value to burn\\n    function burn(uint256 value) external override ifBurnable {\\n        _burn(msg.sender, value);\\n    }\\n\\n    /// @notice Mint `value` tokens to `to`\\n    /// @dev Only callable by the owner, throws otherwise\\n    /// @param to The account to mint tokens to\\n    /// @param value The number of tokens to mint\\n    function mint(address to, uint256 value) external override onlyOwner {\\n        _mint(to, value);\\n    }\\n\\n    // ============ Internal Methods ============\\n\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        balanceOf[from] -= value;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += value;\\n        }\\n\\n        emit Transfer(from, to, value);\\n    }\\n\\n    function _mint(address to, uint256 value) internal {\\n        require(to != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        totalSupply += value;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += value;\\n        }\\n\\n        emit Transfer(address(0), to, value);\\n    }\\n\\n    function _approve(\\n        address _owner,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        allowance[_owner][spender] = value;\\n\\n        emit Approval(_owner, spender, value);\\n    }\\n\\n    function _burn(address from, uint256 value) internal {\\n        balanceOf[from] -= value;\\n\\n        // Cannot underflow because a user's balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply -= value;\\n        }\\n\\n        emit Transfer(from, address(0), value);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.10;\\n\\ninterface IOwnableEvents {\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n}\\n\\ncontract Ownable is IOwnableEvents {\\n    address public owner;\\n    address private nextOwner;\\n\\n    // modifiers\\n\\n    modifier onlyOwner() {\\n        require(isOwner(), \\\"caller is not the owner.\\\");\\n        _;\\n    }\\n\\n    modifier onlyNextOwner() {\\n        require(isNextOwner(), \\\"current owner must set caller as next owner.\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Initialize contract by setting transaction submitter as initial owner.\\n     */\\n    constructor(address owner_) {\\n        owner = owner_;\\n        emit OwnershipTransferred(address(0), owner);\\n    }\\n\\n    /**\\n     * @dev Initiate ownership transfer by setting nextOwner.\\n     */\\n    function transferOwnership(address nextOwner_) external onlyOwner {\\n        require(nextOwner_ != address(0), \\\"Next owner is the zero address.\\\");\\n\\n        nextOwner = nextOwner_;\\n    }\\n\\n    /**\\n     * @dev Cancel ownership transfer by deleting nextOwner.\\n     */\\n    function cancelOwnershipTransfer() external onlyOwner {\\n        delete nextOwner;\\n    }\\n\\n    /**\\n     * @dev Accepts ownership transfer by setting owner.\\n     */\\n    function acceptOwnership() external onlyNextOwner {\\n        delete nextOwner;\\n\\n        owner = msg.sender;\\n\\n        emit OwnershipTransferred(owner, msg.sender);\\n    }\\n\\n    /**\\n     * @dev Renounce ownership by setting owner to zero address.\\n     */\\n    function renounceOwnership() external onlyOwner {\\n        _renounceOwnership();\\n    }\\n\\n    /**\\n     * @dev Returns true if the caller is the current owner.\\n     */\\n    function isOwner() public view returns (bool) {\\n        return msg.sender == owner;\\n    }\\n\\n    /**\\n     * @dev Returns true if the caller is the next owner.\\n     */\\n    function isNextOwner() public view returns (bool) {\\n        return msg.sender == nextOwner;\\n    }\\n\\n    function _setOwner(address previousOwner, address newOwner) internal {\\n        owner = newOwner;\\n        emit OwnershipTransferred(previousOwner, owner);\\n    }\\n\\n    function _renounceOwnership() internal {\\n        emit OwnershipTransferred(owner, address(0));\\n\\n        owner = address(0);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/ERC20/interface/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.10;\\n\\ninterface IERC20Events {\\n    /// @notice EIP-20 transfer event\\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\\n\\n    /// @notice EIP-20 approval event\\n    event Approval(\\n        address indexed _owner,\\n        address indexed _spender,\\n        uint256 _value\\n    );\\n\\n    /// @notice Mint event\\n    event Mint(address indexed _to, uint256 _value);\\n}\\n\\ninterface IERC20 {\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n\\n    function PERMIT_TYPEHASH() external view returns (bytes32);\\n\\n    function initialize(\\n        address operator_,\\n        string memory name_,\\n        string memory symbol_,\\n        uint256 totalSupply_,\\n        uint8 decimals_\\n    ) external returns (address);\\n\\n    function setBurnable(bool canBurn) external;\\n\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function decimals() external view returns (uint8);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address owner) external view returns (uint256);\\n\\n    function allowance(address owner, address spender)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    function nonces(address owner) external view returns (uint256);\\n\\n    function mint(address to, uint256 amount) external;\\n\\n    function burn(uint256 amount) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 2000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"factory_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERMIT_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"burnable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cancelOwnershipTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"name_\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol_\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"totalSupply_\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"decimals_\",\"type\":\"uint8\"}],\"name\":\"initialize\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isNextOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"canBurn\",\"type\":\"bool\"}],\"name\":\"setBurnable\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nextOwner_\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "ERC20", "CompilerVersion": "v0.8.10+commit.fc410830", "OptimizationUsed": "1", "Runs": "2000", "ConstructorArguments": "000000000000000000000000fdaef6d6ac99243b80643730badaec4171118fd9", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}