{"SourceCode": "// SPDX-License-Identifier: GPL-3.0\r\n// File: contracts/interfaces/IERC721Receiver.sol\r\n\r\n\r\n\r\npragma solidity >= 0.8.0 <0.9.0;\r\n\r\ninterface IERC721Receiver {\r\n    function onERC721Received(\r\n        address operator,\r\n        address from,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}\r\n// File: contracts/standards/ERC721Holder.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\ncontract ERC721Holder is IERC721Receiver {\r\n    function onERC721Received(address, address, uint256, bytes memory) public virtual override returns (bytes4) {\r\n        return this.onERC721Received.selector;\r\n    }\r\n}\r\n// File: contracts/interfaces/IERC20.sol\r\n\r\n\r\n\r\npragma solidity >= 0.8.0 <0.9.0;\r\n\r\ninterface IERC20 {\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\r\n}\r\n// File: contracts/interfaces/IERC165.sol\r\n\r\n\r\n\r\npragma solidity >= 0.8.0 <0.9.0;\r\n\r\ninterface IERC165 {\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n// File: contracts/standards/ERC165.sol\r\n\r\n\r\n\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\n\r\nabstract contract ERC165 is IERC165 {\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n        return interfaceId == type(IERC165).interfaceId;\r\n    }\r\n}\r\n// File: contracts/interfaces/IERC1155Receiver.sol\r\n\r\n\r\n\r\npragma solidity >= 0.8.0 <0.9.0;\r\n\r\n\r\n\r\ninterface IERC1155Receiver is IERC165 {\r\n    function onERC1155Received(\r\n        address operator,\r\n        address from,\r\n        uint256 id,\r\n        uint256 value,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n\r\n    function onERC1155BatchReceived(\r\n        address operator,\r\n        address from,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata values,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}\r\n// File: contracts/standards/ERC1155Receiver.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\nabstract contract ERC1155Receiver is ERC165, IERC1155Receiver {\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\r\n        return interfaceId == type(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId);\r\n    }\r\n}\r\n// File: contracts/standards/ERC1155Holder.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\ncontract ERC1155Holder is ERC1155Receiver {\r\n    function onERC1155Received(\r\n        address,\r\n        address,\r\n        uint256,\r\n        uint256,\r\n        bytes memory\r\n    ) public virtual override returns (bytes4) {\r\n        return this.onERC1155Received.selector;\r\n    }\r\n\r\n    function onERC1155BatchReceived(\r\n        address,\r\n        address,\r\n        uint256[] memory,\r\n        uint256[] memory,\r\n        bytes memory\r\n    ) public virtual override returns (bytes4) {\r\n        return this.onERC1155BatchReceived.selector;\r\n    }\r\n}\r\n// File: contracts/interfaces/IERC721.sol\r\n\r\n\r\n\r\npragma solidity >= 0.8.0 <0.9.0;\r\n\r\n\r\ninterface IERC721 is IERC165 {\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\r\n    function transferFrom(address from, address to, uint256 tokenId) external;\r\n    function approve(address to, uint256 tokenId) external;\r\n    function setApprovalForAll(address operator, bool approved) external;\r\n    function getApproved(uint256 tokenId) external view returns (address operator);\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n}\r\n// File: contracts/interfaces/IERC1155.sol\r\n\r\n\r\n\r\npragma solidity >= 0.8.0 <0.9.0;\r\n\r\n\r\ninterface IERC1155 is IERC165 {\r\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\r\n    event TransferBatch(\r\n        address indexed operator,\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256[] ids,\r\n        uint256[] values\r\n    );\r\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\r\n    event URI(string value, uint256 indexed id);\r\n    function balanceOf(address account, uint256 id) external view returns (uint256);\r\n    function balanceOfBatch(\r\n        address[] calldata accounts,\r\n        uint256[] calldata ids\r\n    ) external view returns (uint256[] memory);\r\n    function setApprovalForAll(address operator, bool approved) external;\r\n    function isApprovedForAll(address account, address operator) external view returns (bool);\r\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\r\n    function safeBatchTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata amounts,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n// File: contracts/utils/Counters.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\nlibrary Counters {\r\n    struct Counter {\r\n        uint256 _value;\r\n    }\r\n\r\n    function current(Counter storage counter) internal view returns (uint256) {\r\n        return counter._value;\r\n    }\r\n\r\n    function increment(Counter storage counter) internal {\r\n        unchecked {\r\n            counter._value += 1;\r\n        }\r\n    }\r\n\r\n    function decrement(Counter storage counter) internal {\r\n        uint256 value = counter._value;\r\n        require(value > 0, \"Counter: decrement overflow\");\r\n        unchecked {\r\n            counter._value = value - 1;\r\n        }\r\n    }\r\n\r\n    function reset(Counter storage counter) internal {\r\n        counter._value = 0;\r\n    }\r\n}\r\n// File: contracts/utils/Ownable.sol\r\n\r\n\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\nabstract contract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    constructor() {\r\n        _changeOwner(msg.sender);\r\n    }\r\n    modifier onlyOwner() {\r\n        require(_owner == msg.sender, \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _changeOwner(address(0));\r\n    }\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n    function _changeOwner(address newOwner) internal virtual {\r\n        address old = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(old, newOwner);\r\n    }\r\n}\r\n// File: contracts/qorpoMarket/qorpoMarket.sol\r\n\r\n\r\npragma solidity >=0.7.0 <0.9.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ninterface IERC2981 is IERC165 {\r\n    /**\r\n     * @dev Returns how much royalty is owed and to whom, based on a sale price that may be denominated in any unit of\r\n     * exchange. The royalty amount is denominated and should be paid in that same unit of exchange.\r\n     */\r\n    function royaltyInfo(uint256 tokenId, uint256 salePrice)\r\n        external\r\n        view\r\n        returns (address receiver, uint256 royaltyAmount);\r\n}\r\n\r\ncontract QorpoMarket is Ownable, ERC1155Holder, ERC721Holder{\r\n    using Counters for Counters.Counter;\r\n    struct Offer{\r\n        address nftAddress;\r\n        uint256 nftTokenId;\r\n        uint256 amount;\r\n        address seller;\r\n        uint256 createdAt;\r\n    }\r\n    uint8 _ERC20 = 1;\r\n    uint8 _ERC721 = 2;\r\n    uint8 _ERC1155 = 3;\r\n    uint16 marketFeePerMille = 0;\r\n    Counters.Counter private offerId;\r\n    mapping(uint256 => Offer) offers;\r\n    mapping (uint256 => mapping (address => uint256)) public offerPrices;\r\n\r\n\r\n    event CreateMarketOffer(uint256 indexed offerId, address nftAddress, uint256 nftTokenId,\r\n     address[] paymentCurrencies, uint256[] paymentPrices, uint256 amount, address seller);\r\n    event BuyMarketOffer(uint256 indexed offerId, address nftAddress, uint256 nftTokenId,\r\n     address paymentCurrency, uint256 price, uint256 amount, address seller);\r\n    event CancelMarketOffer(uint256 indexed offerId, address nftAddress, uint256 nftTokenId, uint256 amount, address seller);\r\n    event RoyaltyPayment(address from, address indexed to, address indexed tokenAddress, uint256 indexed amount, address nftAddress, uint256 tokenId);\r\n\r\n    function createOffer(address[] calldata paymentCurrencies, uint256[] calldata paymentPrices, address nftAddress, uint256 nftTokenId, uint256 amount)\r\n    public returns (uint256){   \r\n        require(paymentCurrencies.length <= 5, \"Market: only up to 5 payment options are allowed\");\r\n        require(amount>0, \"Market: amount should be greater than 0\");\r\n        require(paymentCurrencies.length>0, \"Market: offer must have at least 1 payment option\");\r\n        uint8 contractType = determineContractType(nftAddress);\r\n        if(contractType==2){\r\n            require(amount==1, \"Market: amount has to be equal to 1 in case of ERC721\");\r\n            IERC721(nftAddress).transferFrom(msg.sender, address(this), nftTokenId);\r\n        }\r\n        else if(contractType==3){\r\n            IERC1155(nftAddress).safeTransferFrom(msg.sender, address(this), nftTokenId, amount, \"\");\r\n        }\r\n        else{\r\n            revert(\"Market: Not valid NFT standard\");\r\n        }\r\n        offerId.increment();\r\n        require(paymentCurrencies.length==paymentPrices.length, \"Market: payment addresses must have same lenght as prices\");\r\n        for (uint i=0; i<paymentCurrencies.length; i++){\r\n             require(paymentPrices[i]>0, \"Market: price should be greater than 0\");\r\n             offerPrices[offerId.current()][paymentCurrencies[i]] = paymentPrices[i];       \r\n        }\r\n        offers[offerId.current()] = Offer(nftAddress, nftTokenId, amount, msg.sender, block.number);\r\n        emit CreateMarketOffer(offerId.current(), nftAddress, nftTokenId, paymentCurrencies, paymentPrices, amount, msg.sender);\r\n        return offerId.current();\r\n    }\r\n\r\n    function buyOffer(uint256 _offerId, address paymentCurrency) public payable{\r\n        require(offers[_offerId].createdAt != 0, \"Market: offer is not valid\");\r\n        require(offerPrices[_offerId][paymentCurrency] != 0, \"Market: ivalid payment token address\");\r\n        Offer memory offer = offers[_offerId];\r\n        delete offers[_offerId];\r\n        uint price = offerPrices[_offerId][paymentCurrency];\r\n        uint256 priceAfterFee = uint256(price*(1000-marketFeePerMille)/1000);\r\n        uint256 royaltyAmount = 0;\r\n        address royaltyReceiver = address(0);\r\n        if(IERC165(offer.nftAddress).supportsInterface(0x2a55205a)){\r\n            (royaltyReceiver, royaltyAmount) = IERC2981(offer.nftAddress).royaltyInfo(offer.nftTokenId, priceAfterFee);\r\n        }\r\n        if(paymentCurrency!=address(0)){\r\n            if(priceAfterFee-royaltyAmount>0){\r\n                IERC20(paymentCurrency).transferFrom(msg.sender, offer.seller, priceAfterFee-royaltyAmount);\r\n            }\r\n            if(price-priceAfterFee > 0){\r\n                IERC20(paymentCurrency).transferFrom(msg.sender, address(this), price-priceAfterFee);\r\n            }\r\n            if(royaltyAmount != 0){\r\n                IERC20(paymentCurrency).transferFrom(msg.sender, royaltyReceiver, royaltyAmount);\r\n                emit RoyaltyPayment(msg.sender, royaltyReceiver, paymentCurrency, royaltyAmount, offer.nftAddress,\r\n                offer.nftTokenId);\r\n            }\r\n        }\r\n        else{\r\n            require(msg.value >= price, \"Market: not enough natives send\");\r\n            if(priceAfterFee-royaltyAmount>0){\r\n                payable(offer.seller).transfer(priceAfterFee-royaltyAmount);\r\n            }\r\n            if(royaltyAmount != 0){\r\n                payable(royaltyReceiver).transfer(royaltyAmount);\r\n                emit RoyaltyPayment(msg.sender, royaltyReceiver, paymentCurrency, royaltyAmount, offer.nftAddress,\r\n                offer.nftTokenId);\r\n            }\r\n        }\r\n        uint8 contractType = determineContractType(offer.nftAddress);\r\n        if(contractType==2){\r\n            IERC721(offer.nftAddress).transferFrom(address(this), msg.sender, offer.nftTokenId);\r\n        }\r\n        else{\r\n            IERC1155(offer.nftAddress).safeTransferFrom(address(this), msg.sender, offer.nftTokenId, offer.amount, \"\");\r\n        }\r\n        emit BuyMarketOffer(_offerId, offer.nftAddress, offer.nftTokenId, paymentCurrency, price, offer.amount, msg.sender);\r\n    }\r\n    function cancelOffer(uint256 _offerId) public{\r\n        require(offers[_offerId].createdAt != 0, \"Market: offer is not valid\");\r\n        require(offers[_offerId].seller == msg.sender, \"Market: you are not eligible for refund\");\r\n        Offer memory offer = offers[_offerId];\r\n        delete offers[_offerId];\r\n        uint8 contractType = determineContractType(offer.nftAddress);\r\n        if(contractType==2){\r\n            IERC721(offer.nftAddress).transferFrom(address(this), msg.sender, offer.nftTokenId);\r\n        }\r\n        else{\r\n            IERC1155(offer.nftAddress).safeTransferFrom(address(this), msg.sender, offer.nftTokenId, offer.amount, \"\");\r\n        }\r\n        emit CancelMarketOffer(_offerId, offer.nftAddress, offer.nftTokenId, offer.amount, msg.sender);\r\n    }\r\n    function getOffer(uint256 _offerId) public view returns(Offer memory){\r\n        return offers[_offerId];\r\n    }\r\n\r\n    function getOfferCreator(uint256 _offerId) public view returns(address){\r\n        return offers[_offerId].seller;\r\n    }\r\n\r\n    function withdraw(address contract_address, uint8 standard, uint256 tokenId, uint256 amount) public onlyOwner{\r\n        if(contract_address==address(0)){\r\n            payable(msg.sender).transfer(amount);\r\n        }\r\n        else if(standard==_ERC20){\r\n            if(amount==0) amount = IERC20(contract_address).balanceOf(address(this));\r\n            IERC20(contract_address).transfer(msg.sender, amount);\r\n        }\r\n        else if(standard==_ERC721){\r\n            IERC721(contract_address).transferFrom(address(this), msg.sender, tokenId);\r\n        }\r\n        else if(standard==_ERC1155){\r\n            if(amount==0) amount = IERC1155(contract_address).balanceOf(address(this), tokenId);\r\n            IERC1155(contract_address).safeTransferFrom(address(this), msg.sender, tokenId, amount, \"\");\r\n        }\r\n        \r\n    }\r\n\r\n    function getMarketFeePerMille() public view returns(uint16){\r\n        return marketFeePerMille;\r\n    }\r\n\r\n    function setMarketFee(uint16 newFeePerMille) public onlyOwner{\r\n        require(newFeePerMille >= 0 && newFeePerMille<=1000, \"Market: invalid fee value\");\r\n        marketFeePerMille = newFeePerMille;\r\n    }\r\n\r\n    function determineContractType(address contractAddress) internal view returns(uint8){\r\n        bytes4 IERC1155_ID = 0xd9b67a26;\r\n        bytes4 IERC721_ID = 0x80ac58cd;\r\n        (bool isSuccess, bytes memory response) = contractAddress.staticcall(abi.encodeWithSignature(\"supportsInterface(bytes4)\",IERC1155_ID));\r\n        if(isSuccess){\r\n            if(abi.decode(response, (bool)))return 3;\r\n            (isSuccess,response) = contractAddress.staticcall(abi.encodeWithSignature(\"supportsInterface(bytes4)\",IERC721_ID));\r\n            if(isSuccess && abi.decode(response, (bool))) return 2;\r\n        }\r\n        (isSuccess,) = contractAddress.staticcall(abi.encodeWithSignature(\"balanceOf(address,uint256)\",msg.sender, 1));\r\n        if(isSuccess) return 3;\r\n        (isSuccess,) = contractAddress.staticcall(abi.encodeWithSignature(\"balanceOf(address)\",msg.sender));\r\n        if(isSuccess){\r\n            (isSuccess,) = contractAddress.staticcall(abi.encodeWithSignature(\"decimals()\"));\r\n            if(isSuccess) return 1;\r\n            return 2;\r\n        }\r\n        return 0;\r\n    } \r\n}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"offerId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"nftAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nftTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"paymentCurrency\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"}],\"name\":\"BuyMarketOffer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"offerId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"nftAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nftTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"}],\"name\":\"CancelMarketOffer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"offerId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"nftAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nftTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"paymentCurrencies\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"paymentPrices\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"}],\"name\":\"CreateMarketOffer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"nftAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"RoyaltyPayment\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_offerId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"paymentCurrency\",\"type\":\"address\"}],\"name\":\"buyOffer\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_offerId\",\"type\":\"uint256\"}],\"name\":\"cancelOffer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"paymentCurrencies\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"paymentPrices\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"nftAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nftTokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"createOffer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMarketFeePerMille\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_offerId\",\"type\":\"uint256\"}],\"name\":\"getOffer\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"nftAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nftTokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"createdAt\",\"type\":\"uint256\"}],\"internalType\":\"struct QorpoMarket.Offer\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_offerId\",\"type\":\"uint256\"}],\"name\":\"getOfferCreator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"offerPrices\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155BatchReceived\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"newFeePerMille\",\"type\":\"uint16\"}],\"name\":\"setMarketFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contract_address\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"standard\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "QorpoMarket", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU GPLv2", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://813fe00fe595dfeba25f1c33dc9c5c4c4064564fab228bfbd4cff01913d4afc8"}