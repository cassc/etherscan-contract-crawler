{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 100\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"contracts/bridge/DestinationBridge.sol\": {\r\n      \"content\": \"/**SPDX-License-Identifier: BUSL-1.1\\n\\n      \u2584\u2584\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2584\\n   \u2553\u2588\u2588\u2580\u2514 ,\u2553\u2584\u2584\u2584, '\u2580\u2588\u2588\u2584\\n  \u2588\u2588\u2580 \u2584\u2588\u2588\u2580\u2580\u2559\u2559\u2580\u2580\u2588\u2588\u2584 \u2514\u2588\u2588\u00b5           ,,       ,,      ,     ,,,            ,,,\\n \u2588\u2588 ,\u2588\u2588\u00ac \u2584\u2588\u2588\u2588\u2588\u2584  \u2580\u2588\u2584 \u2559\u2588\u2584      \u2584\u2588\u2588\u2588\u2580\u2580\u2588\u2588\u2588\u2584   \u2588\u2588\u2588\u2584    \u2588\u2588  \u2588\u2588\u2588\u2580\u2580\u2580\u2588\u2588\u2588\u2584    \u2584\u2588\u2588\u2588\u2580\u2580\u2588\u2588\u2588,\\n\u2588\u2588  \u2588\u2588 \u2552\u2588\u2580'   \u2559\u2588\u258c \u2559\u2588\u258c \u2588\u2588     \u2590\u2588\u2588      \u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588,  \u2588\u2588  \u2588\u2588\u258c    \u2514\u2588\u2588\u258c  \u2588\u2588\u258c     \u2514\u2588\u2588\u258c\\n\u2588\u2588 \u2590\u2588\u258c \u2588\u2588      \u255f\u2588  \u2588\u258c \u255f\u2588     \u2588\u2588\u258c      \u2590\u2588\u2588  \u2588\u2588 \u2514\u2588\u2588\u2588 \u2588\u2588  \u2588\u2588\u258c     \u255f\u2588\u2588 j\u2588\u2588       \u255f\u2588\u2588\\n\u255f\u2588  \u2588\u2588 \u2559\u2588\u2588    \u2584\u2588\u2580 \u2590\u2588\u258c \u2588\u2588     \u2559\u2588\u2588      \u2588\u2588\u258c  \u2588\u2588   \u2559\u2588\u2588\u2588\u2588  \u2588\u2588\u258c    \u2584\u2588\u2588\u2580  \u2588\u2588\u258c     ,\u2588\u2588\u2580\\n \u2588\u2588 \\\"\u2588\u2588, \u2559\u2580\u2580\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2310      \u2559\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2580   \u2588\u2588     \u2559\u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2580\u2580     \u2559\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2580`\\n  \u2588\u2588\u2584 \u2559\u2580\u2588\u2588\u2584\u2584\u2584\u2584\u2584,,,                \u00ac\u2500                                    '\u2500\u00ac\\n   \u2559\u2580\u2588\u2588\u2584 '\u2559\u2559\u2559\u2580\u2580\u2580\u2580\u2580\u2580\u2580\u2580\\n      \u2559\u2580\u2580\u2588\u2588\u2588\u2588\u2588\u2588R\u2310\\n\\n */\\npragma solidity 0.8.16;\\n\\nimport \\\"contracts/interfaces/IAxelarGateway.sol\\\";\\nimport \\\"contracts/external/axelar/AxelarExecutable.sol\\\";\\nimport \\\"contracts/interfaces/IRWALike.sol\\\";\\nimport \\\"contracts/interfaces/IAllowlist.sol\\\";\\nimport \\\"contracts/external/openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"contracts/external/openzeppelin/contracts/security/Pausable.sol\\\";\\nimport \\\"contracts/bridge/MintRateLimiter.sol\\\";\\nimport \\\"contracts/external/openzeppelin/contracts/token/SafeERC20.sol\\\";\\n\\ncontract DestinationBridge is\\n  AxelarExecutable,\\n  MintTimeBasedRateLimiter,\\n  Ownable,\\n  Pausable\\n{\\n  using SafeERC20 for IERC20;\\n  /// @notice Token contract bridged by this contract\\n  IRWALike public immutable TOKEN;\\n\\n  /// @notice Pointer to AxelarGateway contract\\n  IAxelarGateway public immutable AXELAR_GATEWAY;\\n\\n  /// @notice Pointer to USDY allowlist\\n  IAllowlist public immutable ALLOWLIST;\\n\\n  // Mapping used to track approvers, approved msg src's and spent nonces\\n  mapping(address => bool) public approvers;\\n  mapping(string => bytes32) public chainToApprovedSender;\\n  mapping(bytes32 => mapping(uint256 => bool)) public isSpentNonce;\\n\\n  /// @notice Versioning for payload, must match SourceBridge version\\n  bytes32 public constant VERSION = \\\"1.0\\\";\\n\\n  /// @notice Mappings used to track transaction and thresholds\\n  mapping(bytes32 => TxnThreshold) public txnToThresholdSet;\\n  mapping(string => Threshold[]) public chainToThresholds;\\n  mapping(bytes32 => Transaction) public txnHashToTransaction;\\n\\n  constructor(\\n    address _token,\\n    address _axelarGateway,\\n    address _allowlist,\\n    address _ondoApprover,\\n    address _owner,\\n    uint256 _mintLimit,\\n    uint256 _mintDuration\\n  )\\n    AxelarExecutable(_axelarGateway)\\n    MintTimeBasedRateLimiter(_mintDuration, _mintLimit)\\n  {\\n    TOKEN = IRWALike(_token);\\n    AXELAR_GATEWAY = IAxelarGateway(_axelarGateway);\\n    ALLOWLIST = IAllowlist(_allowlist);\\n    approvers[_ondoApprover] = true;\\n    _transferOwnership(_owner);\\n  }\\n\\n  /*//////////////////////////////////////////////////////////////\\n                         Axelar Functions\\n  //////////////////////////////////////////////////////////////*/\\n\\n  /**\\n   * @notice Internal overriden function that is executed when contract is called by Axelar Relayer\\n   *\\n   * @param srcChain The string of the source chain eg: arbitrum\\n   * @param srcAddr  The string of the address of the source contract\\n   * @param payload  The payload to pass cross chain\\n   */\\n  function _execute(\\n    string calldata srcChain,\\n    string calldata srcAddr,\\n    bytes calldata payload\\n  ) internal override whenNotPaused {\\n    (bytes32 version, , address srcSender, uint256 amt, uint256 nonce) = abi\\n      .decode(payload, (bytes32, uint256, address, uint256, uint256));\\n\\n    if (version != VERSION) {\\n      revert InvalidVersion();\\n    }\\n    if (chainToApprovedSender[srcChain] == bytes32(0)) {\\n      revert ChainNotSupported();\\n    }\\n    if (chainToApprovedSender[srcChain] != keccak256(abi.encode(srcAddr))) {\\n      revert SourceNotSupported();\\n    }\\n    if (isSpentNonce[chainToApprovedSender[srcChain]][nonce]) {\\n      revert NonceSpent();\\n    }\\n\\n    isSpentNonce[chainToApprovedSender[srcChain]][nonce] = true;\\n\\n    bytes32 txnHash = keccak256(payload);\\n    txnHashToTransaction[txnHash] = Transaction(srcSender, amt);\\n    _attachThreshold(amt, txnHash, srcChain);\\n    _approve(txnHash);\\n    _mintIfThresholdMet(txnHash);\\n    emit MessageReceived(txnHash, srcChain, srcSender, amt, nonce);\\n  }\\n\\n  /*//////////////////////////////////////////////////////////////\\n                        Internal Functions\\n  //////////////////////////////////////////////////////////////*/\\n\\n  /**\\n   * @notice Internal function used to attach a specific threshold to a given\\n   *         `txnHash`.\\n   *\\n   * @param amount   The amount of the token being bridged\\n   * @param txnHash  The transaction hash to associate the threshold with\\n   * @param srcChain The chain corresponding to the chain that the token\\n   *                 being bridged originated from.\\n   */\\n  function _attachThreshold(\\n    uint256 amount,\\n    bytes32 txnHash,\\n    string memory srcChain\\n  ) internal {\\n    Threshold[] memory thresholds = chainToThresholds[srcChain];\\n    for (uint256 i = 0; i < thresholds.length; ++i) {\\n      Threshold memory t = thresholds[i];\\n      if (amount <= t.amount) {\\n        txnToThresholdSet[txnHash] = TxnThreshold(\\n          t.numberOfApprovalsNeeded,\\n          new address[](0)\\n        );\\n        break;\\n      }\\n    }\\n    if (txnToThresholdSet[txnHash].numberOfApprovalsNeeded == 0) {\\n      revert NoThresholdMatch();\\n    }\\n  }\\n\\n  /**\\n   * @notice Internal function used to approve and conditionally mint for a\\n   *         given txn. Approval is conditional on this approver having not\\n   *         previously approved the txn\\n   *\\n   * @param txnHash The txnHash to approve and conditionally mint to\\n   */\\n  function _approve(bytes32 txnHash) internal {\\n    // Check that the approver has not already approved\\n    TxnThreshold storage t = txnToThresholdSet[txnHash];\\n    uint256 approversLength = t.approvers.length;\\n    if (approversLength > 0) {\\n      for (uint256 i = 0; i < approversLength; ++i) {\\n        if (t.approvers[i] == msg.sender) {\\n          revert AlreadyApproved();\\n        }\\n      }\\n    }\\n    t.approvers.push(msg.sender);\\n    emit TransactionApproved(\\n      txnHash,\\n      msg.sender,\\n      approversLength + 1,\\n      t.numberOfApprovalsNeeded\\n    );\\n  }\\n\\n  /**\\n   * @notice Internal function to mint tokens for a user if the transaction has\\n   *         passed the threshold for number of approvers\\n   *\\n   * @param txnHash The hash of the payload we wish to mint\\n   */\\n  function _mintIfThresholdMet(bytes32 txnHash) internal {\\n    bool thresholdMet = _checkThresholdMet(txnHash);\\n    if (thresholdMet) {\\n      Transaction memory txn = txnHashToTransaction[txnHash];\\n      _checkAndUpdateInstantMintLimit(txn.amount);\\n      if (\\n        address(ALLOWLIST) != address(0) && !ALLOWLIST.isAllowed(txn.sender)\\n      ) {\\n        ALLOWLIST.setAccountStatus(\\n          txn.sender,\\n          ALLOWLIST.getValidTermIndexes()[0],\\n          true\\n        );\\n      }\\n      TOKEN.mint(txn.sender, txn.amount);\\n      // Clear the approval for this bridge payload\\n      delete txnHashToTransaction[txnHash];\\n      emit BridgeCompleted(txn.sender, txn.amount);\\n    }\\n  }\\n\\n  /**\\n   * @notice Internal function used to check if the approval threshold has been\\n   *         met for a given transaction.\\n   *\\n   * @param txnHash The txnHash to check\\n   *\\n   * @dev If an approver has been removed, any previous approvals are still valid\\n   */\\n  function _checkThresholdMet(bytes32 txnHash) internal view returns (bool) {\\n    TxnThreshold storage t = txnToThresholdSet[txnHash];\\n    return t.approvers.length >= t.numberOfApprovalsNeeded;\\n  }\\n\\n  /*//////////////////////////////////////////////////////////////\\n                        Protected Functions\\n  //////////////////////////////////////////////////////////////*/\\n\\n  /**\\n   * @notice Protected Function used to approve messages passed to the\\n   *         Receiver contract. This function is able to be called by any\\n   *         approver that is added and associated with Ondo.\\n   *\\n   * @param txnHash The keccak256 hash of the payload\\n   */\\n  function approve(bytes32 txnHash) external {\\n    if (!approvers[msg.sender]) {\\n      revert NotApprover();\\n    }\\n    _approve(txnHash);\\n    _mintIfThresholdMet(txnHash);\\n  }\\n\\n  /**\\n   * @notice Admin function to add an ondo Signer or Axelar Relayer\\n   *\\n   * @param approver  The address we would like to add\\n   */\\n  function addApprover(address approver) external onlyOwner {\\n    approvers[approver] = true;\\n    emit ApproverAdded(approver);\\n  }\\n\\n  /**\\n   * @notice Admin function to remove an approver\\n   *\\n   * @param approver The address of the approver that we would like to remove\\n   */\\n  function removeApprover(address approver) external onlyOwner {\\n    delete approvers[approver];\\n    emit ApproverRemoved(approver);\\n  }\\n\\n  /**\\n   * @notice Admin function that will allow bridge calls originating from a given address\\n   *         on a given chain.\\n   * @notice This will initialize a nested mapping in which spent nonces from this `srcAddress`\\n   *         are logged and prevented from being reused\\n   *\\n   * @param srcChain            The chain to support\\n   * @param srcContractAddress  The address of the Ondo Bridge on the source chain\\n   *\\n   * @dev srcContractAddress: Is case sensitive and must be the checksum address\\n   * of the srcBridge contract which is allowed to call into this contract.\\n   */\\n  function addChainSupport(\\n    string calldata srcChain,\\n    string calldata srcContractAddress\\n  ) external onlyOwner {\\n    chainToApprovedSender[srcChain] = keccak256(abi.encode(srcContractAddress));\\n    emit ChainIdSupported(srcChain, srcContractAddress);\\n  }\\n\\n  /**\\n   * @notice Admin function that will remove support for previously supported chains\\n   *\\n   * @param srcChain The source chain whose support is being removed\\n   */\\n  function removeChainSupport(string calldata srcChain) external onlyOwner {\\n    delete chainToApprovedSender[srcChain];\\n    emit ChainSupportRemoved(srcChain);\\n  }\\n\\n  /**\\n   * @notice Admin function used to clear and set thresholds corresponding to a chain\\n   *\\n   * @param srcChain       The chain to set the threshold for\\n   * @param amounts        The ordered array of values corresponding to\\n   *                       the amount for a given threshold\\n   * @param numOfApprovers The ordered array of the number of approvals needed\\n   *                       for a given threshold\\n   *\\n   * @dev This function will remove all previously set thresholds for a given chain\\n   *      and will thresholds corresponding to the params of this function. Passing\\n   *      in empty arrays will remove all thresholds for a given chain\\n   */\\n  function setThresholds(\\n    string calldata srcChain,\\n    uint256[] calldata amounts,\\n    uint256[] calldata numOfApprovers\\n  ) external onlyOwner {\\n    if (amounts.length != numOfApprovers.length) {\\n      revert ArrayLengthMismatch();\\n    }\\n    delete chainToThresholds[srcChain];\\n    for (uint256 i = 0; i < amounts.length; ++i) {\\n      if (numOfApprovers[i] == 0) {\\n        revert NumOfApproversCannotBeZero();\\n      }\\n      if (i == 0) {\\n        chainToThresholds[srcChain].push(\\n          Threshold(amounts[i], numOfApprovers[i])\\n        );\\n      } else {\\n        if (chainToThresholds[srcChain][i - 1].amount > amounts[i]) {\\n          revert ThresholdsNotInAscendingOrder();\\n        }\\n        chainToThresholds[srcChain].push(\\n          Threshold(amounts[i], numOfApprovers[i])\\n        );\\n      }\\n    }\\n    emit ThresholdSet(srcChain, amounts, numOfApprovers);\\n  }\\n\\n  /**\\n   * @notice Admin function used to set the mint limit\\n   *\\n   * @param mintLimit The new mint limit\\n   */\\n  function setMintLimit(uint256 mintLimit) external onlyOwner {\\n    _setMintLimit(mintLimit);\\n  }\\n\\n  /**\\n   * @notice Admin function used to set the mint duration\\n   *\\n   * @param mintDuration The new mint duration\\n   */\\n  function setMintLimitDuration(uint256 mintDuration) external onlyOwner {\\n    _setMintLimitDuration(mintDuration);\\n  }\\n\\n  /**\\n   * @notice Admin function used to pause the contract\\n   *\\n   * @dev Only used for bridge functions\\n   */\\n  function pause() external onlyOwner {\\n    _pause();\\n  }\\n\\n  /**\\n   * @notice Admin function used to unpause the contract\\n   *\\n   * @dev Only used for bridge functions\\n   */\\n  function unpause() external onlyOwner {\\n    _unpause();\\n  }\\n\\n  /**\\n   * @notice Admin function used to rescue ERC20 Tokens sent to the contract\\n   *\\n   * @param _token The address of the token to rescue\\n   */\\n  function rescueTokens(address _token) external onlyOwner {\\n    uint256 balance = IERC20(_token).balanceOf(address(this));\\n    IERC20(_token).safeTransfer(owner(), balance);\\n  }\\n\\n  /*//////////////////////////////////////////////////////////////\\n                       Helper Functions\\n  //////////////////////////////////////////////////////////////*/\\n\\n  /**\\n   * @notice External view function used to get the number of approvers for a\\n   *         given txnHash\\n   *\\n   * @param txnHash The hash to get the number of approvers for\\n   */\\n  function getNumApproved(bytes32 txnHash) external view returns (uint256) {\\n    return txnToThresholdSet[txnHash].approvers.length;\\n  }\\n\\n  /*//////////////////////////////////////////////////////////////\\n                      Structs, Events, Errors\\n  //////////////////////////////////////////////////////////////*/\\n\\n  struct Threshold {\\n    uint256 amount;\\n    uint256 numberOfApprovalsNeeded;\\n  }\\n\\n  struct TxnThreshold {\\n    uint256 numberOfApprovalsNeeded;\\n    address[] approvers;\\n  }\\n\\n  struct Transaction {\\n    address sender;\\n    uint256 amount;\\n  }\\n\\n  /**\\n   * @notice event emitted when an address is removed as an approver\\n   *\\n   * @param approver The address being removed\\n   */\\n  event ApproverRemoved(address approver);\\n\\n  /**\\n   * @notice event emitted when an address is added as an approver\\n   *\\n   * @param approver  The address to add\\n   */\\n  event ApproverAdded(address approver);\\n\\n  /**\\n   * @notice event emitted when a new contract is whitelisted as an approved\\n   *         message passer.\\n   *\\n   * @param srcChain        The chain for the approved address\\n   * @param approvedSource  The address corresponding to the source bridge contract\\n   */\\n  event ChainIdSupported(string indexed srcChain, string approvedSource);\\n\\n  /**\\n   * @notice event emitted when a threshold has been set\\n   *\\n   * @param chain           The chain for which the threshold was set\\n   * @param amounts         The amount of tokens to reach this threshold\\n   * @param numOfApprovers  The number of approvals needed\\n   */\\n  event ThresholdSet(\\n    string indexed chain,\\n    uint256[] amounts,\\n    uint256[] numOfApprovers\\n  );\\n\\n  /**\\n   * @notice event emitted when the user has been minted their tokens on the dst chain\\n   *\\n   * @param user    The recipient address of the newly minted tokens\\n   * @param amount  The amount of tokens that have been minted\\n   */\\n  event BridgeCompleted(address indexed user, uint256 amount);\\n\\n  /**\\n   * @notice event emitted when this bridge contract receives a cross chain message\\n   *\\n   * @param txnHash   The hash of the payload that has been bridged\\n   * @param srcChain  The chain from which the message is originating\\n   * @param srcSender The address of the msg.sender on the source chain\\n   * @param amt       The amount of tokens being bridged\\n   * @param nonce     The nonce corresponding to the contract which originated the msg\\n   */\\n  event MessageReceived(\\n    bytes32 indexed txnHash,\\n    string indexed srcChain,\\n    address indexed srcSender,\\n    uint256 amt,\\n    uint256 nonce\\n  );\\n\\n  /**\\n   * @notice event emitted when a transaction has been approved\\n   *\\n   * @param txnHash              The hash of the payload that has been approved\\n   * @param approver             The address of the approver\\n   * @param numApprovers         The number of approvers for this transaction\\n   * @param thresholdRequirement The number of approvals needed for this transaction\\n   */\\n  event TransactionApproved(\\n    bytes32 indexed txnHash,\\n    address approver,\\n    uint256 numApprovers,\\n    uint256 thresholdRequirement\\n  );\\n\\n  /**\\n   * @notice event emitted when support for a chain is removed\\n   *\\n   * @param srcChain The chain whose support is being removed\\n   */\\n  event ChainSupportRemoved(string indexed srcChain);\\n\\n  error NotApprover();\\n  error NoThresholdMatch();\\n  error ThresholdsNotInAscendingOrder();\\n\\n  error ChainNotSupported();\\n  error SourceNotSupported();\\n  error NonceSpent();\\n  error AlreadyApproved();\\n  error InvalidVersion();\\n  error ArrayLengthMismatch();\\n  error NumOfApproversCannotBeZero();\\n}\\n\"\r\n    },\r\n    \"contracts/bridge/MintRateLimiter.sol\": {\r\n      \"content\": \"/**SPDX-License-Identifier: BUSL-1.1\\n\\n      \u2584\u2584\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2584\\n   \u2553\u2588\u2588\u2580\u2514 ,\u2553\u2584\u2584\u2584, '\u2580\u2588\u2588\u2584\\n  \u2588\u2588\u2580 \u2584\u2588\u2588\u2580\u2580\u2559\u2559\u2580\u2580\u2588\u2588\u2584 \u2514\u2588\u2588\u00b5           ,,       ,,      ,     ,,,            ,,,\\n \u2588\u2588 ,\u2588\u2588\u00ac \u2584\u2588\u2588\u2588\u2588\u2584  \u2580\u2588\u2584 \u2559\u2588\u2584      \u2584\u2588\u2588\u2588\u2580\u2580\u2588\u2588\u2588\u2584   \u2588\u2588\u2588\u2584    \u2588\u2588  \u2588\u2588\u2588\u2580\u2580\u2580\u2588\u2588\u2588\u2584    \u2584\u2588\u2588\u2588\u2580\u2580\u2588\u2588\u2588,\\n\u2588\u2588  \u2588\u2588 \u2552\u2588\u2580'   \u2559\u2588\u258c \u2559\u2588\u258c \u2588\u2588     \u2590\u2588\u2588      \u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588,  \u2588\u2588  \u2588\u2588\u258c    \u2514\u2588\u2588\u258c  \u2588\u2588\u258c     \u2514\u2588\u2588\u258c\\n\u2588\u2588 \u2590\u2588\u258c \u2588\u2588      \u255f\u2588  \u2588\u258c \u255f\u2588     \u2588\u2588\u258c      \u2590\u2588\u2588  \u2588\u2588 \u2514\u2588\u2588\u2588 \u2588\u2588  \u2588\u2588\u258c     \u255f\u2588\u2588 j\u2588\u2588       \u255f\u2588\u2588\\n\u255f\u2588  \u2588\u2588 \u2559\u2588\u2588    \u2584\u2588\u2580 \u2590\u2588\u258c \u2588\u2588     \u2559\u2588\u2588      \u2588\u2588\u258c  \u2588\u2588   \u2559\u2588\u2588\u2588\u2588  \u2588\u2588\u258c    \u2584\u2588\u2588\u2580  \u2588\u2588\u258c     ,\u2588\u2588\u2580\\n \u2588\u2588 \\\"\u2588\u2588, \u2559\u2580\u2580\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2310      \u2559\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2580   \u2588\u2588     \u2559\u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2580\u2580     \u2559\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2580`\\n  \u2588\u2588\u2584 \u2559\u2580\u2588\u2588\u2584\u2584\u2584\u2584\u2584,,,                \u00ac\u2500                                    '\u2500\u00ac\\n   \u2559\u2580\u2588\u2588\u2584 '\u2559\u2559\u2559\u2580\u2580\u2580\u2580\u2580\u2580\u2580\u2580\\n      \u2559\u2580\u2580\u2588\u2588\u2588\u2588\u2588\u2588R\u2310\\n\\n */\\npragma solidity 0.8.16;\\n\\n/**\\n * @title InstantMintTimeBasedRateLimiter\\n *\\n * @notice This abstract contract implements two rate limiters: one for minting\\n *         and one for redeeming. Each limit is completely independent: mints\\n *         and redemption don't offset each other. Each limit is associated\\n *         with a duration, after which the tracked amount is reset. The\\n *         amounts tracked are agnostic to a specific token; the usage is\\n *         determined by the inheriting contracts.\\n *\\n * @dev Although this contract has all of its functions implemented, this\\n *      contract is marked abstract to prevent an accidental deployment and to\\n *      signify that we would never deploy this contract standalone.\\n *\\n */\\nabstract contract MintTimeBasedRateLimiter {\\n  // `currentMintAmount` resets after this interval (in seconds)\\n  uint256 public resetMintDuration;\\n  // timestamp when `currentMintAmount` was last reset\\n  uint256 public lastResetMintTime;\\n\\n  // maximum amount that can be minted during a `resetMintDuration` window\\n  uint256 public mintLimit;\\n  // amount already minted during the current `resetMintDuration` window\\n  uint256 public currentMintAmount;\\n\\n  /**\\n   * @notice In the constructor, we initialize the variables for the mint and\\n   *         redemption rate limiters.\\n   *\\n   * @param _mintResetDuration   `currentMintAmount` resets after this interval\\n   *                                    (in seconds)\\n   * @param _instantMintLimit           maximum amount that can be minted during a\\n   *                                    `resetMintDuration` window\\n   *\\n   * @dev If a duration is zero, the limit resets before each mint/redemption.\\n   * @dev If a limit is zero, the relevant check always fails.\\n   */\\n  constructor(uint256 _mintResetDuration, uint256 _instantMintLimit) {\\n    resetMintDuration = _mintResetDuration; // can be zero for per-block limit\\n    mintLimit = _instantMintLimit; // can be zero to disable minting\\n\\n    lastResetMintTime = block.timestamp;\\n  }\\n\\n  /**\\n   * @notice Checks the requested mint amount against the rate limiter (and\\n   *         updates the remaining amount)\\n   *\\n   * @param amount The requested mint amount\\n   *\\n   * @dev Reverts if the requested mint amount exceeds the current limit\\n   */\\n  function _checkAndUpdateInstantMintLimit(uint256 amount) internal {\\n    require(amount > 0, \\\"RateLimit: mint amount can't be zero\\\");\\n\\n    if (block.timestamp >= lastResetMintTime + resetMintDuration) {\\n      // time has passed, reset\\n      currentMintAmount = 0;\\n      lastResetMintTime = block.timestamp;\\n    }\\n    require(\\n      amount <= mintLimit - currentMintAmount,\\n      \\\"RateLimit: Mint exceeds rate limit\\\"\\n    );\\n\\n    currentMintAmount += amount;\\n  }\\n\\n  /**\\n   * @notice Update the amount of token that can be minted during one duration\\n   *\\n   * @param _mintLimit The token amount\\n   *\\n   * @dev If a limit is zero, the relevant check always fails.\\n   */\\n  function _setMintLimit(uint256 _mintLimit) internal {\\n    mintLimit = _mintLimit;\\n    emit MintLimitSet(_mintLimit);\\n  }\\n\\n  /**\\n   * @notice Update the duration for the mint rate limiter\\n   *\\n   * @param _mintResetDuration The duration in seconds\\n   *\\n   * @dev If a duration is zero, the limit resets before each mint/redemption\\n   */\\n  function _setMintLimitDuration(uint256 _mintResetDuration) internal {\\n    resetMintDuration = _mintResetDuration;\\n    emit MintLimitDurationSet(_mintResetDuration);\\n  }\\n\\n  /**\\n   * @notice Event emitted when mint limit is set\\n   *\\n   * @param mintLimit How much of some token can be minted within\\n   *                  an interval of length `resetMintDuration`\\n   *\\n   * @dev See inheriting contract for representation\\n   */\\n  event MintLimitSet(uint256 mintLimit);\\n\\n  /**\\n   * @notice Event emitted when mint limit duration is set\\n   *\\n   * @param instantMintLimitDuration The time window in which `mintLimit`\\n   *                          of some token can be minted\\n   *\\n   * @dev instantMintLimitDuration is specified in seconds\\n   */\\n  event MintLimitDurationSet(uint256 instantMintLimitDuration);\\n}\\n\"\r\n    },\r\n    \"contracts/external/axelar/AxelarExecutable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport {IAxelarGateway} from \\\"../../interfaces/IAxelarGateway.sol\\\";\\nimport {IAxelarExecutable} from \\\"../../interfaces/IAxelarExecutable.sol\\\";\\n\\ncontract AxelarExecutable is IAxelarExecutable {\\n  IAxelarGateway public immutable gateway;\\n\\n  constructor(address gateway_) {\\n    if (gateway_ == address(0)) revert InvalidAddress();\\n\\n    gateway = IAxelarGateway(gateway_);\\n  }\\n\\n  function execute(\\n    bytes32 commandId,\\n    string calldata sourceChain,\\n    string calldata sourceAddress,\\n    bytes calldata payload\\n  ) external {\\n    bytes32 payloadHash = keccak256(payload);\\n\\n    if (\\n      !gateway.validateContractCall(\\n        commandId,\\n        sourceChain,\\n        sourceAddress,\\n        payloadHash\\n      )\\n    ) revert NotApprovedByGateway();\\n\\n    _execute(sourceChain, sourceAddress, payload);\\n  }\\n\\n  function executeWithToken(\\n    bytes32 commandId,\\n    string calldata sourceChain,\\n    string calldata sourceAddress,\\n    bytes calldata payload,\\n    string calldata tokenSymbol,\\n    uint256 amount\\n  ) external {\\n    bytes32 payloadHash = keccak256(payload);\\n\\n    if (\\n      !gateway.validateContractCallAndMint(\\n        commandId,\\n        sourceChain,\\n        sourceAddress,\\n        payloadHash,\\n        tokenSymbol,\\n        amount\\n      )\\n    ) revert NotApprovedByGateway();\\n\\n    _executeWithToken(sourceChain, sourceAddress, payload, tokenSymbol, amount);\\n  }\\n\\n  function _execute(\\n    string calldata sourceChain,\\n    string calldata sourceAddress,\\n    bytes calldata payload\\n  ) internal virtual {}\\n\\n  // false detection from slither\\n  // slither-disable-next-line dead-code\\n  function _executeWithToken(\\n    string calldata sourceChain,\\n    string calldata sourceAddress,\\n    bytes calldata payload,\\n    string calldata tokenSymbol,\\n    uint256 amount\\n  ) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"contracts/external/openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"contracts/external/openzeppelin/contracts/utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n  address private _owner;\\n\\n  event OwnershipTransferred(\\n    address indexed previousOwner,\\n    address indexed newOwner\\n  );\\n\\n  /**\\n   * @dev Initializes the contract setting the deployer as the initial owner.\\n   */\\n  constructor() {\\n    _transferOwnership(_msgSender());\\n  }\\n\\n  /**\\n   * @dev Returns the address of the current owner.\\n   */\\n  function owner() public view virtual returns (address) {\\n    return _owner;\\n  }\\n\\n  /**\\n   * @dev Throws if called by any account other than the owner.\\n   */\\n  modifier onlyOwner() {\\n    require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    _;\\n  }\\n\\n  /**\\n   * @dev Leaves the contract without owner. It will not be possible to call\\n   * `onlyOwner` functions anymore. Can only be called by the current owner.\\n   *\\n   * NOTE: Renouncing ownership will leave the contract without an owner,\\n   * thereby removing any functionality that is only available to the owner.\\n   */\\n  function renounceOwnership() public virtual onlyOwner {\\n    _transferOwnership(address(0));\\n  }\\n\\n  /**\\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n   * Can only be called by the current owner.\\n   */\\n  function transferOwnership(address newOwner) public virtual onlyOwner {\\n    require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n    _transferOwnership(newOwner);\\n  }\\n\\n  /**\\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n   * Internal function without access restriction.\\n   */\\n  function _transferOwnership(address newOwner) internal virtual {\\n    address oldOwner = _owner;\\n    _owner = newOwner;\\n    emit OwnershipTransferred(oldOwner, newOwner);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/external/openzeppelin/contracts/security/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"contracts/external/openzeppelin/contracts/utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context {\\n  /**\\n   * @dev Emitted when the pause is triggered by `account`.\\n   */\\n  event Paused(address account);\\n\\n  /**\\n   * @dev Emitted when the pause is lifted by `account`.\\n   */\\n  event Unpaused(address account);\\n\\n  bool private _paused;\\n\\n  /**\\n   * @dev Initializes the contract in unpaused state.\\n   */\\n  constructor() {\\n    _paused = false;\\n  }\\n\\n  /**\\n   * @dev Returns true if the contract is paused, and false otherwise.\\n   */\\n  function paused() public view virtual returns (bool) {\\n    return _paused;\\n  }\\n\\n  /**\\n   * @dev Modifier to make a function callable only when the contract is not paused.\\n   *\\n   * Requirements:\\n   *\\n   * - The contract must not be paused.\\n   */\\n  modifier whenNotPaused() {\\n    require(!paused(), \\\"Pausable: paused\\\");\\n    _;\\n  }\\n\\n  /**\\n   * @dev Modifier to make a function callable only when the contract is paused.\\n   *\\n   * Requirements:\\n   *\\n   * - The contract must be paused.\\n   */\\n  modifier whenPaused() {\\n    require(paused(), \\\"Pausable: not paused\\\");\\n    _;\\n  }\\n\\n  /**\\n   * @dev Triggers stopped state.\\n   *\\n   * Requirements:\\n   *\\n   * - The contract must not be paused.\\n   */\\n  function _pause() internal virtual whenNotPaused {\\n    _paused = true;\\n    emit Paused(_msgSender());\\n  }\\n\\n  /**\\n   * @dev Returns to normal state.\\n   *\\n   * Requirements:\\n   *\\n   * - The contract must be paused.\\n   */\\n  function _unpause() internal virtual whenPaused {\\n    _paused = false;\\n    emit Unpaused(_msgSender());\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/external/openzeppelin/contracts/token/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n  /**\\n   * @dev Returns the amount of tokens in existence.\\n   */\\n  function totalSupply() external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the amount of tokens owned by `account`.\\n   */\\n  function balanceOf(address account) external view returns (uint256);\\n\\n  /**\\n   * @dev Moves `amount` tokens from the caller's account to `to`.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transfer(address to, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Returns the remaining number of tokens that `spender` will be\\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n   * zero by default.\\n   *\\n   * This value changes when {approve} or {transferFrom} are called.\\n   */\\n  function allowance(address owner, address spender)\\n    external\\n    view\\n    returns (uint256);\\n\\n  /**\\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n   * that someone may use both the old and the new allowance by unfortunate\\n   * transaction ordering. One possible solution to mitigate this race\\n   * condition is to first reduce the spender's allowance to 0 and set the\\n   * desired value afterwards:\\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n   *\\n   * Emits an {Approval} event.\\n   */\\n  function approve(address spender, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Moves `amount` tokens from `from` to `to` using the\\n   * allowance mechanism. `amount` is then deducted from the caller's\\n   * allowance.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transferFrom(\\n    address from,\\n    address to,\\n    uint256 amount\\n  ) external returns (bool);\\n\\n  /**\\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n   * another (`to`).\\n   *\\n   * Note that `value` may be zero.\\n   */\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n  /**\\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n   * a call to {approve}. `value` is the new allowance.\\n   */\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/external/openzeppelin/contracts/token/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"contracts/external/openzeppelin/contracts/token/IERC20.sol\\\";\\nimport \\\"contracts/external/openzeppelin/contracts/utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n  using Address for address;\\n\\n  function safeTransfer(\\n    IERC20 token,\\n    address to,\\n    uint256 value\\n  ) internal {\\n    _callOptionalReturn(\\n      token,\\n      abi.encodeWithSelector(token.transfer.selector, to, value)\\n    );\\n  }\\n\\n  function safeTransferFrom(\\n    IERC20 token,\\n    address from,\\n    address to,\\n    uint256 value\\n  ) internal {\\n    _callOptionalReturn(\\n      token,\\n      abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\\n    );\\n  }\\n\\n  /**\\n   * @dev Deprecated. This function has issues similar to the ones found in\\n   * {IERC20-approve}, and its usage is discouraged.\\n   *\\n   * Whenever possible, use {safeIncreaseAllowance} and\\n   * {safeDecreaseAllowance} instead.\\n   */\\n  function safeApprove(\\n    IERC20 token,\\n    address spender,\\n    uint256 value\\n  ) internal {\\n    // safeApprove should only be called when setting an initial allowance,\\n    // or when resetting it to zero. To increase and decrease it, use\\n    // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n    require(\\n      (value == 0) || (token.allowance(address(this), spender) == 0),\\n      \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n    );\\n    _callOptionalReturn(\\n      token,\\n      abi.encodeWithSelector(token.approve.selector, spender, value)\\n    );\\n  }\\n\\n  function safeIncreaseAllowance(\\n    IERC20 token,\\n    address spender,\\n    uint256 value\\n  ) internal {\\n    uint256 newAllowance = token.allowance(address(this), spender) + value;\\n    _callOptionalReturn(\\n      token,\\n      abi.encodeWithSelector(token.approve.selector, spender, newAllowance)\\n    );\\n  }\\n\\n  function safeDecreaseAllowance(\\n    IERC20 token,\\n    address spender,\\n    uint256 value\\n  ) internal {\\n    unchecked {\\n      uint256 oldAllowance = token.allowance(address(this), spender);\\n      require(\\n        oldAllowance >= value,\\n        \\\"SafeERC20: decreased allowance below zero\\\"\\n      );\\n      uint256 newAllowance = oldAllowance - value;\\n      _callOptionalReturn(\\n        token,\\n        abi.encodeWithSelector(token.approve.selector, spender, newAllowance)\\n      );\\n    }\\n  }\\n\\n  /**\\n   * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n   * on the return value: the return value is optional (but if data is returned, it must not be false).\\n   * @param token The token targeted by the call.\\n   * @param data The call data (encoded using abi.encode or one of its variants).\\n   */\\n  function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n    // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n    // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n    // the target address contains contract code and also asserts for success in the low-level call.\\n\\n    bytes memory returndata =\\n      address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n    if (returndata.length > 0) {\\n      // Return data is optional\\n      require(\\n        abi.decode(returndata, (bool)),\\n        \\\"SafeERC20: ERC20 operation did not succeed\\\"\\n      );\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/external/openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n  /**\\n   * @dev Returns true if `account` is a contract.\\n   *\\n   * [IMPORTANT]\\n   * ====\\n   * It is unsafe to assume that an address for which this function returns\\n   * false is an externally-owned account (EOA) and not a contract.\\n   *\\n   * Among others, `isContract` will return false for the following\\n   * types of addresses:\\n   *\\n   *  - an externally-owned account\\n   *  - a contract in construction\\n   *  - an address where a contract will be created\\n   *  - an address where a contract lived, but was destroyed\\n   * ====\\n   *\\n   * [IMPORTANT]\\n   * ====\\n   * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n   *\\n   * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n   * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n   * constructor.\\n   * ====\\n   */\\n  function isContract(address account) internal view returns (bool) {\\n    // This method relies on extcodesize/address.code.length, which returns 0\\n    // for contracts in construction, since the code is only stored at the end\\n    // of the constructor execution.\\n\\n    return account.code.length > 0;\\n  }\\n\\n  /**\\n   * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n   * `recipient`, forwarding all available gas and reverting on errors.\\n   *\\n   * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n   * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n   * imposed by `transfer`, making them unable to receive funds via\\n   * `transfer`. {sendValue} removes this limitation.\\n   *\\n   * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n   *\\n   * IMPORTANT: because control is transferred to `recipient`, care must be\\n   * taken to not create reentrancy vulnerabilities. Consider using\\n   * {ReentrancyGuard} or the\\n   * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n   */\\n  function sendValue(address payable recipient, uint256 amount) internal {\\n    require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n    (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n    require(\\n      success,\\n      \\\"Address: unable to send value, recipient may have reverted\\\"\\n    );\\n  }\\n\\n  /**\\n   * @dev Performs a Solidity function call using a low level `call`. A\\n   * plain `call` is an unsafe replacement for a function call: use this\\n   * function instead.\\n   *\\n   * If `target` reverts with a revert reason, it is bubbled up by this\\n   * function (like regular Solidity function calls).\\n   *\\n   * Returns the raw returned data. To convert to the expected return value,\\n   * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n   *\\n   * Requirements:\\n   *\\n   * - `target` must be a contract.\\n   * - calling `target` with `data` must not revert.\\n   *\\n   * _Available since v3.1._\\n   */\\n  function functionCall(address target, bytes memory data)\\n    internal\\n    returns (bytes memory)\\n  {\\n    return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n   * `errorMessage` as a fallback revert reason when `target` reverts.\\n   *\\n   * _Available since v3.1._\\n   */\\n  function functionCall(\\n    address target,\\n    bytes memory data,\\n    string memory errorMessage\\n  ) internal returns (bytes memory) {\\n    return functionCallWithValue(target, data, 0, errorMessage);\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n   * but also transferring `value` wei to `target`.\\n   *\\n   * Requirements:\\n   *\\n   * - the calling contract must have an ETH balance of at least `value`.\\n   * - the called Solidity function must be `payable`.\\n   *\\n   * _Available since v3.1._\\n   */\\n  function functionCallWithValue(\\n    address target,\\n    bytes memory data,\\n    uint256 value\\n  ) internal returns (bytes memory) {\\n    return\\n      functionCallWithValue(\\n        target,\\n        data,\\n        value,\\n        \\\"Address: low-level call with value failed\\\"\\n      );\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n   * with `errorMessage` as a fallback revert reason when `target` reverts.\\n   *\\n   * _Available since v3.1._\\n   */\\n  function functionCallWithValue(\\n    address target,\\n    bytes memory data,\\n    uint256 value,\\n    string memory errorMessage\\n  ) internal returns (bytes memory) {\\n    require(\\n      address(this).balance >= value,\\n      \\\"Address: insufficient balance for call\\\"\\n    );\\n    require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n    (bool success, bytes memory returndata) = target.call{value: value}(data);\\n    return verifyCallResult(success, returndata, errorMessage);\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n   * but performing a static call.\\n   *\\n   * _Available since v3.3._\\n   */\\n  function functionStaticCall(address target, bytes memory data)\\n    internal\\n    view\\n    returns (bytes memory)\\n  {\\n    return\\n      functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n   * but performing a static call.\\n   *\\n   * _Available since v3.3._\\n   */\\n  function functionStaticCall(\\n    address target,\\n    bytes memory data,\\n    string memory errorMessage\\n  ) internal view returns (bytes memory) {\\n    require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n    (bool success, bytes memory returndata) = target.staticcall(data);\\n    return verifyCallResult(success, returndata, errorMessage);\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n   * but performing a delegate call.\\n   *\\n   * _Available since v3.4._\\n   */\\n  function functionDelegateCall(address target, bytes memory data)\\n    internal\\n    returns (bytes memory)\\n  {\\n    return\\n      functionDelegateCall(\\n        target,\\n        data,\\n        \\\"Address: low-level delegate call failed\\\"\\n      );\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n   * but performing a delegate call.\\n   *\\n   * _Available since v3.4._\\n   */\\n  function functionDelegateCall(\\n    address target,\\n    bytes memory data,\\n    string memory errorMessage\\n  ) internal returns (bytes memory) {\\n    require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n    (bool success, bytes memory returndata) = target.delegatecall(data);\\n    return verifyCallResult(success, returndata, errorMessage);\\n  }\\n\\n  /**\\n   * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n   * revert reason using the provided one.\\n   *\\n   * _Available since v4.3._\\n   */\\n  function verifyCallResult(\\n    bool success,\\n    bytes memory returndata,\\n    string memory errorMessage\\n  ) internal pure returns (bytes memory) {\\n    if (success) {\\n      return returndata;\\n    } else {\\n      // Look for revert reason and bubble it up if present\\n      if (returndata.length > 0) {\\n        // The easiest way to bubble the revert reason is using memory via assembly\\n\\n        assembly {\\n          let returndata_size := mload(returndata)\\n          revert(add(32, returndata), returndata_size)\\n        }\\n      } else {\\n        revert(errorMessage);\\n      }\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/external/openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n  function _msgSender() internal view virtual returns (address) {\\n    return msg.sender;\\n  }\\n\\n  function _msgData() internal view virtual returns (bytes calldata) {\\n    return msg.data;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IAllowlist.sol\": {\r\n      \"content\": \"/**SPDX-License-Identifier: BUSL-1.1\\n\\n      \u2584\u2584\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2584\\n   \u2553\u2588\u2588\u2580\u2514 ,\u2553\u2584\u2584\u2584, '\u2580\u2588\u2588\u2584\\n  \u2588\u2588\u2580 \u2584\u2588\u2588\u2580\u2580\u2559\u2559\u2580\u2580\u2588\u2588\u2584 \u2514\u2588\u2588\u00b5           ,,       ,,      ,     ,,,            ,,,\\n \u2588\u2588 ,\u2588\u2588\u00ac \u2584\u2588\u2588\u2588\u2588\u2584  \u2580\u2588\u2584 \u2559\u2588\u2584      \u2584\u2588\u2588\u2588\u2580\u2580\u2588\u2588\u2588\u2584   \u2588\u2588\u2588\u2584    \u2588\u2588  \u2588\u2588\u2588\u2580\u2580\u2580\u2588\u2588\u2588\u2584    \u2584\u2588\u2588\u2588\u2580\u2580\u2588\u2588\u2588,\\n\u2588\u2588  \u2588\u2588 \u2552\u2588\u2580'   \u2559\u2588\u258c \u2559\u2588\u258c \u2588\u2588     \u2590\u2588\u2588      \u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588,  \u2588\u2588  \u2588\u2588\u258c    \u2514\u2588\u2588\u258c  \u2588\u2588\u258c     \u2514\u2588\u2588\u258c\\n\u2588\u2588 \u2590\u2588\u258c \u2588\u2588      \u255f\u2588  \u2588\u258c \u255f\u2588     \u2588\u2588\u258c      \u2590\u2588\u2588  \u2588\u2588 \u2514\u2588\u2588\u2588 \u2588\u2588  \u2588\u2588\u258c     \u255f\u2588\u2588 j\u2588\u2588       \u255f\u2588\u2588\\n\u255f\u2588  \u2588\u2588 \u2559\u2588\u2588    \u2584\u2588\u2580 \u2590\u2588\u258c \u2588\u2588     \u2559\u2588\u2588      \u2588\u2588\u258c  \u2588\u2588   \u2559\u2588\u2588\u2588\u2588  \u2588\u2588\u258c    \u2584\u2588\u2588\u2580  \u2588\u2588\u258c     ,\u2588\u2588\u2580\\n \u2588\u2588 \\\"\u2588\u2588, \u2559\u2580\u2580\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2310      \u2559\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2580   \u2588\u2588     \u2559\u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2580\u2580     \u2559\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2580`\\n  \u2588\u2588\u2584 \u2559\u2580\u2588\u2588\u2584\u2584\u2584\u2584\u2584,,,                \u00ac\u2500                                    '\u2500\u00ac\\n   \u2559\u2580\u2588\u2588\u2584 '\u2559\u2559\u2559\u2580\u2580\u2580\u2580\u2580\u2580\u2580\u2580\\n      \u2559\u2580\u2580\u2588\u2588\u2588\u2588\u2588\u2588R\u2310\\n\\n */\\npragma solidity 0.8.16;\\n\\ninterface IAllowlist {\\n  function addTerm(string calldata term) external;\\n\\n  function setCurrentTermIndex(uint256 _currentTermIndex) external;\\n\\n  function setValidTermIndexes(uint256[] calldata indexes) external;\\n\\n  function isAllowed(address account) external view returns (bool);\\n\\n  function getCurrentTerm() external view returns (string memory);\\n\\n  function currentTermIndex() external view returns (uint256);\\n\\n  function getValidTermIndexes() external view returns (uint256[] memory);\\n\\n  function addAccountToAllowlist(\\n    uint256 _currentTermIndex,\\n    address account,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) external;\\n\\n  function addSelfToAllowlist(uint256 termIndex) external;\\n\\n  function setAccountStatus(\\n    address account,\\n    uint256 termIndex,\\n    bool status\\n  ) external;\\n\\n  /**\\n   * @notice Event emitted when a term is added\\n   *\\n   * @param hashedMessage The hash of the terms string that was added\\n   * @param termIndex     The index of the term that was added\\n   */\\n  event TermAdded(bytes32 hashedMessage, uint256 termIndex);\\n\\n  /**\\n   * @notice Event emitted when the current term index is set\\n   *\\n   * @param oldIndex The old current term index\\n   * @param newIndex The new current term index\\n   */\\n  event CurrentTermIndexSet(uint256 oldIndex, uint256 newIndex);\\n\\n  /**\\n   * @notice Event emitted when the valid term indexes are set\\n   *\\n   * @param oldIndexes The old valid term indexes\\n   * @param newIndexes The new valid term indexes\\n   */\\n  event ValidTermIndexesSet(uint256[] oldIndexes, uint256[] newIndexes);\\n\\n  /**\\n   * @notice Event emitted when an accoun status is set by an admin\\n   *\\n   * @param account   The account whose status was set\\n   * @param termIndex The term index of the account whose status that was set\\n   * @param status    The new status of the account\\n   */\\n  event AccountStatusSetByAdmin(\\n    address indexed account,\\n    uint256 indexed termIndex,\\n    bool status\\n  );\\n\\n  /**\\n   * @notice Event emitted when an account adds itself added to the allowlist\\n   *\\n   * @param account   The account that was added\\n   * @param termIndex The term index for which the account was added\\n   */\\n  event AccountAddedSelf(address indexed account, uint256 indexed termIndex);\\n\\n  /**\\n   * @notice Event emitted when an account is added to the allowlist by a signature\\n   *\\n   * @param account   The account that was added\\n   * @param termIndex The term index for which the account was added\\n   * @param v         The v value of the signature\\n   * @param r         The r value of the signature\\n   * @param s         The s value of the signature\\n   */\\n  event AccountAddedFromSignature(\\n    address indexed account,\\n    uint256 indexed termIndex,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  );\\n\\n  /**\\n   * @notice Event emitted when an account status is set\\n   *\\n   * @param account   The account whose status was set\\n   * @param termIndex The term index of the account whose status was set\\n   * @param status    The new status of the account\\n   */\\n  event AccountStatusSet(\\n    address indexed account,\\n    uint256 indexed termIndex,\\n    bool status\\n  );\\n\\n  /// ERRORS ///\\n  error InvalidTermIndex();\\n  error InvalidVSignature();\\n  error AlreadyVerified();\\n  error InvalidSigner();\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IAxelarExecutable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport {IAxelarGateway} from \\\"./IAxelarGateway.sol\\\";\\n\\ninterface IAxelarExecutable {\\n  error InvalidAddress();\\n  error NotApprovedByGateway();\\n\\n  function gateway() external view returns (IAxelarGateway);\\n\\n  function execute(\\n    bytes32 commandId,\\n    string calldata sourceChain,\\n    string calldata sourceAddress,\\n    bytes calldata payload\\n  ) external;\\n\\n  function executeWithToken(\\n    bytes32 commandId,\\n    string calldata sourceChain,\\n    string calldata sourceAddress,\\n    bytes calldata payload,\\n    string calldata tokenSymbol,\\n    uint256 amount\\n  ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IAxelarGateway.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\ninterface IAxelarGateway {\\n  function callContract(\\n    string calldata destinationChain,\\n    string calldata contractAddress,\\n    bytes calldata payload\\n  ) external;\\n\\n  function validateContractCall(\\n    bytes32 commandId,\\n    string calldata sourceChain,\\n    string calldata sourceAddress,\\n    bytes32 payloadHash\\n  ) external returns (bool);\\n\\n  function validateContractCallAndMint(\\n    bytes32 commandId,\\n    string calldata sourceChain,\\n    string calldata sourceAddress,\\n    bytes32 payloadHash,\\n    string calldata symbol,\\n    uint256 amount\\n  ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IRWALike.sol\": {\r\n      \"content\": \"/**SPDX-License-Identifier: BUSL-1.1\\n\\n      \u2584\u2584\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2584\\n   \u2553\u2588\u2588\u2580\u2514 ,\u2553\u2584\u2584\u2584, '\u2580\u2588\u2588\u2584\\n  \u2588\u2588\u2580 \u2584\u2588\u2588\u2580\u2580\u2559\u2559\u2580\u2580\u2588\u2588\u2584 \u2514\u2588\u2588\u00b5           ,,       ,,      ,     ,,,            ,,,\\n \u2588\u2588 ,\u2588\u2588\u00ac \u2584\u2588\u2588\u2588\u2588\u2584  \u2580\u2588\u2584 \u2559\u2588\u2584      \u2584\u2588\u2588\u2588\u2580\u2580\u2588\u2588\u2588\u2584   \u2588\u2588\u2588\u2584    \u2588\u2588  \u2588\u2588\u2588\u2580\u2580\u2580\u2588\u2588\u2588\u2584    \u2584\u2588\u2588\u2588\u2580\u2580\u2588\u2588\u2588,\\n\u2588\u2588  \u2588\u2588 \u2552\u2588\u2580'   \u2559\u2588\u258c \u2559\u2588\u258c \u2588\u2588     \u2590\u2588\u2588      \u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588,  \u2588\u2588  \u2588\u2588\u258c    \u2514\u2588\u2588\u258c  \u2588\u2588\u258c     \u2514\u2588\u2588\u258c\\n\u2588\u2588 \u2590\u2588\u258c \u2588\u2588      \u255f\u2588  \u2588\u258c \u255f\u2588     \u2588\u2588\u258c      \u2590\u2588\u2588  \u2588\u2588 \u2514\u2588\u2588\u2588 \u2588\u2588  \u2588\u2588\u258c     \u255f\u2588\u2588 j\u2588\u2588       \u255f\u2588\u2588\\n\u255f\u2588  \u2588\u2588 \u2559\u2588\u2588    \u2584\u2588\u2580 \u2590\u2588\u258c \u2588\u2588     \u2559\u2588\u2588      \u2588\u2588\u258c  \u2588\u2588   \u2559\u2588\u2588\u2588\u2588  \u2588\u2588\u258c    \u2584\u2588\u2588\u2580  \u2588\u2588\u258c     ,\u2588\u2588\u2580\\n \u2588\u2588 \\\"\u2588\u2588, \u2559\u2580\u2580\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2310      \u2559\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2580   \u2588\u2588     \u2559\u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2580\u2580     \u2559\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2580`\\n  \u2588\u2588\u2584 \u2559\u2580\u2588\u2588\u2584\u2584\u2584\u2584\u2584,,,                \u00ac\u2500                                    '\u2500\u00ac\\n   \u2559\u2580\u2588\u2588\u2584 '\u2559\u2559\u2559\u2580\u2580\u2580\u2580\u2580\u2580\u2580\u2580\\n      \u2559\u2580\u2580\u2588\u2588\u2588\u2588\u2588\u2588R\u2310\\n */\\npragma solidity 0.8.16;\\n\\n// This interface is not inherited directly by RWA, instead, it is a\\n// subset of functions provided by all RWA tokens that the RWA Hub\\n// Client uses.\\nimport \\\"contracts/external/openzeppelin/contracts/token/IERC20.sol\\\";\\n\\ninterface IRWALike is IERC20 {\\n  function mint(address to, uint256 amount) external;\\n\\n  function burn(uint256 amount) external;\\n\\n  function burnFrom(address from, uint256 amount) external;\\n}\\n\"\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_axelarGateway\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_allowlist\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_ondoApprover\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_mintLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_mintDuration\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AlreadyApproved\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ArrayLengthMismatch\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ChainNotSupported\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidVersion\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoThresholdMatch\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NonceSpent\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotApprovedByGateway\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotApprover\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NumOfApproversCannotBeZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SourceNotSupported\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ThresholdsNotInAscendingOrder\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"approver\",\"type\":\"address\"}],\"name\":\"ApproverAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"approver\",\"type\":\"address\"}],\"name\":\"ApproverRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"BridgeCompleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"string\",\"name\":\"srcChain\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"approvedSource\",\"type\":\"string\"}],\"name\":\"ChainIdSupported\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"string\",\"name\":\"srcChain\",\"type\":\"string\"}],\"name\":\"ChainSupportRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"txnHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"string\",\"name\":\"srcChain\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"srcSender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"MessageReceived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"instantMintLimitDuration\",\"type\":\"uint256\"}],\"name\":\"MintLimitDurationSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mintLimit\",\"type\":\"uint256\"}],\"name\":\"MintLimitSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"string\",\"name\":\"chain\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"numOfApprovers\",\"type\":\"uint256[]\"}],\"name\":\"ThresholdSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"txnHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"approver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"numApprovers\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"thresholdRequirement\",\"type\":\"uint256\"}],\"name\":\"TransactionApproved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ALLOWLIST\",\"outputs\":[{\"internalType\":\"contract IAllowlist\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"AXELAR_GATEWAY\",\"outputs\":[{\"internalType\":\"contract IAxelarGateway\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TOKEN\",\"outputs\":[{\"internalType\":\"contract IRWALike\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VERSION\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"approver\",\"type\":\"address\"}],\"name\":\"addApprover\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"srcChain\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"srcContractAddress\",\"type\":\"string\"}],\"name\":\"addChainSupport\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"txnHash\",\"type\":\"bytes32\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"approvers\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"chainToApprovedSender\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"chainToThresholds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"numberOfApprovalsNeeded\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentMintAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"commandId\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"sourceChain\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"sourceAddress\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"commandId\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"sourceChain\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"sourceAddress\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"},{\"internalType\":\"string\",\"name\":\"tokenSymbol\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"executeWithToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gateway\",\"outputs\":[{\"internalType\":\"contract IAxelarGateway\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"txnHash\",\"type\":\"bytes32\"}],\"name\":\"getNumApproved\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"isSpentNonce\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastResetMintTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"approver\",\"type\":\"address\"}],\"name\":\"removeApprover\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"srcChain\",\"type\":\"string\"}],\"name\":\"removeChainSupport\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"rescueTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"resetMintDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"mintLimit\",\"type\":\"uint256\"}],\"name\":\"setMintLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"mintDuration\",\"type\":\"uint256\"}],\"name\":\"setMintLimitDuration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"srcChain\",\"type\":\"string\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"numOfApprovers\",\"type\":\"uint256[]\"}],\"name\":\"setThresholds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"txnHashToTransaction\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"txnToThresholdSet\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"numberOfApprovalsNeeded\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "DestinationBridge", "CompilerVersion": "v0.8.16+commit.07a7930e", "OptimizationUsed": "1", "Runs": "100", "ConstructorArguments": "00000000000000000000000049cc578ae695a66c45eef728f2aaf22646363cc60000000000000000000000004f4495243837681061c4743b74b3eedf548d56a5000000000000000000000000000000000000000000000000000000000000000000000000000000000000000043997c583ed206770754aa63cc4ef0d32672086200000000000000000000000043997c583ed206770754aa63cc4ef0d32672086200000000000000000000000000000000000000000000152d02c7e14af68000000000000000000000000000000000000000000000000000000000000000015180", "EVMVersion": "london", "Library": "", "LicenseType": "Unlicense", "Proxy": "0", "Implementation": "", "SwarmSource": ""}