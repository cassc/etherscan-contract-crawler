{"SourceCode": "// SPDX-License-Identifier: MIT\r\n// File: SafeMath.sol\r\n\r\n\r\npragma solidity ^0.8.16;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Multiplies two numbers, throws on overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) external pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two numbers, truncating the quotient.\r\n     */\r\n    function div(uint256 a, uint256 b) external pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n     */\r\n    function sub(uint256 a, uint256 b) external pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Adds two numbers, throws on overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) external pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n\r\n     function min(uint256 x, uint256 y) external pure returns (uint256) {\r\n        return x < y ? x : y;\r\n    }\r\n\r\n   \r\n}\r\n// File: IERC721.sol\r\n\r\n\r\n\r\n// This is an interface for the ERC721 token standard.\r\n// ERC721 is a standard for non-fungible tokens (NFTs) on the Ethereum blockchain.\r\n\r\npragma solidity ^0.8.16;\r\n\r\ninterface IERC721 {\r\n    // Transfers ownership of an NFT from one address to another.\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    // Returns the owner of a specific NFT.\r\n    function ownerOf(uint256 tokenId) external view returns (address);\r\n\r\n    // Returns the approved address for a specific NFT.\r\n    function getApproved(uint256 _tokenId) external view returns (address);\r\n\r\n    // Approves another address to transfer the given NFT.\r\n    function approve(address sender, uint256 _tokenId)\r\n        external\r\n        returns (bool success);\r\n}\r\n\r\n// File: IERC20.sol\r\n\r\n\r\n\r\n// This is an interface for the ERC20 token standard.\r\n// ERC20 is a widely adopted standard for fungible tokens on the Ethereum blockchain.\r\n\r\npragma solidity ^0.8.16;\r\n\r\ninterface IERC20 {\r\n    // Transfers a specified amount of tokens from the sender to a recipient.\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    // Returns the balance of tokens for a specific account.\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    // Returns the amount of tokens that the spender is allowed to spend on behalf of the owner.\r\n    function allowance(address token, address sender) external view returns (uint256 remaining);\r\n\r\n    // Allows the owner of tokens to approve another address to spend a specified amount of tokens on their behalf.\r\n    function approve(address sender, uint256 amount) external returns (bool success);\r\n}\r\n\r\n// File: ZkGhost.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.16;\r\n\r\n// Import the interfaces for IERC20 and IERC721 tokens\r\n\r\n\r\n\r\n// Import the SafeMath library\r\n\r\n\r\n/**\r\n * @title ZkGhost\r\n * @dev The Directory contract allows users to publish their public keys on blockchain,\r\n * consisting of the parameters x_cor, y_cor, and sharedSecret.\r\n * These keys allow the receiver to generate the private key associated with his stealth address.\r\n * Users publish their public keys by invoking the appropriate functions in the contract.\r\n * The contract maintains a log of published keys and keeps track of the total funds sent and received.\r\n * Users can transfer native coins, ERC20, and Non-fungible tokens to a designated recipient stealth address,\r\n * authorized by their published keys.\r\n */\r\n\r\ncontract ZkGhost {\r\n    \r\n    using SafeMath for uint256;\r\n\r\n    // @notice Define a struct to represent public keys\r\n    // @dev 'x_cor' and 'y_cor' are the 32 bytes represent zkghost key\r\n    // where sharedSecret is 2 bytes of stealth address prefixed with zkghost key , used for verification\r\n    // public keys = sharedSecret + (x_cor + y_cor) sharedSecret + (zkghost keys)\r\n\r\n    struct publickeys {\r\n        bytes32 x_cor;\r\n        bytes32 y_cor;\r\n        bytes2 sharedSecret;\r\n    }\r\n\r\n    // @notice Define variables to keep track of the total funds received and the length of public keys\r\n\r\n    uint256 internal totalFunds;\r\n\r\n    uint256 internal totalStealthAdd;\r\n\r\n    // @notice Define a variable to store the owner of the contract\r\n\r\n    address private owner;\r\n\r\n    // @notice Define an array to store the logs of published public keys\r\n\r\n    publickeys[] public logs;\r\n\r\n    // @notice Define the contract name\r\n\r\n    string public contractName;\r\n\r\n    // @notice Events\r\n\r\n    event publicKeys(bytes32 x_cor, bytes32 y_cor, bytes2 sharedSecret);\r\n\r\n    // @notice Modifiers\r\n\r\n    modifier onlyOwner() {\r\n        assert(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    modifier validateTokenAddr(address token) {\r\n        require(token != address(0x0), \"Token address required\");\r\n        _;\r\n    }\r\n\r\n    // @notice Constructor\r\n\r\n    constructor() {\r\n        owner = msg.sender;\r\n        contractName = \"ZkGhost v1\";\r\n    }\r\n\r\n    // @notice Getters\r\n\r\n    function gettotalStealthAddresses() public view returns (uint256) {\r\n        return totalStealthAdd;\r\n    }\r\n\r\n    function getTotalVolume() public view returns (uint256) {\r\n        return totalFunds;\r\n    }\r\n\r\n    // @notice Function to update the total volume of the contract\r\n\r\n    function updateTvl(uint256 _vol) internal {\r\n        uint256 updatedTotalFunds;\r\n        uint256 updatedtotalStealthAddresses;\r\n\r\n        assembly {\r\n            // Load values from storage\r\n            updatedTotalFunds := sload(totalFunds.slot)\r\n            updatedtotalStealthAddresses := sload(totalStealthAdd.slot)\r\n\r\n            // Perform operations\r\n            updatedTotalFunds := add(updatedTotalFunds, _vol)\r\n            updatedtotalStealthAddresses := add(updatedtotalStealthAddresses, 1)\r\n\r\n            // Store the updated values back to storage\r\n            sstore(totalFunds.slot, updatedTotalFunds)\r\n            sstore(totalStealthAdd.slot, updatedtotalStealthAddresses)\r\n        }\r\n    }\r\n\r\n    // @notice Function to publish public keys\r\n    // @param x_cor & y_cor: 32-byte of zkghost key\r\n    // @param sharedSecret: 2-bytes of stealth address prefixed with zkghost key\r\n\r\n    function publishPubkeys(\r\n        bytes32 x_cor,\r\n        bytes32 y_cor,\r\n        bytes2 sharedSecret\r\n    ) private {\r\n        logs.push(publickeys(x_cor, y_cor, sharedSecret));\r\n    }\r\n\r\n    // @notice Function to get the length of public keys array\r\n\r\n    function pubKeysLen() public view returns (uint256) {\r\n        return logs.length;\r\n    }\r\n\r\n    // @notice Function to transfer eth to a target stealth address\r\n    // @param x_cor & y_cor: 32-byte zkghost key\r\n\r\n    // @param sharedSecret: 2-byte of stealth address prefixed with zkghost key\r\n    // @param target: The target address (i.e., the recipient's stealth address)\r\n\r\n    function Transfer(\r\n        bytes32 x_cor,\r\n        bytes32 y_cor,\r\n        bytes2 sharedSecret,\r\n        address payable target\r\n    ) public payable returns (uint256) {\r\n        // Check that the value being transferred is greater than 0.\r\n        require(msg.value > 0, \"Amount should be more than 0\");\r\n\r\n        // Publishing public keys on chain respective to receipent's key\r\n\r\n        publishPubkeys(x_cor, y_cor, sharedSecret);\r\n\r\n        // @notice Transfer the funds to the targeted stealth address\r\n\r\n        (bool transferSuccess, ) = target.call{value: msg.value}(\"\");\r\n\r\n        require(transferSuccess, \"Transfer to recipient failed\");\r\n\r\n        // Perform calculations and updates using temporary variables\r\n\r\n        updateTvl(msg.value);\r\n\r\n        // Emit an event to log the publication of public keys\r\n\r\n        emit publicKeys(x_cor, y_cor, sharedSecret);\r\n\r\n        return (msg.value);\r\n    }\r\n\r\n    // @notice Function to transfer ERC20 tokens to a target stealth address\r\n    // @param x_cor & y_cor: 32-byte zkghost key\r\n\r\n    // @param sharedSecret: 2-byte of stealth address prefixed with zkghost key\r\n    // @param token: The ERC20 token contract address\r\n    // @param target: The target address (i.e., the recipient's stealth address)\r\n    // @param amount: The amount of tokens to transfer\r\n\r\n    function TransferERC20(\r\n        bytes32 x_cor,\r\n        bytes32 y_cor,\r\n        bytes2 sharedSecret,\r\n        address token,\r\n        address target,\r\n        uint256 amount\r\n    ) external payable validateTokenAddr(token) {\r\n        \r\n        // Check that the amount being transferred is greater than 0\r\n\r\n        require(amount > 0, \"Amount should be more than 0\");\r\n\r\n        require(\r\n            IERC20(token).balanceOf(msg.sender) >= amount,\r\n            \"Not enough tokens\"\r\n        );\r\n\r\n        if (IERC20(token).allowance(msg.sender, address(this)) < amount) {\r\n            revert(\"Not enough allowance\");\r\n        }\r\n\r\n        // Publish the public keys.\r\n        publishPubkeys(x_cor, y_cor, sharedSecret);\r\n\r\n        // @notice Transfer tokens from sender's account to target account.\r\n        IERC20(token).transferFrom(msg.sender, target, amount);\r\n\r\n        // Perform calculations and updates using temporary variables.\r\n        updateTvl(amount);\r\n\r\n        // Emit an event to log the publication of public keys.\r\n        emit publicKeys(x_cor, y_cor, sharedSecret);\r\n    }\r\n\r\n    // @notice Function to transfer ERC721 token  to a target stealth address\r\n    // @param x_cor & y_cor: 32-byte zkghost key\r\n\r\n    // @param sharedSecret: 2-byte of stealth address prefixed with zkghost key\r\n    // @param ERC721Token: The ERC721 token address\r\n    // @param target: The targeted stealth address\r\n    // @param tokenId: The tokenId of ERC721 to transfer\r\n\r\n    function TransferERC721(\r\n        bytes32 x_cor,\r\n        bytes32 y_cor,\r\n        bytes2 sharedSecret,\r\n        address ERC721Token,\r\n        address target,\r\n        uint256 tokenId\r\n    ) external {\r\n        // Check that ERC721Token is not empty.\r\n\r\n        require(ERC721Token != address(0x0), \" Enter the token address\");\r\n\r\n        require(\r\n            IERC721(ERC721Token).ownerOf(tokenId) == msg.sender,\r\n            \"You are not the owner of this tokenId\"\r\n        );\r\n\r\n        // check if the ERC721 approval belongs to the owner\r\n\r\n        if (IERC721(ERC721Token).getApproved(tokenId) != address(this)) {\r\n            revert(\"Not approved\");\r\n        }\r\n\r\n        // Publish the public keys.\r\n        publishPubkeys(x_cor, y_cor, sharedSecret);\r\n\r\n        // @notice Transfer Non Fungible tokens (ERC721) from sender's account to target account.\r\n\r\n        IERC721(ERC721Token).transferFrom(msg.sender, target, tokenId);\r\n\r\n        // Perform calculations and updates using temporary variables.\r\n        updateTvl(1);\r\n\r\n        // Emit an event to log the publication of public keys.\r\n        emit publicKeys(x_cor, y_cor, sharedSecret);\r\n    }\r\n\r\n\r\n\r\n\r\n    // @notice Function to retrieve a range of public keys\r\n    // @param initVal: The initial value required to start retreiving public keys \r\n     \r\n\r\n    function retrievePubKeys(uint256 initVal)\r\n        public\r\n        view\r\n        returns (publickeys[10] memory)\r\n    {\r\n        publickeys[10] memory Keys;\r\n\r\n        // Ensure initVal is not greater than the length of logs\r\n        uint256 j = initVal >= logs.length ? logs.length : initVal;\r\n        uint256 end = j > 10 ? j - 10 : 0;\r\n\r\n        for (uint256 i = j; i > end; i--) {\r\n            // Check if index is within bounds of the logs array\r\n\r\n            //10-10=0 , 10-9=1 decrementing i from j and storing in keys\r\n            Keys[j - i] = logs[i - 1];\r\n        }\r\n\r\n        return Keys;\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"x_cor\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"y_cor\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes2\",\"name\":\"sharedSecret\",\"type\":\"bytes2\"}],\"name\":\"publicKeys\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"x_cor\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"y_cor\",\"type\":\"bytes32\"},{\"internalType\":\"bytes2\",\"name\":\"sharedSecret\",\"type\":\"bytes2\"},{\"internalType\":\"address payable\",\"name\":\"target\",\"type\":\"address\"}],\"name\":\"Transfer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"x_cor\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"y_cor\",\"type\":\"bytes32\"},{\"internalType\":\"bytes2\",\"name\":\"sharedSecret\",\"type\":\"bytes2\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TransferERC20\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"x_cor\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"y_cor\",\"type\":\"bytes32\"},{\"internalType\":\"bytes2\",\"name\":\"sharedSecret\",\"type\":\"bytes2\"},{\"internalType\":\"address\",\"name\":\"ERC721Token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"TransferERC721\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractName\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalVolume\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gettotalStealthAddresses\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"logs\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"x_cor\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"y_cor\",\"type\":\"bytes32\"},{\"internalType\":\"bytes2\",\"name\":\"sharedSecret\",\"type\":\"bytes2\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pubKeysLen\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"initVal\",\"type\":\"uint256\"}],\"name\":\"retrievePubKeys\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"x_cor\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"y_cor\",\"type\":\"bytes32\"},{\"internalType\":\"bytes2\",\"name\":\"sharedSecret\",\"type\":\"bytes2\"}],\"internalType\":\"struct ZkGhost.publickeys[10]\",\"name\":\"\",\"type\":\"tuple[10]\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "ZkGhost", "CompilerVersion": "v0.8.24+commit.e11b9ed9", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://c20f8d21ea5993b42e6fbff234fb54ca0bc9ec2d1b1bb0a448665f9ac0846d3d"}