{"SourceCode": "/**\r\n *Submitted for verification at Etherscan.io on 2023-12-01\r\n*/\r\n\r\n//SPDX-License-Identifier: Apache-2.0\r\npragma solidity 0.8.14;\r\n\r\n\r\ninterface IKYCVerification {\r\n\r\n    /**\r\n        Returns true if `user` has passed KYC Verification and has been verified by contract owner\r\n        Returns false if `user` has not passed KYC Verification, or has not yet been verified by contract owner\r\n        \r\n        @param user - Address corresponding to a Person who may or may not have passed KYC Verification\r\n        @return bool - Returns true if `user` is KYC verified, false otherwise\r\n     */\r\n    function isVerified(address user) external view returns (bool);\r\n\r\n    /**\r\n        Validates that the hashed value for `information` - the KYC Information - of `User`\r\n        Matches what is stored on chain. This function can be used to ensure that off-chain data\r\n        has not been manipulated or altered in any way\r\n\r\n        @param user - Address corresponding to a person who may or may not have passed KYC Verification\r\n        @param information - Stringified KYC Information for `user`\r\n        @return bool - Returns true if hashed `information` matches what is stored on-chain for `user`\r\n     */\r\n    function validate(address user, string calldata information) external view returns (bool);\r\n\r\n    /**\r\n        Validates that `hashedData` ( the hashed KYC Information of `User` )\r\n        Matches what is stored on chain. This function can be used to ensure that off-chain data\r\n        has not been manipulated or altered in any way\r\n\r\n        @param user - Address corresponding to a person who may or may not have passed KYC Verification\r\n        @param hashedData - Hashed version of KYC Information for `user`\r\n        @return bool - Returns true if `hashedData` matches what is stored on-chain for `user`\r\n     */\r\n    function validateHash(address user, bytes32 hashedData) external view returns (bool);\r\n\r\n    /**\r\n        Returns the hash of a given input string. Should be used to determine the hash of\r\n        KYC Information from registered users, prior to calling the `verify()` function\r\n\r\n        @param information - KYC Information\r\n        @return bytes32 - Hashed bytes of `information`\r\n     */\r\n    function getHash(string calldata information) external view returns (bytes32);\r\n\r\n}\r\n\r\ninterface IDatabase {\r\n    function isAuthorized(address account) external view returns (bool);\r\n}\r\n\r\n/**\r\n    @title KYC Verification Contract\r\n    \r\n    Manages Storing and Validating Users Who Have Passed The KYC Audit Process\r\n    Allows External Contracts To Query User's Verification Status\r\n    To Prevent Use From Users Who Have Not Yet Been Verified To Use Them\r\n\r\n    This Contract, If Used Appropriately, Will Allow The Owners To Follow\r\n    Proper Legal Guidelines In Accordance With SEC Rules And Regulations\r\n\r\n */\r\ncontract KYCVerify is IKYCVerification {\r\n\r\n    /**\r\n        Stores the mapping of each registered `user` address\r\n        And the corresponding hash of the KYC data entered off chain\r\n\r\n        Use the `getHash()` function to convert a string of KYC data\r\n        Into a bytes32 hash prior to calling `verify()` to ensure the data matches\r\n\r\n        `validate()` can be called to ensure that the KYC data stored off chain\r\n        Has not been altered in any way by comparing the hash of the stored data\r\n        To the hash stored on chain\r\n\r\n        `isVerified()` can be called by any smart contract to ensure only addresses\r\n        corresponding to users who are KYC Verified are able to interact with the Platform\r\n     */\r\n    mapping ( address => bytes32 ) private hashMap;\r\n\r\n    /**\r\n        Master Database Which Interacts With Auth And KYC Databases\r\n     */\r\n    IDatabase public immutable Database;\r\n\r\n    /**\r\n        Modifier To Ensure Only Authorized Addresses May Set Verification Status In This Contract\r\n        If `Database.isAuthorized(msg.sender)` returns false, Transaction execution is reverted\r\n     */\r\n    modifier onlyOwner() {\r\n        require(\r\n            Database.isAuthorized(msg.sender),\r\n            'Sender Is Not Authorized'\r\n        );\r\n        _;\r\n    }\r\n\r\n    event Verified(address user);\r\n\r\n    /**\r\n        Initialize Database\r\n     */\r\n    constructor(address DB) {\r\n        Database = IDatabase(DB);\r\n    }\r\n\r\n    /**\r\n        Verifies that the address corresponding to `user` has been KYC'd\r\n        Stores the hash of the KYC information on-chain to ensure that the data\r\n        has not been altered off-chain. \r\n        \r\n        This function will grant access to the address corresponding to `user`\r\n        to interact with restricted contracts that ensure `isVerified()` returns true \r\n        before allowing for contract interactions to occur.\r\n\r\n        To ensure the hash stored on-chain matches the data stored off-chain\r\n        Call `getHash()` on the off-chain data and pass the resulting bytes32 output into `verify()`\r\n        This will ensure small issues like spacing and capitalization are accounted for and will not cause hashes to mismatch\r\n\r\n        This function should only be called once the user has passed the KYC Verification Process\r\n        And the operator of this contract is positive the data they provided matches their identity\r\n\r\n        This is a dangerous function if misused. Calling verify with a non-zero input for \r\n        `hashedData` will cause every interacting contract to assume `user` is now KYC Verified. \r\n        Likewise, calling verify with a zero input for `hashedData` will cause every interacting \r\n        contract to assume `user` is no longer KYC Verified.\r\n\r\n        Ensure the keys which operate this contract are safely kept to prevent manipulation\r\n        Locking contract ownership behind a Multi Signature Wallet owned by Company Executives\r\n        Is the safest way to ensure data is preserved and KYC is enforced.\r\n\r\n        @param user - Address corresponding to a Person who has passed KYC Verification\r\n        @param hashedData - Hashed KYC Data Of User, To Ensure Data stored off-chain is accurate\r\n     */\r\n    function verify(address user, bytes32 hashedData) external onlyOwner {\r\n        hashMap[user] = hashedData;\r\n        emit Verified(user);\r\n    }\r\n\r\n    /**\r\n        Returns true if `user` has passed KYC Verification and has been verified by contract owner\r\n        Returns false if `user` has not passed KYC Verification, or has not yet been verified by contract owner\r\n        \r\n        @param user - Address corresponding to a Person who may or may not have passed KYC Verification\r\n        @return bool - Returns true if `user` is KYC verified, false otherwise\r\n     */\r\n    function isVerified(address user) external view override returns (bool) {\r\n        return hashMap[user] != bytes32(0);\r\n    }\r\n\r\n    /**\r\n        Validates that the hashed value for `information` - the KYC Information - of `User`\r\n        Matches what is stored on chain. This function can be used to ensure that off-chain data\r\n        has not been manipulated or altered in any way\r\n\r\n        @param user - Address corresponding to a person who may or may not have passed KYC Verification\r\n        @param information - Stringified KYC Information for `user`\r\n        @return bool - Returns true if hashed `information` matches what is stored on-chain for `user`\r\n     */\r\n    function validate(address user, string calldata information) external view override returns (bool) {\r\n        return hashMap[user] == keccak256(bytes(information));\r\n    }\r\n\r\n    /**\r\n        Validates that `hashedData` ( the hashed KYC Information of `User` )\r\n        Matches what is stored on chain. This function can be used to ensure that off-chain data\r\n        has not been manipulated or altered in any way\r\n\r\n        @param user - Address corresponding to a person who may or may not have passed KYC Verification\r\n        @param hashedData - Hashed version of KYC Information for `user`\r\n        @return bool - Returns true if `hashedData` matches what is stored on-chain for `user`\r\n     */\r\n    function validateHash(address user, bytes32 hashedData) external view override returns (bool) {\r\n        return hashMap[user] == hashedData;\r\n    }\r\n\r\n    /**\r\n        Returns the hash of a given input string. Should be used to determine the hash of\r\n        KYC Information from registered users, prior to calling the `verify()` function\r\n\r\n        @param information - KYC Information\r\n        @return bytes32 - Hashed bytes of `information`\r\n     */\r\n    function getHash(string calldata information) external pure override returns (bytes32) {\r\n        return keccak256(bytes(information));\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"DB\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"Verified\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"Database\",\"outputs\":[{\"internalType\":\"contract IDatabase\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"information\",\"type\":\"string\"}],\"name\":\"getHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"isVerified\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"information\",\"type\":\"string\"}],\"name\":\"validate\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"hashedData\",\"type\":\"bytes32\"}],\"name\":\"validateHash\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"hashedData\",\"type\":\"bytes32\"}],\"name\":\"verify\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "KYCVerify", "CompilerVersion": "v0.8.14+commit.80d49f37", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000238a94e37a1bade56cfcc5dbe7f48da88aa9db19", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://18cc02dc26e18522b4b09b92d97d7ade87ded0ea19a2e90f30083274b4ef29ed"}