{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/core/verifier/instances/Verifier28x32.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n// Copyright 2022 Aztec\\npragma solidity >=0.8.4;\\n\\nimport {VerificationKey28x32} from \\\"../keys/VerificationKey28x32.sol\\\";\\nimport {BaseStandardVerifier} from \\\"../BaseStandardVerifier.sol\\\";\\n\\ncontract Verifier28x32 is BaseStandardVerifier {\\n    function getVerificationKeyHash() public pure override(BaseStandardVerifier) returns (bytes32) {\\n        return VerificationKey28x32.verificationKeyHash();\\n    }\\n\\n    function loadVerificationKey(uint256 vk, uint256 _omegaInverseLoc) internal pure virtual override {\\n        VerificationKey28x32.loadVerificationKey(vk, _omegaInverseLoc);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/core/verifier/keys/VerificationKey28x32.sol\": {\r\n      \"content\": \"// Verification Key Hash: 30c540ad71c1de0ea945ef250fec744221207208b9c1a5e355ff394c0873e55c\\n// SPDX-License-Identifier: Apache-2.0\\n// Copyright 2022 Aztec\\npragma solidity >=0.8.4;\\n\\nlibrary VerificationKey28x32 {\\n    function verificationKeyHash() internal pure returns (bytes32) {\\n        return 0x30c540ad71c1de0ea945ef250fec744221207208b9c1a5e355ff394c0873e55c;\\n    }\\n\\n    function loadVerificationKey(uint256 _vk, uint256 _omegaInverseLoc) internal pure {\\n        assembly {\\n            mstore(add(_vk, 0x00), 0x0000000000000000000000000000000000000000000000000000000000800000) // vk.circuit_size\\n            mstore(add(_vk, 0x20), 0x0000000000000000000000000000000000000000000000000000000000000011) // vk.num_inputs\\n            mstore(add(_vk, 0x40), 0x0210fe635ab4c74d6b7bcf70bc23a1395680c64022dd991fb54d4506ab80c59d) // vk.work_root\\n            mstore(add(_vk, 0x60), 0x30644e121894ba67550ff245e0f5eb5a25832df811e8df9dd100d30c2c14d821) // vk.domain_inverse\\n            mstore(add(_vk, 0x80), 0x1d349b8977724e09c86fa578f4735879a9f44c213b0c8ca5102e4c3971408ef1) // vk.Q1.x\\n            mstore(add(_vk, 0xa0), 0x24f288f17b6ae11b4b7864ab9594f8b2f4f19ea1d60e17f772974e91844ac462) // vk.Q1.y\\n            mstore(add(_vk, 0xc0), 0x1478cb35d613e2cfbfda0b9dce986b7f00930b2556fa46cdc3baee5dc76bf589) // vk.Q2.x\\n            mstore(add(_vk, 0xe0), 0x2c18d64a741c1d344f0d52e6c62f7ac79821aba10256a15d2622438791a82839) // vk.Q2.y\\n            mstore(add(_vk, 0x100), 0x1da0feb3b521b13e4c0f131fb7e5fe4a4406caa1cee0df757659f2303329c00c) // vk.Q3.x\\n            mstore(add(_vk, 0x120), 0x1f964f3a14e19de343a7a8a7ae0fc7b3c44211a9927ebbdb9556fd623177464c) // vk.Q3.y\\n            mstore(add(_vk, 0x140), 0x188fa91323b2ba20000d98efb311dc84b27ec60203c6f51301471213bfcc0c93) // vk.QM.x\\n            mstore(add(_vk, 0x160), 0x0dec5cadfc71c9c707e8d451f6a87ee63a25769d6ca4b35f84596bc8d163ab13) // vk.QM.y\\n            mstore(add(_vk, 0x180), 0x0e18198690edc77d449e2a46b5bffffd1356422c0fa54e3cc011194ba83eb6ed) // vk.QC.x\\n            mstore(add(_vk, 0x1a0), 0x1f22be590007dbcd8ce6d51b513bccb91906f3baec495226810856655b7fde35) // vk.QC.y\\n            mstore(add(_vk, 0x1c0), 0x1ae57998807b3d1393feec54458002a457f5518b9adc66bb2facf68fd08e6c85) // vk.SIGMA1.x\\n            mstore(add(_vk, 0x1e0), 0x078c0f28b8823d267717a4b9903af394feb40e305acd6d5692239b8449c391a3) // vk.SIGMA1.y\\n            mstore(add(_vk, 0x200), 0x23a3fa199f93bbdf437853790a5505ec120cb1d311b629342304cb07a77161f3) // vk.SIGMA2.x\\n            mstore(add(_vk, 0x220), 0x2e7711ded1fcd544e9f1aa2a82173475cd143f8111628694766546e179f071f7) // vk.SIGMA2.y\\n            mstore(add(_vk, 0x240), 0x1e242bd59e58c879d7ac9629be07a5396ac7d95f05496dbc2c9f45627d56c148) // vk.SIGMA3.x\\n            mstore(add(_vk, 0x260), 0x239a1f09cab3a4d6524ddb0577a804d883c806a55bf4931e037a0592b5faad7c) // vk.SIGMA3.y\\n            mstore(add(_vk, 0x280), 0x01) // vk.contains_recursive_proof\\n            mstore(add(_vk, 0x2a0), 1) // vk.recursive_proof_public_input_indices\\n            mstore(add(_vk, 0x2c0), 0x260e01b251f6f1c7e7ff4e580791dee8ea51d87a358e038b4efe30fac09383c1) // vk.g2_x.X.c1\\n            mstore(add(_vk, 0x2e0), 0x0118c4d5b837bcc2bc89b5b398b5974e9f5944073b32078b7e231fec938883b0) // vk.g2_x.X.c0\\n            mstore(add(_vk, 0x300), 0x04fc6369f7110fe3d25156c1bb9a72859cf2a04641f99ba4ee413c80da6a5fe4) // vk.g2_x.Y.c1\\n            mstore(add(_vk, 0x320), 0x22febda3c0c0632a56475b4214e5615e11e6dd3f96e6cea2854a87d4dacc5e55) // vk.g2_x.Y.c0\\n            mstore(_omegaInverseLoc, 0x2165a1a5bda6792b1dd75c9f4e2b8e61126a786ba1a6eadf811b03e7d69ca83b) // vk.work_root_inverse\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/core/verifier/BaseStandardVerifier.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n// Copyright 2022 Aztec\\npragma solidity >=0.8.4;\\n// gas cost at 5000 optimizer runs 0.8.10: 287,589 (includes 21,000 base cost)\\n\\nimport {IVerifier} from \\\"../interfaces/IVerifier.sol\\\";\\n\\n/**\\n * @title Standard Plonk proof verification contract\\n * @dev Top level Plonk proof verification contract, which allows Plonk proof to be verified\\n */\\nabstract contract BaseStandardVerifier is IVerifier {\\n    // VERIFICATION KEY MEMORY LOCATIONS\\n    uint256 internal constant N_LOC = 0x200 + 0x00;\\n    uint256 internal constant NUM_INPUTS_LOC = 0x200 + 0x20;\\n    uint256 internal constant OMEGA_LOC = 0x200 + 0x40;\\n    uint256 internal constant DOMAIN_INVERSE_LOC = 0x200 + 0x60;\\n    uint256 internal constant Q1_X_LOC = 0x200 + 0x80;\\n    uint256 internal constant Q1_Y_LOC = 0x200 + 0xa0;\\n    uint256 internal constant Q2_X_LOC = 0x200 + 0xc0;\\n    uint256 internal constant Q2_Y_LOC = 0x200 + 0xe0;\\n    uint256 internal constant Q3_X_LOC = 0x200 + 0x100;\\n    uint256 internal constant Q3_Y_LOC = 0x200 + 0x120;\\n    uint256 internal constant QM_X_LOC = 0x200 + 0x140;\\n    uint256 internal constant QM_Y_LOC = 0x200 + 0x160;\\n    uint256 internal constant QC_X_LOC = 0x200 + 0x180;\\n    uint256 internal constant QC_Y_LOC = 0x200 + 0x1a0;\\n    uint256 internal constant SIGMA1_X_LOC = 0x200 + 0x1c0;\\n    uint256 internal constant SIGMA1_Y_LOC = 0x200 + 0x1e0;\\n    uint256 internal constant SIGMA2_X_LOC = 0x200 + 0x200;\\n    uint256 internal constant SIGMA2_Y_LOC = 0x200 + 0x220;\\n    uint256 internal constant SIGMA3_X_LOC = 0x200 + 0x240;\\n    uint256 internal constant SIGMA3_Y_LOC = 0x200 + 0x260;\\n    uint256 internal constant CONTAINS_RECURSIVE_PROOF_LOC = 0x200 + 0x280;\\n    uint256 internal constant RECURSIVE_PROOF_PUBLIC_INPUT_INDICES_LOC = 0x200 + 0x2a0;\\n    uint256 internal constant G2X_X0_LOC = 0x200 + 0x2c0;\\n    uint256 internal constant G2X_X1_LOC = 0x200 + 0x2e0;\\n    uint256 internal constant G2X_Y0_LOC = 0x200 + 0x300;\\n    uint256 internal constant G2X_Y1_LOC = 0x200 + 0x320;\\n    // 26\\n\\n    // ### PROOF DATA MEMORY LOCATIONS\\n    uint256 internal constant W1_X_LOC = 0x200 + 0x340 + 0x00;\\n    uint256 internal constant W1_Y_LOC = 0x200 + 0x340 + 0x20;\\n    uint256 internal constant W2_X_LOC = 0x200 + 0x340 + 0x40;\\n    uint256 internal constant W2_Y_LOC = 0x200 + 0x340 + 0x60;\\n    uint256 internal constant W3_X_LOC = 0x200 + 0x340 + 0x80;\\n    uint256 internal constant W3_Y_LOC = 0x200 + 0x340 + 0xa0;\\n    uint256 internal constant Z_X_LOC = 0x200 + 0x340 + 0xc0;\\n    uint256 internal constant Z_Y_LOC = 0x200 + 0x340 + 0xe0;\\n    uint256 internal constant T1_X_LOC = 0x200 + 0x340 + 0x100;\\n    uint256 internal constant T1_Y_LOC = 0x200 + 0x340 + 0x120;\\n    uint256 internal constant T2_X_LOC = 0x200 + 0x340 + 0x140;\\n    uint256 internal constant T2_Y_LOC = 0x200 + 0x340 + 0x160;\\n    uint256 internal constant T3_X_LOC = 0x200 + 0x340 + 0x180;\\n    uint256 internal constant T3_Y_LOC = 0x200 + 0x340 + 0x1a0;\\n    uint256 internal constant W1_EVAL_LOC = 0x200 + 0x340 + 0x1c0;\\n    uint256 internal constant W2_EVAL_LOC = 0x200 + 0x340 + 0x1e0;\\n    uint256 internal constant W3_EVAL_LOC = 0x200 + 0x340 + 0x200;\\n    uint256 internal constant SIGMA1_EVAL_LOC = 0x200 + 0x340 + 0x220;\\n    uint256 internal constant SIGMA2_EVAL_LOC = 0x200 + 0x340 + 0x240;\\n    uint256 internal constant Z_OMEGA_EVAL_LOC = 0x200 + 0x340 + 0x260;\\n    uint256 internal constant PI_Z_X_LOC = 0x200 + 0x340 + 0x280;\\n    uint256 internal constant PI_Z_Y_LOC = 0x200 + 0x340 + 0x2a0;\\n    uint256 internal constant PI_Z_OMEGA_X_LOC = 0x200 + 0x340 + 0x2c0;\\n    uint256 internal constant PI_Z_OMEGA_Y_LOC = 0x200 + 0x340 + 0x2e0;\\n    // 24\\n\\n    // ### CHALLENGES MEMORY OFFSETS\\n    uint256 internal constant C_BETA_LOC = 0x200 + 0x340 + 0x300 + 0x00;\\n    uint256 internal constant C_GAMMA_LOC = 0x200 + 0x340 + 0x300 + 0x20;\\n    uint256 internal constant C_ALPHA_LOC = 0x200 + 0x340 + 0x300 + 0x40;\\n    uint256 internal constant C_ARITHMETIC_ALPHA_LOC = 0x200 + 0x340 + 0x300 + 0x60;\\n    uint256 internal constant C_ZETA_LOC = 0x200 + 0x340 + 0x300 + 0x80;\\n    uint256 internal constant C_CURRENT_LOC = 0x200 + 0x340 + 0x300 + 0xa0;\\n    uint256 internal constant C_V0_LOC = 0x200 + 0x340 + 0x300 + 0xc0;\\n    uint256 internal constant C_V1_LOC = 0x200 + 0x340 + 0x300 + 0xe0;\\n    uint256 internal constant C_V2_LOC = 0x200 + 0x340 + 0x300 + 0x100;\\n    uint256 internal constant C_V3_LOC = 0x200 + 0x340 + 0x300 + 0x120;\\n    uint256 internal constant C_V4_LOC = 0x200 + 0x340 + 0x300 + 0x140;\\n    uint256 internal constant C_V5_LOC = 0x200 + 0x340 + 0x300 + 0x160;\\n    uint256 internal constant C_U_LOC = 0x200 + 0x340 + 0x300 + 0x180;\\n    // 13\\n\\n    // ### LOCAL VARIABLES MEMORY OFFSETS\\n    uint256 internal constant DELTA_NUMERATOR_LOC = 0x200 + 0x340 + 0x300 + 0x1a0 + 0x00;\\n    uint256 internal constant DELTA_DENOMINATOR_LOC = 0x200 + 0x340 + 0x300 + 0x1a0 + 0x20;\\n    uint256 internal constant ZETA_POW_N_LOC = 0x200 + 0x340 + 0x300 + 0x1a0 + 0x40;\\n    uint256 internal constant PUBLIC_INPUT_DELTA_LOC = 0x200 + 0x340 + 0x300 + 0x1a0 + 0x60;\\n    uint256 internal constant ZERO_POLY_LOC = 0x200 + 0x340 + 0x300 + 0x1a0 + 0x80;\\n    uint256 internal constant L_START_LOC = 0x200 + 0x340 + 0x300 + 0x1a0 + 0xa0;\\n    uint256 internal constant L_END_LOC = 0x200 + 0x340 + 0x300 + 0x1a0 + 0xc0;\\n    uint256 internal constant R_ZERO_EVAL_LOC = 0x200 + 0x340 + 0x300 + 0x1a0 + 0xe0;\\n    uint256 internal constant ACCUMULATOR_X_LOC = 0x200 + 0x340 + 0x300 + 0x1a0 + 0x100;\\n    uint256 internal constant ACCUMULATOR_Y_LOC = 0x200 + 0x340 + 0x300 + 0x1a0 + 0x120;\\n    uint256 internal constant ACCUMULATOR2_X_LOC = 0x200 + 0x340 + 0x300 + 0x1a0 + 0x140;\\n    uint256 internal constant ACCUMULATOR2_Y_LOC = 0x200 + 0x340 + 0x300 + 0x1a0 + 0x160;\\n    uint256 internal constant PAIRING_LHS_X_LOC = 0x200 + 0x340 + 0x300 + 0x1a0 + 0x180;\\n    uint256 internal constant PAIRING_LHS_Y_LOC = 0x200 + 0x340 + 0x300 + 0x1a0 + 0x1a0;\\n    uint256 internal constant PAIRING_RHS_X_LOC = 0x200 + 0x340 + 0x300 + 0x1a0 + 0x1c0;\\n    uint256 internal constant PAIRING_RHS_Y_LOC = 0x200 + 0x340 + 0x300 + 0x1a0 + 0x1e0;\\n    // 16\\n\\n    // ### SUCCESS FLAG MEMORY LOCATIONS\\n    uint256 internal constant GRAND_PRODUCT_SUCCESS_FLAG = 0x200 + 0x340 + 0x300 + 0x1a0 + 0x200 + 0x00;\\n    uint256 internal constant ARITHMETIC_TERM_SUCCESS_FLAG = 0x200 + 0x340 + 0x300 + 0x1a0 + 0x200 + 0x20;\\n    uint256 internal constant BATCH_OPENING_SUCCESS_FLAG = 0x200 + 0x340 + 0x300 + 0x1a0 + 0x200 + 0x40;\\n    uint256 internal constant OPENING_COMMITMENT_SUCCESS_FLAG = 0x200 + 0x340 + 0x300 + 0x1a0 + 0x200 + 0x60;\\n    uint256 internal constant PAIRING_PREAMBLE_SUCCESS_FLAG = 0x200 + 0x340 + 0x300 + 0x1a0 + 0x200 + 0x80;\\n    uint256 internal constant PAIRING_SUCCESS_FLAG = 0x200 + 0x340 + 0x300 + 0x1a0 + 0x200 + 0xa0;\\n    uint256 internal constant RESULT_FLAG = 0x200 + 0x340 + 0x300 + 0x1a0 + 0x200 + 0xc0;\\n    // 7\\n\\n    // misc stuff\\n    uint256 internal constant OMEGA_INVERSE_LOC = 0x200 + 0x340 + 0x300 + 0x1a0 + 0x200 + 0xe0;\\n    uint256 internal constant C_ALPHA_SQR_LOC = 0x200 + 0x340 + 0x300 + 0x1a0 + 0x200 + 0xe0 + 0x20;\\n    // 2\\n\\n    // ### RECURSION VARIABLE MEMORY LOCATIONS\\n    uint256 internal constant RECURSIVE_P1_X_LOC = 0x200 + 0x340 + 0x300 + 0x1a0 + 0x200 + 0xe0 + 0x40;\\n    uint256 internal constant RECURSIVE_P1_Y_LOC = 0x200 + 0x340 + 0x300 + 0x1a0 + 0x200 + 0xe0 + 0x60;\\n    uint256 internal constant RECURSIVE_P2_X_LOC = 0x200 + 0x340 + 0x300 + 0x1a0 + 0x200 + 0xe0 + 0x80;\\n    uint256 internal constant RECURSIVE_P2_Y_LOC = 0x200 + 0x340 + 0x300 + 0x1a0 + 0x200 + 0xe0 + 0xa0;\\n\\n    uint256 internal constant PUBLIC_INPUTS_HASH_LOCATION = 0x200 + 0x340 + 0x300 + 0x1a0 + 0x200 + 0xe0 + 0xc0;\\n\\n    bytes4 internal constant PUBLIC_INPUT_INVALID_BN128_G1_POINT_SELECTOR = 0xeba9f4a6;\\n    bytes4 internal constant PUBLIC_INPUT_GE_P_SELECTOR = 0x374a972f;\\n    bytes4 internal constant MOD_EXP_FAILURE_SELECTOR = 0xf894a7bc;\\n    bytes4 internal constant EC_SCALAR_MUL_FAILURE_SELECTOR = 0xf755f369;\\n    bytes4 internal constant PROOF_FAILURE_SELECTOR = 0x0711fcec;\\n\\n    error PUBLIC_INPUTS_HASH_VERIFICATION_FAILED(uint256, uint256);\\n    error PUBLIC_INPUT_INVALID_BN128_G1_POINT();\\n    error PUBLIC_INPUT_GE_P();\\n    error MOD_EXP_FAILURE();\\n    error EC_SCALAR_MUL_FAILURE();\\n    error PROOF_FAILURE();\\n\\n    function getVerificationKeyHash() public pure virtual override(IVerifier) returns (bytes32);\\n\\n    function loadVerificationKey(uint256 vk, uint256 _omegaInverseLoc) internal pure virtual;\\n\\n    /**\\n     * @dev Verify a Plonk proof\\n     * @param - array of serialized proof data\\n     * @param - public input hash as computed from the broadcast data\\n     * @return True if proof is valid, reverts otherwise\\n     */\\n    function verify(bytes calldata, uint256 public_inputs_hash) external view override(IVerifier) returns (bool) {\\n        // validate the correctness of the public inputs hash\\n        {\\n            bool hash_matches_input;\\n            uint256 recovered_hash;\\n            assembly {\\n                recovered_hash := calldataload(add(calldataload(0x04), 0x24))\\n                hash_matches_input := eq(recovered_hash, public_inputs_hash)\\n            }\\n            if (!hash_matches_input) {\\n                revert PUBLIC_INPUTS_HASH_VERIFICATION_FAILED(public_inputs_hash, recovered_hash);\\n            }\\n        }\\n\\n        loadVerificationKey(N_LOC, OMEGA_INVERSE_LOC);\\n\\n        assembly {\\n            let q := 21888242871839275222246405745257275088696311157297823662689037894645226208583 // EC group order\\n            let p := 21888242871839275222246405745257275088548364400416034343698204186575808495617 // Prime field order\\n\\n            /**\\n             * LOAD PROOF FROM CALLDATA\\n             */\\n            {\\n                let data_ptr := add(calldataload(0x04), 0x24)\\n                if mload(CONTAINS_RECURSIVE_PROOF_LOC) {\\n                    let index_counter := add(mul(mload(RECURSIVE_PROOF_PUBLIC_INPUT_INDICES_LOC), 32), data_ptr)\\n\\n                    let x0 := calldataload(index_counter)\\n                    x0 := add(x0, shl(68, calldataload(add(index_counter, 0x20))))\\n                    x0 := add(x0, shl(136, calldataload(add(index_counter, 0x40))))\\n                    x0 := add(x0, shl(204, calldataload(add(index_counter, 0x60))))\\n                    let y0 := calldataload(add(index_counter, 0x80))\\n                    y0 := add(y0, shl(68, calldataload(add(index_counter, 0xa0))))\\n                    y0 := add(y0, shl(136, calldataload(add(index_counter, 0xc0))))\\n                    y0 := add(y0, shl(204, calldataload(add(index_counter, 0xe0))))\\n                    let x1 := calldataload(add(index_counter, 0x100))\\n                    x1 := add(x1, shl(68, calldataload(add(index_counter, 0x120))))\\n                    x1 := add(x1, shl(136, calldataload(add(index_counter, 0x140))))\\n                    x1 := add(x1, shl(204, calldataload(add(index_counter, 0x160))))\\n                    let y1 := calldataload(add(index_counter, 0x180))\\n                    y1 := add(y1, shl(68, calldataload(add(index_counter, 0x1a0))))\\n                    y1 := add(y1, shl(136, calldataload(add(index_counter, 0x1c0))))\\n                    y1 := add(y1, shl(204, calldataload(add(index_counter, 0x1e0))))\\n                    mstore(RECURSIVE_P1_X_LOC, x0)\\n                    mstore(RECURSIVE_P1_Y_LOC, y0)\\n                    mstore(RECURSIVE_P2_X_LOC, x1)\\n                    mstore(RECURSIVE_P2_Y_LOC, y1)\\n\\n                    // validate these are valid bn128 G1 points\\n                    if iszero(and(and(lt(x0, q), lt(x1, q)), and(lt(y0, q), lt(y1, q)))) {\\n                        mstore(0x00, PUBLIC_INPUT_INVALID_BN128_G1_POINT_SELECTOR)\\n                        revert(0x00, 0x04)\\n                    }\\n                }\\n\\n                let public_input_byte_length := mul(mload(NUM_INPUTS_LOC), 32)\\n                data_ptr := add(data_ptr, public_input_byte_length)\\n\\n                mstore(W1_X_LOC, mod(calldataload(add(data_ptr, 0x20)), q))\\n                mstore(W1_Y_LOC, mod(calldataload(data_ptr), q))\\n                mstore(W2_X_LOC, mod(calldataload(add(data_ptr, 0x60)), q))\\n                mstore(W2_Y_LOC, mod(calldataload(add(data_ptr, 0x40)), q))\\n                mstore(W3_X_LOC, mod(calldataload(add(data_ptr, 0xa0)), q))\\n                mstore(W3_Y_LOC, mod(calldataload(add(data_ptr, 0x80)), q))\\n                mstore(Z_X_LOC, mod(calldataload(add(data_ptr, 0xe0)), q))\\n                mstore(Z_Y_LOC, mod(calldataload(add(data_ptr, 0xc0)), q))\\n                mstore(T1_X_LOC, mod(calldataload(add(data_ptr, 0x120)), q))\\n                mstore(T1_Y_LOC, mod(calldataload(add(data_ptr, 0x100)), q))\\n                mstore(T2_X_LOC, mod(calldataload(add(data_ptr, 0x160)), q))\\n                mstore(T2_Y_LOC, mod(calldataload(add(data_ptr, 0x140)), q))\\n                mstore(T3_X_LOC, mod(calldataload(add(data_ptr, 0x1a0)), q))\\n                mstore(T3_Y_LOC, mod(calldataload(add(data_ptr, 0x180)), q))\\n                mstore(W1_EVAL_LOC, mod(calldataload(add(data_ptr, 0x1c0)), p))\\n                mstore(W2_EVAL_LOC, mod(calldataload(add(data_ptr, 0x1e0)), p))\\n                mstore(W3_EVAL_LOC, mod(calldataload(add(data_ptr, 0x200)), p))\\n                mstore(SIGMA1_EVAL_LOC, mod(calldataload(add(data_ptr, 0x220)), p))\\n                mstore(SIGMA2_EVAL_LOC, mod(calldataload(add(data_ptr, 0x240)), p))\\n                mstore(Z_OMEGA_EVAL_LOC, mod(calldataload(add(data_ptr, 0x260)), p))\\n                mstore(PI_Z_X_LOC, mod(calldataload(add(data_ptr, 0x2a0)), q))\\n                mstore(PI_Z_Y_LOC, mod(calldataload(add(data_ptr, 0x280)), q))\\n                mstore(PI_Z_OMEGA_X_LOC, mod(calldataload(add(data_ptr, 0x2e0)), q))\\n                mstore(PI_Z_OMEGA_Y_LOC, mod(calldataload(add(data_ptr, 0x2c0)), q))\\n            }\\n\\n            {\\n                /**\\n                 * Generate initial challenge\\n                 *\\n                 */\\n\\n                mstore(0x00, shl(224, mload(N_LOC)))\\n                mstore(0x04, shl(224, mload(NUM_INPUTS_LOC)))\\n                let challenge := keccak256(0x00, 0x08)\\n\\n                /**\\n                 * Generate beta, gamma challenges\\n                 */\\n                mstore(PUBLIC_INPUTS_HASH_LOCATION, challenge)\\n                let inputs_start := add(calldataload(0x04), 0x24)\\n                let num_calldata_bytes := add(0xc0, mul(mload(NUM_INPUTS_LOC), 0x20))\\n                calldatacopy(add(PUBLIC_INPUTS_HASH_LOCATION, 0x20), inputs_start, num_calldata_bytes)\\n\\n                challenge := keccak256(PUBLIC_INPUTS_HASH_LOCATION, add(num_calldata_bytes, 0x20))\\n\\n                mstore(C_BETA_LOC, mod(challenge, p))\\n\\n                mstore(0x00, challenge)\\n                mstore8(0x20, 0x01)\\n                challenge := keccak256(0x00, 0x21)\\n                mstore(C_GAMMA_LOC, mod(challenge, p))\\n\\n                /**\\n                 * Generate alpha challenge\\n                 */\\n                mstore(0x00, challenge)\\n                mstore(0x20, mload(Z_Y_LOC))\\n                mstore(0x40, mload(Z_X_LOC))\\n                challenge := keccak256(0x00, 0x60)\\n                mstore(C_ALPHA_LOC, mod(challenge, p))\\n                /**\\n                 * Generate zeta challenge\\n                 */\\n                mstore(0x00, challenge)\\n                mstore(0x20, mload(T1_Y_LOC))\\n                mstore(0x40, mload(T1_X_LOC))\\n                mstore(0x60, mload(T2_Y_LOC))\\n                mstore(0x80, mload(T2_X_LOC))\\n                mstore(0xa0, mload(T3_Y_LOC))\\n                mstore(0xc0, mload(T3_X_LOC))\\n                challenge := keccak256(0x00, 0xe0)\\n\\n                mstore(C_ZETA_LOC, mod(challenge, p))\\n                mstore(C_CURRENT_LOC, challenge)\\n            }\\n\\n            /**\\n             * EVALUATE FIELD OPERATIONS\\n             */\\n\\n            /**\\n             * COMPUTE PUBLIC INPUT DELTA\\n             */\\n            {\\n                let gamma := mload(C_GAMMA_LOC)\\n                let work_root := mload(OMEGA_LOC)\\n                let endpoint := sub(mul(mload(NUM_INPUTS_LOC), 0x20), 0x20)\\n                let public_inputs\\n                let root_1 := mload(C_BETA_LOC)\\n                let root_2 := root_1\\n                let numerator_value := 1\\n                let denominator_value := 1\\n\\n                let p_clone := p // move p to the front of the stack\\n                let valid := true\\n\\n                root_1 := mulmod(root_1, 0x05, p_clone) // k1.beta\\n                root_2 := mulmod(root_2, 0x07, p_clone) // 0x05 + 0x07 = 0x0c = external coset generator\\n\\n                public_inputs := add(calldataload(0x04), 0x24)\\n                endpoint := add(endpoint, public_inputs)\\n\\n                for {} lt(public_inputs, endpoint) {} {\\n                    let input0 := calldataload(public_inputs)\\n                    let N0 := add(root_1, add(input0, gamma))\\n                    let D0 := add(root_2, N0) // 4x overloaded\\n\\n                    root_1 := mulmod(root_1, work_root, p_clone)\\n                    root_2 := mulmod(root_2, work_root, p_clone)\\n\\n                    let input1 := calldataload(add(public_inputs, 0x20))\\n                    let N1 := add(root_1, add(input1, gamma))\\n\\n                    denominator_value := mulmod(mulmod(D0, denominator_value, p_clone), add(N1, root_2), p_clone)\\n                    numerator_value := mulmod(mulmod(N1, N0, p_clone), numerator_value, p_clone)\\n\\n                    root_1 := mulmod(root_1, work_root, p_clone)\\n                    root_2 := mulmod(root_2, work_root, p_clone)\\n\\n                    valid := and(valid, and(lt(input0, p_clone), lt(input1, p_clone)))\\n                    public_inputs := add(public_inputs, 0x40)\\n\\n                    // validate public inputs are field elements (i.e. < p)\\n                    if iszero(and(lt(input0, p_clone), lt(input1, p_clone))) {\\n                        mstore(0x00, PUBLIC_INPUT_GE_P_SELECTOR)\\n                        revert(0x00, 0x04)\\n                    }\\n                }\\n\\n                endpoint := add(endpoint, 0x20)\\n                for {} lt(public_inputs, endpoint) { public_inputs := add(public_inputs, 0x20) } {\\n                    let input0 := calldataload(public_inputs)\\n\\n                    // validate public inputs are field elements (i.e. < p)\\n                    if iszero(lt(input0, p_clone)) {\\n                        mstore(0x00, PUBLIC_INPUT_GE_P_SELECTOR)\\n                        revert(0x00, 0x04)\\n                    }\\n\\n                    valid := and(valid, lt(input0, p_clone))\\n                    let T0 := addmod(input0, gamma, p_clone)\\n                    numerator_value :=\\n                        mulmod(\\n                            numerator_value,\\n                            add(root_1, T0), // 0x05 = coset_generator0\\n                            p_clone\\n                        )\\n                    denominator_value :=\\n                        mulmod(\\n                            denominator_value,\\n                            add(add(root_1, root_2), T0), // 0x0c = coset_generator7\\n                            p_clone\\n                        )\\n                    root_1 := mulmod(root_1, work_root, p_clone)\\n                    root_2 := mulmod(root_2, work_root, p_clone)\\n                }\\n\\n                mstore(DELTA_NUMERATOR_LOC, numerator_value)\\n                mstore(DELTA_DENOMINATOR_LOC, denominator_value)\\n            }\\n\\n            /**\\n             * Compute lagrange poly and vanishing poly fractions\\n             */\\n            {\\n                let zeta := mload(C_ZETA_LOC)\\n\\n                // compute zeta^n, where n is a power of 2\\n                let vanishing_numerator := zeta\\n                {\\n                    // pow_small\\n                    let exponent := mload(N_LOC)\\n                    let count := 1\\n                    for {} lt(count, exponent) { count := add(count, count) } {\\n                        vanishing_numerator := mulmod(vanishing_numerator, vanishing_numerator, p)\\n                    }\\n                }\\n                mstore(ZETA_POW_N_LOC, vanishing_numerator)\\n                vanishing_numerator := addmod(vanishing_numerator, sub(p, 1), p)\\n\\n                let accumulating_root := mload(OMEGA_INVERSE_LOC)\\n                let work_root := sub(p, accumulating_root)\\n                let domain_inverse := mload(DOMAIN_INVERSE_LOC)\\n\\n                let vanishing_denominator := addmod(zeta, work_root, p)\\n                work_root := mulmod(work_root, accumulating_root, p)\\n                vanishing_denominator := mulmod(vanishing_denominator, addmod(zeta, work_root, p), p)\\n                work_root := mulmod(work_root, accumulating_root, p)\\n                vanishing_denominator := mulmod(vanishing_denominator, addmod(zeta, work_root, p), p)\\n                vanishing_denominator :=\\n                    mulmod(vanishing_denominator, addmod(zeta, mulmod(work_root, accumulating_root, p), p), p)\\n\\n                work_root := mload(OMEGA_LOC)\\n\\n                let lagrange_numerator := mulmod(vanishing_numerator, domain_inverse, p)\\n                let l_start_denominator := addmod(zeta, sub(p, 1), p)\\n\\n                // l_end_denominator term contains a term \\\\omega^5 to cut out 5 roots of unity from vanishing poly\\n                accumulating_root := mulmod(work_root, work_root, p)\\n\\n                let l_end_denominator :=\\n                    addmod(\\n                        mulmod(mulmod(mulmod(accumulating_root, accumulating_root, p), work_root, p), zeta, p), sub(p, 1), p\\n                    )\\n\\n                /**\\n                 * Compute inversions using Montgomery's batch inversion trick\\n                 */\\n                let accumulator := mload(DELTA_DENOMINATOR_LOC)\\n                let t0 := accumulator\\n                accumulator := mulmod(accumulator, vanishing_denominator, p)\\n                let t1 := accumulator\\n                accumulator := mulmod(accumulator, l_start_denominator, p)\\n                let t2 := accumulator\\n                {\\n                    mstore(0, 0x20)\\n                    mstore(0x20, 0x20)\\n                    mstore(0x40, 0x20)\\n                    mstore(0x60, mulmod(accumulator, l_end_denominator, p))\\n                    mstore(0x80, sub(p, 2))\\n                    mstore(0xa0, p)\\n                    if iszero(staticcall(gas(), 0x05, 0x00, 0xc0, 0x00, 0x20)) {\\n                        mstore(0x0, MOD_EXP_FAILURE_SELECTOR)\\n                        revert(0x00, 0x04)\\n                    }\\n                    accumulator := mload(0x00)\\n                }\\n\\n                t2 := mulmod(accumulator, t2, p)\\n                accumulator := mulmod(accumulator, l_end_denominator, p)\\n\\n                t1 := mulmod(accumulator, t1, p)\\n                accumulator := mulmod(accumulator, l_start_denominator, p)\\n\\n                t0 := mulmod(accumulator, t0, p)\\n                accumulator := mulmod(accumulator, vanishing_denominator, p)\\n\\n                accumulator := mulmod(mulmod(accumulator, accumulator, p), mload(DELTA_DENOMINATOR_LOC), p)\\n\\n                mstore(PUBLIC_INPUT_DELTA_LOC, mulmod(mload(DELTA_NUMERATOR_LOC), accumulator, p))\\n                mstore(ZERO_POLY_LOC, mulmod(vanishing_numerator, t0, p))\\n                mstore(L_START_LOC, mulmod(lagrange_numerator, t1, p))\\n                mstore(L_END_LOC, mulmod(lagrange_numerator, t2, p))\\n            }\\n\\n            /**\\n             * COMPUTE CONSTANT TERM (r_0) OF LINEARISATION POLYNOMIAL\\n             */\\n            {\\n                let alpha := mload(C_ALPHA_LOC)\\n                let beta := mload(C_BETA_LOC)\\n                let gamma := mload(C_GAMMA_LOC)\\n                let r_0 :=\\n                    sub(\\n                        p,\\n                        mulmod(\\n                            mulmod(\\n                                mulmod(\\n                                    add(add(mload(W1_EVAL_LOC), gamma), mulmod(beta, mload(SIGMA1_EVAL_LOC), p)),\\n                                    add(add(mload(W2_EVAL_LOC), gamma), mulmod(beta, mload(SIGMA2_EVAL_LOC), p)),\\n                                    p\\n                                ),\\n                                add(mload(W3_EVAL_LOC), gamma),\\n                                p\\n                            ),\\n                            mload(Z_OMEGA_EVAL_LOC),\\n                            p\\n                        )\\n                    )\\n                // r_0 = -(\u0101 + \u03b2s\u0304_\u03c31 + \u03b3)( b\u0304 + \u03b2s\u0304_\u03c32 + \u03b3)(c\u0304 + \u03b3)z\u0304_\u03c9\\n                let alpha_sqr := mulmod(alpha, alpha, p)\\n                mstore(C_ALPHA_SQR_LOC, alpha_sqr)\\n                mstore(C_ARITHMETIC_ALPHA_LOC, mulmod(alpha_sqr, alpha_sqr, p))\\n\\n                mstore(\\n                    R_ZERO_EVAL_LOC,\\n                    mulmod(\\n                        addmod(\\n                            addmod(r_0, sub(p, mulmod(mload(L_START_LOC), alpha_sqr, p)), p),\\n                            mulmod(\\n                                mulmod(mload(L_END_LOC), alpha, p),\\n                                addmod(mload(Z_OMEGA_EVAL_LOC), sub(p, mload(PUBLIC_INPUT_DELTA_LOC)), p),\\n                                p\\n                            ),\\n                            p\\n                        ),\\n                        alpha,\\n                        p\\n                    )\\n                )\\n            }\\n\\n            /**\\n             * GENERATE NU AND SEPARATOR CHALLENGES\\n             */\\n            {\\n                let current_challenge := mload(C_CURRENT_LOC)\\n                // get a calldata pointer that points to the start of the data we want to copy\\n                let calldata_ptr := add(calldataload(0x04), 0x24)\\n                // skip over the public inputs\\n                calldata_ptr := add(calldata_ptr, mul(mload(NUM_INPUTS_LOC), 0x20))\\n                // There are SEVEN G1 group elements added into the transcript in the `beta` round, that we need to skip over\\n                // W1, W2, W3 (W4), Z, T1, T2, T3, (T4)\\n                calldata_ptr := add(calldata_ptr, 0x1c0) // 7 * 0x40 = 0x1c0\\n\\n                mstore(0x00, current_challenge)\\n                calldatacopy(0x20, calldata_ptr, 0xc0) // 6 * 0x20 = 0xc0\\n                let challenge := keccak256(0x00, 0xe0) // hash length = 0xe0 (0x20 + num field elements), we include the previous challenge in the hash\\n\\n                mstore(C_V0_LOC, mod(challenge, p))\\n\\n                mstore(0x00, challenge)\\n                mstore8(0x20, 0x01)\\n                mstore(C_V1_LOC, mod(keccak256(0x00, 0x21), p))\\n\\n                mstore8(0x20, 0x02)\\n                mstore(C_V2_LOC, mod(keccak256(0x00, 0x21), p))\\n\\n                mstore8(0x20, 0x03)\\n                mstore(C_V3_LOC, mod(keccak256(0x00, 0x21), p))\\n\\n                mstore8(0x20, 0x04)\\n                mstore(C_V4_LOC, mod(keccak256(0x00, 0x21), p))\\n\\n                mstore8(0x20, 0x05)\\n                challenge := keccak256(0x00, 0x21)\\n                mstore(C_V5_LOC, mod(challenge, p))\\n\\n                // separator\\n                mstore(0x00, challenge)\\n                mstore(0x20, mload(PI_Z_Y_LOC))\\n                mstore(0x40, mload(PI_Z_X_LOC))\\n                mstore(0x60, mload(PI_Z_OMEGA_Y_LOC))\\n                mstore(0x80, mload(PI_Z_OMEGA_X_LOC))\\n\\n                mstore(C_U_LOC, mod(keccak256(0x00, 0xa0), p))\\n            }\\n\\n            // mstore(C_ALPHA_BASE_LOC, mload(C_ALPHA_LOC))\\n\\n            /**\\n             * COMPUTE LINEARISED OPENING TERMS\\n             */\\n            {\\n                // /**\\n                //  * COMPUTE GRAND PRODUCT OPENING GROUP ELEMENT\\n                //  */\\n                let beta := mload(C_BETA_LOC)\\n                let zeta := mload(C_ZETA_LOC)\\n                let gamma := mload(C_GAMMA_LOC)\\n                let alpha := mload(C_ALPHA_LOC)\\n                let beta_zeta := mulmod(beta, zeta, p)\\n\\n                let witness_term := addmod(mload(W1_EVAL_LOC), gamma, p)\\n                let partial_grand_product := addmod(beta_zeta, witness_term, p)\\n                let sigma_multiplier := addmod(mulmod(mload(SIGMA1_EVAL_LOC), beta, p), witness_term, p)\\n                witness_term := addmod(mload(W2_EVAL_LOC), gamma, p)\\n                sigma_multiplier :=\\n                    mulmod(sigma_multiplier, addmod(mulmod(mload(SIGMA2_EVAL_LOC), beta, p), witness_term, p), p)\\n                let k1_beta_zeta := mulmod(0x05, beta_zeta, p)\\n                //  partial_grand_product = mulmod( mulmod( partial_grand_product, w2 + k1.beta.zeta + gamma , p), k2.beta.zeta + gamma + w3, p)\\n                partial_grand_product :=\\n                    mulmod(\\n                        mulmod(\\n                            partial_grand_product,\\n                            addmod(k1_beta_zeta, witness_term, p), // w2 + k1.beta.zeta + gamma\\n                            p\\n                        ),\\n                        addmod(addmod(add(k1_beta_zeta, beta_zeta), gamma, p), mload(W3_EVAL_LOC), p), // k2.beta.zeta + gamma + w3 where k2 = k1+1\\n                        p\\n                    )\\n\\n                let linear_challenge := alpha // Owing to the simplified Plonk, nu =1, linear_challenge = nu * alpha = alpha\\n\\n                mstore(0x00, mload(SIGMA3_X_LOC))\\n                mstore(0x20, mload(SIGMA3_Y_LOC))\\n                mstore(\\n                    0x40,\\n                    mulmod(\\n                        mulmod(sub(p, mulmod(sigma_multiplier, mload(Z_OMEGA_EVAL_LOC), p)), beta, p),\\n                        linear_challenge,\\n                        p\\n                    )\\n                )\\n\\n                // Validate Z\\n                let success\\n                {\\n                    let x := mload(Z_X_LOC)\\n                    let y := mload(Z_Y_LOC)\\n                    let xx := mulmod(x, x, q)\\n                    success := eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q))\\n                    mstore(0x60, x)\\n                    mstore(0x80, y)\\n                }\\n                mstore(\\n                    0xa0,\\n                    addmod(\\n                        mulmod(\\n                            addmod(partial_grand_product, mulmod(mload(L_START_LOC), mload(C_ALPHA_SQR_LOC), p), p),\\n                            linear_challenge,\\n                            p\\n                        ),\\n                        mload(C_U_LOC),\\n                        p\\n                    )\\n                )\\n                // 0x00 = SIGMA3_X_LOC,\\n                // 0x20 = SIGMA3_Y_LOC,\\n                // 0x40 = \u2212(\u0101 + \u03b2s\u0304_\u03c31 + \u03b3)( b\u0304 + \u03b2s\u0304_\u03c32 + \u03b3)\u03b1\u03b2z\u0304_\u03c9,\\n                // 0x60 = Z_X_LOC,\\n                // 0x80 = Z_Y_LOC,\\n                // 0xa0 = (\u0101 + \u03b2z + \u03b3)( b\u0304 + \u03b2k_1 z + \u03b3)(c\u0304 + \u03b2k_2 z + \u03b3)\u03b1 + L_1(z)\u03b1^3 + u\\n                success :=\\n                    and(\\n                        success,\\n                        and(\\n                            staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40),\\n                            // Why ACCUMULATOR_X_LOC := ACCUMULATOR_X_LOC + ACCUMULATOR2_X_LOC? Inner parenthesis is executed before?\\n                            and(\\n                                staticcall(gas(), 7, 0x60, 0x60, ACCUMULATOR_X_LOC, 0x40),\\n                                // [ACCUMULATOR_X_LOC, ACCUMULATOR_X_LOC + 0x40) = ((\u0101 + \u03b2z + \u03b3)( b\u0304 + \u03b2k_1 z + \u03b3)(c\u0304 + \u03b2k_2 z + \u03b3)\u03b1 + L_1(z)\u03b1^3 + u)*[z]_1\\n                                staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40)\\n                            )\\n                        )\\n                    )\\n                // [ACCUMULATOR2_X_LOC, ACCUMULATOR2_X_LOC + 0x40) = \u2212(\u0101 + \u03b2s\u0304_\u03c31 + \u03b3)( b\u0304 + \u03b2s\u0304_\u03c32 + \u03b3)\u03b1\u03b2z\u0304_\u03c9 * [s_\u03c33]_1\\n\\n                mstore(GRAND_PRODUCT_SUCCESS_FLAG, success)\\n            }\\n\\n            /**\\n             * COMPUTE ARITHMETIC SELECTOR OPENING GROUP ELEMENT\\n             */\\n            {\\n                let linear_challenge := mload(C_ARITHMETIC_ALPHA_LOC) // Owing to simplified Plonk, nu = 1,  linear_challenge = C_ARITHMETIC_ALPHA (= alpha^4)\\n\\n                let t1 := mulmod(mload(W1_EVAL_LOC), linear_challenge, p) // reuse this for QM scalar multiplier\\n                // Q1\\n                mstore(0x00, mload(Q1_X_LOC))\\n                mstore(0x20, mload(Q1_Y_LOC))\\n                mstore(0x40, t1)\\n\\n                // add Q1 scalar mul into grand product scalar mul\\n                // Observe that ACCUMULATOR_X_LOC and ACCUMULATOR2_X_LOC are 0x40 bytes apart. Below, ACCUMULATOR2_X_LOC\\n                // captures new terms Q1, Q2, and so on and they get accumulated to ACCUMULATOR_X_LOC\\n                let success :=\\n                    and(\\n                        staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40),\\n                        // [ACCUMULATOR_X_LOC, ACCUMULATOR_X_LOC + 0x40) = ((\u0101 + \u03b2z + \u03b3)( b\u0304 + \u03b2k_1 z + \u03b3)(c\u0304 + \u03b2k_2 z + \u03b3)\u03b1 + L_1(z)\u03b1^3 + u)*[z]_1 \u2212(\u0101 + \u03b2s\u0304_\u03c31 + \u03b3)( b\u0304 + \u03b2s\u0304_\u03c32 + \u03b3)\u03b1\u03b2z\u0304_\u03c9 * [s_\u03c33]_1\\n                        staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40)\\n                    )\\n                // [ACCUMULATOR2_X_LOC, ACCUMULATOR2_X_LOC + 0x40) = \u0101 * [q_L]_1\\n\\n                // Q2\\n                mstore(0x00, mload(Q2_X_LOC))\\n                mstore(0x20, mload(Q2_Y_LOC))\\n                mstore(0x40, mulmod(mload(W2_EVAL_LOC), linear_challenge, p))\\n                success :=\\n                    and(\\n                        success,\\n                        and(\\n                            staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40),\\n                            staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40)\\n                        )\\n                    )\\n\\n                // Q3\\n                mstore(0x00, mload(Q3_X_LOC))\\n                mstore(0x20, mload(Q3_Y_LOC))\\n                mstore(0x40, mulmod(mload(W3_EVAL_LOC), linear_challenge, p))\\n                success :=\\n                    and(\\n                        success,\\n                        and(\\n                            staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40),\\n                            staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40)\\n                        )\\n                    )\\n\\n                // QM\\n                mstore(0x00, mload(QM_X_LOC))\\n                mstore(0x20, mload(QM_Y_LOC))\\n                mstore(0x40, mulmod(t1, mload(W2_EVAL_LOC), p))\\n                success :=\\n                    and(\\n                        success,\\n                        and(\\n                            staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40),\\n                            staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40)\\n                        )\\n                    )\\n\\n                // QC\\n                mstore(0x00, mload(QC_X_LOC))\\n                mstore(0x20, mload(QC_Y_LOC))\\n                mstore(0x40, linear_challenge)\\n                success :=\\n                    and(\\n                        success,\\n                        and(\\n                            staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40),\\n                            staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40)\\n                        )\\n                    )\\n\\n                mstore(ARITHMETIC_TERM_SUCCESS_FLAG, success)\\n            }\\n\\n            /**\\n             * COMPUTE BATCH OPENING COMMITMENT\\n             */\\n            {\\n                // previous scalar_multiplier = 1, z^n, z^2n\\n                // scalar_multiplier owing to the simplified Plonk = 1 * -Z_H(z), z^n * -Z_H(z), z^2n * -Z_H(z)\\n                // VALIDATE T1\\n                let success\\n                {\\n                    let x := mload(T1_X_LOC)\\n                    let y := mload(T1_Y_LOC)\\n                    let xx := mulmod(x, x, q)\\n                    success := eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q))\\n                    mstore(0x00, x)\\n                    mstore(0x20, y)\\n                    mstore(0x40, sub(p, mload(ZERO_POLY_LOC)))\\n                    // mstore(ACCUMULATOR2_X_LOC, x)\\n                    // mstore(ACCUMULATOR2_Y_LOC, y)\\n                }\\n                success :=\\n                    and(\\n                        success,\\n                        and(\\n                            staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40),\\n                            staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40)\\n                        )\\n                    )\\n\\n                // VALIDATE T2\\n                let scalar_multiplier := mload(ZETA_POW_N_LOC)\\n                {\\n                    let x := mload(T2_X_LOC)\\n                    let y := mload(T2_Y_LOC)\\n                    let xx := mulmod(x, x, q)\\n                    success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                    mstore(0x00, x)\\n                    mstore(0x20, y)\\n                }\\n                mstore(0x40, mulmod(scalar_multiplier, sub(p, mload(ZERO_POLY_LOC)), p))\\n\\n                success :=\\n                    and(\\n                        staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40),\\n                        and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n                    )\\n\\n                // VALIDATE T3\\n                {\\n                    let x := mload(T3_X_LOC)\\n                    let y := mload(T3_Y_LOC)\\n                    let xx := mulmod(x, x, q)\\n                    success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                    mstore(0x00, x)\\n                    mstore(0x20, y)\\n                }\\n                mstore(0x40, mulmod(scalar_multiplier, mulmod(scalar_multiplier, sub(p, mload(ZERO_POLY_LOC)), p), p))\\n                success :=\\n                    and(\\n                        staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40),\\n                        and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n                    )\\n\\n                // VALIDATE W1\\n                {\\n                    let x := mload(W1_X_LOC)\\n                    let y := mload(W1_Y_LOC)\\n                    let xx := mulmod(x, x, q)\\n                    success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                    mstore(0x00, x)\\n                    mstore(0x20, y)\\n                }\\n                mstore(0x40, mload(C_V0_LOC))\\n\\n                success :=\\n                    and(\\n                        staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40),\\n                        and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n                    )\\n\\n                // VALIDATE W2\\n                {\\n                    let x := mload(W2_X_LOC)\\n                    let y := mload(W2_Y_LOC)\\n                    let xx := mulmod(x, x, q)\\n                    success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                    mstore(0x00, x)\\n                    mstore(0x20, y)\\n                }\\n                mstore(0x40, mload(C_V1_LOC))\\n                success :=\\n                    and(\\n                        staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40),\\n                        and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n                    )\\n\\n                // VALIDATE W3\\n                {\\n                    let x := mload(W3_X_LOC)\\n                    let y := mload(W3_Y_LOC)\\n                    let xx := mulmod(x, x, q)\\n                    success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                    mstore(0x00, x)\\n                    mstore(0x20, y)\\n                }\\n                mstore(0x40, mload(C_V2_LOC))\\n                success :=\\n                    and(\\n                        staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40),\\n                        and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n                    )\\n\\n                mstore(0x00, mload(SIGMA1_X_LOC))\\n                mstore(0x20, mload(SIGMA1_Y_LOC))\\n                mstore(0x40, mload(C_V3_LOC))\\n                success :=\\n                    and(\\n                        staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40),\\n                        and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n                    )\\n\\n                mstore(0x00, mload(SIGMA2_X_LOC))\\n                mstore(0x20, mload(SIGMA2_Y_LOC))\\n                mstore(0x40, mload(C_V4_LOC))\\n                success :=\\n                    and(\\n                        staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40),\\n                        and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n                    )\\n\\n                mstore(BATCH_OPENING_SUCCESS_FLAG, success)\\n            }\\n\\n            /**\\n             * COMPUTE BATCH EVALUATION SCALAR MULTIPLIER\\n             */\\n            {\\n                mstore(0x00, 0x01) // [1].x\\n                mstore(0x20, 0x02) // [1].y\\n                // Yul stack optimizer doing some work here...\\n                mstore(\\n                    0x40,\\n                    sub(\\n                        p,\\n                        addmod(\\n                            mulmod(mload(C_U_LOC), mload(Z_OMEGA_EVAL_LOC), p),\\n                            addmod(\\n                                sub(p, mload(R_ZERO_EVAL_LOC)), // Change owing to the simplified Plonk\\n                                addmod(\\n                                    mulmod(mload(C_V4_LOC), mload(SIGMA2_EVAL_LOC), p),\\n                                    addmod(\\n                                        mulmod(mload(C_V3_LOC), mload(SIGMA1_EVAL_LOC), p),\\n                                        addmod(\\n                                            mulmod(mload(C_V2_LOC), mload(W3_EVAL_LOC), p),\\n                                            addmod(\\n                                                mulmod(mload(C_V1_LOC), mload(W2_EVAL_LOC), p),\\n                                                mulmod(mload(C_V0_LOC), mload(W1_EVAL_LOC), p),\\n                                                p\\n                                            ),\\n                                            p\\n                                        ),\\n                                        p\\n                                    ),\\n                                    p\\n                                ),\\n                                p\\n                            ),\\n                            p\\n                        )\\n                    )\\n                )\\n\\n                let success :=\\n                    and(\\n                        staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40),\\n                        staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40)\\n                    )\\n                mstore(OPENING_COMMITMENT_SUCCESS_FLAG, success)\\n            }\\n\\n            /**\\n             * PERFORM PAIRING PREAMBLE\\n             */\\n            {\\n                let u := mload(C_U_LOC)\\n                let zeta := mload(C_ZETA_LOC)\\n                let success\\n                // VALIDATE PI_Z\\n                {\\n                    let x := mload(PI_Z_X_LOC)\\n                    let y := mload(PI_Z_Y_LOC)\\n                    let xx := mulmod(x, x, q)\\n                    success := eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q))\\n                    mstore(0x00, x)\\n                    mstore(0x20, y)\\n                }\\n                // compute zeta.[PI_Z] and add into accumulator\\n                mstore(0x40, zeta)\\n                success :=\\n                    and(\\n                        success,\\n                        and(\\n                            staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40),\\n                            staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40)\\n                        )\\n                    )\\n\\n                // VALIDATE PI_Z_OMEGA\\n                {\\n                    let x := mload(PI_Z_OMEGA_X_LOC)\\n                    let y := mload(PI_Z_OMEGA_Y_LOC)\\n                    let xx := mulmod(x, x, q)\\n                    success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                    mstore(0x00, x)\\n                    mstore(0x20, y)\\n                }\\n                // compute u.zeta.omega.[PI_Z_OMEGA] and add into accumulator\\n                mstore(0x40, mulmod(mulmod(u, zeta, p), mload(OMEGA_LOC), p))\\n                success :=\\n                    and(\\n                        staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, PAIRING_RHS_X_LOC, 0x40),\\n                        and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n                    )\\n\\n                mstore(0x00, mload(PI_Z_X_LOC))\\n                mstore(0x20, mload(PI_Z_Y_LOC))\\n                mstore(0x40, mload(PI_Z_OMEGA_X_LOC))\\n                mstore(0x60, mload(PI_Z_OMEGA_Y_LOC))\\n                mstore(0x80, u)\\n                success :=\\n                    and(\\n                        staticcall(gas(), 6, 0x00, 0x80, PAIRING_LHS_X_LOC, 0x40),\\n                        and(success, staticcall(gas(), 7, 0x40, 0x60, 0x40, 0x40))\\n                    )\\n                // negate lhs y-coordinate\\n                mstore(PAIRING_LHS_Y_LOC, sub(q, mload(PAIRING_LHS_Y_LOC)))\\n\\n                if mload(CONTAINS_RECURSIVE_PROOF_LOC) {\\n                    // VALIDATE RECURSIVE P1\\n                    {\\n                        let x := mload(RECURSIVE_P1_X_LOC)\\n                        let y := mload(RECURSIVE_P1_Y_LOC)\\n                        let xx := mulmod(x, x, q)\\n                        success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                        mstore(0x00, x)\\n                        mstore(0x20, y)\\n                    }\\n\\n                    // compute u.u.[recursive_p1] and write into 0x60\\n                    mstore(0x40, mulmod(u, u, p))\\n                    success := and(success, staticcall(gas(), 7, 0x00, 0x60, 0x60, 0x40))\\n                    // VALIDATE RECURSIVE P2\\n                    {\\n                        let x := mload(RECURSIVE_P2_X_LOC)\\n                        let y := mload(RECURSIVE_P2_Y_LOC)\\n                        let xx := mulmod(x, x, q)\\n                        success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                        mstore(0x00, x)\\n                        mstore(0x20, y)\\n                    }\\n                    // compute u.u.[recursive_p2] and write into 0x00\\n                    // 0x40 still contains u*u\\n                    success := and(success, staticcall(gas(), 7, 0x00, 0x60, 0x00, 0x40))\\n\\n                    // compute u.u.[recursiveP1] + rhs and write into rhs\\n                    mstore(0xa0, mload(PAIRING_RHS_X_LOC))\\n                    mstore(0xc0, mload(PAIRING_RHS_Y_LOC))\\n                    success := and(success, staticcall(gas(), 6, 0x60, 0x80, PAIRING_RHS_X_LOC, 0x40))\\n\\n                    // compute u.u.[recursiveP2] + lhs and write into lhs\\n                    mstore(0x40, mload(PAIRING_LHS_X_LOC))\\n                    mstore(0x60, mload(PAIRING_LHS_Y_LOC))\\n                    success := and(success, staticcall(gas(), 6, 0x00, 0x80, PAIRING_LHS_X_LOC, 0x40))\\n                }\\n\\n                if iszero(success) {\\n                    mstore(0x0, EC_SCALAR_MUL_FAILURE_SELECTOR)\\n                    revert(0x00, 0x04)\\n                }\\n                mstore(PAIRING_PREAMBLE_SUCCESS_FLAG, success)\\n            }\\n\\n            /**\\n             * PERFORM PAIRING\\n             */\\n            {\\n                // rhs paired with [1]_2\\n                // lhs paired with [x]_2\\n\\n                mstore(0x00, mload(PAIRING_RHS_X_LOC))\\n                mstore(0x20, mload(PAIRING_RHS_Y_LOC))\\n                mstore(0x40, 0x198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c2) // this is [1]_2\\n                mstore(0x60, 0x1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed)\\n                mstore(0x80, 0x090689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b)\\n                mstore(0xa0, 0x12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa)\\n\\n                mstore(0xc0, mload(PAIRING_LHS_X_LOC))\\n                mstore(0xe0, mload(PAIRING_LHS_Y_LOC))\\n                mstore(0x100, mload(G2X_X0_LOC))\\n                mstore(0x120, mload(G2X_X1_LOC))\\n                mstore(0x140, mload(G2X_Y0_LOC))\\n                mstore(0x160, mload(G2X_Y1_LOC))\\n\\n                let success := staticcall(gas(), 8, 0x00, 0x180, 0x00, 0x20)\\n                mstore(PAIRING_SUCCESS_FLAG, success)\\n                mstore(RESULT_FLAG, mload(0x00))\\n            }\\n            if iszero(\\n                and(\\n                    and(\\n                        and(\\n                            and(\\n                                and(\\n                                    and(mload(PAIRING_SUCCESS_FLAG), mload(RESULT_FLAG)),\\n                                    mload(PAIRING_PREAMBLE_SUCCESS_FLAG)\\n                                ),\\n                                mload(OPENING_COMMITMENT_SUCCESS_FLAG)\\n                            ),\\n                            mload(BATCH_OPENING_SUCCESS_FLAG)\\n                        ),\\n                        mload(ARITHMETIC_TERM_SUCCESS_FLAG)\\n                    ),\\n                    mload(GRAND_PRODUCT_SUCCESS_FLAG)\\n                )\\n            ) {\\n                mstore(0x0, PROOF_FAILURE_SELECTOR)\\n                revert(0x00, 0x04)\\n            }\\n            {\\n                mstore(0x00, 0x01)\\n                return(0x00, 0x20) // Proof succeeded!\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/core/interfaces/IVerifier.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n// Copyright 2022 Aztec\\npragma solidity >=0.8.4;\\n\\ninterface IVerifier {\\n    function verify(bytes memory _serializedProof, uint256 _publicInputsHash) external returns (bool);\\n\\n    function getVerificationKeyHash() external pure returns (bytes32);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"core/=src/core/\",\r\n      \"periphery/=src/periphery/\",\r\n      \"mocks/=src/test/mocks/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"rollup-encoder/=lib/rollup-encoder/src/\",\r\n      \"@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/\",\r\n      \"@openzeppelin/contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/\",\r\n      \"@uniswap/v2-periphery/=lib/v2-periphery/\",\r\n      \"@uniswap/v2-core/=lib/v2-core/\",\r\n      \"bridge-deployments/=lib/aztec-connect-bridges/src/deployment/\",\r\n      \"bridge-tests/=lib/aztec-connect-bridges/src/test/\",\r\n      \"bridge-interfaces/=lib/aztec-connect-bridges/src/interfaces/\",\r\n      \"aztec-connect-bridges/=lib/aztec-connect-bridges/src/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"v2-core/=lib/v2-core/contracts/\",\r\n      \"v2-periphery/=lib/v2-periphery/contracts/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 2000\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"name\":\"EC_SCALAR_MUL_FAILURE\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MOD_EXP_FAILURE\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PROOF_FAILURE\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"PUBLIC_INPUTS_HASH_VERIFICATION_FAILED\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PUBLIC_INPUT_GE_P\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PUBLIC_INPUT_INVALID_BN128_G1_POINT\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"getVerificationKeyHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"public_inputs_hash\",\"type\":\"uint256\"}],\"name\":\"verify\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Verifier28x32", "CompilerVersion": "v0.8.10+commit.fc410830", "OptimizationUsed": "1", "Runs": "2000", "ConstructorArguments": "", "EVMVersion": "london", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}