{"SourceCode": "pragma solidity 0.6.0;\r\n\r\n/**\r\n * @title Offering contract\r\n * @dev Offering logic and mining logic\r\n */\r\ncontract Nest_NToken_OfferMain {\r\n    \r\n    using SafeMath for uint256;\r\n    using address_make_payable for address;\r\n    using SafeERC20 for ERC20;\r\n    \r\n    // Offering data structure\r\n    struct Nest_NToken_OfferPriceData {\r\n        // The unique identifier is determined by the position of the offer in the array, and is converted to each other through a fixed algorithm (toindex(), toaddress())\r\n        address owner;                                  //  Offering owner\r\n        bool deviate;                                   //  Whether it deviates \r\n        address tokenAddress;                           //  The erc20 contract address of the target offer token\r\n        \r\n        uint256 ethAmount;                              //  The ETH amount in the offer list\r\n        uint256 tokenAmount;                            //  The token amount in the offer list\r\n        \r\n        uint256 dealEthAmount;                          //  The remaining number of tradable ETH\r\n        uint256 dealTokenAmount;                        //  The remaining number of tradable tokens\r\n        \r\n        uint256 blockNum;                               //  The block number where the offer is located\r\n        uint256 serviceCharge;                          //  The fee for mining\r\n        // Determine whether the asset has been collected by judging that ethamount, tokenamount, and servicecharge are all 0\r\n    }\r\n    \r\n    Nest_NToken_OfferPriceData [] _prices;                              //  Array used to save offers\r\n    Nest_3_VoteFactory _voteFactory;                                    //  Voting contract\r\n    Nest_3_OfferPrice _offerPrice;                                      //  Price contract\r\n    Nest_NToken_TokenMapping _tokenMapping;                             //  NToken mapping contract\r\n    ERC20 _nestToken;                                                   //  nestToken\r\n    Nest_3_Abonus _abonus;                                              //  Bonus pool\r\n    uint256 _miningETH = 10;                                            //  Offering mining fee ratio\r\n    uint256 _tranEth = 1;                                               //  Taker fee ratio\r\n    uint256 _tranAddition = 2;                                          //  Additional transaction multiple\r\n    uint256 _leastEth = 10 ether;                                       //  Minimum offer of ETH\r\n    uint256 _offerSpan = 10 ether;                                      //  ETH Offering span\r\n    uint256 _deviate = 10;                                              //  Price deviation - 10%\r\n    uint256 _deviationFromScale = 10;                                   //  Deviation from asset scale\r\n    uint256 _ownerMining = 5;                                           //  Creator ratio\r\n    uint256 _afterMiningAmount = 0.4 ether;                             //  Stable period mining amount\r\n    uint32 _blockLimit = 25;                                            //  Block interval upper limit\r\n    \r\n    uint256 _blockAttenuation = 2400000;                                //  Block decay interval\r\n    mapping(uint256 => mapping(address => uint256)) _blockOfferAmount;  //  Block offer times - block number=>token address=>offer fee\r\n    mapping(uint256 => mapping(address => uint256)) _blockMining;       //  Offering block mining amount - block number=>token address=>mining amount\r\n    uint256[10] _attenuationAmount;                                     //  Mining decay list\r\n    \r\n    //  Log token contract address\r\n    event OfferTokenContractAddress(address contractAddress);           \r\n    //  Log offering contract, token address, amount of ETH, amount of ERC20, delayed block, mining fee\r\n    event OfferContractAddress(address contractAddress, address tokenAddress, uint256 ethAmount, uint256 erc20Amount, uint256 continued,uint256 mining);         \r\n    //  Log transaction sender, transaction token, transaction amount, purchase token address, purchase token amount, transaction offering contract address, transaction user address\r\n    event OfferTran(address tranSender, address tranToken, uint256 tranAmount,address otherToken, uint256 otherAmount, address tradedContract, address tradedOwner);        \r\n    //  Log current block, current block mined amount, token address\r\n    event OreDrawingLog(uint256 nowBlock, uint256 blockAmount, address tokenAddress);\r\n    //  Log offering block, token address, token offered times\r\n    event MiningLog(uint256 blockNum, address tokenAddress, uint256 offerTimes);\r\n    \r\n    /**\r\n     * Initialization method\r\n     * @param voteFactory Voting contract address\r\n     **/\r\n    constructor (address voteFactory) public {\r\n        Nest_3_VoteFactory voteFactoryMap = Nest_3_VoteFactory(address(voteFactory));\r\n        _voteFactory = voteFactoryMap;                                                                 \r\n        _offerPrice = Nest_3_OfferPrice(address(voteFactoryMap.checkAddress(\"nest.v3.offerPrice\")));            \r\n        _nestToken = ERC20(voteFactoryMap.checkAddress(\"nest\"));                                                          \r\n        _abonus = Nest_3_Abonus(voteFactoryMap.checkAddress(\"nest.v3.abonus\"));\r\n        _tokenMapping = Nest_NToken_TokenMapping(address(voteFactoryMap.checkAddress(\"nest.nToken.tokenMapping\")));\r\n        \r\n        uint256 blockAmount = 4 ether;\r\n        for (uint256 i = 0; i < 10; i ++) {\r\n            _attenuationAmount[i] = blockAmount;\r\n            blockAmount = blockAmount.mul(8).div(10);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Reset voting contract method\r\n     * @param voteFactory Voting contract address\r\n     **/\r\n    function changeMapping(address voteFactory) public onlyOwner {\r\n        Nest_3_VoteFactory voteFactoryMap = Nest_3_VoteFactory(address(voteFactory));\r\n        _voteFactory = voteFactoryMap;                                                          \r\n        _offerPrice = Nest_3_OfferPrice(address(voteFactoryMap.checkAddress(\"nest.v3.offerPrice\")));      \r\n        _nestToken = ERC20(voteFactoryMap.checkAddress(\"nest\"));                                                   \r\n        _abonus = Nest_3_Abonus(voteFactoryMap.checkAddress(\"nest.v3.abonus\"));\r\n        _tokenMapping = Nest_NToken_TokenMapping(address(voteFactoryMap.checkAddress(\"nest.nToken.tokenMapping\")));\r\n    }\r\n    \r\n    /**\r\n     * Offering method\r\n     * @param ethAmount ETH amount\r\n     * @param erc20Amount Erc20 token amount\r\n     * @param erc20Address Erc20 token address\r\n     **/\r\n    function offer(uint256 ethAmount, uint256 erc20Amount, address erc20Address) public payable {\r\n        require(address(msg.sender) == address(tx.origin), \"It can't be a contract\");\r\n        address nTokenAddress = _tokenMapping.checkTokenMapping(erc20Address);\r\n        require(nTokenAddress != address(0x0));\r\n        //  Judge whether the price deviates\r\n        uint256 ethMining;\r\n        bool isDeviate = comparativePrice(ethAmount,erc20Amount,erc20Address);\r\n        if (isDeviate) {\r\n            require(ethAmount >= _leastEth.mul(_deviationFromScale), \"EthAmount needs to be no less than 10 times of the minimum scale\");\r\n            ethMining = _leastEth.mul(_miningETH).div(1000);\r\n        } else {\r\n            ethMining = ethAmount.mul(_miningETH).div(1000);\r\n        }\r\n        require(msg.value >= ethAmount.add(ethMining), \"msg.value needs to be equal to the quoted eth quantity plus Mining handling fee\");\r\n        uint256 subValue = msg.value.sub(ethAmount.add(ethMining));\r\n        if (subValue > 0) {\r\n            repayEth(address(msg.sender), subValue);\r\n        }\r\n        //  Create an offer\r\n        createOffer(ethAmount, erc20Amount, erc20Address,isDeviate, ethMining);\r\n        //  Transfer in offer asset - erc20 to this contract\r\n        ERC20(erc20Address).safeTransferFrom(address(msg.sender), address(this), erc20Amount);\r\n        _abonus.switchToEthForNTokenOffer.value(ethMining)(nTokenAddress);\r\n        //  Mining\r\n        if (_blockOfferAmount[block.number][erc20Address] == 0) {\r\n            uint256 miningAmount = oreDrawing(nTokenAddress);\r\n            Nest_NToken nToken = Nest_NToken(nTokenAddress);\r\n            nToken.transfer(nToken.checkBidder(), miningAmount.mul(_ownerMining).div(100));\r\n            _blockMining[block.number][erc20Address] = miningAmount.sub(miningAmount.mul(_ownerMining).div(100));\r\n        }\r\n        _blockOfferAmount[block.number][erc20Address] = _blockOfferAmount[block.number][erc20Address].add(ethMining);\r\n    }\r\n    \r\n    /**\r\n     * @dev Create offer\r\n     * @param ethAmount Offering ETH amount\r\n     * @param erc20Amount Offering erc20 amount\r\n     * @param erc20Address Offering erc20 address\r\n     **/\r\n    function createOffer(uint256 ethAmount, uint256 erc20Amount, address erc20Address, bool isDeviate, uint256 mining) private {\r\n        // Check offer conditions\r\n        require(ethAmount >= _leastEth, \"Eth scale is smaller than the minimum scale\");                                                 \r\n        require(ethAmount % _offerSpan == 0, \"Non compliant asset span\");\r\n        require(erc20Amount % (ethAmount.div(_offerSpan)) == 0, \"Asset quantity is not divided\");\r\n        require(erc20Amount > 0);\r\n        // Create offering contract\r\n        emit OfferContractAddress(toAddress(_prices.length), address(erc20Address), ethAmount, erc20Amount,_blockLimit,mining);\r\n        _prices.push(Nest_NToken_OfferPriceData(\r\n            msg.sender,\r\n            isDeviate,\r\n            erc20Address,\r\n            \r\n            ethAmount,\r\n            erc20Amount,\r\n            \r\n            ethAmount, \r\n            erc20Amount, \r\n            \r\n            block.number,\r\n            mining\r\n        ));\r\n        // Record price\r\n        _offerPrice.addPrice(ethAmount, erc20Amount, block.number.add(_blockLimit), erc20Address, address(msg.sender));\r\n    }\r\n    \r\n    // Convert offer address into index in offer array\r\n    function toIndex(address contractAddress) public pure returns(uint256) {\r\n        return uint256(contractAddress);\r\n    }\r\n    \r\n    // Convert index in offer array into offer address \r\n    function toAddress(uint256 index) public pure returns(address) {\r\n        return address(index);\r\n    }\r\n    \r\n    /**\r\n     * Withdraw offer assets\r\n     * @param contractAddress Offer address\r\n     **/\r\n    function turnOut(address contractAddress) public {\r\n        require(address(msg.sender) == address(tx.origin), \"It can't be a contract\");\r\n        uint256 index = toIndex(contractAddress);\r\n        Nest_NToken_OfferPriceData storage offerPriceData = _prices[index];\r\n        require(checkContractState(offerPriceData.blockNum) == 1, \"Offer status error\");\r\n        // Withdraw ETH\r\n        if (offerPriceData.ethAmount > 0) {\r\n            uint256 payEth = offerPriceData.ethAmount;\r\n            offerPriceData.ethAmount = 0;\r\n            repayEth(offerPriceData.owner, payEth);\r\n        }\r\n        // Withdraw erc20\r\n        if (offerPriceData.tokenAmount > 0) {\r\n            uint256 payErc = offerPriceData.tokenAmount;\r\n            offerPriceData.tokenAmount = 0;\r\n            ERC20(address(offerPriceData.tokenAddress)).transfer(offerPriceData.owner, payErc);\r\n            \r\n        }\r\n        // Mining settlement\r\n        if (offerPriceData.serviceCharge > 0) {\r\n            mining(offerPriceData.blockNum, offerPriceData.tokenAddress, offerPriceData.serviceCharge, offerPriceData.owner);\r\n            offerPriceData.serviceCharge = 0;\r\n        }\r\n    }\r\n    \r\n    /**\r\n    * @dev Taker order - pay ETH and buy erc20\r\n    * @param ethAmount The amount of ETH of this offer\r\n    * @param tokenAmount The amount of erc20 of this offer\r\n    * @param contractAddress The target offer address\r\n    * @param tranEthAmount The amount of ETH of taker order\r\n    * @param tranTokenAmount The amount of erc20 of taker order\r\n    * @param tranTokenAddress The erc20 address of taker order\r\n    */\r\n    function sendEthBuyErc(uint256 ethAmount, uint256 tokenAmount, address contractAddress, uint256 tranEthAmount, uint256 tranTokenAmount, address tranTokenAddress) public payable {\r\n        require(address(msg.sender) == address(tx.origin), \"It can't be a contract\");\r\n        uint256 serviceCharge = tranEthAmount.mul(_tranEth).div(1000);\r\n        require(msg.value == ethAmount.add(tranEthAmount).add(serviceCharge), \"msg.value needs to be equal to the quotation eth quantity plus transaction eth plus\");\r\n        require(tranEthAmount % _offerSpan == 0, \"Transaction size does not meet asset span\");\r\n        \r\n        //  Get the offer data structure\r\n        uint256 index = toIndex(contractAddress);\r\n        Nest_NToken_OfferPriceData memory offerPriceData = _prices[index]; \r\n        //  Check the price, compare the current offer to the last effective price\r\n        bool thisDeviate = comparativePrice(ethAmount,tokenAmount,tranTokenAddress);\r\n        bool isDeviate;\r\n        if (offerPriceData.deviate == true) {\r\n            isDeviate = true;\r\n        } else {\r\n            isDeviate = thisDeviate;\r\n        }\r\n        //  Limit the taker order only be twice the amount of the offer to prevent large-amount attacks\r\n        if (offerPriceData.deviate) {\r\n            //  The taker order deviates  x2\r\n            require(ethAmount >= tranEthAmount.mul(_tranAddition), \"EthAmount needs to be no less than 2 times of transaction scale\");\r\n        } else {\r\n            if (isDeviate) {\r\n                //  If the taken offer is normal and the taker order deviates x10\r\n                require(ethAmount >= tranEthAmount.mul(_deviationFromScale), \"EthAmount needs to be no less than 10 times of transaction scale\");\r\n            } else {\r\n                //  If the taken offer is normal and the taker order is normal x2\r\n                require(ethAmount >= tranEthAmount.mul(_tranAddition), \"EthAmount needs to be no less than 2 times of transaction scale\");\r\n            }\r\n        }\r\n        \r\n        // Check whether the conditions for taker order are satisfied\r\n        require(checkContractState(offerPriceData.blockNum) == 0, \"Offer status error\");\r\n        require(offerPriceData.dealEthAmount >= tranEthAmount, \"Insufficient trading eth\");\r\n        require(offerPriceData.dealTokenAmount >= tranTokenAmount, \"Insufficient trading token\");\r\n        require(offerPriceData.tokenAddress == tranTokenAddress, \"Wrong token address\");\r\n        require(tranTokenAmount == offerPriceData.dealTokenAmount * tranEthAmount / offerPriceData.dealEthAmount, \"Wrong token amount\");\r\n        \r\n        // Update the offer information\r\n        offerPriceData.ethAmount = offerPriceData.ethAmount.add(tranEthAmount);\r\n        offerPriceData.tokenAmount = offerPriceData.tokenAmount.sub(tranTokenAmount);\r\n        offerPriceData.dealEthAmount = offerPriceData.dealEthAmount.sub(tranEthAmount);\r\n        offerPriceData.dealTokenAmount = offerPriceData.dealTokenAmount.sub(tranTokenAmount);\r\n        _prices[index] = offerPriceData;\r\n        // Create a new offer\r\n        createOffer(ethAmount, tokenAmount, tranTokenAddress, isDeviate, 0);\r\n        // Transfer in erc20 + offer asset to this contract\r\n        if (tokenAmount > tranTokenAmount) {\r\n            ERC20(tranTokenAddress).safeTransferFrom(address(msg.sender), address(this), tokenAmount.sub(tranTokenAmount));\r\n        } else {\r\n            ERC20(tranTokenAddress).safeTransfer(address(msg.sender), tranTokenAmount.sub(tokenAmount));\r\n        }\r\n\r\n        // Modify price\r\n        _offerPrice.changePrice(tranEthAmount, tranTokenAmount, tranTokenAddress, offerPriceData.blockNum.add(_blockLimit));\r\n        emit OfferTran(address(msg.sender), address(0x0), tranEthAmount, address(tranTokenAddress), tranTokenAmount, contractAddress, offerPriceData.owner);\r\n        \r\n        // Transfer fee\r\n        if (serviceCharge > 0) {\r\n            address nTokenAddress = _tokenMapping.checkTokenMapping(tranTokenAddress);\r\n            _abonus.switchToEth.value(serviceCharge)(nTokenAddress);\r\n        }\r\n    }\r\n    \r\n    /**\r\n    * @dev Taker order - pay erc20 and buy ETH\r\n    * @param ethAmount The amount of ETH of this offer\r\n    * @param tokenAmount The amount of erc20 of this offer\r\n    * @param contractAddress The target offer address\r\n    * @param tranEthAmount The amount of ETH of taker order\r\n    * @param tranTokenAmount The amount of erc20 of taker order\r\n    * @param tranTokenAddress The erc20 address of taker order\r\n    */\r\n    function sendErcBuyEth(uint256 ethAmount, uint256 tokenAmount, address contractAddress, uint256 tranEthAmount, uint256 tranTokenAmount, address tranTokenAddress) public payable {\r\n        require(address(msg.sender) == address(tx.origin), \"It can't be a contract\");\r\n        uint256 serviceCharge = tranEthAmount.mul(_tranEth).div(1000);\r\n        require(msg.value == ethAmount.sub(tranEthAmount).add(serviceCharge), \"msg.value needs to be equal to the quoted eth quantity plus transaction handling fee\");\r\n        require(tranEthAmount % _offerSpan == 0, \"Transaction size does not meet asset span\");\r\n        //  Get the offer data structure\r\n        uint256 index = toIndex(contractAddress);\r\n        Nest_NToken_OfferPriceData memory offerPriceData = _prices[index]; \r\n        //  Check the price, compare the current offer to the last effective price\r\n        bool thisDeviate = comparativePrice(ethAmount,tokenAmount,tranTokenAddress);\r\n        bool isDeviate;\r\n        if (offerPriceData.deviate == true) {\r\n            isDeviate = true;\r\n        } else {\r\n            isDeviate = thisDeviate;\r\n        }\r\n        //  Limit the taker order only be twice the amount of the offer to prevent large-amount attacks\r\n        if (offerPriceData.deviate) {\r\n            //  The taker order deviates  x2\r\n            require(ethAmount >= tranEthAmount.mul(_tranAddition), \"EthAmount needs to be no less than 2 times of transaction scale\");\r\n        } else {\r\n            if (isDeviate) {\r\n                //  If the taken offer is normal and the taker order deviates x10\r\n                require(ethAmount >= tranEthAmount.mul(_deviationFromScale), \"EthAmount needs to be no less than 10 times of transaction scale\");\r\n            } else {\r\n                //  If the taken offer is normal and the taker order is normal x2\r\n                require(ethAmount >= tranEthAmount.mul(_tranAddition), \"EthAmount needs to be no less than 2 times of transaction scale\");\r\n            }\r\n        }\r\n        // Check whether the conditions for taker order are satisfied\r\n        require(checkContractState(offerPriceData.blockNum) == 0, \"Offer status error\");\r\n        require(offerPriceData.dealEthAmount >= tranEthAmount, \"Insufficient trading eth\");\r\n        require(offerPriceData.dealTokenAmount >= tranTokenAmount, \"Insufficient trading token\");\r\n        require(offerPriceData.tokenAddress == tranTokenAddress, \"Wrong token address\");\r\n        require(tranTokenAmount == offerPriceData.dealTokenAmount * tranEthAmount / offerPriceData.dealEthAmount, \"Wrong token amount\");\r\n        // Update the offer information\r\n        offerPriceData.ethAmount = offerPriceData.ethAmount.sub(tranEthAmount);\r\n        offerPriceData.tokenAmount = offerPriceData.tokenAmount.add(tranTokenAmount);\r\n        offerPriceData.dealEthAmount = offerPriceData.dealEthAmount.sub(tranEthAmount);\r\n        offerPriceData.dealTokenAmount = offerPriceData.dealTokenAmount.sub(tranTokenAmount);\r\n        _prices[index] = offerPriceData;\r\n        // Create a new offer\r\n        createOffer(ethAmount, tokenAmount, tranTokenAddress, isDeviate, 0);\r\n        // Transfer in erc20 + offer asset to this contract\r\n        ERC20(tranTokenAddress).safeTransferFrom(address(msg.sender), address(this), tranTokenAmount.add(tokenAmount));\r\n        // Modify price\r\n        _offerPrice.changePrice(tranEthAmount, tranTokenAmount, tranTokenAddress, offerPriceData.blockNum.add(_blockLimit));\r\n        emit OfferTran(address(msg.sender), address(tranTokenAddress), tranTokenAmount, address(0x0), tranEthAmount, contractAddress, offerPriceData.owner);\r\n        // Transfer fee\r\n        if (serviceCharge > 0) {\r\n            address nTokenAddress = _tokenMapping.checkTokenMapping(tranTokenAddress);\r\n            _abonus.switchToEth.value(serviceCharge)(nTokenAddress);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Offering mining\r\n     * @param ntoken NToken address\r\n     **/\r\n    function oreDrawing(address ntoken) private returns(uint256) {\r\n        Nest_NToken miningToken = Nest_NToken(ntoken);\r\n        (uint256 createBlock, uint256 recentlyUsedBlock) = miningToken.checkBlockInfo();\r\n        uint256 attenuationPointNow = block.number.sub(createBlock).div(_blockAttenuation);\r\n        uint256 miningAmount = 0;\r\n        uint256 attenuation;\r\n        if (attenuationPointNow > 9) {\r\n            attenuation = _afterMiningAmount;\r\n        } else {\r\n            attenuation = _attenuationAmount[attenuationPointNow];\r\n        }\r\n        miningAmount = attenuation.mul(block.number.sub(recentlyUsedBlock));\r\n        miningToken.increaseTotal(miningAmount);\r\n        emit OreDrawingLog(block.number, miningAmount, ntoken);\r\n        return miningAmount;\r\n    }\r\n    \r\n    /**\r\n     * Retrieve mining\r\n     * @param token Token address\r\n     **/\r\n    function mining(uint256 blockNum, address token, uint256 serviceCharge, address owner) private returns(uint256) {\r\n        //  Block mining amount*offer fee/block offer fee\r\n        uint256 miningAmount = _blockMining[blockNum][token].mul(serviceCharge).div(_blockOfferAmount[blockNum][token]);        \r\n        //  Transfer NToken \r\n        Nest_NToken nToken = Nest_NToken(address(_tokenMapping.checkTokenMapping(token)));\r\n        require(nToken.transfer(address(owner), miningAmount), \"Transfer failure\");\r\n        \r\n        emit MiningLog(blockNum, token,_blockOfferAmount[blockNum][token]);\r\n        return miningAmount;\r\n    }\r\n    \r\n    // Compare order prices\r\n    function comparativePrice(uint256 myEthValue, uint256 myTokenValue, address token) private view returns(bool) {\r\n        (uint256 frontEthValue, uint256 frontTokenValue) = _offerPrice.updateAndCheckPricePrivate(token);\r\n        if (frontEthValue == 0 || frontTokenValue == 0) {\r\n            return false;\r\n        }\r\n        uint256 maxTokenAmount = myEthValue.mul(frontTokenValue).mul(uint256(100).add(_deviate)).div(frontEthValue.mul(100));\r\n        if (myTokenValue <= maxTokenAmount) {\r\n            uint256 minTokenAmount = myEthValue.mul(frontTokenValue).mul(uint256(100).sub(_deviate)).div(frontEthValue.mul(100));\r\n            if (myTokenValue >= minTokenAmount) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    \r\n    // Check contract status\r\n    function checkContractState(uint256 createBlock) public view returns (uint256) {\r\n        if (block.number.sub(createBlock) > _blockLimit) {\r\n            return 1;\r\n        }\r\n        return 0;\r\n    }\r\n    \r\n    // Transfer ETH\r\n    function repayEth(address accountAddress, uint256 asset) private {\r\n        address payable addr = accountAddress.make_payable();\r\n        addr.transfer(asset);\r\n    }\r\n    \r\n    // View the upper limit of the block interval\r\n    function checkBlockLimit() public view returns(uint256) {\r\n        return _blockLimit;\r\n    }\r\n    \r\n    // View taker fee ratio\r\n    function checkTranEth() public view returns (uint256) {\r\n        return _tranEth;\r\n    }\r\n    \r\n    // View additional transaction multiple\r\n    function checkTranAddition() public view returns(uint256) {\r\n        return _tranAddition;\r\n    }\r\n    \r\n    // View minimum offering ETH\r\n    function checkleastEth() public view returns(uint256) {\r\n        return _leastEth;\r\n    }\r\n    \r\n    // View offering ETH span\r\n    function checkOfferSpan() public view returns(uint256) {\r\n        return _offerSpan;\r\n    }\r\n\r\n    // View block offering amount\r\n    function checkBlockOfferAmount(uint256 blockNum, address token) public view returns (uint256) {\r\n        return _blockOfferAmount[blockNum][token];\r\n    }\r\n    \r\n    // View offering block mining amount\r\n    function checkBlockMining(uint256 blockNum, address token) public view returns (uint256) {\r\n        return _blockMining[blockNum][token];\r\n    }\r\n    \r\n    // View offering mining amount\r\n    function checkOfferMining(uint256 blockNum, address token, uint256 serviceCharge) public view returns (uint256) {\r\n        if (serviceCharge == 0) {\r\n            return 0;\r\n        } else {\r\n            return _blockMining[blockNum][token].mul(serviceCharge).div(_blockOfferAmount[blockNum][token]);\r\n        }\r\n    }\r\n    \r\n    //  View the owner allocation ratio\r\n    function checkOwnerMining() public view returns(uint256) {\r\n        return _ownerMining;\r\n    }\r\n    \r\n    // View the mining decay\r\n    function checkAttenuationAmount(uint256 num) public view returns(uint256) {\r\n        return _attenuationAmount[num];\r\n    }\r\n    \r\n    // Modify taker order fee ratio\r\n    function changeTranEth(uint256 num) public onlyOwner {\r\n        _tranEth = num;\r\n    }\r\n    \r\n    // Modify block interval upper limit\r\n    function changeBlockLimit(uint32 num) public onlyOwner {\r\n        _blockLimit = num;\r\n    }\r\n    \r\n    // Modify additional transaction multiple\r\n    function changeTranAddition(uint256 num) public onlyOwner {\r\n        require(num > 0, \"Parameter needs to be greater than 0\");\r\n        _tranAddition = num;\r\n    }\r\n    \r\n    // Modify minimum offering ETH\r\n    function changeLeastEth(uint256 num) public onlyOwner {\r\n        require(num > 0, \"Parameter needs to be greater than 0\");\r\n        _leastEth = num;\r\n    }\r\n    \r\n    // Modify offering ETH span\r\n    function changeOfferSpan(uint256 num) public onlyOwner {\r\n        require(num > 0, \"Parameter needs to be greater than 0\");\r\n        _offerSpan = num;\r\n    }\r\n    \r\n    // Modify price deviation\r\n    function changekDeviate(uint256 num) public onlyOwner {\r\n        _deviate = num;\r\n    }\r\n    \r\n    // Modify the deviation from scale \r\n    function changeDeviationFromScale(uint256 num) public onlyOwner {\r\n        _deviationFromScale = num;\r\n    }\r\n    \r\n    // Modify the owner allocation ratio\r\n    function changeOwnerMining(uint256 num) public onlyOwner {\r\n        _ownerMining = num;\r\n    }\r\n    \r\n    // Modify the mining decay\r\n    function changeAttenuationAmount(uint256 firstAmount, uint256 top, uint256 bottom) public onlyOwner {\r\n        uint256 blockAmount = firstAmount;\r\n        for (uint256 i = 0; i < 10; i ++) {\r\n            _attenuationAmount[i] = blockAmount;\r\n            blockAmount = blockAmount.mul(top).div(bottom);\r\n        }\r\n    }\r\n    \r\n    // Vote administrators only\r\n    modifier onlyOwner(){\r\n        require(_voteFactory.checkOwners(msg.sender), \"No authority\");\r\n        _;\r\n    }\r\n    \r\n    /**\r\n     * Get the number of offers stored in the offer array\r\n     * @return The number of offers stored in the offer array\r\n     **/\r\n    function getPriceCount() view public returns (uint256) {\r\n        return _prices.length;\r\n    }\r\n    \r\n    /**\r\n     * Get offer information according to the index\r\n     * @param priceIndex Offer index\r\n     * @return Offer information\r\n     **/\r\n    function getPrice(uint256 priceIndex) view public returns (string memory) {\r\n        //  The buffer array used to generate the result string\r\n        bytes memory buf = new bytes(500000);\r\n        uint256 index = 0;\r\n        index = writeOfferPriceData(priceIndex, _prices[priceIndex], buf, index);\r\n        // Generate the result string and return\r\n        bytes memory str = new bytes(index);\r\n        while(index-- > 0) {\r\n            str[index] = buf[index];\r\n        }\r\n        return string(str);\r\n    }\r\n    \r\n    /**\r\n     * Search the contract address list of the target account (reverse order)\r\n     * @param start Search forward from the index corresponding to the given contract address (not including the record corresponding to start address)\r\n     * @param count Maximum number of records to return\r\n     * @param maxFindCount The max index to search\r\n     * @param owner Target account address\r\n     * @return Separate the offer records with symbols. use , to divide fields:  \r\n     * uuid,owner,tokenAddress,ethAmount,tokenAmount,dealEthAmount,dealTokenAmount,blockNum,serviceCharge\r\n     **/\r\n    function find(address start, uint256 count, uint256 maxFindCount, address owner) view public returns (string memory) {\r\n        // Buffer array used to generate result string\r\n        bytes memory buf = new bytes(500000);\r\n        uint256 index = 0;\r\n        // Calculate search interval i and end\r\n        uint256 i = _prices.length;\r\n        uint256 end = 0;\r\n        if (start != address(0)) {\r\n            i = toIndex(start);\r\n        }\r\n        if (i > maxFindCount) {\r\n            end = i - maxFindCount;\r\n        }\r\n        // Loop search, write qualified records into buffer\r\n        while (count > 0 && i-- > end) {\r\n            Nest_NToken_OfferPriceData memory price = _prices[i];\r\n            if (price.owner == owner) {\r\n                --count;\r\n                index = writeOfferPriceData(i, price, buf, index);\r\n            }\r\n        }\r\n        // Generate result string and return\r\n        bytes memory str = new bytes(index);\r\n        while(index-- > 0) {\r\n            str[index] = buf[index];\r\n        }\r\n        return string(str);\r\n    }\r\n    \r\n    /**\r\n     * Get the list of offers by page\r\n     * @param offset Skip the first offset records\r\n     * @param count Maximum number of records to return\r\n     * @param order Sort rules. 0 means reverse order, non-zero means positive order\r\n     * @return Separate the offer records with symbols. use , to divide fields: \r\n     * uuid,owner,tokenAddress,ethAmount,tokenAmount,dealEthAmount,dealTokenAmount,blockNum,serviceCharge\r\n     **/\r\n    function list(uint256 offset, uint256 count, uint256 order) view public returns (string memory) {\r\n        \r\n        // Buffer array used to generate result string \r\n        bytes memory buf = new bytes(500000);\r\n        uint256 index = 0;\r\n        \r\n        // Find search interval i and end\r\n        uint256 i = 0;\r\n        uint256 end = 0;\r\n        \r\n        if (order == 0) {\r\n            // Reverse order, in default \r\n            // Calculate search interval i and end\r\n            if (offset < _prices.length) {\r\n                i = _prices.length - offset;\r\n            } \r\n            if (count < i) {\r\n                end = i - count;\r\n            }\r\n            \r\n            // Write records in the target interval into the buffer\r\n            while (i-- > end) {\r\n                index = writeOfferPriceData(i, _prices[i], buf, index);\r\n            }\r\n        } else {\r\n            // Ascending order\r\n            // Calculate the search interval i and end\r\n            if (offset < _prices.length) {\r\n                i = offset;\r\n            } else {\r\n                i = _prices.length;\r\n            }\r\n            end = i + count;\r\n            if(end > _prices.length) {\r\n                end = _prices.length;\r\n            }\r\n            \r\n            // Write the records in the target interval into the buffer\r\n            while (i < end) {\r\n                index = writeOfferPriceData(i, _prices[i], buf, index);\r\n                ++i;\r\n            }\r\n        }\r\n        \r\n        // Generate the result string and return\r\n        bytes memory str = new bytes(index);\r\n        while(index-- > 0) {\r\n            str[index] = buf[index];\r\n        }\r\n        return string(str);\r\n    }   \r\n     \r\n    // Write the offer data into the buffer and return the buffer index\r\n    function writeOfferPriceData(uint256 priceIndex, Nest_NToken_OfferPriceData memory price, bytes memory buf, uint256 index) pure private returns (uint256) {\r\n        \r\n        index = writeAddress(toAddress(priceIndex), buf, index);\r\n        buf[index++] = byte(uint8(44));\r\n        \r\n        index = writeAddress(price.owner, buf, index);\r\n        buf[index++] = byte(uint8(44));\r\n        \r\n        index = writeAddress(price.tokenAddress, buf, index);\r\n        buf[index++] = byte(uint8(44));\r\n        \r\n        index = writeUInt(price.ethAmount, buf, index);\r\n        buf[index++] = byte(uint8(44));\r\n        \r\n        index = writeUInt(price.tokenAmount, buf, index);\r\n        buf[index++] = byte(uint8(44));\r\n       \r\n        index = writeUInt(price.dealEthAmount, buf, index);\r\n        buf[index++] = byte(uint8(44));\r\n        \r\n        index = writeUInt(price.dealTokenAmount, buf, index);\r\n        buf[index++] = byte(uint8(44));\r\n        \r\n        index = writeUInt(price.blockNum, buf, index);\r\n        buf[index++] = byte(uint8(44));\r\n        \r\n        index = writeUInt(price.serviceCharge, buf, index);\r\n        buf[index++] = byte(uint8(44));\r\n        \r\n        return index;\r\n    }\r\n     \r\n    // Convert integer to string in decimal form, write the string into the buffer, and return the buffer index\r\n    function writeUInt(uint256 iv, bytes memory buf, uint256 index) pure public returns (uint256) {\r\n        uint256 i = index;\r\n        do {\r\n            buf[index++] = byte(uint8(iv % 10 +48));\r\n            iv /= 10;\r\n        } while (iv > 0);\r\n        \r\n        for (uint256 j = index; j > i; ++i) {\r\n            byte t = buf[i];\r\n            buf[i] = buf[--j];\r\n            buf[j] = t;\r\n        }\r\n        \r\n        return index;\r\n    }\r\n\r\n    // Convert the address to a hexadecimal string and write it into the buffer, and return the buffer index\r\n    function writeAddress(address addr, bytes memory buf, uint256 index) pure private returns (uint256) {\r\n        \r\n        uint256 iv = uint256(addr);\r\n        uint256 i = index + 40;\r\n        do {\r\n            uint256 w = iv % 16;\r\n            if(w < 10) {\r\n                buf[index++] = byte(uint8(w +48));\r\n            } else {\r\n                buf[index++] = byte(uint8(w +87));\r\n            }\r\n            \r\n            iv /= 16;\r\n        } while (index < i);\r\n        \r\n        i -= 40;\r\n        for (uint256 j = index; j > i; ++i) {\r\n            byte t = buf[i];\r\n            buf[i] = buf[--j];\r\n            buf[j] = t;\r\n        }\r\n        \r\n        return index;\r\n    }\r\n}\r\n\r\n// Price contract\r\ninterface Nest_3_OfferPrice {\r\n    // Add price data\r\n    function addPrice(uint256 ethAmount, uint256 tokenAmount, uint256 endBlock, address tokenAddress, address offerOwner) external;\r\n    // Modify price\r\n    function changePrice(uint256 ethAmount, uint256 tokenAmount, address tokenAddress, uint256 endBlock) external;\r\n    function updateAndCheckPricePrivate(address tokenAddress) external view returns(uint256 ethAmount, uint256 erc20Amount);\r\n}\r\n\r\n// Voting contract\r\ninterface Nest_3_VoteFactory {\r\n    //  Check address\r\n\tfunction checkAddress(string calldata name) external view returns (address contractAddress);\r\n\t// Check whether an administrator\r\n\tfunction checkOwners(address man) external view returns (bool);\r\n}\r\n\r\n// NToken contract\r\ninterface Nest_NToken {\r\n    // Additional issuance\r\n    function increaseTotal(uint256 value) external;\r\n    // Check mining information\r\n    function checkBlockInfo() external view returns(uint256 createBlock, uint256 recentlyUsedBlock);\r\n    // Check creator\r\n    function checkBidder() external view returns(address);\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// NToken mapping contract\r\ninterface Nest_NToken_TokenMapping {\r\n    // Check token mapping\r\n    function checkTokenMapping(address token) external view returns (address);\r\n}\r\n\r\n// Bonus pool contract\r\ninterface Nest_3_Abonus {\r\n    function switchToEth(address token) external payable;\r\n    function switchToEthForNTokenOffer(address token) external payable;\r\n}\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\nlibrary address_make_payable {\r\n   function make_payable(address x) internal pure returns (address payable) {\r\n      return address(uint160(x));\r\n   }\r\n}\r\n\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(ERC20 token, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(ERC20 token, address from, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function safeApprove(ERC20 token, address spender, uint256 value) internal {\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(ERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(ERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n    function callOptionalReturn(ERC20 token, bytes memory data) private {\r\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0) {\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\ninterface ERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\nlibrary Address {\r\n    function isContract(address account) internal view returns (bool) {\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n        (bool success, ) = recipient.call.value(amount)(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"voteFactory\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"blockNum\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"offerTimes\",\"type\":\"uint256\"}],\"name\":\"MiningLog\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"erc20Amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"continued\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mining\",\"type\":\"uint256\"}],\"name\":\"OfferContractAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"OfferTokenContractAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tranSender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tranToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tranAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"otherToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"otherAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tradedContract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tradedOwner\",\"type\":\"address\"}],\"name\":\"OfferTran\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nowBlock\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"blockAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"OreDrawingLog\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"firstAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"top\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bottom\",\"type\":\"uint256\"}],\"name\":\"changeAttenuationAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"num\",\"type\":\"uint32\"}],\"name\":\"changeBlockLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"num\",\"type\":\"uint256\"}],\"name\":\"changeDeviationFromScale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"num\",\"type\":\"uint256\"}],\"name\":\"changeLeastEth\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"voteFactory\",\"type\":\"address\"}],\"name\":\"changeMapping\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"num\",\"type\":\"uint256\"}],\"name\":\"changeOfferSpan\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"num\",\"type\":\"uint256\"}],\"name\":\"changeOwnerMining\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"num\",\"type\":\"uint256\"}],\"name\":\"changeTranAddition\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"num\",\"type\":\"uint256\"}],\"name\":\"changeTranEth\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"num\",\"type\":\"uint256\"}],\"name\":\"changekDeviate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"num\",\"type\":\"uint256\"}],\"name\":\"checkAttenuationAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"checkBlockLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"blockNum\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"checkBlockMining\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"blockNum\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"checkBlockOfferAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"createBlock\",\"type\":\"uint256\"}],\"name\":\"checkContractState\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"blockNum\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"serviceCharge\",\"type\":\"uint256\"}],\"name\":\"checkOfferMining\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"checkOfferSpan\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"checkOwnerMining\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"checkTranAddition\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"checkTranEth\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"checkleastEth\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"start\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFindCount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"find\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"priceIndex\",\"type\":\"uint256\"}],\"name\":\"getPrice\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPriceCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"offset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"order\",\"type\":\"uint256\"}],\"name\":\"list\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ethAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"erc20Amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"erc20Address\",\"type\":\"address\"}],\"name\":\"offer\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ethAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tranEthAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tranTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tranTokenAddress\",\"type\":\"address\"}],\"name\":\"sendErcBuyEth\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ethAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tranEthAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tranTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tranTokenAddress\",\"type\":\"address\"}],\"name\":\"sendEthBuyErc\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"toAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"toIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"turnOut\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"iv\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"buf\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"writeUInt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]", "ContractName": "Nest_NToken_OfferMain", "CompilerVersion": "v0.6.0+commit.26b70077", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000006cd5698e8854fb6879d6b1c694223b389b465dea", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU GPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://1abb1bbe3f8f8756f9e4b5108a0bdcb6f162e61194794f574e54f679bf0a4620"}