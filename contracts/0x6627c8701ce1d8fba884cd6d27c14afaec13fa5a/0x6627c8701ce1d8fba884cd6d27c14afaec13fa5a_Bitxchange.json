{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"Bitxchange.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n//\\r\\n// No-gas required token swapping to ETH.\\r\\n// https://xc.bitx.cx\\r\\n//\\r\\n// Keeps gas cost and fee\\r\\n// 90% fee sent to $bitx stakers\\r\\n// $Bitx: 0xD150e07f602bf3239BE3DE4341E10BE1678a3f8b\\r\\n//\\r\\n// Buy & Stake: https://token.bitx.cx\\r\\n//\\r\\n// Developed by @Rotwang9000 for https://Bitx.cx\\r\\n// https://t.me/BitXcx\\r\\n//\\r\\n// Register for Airdrop: https://t.me/BitxLiveBot\\r\\n\\r\\npragma solidity ^0.8.20;\\r\\n\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\\\";\\r\\nimport \\\"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\\\";\\r\\n\\r\\ninterface IRewardPot {\\r\\n    function addToRewardPot() external payable;\\r\\n}\\r\\n\\r\\ncontract Bitxchange is Ownable {\\r\\n    IUniswapV2Router02 public uniswapRouter;\\r\\n    IRewardPot public rewardPot;\\r\\n    uint256 public feePercentage = 750; // 0.75% fee, scaled by 10^4\\r\\n    uint256 public estimatedGasForSwap = 250000;\\r\\n    address public relayer;\\r\\n\\r\\n    event FeeUpdated(uint256 newFee);\\r\\n    event RewardPotUpdated(address newRewardPot);\\r\\n    event SwapSuccessful(address indexed from, uint256 receivedETH);\\r\\n\\r\\n    constructor(\\r\\n        address _uniswapRouter,\\r\\n        address _rewardPot,\\r\\n        address _relayer\\r\\n    ) Ownable(msg.sender) {\\r\\n        uniswapRouter = IUniswapV2Router02(_uniswapRouter);\\r\\n        rewardPot = IRewardPot(_rewardPot);\\r\\n        relayer = _relayer;\\r\\n    }\\r\\n\\r\\n    // Payable function\\r\\n    function receiveFunds() public payable {}\\r\\n\\r\\n    receive() external payable {}\\r\\n\\r\\n    // Payable fallback function (Solidity 0.6.0 and later)\\r\\n    fallback() external payable {}\\r\\n\\r\\n    // Owner deposits ETH into the contract\\r\\n    function depositETH() external payable {}\\r\\n\\r\\n    modifier onlyRelayer() {\\r\\n        require(\\r\\n            msg.sender == relayer || msg.sender == owner(),\\r\\n            \\\"Not the relayer\\\"\\r\\n        );\\r\\n        _;\\r\\n    }\\r\\n\\r\\n\\tfunction uniswapAddress() public view returns(address){\\r\\n\\t\\treturn address(uniswapRouter);\\r\\n\\t}\\r\\n\\r\\n    // Owner can withdraw ETH\\r\\n    function withdrawETH(uint256 amount) external onlyOwner {\\r\\n        payable(owner()).transfer(amount);\\r\\n    }\\r\\n\\r\\n    function setRelayer(address _newRelayer) external onlyOwner {\\r\\n        relayer = _newRelayer;\\r\\n    }\\r\\n\\r\\n    function setFeePercentage(uint256 _newFee) external onlyOwner {\\r\\n        feePercentage = _newFee;\\r\\n        emit FeeUpdated(_newFee);\\r\\n    }\\r\\n\\r\\n    function setEstimatedGasForSwap(\\r\\n        uint256 _newEstimatedGasForSwap\\r\\n    ) external onlyOwner {\\r\\n        estimatedGasForSwap = _newEstimatedGasForSwap;\\r\\n    }\\r\\n\\r\\n    function setUniswapRouter(address _newRouter) external onlyOwner {\\r\\n        require(_newRouter != address(0), \\\"Invalid address\\\");\\r\\n        uniswapRouter = IUniswapV2Router02(_newRouter);\\r\\n    }\\r\\n\\r\\n    function setRewardPot(address _newRewardPot) external onlyOwner {\\r\\n        require(_newRewardPot != address(0), \\\"Invalid address\\\");\\r\\n        rewardPot = IRewardPot(_newRewardPot);\\r\\n        emit RewardPotUpdated(_newRewardPot);\\r\\n    }\\r\\n\\r\\n    function rescueTokens(\\r\\n        address token,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) external onlyRelayer {\\r\\n        uint256 balance = IERC20(token).balanceOf(address(this));\\r\\n        require(amount <= balance, \\\"Not enough tokens to rescue\\\");\\r\\n        require(IERC20(token).transfer(to, amount), \\\"Transfer failed\\\");\\r\\n    }\\r\\n\\r\\n    function tryGetAmountsOut(\\r\\n        uint amountIn,\\r\\n        address[] memory path\\r\\n    ) internal view returns (bool success, uint256 amountOut) {\\r\\n        try uniswapRouter.getAmountsOut(amountIn, path) returns (\\r\\n            uint256[] memory amounts\\r\\n        ) {\\r\\n            return (true, amounts[1]);\\r\\n        } catch {\\r\\n            return (false, 0);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // Function to check if a swap is possible\\r\\n    function canSwap(\\r\\n        address token,\\r\\n        uint256 amountIn,\\r\\n        uint256 userGasPrice\\r\\n    ) public view returns (bool) {\\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = token;\\r\\n        path[1] = uniswapRouter.WETH();\\r\\n\\r\\n        // Check if there's enough liquidity for the swap\\r\\n        (bool success, uint256 amountOut) = tryGetAmountsOut(amountIn, path);\\r\\n        if (!success || amountOut == 0) {\\r\\n            return false;\\r\\n        }\\r\\n\\r\\n        // Estimate gas cost and check against the minimum output amount\\r\\n        uint256 estimatedGasCost = estimatedGasForSwap * userGasPrice;\\r\\n        if (estimatedGasCost >= amountOut) {\\r\\n            return false;\\r\\n        }\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function getSwapQuote(\\r\\n        address token,\\r\\n        uint256 amount,\\r\\n        uint256 slippage,\\r\\n        uint256 userGasPrice\\r\\n    )\\r\\n        public\\r\\n        view\\r\\n        returns (uint256 minAmountOut, uint256 estimatedGasCost, bool canDoSwap)\\r\\n    {\\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = token;\\r\\n        path[1] = uniswapRouter.WETH();\\r\\n\\r\\n        // Get the expected output amount based on the input amount and path\\r\\n        (bool success, uint256 expectedAmountOut) = tryGetAmountsOut(\\r\\n            amount,\\r\\n            path\\r\\n        );\\r\\n        require(success, \\\"No liquidity for this token\\\");\\r\\n\\r\\n        // Apply slippage\\r\\n        minAmountOut = (expectedAmountOut * (10000 - slippage)) / 10000;\\r\\n\\r\\n        // Benchmark gas for Uniswap swap: 184,523 (from Ethereum.org)\\r\\n        // Adding a 20% buffer for other operations and fluctuations: ~221,428\\r\\n        //uint256 estimatedGasForSwap = 221428;\\r\\n\\r\\n        // Calculate estimated gas cost based on user-provided gas price\\r\\n        estimatedGasCost = estimatedGasForSwap * userGasPrice;\\r\\n\\r\\n        return (\\r\\n            minAmountOut,\\r\\n            estimatedGasCost,\\r\\n            canSwap(token, amount, userGasPrice)\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function swapTokensWithPermit(\\r\\n        address token,\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount,\\r\\n        uint256 minAmountOut,\\r\\n        uint expectedAmountOut,\\r\\n        uint unpaidFees,\\r\\n        uint256 deadline,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) public payable onlyRelayer {\\r\\n        IERC20Permit(token).permit(\\r\\n            from,\\r\\n            address(this),\\r\\n            amount,\\r\\n            deadline,\\r\\n            v,\\r\\n            r,\\r\\n            s\\r\\n        );\\r\\n\\r\\n        // Perform the swap\\r\\n        return\\r\\n            swapTokensWithTransfer(\\r\\n                token,\\r\\n                from,\\r\\n                to,\\r\\n                amount,\\r\\n                minAmountOut,\\r\\n                expectedAmountOut,\\r\\n                unpaidFees\\r\\n            );\\r\\n    }\\r\\n\\r\\n    function swapTokensWithTransfer(\\r\\n        address token,\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount,\\r\\n        uint256 minAmountOut,\\r\\n        uint expectedAmountOut,\\r\\n        uint unpaidFees\\r\\n    ) public payable onlyRelayer {\\r\\n        require(\\r\\n            IERC20(token).transferFrom(from, address(this), amount),\\r\\n            \\\"Transfer Failed\\\"\\r\\n        );\\r\\n\\r\\n        return\\r\\n            swapTokensForETH(\\r\\n                token,\\r\\n                to,\\r\\n                amount,\\r\\n                minAmountOut,\\r\\n                expectedAmountOut,\\r\\n                unpaidFees\\r\\n            );\\r\\n    }\\r\\n\\r\\n    function swapTokensForETH(\\r\\n        address token,\\r\\n        address to,\\r\\n        uint256 amount,\\r\\n        uint256 minAmountOut,\\r\\n        uint expectedAmountOut,\\r\\n        uint unpaidFees\\r\\n    ) public payable onlyRelayer {\\r\\n        uint256 gasCost = gasleft();\\r\\n\\r\\n        // Estimate gas cost and check against minAmountOut\\r\\n        uint256 estimatedGasCost = estimatedGasForSwap * tx.gasprice;\\r\\n        require(\\r\\n            estimatedGasCost + unpaidFees < minAmountOut,\\r\\n            \\\"Estimated gas cost exceeds minAmountOut\\\"\\r\\n        );\\r\\n        require(\\r\\n            expectedAmountOut >= minAmountOut,\\r\\n            \\\"Expected amount less than minimum requested\\\"\\r\\n        );\\r\\n\\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = token;\\r\\n        path[1] = uniswapRouter.WETH();\\r\\n\\r\\n        // Check tokens are in the contract\\r\\n        require(\\r\\n            IERC20(token).balanceOf(address(this)) >= amount,\\r\\n            \\\"Token not in contract\\\"\\r\\n        );\\r\\n\\r\\n        // Perform the swap\\r\\n        IERC20(token).approve(address(uniswapRouter), amount);\\r\\n\\r\\n        uint256[] memory amounts = uniswapRouter.swapExactTokensForETH(\\r\\n            amount,\\r\\n            minAmountOut,\\r\\n            path,\\r\\n            address(this),\\r\\n            block.timestamp\\r\\n        );\\r\\n        gasCost = ((gasCost - gasleft()) + 100000) * tx.gasprice; // including extra for the transfers after this\\r\\n        gasCost = gasCost + unpaidFees;\\r\\n        uint receivedETH = amounts[1];\\r\\n        if (gasCost > receivedETH) {\\r\\n            payable(msg.sender).transfer(gasCost);\\r\\n        } else {\\r\\n            payable(msg.sender).transfer(gasCost);\\r\\n\\r\\n            receivedETH = amounts[1] - gasCost;\\r\\n            // Calculate the fee-free zone and the excess amount\\r\\n            uint256 feeFreeZone = expectedAmountOut > minAmountOut\\r\\n                ? expectedAmountOut - minAmountOut\\r\\n                : 0;\\r\\n            uint256 excessAmount = receivedETH > expectedAmountOut\\r\\n                ? receivedETH - expectedAmountOut\\r\\n                : 0;\\r\\n\\r\\n            // Calculate and send the fee\\r\\n            uint256 totalFee = (((receivedETH - feeFreeZone - excessAmount) *\\r\\n                feePercentage) / 10000) + (excessAmount * 40) / 100; // 40% of the excess amount\\r\\n\\r\\n            // Send 90% of the total fee to the reward pot\\r\\n            rewardPot.addToRewardPot{value: (totalFee * 90) / 100}();\\r\\n\\r\\n            // The remaining fee stays in the contract\\r\\n\\r\\n            // Send the remaining ETH back to the original sender\\r\\n            payable(to).transfer(receivedETH - totalFee);\\r\\n        }\\r\\n\\r\\n        emit SwapSuccessful(to, receivedETH);\\r\\n    }\\r\\n\\r\\n    function swapTokensForETH_UserPaysGas_withPermit(\\r\\n        address token,\\r\\n        uint256 amount,\\r\\n        uint256 minAmountOut,\\r\\n        uint256 deadline,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) external payable {\\r\\n\\t\\tif(deadline > block.timestamp){\\r\\n\\t\\t\\tIERC20Permit(token).permit(\\r\\n\\t\\t\\t\\tmsg.sender,\\r\\n\\t\\t\\t\\taddress(this),\\r\\n\\t\\t\\t\\tamount,\\r\\n\\t\\t\\t\\tdeadline,\\r\\n\\t\\t\\t\\tv,\\r\\n\\t\\t\\t\\tr,\\r\\n\\t\\t\\t\\ts\\r\\n\\t\\t\\t);\\r\\n\\t\\t}\\r\\n        // Perform the swap\\r\\n        return swapTokensForETH_UserPaysGas(token, amount, minAmountOut);\\r\\n    }\\r\\n\\r\\n    function swapTokensForETH_UserPaysGas(\\r\\n        address token,\\r\\n        uint256 amount,\\r\\n        uint256 minAmountOut\\r\\n    ) public payable {\\r\\n        // Perform the swap\\r\\n        IERC20(token).transferFrom(msg.sender, address(this), amount);\\r\\n        IERC20(token).approve(address(uniswapRouter), amount);\\r\\n\\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = token;\\r\\n        path[1] = uniswapRouter.WETH();\\r\\n\\r\\n        uint256[] memory amounts = uniswapRouter.swapExactTokensForETH(\\r\\n            amount,\\r\\n            minAmountOut,\\r\\n            path,\\r\\n            address(this),\\r\\n            block.timestamp\\r\\n        );\\r\\n        uint256 receivedETH = amounts[1];\\r\\n\\r\\n        // Calculate and send the fee\\r\\n        uint256 fee = (receivedETH * feePercentage) / 10000;\\r\\n\\r\\n        // Send 90% of the fee to the reward pot\\r\\n        rewardPot.addToRewardPot{value: (fee * 90) / 100}();\\r\\n\\r\\n        // The remaining 10% fee stays in the contract\\r\\n\\r\\n        // Send the remaining ETH back to the original sender\\r\\n        payable(msg.sender).transfer(receivedETH - fee);\\r\\n\\r\\n        emit SwapSuccessful(msg.sender, receivedETH);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.2;\\n\\nimport './IUniswapV2Router01.sol';\\n\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountETH);\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountETH);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable;\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Permit.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n *\\n * ==== Security Considerations\\n *\\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\\n * generally recommended is:\\n *\\n * ```solidity\\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\\n *     doThing(..., value);\\n * }\\n *\\n * function doThing(..., uint256 value) public {\\n *     token.safeTransferFrom(msg.sender, address(this), value);\\n *     ...\\n * }\\n * ```\\n *\\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\\n * {SafeERC20-safeTransferFrom}).\\n *\\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\\n * contracts should have entry points that don't rely on permit.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     *\\n     * CAUTION: See Security Considerations above.\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the value of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the value of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\n     * allowance mechanism. `value` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Context} from \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * The initial owner is set to the address provided by the deployer. This can\\n * later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    /**\\n     * @dev The caller account is not authorized to perform an operation.\\n     */\\n    error OwnableUnauthorizedAccount(address account);\\n\\n    /**\\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\\n     */\\n    error OwnableInvalidOwner(address owner);\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\\n     */\\n    constructor(address initialOwner) {\\n        if (initialOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(initialOwner);\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        if (owner() != _msgSender()) {\\n            revert OwnableUnauthorizedAccount(_msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        if (newOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.2;\\n\\ninterface IUniswapV2Router01 {\\n    function factory() external pure returns (address);\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETH(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountToken, uint amountETH);\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountToken, uint amountETH);\\n    function swapExactTokensForTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapTokensForExactTokens(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Context.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_uniswapRouter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_rewardPot\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_relayer\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnableInvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnableUnauthorizedAccount\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newFee\",\"type\":\"uint256\"}],\"name\":\"FeeUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newRewardPot\",\"type\":\"address\"}],\"name\":\"RewardPotUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"receivedETH\",\"type\":\"uint256\"}],\"name\":\"SwapSuccessful\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"userGasPrice\",\"type\":\"uint256\"}],\"name\":\"canSwap\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositETH\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"estimatedGasForSwap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feePercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"slippage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"userGasPrice\",\"type\":\"uint256\"}],\"name\":\"getSwapQuote\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"minAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"estimatedGasCost\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"canDoSwap\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"receiveFunds\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"relayer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"rescueTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardPot\",\"outputs\":[{\"internalType\":\"contract IRewardPot\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newEstimatedGasForSwap\",\"type\":\"uint256\"}],\"name\":\"setEstimatedGasForSwap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newFee\",\"type\":\"uint256\"}],\"name\":\"setFeePercentage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newRelayer\",\"type\":\"address\"}],\"name\":\"setRelayer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newRewardPot\",\"type\":\"address\"}],\"name\":\"setRewardPot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newRouter\",\"type\":\"address\"}],\"name\":\"setUniswapRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expectedAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unpaidFees\",\"type\":\"uint256\"}],\"name\":\"swapTokensForETH\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minAmountOut\",\"type\":\"uint256\"}],\"name\":\"swapTokensForETH_UserPaysGas\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"swapTokensForETH_UserPaysGas_withPermit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expectedAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unpaidFees\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"swapTokensWithPermit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expectedAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unpaidFees\",\"type\":\"uint256\"}],\"name\":\"swapTokensWithTransfer\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapRouter\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Bitxchange", "CompilerVersion": "v0.8.22+commit.4fc1097e", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000c532a74256d3db42d0bf7a0400fefdbad7694008000000000000000000000000d150e07f602bf3239be3de4341e10be1678a3f8b000000000000000000000000d895bc94d1413a36938dee9c3c377fce35651927", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}