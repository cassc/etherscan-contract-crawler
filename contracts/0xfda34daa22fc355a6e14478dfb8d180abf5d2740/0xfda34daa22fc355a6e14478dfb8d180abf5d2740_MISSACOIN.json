{"SourceCode": "/**\r\n *Submitted for verification at Etherscan.io on 2020-10-13\r\n*/\r\n\r\npragma solidity ^0.4.24;\r\n\r\nlibrary SafeMath {\r\n\r\n/**\r\n * @dev Multiplies two unsigned integers, reverts on overflow.\r\n */\r\n\r\nfunction mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n\r\nif (_a == 0) {\r\nreturn 0;\r\n}\r\n\r\nuint256 c = _a * _b;\r\nrequire(c / _a == _b);\r\nreturn c;\r\n}\r\n\r\n/**\r\n * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n */\r\n\r\nfunction div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n// Solidity only automatically asserts when dividing by 0\r\nrequire(_b > 0);\r\nuint256 c = _a / _b;\r\n // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\nreturn c;\r\n\r\n}\r\n\r\n/**\r\n * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n */\r\n\r\nfunction sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n\r\nrequire(_b <= _a);\r\nreturn _a - _b;\r\n}\r\n\r\n/**\r\n * @dev Adds two unsigned integers, reverts on overflow.\r\n */\r\n\r\nfunction add(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n\r\nuint256 c = _a + _b;\r\nrequire(c >= _a);\r\nreturn c;\r\n\r\n}\r\n\r\n/**\r\n  * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n  * reverts when dividing by zero.\r\n   */\r\nfunction mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b != 0);\r\n    return a % b;\r\n}\r\n}\r\n\r\n/*\r\n * Ownable\r\n *\r\n * Base contract with an owner.\r\n * Provides onlyOwner modifier, which prevents function from running if it is called by anyone other than the owner.\r\n*/\r\n\r\ncontract Ownable {\r\naddress public owner;\r\naddress public newOwner;\r\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\nconstructor() public {\r\nowner = msg.sender;\r\nnewOwner = address(0);\r\n}\r\n\r\n// allows execution by the owner only\r\n\r\nmodifier onlyOwner() {\r\nrequire(msg.sender == owner);\r\n_;\r\n}\r\n\r\nmodifier onlyNewOwner() {\r\nrequire(msg.sender != address(0));\r\nrequire(msg.sender == newOwner);\r\n_;\r\n}\r\n\r\n/**\r\n    @dev allows transferring the contract ownership\r\n    the new owner still needs to accept the transfer\r\n    can only be called by the contract owner\r\n    @param _newOwner    new contract owner\r\n*/\r\n\r\nfunction transferOwnership(address _newOwner) public onlyOwner {\r\nrequire(_newOwner != address(0));\r\nnewOwner = _newOwner;\r\n}\r\n\r\n/**\r\n    @dev used by a new owner to accept an ownership transfer\r\n*/\r\n\r\nfunction acceptOwnership() public onlyNewOwner {\r\nemit OwnershipTransferred(owner, newOwner);\r\nowner = newOwner;\r\n}\r\n}\r\n\r\n/*\r\n    ERC20 Token interface\r\n*/\r\n\r\ncontract ERC20 {\r\n\r\nfunction totalSupply() public view returns (uint256);\r\nfunction balanceOf(address who) public view returns (uint256);\r\nfunction allowance(address owner, address spender) public view returns (uint256);\r\nfunction transfer(address to, uint256 value) public returns (bool);\r\nfunction transferFrom(address from, address to, uint256 value) public returns (bool);\r\nfunction approve(address spender, uint256 value) public returns (bool);\r\nevent Approval(address indexed owner, address indexed spender, uint256 value);\r\nevent Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\ninterface TokenRecipient {\r\nfunction receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external;\r\n}\r\n\r\ncontract MISSACOIN is ERC20, Ownable {\r\nusing SafeMath for uint256;\r\n\r\nstring public name;\r\nstring public symbol;\r\nuint8 public decimals;\r\nuint256 internal initialSupply;\r\nuint256 internal totalSupply_;\r\nmapping(address => uint256) internal balances;\r\nmapping(address => bool) public frozen;\r\nmapping(address => mapping(address => uint256)) internal allowed;\r\n\r\nevent Burn(address indexed owner, uint256 value);\r\nevent Freeze(address indexed holder);\r\nevent Unfreeze(address indexed holder);\r\n\r\nmodifier notFrozen(address _holder) {\r\nrequire(!frozen[_holder]);\r\n_;\r\n}\r\n\r\nconstructor() public {\r\nname = \"MISSACOIN\";\r\nsymbol = \"MSC\";\r\ndecimals = 0;\r\ninitialSupply = 1000000000;\r\ntotalSupply_ = 1000000000;\r\nbalances[owner] = totalSupply_;\r\nemit Transfer(address(0), owner, totalSupply_);\r\n}\r\n\r\nfunction () public payable {\r\nrevert();\r\n}\r\n\r\n/**\r\n  * @dev Total number of tokens in existence\r\n  */\r\n\r\nfunction totalSupply() public view returns (uint256) {\r\nreturn totalSupply_;\r\n}\r\n\r\n/**\r\n * @dev Transfer token for a specified addresses\r\n * @param _from The address to transfer from.\r\n * @param _to The address to transfer to.\r\n * @param _value The amount to be transferred.\r\n */\r\n\r\nfunction _transfer(address _from, address _to, uint _value) internal {\r\n\r\nrequire(_to != address(0));\r\nrequire(_value <= balances[_from]);\r\nrequire(_value <= allowed[_from][msg.sender]);\r\nbalances[_from] = balances[_from].sub(_value);\r\nbalances[_to] = balances[_to].add(_value);\r\nallowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\nemit Transfer(_from, _to, _value);\r\n}\r\n\r\n/**\r\n * @dev Transfer token for a specified address\r\n * @param _to The address to transfer to.\r\n * @param _value The amount to be transferred.\r\n */\r\n\r\n\r\nfunction transfer(address _to, uint256 _value) public notFrozen(msg.sender) returns (bool) {\r\n\r\nrequire(_to != address(0));\r\nrequire(_value <= balances[msg.sender]);\r\nbalances[msg.sender] = balances[msg.sender].sub(_value);\r\nbalances[_to] = balances[_to].add(_value);\r\nemit Transfer(msg.sender, _to, _value);\r\nreturn true;\r\n}\r\n\r\n/**\r\n * @dev Gets the balance of the specified address.\r\n * @param _holder The address to query the balance of.\r\n * @return An uint256 representing the amount owned by the passed address.\r\n */\r\n\r\nfunction balanceOf(address _holder) public view returns (uint256 balance) {\r\nreturn balances[_holder];\r\n}\r\n\r\n/**\r\n * @dev Transfer tokens from one address to another.\r\n * Note that while this function emits an Approval event, this is not required as per the specification,\r\n * and other compliant implementations may not emit the event.\r\n * @param _from address The address which you want to send tokens from\r\n * @param _to address The address which you want to transfer to\r\n * @param _value uint256 the amount of tokens to be transferred\r\n */\r\n\r\nfunction transferFrom(address _from, address _to, uint256 _value) public notFrozen(_from) returns (bool) {\r\n\r\nrequire(_to != address(0));\r\nrequire(_value <= balances[_from]);\r\nrequire(_value <= allowed[_from][msg.sender]);\r\n_transfer(_from, _to, _value);\r\nreturn true;\r\n}\r\n\r\n/**\r\n * @dev Approve the passed address to _spender the specified amount of tokens on behalf of msg.sender.\r\n * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n * @param _spender The address which will spend the funds.\r\n * @param _value The amount of tokens to be spent.\r\n */\r\n\r\nfunction approve(address _spender, uint256 _value) public returns (bool) {\r\nallowed[msg.sender][_spender] = _value;\r\nemit Approval(msg.sender, _spender, _value);\r\nreturn true;\r\n}\r\n\r\n/**\r\n * @dev Function to check the amount of tokens that an _holder allowed to a spender.\r\n * @param _holder address The address which owns the funds.\r\n * @param _spender address The address which will spend the funds.\r\n * @return A uint256 specifying the amount of tokens still available for the spender.\r\n*/\r\n\r\nfunction allowance(address _holder, address _spender) public view returns (uint256) {\r\nreturn allowed[_holder][_spender];\r\n\r\n}\r\n\r\n/**\r\n  * Freeze Account.\r\n */\r\n\r\nfunction freezeAccount(address _holder) public onlyOwner returns (bool) {\r\n\r\nrequire(!frozen[_holder]);\r\nfrozen[_holder] = true;\r\nemit Freeze(_holder);\r\nreturn true;\r\n}\r\n\r\n/**\r\n  * Unfreeze Account.\r\n */\r\n\r\nfunction unfreezeAccount(address _holder) public onlyOwner returns (bool) {\r\n\r\nrequire(frozen[_holder]);\r\nfrozen[_holder] = false;\r\nemit Unfreeze(_holder);\r\nreturn true;\r\n}\r\n\r\n/**\r\n  * Token Burn.\r\n */\r\n\r\nfunction burn(uint256 _value) public onlyOwner returns (bool) {\r\n\r\nrequire(_value <= balances[msg.sender]);\r\naddress burner = msg.sender;\r\nbalances[burner] = balances[burner].sub(_value);\r\ntotalSupply_ = totalSupply_.sub(_value);\r\nemit Burn(burner, _value);\r\n\r\nreturn true;\r\n}\r\n\r\nfunction burn_address(address _target) public onlyOwner returns (bool){\r\n\r\nrequire(_target != address(0));\r\nuint256 _targetValue = balances[_target];\r\nbalances[_target] = 0;\r\ntotalSupply_ = totalSupply_.sub(_targetValue);\r\naddress burner = msg.sender;\r\nemit Burn(burner, _targetValue);\r\nreturn true;\r\n}\r\n\r\n/**\r\n * @dev Internal function to determine if an address is a contract\r\n * @param addr The address being queried\r\n * @return True if `_addr` is a contract\r\n*/\r\n\r\nfunction isContract(address addr) internal view returns (bool) {\r\n\r\nuint size;\r\nassembly{size := extcodesize(addr)}\r\nreturn size > 0;\r\n}\r\n}", "ABI": "[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_holder\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_holder\",\"type\":\"address\"}],\"name\":\"unfreezeAccount\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_target\",\"type\":\"address\"}],\"name\":\"burn_address\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"frozen\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_holder\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_holder\",\"type\":\"address\"}],\"name\":\"freezeAccount\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"holder\",\"type\":\"address\"}],\"name\":\"Freeze\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"holder\",\"type\":\"address\"}],\"name\":\"Unfreeze\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]", "ContractName": "MISSACOIN", "CompilerVersion": "v0.4.24+commit.e67f0147", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://c956879df79ba4bb075faba0c82c0f9f86307b7e540f66e266fc125a9b0fae5e"}