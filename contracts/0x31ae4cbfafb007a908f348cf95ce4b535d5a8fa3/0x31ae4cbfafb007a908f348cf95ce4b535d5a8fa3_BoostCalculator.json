{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"BoostCalculator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.19;\\n\\nimport \\\"ITokenLocker.sol\\\";\\nimport \\\"SystemStart.sol\\\";\\n\\n/**\\n    @title Prisma Boost Calculator\\n    @notice \\\"Boost\\\" refers to a bonus to claimable PRISMA tokens that an account\\n            receives based on it's locked PRISMA weight. An account with \\\"Max boost\\\"\\n            is earning PRISMA rewards at 2x the rate of an account that is unboosted.\\n            Boost works as follows:\\n\\n            * In a given week, the percentage of the weekly PRISMA rewards that an\\n            account can claim with maximum boost is the same as the percentage\\n            of PRISMA lock weight that the account has, relative to the total lock\\n            weight.\\n            * Once an account's weekly claims exceed the amount allowed with max boost,\\n            the boost rate decays linearly from 2x to 1x. This decay occurs over the same\\n            amount of tokens that were available for maximum boost.\\n            * Once an account's weekly claims are more than double the amount allowed for\\n            max boost, the boost bonus is fully depleted.\\n            * At the start of the next week, boost amounts are recalculated.\\n\\n            As an example:\\n\\n            * At the end of week 1, Alice has a lock weight of 100. There is a total\\n              lock weight of 1,000. Alice controls 10% of the total lock weight.\\n            * During week 2, a total of 500,000 new PRISMA rewards are made available\\n            * Because Alice has 10% of the lock weight in week 1, during week 2 she\\n              can claim up to 10% of the rewards (50,000 PRISMA) with her full boost.\\n            * Once Alice's weekly claim exceeds 50,000 PRISMA, her boost decays linearly\\n              as she claims another 50,000 PRISMA.\\n            * Once Alice's weekly claims exceed 100,000 PRISMA, any further claims are\\n              \\\"unboosted\\\" and receive only half as many tokens as they would have boosted.\\n            * At the start of the next week, Alice's boost is fully replenished. She still\\n              controls 10% of the total lock weight, so she can claim another 10% of this\\n              week's emissions at full boost.\\n\\n            Note that boost is applied at the time of claiming a reward, not at the time\\n            the reward was earned. An account that has depleted it's boost may opt to wait\\n            for the start of the next week in order to claim with a larger boost.\\n\\n            On a technical level, we consider the full earned reward to be the maximum\\n            boosted amount. \\\"Unboosted\\\" is more accurately described as \\\"paying a 50%\\n            penalty\\\". Rewards that go undistributed due to claims with lowered boost\\n            are returned to the unallocated token supply, and distributed again in the\\n            emissions of future weeks.\\n */\\ncontract BoostCalculator is SystemStart {\\n    ITokenLocker public immutable locker;\\n\\n    // initial number of weeks where all accounts recieve max boost\\n    uint256 public immutable MAX_BOOST_GRACE_WEEKS;\\n\\n    // week -> total weekly lock weight\\n    // tracked locally to avoid repeated external calls\\n    uint40[65535] totalWeeklyWeights;\\n    // account -> week -> % of lock weight (where 1e9 represents 100%)\\n    mapping(address account => uint32[65535]) accountWeeklyLockPct;\\n\\n    constructor(address _prismaCore, ITokenLocker _locker, uint256 _graceWeeks) SystemStart(_prismaCore) {\\n        require(_graceWeeks > 0, \\\"Grace weeks cannot be 0\\\");\\n        locker = _locker;\\n        MAX_BOOST_GRACE_WEEKS = _graceWeeks + getWeek();\\n    }\\n\\n    /**\\n        @notice Get the adjusted claim amount after applying an account's boost\\n        @param account Address claiming the reward\\n        @param amount Amount being claimed (assuming maximum boost)\\n        @param previousAmount Amount that was already claimed in the current week\\n        @param totalWeeklyEmissions Total PRISMA emissions released this week\\n        @return adjustedAmount Amount of PRISMA received after applying boost\\n     */\\n    function getBoostedAmount(\\n        address account,\\n        uint256 amount,\\n        uint256 previousAmount,\\n        uint256 totalWeeklyEmissions\\n    ) external view returns (uint256 adjustedAmount) {\\n        uint256 week = getWeek();\\n        if (week < MAX_BOOST_GRACE_WEEKS) return amount;\\n        week -= 1;\\n\\n        uint256 accountWeight = locker.getAccountWeightAt(account, week);\\n        uint256 totalWeight = locker.getTotalWeightAt(week);\\n        if (totalWeight == 0) totalWeight = 1;\\n        uint256 pct = (1e9 * accountWeight) / totalWeight;\\n        if (pct == 0) pct = 1;\\n        return _getBoostedAmount(amount, previousAmount, totalWeeklyEmissions, pct);\\n    }\\n\\n    /**\\n        @notice Get the remaining claimable amounts this week that will receive boost\\n        @param claimant address to query boost amounts for\\n        @param previousAmount Amount that was already claimed in the current week\\n        @param totalWeeklyEmissions Total PRISMA emissions released this week\\n        @return maxBoosted remaining claimable amount that will receive max boost\\n        @return boosted remaining claimable amount that will receive some amount of boost (including max boost)\\n     */\\n    function getClaimableWithBoost(\\n        address claimant,\\n        uint256 previousAmount,\\n        uint256 totalWeeklyEmissions\\n    ) external view returns (uint256 maxBoosted, uint256 boosted) {\\n        uint256 week = getWeek();\\n        if (week < MAX_BOOST_GRACE_WEEKS) {\\n            uint256 remaining = totalWeeklyEmissions - previousAmount;\\n            return (remaining, remaining);\\n        }\\n        week -= 1;\\n\\n        uint256 accountWeight = locker.getAccountWeightAt(claimant, week);\\n        uint256 totalWeight = locker.getTotalWeightAt(week);\\n        if (totalWeight == 0) totalWeight = 1;\\n        uint256 pct = (1e9 * accountWeight) / totalWeight;\\n        if (pct == 0) return (0, 0);\\n\\n        uint256 maxBoostable = (totalWeeklyEmissions * pct) / 1e9;\\n        uint256 fullDecay = maxBoostable * 2;\\n\\n        return (\\n            previousAmount >= maxBoostable ? 0 : maxBoostable - previousAmount,\\n            previousAmount >= fullDecay ? 0 : fullDecay - maxBoostable\\n        );\\n    }\\n\\n    /**\\n        @notice Get the adjusted claim amount after applying an account's boost\\n        @dev Stores lock weights and percents to reduce cost on future calls\\n        @param account Address claiming the reward\\n        @param amount Amount being claimed (assuming maximum boost)\\n        @param previousAmount Amount that was already claimed in the current week\\n        @param totalWeeklyEmissions Total PRISMA emissions released this week\\n        @return adjustedAmount Amount of PRISMA received after applying boost\\n     */\\n    function getBoostedAmountWrite(\\n        address account,\\n        uint256 amount,\\n        uint256 previousAmount,\\n        uint256 totalWeeklyEmissions\\n    ) external returns (uint256 adjustedAmount) {\\n        uint256 week = getWeek();\\n        if (week < MAX_BOOST_GRACE_WEEKS) return amount;\\n        week -= 1;\\n\\n        uint256 pct = accountWeeklyLockPct[account][week];\\n        if (pct == 0) {\\n            uint256 totalWeight = totalWeeklyWeights[week];\\n            if (totalWeight == 0) {\\n                totalWeight = locker.getTotalWeightAt(week);\\n                if (totalWeight == 0) totalWeight = 1;\\n                totalWeeklyWeights[week] = uint40(totalWeight);\\n            }\\n\\n            uint256 accountWeight = locker.getAccountWeightAt(account, week);\\n            pct = (1e9 * accountWeight) / totalWeight;\\n            if (pct == 0) pct = 1;\\n            accountWeeklyLockPct[account][week] = uint32(pct);\\n        }\\n\\n        return _getBoostedAmount(amount, previousAmount, totalWeeklyEmissions, pct);\\n    }\\n\\n    function _getBoostedAmount(\\n        uint256 amount,\\n        uint256 previousAmount,\\n        uint256 totalWeeklyEmissions,\\n        uint256 pct\\n    ) internal pure returns (uint256 adjustedAmount) {\\n        // we use 1 to indicate no lock weight: no boost\\n        if (pct == 1) return amount / 2;\\n\\n        uint256 total = amount + previousAmount;\\n        uint256 maxBoostable = (totalWeeklyEmissions * pct) / 1e9;\\n        uint256 fullDecay = maxBoostable * 2;\\n\\n        // entire claim receives max boost\\n        if (maxBoostable >= total) return amount;\\n\\n        // entire claim receives no boost\\n        if (fullDecay <= previousAmount) return amount / 2;\\n\\n        // apply max boost for partial claim\\n        if (previousAmount < maxBoostable) {\\n            adjustedAmount = maxBoostable - previousAmount;\\n            amount -= adjustedAmount;\\n            previousAmount = maxBoostable;\\n        }\\n\\n        // apply no boost for partial claim\\n        if (total > fullDecay) {\\n            adjustedAmount += (total - fullDecay) / 2;\\n            amount -= (total - fullDecay);\\n        }\\n\\n        // simplified calculation if remaining claim is the entire decay amount\\n        if (amount == maxBoostable) return adjustedAmount + ((maxBoostable * 3) / 4);\\n\\n        // remaining calculations handle claim that spans only part of the decay\\n\\n        // get adjusted amount based on the final boost\\n        uint256 finalBoosted = amount - (amount * (previousAmount + amount - maxBoostable)) / maxBoostable / 2;\\n        adjustedAmount += finalBoosted;\\n\\n        // get adjusted amount based on the initial boost\\n        uint256 initialBoosted = amount - (amount * (previousAmount - maxBoostable)) / maxBoostable / 2;\\n        // with linear decay, adjusted amount is half of the difference between initial and final boost amounts\\n        adjustedAmount += (initialBoosted - finalBoosted) / 2;\\n\\n        return adjustedAmount;\\n    }\\n}\\n\"\r\n    },\r\n    \"ITokenLocker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\ninterface ITokenLocker {\\n    struct LockData {\\n        uint256 amount;\\n        uint256 weeksToUnlock;\\n    }\\n    struct ExtendLockData {\\n        uint256 amount;\\n        uint256 currentWeeks;\\n        uint256 newWeeks;\\n    }\\n\\n    event LockCreated(address indexed account, uint256 amount, uint256 _weeks);\\n    event LockExtended(address indexed account, uint256 amount, uint256 _weeks, uint256 newWeeks);\\n    event LocksCreated(address indexed account, LockData[] newLocks);\\n    event LocksExtended(address indexed account, ExtendLockData[] locks);\\n    event LocksFrozen(address indexed account, uint256 amount);\\n    event LocksUnfrozen(address indexed account, uint256 amount);\\n    event LocksWithdrawn(address indexed account, uint256 withdrawn, uint256 penalty);\\n\\n    function extendLock(uint256 _amount, uint256 _weeks, uint256 _newWeeks) external returns (bool);\\n\\n    function extendMany(ExtendLockData[] calldata newExtendLocks) external returns (bool);\\n\\n    function freeze() external;\\n\\n    function getAccountWeightWrite(address account) external returns (uint256);\\n\\n    function getTotalWeightWrite() external returns (uint256);\\n\\n    function lock(address _account, uint256 _amount, uint256 _weeks) external returns (bool);\\n\\n    function lockMany(address _account, LockData[] calldata newLocks) external returns (bool);\\n\\n    function setPenaltyWithdrawalsEnabled(bool _enabled) external returns (bool);\\n\\n    function unfreeze(bool keepIncentivesVote) external;\\n\\n    function withdrawExpiredLocks(uint256 _weeks) external returns (bool);\\n\\n    function withdrawWithPenalty(uint256 amountToWithdraw) external returns (uint256);\\n\\n    function MAX_LOCK_WEEKS() external view returns (uint256);\\n\\n    function PRISMA_CORE() external view returns (address);\\n\\n    function getAccountActiveLocks(\\n        address account,\\n        uint256 minWeeks\\n    ) external view returns (LockData[] memory lockData, uint256 frozenAmount);\\n\\n    function getAccountBalances(address account) external view returns (uint256 locked, uint256 unlocked);\\n\\n    function getAccountWeight(address account) external view returns (uint256);\\n\\n    function getAccountWeightAt(address account, uint256 week) external view returns (uint256);\\n\\n    function getTotalWeight() external view returns (uint256);\\n\\n    function getTotalWeightAt(uint256 week) external view returns (uint256);\\n\\n    function getWeek() external view returns (uint256 week);\\n\\n    function getWithdrawWithPenaltyAmounts(\\n        address account,\\n        uint256 amountToWithdraw\\n    ) external view returns (uint256 amountWithdrawn, uint256 penaltyAmountPaid);\\n\\n    function guardian() external view returns (address);\\n\\n    function incentiveVoter() external view returns (address);\\n\\n    function lockToTokenRatio() external view returns (uint256);\\n\\n    function lockToken() external view returns (address);\\n\\n    function owner() external view returns (address);\\n\\n    function penaltyWithdrawalsEnabled() external view returns (bool);\\n\\n    function prismaCore() external view returns (address);\\n\\n    function totalDecayRate() external view returns (uint32);\\n\\n    function totalUpdatedWeek() external view returns (uint16);\\n}\\n\"\r\n    },\r\n    \"SystemStart.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.19;\\n\\nimport \\\"IPrismaCore.sol\\\";\\n\\n/**\\n    @title Prisma System Start Time\\n    @dev Provides a unified `startTime` and `getWeek`, used for emissions.\\n */\\ncontract SystemStart {\\n    uint256 immutable startTime;\\n\\n    constructor(address prismaCore) {\\n        startTime = IPrismaCore(prismaCore).startTime();\\n    }\\n\\n    function getWeek() public view returns (uint256 week) {\\n        return (block.timestamp - startTime) / 1 weeks;\\n    }\\n}\\n\"\r\n    },\r\n    \"IPrismaCore.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\ninterface IPrismaCore {\\n    event FeeReceiverSet(address feeReceiver);\\n    event GuardianSet(address guardian);\\n    event NewOwnerAccepted(address oldOwner, address owner);\\n    event NewOwnerCommitted(address owner, address pendingOwner, uint256 deadline);\\n    event NewOwnerRevoked(address owner, address revokedOwner);\\n    event Paused();\\n    event PriceFeedSet(address priceFeed);\\n    event Unpaused();\\n\\n    function acceptTransferOwnership() external;\\n\\n    function commitTransferOwnership(address newOwner) external;\\n\\n    function revokeTransferOwnership() external;\\n\\n    function setFeeReceiver(address _feeReceiver) external;\\n\\n    function setGuardian(address _guardian) external;\\n\\n    function setPaused(bool _paused) external;\\n\\n    function setPriceFeed(address _priceFeed) external;\\n\\n    function OWNERSHIP_TRANSFER_DELAY() external view returns (uint256);\\n\\n    function feeReceiver() external view returns (address);\\n\\n    function guardian() external view returns (address);\\n\\n    function owner() external view returns (address);\\n\\n    function ownershipTransferDeadline() external view returns (uint256);\\n\\n    function paused() external view returns (bool);\\n\\n    function pendingOwner() external view returns (address);\\n\\n    function priceFeed() external view returns (address);\\n\\n    function startTime() external view returns (uint256);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"paris\",\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"libraries\": {\r\n      \"BoostCalculator.sol\": {}\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_prismaCore\",\"type\":\"address\"},{\"internalType\":\"contract ITokenLocker\",\"name\":\"_locker\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_graceWeeks\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"MAX_BOOST_GRACE_WEEKS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"previousAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWeeklyEmissions\",\"type\":\"uint256\"}],\"name\":\"getBoostedAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"adjustedAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"previousAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWeeklyEmissions\",\"type\":\"uint256\"}],\"name\":\"getBoostedAmountWrite\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"adjustedAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"claimant\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"previousAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWeeklyEmissions\",\"type\":\"uint256\"}],\"name\":\"getClaimableWithBoost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"maxBoosted\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"boosted\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getWeek\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"week\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"locker\",\"outputs\":[{\"internalType\":\"contract ITokenLocker\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "BoostCalculator", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000005d17ea085f2ff5da3e6979d5d26f1dbab664ccf80000000000000000000000003f78544364c3eccdce4d9c89a630aea26122829d0000000000000000000000000000000000000000000000000000000000000002", "EVMVersion": "paris", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}