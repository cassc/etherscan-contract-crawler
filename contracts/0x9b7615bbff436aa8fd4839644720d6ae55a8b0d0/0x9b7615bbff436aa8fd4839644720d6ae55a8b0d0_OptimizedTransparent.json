{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/common/Proxy.sol\": {\r\n      \"content\": \"/**\\n *  SourceUnit: Protonauts-monorepo/contracts/node_modules/.pnpm/hardhat-deploy@0.9.29_yvvssclfcbeff5cufonczletku/node_modules/hardhat-deploy/solc_0.7/proxy/OptimizedTransparentUpgradeableProxy.sol\\n */\\n\\n////// SPDX-License-Identifier-FLATTEN-SUPPRESS-WARNING: MIT\\n\\npragma solidity ^0.7.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n\\t/**\\n\\t * @dev Returns true if `account` is a contract.\\n\\t *\\n\\t * [////IMPORTANT]\\n\\t * ====\\n\\t * It is unsafe to assume that an address for which this function returns\\n\\t * false is an externally-owned account (EOA) and not a contract.\\n\\t *\\n\\t * Among others, `isContract` will return false for the following\\n\\t * types of addresses:\\n\\t *\\n\\t *  - an externally-owned account\\n\\t *  - a contract in construction\\n\\t *  - an address where a contract will be created\\n\\t *  - an address where a contract lived, but was destroyed\\n\\t * ====\\n\\t */\\n\\tfunction isContract(address account) internal view returns (bool) {\\n\\t\\t// According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\n\\t\\t// and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\n\\t\\t// for accounts without code, i.e. `keccak256('')`\\n\\t\\tbytes32 codehash;\\n\\t\\tbytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n\\t\\t// solhint-disable-next-line no-inline-assembly\\n\\t\\tassembly {\\n\\t\\t\\tcodehash := extcodehash(account)\\n\\t\\t}\\n\\t\\treturn (codehash != accountHash && codehash != 0x0);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n\\t * `recipient`, forwarding all available gas and reverting on errors.\\n\\t *\\n\\t * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n\\t * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n\\t * imposed by `transfer`, making them unable to receive funds via\\n\\t * `transfer`. {sendValue} removes this limitation.\\n\\t *\\n\\t * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n\\t *\\n\\t * ////IMPORTANT: because control is transferred to `recipient`, care must be\\n\\t * taken to not create reentrancy vulnerabilities. Consider using\\n\\t * {ReentrancyGuard} or the\\n\\t * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n\\t */\\n\\tfunction sendValue(address payable recipient, uint256 amount) internal {\\n\\t\\trequire(\\n\\t\\t\\taddress(this).balance >= amount,\\n\\t\\t\\t'Address: insufficient balance'\\n\\t\\t);\\n\\n\\t\\t// solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n\\t\\t(bool success, ) = recipient.call{value: amount}('');\\n\\t\\trequire(\\n\\t\\t\\tsuccess,\\n\\t\\t\\t'Address: unable to send value, recipient may have reverted'\\n\\t\\t);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Performs a Solidity function call using a low level `call`. A\\n\\t * plain`call` is an unsafe replacement for a function call: use this\\n\\t * function instead.\\n\\t *\\n\\t * If `target` reverts with a revert reason, it is bubbled up by this\\n\\t * function (like regular Solidity function calls).\\n\\t *\\n\\t * Returns the raw returned data. To convert to the expected return value,\\n\\t * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - `target` must be a contract.\\n\\t * - calling `target` with `data` must not revert.\\n\\t *\\n\\t * _Available since v3.1._\\n\\t */\\n\\tfunction functionCall(address target, bytes memory data)\\n\\t\\tinternal\\n\\t\\treturns (bytes memory)\\n\\t{\\n\\t\\treturn functionCall(target, data, 'Address: low-level call failed');\\n\\t}\\n\\n\\t/**\\n\\t * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n\\t * `errorMessage` as a fallback revert reason when `target` reverts.\\n\\t *\\n\\t * _Available since v3.1._\\n\\t */\\n\\tfunction functionCall(\\n\\t\\taddress target,\\n\\t\\tbytes memory data,\\n\\t\\tstring memory errorMessage\\n\\t) internal returns (bytes memory) {\\n\\t\\treturn _functionCallWithValue(target, data, 0, errorMessage);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n\\t * but also transferring `value` wei to `target`.\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - the calling contract must have an ETH balance of at least `value`.\\n\\t * - the called Solidity function must be `payable`.\\n\\t *\\n\\t * _Available since v3.1._\\n\\t */\\n\\tfunction functionCallWithValue(\\n\\t\\taddress target,\\n\\t\\tbytes memory data,\\n\\t\\tuint256 value\\n\\t) internal returns (bytes memory) {\\n\\t\\treturn\\n\\t\\t\\tfunctionCallWithValue(\\n\\t\\t\\t\\ttarget,\\n\\t\\t\\t\\tdata,\\n\\t\\t\\t\\tvalue,\\n\\t\\t\\t\\t'Address: low-level call with value failed'\\n\\t\\t\\t);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n\\t * with `errorMessage` as a fallback revert reason when `target` reverts.\\n\\t *\\n\\t * _Available since v3.1._\\n\\t */\\n\\tfunction functionCallWithValue(\\n\\t\\taddress target,\\n\\t\\tbytes memory data,\\n\\t\\tuint256 value,\\n\\t\\tstring memory errorMessage\\n\\t) internal returns (bytes memory) {\\n\\t\\trequire(\\n\\t\\t\\taddress(this).balance >= value,\\n\\t\\t\\t'Address: insufficient balance for call'\\n\\t\\t);\\n\\t\\treturn _functionCallWithValue(target, data, value, errorMessage);\\n\\t}\\n\\n\\tfunction _functionCallWithValue(\\n\\t\\taddress target,\\n\\t\\tbytes memory data,\\n\\t\\tuint256 weiValue,\\n\\t\\tstring memory errorMessage\\n\\t) private returns (bytes memory) {\\n\\t\\trequire(isContract(target), 'Address: call to non-contract');\\n\\n\\t\\t// solhint-disable-next-line avoid-low-level-calls\\n\\t\\t(bool success, bytes memory returndata) = target.call{value: weiValue}(\\n\\t\\t\\tdata\\n\\t\\t);\\n\\t\\tif (success) {\\n\\t\\t\\treturn returndata;\\n\\t\\t} else {\\n\\t\\t\\t// Look for revert reason and bubble it up if present\\n\\t\\t\\tif (returndata.length > 0) {\\n\\t\\t\\t\\t// The easiest way to bubble the revert reason is using memory via assembly\\n\\n\\t\\t\\t\\t// solhint-disable-next-line no-inline-assembly\\n\\t\\t\\t\\tassembly {\\n\\t\\t\\t\\t\\tlet returndata_size := mload(returndata)\\n\\t\\t\\t\\t\\trevert(add(32, returndata), returndata_size)\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\trevert(errorMessage);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n\\n/**\\n *  SourceUnit: Protonauts-monorepo/contracts/node_modules/.pnpm/hardhat-deploy@0.9.29_yvvssclfcbeff5cufonczletku/node_modules/hardhat-deploy/solc_0.7/proxy/OptimizedTransparentUpgradeableProxy.sol\\n */\\n\\n////// SPDX-License-Identifier-FLATTEN-SUPPRESS-WARNING: MIT\\n\\npragma solidity ^0.7.0;\\n\\n/**\\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\\n * be specified by overriding the virtual {_implementation} function.\\n *\\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\\n * different contract through the {_delegate} function.\\n *\\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\\n */\\nabstract contract Proxy {\\n\\t/**\\n\\t * @dev Delegates the current call to `implementation`.\\n\\t *\\n\\t * This function does not return to its internall call site, it will return directly to the external caller.\\n\\t */\\n\\tfunction _delegate(address implementation) internal {\\n\\t\\t// solhint-disable-next-line no-inline-assembly\\n\\t\\tassembly {\\n\\t\\t\\t// Copy msg.data. We take full control of memory in this inline assembly\\n\\t\\t\\t// block because it will not return to Solidity code. We overwrite the\\n\\t\\t\\t// Solidity scratch pad at memory position 0.\\n\\t\\t\\tcalldatacopy(0, 0, calldatasize())\\n\\n\\t\\t\\t// Call the implementation.\\n\\t\\t\\t// out and outsize are 0 because we don't know the size yet.\\n\\t\\t\\tlet result := delegatecall(\\n\\t\\t\\t\\tgas(),\\n\\t\\t\\t\\timplementation,\\n\\t\\t\\t\\t0,\\n\\t\\t\\t\\tcalldatasize(),\\n\\t\\t\\t\\t0,\\n\\t\\t\\t\\t0\\n\\t\\t\\t)\\n\\n\\t\\t\\t// Copy the returned data.\\n\\t\\t\\treturndatacopy(0, 0, returndatasize())\\n\\n\\t\\t\\tswitch result\\n\\t\\t\\t// delegatecall returns 0 on error.\\n\\t\\t\\tcase 0 {\\n\\t\\t\\t\\trevert(0, returndatasize())\\n\\t\\t\\t}\\n\\t\\t\\tdefault {\\n\\t\\t\\t\\treturn(0, returndatasize())\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t/**\\n\\t * @dev This is a virtual function that should be overriden so it returns the address to which the fallback function\\n\\t * and {_fallback} should delegate.\\n\\t */\\n\\tfunction _implementation() internal view virtual returns (address);\\n\\n\\t/**\\n\\t * @dev Delegates the current call to the address returned by `_implementation()`.\\n\\t *\\n\\t * This function does not return to its internall call site, it will return directly to the external caller.\\n\\t */\\n\\tfunction _fallback() internal {\\n\\t\\t_beforeFallback();\\n\\t\\t_delegate(_implementation());\\n\\t}\\n\\n\\t/**\\n\\t * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\\n\\t * function in the contract matches the call data.\\n\\t */\\n\\tfallback() external payable {\\n\\t\\t_fallback();\\n\\t}\\n\\n\\t/**\\n\\t * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\\n\\t * is empty.\\n\\t */\\n\\treceive() external payable {\\n\\t\\t_fallback();\\n\\t}\\n\\n\\t/**\\n\\t * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\\n\\t * call, or as part of the Solidity `fallback` or `receive` functions.\\n\\t *\\n\\t * If overriden should call `super._beforeFallback()`.\\n\\t */\\n\\tfunction _beforeFallback() internal virtual {}\\n}\\n\\n/**\\n *  SourceUnit: Protonauts-monorepo/contracts/node_modules/.pnpm/hardhat-deploy@0.9.29_yvvssclfcbeff5cufonczletku/node_modules/hardhat-deploy/solc_0.7/proxy/OptimizedTransparentUpgradeableProxy.sol\\n */\\n\\n////// SPDX-License-Identifier-FLATTEN-SUPPRESS-WARNING: MIT\\n\\npragma solidity ^0.7.0;\\n\\n////import \\\"./Proxy.sol\\\";\\n////import \\\"../utils/Address.sol\\\";\\n\\n/**\\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\\n * implementation address that can be changed. This address is stored in storage in the location specified by\\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\\n * implementation behind the proxy.\\n *\\n * Upgradeability is only provided internally through {_upgradeTo}. For an externally upgradeable proxy see\\n * {TransparentUpgradeableProxy}.\\n */\\ncontract UpgradeableProxy is Proxy {\\n\\t/**\\n\\t * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\\n\\t *\\n\\t * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\\n\\t * function call, and allows initializating the storage of the proxy like a Solidity constructor.\\n\\t */\\n\\tconstructor(address _logic, bytes memory _data) payable {\\n\\t\\tassert(\\n\\t\\t\\t_IMPLEMENTATION_SLOT ==\\n\\t\\t\\t\\tbytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1)\\n\\t\\t);\\n\\t\\t_setImplementation(_logic);\\n\\t\\tif (_data.length > 0) {\\n\\t\\t\\t// solhint-disable-next-line avoid-low-level-calls\\n\\t\\t\\t(bool success, ) = _logic.delegatecall(_data);\\n\\t\\t\\trequire(success);\\n\\t\\t}\\n\\t}\\n\\n\\t/**\\n\\t * @dev Emitted when the implementation is upgraded.\\n\\t */\\n\\tevent Upgraded(address indexed implementation);\\n\\n\\t/**\\n\\t * @dev Storage slot with the address of the current implementation.\\n\\t * This is the keccak-256 hash of \\\"eip1967.proxy.implementation\\\" subtracted by 1, and is\\n\\t * validated in the constructor.\\n\\t */\\n\\tbytes32 private constant _IMPLEMENTATION_SLOT =\\n\\t\\t0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n\\t/**\\n\\t * @dev Returns the current implementation address.\\n\\t */\\n\\tfunction _implementation() internal view override returns (address impl) {\\n\\t\\tbytes32 slot = _IMPLEMENTATION_SLOT;\\n\\t\\t// solhint-disable-next-line no-inline-assembly\\n\\t\\tassembly {\\n\\t\\t\\timpl := sload(slot)\\n\\t\\t}\\n\\t}\\n\\n\\t/**\\n\\t * @dev Upgrades the proxy to a new implementation.\\n\\t *\\n\\t * Emits an {Upgraded} event.\\n\\t */\\n\\tfunction _upgradeTo(address newImplementation) internal {\\n\\t\\t_setImplementation(newImplementation);\\n\\t\\temit Upgraded(newImplementation);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Stores a new address in the EIP1967 implementation slot.\\n\\t */\\n\\tfunction _setImplementation(address newImplementation) private {\\n\\t\\trequire(\\n\\t\\t\\tAddress.isContract(newImplementation),\\n\\t\\t\\t'UpgradeableProxy: new implementation is not a contract'\\n\\t\\t);\\n\\n\\t\\tbytes32 slot = _IMPLEMENTATION_SLOT;\\n\\n\\t\\t// solhint-disable-next-line no-inline-assembly\\n\\t\\tassembly {\\n\\t\\t\\tsstore(slot, newImplementation)\\n\\t\\t}\\n\\t}\\n}\\n\\n/**\\n *  SourceUnit: Protonauts-monorepo/contracts/node_modules/.pnpm/hardhat-deploy@0.9.29_yvvssclfcbeff5cufonczletku/node_modules/hardhat-deploy/solc_0.7/proxy/OptimizedTransparentUpgradeableProxy.sol\\n */\\n\\n////// SPDX-License-Identifier-FLATTEN-SUPPRESS-WARNING: MIT\\npragma solidity ^0.7.0;\\n\\n////import \\\"../openzeppelin/proxy/UpgradeableProxy.sol\\\";\\n\\n/**\\n * @dev This contract implements a proxy that is upgradeable by an admin.\\n *\\n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector\\n * clashing], which can potentially be used in an attack, this contract uses the\\n * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two\\n * things that go hand in hand:\\n *\\n * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if\\n * that call matches one of the admin functions exposed by the proxy itself.\\n * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the\\n * implementation. If the admin tries to call a function on the implementation it will fail with an error that says\\n * \\\"admin cannot fallback to proxy target\\\".\\n *\\n * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing\\n * the admin, so it's best if it's a dedicated account that is not used for anything else. This will avoid headaches due\\n * to sudden errors when trying to call a function from the proxy implementation.\\n *\\n * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,\\n * you should think of the `ProxyAdmin` instance as the real administrative inerface of your proxy.\\n */\\ncontract OptimizedTransparentUpgradeableProxy is UpgradeableProxy {\\n\\taddress internal immutable _ADMIN;\\n\\n\\t/**\\n\\t * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and\\n\\t * optionally initialized with `_data` as explained in {UpgradeableProxy-constructor}.\\n\\t */\\n\\tconstructor(\\n\\t\\taddress initialLogic,\\n\\t\\taddress initialAdmin,\\n\\t\\tbytes memory _data\\n\\t) payable UpgradeableProxy(initialLogic, _data) {\\n\\t\\tassert(\\n\\t\\t\\t_ADMIN_SLOT ==\\n\\t\\t\\t\\tbytes32(uint256(keccak256('eip1967.proxy.admin')) - 1)\\n\\t\\t);\\n\\t\\tbytes32 slot = _ADMIN_SLOT;\\n\\n\\t\\t_ADMIN = initialAdmin;\\n\\n\\t\\t// still store it to work with EIP-1967\\n\\t\\t// solhint-disable-next-line no-inline-assembly\\n\\t\\tassembly {\\n\\t\\t\\tsstore(slot, initialAdmin)\\n\\t\\t}\\n\\t}\\n\\n\\t/**\\n\\t * @dev Storage slot with the admin of the contract.\\n\\t * This is the keccak-256 hash of \\\"eip1967.proxy.admin\\\" subtracted by 1, and is\\n\\t * validated in the constructor.\\n\\t */\\n\\tbytes32 private constant _ADMIN_SLOT =\\n\\t\\t0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n\\t/**\\n\\t * @dev Modifier used internally that will delegate the call to the implementation unless the sender is the admin.\\n\\t */\\n\\tmodifier ifAdmin() {\\n\\t\\tif (msg.sender == _admin()) {\\n\\t\\t\\t_;\\n\\t\\t} else {\\n\\t\\t\\t_fallback();\\n\\t\\t}\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns the current admin.\\n\\t *\\n\\t * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyAdmin}.\\n\\t *\\n\\t * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\\n\\t * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\\n\\t * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\\n\\t */\\n\\tfunction admin() external ifAdmin returns (address) {\\n\\t\\treturn _admin();\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns the current implementation.\\n\\t *\\n\\t * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}.\\n\\t *\\n\\t * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\\n\\t * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\\n\\t * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\\n\\t */\\n\\tfunction implementation() external ifAdmin returns (address) {\\n\\t\\treturn _implementation();\\n\\t}\\n\\n\\t/**\\n\\t * @dev Upgrade the implementation of the proxy.\\n\\t *\\n\\t * NOTE: Only the admin can call this function. See {ProxyAdmin-upgrade}.\\n\\t */\\n\\tfunction upgradeTo(address newImplementation) external ifAdmin {\\n\\t\\t_upgradeTo(newImplementation);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified\\n\\t * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the\\n\\t * proxied contract.\\n\\t *\\n\\t * NOTE: Only the admin can call this function. See {ProxyAdmin-upgradeAndCall}.\\n\\t */\\n\\tfunction upgradeToAndCall(address newImplementation, bytes calldata data)\\n\\t\\texternal\\n\\t\\tpayable\\n\\t\\tifAdmin\\n\\t{\\n\\t\\t_upgradeTo(newImplementation);\\n\\t\\t// solhint-disable-next-line avoid-low-level-calls\\n\\t\\t(bool success, ) = newImplementation.delegatecall(data);\\n\\t\\trequire(success);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns the current admin.\\n\\t */\\n\\tfunction _admin() internal view returns (address adm) {\\n\\t\\treturn _ADMIN;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Makes sure the admin cannot access the fallback function. See {Proxy-_beforeFallback}.\\n\\t */\\n\\tfunction _beforeFallback() internal virtual override {\\n\\t\\trequire(\\n\\t\\t\\tmsg.sender != _admin(),\\n\\t\\t\\t'TransparentUpgradeableProxy: admin cannot fallback to proxy target'\\n\\t\\t);\\n\\t\\tsuper._beforeFallback();\\n\\t}\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 999999\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"initialLogic\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"initialAdmin\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"Upgraded\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"implementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"}],\"name\":\"upgradeTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"upgradeToAndCall\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "OptimizedTransparentUpgradeableProxy", "CompilerVersion": "v0.7.6+commit.7338295f", "OptimizationUsed": "1", "Runs": "999999", "ConstructorArguments": "000000000000000000000000cb42a64956be83722557fc9bbc10c5eee6b2a9a4000000000000000000000000becfd660fa46c88fcd5ced28af25d5eab803d54800000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000000104906571470000000000000000000000004758b385602d166a75710fd1f8b75139d44566f0000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000000000000950726f746f6e6175740000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002d416e20496e7465726f70657261626c65204d657461766572736520436861726163746572205374616e646172640000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "1", "Implementation": "0xcb42a64956be83722557fc9bbc10c5eee6b2a9a4", "SwarmSource": ""}