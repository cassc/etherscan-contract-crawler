{"SourceCode": "{\"Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn\\u0027t rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length \\u003e 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity\\u0027s `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance \\u003e= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance \\u003e= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\\u0027t, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length \\u003e 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"},\"AFiManager.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity =0.8.0;\\n\\nimport \\\"./IAFi.sol\\\";\\nimport \\\"./IAFiStorage.sol\\\";\\nimport \\\"./TransferHelper.sol\\\";\\nimport \\\"./Ownable.sol\\\";\\nimport {ReentrancyGuard} from \\\"./ReentrancyGuard.sol\\\";\\nimport \\\"./ArrayUtils.sol\\\";\\nimport {SafeMath} from \\\"./SafeMath.sol\\\";\\nimport {SafeERC20} from \\\"./SafeERC20.sol\\\";\\n\\n/**\\n * @title AFiManager.\\n * @notice Manager conntract for handling rebalancing and adding/updating team wallets in the AFi contracts.\\n * @dev Error codes: AFM01: Caller is not MultiSig. AFM02: Cannot be address zero. AFM03: Teamwallet already present. AFM04: Previous and current active status cannot be the same.\\n */\\ncontract AFiManager is Ownable, ReentrancyGuard {\\n  using ArrayUtils for uint[];\\n  using ArrayUtils for address[];\\n  using SafeMath for uint;\\n  using SafeERC20 for IERC20;\\n\\n  address[] internal _uTokens;\\n  address[] private _uTokensAfterRebalance;\\n  uint[] public _uTokenProportions;\\n\\n  address[] public tokens;\\n  uint[] internal defaultProportion;\\n  mapping(address =\\u003e bool) internal underlyingExists;\\n  mapping(address =\\u003e mapping(address =\\u003euint)) internal underlyingSlippage;\\n  address UNISWAP_EXCHANGE = 0xE592427A0AEce92De3Edee1F18E0157C05861564;\\n  address private constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\n  uint public daoProfit = 6;\\n  uint public totalProfit = 10;\\n  bool internal paused;\\n  mapping(address =\\u003e bool) internal newListExist;\\n\\n  struct activeRebalTransaction {\\n    bytes data;\\n    IAFi aFiContract;\\n    IAFiStorage _aFiStorage;\\n    IERC20 depositToken;\\n    address newUToken;\\n    address uTokenToRemove;\\n    uint8 scenario;\\n    bool executed;\\n    uint numConfirmations;\\n    uint txId;\\n  }\\n\\n  modifier onlySpecificAddress(address _addr) {\\n    require(msg.sender == _addr); //solhint-disable-line reason-string\\n    _;\\n  }\\n\\n  event Rebalance(IAFi indexed _aFiContract, uint8 _scenario);\\n  event AddTeamWalletInAFi(address indexed aFiContract, address _wallet);\\n  event UpdateMultisig(\\n    address indexed _manager,\\n    address _oldMultisig,\\n    address _newMultisig\\n  );\\n  event WithdrawFromPool(address indexed _aFiContract, address uToken);\\n  event AFiManagerSwap(\\n    IAFi indexed _aFiContract,\\n    address _fromToken,\\n    address _toToken,\\n    uint _amount\\n  );\\n  event SetActiveRebalStatus(address indexed _aFiContract, bool status);\\n  event ProfitShareUpdated(uint daoProfit, uint totalProfit);\\n  event RebalanceUnderlyingTokens(\\n    address indexed aFiContract,\\n    address _aFiStorage,\\n    address[] newUnderlyingTokens,\\n    address stableCoin,\\n    uint managerFee\\n  );\\n  event UTokenProportionUpdated(address indexed aFiContract, uint256[] uTokenProportions);\\n  event ProfitShareDistributed(address indexed aFiContract, address indexed teamWallet, uint256 amount);\\n  /**\\n   * @param account Address of the account that paused the contract.\\n   */\\n  event Paused(address account);\\n  /**\\n   * @param account Address of the account that unpaused the contract.\\n   */\\n  event Unpaused(address account);\\n\\n  modifier contractUnpaused() {\\n    require(!paused, \\\"contract is unpaused\\\");\\n    _;\\n  }\\n\\n  modifier contractPaused() {\\n    require(paused, \\\"contract is paused\\\");\\n    _;\\n  }\\n\\n   /**\\n   * @notice To pause the contract.\\n   * @dev Requirements: It can only be invoked by owner.\\n   */\\n  function pause() external contractUnpaused onlyOwner {\\n    paused = true;\\n    emit Paused(msg.sender);\\n  }\\n\\n  /**\\n   * @notice To resume/unpause the contract.\\n   * @dev Requirements: It can only be invoked by the owner.\\n   */\\n  function unPause() external contractPaused onlyOwner {\\n    paused = false;\\n    emit Unpaused(msg.sender);\\n  }\\n\\n\\n  /**\\n   * @notice Returns the pause status of the contract.\\n   * @return bool pause status of the contract.\\n   */\\n  function getPauseStatus() external view returns (bool) {\\n    return paused;\\n  }\\n\\n  /**\\n   * @notice To add a new team wallet.\\n   * @dev The wallet must not be address zero. The wallet must not be present.\\n   * @param _aFiStorage Address of AFiStorage contract.\\n   * @param aFiContract Address of the AFi contract.\\n   * @param _wallet Wallet address that has to be added in the `teamWallets` array.\\n   */\\n  function addTeamWalletInAFi(\\n    IAFiStorage _aFiStorage,\\n    address aFiContract,\\n    address _wallet\\n  ) external onlyOwner nonReentrant contractUnpaused{\\n    require(_wallet != address(0), \\\"AFM02\\\");\\n    (, bool isPresent) = _aFiStorage.getTeamWalletDetails(aFiContract, _wallet);\\n    require(!isPresent, \\\"AFM03\\\");\\n    _aFiStorage.addTeamWallet(aFiContract, _wallet, true, true);\\n    emit AddTeamWalletInAFi(aFiContract, _wallet);\\n  }\\n\\n  /**\\n   * @notice To rebalance the underlying tokens.\\n   * @dev Scenario can be either of 0, 1 or 2.\\n   * @dev 1 =\\u003e Remove all DepositToken from U1 \\u0026 Invest into U2, U3.\\n   * @dev 2 =\\u003e Remove all DepositToken from U1, if loss, invest all in U4.\\n   * @dev 3 =\\u003e Remove all DepositToken from U1, if profit, invest 50% in U2, U3 \\u0026 50% in U4.\\n   * @param aFiContract Address of AFi contract (AToken).\\n   * @param _aFiStorage Address of AFiStorage contract.\\n   * @param newUToken Address of the new underlying token.\\n   * @param scenario It is either of 1, 2 or 3.\\n   */\\n  function rebalance(\\n    bytes memory data,\\n    IAFi aFiContract,\\n    IAFiStorage _aFiStorage,\\n    IERC20 depositToken,\\n    address newUToken,\\n    address uTokenToRemove,\\n    uint8 scenario,\\n    uint deadline,\\n    uint[] memory slippageFactor\\n  ) external onlyOwner nonReentrant contractUnpaused{\\n    require(scenario \\u003c= 3 \\u0026\\u0026 scenario \\u003e 0, \\\"scenario no. outbount\\\");\\n    require(_aFiStorage.isAFiActiveRebalanced(address(aFiContract)), \\\"AM00\\\");\\n    \\n    _uTokens = aFiContract.getUTokens();\\n \\n    (_uTokenProportions, defaultProportion, ) = aFiContract.getProportionsAndRebalTime();\\n\\n    setSlippage(aFiContract, _uTokens, depositToken, slippageFactor);\\n\\n    if (scenario \\u003e= 2 \\u0026\\u0026 scenario \\u003c= 3) {\\n      (, bool present) = ArrayUtils.indexOf(_uTokens, newUToken);\\n      require(!present, \\\"new token already present\\\");\\n      validateNewUTokenData(aFiContract, data, newUToken);\\n    }\\n    uint totalReturnedDepositToken;\\n    {\\n\\n      uint aFiDepositTokenBalance= depositToken.balanceOf(\\n        address(aFiContract)\\n      );\\n\\n      _aFiStorage._withdrawAll(address(aFiContract), uTokenToRemove);\\n      require(IERC20(uTokenToRemove).balanceOf(address(aFiContract)) \\u003e 0, \\\"Invalid rebalance amount\\\");\\n      // To avoid stack too deep error\\n      // Get Deposit token back from the UToken that is going to be rebalanced\\n      address midTok = aFiContract.getMidToken(uTokenToRemove);\\n      if(midTok == address(depositToken)){\\n        //update unipool\\n        aFiContract.updateuniPool(uTokenToRemove, midTok);\\n      }\\n      aFiManagerSwap(\\n        uTokenToRemove,\\n        address(depositToken),\\n        IERC20(uTokenToRemove).balanceOf(address(aFiContract)),\\n        aFiContract,\\n        deadline,\\n        midTok,\\n        slippageFactor\\n      );\\n      uint aFiDepositTokenBalanceAfterSwap = depositToken.balanceOf(\\n        address(aFiContract)\\n      );\\n      totalReturnedDepositToken = aFiDepositTokenBalanceAfterSwap.sub(aFiDepositTokenBalance);\\n    }\\n\\n    {\\n      // To avoid stack too deep error\\n      (uint uTokenToRemoveIndex, ) = _uTokens.indexOf(uTokenToRemove);\\n\\n      if (scenario \\u003e 1 \\u0026\\u0026 scenario \\u003c 4) {\\n        updateProportionData();\\n        aFiContract.updatePoolData(data);\\n      }\\n      if (scenario == 1) {\\n        // investInOtherUTokens\\n        scenario1Investments(\\n          depositToken,\\n          uTokenToRemoveIndex,\\n          aFiContract,\\n          _aFiStorage,\\n          _uTokens,\\n          _uTokenProportions,\\n          totalReturnedDepositToken,\\n          deadline,\\n          slippageFactor\\n        );\\n\\n        removeIndex(uTokenToRemoveIndex);\\n        _uTokens = _uTokensAfterRebalance;\\n        updateProportion(address(aFiContract), _aFiStorage);\\n        aFiContract.updateUnderlyingData(_uTokens, _uTokenProportions, defaultProportion);\\n      } else if (scenario == 2) {\\n        scenario2Investments(\\n          depositToken,\\n          uTokenToRemoveIndex,\\n          aFiContract,\\n          _aFiStorage,\\n          _uTokens,\\n          newUToken,\\n          totalReturnedDepositToken,\\n          deadline,\\n          slippageFactor\\n        );\\n\\n        removeIndex(uTokenToRemoveIndex);\\n        _uTokens = _uTokensAfterRebalance;\\n        updateProportion(address(aFiContract), _aFiStorage);\\n        aFiContract.updateUnderlyingData(_uTokens, _uTokenProportions, defaultProportion);\\n      } else if (scenario == 3) {\\n        scenario3Investments(\\n          depositToken,\\n          uTokenToRemoveIndex,\\n          aFiContract,\\n          _aFiStorage,\\n          _uTokens,\\n          newUToken,\\n          totalReturnedDepositToken,\\n          deadline,\\n          slippageFactor\\n        );\\n        removeIndex(uTokenToRemoveIndex);\\n        _uTokens = _uTokensAfterRebalance;\\n        updateProportion(address(aFiContract), _aFiStorage);\\n        aFiContract.updateUnderlyingData(_uTokens, _uTokenProportions, defaultProportion);\\n      }\\n    }\\n  }\\n\\n  /**\\n   * @notice To invest tokens as per scenario 1.\\n   * @dev 1 =\\u003e Remove all DepositToken from U1 \\u0026 Invest into U2, U3.\\n   * @param uTokenToRemoveIndex Index of the underlying token that has to be set to inactive.\\n   * @param aFiContract Address of AFi contract (AToken).\\n   * @param _aFiStorage Address of AFiStorage contract.\\n   * @param uTokens An array of underlying tokens.\\n   * @param uTokenProportions An array of underlying tokens proportions.\\n   */\\n  function scenario1Investments(\\n    IERC20 depositToken,\\n    uint uTokenToRemoveIndex,\\n    IAFi aFiContract,\\n    IAFiStorage _aFiStorage,\\n    address[] memory uTokens,\\n    uint[] memory uTokenProportions,\\n    uint totalReturnedDepositToken,\\n    uint deadline,\\n    uint[] memory slippageFactor\\n  ) internal {\\n  uint256 _denominator;\\n  {\\n    // To avoid stack too deep error\\n    // Calculate the denominator as per the updated proportions\\n    for (uint i = 0; i \\u003c uTokens.length; i++) {\\n      if (i != uTokenToRemoveIndex) {\\n        _denominator += uTokenProportions[i];\\n      }\\n    }\\n  }\\n\\n  {\\n    // Invest the totalReturnedDepositToken as per the proportions\\n    // Invest the Swapped Deposit Token into other UTokens\\n    address[] memory rbtoUTokens = new address[](uTokens.length - 1);\\n    uint rbIndex = 0;\\n    address midTok;\\n    for (uint j = 0; j \\u003c uTokens.length; j++) {\\n      if (j != uTokenToRemoveIndex) {\\n        midTok = aFiContract.getMidToken(uTokens[j]);\\n        if(midTok == address(depositToken)){\\n          //update unipool\\n          aFiContract.updateuniPool(uTokens[j], midTok);\\n        }\\n        rbtoUTokens[rbIndex] = uTokens[j];\\n        aFiManagerSwap(\\n          address(depositToken),\\n          uTokens[j],\\n          (uTokenProportions[j] * totalReturnedDepositToken) / _denominator,\\n          aFiContract,\\n          deadline, \\n          midTok,\\n          slippageFactor\\n        );\\n        rbIndex++;\\n      }\\n    }\\n\\n    _uTokensAfterRebalance = rbtoUTokens;\\n    // Update rebalancing details\\n    _aFiStorage.updateRebalanceDetails(\\n      address(aFiContract),\\n      uTokens[uTokenToRemoveIndex],\\n      rbtoUTokens,\\n      1\\n    );\\n  }\\n  emit Rebalance(aFiContract, 1);\\n}\\n\\n\\n  /**\\n   * @notice To invest tokens as per scenario 2.\\n   * @dev 2 =\\u003e Remove all DepositToken from U1, if loss, invest all in U4.\\n   * @param uTokenToRemoveIndex Index of the underlying token that has to be set to inactive.\\n   * @param aFiContract Address of AFi contract (AToken).\\n   * @param _aFiStorage Address of AFiStorage contract.\\n   * @param uTokens An array of underlying tokens.\\n   * @param newUToken Address of the new underlying token.\\n   */\\n  function scenario2Investments(\\n    IERC20 depositToken,\\n    uint uTokenToRemoveIndex,\\n    IAFi aFiContract,\\n    IAFiStorage _aFiStorage,\\n    address[] memory uTokens,\\n    address newUToken,\\n    uint totalReturnedDepositToken,\\n    uint deadline,\\n    uint[] memory slippageFactor\\n  ) internal{\\n    {\\n      address[] memory rbtoUTokens = new address[](uTokens.length);\\n\\n      for (uint j = 0; j \\u003c uTokens.length; j++) {\\n        if (j != uTokenToRemoveIndex) {\\n          if (j \\u003c uTokenToRemoveIndex) {\\n            rbtoUTokens[j] = uTokens[j];\\n          } else {\\n            rbtoUTokens[j - 1] = uTokens[j];\\n          }\\n        }\\n      }\\n\\n      rbtoUTokens[rbtoUTokens.length - 1] = newUToken;\\n      _uTokensAfterRebalance = rbtoUTokens;\\n      address midTok = aFiContract.getMidToken(newUToken);\\n      if(midTok == address(depositToken)){\\n        //update unipool\\n        aFiContract.updateuniPool(newUToken, midTok);\\n      }\\n      aFiManagerSwap(\\n        address(depositToken),\\n        newUToken,\\n        totalReturnedDepositToken,\\n        aFiContract,\\n        deadline,\\n        midTok,\\n        slippageFactor\\n      );\\n\\n      // Update rebalancing details\\n      _aFiStorage.updateRebalanceDetails(\\n        address(aFiContract),\\n        uTokens[uTokenToRemoveIndex],\\n        rbtoUTokens,\\n        2\\n      );\\n    }\\n\\n    emit Rebalance(aFiContract, 2);\\n  }\\n\\n  /**\\n   * @notice To invest tokens as per scenario 3.\\n   * @dev 3 =\\u003e Remove all DepositToken from U1, if profit, invest 50% in U2, U3 \\u0026 50% in U4.\\n   * @param uTokenToRemoveIndex Index of the underlying token that has to be set to inactive.\\n   * @param aFiContract Address of AFi contract (AToken).\\n   * @param _aFiStorage Address of AFiStorage contract.\\n   * @param uTokens An array of underlying tokens.\\n   * @param newUToken Address of the new underlying token.\\n   */\\n  function scenario3Investments(\\n    IERC20 depositToken,\\n    uint uTokenToRemoveIndex,\\n    IAFi aFiContract,\\n    IAFiStorage _aFiStorage,\\n    address[] memory uTokens,\\n    address newUToken,\\n    uint totalReturnedDepositToken,\\n    uint deadline,\\n    uint[] memory slippageFactor\\n  ) internal{\\n    {\\n      address[] memory rbtoUTokens = new address[](uTokens.length);\\n      uint j;\\n      address midTok;\\n      // To avoid stack too deep error\\n      // Invest the other 50% Swapped DepositToken into other UTokens\\n      for (j = 0; j \\u003c uTokens.length; j++) {\\n        if (j != uTokenToRemoveIndex) {\\n          if (j \\u003c uTokenToRemoveIndex) {\\n            rbtoUTokens[j] = uTokens[j];\\n          }else {\\n            rbtoUTokens[j - 1] = uTokens[j];\\n          }\\n          \\n          midTok = aFiContract.getMidToken(uTokens[j]);\\n          if(midTok == address(depositToken)){\\n            //update unipool\\n            aFiContract.updateuniPool(uTokens[j], midTok);\\n          }\\n          aFiManagerSwap(\\n            address(depositToken),\\n            uTokens[j],\\n            (totalReturnedDepositToken * (50)) / ((uTokens.length - 1) * (100)),\\n            aFiContract,\\n            deadline,\\n            midTok,\\n            slippageFactor\\n          );\\n        }\\n      }\\n\\n      rbtoUTokens[rbtoUTokens.length - 1] = newUToken;\\n      _uTokensAfterRebalance = rbtoUTokens;\\n\\n      // Gets distribution array\\n      // Invest the 50% of Swapped Deposit Token into new UToken\\n\\n      midTok = aFiContract.getMidToken(newUToken);\\n      if(midTok == address(depositToken)){\\n        //update unipool\\n        aFiContract.updateuniPool(newUToken, midTok);\\n      }\\n      aFiManagerSwap(\\n        address(depositToken),\\n        newUToken,\\n        (totalReturnedDepositToken * (50)) / (100),\\n        aFiContract,\\n        deadline,\\n        midTok,\\n        slippageFactor\\n      );\\n\\n      // Update rebalancing details\\n      _aFiStorage.updateRebalanceDetails(\\n        address(aFiContract),\\n        uTokens[uTokenToRemoveIndex],\\n        rbtoUTokens,\\n        3\\n      );\\n    }\\n    emit Rebalance(aFiContract, 3);\\n  }\\n\\n  /**\\n   * @notice Gateway for initiating a Swap from the AFiManager contract.\\n   * @dev The contract must not be paused. It can only be invoked by the AFiManager contract.\\n   * @param from The source token which is swapped for the destination token.\\n   * @param to The destination token to which the from token is swapped into.\\n   * @param amount Amount of from token for swapping.\\n   */\\n  function aFiManagerSwap(\\n    address from,\\n    address to,\\n    uint amount,\\n    IAFi aFiContract,\\n    uint256 deadline,\\n    address midTok,\\n    uint[] memory slippageFactor\\n  ) internal contractUnpaused {\\n    {\\n      // Initiate Swap via UniswapV3\\n      aFiContract.swapViAFiStorage(from, to, amount, deadline, midTok, slippageFactor, 3);\\n    }\\n\\n    emit AFiManagerSwap(aFiContract, from, to, amount);\\n  }\\n\\n  function validateNewUTokenData(IAFi afiContract, bytes memory _data, address newUToken) internal {\\n    IAFi.PoolsData memory pooldata = abi.decode(_data, (IAFi.PoolsData));\\n    IAFi.UnderlyingData memory uniData = abi.decode(pooldata.underlyingData, (IAFi.UnderlyingData));\\n    require(\\n        pooldata._underlyingTokensProportion.length == pooldata._compound.length \\u0026\\u0026\\n        pooldata._compound.length == pooldata._dToken.length \\u0026\\u0026\\n        pooldata._dToken.length == pooldata._aaveToken.length,\\n      \\\"AFM05\\\"\\n    );\\n    require(uniData._underlyingTokens.length == 1, \\\"AFM06\\\");\\n    require(pooldata._underlyingTokensProportion[0] == 0, \\\"AFM07\\\");\\n    require(uniData._underlyingTokens[0]== newUToken, \\\"AFM08\\\");\\n\\n    afiContract.upDateInputTokPool(pooldata.underlyingData);\\n  }\\n\\n  /**\\n   * @notice  To toggle team wallet status to either active/inactive.\\n   * @dev The contract must not be paused.It can invoke by owner\\n   * @param aFiContract Address of AFi contract (AToken).\\n   * @param _aFiStorage Address of the AFi Storage Contract.\\n   * @param status Address of the underlying tokens oracles.\\n   */\\n  function setActiveRebalStatus(\\n    IAFiStorage _aFiStorage,\\n    address aFiContract,\\n    bool status\\n  ) external onlyOwner nonReentrant contractUnpaused{\\n    _aFiStorage.setActiveRebalancedStatus(aFiContract, status);\\n    emit SetActiveRebalStatus(aFiContract, status);\\n  }\\n\\n  /**\\n   * @notice To rebalance the underlying tokens.\\n   * @dev Remove all DepositToken from multiple underlying tokens \\u0026 Invest into new underlying tokens.\\n   * @param aFiContract Address of AFi contract (AToken).\\n   */\\n  function rebalanceUnderlyingTokens(\\n    IAFi aFiContract,\\n    IAFiStorage _aFiStorage,\\n    bytes memory underlyingData,\\n    address[] memory newUnderlyingOracle,\\n    address stableCoin,\\n    uint managerFee,\\n    uint deadline,\\n    uint[] memory slippageFactor\\n  ) external onlyOwner contractUnpaused {\\n    require(newUnderlyingOracle.length \\u003c= 10,\\\"more than 10 underlying\\\");\\n    _uTokens = aFiContract.getUTokens();\\n    setSlippage(aFiContract, _uTokens,  IERC20(stableCoin), slippageFactor);\\n\\n    (_uTokenProportions, defaultProportion, ) = aFiContract.getProportionsAndRebalTime();\\n\\n    IAFi.UnderlyingData memory underlyingUniData = abi.decode(underlyingData, (IAFi.UnderlyingData));\\n    uint stableCoinBalance = IERC20(stableCoin).balanceOf(address(aFiContract));\\n    aFiContract.upDateInputTokPool(underlyingData);\\n    uint sameUnderlyingCount = rebalanceAlgo(underlyingData, newUnderlyingOracle, aFiContract, stableCoin, deadline, slippageFactor);\\n\\n    // Feetransfer to caller for rebalance\\n    if (managerFee \\u003e 0 \\u0026\\u0026 IERC20(stableCoin).balanceOf(address(aFiContract)) \\u003e managerFee) {\\n      aFiContract.sendProfitOrFeeToManager(msg.sender, managerFee, stableCoin);\\n    }\\n\\n    swapNewUnderlying(\\n      underlyingUniData._underlyingTokens,\\n      stableCoin,\\n      aFiContract,\\n      sameUnderlyingCount,\\n      stableCoinBalance,\\n      deadline,\\n      slippageFactor\\n    );\\n\\n    aFiContract.updateUnderlyingData(underlyingUniData._underlyingTokens, _uTokenProportions, defaultProportion);\\n    addUnderlying(_aFiStorage, aFiContract, underlyingUniData._underlyingTokens);\\n\\n    emit RebalanceUnderlyingTokens(\\n      address(aFiContract),\\n      address(_aFiStorage),\\n      underlyingUniData._underlyingTokens,\\n      stableCoin,\\n      managerFee\\n    );\\n  }\\n\\n  function rebalanceAlgo(bytes memory uniData, address[] memory newUnderlyingOracle, IAFi aFiContract, address stableCoin, uint deadline, uint[] memory slippageFactor) internal returns(uint256){\\n    bool exist;\\n    uint sameUnderlyingCount;\\n    IAFi.UnderlyingData memory underlyingUniData = abi.decode(uniData, (IAFi.UnderlyingData));\\n\\n    for(uint i= 0;i \\u003c _uTokens.length; i++){\\n      underlyingExists[_uTokens[i]] = true;\\n    }\\n\\n    for (uint i = 0; i \\u003c underlyingUniData._underlyingTokens.length; i++) {\\n      exist = checkIfUTokenExist(underlyingUniData._underlyingTokens[i]);\\n      aFiContract.updateOracleData(underlyingUniData._underlyingTokens[i], newUnderlyingOracle[i], underlyingUniData._underlyingUniPoolToken[i], underlyingUniData._underlyingUniPool[i]);\\n      if (exist) {\\n        newListExist[underlyingUniData._underlyingTokens[i]] = true;\\n        exist = false;\\n        sameUnderlyingCount++;\\n      }\\n    }\\n\\n    address midTok;\\n    uint rebalanceAmount;\\n    if(sameUnderlyingCount \\u003c (_uTokens.length)){\\n      for (uint i = 0; i \\u003c _uTokens.length; i++) {\\n        if (!newListExist[_uTokens[i]]) {\\n          rebalanceAmount = IERC20(_uTokens[i]).balanceOf(address(aFiContract));\\n          midTok = aFiContract.getMidToken(_uTokens[i]);\\n          if(midTok == stableCoin){\\n            //update unipool\\n            aFiContract.updateuniPool(_uTokens[i], midTok);\\n          }\\n          // Get Deposit token back from the UToken that is going to be rebalanced\\n          aFiManagerSwap(_uTokens[i], stableCoin, rebalanceAmount, aFiContract, deadline, midTok, slippageFactor);\\n        }\\n      }\\n    }else{\\n      for (uint i = 0; i \\u003c _uTokens.length; i++) {\\n        rebalanceAmount = IERC20(_uTokens[i]).balanceOf(address(aFiContract));\\n        midTok = aFiContract.getMidToken(_uTokens[i]);\\n        if(midTok == stableCoin){\\n          //update unipool\\n          aFiContract.updateuniPool(_uTokens[i], midTok);\\n        }\\n        // Get Deposit token back from the UToken that is going to be rebalanced\\n        aFiManagerSwap(_uTokens[i], stableCoin, rebalanceAmount, aFiContract, deadline, midTok, slippageFactor);\\n      }\\n    }\\n\\n    return sameUnderlyingCount;\\n  } \\n\\n  function swapNewUnderlying(\\n    address[] memory uTokensToAdd,\\n    address stableCoin,\\n    IAFi aFiContract,\\n    uint _sameUnderlying,\\n    uint oldBalance,\\n    uint deadline, \\n    uint[] memory slippageFactor\\n  ) internal {\\n    uint underlyingBalance;\\n\\n    uint stableCoinBalance = ((IERC20(stableCoin).balanceOf(address(aFiContract))) - (oldBalance));\\n    uint newRebalToken = uTokensToAdd.length - _sameUnderlying;\\n    \\n    if (stableCoinBalance \\u003e 0) {\\n      address midTok;\\n      if(_sameUnderlying == _uTokens.length){\\n        \\n        _uTokens = uTokensToAdd;\\n        newRebalToken = uTokensToAdd.length;\\n        underlyingBalance = (stableCoinBalance / (newRebalToken));\\n      if(underlyingBalance \\u003e 0){\\n          for (uint i = 0; i \\u003c uTokensToAdd.length; i++) {\\n            midTok = aFiContract.getMidToken(uTokensToAdd[i]);\\n            if(midTok == stableCoin){\\n              //update unipool\\n              aFiContract.updateuniPool(uTokensToAdd[i], midTok);\\n            }\\n\\n            aFiManagerSwap(stableCoin, uTokensToAdd[i], underlyingBalance, aFiContract, deadline, midTok, slippageFactor);\\n          }\\n        }\\n      }else{\\n        underlyingBalance = (stableCoinBalance / (newRebalToken));\\n        for (uint i = 0; i \\u003c uTokensToAdd.length; i++) {\\n          if(!underlyingExists[uTokensToAdd[i]] \\u0026\\u0026 underlyingBalance \\u003e 0){\\n            midTok = aFiContract.getMidToken(uTokensToAdd[i]);\\n            if(midTok == stableCoin){\\n              //update unipool\\n              aFiContract.updateuniPool(uTokensToAdd[i], midTok);\\n            }\\n            aFiManagerSwap(stableCoin, uTokensToAdd[i], underlyingBalance, aFiContract, deadline, midTok, slippageFactor);\\n          } \\n        }\\n      }\\n    }\\n\\n    for(uint256 i= 0;i \\u003c _uTokens.length; i++){\\n      underlyingExists[_uTokens[i]] = false;\\n    }\\n  }\\n\\n  // emergency withdraw from pools\\n  function withdrawFromPool(\\n    IAFiStorage _afiStorage,\\n    IAFi aFiContract,\\n    address underlyinToken\\n  ) external onlyOwner nonReentrant contractUnpaused{\\n    _afiStorage._withdrawAll(address(aFiContract), underlyinToken);\\n    emit WithdrawFromPool(address(aFiContract), underlyinToken);\\n  }\\n\\n  /**\\n   * @notice To distribute profit share amongst team wallet.\\n   * @param share The profit amount that is distributed amongst team wallets.\\n   * @param oToken Output token\\n   * @return totalProfitShare Returns the total profit share that was distributed amongst the team wallets\\n   */\\n  function _distributeProfitShare(\\n    address _aFiStorage,\\n    address aFiContract,\\n    uint share,\\n    address oToken,\\n    uint256 depositNAV,\\n    uint256 redemptionNAV\\n  ) external onlySpecificAddress(aFiContract) returns (uint totalProfitShare) {\\n    uint256 profitShare;\\n    (uint256 price, uint256 multiplier) = IAFiStorage(_aFiStorage).checkIfUSDC(\\n      aFiContract,\\n      oToken,\\n      WETH\\n    );\\n    \\n    if(price !=0){\\n      profitShare = (\\n      (redemptionNAV.sub(depositNAV)).mul(share).mul(multiplier)\\n      ).div(\\n        ((uint(price)).mul(10 ** (IAFiStorage(_aFiStorage).validateAndGetDecimals(oToken)))).mul(\\n          10000\\n        )\\n      );\\n      totalProfitShare = profitDistribution(aFiContract, _aFiStorage, profitShare, oToken);\\n    }\\n  }\\n\\n  function profitDistribution(address aFiContract, address _aFiStorage, uint256 profitShare, address oToken) internal returns(uint totalProfitShare){\\n    // Investor has made a profit, let us distribute the profit share amongst team wallet\\n    address[] memory _teamWallets = IAFiStorage(_aFiStorage).getTeamWalletsOfAFi(\\n      aFiContract\\n    );\\n    // Alpha Creator gets 4% of gain\\n\\n    uint totalActive = IAFiStorage(_aFiStorage).getTotalActiveWallets(aFiContract);\\n    uint256 teamProfitShare = profitShare.mul(totalProfit - daoProfit).div(\\n      (totalActive - 1).mul(100)\\n    );\\n\\n    for (uint i = 0; i \\u003c _teamWallets.length; i++) {\\n      (bool isActive, ) = IAFiStorage(_aFiStorage).getTeamWalletDetails(\\n        aFiContract,\\n        _teamWallets[i]\\n      );\\n\\n      if (isActive) {\\n        if (i == 0) {\\n          // /**\\n          //   Always at i==0 address must be of Aarna Dao\\n          //   Aarna DAO gets 6% of gain\\n          // */\\n          uint256 daoProfitShare = profitShare.mul(daoProfit).div(100);\\n          profitShare = daoProfitShare;\\n        } else {\\n          profitShare = teamProfitShare;\\n        }\\n        IAFi(aFiContract).sendProfitOrFeeToManager(_teamWallets[i], profitShare, oToken);\\n        emit ProfitShareDistributed(aFiContract, _teamWallets[i], profitShare);\\n      }\\n    }\\n    totalProfitShare = totalProfitShare.add(profitShare); \\n  }\\n  \\n  function updateProfitShare(uint _totalProfit, uint _daoProfit) external onlyOwner contractUnpaused{\\n    require(_daoProfit \\u003c _totalProfit \\u0026\\u0026 _totalProfit \\u003c= 10, \\\"AM02\\\");\\n    daoProfit = _daoProfit;\\n    totalProfit = _totalProfit;\\n    emit ProfitShareUpdated(daoProfit, totalProfit); // Emit relevant event\\n  }\\n\\n /**\\n   * @notice Updates the underlying token in uTokens array by updating price oracle and existance of the token.\\n   * @dev The contract must call this if the product type is 3 and\\n   * If token is old(Already present in the underlying before new underlying) then only existance status will change.\\n   * If token is new and never existed in previous underlying token array then\\n   * It should add the token in underlying token\\u0027s array by\\n   * updating it\\u0027s price oracle and existance status.\\n   * @param _aFiStorage indicates the address of the afiStorage.\\n   * @param _aFiContract indicates the address of the afiContract.\\n   * @param uToken indicates the address of the underlying token.\\n   */\\n  function addUnderlying(\\n    IAFiStorage _aFiStorage,\\n    IAFi _aFiContract,\\n    address[] memory uToken\\n    ) internal{\\n\\n      uint[] memory props = new uint[](uToken.length);\\n      address midTok;\\n\\n      for (uint j = 0; j \\u003c uToken.length; j++) {\\n        midTok = _aFiContract.getMidToken(uToken[j]);\\n        underlyingExists[uToken[j]] = true;\\n        uint256 newProp = (_aFiStorage.calcPoolValue(uToken[j], address(_aFiContract), midTok).mul(10000000)).div(\\n          _aFiStorage.calculatePoolInUsd(address(_aFiContract))\\n        );\\n        props[j] = newProp;\\n      }\\n      _aFiContract.updateUnderlyingData(uToken, props, props);\\n  }\\n\\n  /**\\n  * @notice gets the new proportions of the underlying tokens in an afiContract.\\n  * @return uTokensProportions array of new uTokens proportions for logging.\\n  * @param aFiContract indicates address of afiContract\\n  * @param _aFiStorage indicates address of afiStorage.\\n  */\\n  function updateProportion(address aFiContract, IAFiStorage _aFiStorage)\\n  internal\\n  returns (uint[] memory)\\n    {\\n      uint256 uTokenLen = _uTokens.length;\\n      uint256 totalProp;\\n      address midTok;\\n      tokens = _uTokens;\\n      //Update Proportions\\n      unchecked {\\n        for (uint j = 0; j \\u003c uTokenLen; j++) {\\n          midTok = IAFi(aFiContract).getMidToken(_uTokens[j]);\\n          _uTokenProportions[j] = (\\n          _aFiStorage.calcPoolValue(_uTokens[j], aFiContract, midTok).mul(10000000)\\n          ).div(_aFiStorage.calculatePoolInUsd(aFiContract));\\n          defaultProportion[j] = _uTokenProportions[j];\\n          totalProp = totalProp + _uTokenProportions[j];\\n        }\\n      }\\n      // fail safe condition\\n      if (totalProp \\u003e 10000000) {\\n        uint256 rem = totalProp - 10000000;\\n        uint256 currentTotalProp = totalProp;\\n        totalProp = 0;\\n        for(uint i = 0; i \\u003c uTokenLen; i++){\\n          if(_uTokenProportions[i] \\u003e 0){\\n            _uTokenProportions[i] -= rem.mul(_uTokenProportions[i]).div(currentTotalProp);\\n          }\\n          totalProp +=  _uTokenProportions[i];\\n        }\\n        if (totalProp \\u003e 10000000) {\\n          rem = totalProp - 10000000;\\n          _uTokenProportions[uTokenLen - 1] -= rem;\\n        }\\n      }\\n      return _uTokenProportions;\\n  }\\n\\n  /**\\n  * @notice Removes a token and it\\u0027s proportion and default Proportion from the uToken and uTokenProportion and defaultUToken proportion array in afi Contract.\\n  * @param uTokenToRemoveIndex index of the token to remove.\\n  */\\n  function removeIndex(\\n      uint uTokenToRemoveIndex\\n  ) internal{\\n      //To avoid stack too deep error\\n      _uTokens.sPopAddress(uTokenToRemoveIndex);\\n      _uTokenProportions.sPopUint256(uTokenToRemoveIndex);\\n      defaultProportion.sPopUint256(uTokenToRemoveIndex);\\n  }\\n\\n  function updateProportionData() internal {\\n    uint proportion = 0;\\n    defaultProportion.push(proportion);\\n    _uTokenProportions.push(proportion);\\n  }\\n\\n  function setSlippage(IAFi aFiContract, address[] memory uToken, IERC20 depositToken, uint[] memory slippageFactor) internal{\\n    for(uint i=0; i\\u003c uToken.length; i++){\\n      underlyingSlippage[address(aFiContract)][uToken[i]] = slippageFactor[i];\\n    }\\n    underlyingSlippage[address(aFiContract)][address(depositToken)] = slippageFactor[uToken.length]; \\n  }\\n\\n  /**\\n  * @notice Returns the existance status of a token in a afi contract.\\n  * @param uTok indicates the address of the token.\\n  * @return bool whether token exists or not.\\n  */\\n  function checkIfUTokenExist(address uTok) internal view returns (bool) {\\n    return underlyingExists[uTok];\\n  }\\n\\n  /**\\n  * @notice Returns a new array of underlying token, token proportion and default proption that to be used by the AFiBase.\\n  * @param aFiContract address of the afiContract.\\n  * @param aFiContract address of the AFiStorage.\\n  * @return uTokensProportions array of new proportion.\\n  */\\n  function updateUTokenProportion(address aFiContract, address _aFiStorage) external returns(uint256[] memory uTokensProportions){\\n    require(msg.sender == IAFi(aFiContract).getRebalContract(), \\\"NA\\\");\\n    _uTokens = IAFi(aFiContract).getUTokens();\\n    (_uTokenProportions, defaultProportion, ) = IAFi(aFiContract).getProportionsAndRebalTime();\\n    uTokensProportions = updateProportion(aFiContract, IAFiStorage(_aFiStorage));\\n    emit UTokenProportionUpdated(aFiContract, uTokensProportions);\\n  } \\n\\n  function uTokenslippage(address aFiContract, address uToken) external view returns(uint uTokenSlippage){\\n    return underlyingSlippage[aFiContract][uToken];\\n  }\\n\\n  function emergencyRebalance(\\n    IAFi aFiContract,\\n    IAFiStorage _aFiStorage,\\n    address uTokenToRemove,\\n    address[] memory uTok,\\n    uint256[] memory newProp\\n  ) external onlyOwner nonReentrant contractUnpaused{\\n    if(aFiContract.getTypeOfProduct() == 2){\\n      _aFiStorage._withdrawAll(address(aFiContract), uTokenToRemove);\\n    }\\n    aFiContract.updateUnderlyingData(uTok, newProp, newProp);\\n  }\\n}\"},\"ArrayUtils.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicensed\\n\\npragma solidity =0.8.0;\\n\\n// Reference: https://github.com/cryptofinlabs/cryptofin-solidity/blob/master/contracts/array-utils/AddressArrayUtils.sol\\nlibrary ArrayUtils {\\n  /**\\n   * Deletes address at index and fills the spot with the last address.\\n   * Order is preserved.\\n   */\\n  // solhint-disable-next-line var-name-mixedcase\\n  function sPopAddress(address[] storage A, uint index) internal {\\n    uint length = A.length;\\n    if (index \\u003e= length) {\\n      revert(\\\"Error: index out of bounds\\\");\\n    }\\n\\n    for (uint i = index; i \\u003c length - 1; i++) {\\n      A[i] = A[i + 1];\\n    }\\n    A.pop();\\n  }\\n\\n  // solhint-disable-next-line var-name-mixedcase\\n  function sPopUint256(uint[] storage A, uint index) internal {\\n    uint length = A.length;\\n    if (index \\u003e= length) {\\n      revert(\\\"Error: index out of bounds\\\");\\n    }\\n\\n    for (uint i = index; i \\u003c length - 1; i++) {\\n      A[i] = A[i + 1];\\n    }\\n    A.pop();\\n  }\\n\\n  // solhint-disable-next-line var-name-mixedcase\\n  function sumOfMArrays(\\n    uint[] memory A,\\n    uint[] memory B\\n  ) internal pure returns (uint[] memory sum) {\\n    sum = new uint[](A.length);\\n    for (uint i = 0; i \\u003c A.length; i++) {\\n      sum[i] = A[i] + B[i];\\n    }\\n    return sum;\\n  }\\n\\n  /**\\n   * Finds the index of the first occurrence of the given element.\\n   * @param A The input array to search\\n   * @param a The value to find\\n   * @return Returns (index and isIn) for the first occurrence starting from index 0\\n   */\\n  function indexOf(address[] memory A, address a) internal pure returns (uint, bool) {\\n    uint length = A.length;\\n    for (uint i = 0; i \\u003c length; i++) {\\n      if (A[i] == a) {\\n        return (i, true);\\n      }\\n    }\\n    return (type(uint).max, false);\\n  }\\n\\n  /**\\n   * Returns true if the value is present in the list. Uses indexOf internally.\\n   * @param A The input array to search\\n   * @param a The value to find\\n   * @return Returns isIn for the first occurrence starting from index 0\\n   */\\n  function contains(address[] memory A, address a) internal pure returns (bool) {\\n    (, bool isIn) = indexOf(A, a);\\n    return isIn;\\n  }\\n\\n  /**\\n   * Returns true if there are 2 elements that are the same in an array\\n   * @param A The input array to search\\n   * @return Returns boolean for the first occurrence of a duplicate\\n   */\\n  function hasDuplicate(address[] memory A) internal pure returns (bool) {\\n    require(A.length \\u003e 0, \\\"A is empty\\\");\\n\\n    for (uint i = 0; i \\u003c A.length - 1; i++) {\\n      address current = A[i];\\n      for (uint j = i + 1; j \\u003c A.length; j++) {\\n        if (current == A[j]) {\\n          return true;\\n        }\\n      }\\n    }\\n    return false;\\n  }\\n\\n  /**\\n   * @param A The input array to search\\n   * @param a The address to remove\\n   * @return Returns the array with the object removed.\\n   */\\n  function remove(\\n    address[] memory A,\\n    address a\\n  ) internal pure returns (address[] memory) {\\n    (uint index, bool isIn) = indexOf(A, a);\\n    if (!isIn) {\\n      revert(\\\"Address not in array.\\\");\\n    } else {\\n      (address[] memory _A, ) = pop(A, index);\\n      return _A;\\n    }\\n  }\\n\\n  /**\\n   * @param A The input array to search\\n   * @param a The address to remove\\n   */\\n  function removeStorage(address[] storage A, address a) internal {\\n    (uint index, bool isIn) = indexOf(A, a);\\n    if (!isIn) {\\n      revert(\\\"Address not in array.\\\");\\n    } else {\\n      uint lastIndex = A.length - 1; // If the array would be empty, the previous line would throw, so no underflow here\\n      if (index != lastIndex) {\\n        A[index] = A[lastIndex];\\n      }\\n      A.pop();\\n    }\\n  }\\n\\n  /**\\n   * Removes specified index from array\\n   * @param A The input array to search\\n   * @param index The index to remove\\n   * @return Returns the new array and the removed entry\\n   */\\n  function pop(\\n    address[] memory A,\\n    uint index\\n  ) internal pure returns (address[] memory, address) {\\n    uint length = A.length;\\n    require(index \\u003c A.length, \\\"Index must be \\u003c A length\\\");\\n    address[] memory newAddresses = new address[](length - 1);\\n    for (uint i = 0; i \\u003c index; i++) {\\n      newAddresses[i] = A[i];\\n    }\\n    for (uint j = index + 1; j \\u003c length; j++) {\\n      newAddresses[j - 1] = A[j];\\n    }\\n    return (newAddresses, A[index]);\\n  }\\n\\n  /**\\n   * Returns the combination of the two arrays\\n   * @param A The first array\\n   * @param B The second array\\n   * @return Returns A extended by B\\n   */\\n  function extend(\\n    address[] memory A,\\n    address[] memory B\\n  ) internal pure returns (address[] memory) {\\n    uint aLength = A.length;\\n    uint bLength = B.length;\\n    address[] memory newAddresses = new address[](aLength + bLength);\\n    for (uint i = 0; i \\u003c aLength; i++) {\\n      newAddresses[i] = A[i];\\n    }\\n    for (uint j = 0; j \\u003c bLength; j++) {\\n      newAddresses[aLength + j] = B[j];\\n    }\\n    return newAddresses;\\n  }\\n\\n  /**\\n   * Validate that address and uint array lengths match. Validate address array is not empty\\n   * and contains no duplicate elements.\\n   *\\n   * @param A         Array of addresses\\n   * @param B         Array of uint\\n   */\\n  function validatePairsWithArray(address[] memory A, uint[] memory B) internal pure {\\n    require(A.length == B.length, \\\"Array length mismatch\\\");\\n    _validateLengthAndUniqueness(A);\\n  }\\n\\n  /**\\n   * Validate that address and bool array lengths match. Validate address array is not empty\\n   * and contains no duplicate elements.\\n   *\\n   * @param A         Array of addresses\\n   * @param B         Array of bool\\n   */\\n  function validatePairsWithArray(address[] memory A, bool[] memory B) internal pure {\\n    require(A.length == B.length, \\\"Array length mismatch\\\");\\n    _validateLengthAndUniqueness(A);\\n  }\\n\\n  /**\\n   * Validate that address and string array lengths match. Validate address array is not empty\\n   * and contains no duplicate elements.\\n   *\\n   * @param A         Array of addresses\\n   * @param B         Array of strings\\n   */\\n  function validatePairsWithArray(address[] memory A, string[] memory B) internal pure {\\n    require(A.length == B.length, \\\"Array length mismatch\\\");\\n    _validateLengthAndUniqueness(A);\\n  }\\n\\n  /**\\n   * Validate that address array lengths match, and calling address array are not empty\\n   * and contain no duplicate elements.\\n   *\\n   * @param A         Array of addresses\\n   * @param B         Array of addresses\\n   */\\n  function validatePairsWithArray(\\n    address[] memory A,\\n    address[] memory B\\n  ) internal pure {\\n    require(A.length == B.length, \\\"Array length mismatch\\\");\\n    _validateLengthAndUniqueness(A);\\n  }\\n\\n  /**\\n   * Validate that address and bytes array lengths match. Validate address array is not empty\\n   * and contains no duplicate elements.\\n   *\\n   * @param A         Array of addresses\\n   * @param B         Array of bytes\\n   */\\n  function validatePairsWithArray(address[] memory A, bytes[] memory B) internal pure {\\n    require(A.length == B.length, \\\"Array length mismatch\\\");\\n    _validateLengthAndUniqueness(A);\\n  }\\n\\n  /**\\n   * Validate address array is not empty and contains no duplicate elements.\\n   *\\n   * @param A          Array of addresses\\n   */\\n  function _validateLengthAndUniqueness(address[] memory A) internal pure {\\n    require(A.length \\u003e 0, \\\"Array length must be \\u003e 0\\\");\\n    require(!hasDuplicate(A), \\\"Cannot duplicate addresses\\\");\\n  }\\n}\\n\"},\"Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"},\"draft-IERC20Permit.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account\\u0027s ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn\\u0027t\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``\\u0027s tokens,\\n     * given ``owner``\\u0027s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``\\u0027s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``\\u0027s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"},\"IAFi.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicensed\\n\\npragma solidity =0.8.0;\\n\\nimport {IERC20Extended as IERC20} from \\\"./IERC20Extended.sol\\\";\\nimport \\\"./IAFiStorage.sol\\\";\\nimport \\\"./IPassiveRebal.sol\\\";\\n\\n/**\\n * @title PassiveRebal.\\n * @notice Interface of the Passive Rebalance contract.\\n */\\ninterface PassiveRebal {\\n\\n  function applyRebalForProportions(\\n    address _aFiContract,\\n    address _aFiManager,\\n    uint _strategyNumber,\\n    address[] memory _tokens\\n  ) external returns (uint[] memory proportions);\\n\\n  function getPauseStatus() external returns (bool);\\n\\n  function getRebalPeriod(address aFiContract) external returns (uint);\\n\\n  function updateRebalPeriod(address aFiContract, uint _newRebalPeiod) external;\\n\\n  function setPassiveRebalancedStatus(address aFiContract, bool status) external;\\n\\n  function isAFiPassiveRebalanced(\\n    address aFiContract\\n  ) external returns (bool _isPassiveRebalanced);\\n\\n  function getRebalStrategyNumber(address aFiContract) external returns (uint);\\n\\n  function updateRebalStrategyNumber(\\n    address aFiContract,\\n    uint updatedStrategy\\n  ) external;\\n}\\n\\ninterface IAFiManager {\\n  function _distributeProfitShare(\\n    address aFiStorage,\\n    address aFiContract,\\n    uint profit,\\n    address oToken,\\n    uint256 depositNAV,\\n    uint256 redemptionNAV\\n  ) external returns (uint totalProfitShare);\\n\\n  function updateUTokenProportion(address aFiContract,address aFiStorage) external returns(uint256[] memory);\\n\\n  function intializeData(address aFiContract,address[] memory underlyingTokens,uint[] memory underlyingProportion) external;\\n\\n  function uTokenslippage(address aFiContract, address uToken) external view returns(uint uTokenSlippage);\\n\\n}\\n\\n/**\\n * @title IAFi.\\n * @notice Interface of the AToken.\\n */\\ninterface IAFi {\\n\\n  struct StablePools{\\n    address[] _pools;\\n  }\\n\\n  struct UnderlyingData{\\n    address[] _underlyingTokens;\\n    address[] _underlyingUniPoolToken;\\n    address[] _underlyingUniPool;\\n    address[] _underlyingPoolWithWETH;\\n    StablePools[] stablePools;\\n    address[] stableWethPool;\\n  }\\n\\n  struct PoolsData {\\n    address[] _depositStableCoin;\\n    address[] _depositCoinOracle;\\n    bytes underlyingData;                                                                             \\n    address _apr;\\n    address[] _compound;\\n    address[] _aaveToken;\\n    address[] _priceOracles;\\n    uint[] _underlyingTokensProportion;\\n    uint[] _dToken;\\n    uint _typeOfProduct;\\n  }\\n\\n  /**\\n   * @param account Address of the account that paused the contract.\\n   * @param isDeposit True if we want to pause deposit otherwise false if want to pause withdraw.\\n   */\\n  event Paused(address account,bool isDeposit);\\n  /**\\n   * @param account Address of the account that unpaused the contract.\\n   * @param isDeposit True if we want to unpause deposit otherwise false if want to unpause withdraw.\\n   */\\n  event Unpaused(address account,bool isDeposit);\\n\\n  /**\\n   * @notice Function to initialize the data, owner and afi token related data.\\n   * @dev the function should be called once only by factory\\n   * @param newOwner indicates the owner of the created afi product.\\n   * @param _name indicates the name of the afi Token\\n   * @param _symbol indicates symbol of the the afi Token.\\n   * @param data indicates the encoded data that follows the PoolsData struct format.\\n   * @param _isActiveRebalanced indicates the active rebalance status of the afi contract.\\n   * @param _aFiStorage indicates the afi storage contract address.\\n   */\\n  function initialize(\\n    address newOwner,\\n    string memory _name,\\n    string memory _symbol,\\n    bytes memory data,\\n    bool _isActiveRebalanced,\\n    IAFiStorage _aFiStorage\\n  ) external;\\n\\n  /**\\n   * @notice Function to initialize the platform related data.\\n   * @dev  the function should be called once only by factory\\n   * @param _teamWallets indicates the array of the wallets to share the profit and confirm active rebalance txn.\\n   * @param _rebalContract indicates passive rebal strategy contract address.\\n   * @param _isPassiveRebalanced indicates the passive rebalance status of the afi contract.\\n   * @param _aFiManager indicates the afi manager contract address.\\n   * @param _aarnaEngine indicates the engine contract.\\n   */\\n  function initializePlatformData(\\n    address[] memory _teamWallets,\\n    IPassiveRebal _rebalContract,\\n    bool _isPassiveRebalanced,\\n    address _aFiManager,\\n    address _aarnaEngine\\n  ) external;\\n\\n  /**\\n   * @notice Function to initialize accepted tokens in deposit and withdraw functions.\\n   * @dev  the function should be called once only by factory\\n   * @param iToken indicates the array of the accepted token addressess.\\n   */\\n  function initializeToken(\\n    address[] memory iToken,\\n    address[] memory iTokenOracel,\\n    bytes memory poolData\\n  ) external;\\n\\n  /**\\n   * @notice Returns the array of underlying tokens.\\n   * @return uTokensArray Array of underlying tokens.\\n   */\\n  function getUTokens() external view returns (address[] memory uTokensArray);\\n  function swapViAFiStorage(\\n    address from,\\n    address to,\\n    uint amount,\\n    uint deadline,\\n    address midTok,\\n    uint[] memory slippageFactor,\\n    uint8 counter\\n  ) external returns(uint256);\\n  \\n  /**\\n   * @notice Returns the paused status of the contract.\\n   */\\n  function isPaused() external view returns (bool,bool);\\n  function getProportionsAndRebalTime() external view returns (uint[] memory, uint[] memory, uint256);\\n  /**\\n   * @notice Updates the pool data during Active Rebalance.\\n   * @param data that follows PoolsData format indicates the data of the token being rebalanced in Active Rebalance.\\n   */\\n  function updatePoolData(bytes memory data) external;\\n  function sendProfitOrFeeToManager(address wallet, uint profitShare, address oToken) external;\\n  function totalSupply() external view returns (uint);\\n  function updateUnderlyingData(address[] memory _uTokens,uint256[] memory _uTokenProportion,uint256[] memory _defaultProportion)external;\\n  function _supplyDydx(address tok, uint amount) external;\\n  function _supplyAave(address tok, uint amount) external;\\n  function _supplyCompound(address tok, uint amount) external;\\n  function getRebalContract() external view returns(address);\\n  function getPriceOracle(address tok) external view returns(address);\\n  function updateOracleData(address _uTokens, address _oracleAddress, address _underlyingMidToken, address uniPool)external;\\n  function _withdrawAave(address tok, uint amount) external;\\n  function _withdrawDydx(address tok, uint amount) external;\\n  function _withdrawCompound(address tok, uint amount) external;\\n  function getTVL() external view returns(uint256);\\n  function upDateInputTokPool(bytes memory uniData) external;\\n  function getTypeOfProduct() external view returns(uint256);\\n  function updateuniPool(address tok, address midTok) external;\\n  function getMidToken(address tok) external view returns (address);\\n  function getPool(\\n    address tok,\\n    address midTok\\n  ) external view returns (address);\\n}\"},\"IAFiStorage.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicensed\\n\\npragma solidity =0.8.0;\\n\\n/**\\n * @title IAFiStorage.\\n * @notice Interface of the AFiStorage.\\n */\\n\\ninterface IIEarnManager {\\n  function recommend(\\n    address _token,\\n    address afiBase,\\n    address afiStorage\\n  ) external view returns (string memory choice, uint capr, uint aapr, uint dapr);\\n}\\n\\ninterface IAFiStorage {\\n  /**\\n   * @notice Struct representing investor details.\\n   * @param isPresent Boolean indicating whether an investor exists.\\n   * @param uTokenBalance Investor underlying token balance.\\n   * @param investedAmount Amount of StableCoin invested in the underlying token\\n   */\\n  struct Investor {\\n    bool isPresent;\\n    uint depositNAV;\\n    uint redemptionNAV;\\n  }\\n\\n  /**\\n   * @notice Struct representing TeamWallet details.\\n   * @param isPresent Boolean indicating whether a wallet exists.\\n   * @param isActive Boolean indicating whether a wallet is active.\\n   * @param walletAddress Wallet address.\\n   */\\n  struct TeamWallet {\\n    bool isPresent;\\n    bool isActive;\\n    address walletAddress;\\n  }\\n\\n  /**\\n   * @notice enum representing Lending Protocols.\\n   * @param NONE represents NO protocol.\\n   * @param DYDX represents DYDX protocol.\\n   * @param COMPOUND represents COMPOUND protocol.\\n   * @param AAVE represents AAVE protocol.\\n   */\\n  enum Lender {\\n    NONE,\\n    DYDX,\\n    COMPOUND,\\n    AAVE\\n  }\\n\\n  /**\\n   * @notice Struct representing Rebalance details.\\n   * @param scenario Scenario can be either of 0, 1 or 2.\\n   * @param rebalancedUToken Address of the underlying token that is rebalanced.\\n   * @param rebalancedToUTokens Array of addresses of underlying tokens to which the uToken has been rebalanced.\\n   */\\n  struct RebalanceDetails {\\n    uint8 scenario;\\n    address rebalancedUToken;\\n    address[] rebalancedToUTokens;\\n  }\\n\\n  /**\\n   * @param walletAddress Address of the wallet.\\n   * @param isActive Boolean indicating wallet active status.\\n   */\\n  event TeamWalletActive(address indexed walletAddress, bool isActive);\\n\\n  /**\\n   * @param walletAddress Address of the wallet.\\n   * @param isActive Boolean indicating wallet active status.\\n   */\\n  event TeamWalletAdd(address indexed walletAddress, bool isActive);\\n\\n  /**\\n   * @notice Returns the team wallet details.\\n   * @param aFiContract Address of the AFi contract.\\n   * @param _wallet Wallet address\\n   * @return isPresent Boolean indicating the present status of the wallet.\\n   * @return isActive Boolean indicating whether to set the wallet to either active/inactive.\\n   */\\n  function getTeamWalletDetails(\\n    address aFiContract,\\n    address _wallet\\n  ) external view returns (bool isPresent, bool isActive);\\n\\n  /**\\n   * @notice To add a new team wallet.\\n   * @param aFiContract Address of the AFi contract.\\n   * @param _wallet Wallet address that has to be added in the `teamWallets` array.\\n   * @param isActive Boolean indicating whether to set the wallet to either active/inactive.\\n   * @param isPresent Boolean indicating the present status of the wallet.\\n   */\\n  function addTeamWallet(\\n    address aFiContract,\\n    address _wallet,\\n    bool isActive,\\n    bool isPresent\\n  ) external;\\n\\n  /**\\n   * @notice Returns the team wallets for an AFi.\\n   * @param aFiContract Address of the AFi contract.\\n   * @return _teamWallets Array of teamWallets.\\n   */\\n  function getTeamWalletsOfAFi(\\n    address aFiContract\\n  ) external view returns (address[] memory _teamWallets);\\n\\n  /**\\n   * @notice Sets the address for team wallets.\\n   * @param aFiContract Address of the AFi contract.\\n   * @param _teamWallets Array of addresses for the team wallets.\\n   */\\n  function setTeamWallets(address aFiContract, address[] memory _teamWallets) external;\\n\\n  /**\\n   * @notice Sets the status for the AFi in the storage contract.\\n   * @param aFiContract Address of the AFi contract.\\n   * @param active status for afiContracts.\\n   */\\n  function setAFiActive(address aFiContract, bool active) external;\\n\\n  /**\\n   * @notice To update rebalance details in the storage\\n   * @param aFiContract Address of the AFi contract.\\n   * @param rbUToken Address of the underlying token that is rebalanced.\\n   * @param rbtoUTokens Array of addresses of underlying tokens to which the uToken has been rebalanced.\\n   * @param _scenario Scenario can be either of 0, 1 or 2.\\n   */\\n  function updateRebalanceDetails(\\n    address aFiContract,\\n    address rbUToken,\\n    address[] memory rbtoUTokens,\\n    uint8 _scenario\\n  ) external;\\n\\n  /**\\n   * @notice Sets Active Rebalance status of an AFi.\\n   * @param aFiContract Address of the AFi contract.\\n   * @param status indicating active rebalance status of the AFi contract.\\n   */\\n  function setActiveRebalancedStatus(address aFiContract, bool status) external;\\n\\n  /**\\n   * @notice gets Active Rebalance status of an AFi.\\n   * @param aFiContract Address of the AFi contract.\\n   * @return _isActiveRebalanced bool indicating active rebalance status of the AFi contract.\\n   */\\n  function isAFiActiveRebalanced(\\n    address aFiContract\\n  ) external view returns (bool _isActiveRebalanced);\\n\\n  function getTotalActiveWallets(address aFiContract) external view returns (uint);\\n\\n  function setAPR(address aFiContract, address _apr) external;\\n\\n  function calcPoolValue(address tok, address afiContract, address midTok) external view returns (uint);\\n\\n  function calculateBalanceOfUnderlying(\\n    address tok,\\n    address afiContract\\n  ) external view returns (uint);\\n\\n  function calculatePoolInUsd(address afiContract) external view returns (uint);\\n\\n  function calcPoolValueSome(\\n    address tok,\\n    address afiContract,\\n    address midTok\\n  ) external view returns (uint);\\n\\n  function afiSync(\\n    address afiContract,\\n    address tok,\\n    address aaveTok,\\n    uint dtoken,\\n    address compTok\\n  ) external;\\n\\n  function getPriceOracle(address tokenIn) external view returns (uint256 priceOracle);\\n  function getAFiInitStatus(address afiContract) external view returns(bool, bool, bool);\\n  function afiContractInitUpdate(address afiContract, uint order) external;\\n  function getMinimumAmountOut(address afiContract, address _tokenIn, uint256 _amountIn, address _tokenOut, address midTok, address uniPool) external view  returns(uint256 priceOracle);\\n  function checkIfUSDC(address afiContract, address tok, address midTok) external view returns (uint256, uint256);\\n  function validateAndGetDecimals(address tok) external  view returns(uint256);\\n  function getStakedStatus(address aFiContract,address uToken) external view  returns(bool);\\n  function rearrange(address aFiContract) external;\\n  function balanceDydx(address tok, address afiContract) external view returns (uint);\\n  function balanceDydxAvailable(address tok) external view returns (uint);\\n  function balanceCompoundInToken(address tok, address afiContract) external view returns (uint);\\n  function balanceCompound(address tok, address afiContract) external view returns (uint);\\n  function balanceAave(address tok, address afiContract) external view returns (uint);\\n  function swapForOtherProduct(address afiContract, uint r, address oToken, uint deadline, uint[] memory slippageFactor) external returns(uint256);\\n  function caculateMinOutForUniswap(address afiContract, address _tokenIn, address _tokenOut, uint256 amt, address middleToken, address uniPool) external view returns(uint256);\\n  function _withdrawAll(address afiContract, address tok) external;\\n}\\n\"},\"IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"},\"IERC20Extended.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicensed\\n\\npragma solidity =0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\ninterface IERC20Extended is IERC20 {\\n  function decimals() external view returns (uint8);\\n}\\n\"},\"IPassiveRebal.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicensed\\npragma solidity =0.8.0;\\n\\ninterface IPassiveRebal {\\n  function applyRebalForProportions(\\n    address _aFiContract,\\n    address _aFiManager,\\n    address _aFiStorage,\\n    uint _strategyNumber,\\n    address[] memory _tokens\\n  ) external returns (uint[] memory proportions);\\n\\n  function getPauseStatus() external returns (bool);\\n\\n  function getRebalPeriod(address aFiContract) external returns (uint);\\n\\n  function updateRebalPeriod(address aFiContract, uint _newRebalPeiod) external;\\n\\n  function setPassiveRebalancedStatus(address aFiContract, bool status) external;\\n\\n  function isAFiPassiveRebalanced(\\n    address aFiContract\\n  ) external returns (bool _isPassiveRebalanced);\\n\\n  function getRebalStrategyNumber(address aFiContract) external returns (uint);\\n\\n  function updateRebalStrategyNumber(\\n    address aFiContract,\\n    uint updatedStrategy\\n  ) external;\\n}\\n\"},\"Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"},\"ReentrancyGuard.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot\\u0027s contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler\\u0027s defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction\\u0027s gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"},\"SafeERC20.sol\":{\"content\":\"    // SPDX-License-Identifier: MIT\\n    // OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\\n\\n    pragma solidity ^0.8.0;\\n\\n    import \\\"./IERC20.sol\\\";\\n    import \\\"./draft-IERC20Permit.sol\\\";\\n    import \\\"./Address.sol\\\";\\n\\n    /**\\n    * @title SafeERC20\\n    * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n    * contract returns false). Tokens that return no value (and instead revert or\\n    * throw on failure) are also supported, non-reverting calls are assumed to be\\n    * successful.\\n    * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n    * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n    */\\n    library SafeERC20 {\\n        using Address for address;\\n\\n        function safeTransfer(\\n            IERC20 token,\\n            address to,\\n            uint256 value\\n        ) internal {\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n        }\\n\\n        function safeTransferFrom(\\n            IERC20 token,\\n            address from,\\n            address to,\\n            uint256 value\\n        ) internal {\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n        }\\n\\n        /**\\n        * @dev Deprecated. This function has issues similar to the ones found in\\n        * {IERC20-approve}, and its usage is discouraged.\\n        *\\n        * Whenever possible, use {safeIncreaseAllowance} and\\n        * {safeDecreaseAllowance} instead.\\n        */\\n        function safeApprove(\\n            IERC20 token,\\n            address spender,\\n            uint256 value\\n        ) internal {\\n            // safeApprove should only be called when setting an initial allowance,\\n            // or when resetting it to zero. To increase and decrease it, use\\n            // \\u0027safeIncreaseAllowance\\u0027 and \\u0027safeDecreaseAllowance\\u0027\\n            require(\\n                (value == 0) || (token.allowance(address(this), spender) == 0),\\n                \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n            );\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n        }\\n\\n        function safeIncreaseAllowance(\\n            IERC20 token,\\n            address spender,\\n            uint256 value\\n        ) internal {\\n            uint256 newAllowance = token.allowance(address(this), spender) + value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n\\n        function safeDecreaseAllowance(\\n            IERC20 token,\\n            address spender,\\n            uint256 value\\n        ) internal {\\n            unchecked {\\n                uint256 oldAllowance = token.allowance(address(this), spender);\\n                require(oldAllowance \\u003e= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n                uint256 newAllowance = oldAllowance - value;\\n                _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n            }\\n        }\\n\\n        function safePermit(\\n            IERC20Permit token,\\n            address owner,\\n            address spender,\\n            uint256 value,\\n            uint256 deadline,\\n            uint8 v,\\n            bytes32 r,\\n            bytes32 s\\n        ) internal {\\n            uint256 nonceBefore = token.nonces(owner);\\n            token.permit(owner, spender, value, deadline, v, r, s);\\n            uint256 nonceAfter = token.nonces(owner);\\n            require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n        }\\n\\n        /**\\n        * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n        * on the return value: the return value is optional (but if data is returned, it must not be false).\\n        * @param token The token targeted by the call.\\n        * @param data The call data (encoded using abi.encode or one of its variants).\\n        */\\n        function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n            // We need to perform a low level call here, to bypass Solidity\\u0027s return data size checking mechanism, since\\n            // we\\u0027re implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n            // the target address contains contract code and also asserts for success in the low-level call.\\n\\n            bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n            if (returndata.length \\u003e 0) {\\n                // Return data is optional\\n                require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n            }\\n        }\\n    }\\n\"},\"SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler\\u0027s built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations.\\n *\\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c \\u003c a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b \\u003e a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\n            // benefit is lost if \\u0027b\\u0027 is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b \\u003c= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b \\u003e 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b \\u003e 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\"},\"TransferHelper.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity \\u003e=0.6.0;\\n\\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\\nlibrary TransferHelper {\\n    function safeApprove(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes(\\u0027approve(address,uint256)\\u0027)));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\\n        require(\\n            success \\u0026\\u0026 (data.length == 0 || abi.decode(data, (bool))),\\n            \\u0027TransferHelper::safeApprove: approve failed\\u0027\\n        );\\n    }\\n\\n    function safeTransfer(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes(\\u0027transfer(address,uint256)\\u0027)));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\\n        require(\\n            success \\u0026\\u0026 (data.length == 0 || abi.decode(data, (bool))),\\n            \\u0027TransferHelper::safeTransfer: transfer failed\\u0027\\n        );\\n    }\\n\\n    function safeTransferFrom(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes(\\u0027transferFrom(address,address,uint256)\\u0027)));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\\n        require(\\n            success \\u0026\\u0026 (data.length == 0 || abi.decode(data, (bool))),\\n            \\u0027TransferHelper::transferFrom: transferFrom failed\\u0027\\n        );\\n    }\\n\\n    function safeTransferETH(address to, uint256 value) internal {\\n        (bool success, ) = to.call{value: value}(new bytes(0));\\n        require(success, \\u0027TransferHelper::safeTransferETH: ETH transfer failed\\u0027);\\n    }\\n}\"}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract IAFi\",\"name\":\"_aFiContract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_fromToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_toToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"AFiManagerSwap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"aFiContract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"AddTeamWalletInAFi\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"aFiContract\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"teamWallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ProfitShareDistributed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"daoProfit\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalProfit\",\"type\":\"uint256\"}],\"name\":\"ProfitShareUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract IAFi\",\"name\":\"_aFiContract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"_scenario\",\"type\":\"uint8\"}],\"name\":\"Rebalance\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"aFiContract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_aFiStorage\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"newUnderlyingTokens\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"stableCoin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"managerFee\",\"type\":\"uint256\"}],\"name\":\"RebalanceUnderlyingTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_aFiContract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"SetActiveRebalStatus\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"aFiContract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"uTokenProportions\",\"type\":\"uint256[]\"}],\"name\":\"UTokenProportionUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_manager\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_oldMultisig\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_newMultisig\",\"type\":\"address\"}],\"name\":\"UpdateMultisig\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_aFiContract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"uToken\",\"type\":\"address\"}],\"name\":\"WithdrawFromPool\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_aFiStorage\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"aFiContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"share\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"oToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"depositNAV\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"redemptionNAV\",\"type\":\"uint256\"}],\"name\":\"_distributeProfitShare\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalProfitShare\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_uTokenProportions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IAFiStorage\",\"name\":\"_aFiStorage\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"aFiContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"addTeamWalletInAFi\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"daoProfit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IAFi\",\"name\":\"aFiContract\",\"type\":\"address\"},{\"internalType\":\"contract IAFiStorage\",\"name\":\"_aFiStorage\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"uTokenToRemove\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"uTok\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"newProp\",\"type\":\"uint256[]\"}],\"name\":\"emergencyRebalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPauseStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"contract IAFi\",\"name\":\"aFiContract\",\"type\":\"address\"},{\"internalType\":\"contract IAFiStorage\",\"name\":\"_aFiStorage\",\"type\":\"address\"},{\"internalType\":\"contract IERC20Extended\",\"name\":\"depositToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"newUToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"uTokenToRemove\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"scenario\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"slippageFactor\",\"type\":\"uint256[]\"}],\"name\":\"rebalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IAFi\",\"name\":\"aFiContract\",\"type\":\"address\"},{\"internalType\":\"contract IAFiStorage\",\"name\":\"_aFiStorage\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"underlyingData\",\"type\":\"bytes\"},{\"internalType\":\"address[]\",\"name\":\"newUnderlyingOracle\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"stableCoin\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"managerFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"slippageFactor\",\"type\":\"uint256[]\"}],\"name\":\"rebalanceUnderlyingTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IAFiStorage\",\"name\":\"_aFiStorage\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"aFiContract\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"setActiveRebalStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalProfit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"aFiContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"uToken\",\"type\":\"address\"}],\"name\":\"uTokenslippage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"uTokenSlippage\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unPause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_totalProfit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_daoProfit\",\"type\":\"uint256\"}],\"name\":\"updateProfitShare\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"aFiContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_aFiStorage\",\"type\":\"address\"}],\"name\":\"updateUTokenProportion\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"uTokensProportions\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IAFiStorage\",\"name\":\"_afiStorage\",\"type\":\"address\"},{\"internalType\":\"contract IAFi\",\"name\":\"aFiContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"underlyinToken\",\"type\":\"address\"}],\"name\":\"withdrawFromPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "AFiManager", "CompilerVersion": "v0.8.0+commit.c7dfd78e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU GPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://a098e3455c1b2f8025294da11d24cc37ed101aa259a3fd0678508af6dae1285e"}