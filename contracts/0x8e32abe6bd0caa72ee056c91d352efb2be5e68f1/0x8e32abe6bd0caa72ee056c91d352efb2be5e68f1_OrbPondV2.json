{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/access/OwnableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport {Initializable} from \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    function __Ownable_init() internal onlyInitializing {\\n        __Ownable_init_unchained();\\n    }\\n\\n    function __Ownable_init_unchained() internal onlyInitializing {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/finance/PaymentSplitterUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (finance/PaymentSplitter.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../token/ERC20/utils/SafeERC20Upgradeable.sol\\\";\\nimport \\\"../utils/AddressUpgradeable.sol\\\";\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport {Initializable} from \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @title PaymentSplitter\\n * @dev This contract allows to split Ether payments among a group of accounts. The sender does not need to be aware\\n * that the Ether will be split in this way, since it is handled transparently by the contract.\\n *\\n * The split can be in equal parts or in any other arbitrary proportion. The way this is specified is by assigning each\\n * account to a number of shares. Of all the Ether that this contract receives, each account will then be able to claim\\n * an amount proportional to the percentage of total shares they were assigned. The distribution of shares is set at the\\n * time of contract deployment and can't be updated thereafter.\\n *\\n * `PaymentSplitter` follows a _pull payment_ model. This means that payments are not automatically forwarded to the\\n * accounts but kept in this contract, and the actual transfer is triggered as a separate step by calling the {release}\\n * function.\\n *\\n * NOTE: This contract assumes that ERC20 tokens will behave similarly to native tokens (Ether). Rebasing tokens, and\\n * tokens that apply fees during transfers, are likely to not be supported as expected. If in doubt, we encourage you\\n * to run tests before sending real value to this contract.\\n */\\ncontract PaymentSplitterUpgradeable is Initializable, ContextUpgradeable {\\n    event PayeeAdded(address account, uint256 shares);\\n    event PaymentReleased(address to, uint256 amount);\\n    event ERC20PaymentReleased(IERC20Upgradeable indexed token, address to, uint256 amount);\\n    event PaymentReceived(address from, uint256 amount);\\n\\n    uint256 private _totalShares;\\n    uint256 private _totalReleased;\\n\\n    mapping(address => uint256) private _shares;\\n    mapping(address => uint256) private _released;\\n    address[] private _payees;\\n\\n    mapping(IERC20Upgradeable => uint256) private _erc20TotalReleased;\\n    mapping(IERC20Upgradeable => mapping(address => uint256)) private _erc20Released;\\n\\n    /**\\n     * @dev Creates an instance of `PaymentSplitter` where each account in `payees` is assigned the number of shares at\\n     * the matching position in the `shares` array.\\n     *\\n     * All addresses in `payees` must be non-zero. Both arrays must have the same non-zero length, and there must be no\\n     * duplicates in `payees`.\\n     */\\n    function __PaymentSplitter_init(address[] memory payees, uint256[] memory shares_) internal onlyInitializing {\\n        __PaymentSplitter_init_unchained(payees, shares_);\\n    }\\n\\n    function __PaymentSplitter_init_unchained(address[] memory payees, uint256[] memory shares_) internal onlyInitializing {\\n        require(payees.length == shares_.length, \\\"PaymentSplitter: payees and shares length mismatch\\\");\\n        require(payees.length > 0, \\\"PaymentSplitter: no payees\\\");\\n\\n        for (uint256 i = 0; i < payees.length; i++) {\\n            _addPayee(payees[i], shares_[i]);\\n        }\\n    }\\n\\n    /**\\n     * @dev The Ether received will be logged with {PaymentReceived} events. Note that these events are not fully\\n     * reliable: it's possible for a contract to receive Ether without triggering this function. This only affects the\\n     * reliability of the events, and not the actual splitting of Ether.\\n     *\\n     * To learn more about this see the Solidity documentation for\\n     * https://solidity.readthedocs.io/en/latest/contracts.html#fallback-function[fallback\\n     * functions].\\n     */\\n    receive() external payable virtual {\\n        emit PaymentReceived(_msgSender(), msg.value);\\n    }\\n\\n    /**\\n     * @dev Getter for the total shares held by payees.\\n     */\\n    function totalShares() public view returns (uint256) {\\n        return _totalShares;\\n    }\\n\\n    /**\\n     * @dev Getter for the total amount of Ether already released.\\n     */\\n    function totalReleased() public view returns (uint256) {\\n        return _totalReleased;\\n    }\\n\\n    /**\\n     * @dev Getter for the total amount of `token` already released. `token` should be the address of an IERC20\\n     * contract.\\n     */\\n    function totalReleased(IERC20Upgradeable token) public view returns (uint256) {\\n        return _erc20TotalReleased[token];\\n    }\\n\\n    /**\\n     * @dev Getter for the amount of shares held by an account.\\n     */\\n    function shares(address account) public view returns (uint256) {\\n        return _shares[account];\\n    }\\n\\n    /**\\n     * @dev Getter for the amount of Ether already released to a payee.\\n     */\\n    function released(address account) public view returns (uint256) {\\n        return _released[account];\\n    }\\n\\n    /**\\n     * @dev Getter for the amount of `token` tokens already released to a payee. `token` should be the address of an\\n     * IERC20 contract.\\n     */\\n    function released(IERC20Upgradeable token, address account) public view returns (uint256) {\\n        return _erc20Released[token][account];\\n    }\\n\\n    /**\\n     * @dev Getter for the address of the payee number `index`.\\n     */\\n    function payee(uint256 index) public view returns (address) {\\n        return _payees[index];\\n    }\\n\\n    /**\\n     * @dev Getter for the amount of payee's releasable Ether.\\n     */\\n    function releasable(address account) public view returns (uint256) {\\n        uint256 totalReceived = address(this).balance + totalReleased();\\n        return _pendingPayment(account, totalReceived, released(account));\\n    }\\n\\n    /**\\n     * @dev Getter for the amount of payee's releasable `token` tokens. `token` should be the address of an\\n     * IERC20 contract.\\n     */\\n    function releasable(IERC20Upgradeable token, address account) public view returns (uint256) {\\n        uint256 totalReceived = token.balanceOf(address(this)) + totalReleased(token);\\n        return _pendingPayment(account, totalReceived, released(token, account));\\n    }\\n\\n    /**\\n     * @dev Triggers a transfer to `account` of the amount of Ether they are owed, according to their percentage of the\\n     * total shares and their previous withdrawals.\\n     */\\n    function release(address payable account) public virtual {\\n        require(_shares[account] > 0, \\\"PaymentSplitter: account has no shares\\\");\\n\\n        uint256 payment = releasable(account);\\n\\n        require(payment != 0, \\\"PaymentSplitter: account is not due payment\\\");\\n\\n        // _totalReleased is the sum of all values in _released.\\n        // If \\\"_totalReleased += payment\\\" does not overflow, then \\\"_released[account] += payment\\\" cannot overflow.\\n        _totalReleased += payment;\\n        unchecked {\\n            _released[account] += payment;\\n        }\\n\\n        AddressUpgradeable.sendValue(account, payment);\\n        emit PaymentReleased(account, payment);\\n    }\\n\\n    /**\\n     * @dev Triggers a transfer to `account` of the amount of `token` tokens they are owed, according to their\\n     * percentage of the total shares and their previous withdrawals. `token` must be the address of an IERC20\\n     * contract.\\n     */\\n    function release(IERC20Upgradeable token, address account) public virtual {\\n        require(_shares[account] > 0, \\\"PaymentSplitter: account has no shares\\\");\\n\\n        uint256 payment = releasable(token, account);\\n\\n        require(payment != 0, \\\"PaymentSplitter: account is not due payment\\\");\\n\\n        // _erc20TotalReleased[token] is the sum of all values in _erc20Released[token].\\n        // If \\\"_erc20TotalReleased[token] += payment\\\" does not overflow, then \\\"_erc20Released[token][account] += payment\\\"\\n        // cannot overflow.\\n        _erc20TotalReleased[token] += payment;\\n        unchecked {\\n            _erc20Released[token][account] += payment;\\n        }\\n\\n        SafeERC20Upgradeable.safeTransfer(token, account, payment);\\n        emit ERC20PaymentReleased(token, account, payment);\\n    }\\n\\n    /**\\n     * @dev internal logic for computing the pending payment of an `account` given the token historical balances and\\n     * already released amounts.\\n     */\\n    function _pendingPayment(\\n        address account,\\n        uint256 totalReceived,\\n        uint256 alreadyReleased\\n    ) private view returns (uint256) {\\n        return (totalReceived * _shares[account]) / _totalShares - alreadyReleased;\\n    }\\n\\n    /**\\n     * @dev Add a new payee to the contract.\\n     * @param account The address of the payee to add.\\n     * @param shares_ The number of shares owned by the payee.\\n     */\\n    function _addPayee(address account, uint256 shares_) private {\\n        require(account != address(0), \\\"PaymentSplitter: account is the zero address\\\");\\n        require(shares_ > 0, \\\"PaymentSplitter: shares are 0\\\");\\n        require(_shares[account] == 0, \\\"PaymentSplitter: account already has shares\\\");\\n\\n        _payees.push(account);\\n        _shares[account] = shares_;\\n        _totalShares = _totalShares + shares_;\\n        emit PayeeAdded(account, shares_);\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[43] private __gap;\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/interfaces/draft-IERC1822Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\\n * proxy whose upgrades are fully controlled by the current implementation.\\n */\\ninterface IERC1822ProxiableUpgradeable {\\n    /**\\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\\n     * address.\\n     *\\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\\n     * function revert if invoked through a proxy.\\n     */\\n    function proxiableUUID() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/interfaces/IERC1967Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC1967.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev ERC-1967: Proxy Storage Slots. This interface contains the events defined in the ERC.\\n *\\n * _Available since v4.8.3._\\n */\\ninterface IERC1967Upgradeable {\\n    /**\\n     * @dev Emitted when the implementation is upgraded.\\n     */\\n    event Upgraded(address indexed implementation);\\n\\n    /**\\n     * @dev Emitted when the admin account has changed.\\n     */\\n    event AdminChanged(address previousAdmin, address newAdmin);\\n\\n    /**\\n     * @dev Emitted when the beacon is changed.\\n     */\\n    event BeaconUpgraded(address indexed beacon);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/proxy/beacon/IBeaconUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\\n */\\ninterface IBeaconUpgradeable {\\n    /**\\n     * @dev Must return an address that can be used as a delegate call target.\\n     *\\n     * {BeaconProxy} will check that this address is a contract.\\n     */\\n    function implementation() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/proxy/ClonesUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/Clones.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\\n * deploying minimal proxy contracts, also known as \\\"clones\\\".\\n *\\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\\n *\\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\\n * deterministic method.\\n *\\n * _Available since v3.4._\\n */\\nlibrary ClonesUpgradeable {\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create opcode, which should never revert.\\n     */\\n    function clone(address implementation) internal returns (address instance) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\\n            // of the `implementation` address with the bytecode before the address.\\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\\n            instance := create(0, 0x09, 0x37)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create failed\\\");\\n    }\\n\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\\n     * the clones cannot be deployed twice at the same address.\\n     */\\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\\n            // of the `implementation` address with the bytecode before the address.\\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\\n            instance := create2(0, 0x09, 0x37, salt)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create2 failed\\\");\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(\\n        address implementation,\\n        bytes32 salt,\\n        address deployer\\n    ) internal pure returns (address predicted) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(add(ptr, 0x38), deployer)\\n            mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)\\n            mstore(add(ptr, 0x14), implementation)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)\\n            mstore(add(ptr, 0x58), salt)\\n            mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))\\n            predicted := keccak256(add(ptr, 0x43), 0x55)\\n        }\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(\\n        address implementation,\\n        bytes32 salt\\n    ) internal view returns (address predicted) {\\n        return predictDeterministicAddress(implementation, salt, address(this));\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/proxy/ERC1967/ERC1967UpgradeUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/ERC1967/ERC1967Upgrade.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../beacon/IBeaconUpgradeable.sol\\\";\\nimport \\\"../../interfaces/IERC1967Upgradeable.sol\\\";\\nimport \\\"../../interfaces/draft-IERC1822Upgradeable.sol\\\";\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\nimport \\\"../../utils/StorageSlotUpgradeable.sol\\\";\\nimport {Initializable} from \\\"../utils/Initializable.sol\\\";\\n\\n/**\\n * @dev This abstract contract provides getters and event emitting update functions for\\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\\n *\\n * _Available since v4.1._\\n */\\nabstract contract ERC1967UpgradeUpgradeable is Initializable, IERC1967Upgradeable {\\n    // This is the keccak-256 hash of \\\"eip1967.proxy.rollback\\\" subtracted by 1\\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\\n\\n    /**\\n     * @dev Storage slot with the address of the current implementation.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.implementation\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    function __ERC1967Upgrade_init() internal onlyInitializing {\\n    }\\n\\n    function __ERC1967Upgrade_init_unchained() internal onlyInitializing {\\n    }\\n    /**\\n     * @dev Returns the current implementation address.\\n     */\\n    function _getImplementation() internal view returns (address) {\\n        return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 implementation slot.\\n     */\\n    function _setImplementation(address newImplementation) private {\\n        require(AddressUpgradeable.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeTo(address newImplementation) internal {\\n        _setImplementation(newImplementation);\\n        emit Upgraded(newImplementation);\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade with additional setup call.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {\\n        _upgradeTo(newImplementation);\\n        if (data.length > 0 || forceCall) {\\n            AddressUpgradeable.functionDelegateCall(newImplementation, data);\\n        }\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) internal {\\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\\n        if (StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT).value) {\\n            _setImplementation(newImplementation);\\n        } else {\\n            try IERC1822ProxiableUpgradeable(newImplementation).proxiableUUID() returns (bytes32 slot) {\\n                require(slot == _IMPLEMENTATION_SLOT, \\\"ERC1967Upgrade: unsupported proxiableUUID\\\");\\n            } catch {\\n                revert(\\\"ERC1967Upgrade: new implementation is not UUPS\\\");\\n            }\\n            _upgradeToAndCall(newImplementation, data, forceCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Storage slot with the admin of the contract.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.admin\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n    /**\\n     * @dev Returns the current admin.\\n     */\\n    function _getAdmin() internal view returns (address) {\\n        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 admin slot.\\n     */\\n    function _setAdmin(address newAdmin) private {\\n        require(newAdmin != address(0), \\\"ERC1967: new admin is the zero address\\\");\\n        StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\\n    }\\n\\n    /**\\n     * @dev Changes the admin of the proxy.\\n     *\\n     * Emits an {AdminChanged} event.\\n     */\\n    function _changeAdmin(address newAdmin) internal {\\n        emit AdminChanged(_getAdmin(), newAdmin);\\n        _setAdmin(newAdmin);\\n    }\\n\\n    /**\\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\\n     */\\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\\n\\n    /**\\n     * @dev Returns the current beacon.\\n     */\\n    function _getBeacon() internal view returns (address) {\\n        return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\\n     */\\n    function _setBeacon(address newBeacon) private {\\n        require(AddressUpgradeable.isContract(newBeacon), \\\"ERC1967: new beacon is not a contract\\\");\\n        require(\\n            AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),\\n            \\\"ERC1967: beacon implementation is not a contract\\\"\\n        );\\n        StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;\\n    }\\n\\n    /**\\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\\n     *\\n     * Emits a {BeaconUpgraded} event.\\n     */\\n    function _upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {\\n        _setBeacon(newBeacon);\\n        emit BeaconUpgraded(newBeacon);\\n        if (data.length > 0 || forceCall) {\\n            AddressUpgradeable.functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);\\n        }\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```solidity\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n *\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     * @custom:oz-retyped-from bool\\n     */\\n    uint8 private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint8 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts.\\n     *\\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\\n     * constructor.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier initializer() {\\n        bool isTopLevelCall = !_initializing;\\n        require(\\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\\n            \\\"Initializable: contract is already initialized\\\"\\n        );\\n        _initialized = 1;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\\n     * are added through upgrades and that require initialization.\\n     *\\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     *\\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier reinitializer(uint8 version) {\\n        require(!_initializing && _initialized < version, \\\"Initializable: contract is already initialized\\\");\\n        _initialized = version;\\n        _initializing = true;\\n        _;\\n        _initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     *\\n     * Emits an {Initialized} event the first time it is successfully executed.\\n     */\\n    function _disableInitializers() internal virtual {\\n        require(!_initializing, \\\"Initializable: contract is initializing\\\");\\n        if (_initialized != type(uint8).max) {\\n            _initialized = type(uint8).max;\\n            emit Initialized(type(uint8).max);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\\n     */\\n    function _getInitializedVersion() internal view returns (uint8) {\\n        return _initialized;\\n    }\\n\\n    /**\\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\\n     */\\n    function _isInitializing() internal view returns (bool) {\\n        return _initializing;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/proxy/utils/UUPSUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/UUPSUpgradeable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../interfaces/draft-IERC1822Upgradeable.sol\\\";\\nimport \\\"../ERC1967/ERC1967UpgradeUpgradeable.sol\\\";\\nimport {Initializable} from \\\"./Initializable.sol\\\";\\n\\n/**\\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\\n *\\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\\n * `UUPSUpgradeable` with a custom implementation of upgrades.\\n *\\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\\n *\\n * _Available since v4.1._\\n */\\nabstract contract UUPSUpgradeable is Initializable, IERC1822ProxiableUpgradeable, ERC1967UpgradeUpgradeable {\\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\\n    address private immutable __self = address(this);\\n\\n    /**\\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\\n     * fail.\\n     */\\n    modifier onlyProxy() {\\n        require(address(this) != __self, \\\"Function must be called through delegatecall\\\");\\n        require(_getImplementation() == __self, \\\"Function must be called through active proxy\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\\n     * callable on the implementing contract but not through proxies.\\n     */\\n    modifier notDelegated() {\\n        require(address(this) == __self, \\\"UUPSUpgradeable: must not be called through delegatecall\\\");\\n        _;\\n    }\\n\\n    function __UUPSUpgradeable_init() internal onlyInitializing {\\n    }\\n\\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\\n    }\\n    /**\\n     * @dev Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the\\n     * implementation. It is used to validate the implementation's compatibility when performing an upgrade.\\n     *\\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\\n     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\\n     */\\n    function proxiableUUID() external view virtual override notDelegated returns (bytes32) {\\n        return _IMPLEMENTATION_SLOT;\\n    }\\n\\n    /**\\n     * @dev Upgrade the implementation of the proxy to `newImplementation`.\\n     *\\n     * Calls {_authorizeUpgrade}.\\n     *\\n     * Emits an {Upgraded} event.\\n     *\\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\\n     */\\n    function upgradeTo(address newImplementation) public virtual onlyProxy {\\n        _authorizeUpgrade(newImplementation);\\n        _upgradeToAndCallUUPS(newImplementation, new bytes(0), false);\\n    }\\n\\n    /**\\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\\n     * encoded in `data`.\\n     *\\n     * Calls {_authorizeUpgrade}.\\n     *\\n     * Emits an {Upgraded} event.\\n     *\\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\\n     */\\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\\n        _authorizeUpgrade(newImplementation);\\n        _upgradeToAndCallUUPS(newImplementation, data, true);\\n    }\\n\\n    /**\\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\\n     * {upgradeTo} and {upgradeToAndCall}.\\n     *\\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\\n     *\\n     * ```solidity\\n     * function _authorizeUpgrade(address) internal override onlyOwner {}\\n     * ```\\n     */\\n    function _authorizeUpgrade(address newImplementation) internal virtual;\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/token/ERC20/extensions/IERC20PermitUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.4) (token/ERC20/extensions/IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n *\\n * ==== Security Considerations\\n *\\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\\n * generally recommended is:\\n *\\n * ```solidity\\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\\n *     doThing(..., value);\\n * }\\n *\\n * function doThing(..., uint256 value) public {\\n *     token.safeTransferFrom(msg.sender, address(this), value);\\n *     ...\\n * }\\n * ```\\n *\\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\\n * {SafeERC20-safeTransferFrom}).\\n *\\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\\n * contracts should have entry points that don't rely on permit.\\n */\\ninterface IERC20PermitUpgradeable {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     *\\n     * CAUTION: See Security Considerations above.\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20Upgradeable {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/token/ERC20/utils/SafeERC20Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20Upgradeable.sol\\\";\\nimport \\\"../extensions/IERC20PermitUpgradeable.sol\\\";\\nimport \\\"../../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20Upgradeable {\\n    using AddressUpgradeable for address;\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransfer(IERC20Upgradeable token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransferFrom(IERC20Upgradeable token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    /**\\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeIncreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\\n        uint256 oldAllowance = token.allowance(address(this), spender);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\\n    }\\n\\n    /**\\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeDecreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\\n        }\\n    }\\n\\n    /**\\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\\n     * to be set to zero before setting it to a non-zero value, such as USDT.\\n     */\\n    function forceApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\\n\\n        if (!_callOptionalReturnBool(token, approvalCall)) {\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\\n            _callOptionalReturn(token, approvalCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\\n     * Revert on invalid signature.\\n     */\\n    function safePermit(\\n        IERC20PermitUpgradeable token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     *\\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\\n     */\\n    function _callOptionalReturnBool(IERC20Upgradeable token, bytes memory data) private returns (bool) {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\\n        // and not revert is the subcall reverts.\\n\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        return\\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && AddressUpgradeable.isContract(address(token));\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/token/ERC721/extensions/IERC721MetadataUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721Upgradeable.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721MetadataUpgradeable is IERC721Upgradeable {\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/token/ERC721/IERC721Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165Upgradeable.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721Upgradeable is IERC165Upgradeable {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/utils/AddressUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     *\\n     * Furthermore, `isContract` will also return true if the target contract within\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\n     * which only has an effect at the end of a transaction.\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/utils/ContextUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.4) (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\nimport {Initializable} from \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal onlyInitializing {\\n    }\\n\\n    function __Context_init_unchained() internal onlyInitializing {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    function _contextSuffixLength() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/utils/introspection/ERC165Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165Upgradeable.sol\\\";\\nimport {Initializable} from \\\"../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\\n    function __ERC165_init() internal onlyInitializing {\\n    }\\n\\n    function __ERC165_init_unchained() internal onlyInitializing {\\n    }\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/utils/introspection/IERC165Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165Upgradeable {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/utils/StorageSlotUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/StorageSlot.sol)\\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for reading and writing primitive types to specific storage slots.\\n *\\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\\n * This library helps with reading and writing to such slots without the need for inline assembly.\\n *\\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\\n *\\n * Example usage to set ERC1967 implementation slot:\\n * ```solidity\\n * contract ERC1967 {\\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n *\\n *     function _getImplementation() internal view returns (address) {\\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n *     }\\n *\\n *     function _setImplementation(address newImplementation) internal {\\n *         require(Address.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n *     }\\n * }\\n * ```\\n *\\n * _Available since v4.1 for `address`, `bool`, `bytes32`, `uint256`._\\n * _Available since v4.9 for `string`, `bytes`._\\n */\\nlibrary StorageSlotUpgradeable {\\n    struct AddressSlot {\\n        address value;\\n    }\\n\\n    struct BooleanSlot {\\n        bool value;\\n    }\\n\\n    struct Bytes32Slot {\\n        bytes32 value;\\n    }\\n\\n    struct Uint256Slot {\\n        uint256 value;\\n    }\\n\\n    struct StringSlot {\\n        string value;\\n    }\\n\\n    struct BytesSlot {\\n        bytes value;\\n    }\\n\\n    /**\\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\\n     */\\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\\n     */\\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\\n     */\\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\\n     */\\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\\n     */\\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\\n     */\\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := store.slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\\n     */\\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\\n     */\\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := store.slot\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/proxy/beacon/IBeacon.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/beacon/IBeacon.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\\n */\\ninterface IBeacon {\\n    /**\\n     * @dev Must return an address that can be used as a delegate call target.\\n     *\\n     * {UpgradeableBeacon} will check that this address is a contract.\\n     */\\n    function implementation() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/proxy/ERC1967/ERC1967Proxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/ERC1967/ERC1967Proxy.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Proxy} from \\\"../Proxy.sol\\\";\\nimport {ERC1967Utils} from \\\"./ERC1967Utils.sol\\\";\\n\\n/**\\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\\n * implementation address that can be changed. This address is stored in storage in the location specified by\\n * https://eips.ethereum.org/EIPS/eip-1967[ERC-1967], so that it doesn't conflict with the storage layout of the\\n * implementation behind the proxy.\\n */\\ncontract ERC1967Proxy is Proxy {\\n    /**\\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `implementation`.\\n     *\\n     * If `_data` is nonempty, it's used as data in a delegate call to `implementation`. This will typically be an\\n     * encoded function call, and allows initializing the storage of the proxy like a Solidity constructor.\\n     *\\n     * Requirements:\\n     *\\n     * - If `data` is empty, `msg.value` must be zero.\\n     */\\n    constructor(address implementation, bytes memory _data) payable {\\n        ERC1967Utils.upgradeToAndCall(implementation, _data);\\n    }\\n\\n    /**\\n     * @dev Returns the current implementation address.\\n     *\\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by ERC-1967) using\\n     * the https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\\n     */\\n    function _implementation() internal view virtual override returns (address) {\\n        return ERC1967Utils.getImplementation();\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/proxy/ERC1967/ERC1967Utils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/ERC1967/ERC1967Utils.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IBeacon} from \\\"../beacon/IBeacon.sol\\\";\\nimport {Address} from \\\"../../utils/Address.sol\\\";\\nimport {StorageSlot} from \\\"../../utils/StorageSlot.sol\\\";\\n\\n/**\\n * @dev This abstract contract provides getters and event emitting update functions for\\n * https://eips.ethereum.org/EIPS/eip-1967[ERC-1967] slots.\\n */\\nlibrary ERC1967Utils {\\n    // We re-declare ERC-1967 events here because they can't be used directly from IERC1967.\\n    // This will be fixed in Solidity 0.8.21. At that point we should remove these events.\\n    /**\\n     * @dev Emitted when the implementation is upgraded.\\n     */\\n    event Upgraded(address indexed implementation);\\n\\n    /**\\n     * @dev Emitted when the admin account has changed.\\n     */\\n    event AdminChanged(address previousAdmin, address newAdmin);\\n\\n    /**\\n     * @dev Emitted when the beacon is changed.\\n     */\\n    event BeaconUpgraded(address indexed beacon);\\n\\n    /**\\n     * @dev Storage slot with the address of the current implementation.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.implementation\\\" subtracted by 1.\\n     */\\n    // solhint-disable-next-line private-vars-leading-underscore\\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    /**\\n     * @dev The `implementation` of the proxy is invalid.\\n     */\\n    error ERC1967InvalidImplementation(address implementation);\\n\\n    /**\\n     * @dev The `admin` of the proxy is invalid.\\n     */\\n    error ERC1967InvalidAdmin(address admin);\\n\\n    /**\\n     * @dev The `beacon` of the proxy is invalid.\\n     */\\n    error ERC1967InvalidBeacon(address beacon);\\n\\n    /**\\n     * @dev An upgrade function sees `msg.value > 0` that may be lost.\\n     */\\n    error ERC1967NonPayable();\\n\\n    /**\\n     * @dev Returns the current implementation address.\\n     */\\n    function getImplementation() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the ERC-1967 implementation slot.\\n     */\\n    function _setImplementation(address newImplementation) private {\\n        if (newImplementation.code.length == 0) {\\n            revert ERC1967InvalidImplementation(newImplementation);\\n        }\\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\\n    }\\n\\n    /**\\n     * @dev Performs implementation upgrade with additional setup call if data is nonempty.\\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\\n     * to avoid stuck value in the contract.\\n     *\\n     * Emits an {IERC1967-Upgraded} event.\\n     */\\n    function upgradeToAndCall(address newImplementation, bytes memory data) internal {\\n        _setImplementation(newImplementation);\\n        emit Upgraded(newImplementation);\\n\\n        if (data.length > 0) {\\n            Address.functionDelegateCall(newImplementation, data);\\n        } else {\\n            _checkNonPayable();\\n        }\\n    }\\n\\n    /**\\n     * @dev Storage slot with the admin of the contract.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.admin\\\" subtracted by 1.\\n     */\\n    // solhint-disable-next-line private-vars-leading-underscore\\n    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n    /**\\n     * @dev Returns the current admin.\\n     *\\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by ERC-1967) using\\n     * the https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\\n     */\\n    function getAdmin() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the ERC-1967 admin slot.\\n     */\\n    function _setAdmin(address newAdmin) private {\\n        if (newAdmin == address(0)) {\\n            revert ERC1967InvalidAdmin(address(0));\\n        }\\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;\\n    }\\n\\n    /**\\n     * @dev Changes the admin of the proxy.\\n     *\\n     * Emits an {IERC1967-AdminChanged} event.\\n     */\\n    function changeAdmin(address newAdmin) internal {\\n        emit AdminChanged(getAdmin(), newAdmin);\\n        _setAdmin(newAdmin);\\n    }\\n\\n    /**\\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.beacon\\\" subtracted by 1.\\n     */\\n    // solhint-disable-next-line private-vars-leading-underscore\\n    bytes32 internal constant BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\\n\\n    /**\\n     * @dev Returns the current beacon.\\n     */\\n    function getBeacon() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(BEACON_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new beacon in the ERC-1967 beacon slot.\\n     */\\n    function _setBeacon(address newBeacon) private {\\n        if (newBeacon.code.length == 0) {\\n            revert ERC1967InvalidBeacon(newBeacon);\\n        }\\n\\n        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;\\n\\n        address beaconImplementation = IBeacon(newBeacon).implementation();\\n        if (beaconImplementation.code.length == 0) {\\n            revert ERC1967InvalidImplementation(beaconImplementation);\\n        }\\n    }\\n\\n    /**\\n     * @dev Change the beacon and trigger a setup call if data is nonempty.\\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\\n     * to avoid stuck value in the contract.\\n     *\\n     * Emits an {IERC1967-BeaconUpgraded} event.\\n     *\\n     * CAUTION: Invoking this function has no effect on an instance of {BeaconProxy} since v5, since\\n     * it uses an immutable beacon without looking at the value of the ERC-1967 beacon slot for\\n     * efficiency.\\n     */\\n    function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {\\n        _setBeacon(newBeacon);\\n        emit BeaconUpgraded(newBeacon);\\n\\n        if (data.length > 0) {\\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\\n        } else {\\n            _checkNonPayable();\\n        }\\n    }\\n\\n    /**\\n     * @dev Reverts if `msg.value` is not zero. It can be used to avoid `msg.value` stuck in the contract\\n     * if an upgrade doesn't perform an initialization call.\\n     */\\n    function _checkNonPayable() private {\\n        if (msg.value > 0) {\\n            revert ERC1967NonPayable();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/proxy/Proxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/Proxy.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\\n * be specified by overriding the virtual {_implementation} function.\\n *\\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\\n * different contract through the {_delegate} function.\\n *\\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\\n */\\nabstract contract Proxy {\\n    /**\\n     * @dev Delegates the current call to `implementation`.\\n     *\\n     * This function does not return to its internal call site, it will return directly to the external caller.\\n     */\\n    function _delegate(address implementation) internal virtual {\\n        assembly {\\n            // Copy msg.data. We take full control of memory in this inline assembly\\n            // block because it will not return to Solidity code. We overwrite the\\n            // Solidity scratch pad at memory position 0.\\n            calldatacopy(0, 0, calldatasize())\\n\\n            // Call the implementation.\\n            // out and outsize are 0 because we don't know the size yet.\\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\\n\\n            // Copy the returned data.\\n            returndatacopy(0, 0, returndatasize())\\n\\n            switch result\\n            // delegatecall returns 0 on error.\\n            case 0 {\\n                revert(0, returndatasize())\\n            }\\n            default {\\n                return(0, returndatasize())\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback\\n     * function and {_fallback} should delegate.\\n     */\\n    function _implementation() internal view virtual returns (address);\\n\\n    /**\\n     * @dev Delegates the current call to the address returned by `_implementation()`.\\n     *\\n     * This function does not return to its internal call site, it will return directly to the external caller.\\n     */\\n    function _fallback() internal virtual {\\n        _delegate(_implementation());\\n    }\\n\\n    /**\\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\\n     * function in the contract matches the call data.\\n     */\\n    fallback() external payable virtual {\\n        _fallback();\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev The ETH balance of the account is not enough to perform the operation.\\n     */\\n    error AddressInsufficientBalance(address account);\\n\\n    /**\\n     * @dev There's no code at `target` (it is not a contract).\\n     */\\n    error AddressEmptyCode(address target);\\n\\n    /**\\n     * @dev A call to an address target failed. The target may have reverted.\\n     */\\n    error FailedInnerCall();\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        if (address(this).balance < amount) {\\n            revert AddressInsufficientBalance(address(this));\\n        }\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        if (!success) {\\n            revert FailedInnerCall();\\n        }\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason or custom error, it is bubbled\\n     * up by this function (like regular Solidity function calls). However, if\\n     * the call reverted with no returned reason, this function reverts with a\\n     * {FailedInnerCall} error.\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        if (address(this).balance < value) {\\n            revert AddressInsufficientBalance(address(this));\\n        }\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\\n     * unsuccessful call.\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata\\n    ) internal view returns (bytes memory) {\\n        if (!success) {\\n            _revert(returndata);\\n        } else {\\n            // only check if target is a contract if the call was successful and the return data is empty\\n            // otherwise we already know that it was a contract\\n            if (returndata.length == 0 && target.code.length == 0) {\\n                revert AddressEmptyCode(target);\\n            }\\n            return returndata;\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\\n     * revert reason or with a default {FailedInnerCall} error.\\n     */\\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\\n        if (!success) {\\n            _revert(returndata);\\n        } else {\\n            return returndata;\\n        }\\n    }\\n\\n    /**\\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\\n     */\\n    function _revert(bytes memory returndata) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert FailedInnerCall();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/StorageSlot.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/StorageSlot.sol)\\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Library for reading and writing primitive types to specific storage slots.\\n *\\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\\n * This library helps with reading and writing to such slots without the need for inline assembly.\\n *\\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\\n *\\n * Example usage to set ERC-1967 implementation slot:\\n * ```solidity\\n * contract ERC1967 {\\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n *\\n *     function _getImplementation() internal view returns (address) {\\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n *     }\\n *\\n *     function _setImplementation(address newImplementation) internal {\\n *         require(newImplementation.code.length > 0);\\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n *     }\\n * }\\n * ```\\n */\\nlibrary StorageSlot {\\n    struct AddressSlot {\\n        address value;\\n    }\\n\\n    struct BooleanSlot {\\n        bool value;\\n    }\\n\\n    struct Bytes32Slot {\\n        bytes32 value;\\n    }\\n\\n    struct Uint256Slot {\\n        uint256 value;\\n    }\\n\\n    struct StringSlot {\\n        string value;\\n    }\\n\\n    struct BytesSlot {\\n        bytes value;\\n    }\\n\\n    /**\\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\\n     */\\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\\n     */\\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\\n     */\\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\\n     */\\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\\n     */\\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\\n     */\\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := store.slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\\n     */\\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\\n     */\\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := store.slot\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/CustomPaymentSplitter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.20;\\n\\nimport {PaymentSplitterUpgradeable} from\\n    \\\"../lib/openzeppelin-contracts-upgradeable/contracts/finance/PaymentSplitterUpgradeable.sol\\\";\\n\\n/// @title   CustomPaymentSplitter - Payment Splitter with initializer\\n/// @author  Jonas Lekevicius\\n/// @dev     This is a non-abstract version of the OpenZeppelin Contract `PaymentSplitterUpgradeable` contract that\\n///          implements an initializer, and has a constructor to disable the initializer on base deployment. Meant to be\\n///          used as an implementation to a EIP-1167 clone factory. This contract is not actually upgradeable despite\\n///          the name of the base contract.\\n/// @custom:security-contact security@orb.land\\ncontract PaymentSplitter is PaymentSplitterUpgradeable {\\n    /// @custom:oz-upgrades-unsafe-allow constructor\\n    constructor() {\\n        _disableInitializers();\\n    }\\n\\n    /// @dev    Calls the initializer of the `PaymentSplitterUpgradeable` contract, with payees and their shares.\\n    /// @param  payees_   Payees addresses.\\n    /// @param  shares_   Payees shares.\\n    function initialize(address[] memory payees_, uint256[] memory shares_) public initializer {\\n        __PaymentSplitter_init(payees_, shares_);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/CustomUUPSUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.20;\\n\\nimport {IERC1822ProxiableUpgradeable} from\\n    \\\"../lib/openzeppelin-contracts-upgradeable/contracts/interfaces/draft-IERC1822Upgradeable.sol\\\";\\nimport {ERC1967UpgradeUpgradeable} from\\n    \\\"../lib/openzeppelin-contracts-upgradeable/contracts/proxy/ERC1967/ERC1967UpgradeUpgradeable.sol\\\";\\n\\n// solhint-disable func-name-mixedcase\\n\\n/// @title   CustomUUPSUpgradeable - UUPSUpgradeable without public functions\\n/// @author  Jonas Lekevicius\\n/// @dev     An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade\\n///          of an `ERC1967Proxy`, when this contract is set as the implementation behind such a proxy. This is a\\n///          modified version of the OpenZeppelin Contract `UUPSUpgradeable` contract that does not expose any public\\n///          functions, to allow custom upgradeability logic to be implemented in the `Orb` contract.\\n///          Also, replaces string errors with custom errors.\\n/// @custom:security-contact security@orb.land\\nabstract contract UUPSUpgradeable is IERC1822ProxiableUpgradeable, ERC1967UpgradeUpgradeable {\\n    // Errors\\n    error RequiresCallViaDelegatecall();\\n    error RequiresCallViaActiveProxy();\\n    error CallViaDelegatecallDisallowed();\\n\\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\\n    address private immutable __self = address(this);\\n\\n    // solhint-disable-next-line no-empty-blocks\\n    function __UUPSUpgradeable_init() internal onlyInitializing {}\\n\\n    // solhint-disable-next-line no-empty-blocks\\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {}\\n\\n    /// @dev  Check that the execution is being performed through a delegatecall call and that the execution context is\\n    ///       a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the\\n    ///       case for UUPS and transparent proxies that are using the current contract as their implementation.\\n    ///       Execution of a function through ERC1167 minimal proxies (clones) would not normally pass this test, but is\\n    ///       not guaranteed to fail.\\n    modifier onlyProxy() {\\n        if (address(this) == __self) {\\n            revert RequiresCallViaDelegatecall();\\n        }\\n        if (_getImplementation() != __self) {\\n            revert RequiresCallViaActiveProxy();\\n        }\\n        _;\\n    }\\n\\n    /// @dev  Check that the execution is not being performed through a delegate call. This allows a function to be\\n    ///       on the implementing contract but not through proxies.\\n    modifier notDelegated() {\\n        if (address(this) != __self) {\\n            revert CallViaDelegatecallDisallowed();\\n        }\\n        _;\\n    }\\n\\n    /// @dev  Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the\\n    ///       implementation. It is used to validate the implementation's compatibility when performing an upgrade.\\n    ///       IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because\\n    ///       this risks bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is\\n    ///       critical that this function revert if invoked through a proxy. This is guaranteed by the `notDelegated`\\n    ///       modifier.\\n    function proxiableUUID() external view virtual override notDelegated returns (bytes32) {\\n        return _IMPLEMENTATION_SLOT;\\n    }\\n\\n    /// @dev  This empty reserved space is put in place to allow future versions to add new variables without shifting\\n    ///       down storage in the inheritance chain.\\n    ///       See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"src/IOwnershipTransferrable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.20;\\n\\ninterface IOwnershipTransferrable {\\n    function transferOwnership(address newOwner) external;\\n}\\n\"\r\n    },\r\n    \"src/Orb.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\\n.                                                                                                                      .\\n.                                                                                                                      .\\n.                                             ./         (@@@@@@@@@@@@@@@@@,                                           .\\n.                                        &@@@@       /@@@@&.        *&@@@@@@@@@@*                                      .\\n.                                    %@@@@@@.      (@@@                  &@@@@@@@@@&                                   .\\n.                                 .@@@@@@@@       @@@                      ,@@@@@@@@@@/                                .\\n.                               *@@@@@@@@@       (@%                         &@@@@@@@@@@/                              .\\n.                              @@@@@@@@@@/       @@                           (@@@@@@@@@@@                             .\\n.                             @@@@@@@@@@@        &@                            %@@@@@@@@@@@                            .\\n.                            @@@@@@@@@@@#         @                             @@@@@@@@@@@@                           .\\n.                           #@@@@@@@@@@@.                                       /@@@@@@@@@@@@                          .\\n.                           @@@@@@@@@@@@                                         @@@@@@@@@@@@                          .\\n.                           @@@@@@@@@@@@                                         @@@@@@@@@@@@                          .\\n.                           @@@@@@@@@@@@.                                        @@@@@@@@@@@@                          .\\n.                           @@@@@@@@@@@@%                                       ,@@@@@@@@@@@@                          .\\n.                           ,@@@@@@@@@@@@                                       @@@@@@@@@@@@/                          .\\n.                            %@@@@@@@@@@@&                                     .@@@@@@@@@@@@                           .\\n.                             #@@@@@@@@@@@#                                    @@@@@@@@@@@&                            .\\n.                              .@@@@@@@@@@@&                                 ,@@@@@@@@@@@,                             .\\n.                                *@@@@@@@@@@@,                              @@@@@@@@@@@#                               .\\n.                                   @@@@@@@@@@@*                          @@@@@@@@@@@.                                 .\\n.                                     .&@@@@@@@@@@*                   .@@@@@@@@@@@.                                    .\\n.                                          &@@@@@@@@@@@%*..   ..,#@@@@@@@@@@@@@*                                       .\\n.                                        ,@@@@   ,#&@@@@@@@@@@@@@@@@@@#*     &@@@#                                     .\\n.                                       @@@@@                                 #@@@@.                                   .\\n.                                      @@@@@*                                  @@@@@,                                  .\\n.                                     @@@@@@@(                               .@@@@@@@                                  .\\n.                                     (@@@@@@@@@@@@@@%/*,.       ..,/#@@@@@@@@@@@@@@@                                  .\\n.                                        #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@%                                     .\\n.                                                ./%@@@@@@@@@@@@@@@@@@@%/,                                             .\\n.                                                                                                                      .\\n.                                                                                                                      .\\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\\npragma solidity 0.8.20;\\n\\nimport {IERC165Upgradeable} from\\n    \\\"../lib/openzeppelin-contracts-upgradeable/contracts/utils/introspection/IERC165Upgradeable.sol\\\";\\nimport {ERC165Upgradeable} from\\n    \\\"../lib/openzeppelin-contracts-upgradeable/contracts/utils/introspection/ERC165Upgradeable.sol\\\";\\nimport {IERC721Upgradeable} from\\n    \\\"../lib/openzeppelin-contracts-upgradeable/contracts/token/ERC721/IERC721Upgradeable.sol\\\";\\nimport {IERC721MetadataUpgradeable} from\\n    \\\"../lib/openzeppelin-contracts-upgradeable/contracts/token/ERC721/extensions/IERC721MetadataUpgradeable.sol\\\";\\nimport {OwnableUpgradeable} from \\\"../lib/openzeppelin-contracts-upgradeable/contracts/access/OwnableUpgradeable.sol\\\";\\nimport {AddressUpgradeable} from \\\"../lib/openzeppelin-contracts-upgradeable/contracts/utils/AddressUpgradeable.sol\\\";\\n\\nimport {UUPSUpgradeable} from \\\"./CustomUUPSUpgradeable.sol\\\";\\nimport {OrbPond} from \\\"./OrbPond.sol\\\";\\n\\n/// @title   Orb - Oath-honored, Harberger-taxed NFT with built-in auction and on-chain invocations\\n/// @author  Jonas Lekevicius\\n/// @author  Eric Wall\\n/// @notice  The Orb is issued by a Creator: the user who swore an Orb Oath together with a date until which the Oath\\n///          will be honored. The Creator can list the Orb for sale at a fixed price, or run an auction for it. The user\\n///          acquiring the Orb is known as the Keeper. The Keeper always has an Orb sale price set and is paying\\n///          Harberger tax based on their set price and a tax rate set by the Creator. This tax is accounted for per\\n///          second, and the Keeper must have enough funds on this contract to cover their ownership; otherwise the Orb\\n///          is re-auctioned, delivering most of the auction proceeds to the previous Keeper. The Orb also has a\\n///          cooldown that allows the Keeper to invoke the Orb \u2014 ask the Creator a question and receive their response,\\n///          based on conditions set in the Orb Oath. Invocation and response hashes and timestamps are tracked in an\\n///          Orb Invocation Registry.\\n/// @dev     Supports ERC-721 interface, including metadata, but reverts on all transfers and approvals. Uses\\n///          `Ownable`'s `owner()` to identify the Creator of the Orb. Uses a custom `UUPSUpgradeable` implementation to\\n///          allow upgrades, if they are requested by the Creator and executed by the Keeper. The Orb is created as an\\n///          ERC-1967 proxy to an `Orb` implementation by the `OrbPond` contract, which is also used to track allowed\\n///          Orb upgrades and keeps a reference to an `OrbInvocationRegistry` used by this Orb.\\n/// @custom:security-contact security@orb.land\\ncontract Orb is IERC721MetadataUpgradeable, ERC165Upgradeable, OwnableUpgradeable, UUPSUpgradeable {\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n    //  EVENTS\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n    event Creation();\\n\\n    // Auction Events\\n    event AuctionStart(\\n        uint256 indexed auctionStartTime, uint256 indexed auctionEndTime, address indexed auctionBeneficiary\\n    );\\n    event AuctionBid(address indexed bidder, uint256 indexed bid);\\n    event AuctionExtension(uint256 indexed newAuctionEndTime);\\n    event AuctionFinalization(address indexed winner, uint256 indexed winningBid);\\n\\n    // Funding Events\\n    event Deposit(address indexed depositor, uint256 indexed amount);\\n    event Withdrawal(address indexed recipient, uint256 indexed amount);\\n    event Settlement(address indexed keeper, address indexed beneficiary, uint256 indexed amount);\\n\\n    // Purchasing Events\\n    event PriceUpdate(uint256 previousPrice, uint256 indexed newPrice);\\n    event Purchase(address indexed seller, address indexed buyer, uint256 indexed price);\\n\\n    // Orb Ownership Events\\n    event Foreclosure(address indexed formerKeeper);\\n    event Relinquishment(address indexed formerKeeper);\\n\\n    // Orb Parameter Events\\n    event OathSwearing(bytes32 indexed oathHash, uint256 indexed honoredUntil, uint256 indexed responsePeriod);\\n    event HonoredUntilUpdate(uint256 previousHonoredUntil, uint256 indexed newHonoredUntil);\\n    event AuctionParametersUpdate(\\n        uint256 previousStartingPrice,\\n        uint256 indexed newStartingPrice,\\n        uint256 previousMinimumBidStep,\\n        uint256 indexed newMinimumBidStep,\\n        uint256 previousMinimumDuration,\\n        uint256 indexed newMinimumDuration,\\n        uint256 previousKeeperMinimumDuration,\\n        uint256 newKeeperMinimumDuration,\\n        uint256 previousBidExtension,\\n        uint256 newBidExtension\\n    );\\n    event FeesUpdate(\\n        uint256 previousKeeperTaxNumerator,\\n        uint256 indexed newKeeperTaxNumerator,\\n        uint256 previousRoyaltyNumerator,\\n        uint256 indexed newRoyaltyNumerator\\n    );\\n    event CooldownUpdate(\\n        uint256 previousCooldown,\\n        uint256 indexed newCooldown,\\n        uint256 previousFlaggingPeriod,\\n        uint256 indexed newFlaggingPeriod\\n    );\\n    event CleartextMaximumLengthUpdate(\\n        uint256 previousCleartextMaximumLength, uint256 indexed newCleartextMaximumLength\\n    );\\n\\n    // Upgrading Events\\n    event UpgradeRequest(address indexed requestedImplementation);\\n\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n    //  ERRORS\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n    // ERC-721 Errors\\n    error NotSupported();\\n\\n    // Authorization Errors\\n    error NotPermitted();\\n    error AlreadyKeeper();\\n    error NotKeeper();\\n    error ContractHoldsOrb();\\n    error ContractDoesNotHoldOrb();\\n    error CreatorDoesNotControlOrb();\\n\\n    // Auction Errors\\n    error AuctionNotRunning();\\n    error AuctionRunning();\\n    error AuctionNotStarted();\\n    error NotPermittedForLeadingBidder();\\n    error InsufficientBid(uint256 bidProvided, uint256 bidRequired);\\n\\n    // Funding Errors\\n    error KeeperSolvent();\\n    error KeeperInsolvent();\\n    error InsufficientFunds(uint256 fundsAvailable, uint256 fundsRequired);\\n\\n    // Purchasing Errors\\n    error CurrentValueIncorrect(uint256 valueProvided, uint256 currentValue);\\n    error PurchasingNotPermitted();\\n    error InvalidNewPrice(uint256 priceProvided);\\n\\n    // Orb Parameter Errors\\n    error HonoredUntilNotDecreasable();\\n    error InvalidAuctionDuration(uint256 auctionDuration);\\n    error RoyaltyNumeratorExceedsDenominator(uint256 royaltyNumerator, uint256 feeDenominator);\\n    error CooldownExceedsMaximumDuration(uint256 cooldown, uint256 cooldownMaximumDuration);\\n    error InvalidCleartextMaximumLength(uint256 cleartextMaximumLength);\\n\\n    // Upgradding Errors\\n    error NoUpgradeRequested();\\n    error NotNextVersion();\\n\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n    //  STORAGE\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n    // CONSTANTS\\n\\n    /// Orb version. Value: 1.\\n    uint256 private constant _VERSION = 1;\\n    /// Fee Nominator: basis points (100.00%). Other fees are in relation to this, and formatted as such.\\n    uint256 internal constant _FEE_DENOMINATOR = 100_00;\\n    /// Harberger tax period: for how long the tax rate applies. Value: 1 year.\\n    uint256 internal constant _KEEPER_TAX_PERIOD = 365 days;\\n    /// Maximum cooldown duration, to prevent potential underflows. Value: 10 years.\\n    uint256 internal constant _COOLDOWN_MAXIMUM_DURATION = 3650 days;\\n    /// Maximum Orb price, limited to prevent potential overflows.\\n    uint256 internal constant _MAXIMUM_PRICE = 2 ** 128;\\n    /// Token ID of the Orb. Value: 1.\\n    uint256 internal constant _TOKEN_ID = 1;\\n\\n    // STATE\\n\\n    // Address Variables\\n\\n    /// Address of the `OrbPond` that deployed this Orb. Pond manages permitted upgrades and provides Orb Invocation\\n    /// Registry address.\\n    address public pond;\\n    /// Beneficiary is another address that receives all Orb proceeds. It is set in the `initializer` as an immutable\\n    /// value. Beneficiary is not allowed to bid in the auction or purchase the Orb. The intended use case for the\\n    /// beneficiary is to set it to a revenue splitting contract. Proceeds that go to the beneficiary are:\\n    /// - The auction winning bid amount;\\n    /// - Royalties from Orb purchase when not purchased from the Orb creator;\\n    /// - Full purchase price when purchased from the Orb creator;\\n    /// - Harberger tax revenue.\\n    address public beneficiary;\\n    /// Address of the Orb keeper. The keeper is the address that owns the Orb and has the right to invoke the Orb and\\n    /// receive a response. The keeper is also the address that pays the Harberger tax. Keeper address is tracked\\n    /// directly, and ERC-721 compatibility uses this value for `ownerOf()` and `balanceOf()` calls.\\n    address public keeper;\\n\\n    // Orb Oath Variables\\n\\n    /// Honored Until: timestamp until which the Orb Oath is honored for the keeper.\\n    uint256 public honoredUntil;\\n    /// Response Period: time period in which the keeper promises to respond to an invocation.\\n    /// There are no penalties for being late within this contract.\\n    uint256 public responsePeriod;\\n\\n    // ERC-721 Variables\\n\\n    /// ERC-721 token name. Just for display purposes on blockchain explorers.\\n    string public name;\\n    /// ERC-721 token symbol. Just for display purposes on blockchain explorers.\\n    string public symbol;\\n    /// Token URI for tokenURI JSONs. Initially set in the `initializer` and setable with `setTokenURI()`.\\n    string internal _tokenURI;\\n\\n    // Funds Variables\\n\\n    /// Funds tracker, per address. Modified by deposits, withdrawals and settlements. The value is without settlement.\\n    /// It means effective user funds (withdrawable) would be different for keeper (subtracting\\n    /// `_owedSinceLastSettlement()`) and beneficiary (adding `_owedSinceLastSettlement()`). If Orb is held by the\\n    /// creator, funds are not subtracted, as Harberger tax does not apply to the creator.\\n    mapping(address => uint256) public fundsOf;\\n\\n    // Fees State Variables\\n\\n    /// Harberger tax for holding. Initial value is 10.00%.\\n    uint256 public keeperTaxNumerator;\\n    /// Secondary sale royalty paid to beneficiary, based on sale price. Initial value is 10.00%.\\n    uint256 public royaltyNumerator;\\n    /// Price of the Orb. Also used during auction to store future purchase price. Has no meaning if the Orb is held by\\n    /// the contract and the auction is not running.\\n    uint256 public price;\\n    /// Last time Orb keeper's funds were settled. Used to calculate amount owed since last settlement. Has no meaning\\n    /// if the Orb is held by the contract.\\n    uint256 public lastSettlementTime;\\n\\n    // Auction State Variables\\n\\n    /// Auction starting price. Initial value is 0 - allows any bid.\\n    uint256 public auctionStartingPrice;\\n    /// Auction minimum bid step: required increase between bids. Each bid has to increase over previous bid by at\\n    /// least this much. If trying to set as zero, will be set to 1 (wei). Initial value is also 1 wei, to disallow\\n    /// equal value bids.\\n    uint256 public auctionMinimumBidStep;\\n    /// Auction minimum duration: the auction will run for at least this long. Initial value is 1 day, and this value\\n    /// cannot be set to zero, as it would prevent any bids from being made.\\n    uint256 public auctionMinimumDuration;\\n    /// Keeper's Auction minimum duration: auction started by the keeper via `relinquish(true)` will run for at least\\n    /// this long. Initial value is 1 day, and this value cannot be set to zero, as it would prevent any bids from being\\n    /// made.\\n    uint256 public auctionKeeperMinimumDuration;\\n    /// Auction bid extension: if auction remaining time is less than this after a bid is made, auction will continue\\n    /// for at least this long. Can be set to zero, in which case the auction will always be `auctionMinimumDuration`\\n    /// long. Initial value is 5 minutes.\\n    uint256 public auctionBidExtension;\\n    /// Auction end time: timestamp when the auction ends, can be extended by late bids. 0 not during the auction.\\n    uint256 public auctionEndTime;\\n    /// Leading bidder: address that currently has the highest bid. 0 not during the auction and before first bid.\\n    address public leadingBidder;\\n    /// Leading bid: highest current bid. 0 not during the auction and before first bid.\\n    uint256 public leadingBid;\\n    /// Auction Beneficiary: address that receives most of the auction proceeds. Zero address if run by creator.\\n    address public auctionBeneficiary;\\n\\n    // Invocation Variables\\n\\n    /// Cooldown: how often the Orb can be invoked.\\n    uint256 public cooldown;\\n    /// Flagging Period: for how long after an invocation the keeper can flag the response.\\n    uint256 public flaggingPeriod;\\n    /// Maximum length for invocation cleartext content.\\n    uint256 public cleartextMaximumLength;\\n    /// Keeper receive time: when the Orb was last transferred, except to this contract.\\n    uint256 public keeperReceiveTime;\\n    /// Last invocation time: when the Orb was last invoked. Used together with `cooldown` constant.\\n    uint256 public lastInvocationTime;\\n\\n    // Upgradeability Variables\\n\\n    /// Requested upgrade implementation address\\n    address public requestedUpgradeImplementation;\\n\\n    /// Gap used to prevent storage collisions.\\n    uint256[100] private __gap;\\n\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n    //  INITIALIZER AND INTERFACE SUPPORT\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n    /// @custom:oz-upgrades-unsafe-allow constructor\\n    constructor() {\\n        _disableInitializers();\\n    }\\n\\n    /// @dev    When deployed, contract mints the only token that will ever exist, to itself.\\n    ///         This token represents the Orb and is called the Orb elsewhere in the contract.\\n    ///         `Ownable` sets the deployer to be the `owner()`, and also the creator in the Orb context.\\n    /// @param  beneficiary_   Address to receive all Orb proceeds.\\n    /// @param  name_          Orb name, used in ERC-721 metadata.\\n    /// @param  symbol_        Orb symbol or ticker, used in ERC-721 metadata.\\n    /// @param  tokenURI_      Initial value for tokenURI JSONs.\\n    function initialize(address beneficiary_, string memory name_, string memory symbol_, string memory tokenURI_)\\n        public\\n        virtual\\n        initializer\\n    {\\n        __Ownable_init();\\n        __UUPSUpgradeable_init();\\n\\n        name = name_;\\n        symbol = symbol_;\\n        beneficiary = beneficiary_;\\n        _tokenURI = tokenURI_;\\n\\n        keeper = address(this);\\n        pond = msg.sender;\\n\\n        // Initial values. Can be changed by creator before selling the Orb.\\n\\n        keeperTaxNumerator = 10_00;\\n        royaltyNumerator = 10_00;\\n\\n        auctionMinimumBidStep = 1;\\n        auctionMinimumDuration = 1 days;\\n        auctionKeeperMinimumDuration = 1 days;\\n        auctionBidExtension = 5 minutes;\\n\\n        cooldown = 7 days;\\n        flaggingPeriod = 7 days;\\n        cleartextMaximumLength = 280;\\n\\n        emit Creation();\\n    }\\n\\n    /// @dev     ERC-165 supportsInterface. Orb contract supports ERC-721 and IOrb interfaces.\\n    /// @param   interfaceId           Interface id to check for support.\\n    /// @return  isInterfaceSupported  If interface with given 4 bytes id is supported.\\n    function supportsInterface(bytes4 interfaceId)\\n        public\\n        view\\n        virtual\\n        override(ERC165Upgradeable, IERC165Upgradeable)\\n        returns (bool isInterfaceSupported)\\n    {\\n        return interfaceId == 0x4645e06f || interfaceId == type(IERC721Upgradeable).interfaceId\\n            || interfaceId == type(IERC721MetadataUpgradeable).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /// @dev     Function exposing creator address as part of IOrb interface.\\n    /// @return  creatorAddress  Address of the Orb creator.\\n    function creator() public view virtual returns (address creatorAddress) {\\n        return owner();\\n    }\\n\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n    //  MODIFIERS\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n    // AUTHORIZATION MODIFIERS\\n\\n    /// @dev  Ensures that the caller owns the Orb. Should only be used in conjuction with `onlyKeeperHeld` or on\\n    ///       external functions, otherwise does not make sense.\\n    ///       Contract inherits `onlyOwner` modifier from `Ownable`.\\n    modifier onlyKeeper() virtual {\\n        if (msg.sender != keeper) {\\n            revert NotKeeper();\\n        }\\n        _;\\n    }\\n\\n    // ORB STATE MODIFIERS\\n\\n    /// @dev  Ensures that the Orb belongs to someone, not the contract itself.\\n    modifier onlyKeeperHeld() virtual {\\n        if (address(this) == keeper) {\\n            revert ContractHoldsOrb();\\n        }\\n        _;\\n    }\\n\\n    /// @dev  Ensures that the Orb belongs to the contract itself or the creator, and the auction hasn't been started.\\n    ///       Most setting-adjusting functions should use this modifier. It means that the Orb properties cannot be\\n    ///       modified while it is held by the keeper or users can bid on the Orb.\\n    modifier onlyCreatorControlled() virtual {\\n        if (address(this) != keeper && owner() != keeper) {\\n            // Creator CAN control (does not revert) if any of these are false:\\n            // - Orb is not held by the contract itself\\n            // - Orb is not held by the creator\\n            // Inverted, this means that the creator CAN control if any of these are true:\\n            // - Orb is held by the contract itself OR\\n            // - Orb is held by the creator\\n            revert CreatorDoesNotControlOrb();\\n        }\\n        if (auctionEndTime > 0) {\\n            revert AuctionRunning();\\n        }\\n        _;\\n    }\\n\\n    // AUCTION MODIFIERS\\n\\n    /// @dev  Ensures that an auction is currently not running. Can be multiple states: auction not started, auction\\n    ///       over but not finalized, or auction finalized.\\n    modifier notDuringAuction() virtual {\\n        if (_auctionRunning()) {\\n            revert AuctionRunning();\\n        }\\n        _;\\n    }\\n\\n    // FUNDS-RELATED MODIFIERS\\n\\n    /// @dev  Ensures that the current Orb keeper has enough funds to cover Harberger tax until now.\\n    modifier onlyKeeperSolvent() virtual {\\n        if (!keeperSolvent()) {\\n            revert KeeperInsolvent();\\n        }\\n        _;\\n    }\\n\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n    //  FUNCTIONS: ERC-721 OVERRIDES\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n    /// @notice  Since there is only one token (Orb), this function only returns one for the Keeper address.\\n    /// @param   owner_  Address to check balance for.\\n    function balanceOf(address owner_) external view virtual returns (uint256 balance) {\\n        return owner_ == keeper ? 1 : 0;\\n    }\\n\\n    /// @notice  Since there is only one token (Orb), this function only returns the Keeper address if the minted\\n    ///          token id is provided.\\n    function ownerOf(uint256 tokenId_) external view virtual returns (address owner) {\\n        return tokenId_ == _TOKEN_ID ? keeper : address(0);\\n    }\\n\\n    /// @notice  Returns a fixed URL for the Orb ERC-721 metadata. `tokenId` argument is accepted for compatibility\\n    ///          with the ERC-721 standard but does not affect the returned URL.\\n    function tokenURI(uint256) external view virtual returns (string memory) {\\n        return _tokenURI;\\n    }\\n\\n    /// @notice  ERC-721 `approve()` is not supported.\\n    function approve(address, uint256) external virtual {\\n        revert NotSupported();\\n    }\\n\\n    /// @notice  ERC-721 `setApprovalForAll()` is not supported.\\n    function setApprovalForAll(address, bool) external virtual {\\n        revert NotSupported();\\n    }\\n\\n    /// @notice  ERC-721 `getApproved()` is not supported.\\n    function getApproved(uint256) external view virtual returns (address) {\\n        revert NotSupported();\\n    }\\n\\n    /// @notice  ERC-721 `isApprovedForAll()` is not supported.\\n    function isApprovedForAll(address, address) external view virtual returns (bool) {\\n        revert NotSupported();\\n    }\\n\\n    /// @notice  ERC-721 `transferFrom()` is not supported.\\n    function transferFrom(address, address, uint256) external virtual {\\n        revert NotSupported();\\n    }\\n\\n    /// @notice  ERC-721 `safeTransferFrom()` is not supported.\\n    function safeTransferFrom(address, address, uint256) external virtual {\\n        revert NotSupported();\\n    }\\n\\n    /// @notice  ERC-721 `safeTransferFrom()` is not supported.\\n    function safeTransferFrom(address, address, uint256, bytes memory) external virtual {\\n        revert NotSupported();\\n    }\\n\\n    /// @dev    Transfers the ERC-721 token to the new address. If the new owner is not this contract (an actual user),\\n    ///         updates `keeperReceiveTime`. `keeperReceiveTime` is used to limit response flagging duration.\\n    /// @param  from_  Address to transfer the Orb from.\\n    /// @param  to_    Address to transfer the Orb to.\\n    function _transferOrb(address from_, address to_) internal virtual {\\n        emit Transfer(from_, to_, _TOKEN_ID);\\n        keeper = to_;\\n        if (to_ != address(this)) {\\n            keeperReceiveTime = block.timestamp;\\n        }\\n    }\\n\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n    //  FUNCTIONS: ORB PARAMETERS\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n    /// @notice  Allows re-swearing of the Orb Oath and set a new `honoredUntil` date. This function can only be called\\n    ///          by the Orb creator when the Orb is in their control. With `swearOath()`, `honoredUntil` date can be\\n    ///          decreased, unlike with the `extendHonoredUntil()` function.\\n    /// @dev     Emits `OathSwearing`.\\n    /// @param   oathHash           Hash of the Oath taken to create the Orb.\\n    /// @param   newHonoredUntil    Date until which the Orb creator will honor the Oath for the Orb keeper.\\n    /// @param   newResponsePeriod  Duration within which the Orb creator promises to respond to an invocation.\\n    function swearOath(bytes32 oathHash, uint256 newHonoredUntil, uint256 newResponsePeriod)\\n        external\\n        virtual\\n        onlyOwner\\n        onlyCreatorControlled\\n    {\\n        honoredUntil = newHonoredUntil;\\n        responsePeriod = newResponsePeriod;\\n        emit OathSwearing(oathHash, newHonoredUntil, newResponsePeriod);\\n    }\\n\\n    /// @notice  Allows the Orb creator to extend the `honoredUntil` date. This function can be called by the Orb\\n    ///          creator anytime and only allows extending the `honoredUntil` date.\\n    /// @dev     Emits `HonoredUntilUpdate`.\\n    /// @param   newHonoredUntil  Date until which the Orb creator will honor the Oath for the Orb keeper. Must be\\n    ///                           greater than the current `honoredUntil` date.\\n    function extendHonoredUntil(uint256 newHonoredUntil) external virtual onlyOwner {\\n        if (newHonoredUntil < honoredUntil) {\\n            revert HonoredUntilNotDecreasable();\\n        }\\n        uint256 previousHonoredUntil = honoredUntil;\\n        honoredUntil = newHonoredUntil;\\n        emit HonoredUntilUpdate(previousHonoredUntil, newHonoredUntil);\\n    }\\n\\n    /// @notice  Allows the Orb creator to replace the `baseURI`. This function can be called by the Orb creator\\n    ///          anytime and is meant for when the current `baseURI` has to be updated.\\n    /// @param   newTokenURI  New `baseURI`, will be concatenated with the token id in `tokenURI()`.\\n    function setTokenURI(string memory newTokenURI) external virtual onlyOwner {\\n        _tokenURI = newTokenURI;\\n    }\\n\\n    /// @notice  Allows the Orb creator to set the auction parameters. This function can only be called by the Orb\\n    ///          creator when the Orb is in their control.\\n    /// @dev     Emits `AuctionParametersUpdate`.\\n    /// @param   newStartingPrice          New starting price for the auction. Can be 0.\\n    /// @param   newMinimumBidStep         New minimum bid step for the auction. Will always be set to at least 1.\\n    /// @param   newMinimumDuration        New minimum duration for the auction. Must be > 0.\\n    /// @param   newKeeperMinimumDuration  New minimum duration for the auction is started by the keeper via\\n    ///                                    `relinquish(true)`. Setting to 0 effectively disables keeper auctions.\\n    /// @param   newBidExtension           New bid extension for the auction. Can be 0.\\n    function setAuctionParameters(\\n        uint256 newStartingPrice,\\n        uint256 newMinimumBidStep,\\n        uint256 newMinimumDuration,\\n        uint256 newKeeperMinimumDuration,\\n        uint256 newBidExtension\\n    ) external virtual onlyOwner onlyCreatorControlled {\\n        if (newMinimumDuration == 0) {\\n            revert InvalidAuctionDuration(newMinimumDuration);\\n        }\\n\\n        uint256 previousStartingPrice = auctionStartingPrice;\\n        auctionStartingPrice = newStartingPrice;\\n\\n        uint256 previousMinimumBidStep = auctionMinimumBidStep;\\n        auctionMinimumBidStep = newMinimumBidStep > 0 ? newMinimumBidStep : 1;\\n\\n        uint256 previousMinimumDuration = auctionMinimumDuration;\\n        auctionMinimumDuration = newMinimumDuration;\\n\\n        uint256 previousKeeperMinimumDuration = auctionKeeperMinimumDuration;\\n        auctionKeeperMinimumDuration = newKeeperMinimumDuration;\\n\\n        uint256 previousBidExtension = auctionBidExtension;\\n        auctionBidExtension = newBidExtension;\\n\\n        emit AuctionParametersUpdate(\\n            previousStartingPrice,\\n            newStartingPrice,\\n            previousMinimumBidStep,\\n            auctionMinimumBidStep,\\n            previousMinimumDuration,\\n            newMinimumDuration,\\n            previousKeeperMinimumDuration,\\n            newKeeperMinimumDuration,\\n            previousBidExtension,\\n            newBidExtension\\n        );\\n    }\\n\\n    /// @notice  Allows the Orb creator to set the new keeper tax and royalty. This function can only be called by the\\n    ///          Orb creator when the Orb is in their control.\\n    /// @dev     Emits `FeesUpdate`.\\n    /// @param   newKeeperTaxNumerator  New keeper tax numerator, in relation to `feeDenominator()`.\\n    /// @param   newRoyaltyNumerator    New royalty numerator, in relation to `feeDenominator()`. Cannot be larger than\\n    ///                                 `feeDenominator()`.\\n    function setFees(uint256 newKeeperTaxNumerator, uint256 newRoyaltyNumerator)\\n        external\\n        virtual\\n        onlyOwner\\n        onlyCreatorControlled\\n    {\\n        if (newRoyaltyNumerator > _FEE_DENOMINATOR) {\\n            revert RoyaltyNumeratorExceedsDenominator(newRoyaltyNumerator, _FEE_DENOMINATOR);\\n        }\\n\\n        uint256 previousKeeperTaxNumerator = keeperTaxNumerator;\\n        keeperTaxNumerator = newKeeperTaxNumerator;\\n\\n        uint256 previousRoyaltyNumerator = royaltyNumerator;\\n        royaltyNumerator = newRoyaltyNumerator;\\n\\n        emit FeesUpdate(\\n            previousKeeperTaxNumerator, newKeeperTaxNumerator, previousRoyaltyNumerator, newRoyaltyNumerator\\n        );\\n    }\\n\\n    /// @notice  Allows the Orb creator to set the new cooldown duration and flagging period - duration for how long\\n    ///          Orb keeper may flag a response. This function can only be called by the Orb creator when the Orb is in\\n    ///          their control.\\n    /// @dev     Emits `CooldownUpdate`.\\n    /// @param   newCooldown        New cooldown in seconds. Cannot be longer than `COOLDOWN_MAXIMUM_DURATION`.\\n    /// @param   newFlaggingPeriod  New flagging period in seconds.\\n    function setCooldown(uint256 newCooldown, uint256 newFlaggingPeriod)\\n        external\\n        virtual\\n        onlyOwner\\n        onlyCreatorControlled\\n    {\\n        if (newCooldown > _COOLDOWN_MAXIMUM_DURATION) {\\n            revert CooldownExceedsMaximumDuration(newCooldown, _COOLDOWN_MAXIMUM_DURATION);\\n        }\\n\\n        uint256 previousCooldown = cooldown;\\n        cooldown = newCooldown;\\n        uint256 previousFlaggingPeriod = flaggingPeriod;\\n        flaggingPeriod = newFlaggingPeriod;\\n        emit CooldownUpdate(previousCooldown, newCooldown, previousFlaggingPeriod, newFlaggingPeriod);\\n    }\\n\\n    /// @notice  Allows the Orb creator to set the new cleartext maximum length. This function can only be called by\\n    ///          the Orb creator when the Orb is in their control.\\n    /// @dev     Emits `CleartextMaximumLengthUpdate`.\\n    /// @param   newCleartextMaximumLength  New cleartext maximum length. Cannot be 0.\\n    function setCleartextMaximumLength(uint256 newCleartextMaximumLength)\\n        external\\n        virtual\\n        onlyOwner\\n        onlyCreatorControlled\\n    {\\n        if (newCleartextMaximumLength == 0) {\\n            revert InvalidCleartextMaximumLength(newCleartextMaximumLength);\\n        }\\n\\n        uint256 previousCleartextMaximumLength = cleartextMaximumLength;\\n        cleartextMaximumLength = newCleartextMaximumLength;\\n        emit CleartextMaximumLengthUpdate(previousCleartextMaximumLength, newCleartextMaximumLength);\\n    }\\n\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n    //  FUNCTIONS: AUCTION\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n    /// @dev     Returns if the auction is currently running. Use `auctionEndTime()` to check when it ends.\\n    /// @return  isAuctionRunning  If the auction is running.\\n    function _auctionRunning() internal view virtual returns (bool isAuctionRunning) {\\n        return auctionEndTime > block.timestamp;\\n    }\\n\\n    /// @dev     Minimum bid that would currently be accepted by `bid()`. `auctionStartingPrice` if no bids were made,\\n    ///          otherwise the leading bid increased by `auctionMinimumBidStep`.\\n    /// @return  auctionMinimumBid  Minimum bid required for `bid()`.\\n    function _minimumBid() internal view virtual returns (uint256 auctionMinimumBid) {\\n        if (leadingBid == 0) {\\n            return auctionStartingPrice;\\n        } else {\\n            unchecked {\\n                return leadingBid + auctionMinimumBidStep;\\n            }\\n        }\\n    }\\n\\n    /// @notice  Allow the Orb creator to start the Orb auction. Will run for at least `auctionMinimumDuration`.\\n    /// @dev     Prevents repeated starts by checking the `auctionEndTime`. Important to set `auctionEndTime` to 0\\n    ///          after auction is finalized. Emits `AuctionStart`.\\n    function startAuction() external virtual onlyOwner notDuringAuction {\\n        if (address(this) != keeper) {\\n            revert ContractDoesNotHoldOrb();\\n        }\\n\\n        if (auctionEndTime > 0) {\\n            revert AuctionRunning();\\n        }\\n\\n        auctionEndTime = block.timestamp + auctionMinimumDuration;\\n        auctionBeneficiary = beneficiary;\\n\\n        emit AuctionStart(block.timestamp, auctionEndTime, auctionBeneficiary);\\n    }\\n\\n    /// @notice  Bids the provided amount, if there's enough funds across funds on contract and transaction value.\\n    ///          Might extend the auction if bidding close to auction end. Important: the leading bidder will not be\\n    ///          able to withdraw any funds until someone outbids them or the auction is finalized.\\n    /// @dev     Emits `AuctionBid`.\\n    /// @param   amount      The value to bid.\\n    /// @param   priceIfWon  Price if the bid wins. Must be less than `MAXIMUM_PRICE`.\\n    function bid(uint256 amount, uint256 priceIfWon) external payable virtual {\\n        if (!_auctionRunning()) {\\n            revert AuctionNotRunning();\\n        }\\n\\n        if (msg.sender == beneficiary) {\\n            revert NotPermitted();\\n        }\\n\\n        uint256 totalFunds = fundsOf[msg.sender] + msg.value;\\n\\n        if (amount < _minimumBid()) {\\n            revert InsufficientBid(amount, _minimumBid());\\n        }\\n\\n        if (totalFunds < amount) {\\n            revert InsufficientFunds(totalFunds, amount);\\n        }\\n\\n        if (priceIfWon > _MAXIMUM_PRICE) {\\n            revert InvalidNewPrice(priceIfWon);\\n        }\\n\\n        fundsOf[msg.sender] = totalFunds;\\n        leadingBidder = msg.sender;\\n        leadingBid = amount;\\n        price = priceIfWon;\\n\\n        emit AuctionBid(msg.sender, amount);\\n\\n        if (block.timestamp + auctionBidExtension > auctionEndTime) {\\n            auctionEndTime = block.timestamp + auctionBidExtension;\\n            emit AuctionExtension(auctionEndTime);\\n        }\\n    }\\n\\n    /// @notice  Finalizes the auction, transferring the winning bid to the beneficiary, and the Orb to the winner.\\n    ///          If the auction was started by previous Keeper with `relinquish(true)`, then most of the auction\\n    ///          proceeds (minus the royalty) will be sent to the previous Keeper. Sets `lastInvocationTime` so that\\n    ///          the Orb could be invoked immediately. The price has been set when bidding, now becomes relevant. If no\\n    ///          bids were made, resets the state to allow the auction to be started again later.\\n    /// @dev     Critical state transition function. Called after `auctionEndTime`, but only if it's not 0. Can be\\n    ///          called by anyone, although probably will be called by the creator or the winner. Emits `PriceUpdate`\\n    ///          and `AuctionFinalization`.\\n    function finalizeAuction() external virtual notDuringAuction {\\n        if (auctionEndTime == 0) {\\n            revert AuctionNotStarted();\\n        }\\n\\n        if (leadingBidder != address(0)) {\\n            fundsOf[leadingBidder] -= leadingBid;\\n            uint256 auctionMinimumRoyaltyNumerator =\\n                (keeperTaxNumerator * auctionKeeperMinimumDuration) / _KEEPER_TAX_PERIOD;\\n            uint256 auctionRoyalty =\\n                auctionMinimumRoyaltyNumerator > royaltyNumerator ? auctionMinimumRoyaltyNumerator : royaltyNumerator;\\n            _splitProceeds(leadingBid, auctionBeneficiary, auctionRoyalty);\\n\\n            lastSettlementTime = block.timestamp;\\n            lastInvocationTime = block.timestamp - cooldown;\\n\\n            emit AuctionFinalization(leadingBidder, leadingBid);\\n            emit PriceUpdate(0, price);\\n            // price has been set when bidding\\n\\n            _transferOrb(address(this), leadingBidder);\\n            leadingBidder = address(0);\\n            leadingBid = 0;\\n        } else {\\n            emit AuctionFinalization(leadingBidder, leadingBid);\\n        }\\n\\n        auctionEndTime = 0;\\n    }\\n\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n    //  FUNCTIONS: FUNDS AND HOLDING\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n    /// @notice  Allows depositing funds on the contract. Not allowed for insolvent keepers.\\n    /// @dev     Deposits are not allowed for insolvent keepers to prevent cheating via front-running. If the user\\n    ///          becomes insolvent, the Orb will always be returned to the contract as the next step. Emits `Deposit`.\\n    function deposit() external payable virtual {\\n        if (msg.sender == keeper && !keeperSolvent()) {\\n            revert KeeperInsolvent();\\n        }\\n\\n        fundsOf[msg.sender] += msg.value;\\n        emit Deposit(msg.sender, msg.value);\\n    }\\n\\n    /// @notice  Function to withdraw all funds on the contract. Not recommended for current Orb keepers if the price\\n    ///          is not zero, as they will become immediately foreclosable. To give up the Orb, call `relinquish()`.\\n    /// @dev     Not allowed for the leading auction bidder.\\n    function withdrawAll() external virtual {\\n        _withdraw(msg.sender, fundsOf[msg.sender]);\\n    }\\n\\n    /// @notice  Function to withdraw given amount from the contract. For current Orb keepers, reduces the time until\\n    ///          foreclosure.\\n    /// @dev     Not allowed for the leading auction bidder.\\n    /// @param   amount  The amount to withdraw.\\n    function withdraw(uint256 amount) external virtual {\\n        _withdraw(msg.sender, amount);\\n    }\\n\\n    /// @notice  Function to withdraw all beneficiary funds on the contract. Settles if possible.\\n    /// @dev     Allowed for anyone at any time, does not use `msg.sender` in its execution.\\n    function withdrawAllForBeneficiary() external virtual {\\n        if (keeper != address(this)) {\\n            _settle();\\n        }\\n        _withdraw(beneficiary, fundsOf[beneficiary]);\\n    }\\n\\n    /// @notice  Settlements transfer funds from Orb keeper to the beneficiary. Orb accounting minimizes required\\n    ///          transactions: Orb keeper's foreclosure time is only dependent on the price and available funds. Fund\\n    ///          transfers are not necessary unless these variables (price, keeper funds) are being changed. Settlement\\n    ///          transfers funds owed since the last settlement, and a new period of virtual accounting begins.\\n    /// @dev     See also `_settle()`.\\n    function settle() external virtual onlyKeeperHeld {\\n        _settle();\\n    }\\n\\n    /// @dev     Returns if the current Orb keeper has enough funds to cover Harberger tax until now. Always true if\\n    ///          creator holds the Orb.\\n    /// @return  isKeeperSolvent  If the current keeper is solvent.\\n    function keeperSolvent() public view virtual returns (bool isKeeperSolvent) {\\n        if (owner() == keeper) {\\n            return true;\\n        }\\n        return fundsOf[keeper] >= _owedSinceLastSettlement();\\n    }\\n\\n    /// @dev     Returns the accounting base for Orb fees (Harberger tax rate and royalty).\\n    /// @return  feeDenominatorValue  The accounting base for Orb fees.\\n    function feeDenominator() external pure virtual returns (uint256 feeDenominatorValue) {\\n        return _FEE_DENOMINATOR;\\n    }\\n\\n    /// @dev     Returns the Harberger tax period base. Keeper tax is for each of this period.\\n    /// @return  keeperTaxPeriodSeconds  How long is the Harberger tax period, in seconds.\\n    function keeperTaxPeriod() external pure virtual returns (uint256 keeperTaxPeriodSeconds) {\\n        return _KEEPER_TAX_PERIOD;\\n    }\\n\\n    /// @dev     Calculates how much money Orb keeper owes Orb beneficiary. This amount would be transferred between\\n    ///          accounts during settlement. **Owed amount can be higher than keeper's funds!** It's important to check\\n    ///          if keeper has enough funds before transferring.\\n    /// @return  owedValue  Wei Orb keeper owes Orb beneficiary since the last settlement time.\\n    function _owedSinceLastSettlement() internal view virtual returns (uint256 owedValue) {\\n        uint256 secondsSinceLastSettlement = block.timestamp - lastSettlementTime;\\n        return (price * keeperTaxNumerator * secondsSinceLastSettlement) / (_KEEPER_TAX_PERIOD * _FEE_DENOMINATOR);\\n    }\\n\\n    /// @dev    Executes the withdrawal for a given amount, does the actual value transfer from the contract to user's\\n    ///         wallet. The only function in the contract that sends value and has re-entrancy risk. Does not check if\\n    ///         the address is payable, as the Address library reverts if it is not. Emits `Withdrawal`.\\n    /// @param  recipient_  The address to send the value to.\\n    /// @param  amount_     The value in wei to withdraw from the contract.\\n    function _withdraw(address recipient_, uint256 amount_) internal virtual {\\n        if (recipient_ == leadingBidder) {\\n            revert NotPermittedForLeadingBidder();\\n        }\\n\\n        if (recipient_ == keeper) {\\n            _settle();\\n        }\\n\\n        if (fundsOf[recipient_] < amount_) {\\n            revert InsufficientFunds(fundsOf[recipient_], amount_);\\n        }\\n\\n        fundsOf[recipient_] -= amount_;\\n\\n        emit Withdrawal(recipient_, amount_);\\n\\n        AddressUpgradeable.sendValue(payable(recipient_), amount_);\\n    }\\n\\n    /// @dev  Keeper might owe more than they have funds available: it means that the keeper is foreclosable.\\n    ///       Settlement would transfer all keeper funds to the beneficiary, but not more. Does not transfer funds if\\n    ///       the creator holds the Orb, but always updates `lastSettlementTime`. Should never be called if Orb is\\n    ///       owned by the contract. Emits `Settlement`.\\n    function _settle() internal virtual {\\n        address _keeper = keeper;\\n\\n        if (owner() == _keeper) {\\n            lastSettlementTime = block.timestamp;\\n            return;\\n        }\\n\\n        uint256 availableFunds = fundsOf[_keeper];\\n        uint256 owedFunds = _owedSinceLastSettlement();\\n        uint256 transferableToBeneficiary = availableFunds <= owedFunds ? availableFunds : owedFunds;\\n\\n        fundsOf[_keeper] -= transferableToBeneficiary;\\n        fundsOf[beneficiary] += transferableToBeneficiary;\\n\\n        lastSettlementTime = block.timestamp;\\n\\n        emit Settlement(_keeper, beneficiary, transferableToBeneficiary);\\n    }\\n\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n    //  FUNCTIONS: PURCHASING AND LISTING\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n    /// @notice  Sets the new purchase price for the Orb. Harberger tax means the asset is always for sale. The price\\n    ///          can be set to zero, making foreclosure time to be never. Can only be called by a solvent keeper.\\n    ///          Settles before adjusting the price, as the new price will change foreclosure time.\\n    /// @dev     Emits `Settlement` and `PriceUpdate`. See also `_setPrice()`.\\n    /// @param   newPrice  New price for the Orb.\\n    function setPrice(uint256 newPrice) external virtual onlyKeeper onlyKeeperSolvent {\\n        _settle();\\n        _setPrice(newPrice);\\n    }\\n\\n    /// @notice  Lists the Orb for sale at the given price to buy directly from the Orb creator. This is an alternative\\n    ///          to the auction mechanism, and can be used to simply have the Orb for sale at a fixed price, waiting\\n    ///          for the buyer. Listing is only allowed if the auction has not been started and the Orb is held by the\\n    ///          contract. When the Orb is purchased from the creator, all proceeds go to the beneficiary and the Orb\\n    ///          comes fully charged, with no cooldown.\\n    /// @dev     Emits `Transfer` and `PriceUpdate`.\\n    /// @param   listingPrice  The price to buy the Orb from the creator.\\n    function listWithPrice(uint256 listingPrice) external virtual onlyOwner {\\n        if (address(this) != keeper) {\\n            revert ContractDoesNotHoldOrb();\\n        }\\n\\n        if (auctionEndTime > 0) {\\n            revert AuctionRunning();\\n        }\\n\\n        _transferOrb(address(this), msg.sender);\\n        _setPrice(listingPrice);\\n    }\\n\\n    /// @notice  Purchasing is the mechanism to take over the Orb. With Harberger tax, the Orb can always be purchased\\n    ///          from its keeper. Purchasing is only allowed while the keeper is solvent. If not, the Orb has to be\\n    ///          foreclosed and re-auctioned. This function does not require the purchaser to have more funds than\\n    ///          required, but purchasing without any reserve would leave the new owner immediately foreclosable.\\n    ///          Beneficiary receives either just the royalty, or full price if the Orb is purchased from the creator.\\n    /// @dev     Requires to provide key Orb parameters (current price, Harberger tax rate, royalty, cooldown and\\n    ///          cleartext maximum length) to prevent front-running: without these parameters Orb creator could\\n    ///          front-run purcaser and change Orb parameters before the purchase; and without current price anyone\\n    ///          could purchase the Orb ahead of the purchaser, set the price higher, and profit from the purchase.\\n    ///          Does not modify `lastInvocationTime` unless buying from the creator.\\n    ///          Does not allow settlement in the same block before `purchase()` to prevent transfers that avoid\\n    ///          royalty payments. Does not allow purchasing from yourself. Emits `PriceUpdate` and `Purchase`.\\n    /// @param   newPrice                       New price to use after the purchase.\\n    /// @param   currentPrice                   Current price, to prevent front-running.\\n    /// @param   currentKeeperTaxNumerator      Current keeper tax numerator, to prevent front-running.\\n    /// @param   currentRoyaltyNumerator        Current royalty numerator, to prevent front-running.\\n    /// @param   currentCooldown                Current cooldown, to prevent front-running.\\n    /// @param   currentCleartextMaximumLength  Current cleartext maximum length, to prevent front-running.\\n    function purchase(\\n        uint256 newPrice,\\n        uint256 currentPrice,\\n        uint256 currentKeeperTaxNumerator,\\n        uint256 currentRoyaltyNumerator,\\n        uint256 currentCooldown,\\n        uint256 currentCleartextMaximumLength\\n    ) external payable virtual onlyKeeperHeld onlyKeeperSolvent {\\n        if (currentPrice != price) {\\n            revert CurrentValueIncorrect(currentPrice, price);\\n        }\\n        if (currentKeeperTaxNumerator != keeperTaxNumerator) {\\n            revert CurrentValueIncorrect(currentKeeperTaxNumerator, keeperTaxNumerator);\\n        }\\n        if (currentRoyaltyNumerator != royaltyNumerator) {\\n            revert CurrentValueIncorrect(currentRoyaltyNumerator, royaltyNumerator);\\n        }\\n        if (currentCooldown != cooldown) {\\n            revert CurrentValueIncorrect(currentCooldown, cooldown);\\n        }\\n        if (currentCleartextMaximumLength != cleartextMaximumLength) {\\n            revert CurrentValueIncorrect(currentCleartextMaximumLength, cleartextMaximumLength);\\n        }\\n\\n        if (lastSettlementTime >= block.timestamp) {\\n            revert PurchasingNotPermitted();\\n        }\\n\\n        _settle();\\n\\n        address _keeper = keeper;\\n\\n        if (msg.sender == _keeper) {\\n            revert AlreadyKeeper();\\n        }\\n        if (msg.sender == beneficiary) {\\n            revert NotPermitted();\\n        }\\n\\n        fundsOf[msg.sender] += msg.value;\\n        uint256 totalFunds = fundsOf[msg.sender];\\n\\n        if (totalFunds < currentPrice) {\\n            revert InsufficientFunds(totalFunds, currentPrice);\\n        }\\n\\n        fundsOf[msg.sender] -= currentPrice;\\n        if (owner() == _keeper) {\\n            lastInvocationTime = block.timestamp - cooldown;\\n            fundsOf[beneficiary] += currentPrice;\\n        } else {\\n            _splitProceeds(currentPrice, _keeper, royaltyNumerator);\\n        }\\n\\n        _setPrice(newPrice);\\n\\n        emit Purchase(_keeper, msg.sender, currentPrice);\\n\\n        _transferOrb(_keeper, msg.sender);\\n    }\\n\\n    /// @dev    Assigns proceeds to beneficiary and primary receiver, accounting for royalty. Used by `purchase()` and\\n    ///         `finalizeAuction()`. Fund deducation should happen before calling this function. Receiver might be\\n    ///         beneficiary if no split is needed.\\n    /// @param  proceeds_  Total proceeds to split between beneficiary and receiver.\\n    /// @param  receiver_  Address of the receiver of the proceeds minus royalty.\\n    /// @param  royalty_   Beneficiary royalty numerator to use for the split.\\n    function _splitProceeds(uint256 proceeds_, address receiver_, uint256 royalty_) internal virtual {\\n        uint256 beneficiaryRoyalty = (proceeds_ * royalty_) / _FEE_DENOMINATOR;\\n        uint256 receiverShare = proceeds_ - beneficiaryRoyalty;\\n        fundsOf[beneficiary] += beneficiaryRoyalty;\\n        fundsOf[receiver_] += receiverShare;\\n    }\\n\\n    /// @dev    Does not check if the new price differs from the previous price: no risk. Limits the price to\\n    ///         MAXIMUM_PRICE to prevent potential overflows in math. Emits `PriceUpdate`.\\n    /// @param  newPrice_  New price for the Orb.\\n    function _setPrice(uint256 newPrice_) internal virtual {\\n        if (newPrice_ > _MAXIMUM_PRICE) {\\n            revert InvalidNewPrice(newPrice_);\\n        }\\n\\n        uint256 previousPrice = price;\\n        price = newPrice_;\\n\\n        emit PriceUpdate(previousPrice, newPrice_);\\n    }\\n\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n    //  FUNCTIONS: RELINQUISHMENT AND FORECLOSURE\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n    /// @notice  Relinquishment is a voluntary giving up of the Orb. It's a combination of withdrawing all funds not\\n    ///          owed to the beneficiary since last settlement and transferring the Orb to the contract. Keepers giving\\n    ///          up the Orb may start an auction for it for their own benefit. Once auction is finalized, most of the\\n    ///          proceeds (minus the royalty) go to the relinquishing Keeper. Alternatives to relinquisment are setting\\n    ///          the price to zero or withdrawing all funds. Orb creator cannot start the keeper auction via this\\n    ///          function, and must call `relinquish(false)` and `startAuction()` separately to run the creator\\n    ///          auction.\\n    /// @dev     Calls `_withdraw()`, which does value transfer from the contract. Emits `Relinquishment`,\\n    ///          `Withdrawal`, and optionally `AuctionStart`.\\n    function relinquish(bool withAuction) external virtual onlyKeeper onlyKeeperSolvent {\\n        _settle();\\n\\n        price = 0;\\n        emit Relinquishment(msg.sender);\\n\\n        if (withAuction && auctionKeeperMinimumDuration > 0) {\\n            if (owner() == msg.sender) {\\n                revert NotPermitted();\\n            }\\n            auctionBeneficiary = msg.sender;\\n            auctionEndTime = block.timestamp + auctionKeeperMinimumDuration;\\n            emit AuctionStart(block.timestamp, auctionEndTime, auctionBeneficiary);\\n        }\\n\\n        _transferOrb(msg.sender, address(this));\\n        _withdraw(msg.sender, fundsOf[msg.sender]);\\n    }\\n\\n    /// @notice  Foreclose can be called by anyone after the Orb keeper runs out of funds to cover the Harberger tax.\\n    ///          It returns the Orb to the contract and starts a auction to find the next keeper. Most of the proceeds\\n    ///          (minus the royalty) go to the previous keeper.\\n    /// @dev     Emits `Foreclosure`, and optionally `AuctionStart`.\\n    function foreclose() external virtual onlyKeeperHeld {\\n        if (keeperSolvent()) {\\n            revert KeeperSolvent();\\n        }\\n\\n        _settle();\\n\\n        address _keeper = keeper;\\n        price = 0;\\n\\n        emit Foreclosure(_keeper);\\n\\n        if (auctionKeeperMinimumDuration > 0) {\\n            auctionBeneficiary = _keeper;\\n            auctionEndTime = block.timestamp + auctionKeeperMinimumDuration;\\n            emit AuctionStart(block.timestamp, auctionEndTime, auctionBeneficiary);\\n        }\\n\\n        _transferOrb(_keeper, address(this));\\n    }\\n\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n    //  FUNCTIONS: INVOKING AND RESPONDING\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n    /// @dev    Allows Orb Invocation Registry to update lastInvocationTime of the Orb. It is the only Orb state\\n    ///         variable that can be written by the Orb Invocation Registry. The Only Orb Invocation Registry that can\\n    ///         update this variable is the one specified in the Orb Pond that created this Orb.\\n    /// @param  timestamp  New value for lastInvocationTime.\\n    function setLastInvocationTime(uint256 timestamp) external virtual {\\n        if (msg.sender != OrbPond(pond).registry()) {\\n            revert NotPermitted();\\n        }\\n        lastInvocationTime = timestamp;\\n    }\\n\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n    //  FUNCTIONS: UPGRADING\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n    /// @notice  Returns the version of the Orb. Internal constant `_VERSION` will be increased with each upgrade.\\n    /// @return  orbVersion  Version of the Orb.\\n    function version() public view virtual returns (uint256 orbVersion) {\\n        return _VERSION;\\n    }\\n\\n    /// @notice  Allows the creator to request an upgrade to the next version of the Orb. Requires that the new version\\n    ///          is registered with the Orb Pond. The upgrade will be performed with `upgradeToNextVersion()` by the\\n    ///          keeper (if there is one), or the creator if the Orb is in their control. The upgrade can be cancelled\\n    ///          by calling this function with `address(0)` as the argument.\\n    /// @dev     Emits `UpgradeRequest`.\\n    /// @param   requestedImplementation  Address of the new version of the Orb, or `address(0)` to cancel.\\n    function requestUpgrade(address requestedImplementation) external virtual onlyOwner {\\n        if (OrbPond(pond).versions(version() + 1) != requestedImplementation && requestedImplementation != address(0)) {\\n            revert NotNextVersion();\\n        }\\n        requestedUpgradeImplementation = requestedImplementation;\\n\\n        emit UpgradeRequest(requestedImplementation);\\n    }\\n\\n    /// @notice  Allows the keeper (if exists) or the creator (if in their control) to upgrade the Orb to the next\\n    ///          version, if the creator requested an upgrade (by calling `requestUpgrade()`) and it still matches with\\n    ///          the next version stored on the Orb Pond contract. Also calls the next version initializer using fixed\\n    ///          calldata stored on the Orb Pond contract.\\n    /// @dev     Emits `UpgradeCompletion`. Can only be called via an active proxy.\\n    function upgradeToNextVersion() external virtual onlyProxy {\\n        if (requestedUpgradeImplementation == address(0)) {\\n            revert NoUpgradeRequested();\\n        }\\n\\n        // auction cannot be running, mostly applies if contract is keeper\\n        if (auctionEndTime > 0) {\\n            revert NotPermitted();\\n        }\\n\\n        if (\\n            // if sender is not keeper or owner\\n            (msg.sender != keeper && msg.sender != owner())\\n            // if sender is keeper, keeper has to be solvent\\n            // if sender is owner, they will always be solvent\\n            || (msg.sender == keeper && !keeperSolvent())\\n            // if sender is owner, but not keeper, keeper has to be this contract\\n            || (msg.sender != keeper && msg.sender == owner() && address(this) != keeper)\\n        ) {\\n            revert NotPermitted();\\n        }\\n\\n        address nextVersionImplementation = OrbPond(pond).versions(version() + 1);\\n        if (nextVersionImplementation != requestedUpgradeImplementation) {\\n            revert NotNextVersion();\\n        }\\n\\n        _upgradeToAndCallUUPS(nextVersionImplementation, OrbPond(pond).upgradeCalldata(version() + 1), false);\\n        requestedUpgradeImplementation = address(0);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/OrbPond.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.20;\\n\\nimport {ERC1967Proxy} from \\\"../lib/openzeppelin-contracts/contracts/proxy/ERC1967/ERC1967Proxy.sol\\\";\\nimport {OwnableUpgradeable} from \\\"../lib/openzeppelin-contracts-upgradeable/contracts/access/OwnableUpgradeable.sol\\\";\\nimport {UUPSUpgradeable} from \\\"../lib/openzeppelin-contracts-upgradeable/contracts/proxy/utils/UUPSUpgradeable.sol\\\";\\nimport {ClonesUpgradeable} from \\\"../lib/openzeppelin-contracts-upgradeable/contracts/proxy/ClonesUpgradeable.sol\\\";\\n\\nimport {PaymentSplitter} from \\\"./CustomPaymentSplitter.sol\\\";\\nimport {IOwnershipTransferrable} from \\\"./IOwnershipTransferrable.sol\\\";\\nimport {Orb} from \\\"./Orb.sol\\\";\\n\\n/// @title   Orb Pond - The Orb Factory\\n/// @author  Jonas Lekevicius\\n/// @notice  Orbs come from a Pond. The Orb Pond is used to efficiently create new Orbs, and track \u201cofficial\u201d Orbs,\\n///          supported by the Orb Land system. The Orb Pond is also used to register allowed Orb upgrade\\n///          implementations, and keeps a reference to an Orb Invocation Registry used by all Orbs created with this\\n///          Orb Pond.\\n/// @dev     Uses `Ownable`'s `owner()` to limit the creation of new Orbs to the administrator and for upgrades.\\n/// @custom:security-contact security@orb.land\\ncontract OrbPond is OwnableUpgradeable, UUPSUpgradeable {\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n    //  EVENTS\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n    event OrbCreation(uint256 indexed orbId, address indexed orbAddress);\\n    event VersionRegistration(uint256 indexed versionNumber, address indexed implementation);\\n\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n    //  ERRORS\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n    error InvalidVersion();\\n\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n    //  STORAGE\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n    /// Orb Pond version. Value: 1.\\n    uint256 private constant _VERSION = 1;\\n\\n    /// The mapping of Orb ids to Orbs. Increases monotonically.\\n    mapping(uint256 orbId => address orbAddress) public orbs;\\n    /// The number of Orbs created so far, used to find the next Orb id.\\n    uint256 public orbCount;\\n\\n    /// The mapping of version numbers to implementation contract addresses. Looked up by Orbs to find implementation\\n    /// contracts for upgrades.\\n    mapping(uint256 versionNumber => address implementation) public versions;\\n    /// The mapping of version numbers to upgrade calldata. Looked up by Orbs to find initialization calldata for\\n    /// upgrades.\\n    mapping(uint256 versionNumber => bytes upgradeCalldata) public upgradeCalldata;\\n    /// The highest version number so far. Could be used for new Orb creation.\\n    uint256 public latestVersion;\\n\\n    /// The address of the Orb Invocation Registry, used to register Orb invocations and responses.\\n    address public registry;\\n    /// The address of the PaymentSplitter implementation contract, used to create new PaymentSplitters.\\n    address public paymentSplitterImplementation;\\n\\n    /// Gap used to prevent storage collisions.\\n    uint256[100] private __gap;\\n\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n    //  INITIALIZER\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n    /// @custom:oz-upgrades-unsafe-allow constructor\\n    constructor() {\\n        _disableInitializers();\\n    }\\n\\n    /// @notice  Initializes the contract, setting the `owner` and `registry` variables.\\n    /// @param   registry_                        The address of the Orb Invocation Registry.\\n    /// @param   paymentSplitterImplementation_   The address of the PaymentSplitter implementation contract.\\n    function initialize(address registry_, address paymentSplitterImplementation_) public initializer {\\n        __Ownable_init();\\n        __UUPSUpgradeable_init();\\n\\n        registry = registry_;\\n        paymentSplitterImplementation = paymentSplitterImplementation_;\\n    }\\n\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n    //  FUNCTIONS: ORB CREATION\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n    /// @notice  Creates a new Orb together with a PaymentSplitter, and emits an event with the Orb's address.\\n    /// @param   payees_       Beneficiaries of the Orb's PaymentSplitter.\\n    /// @param   shares_       Shares of the Orb's PaymentSplitter.\\n    /// @param   name          Name of the Orb, used for display purposes. Suggestion: \\\"NameOrb\\\".\\n    /// @param   symbol        Symbol of the Orb, used for display purposes. Suggestion: \\\"ORB\\\".\\n    /// @param   tokenURI      Initial tokenURI of the Orb, used as part of ERC-721 tokenURI.\\n    function createOrb(\\n        address[] memory payees_,\\n        uint256[] memory shares_,\\n        string memory name,\\n        string memory symbol,\\n        string memory tokenURI\\n    ) external virtual onlyOwner {\\n        address beneficiary = ClonesUpgradeable.clone(paymentSplitterImplementation);\\n        PaymentSplitter(payable(beneficiary)).initialize(payees_, shares_);\\n\\n        bytes memory initializeCalldata = abi.encodeCall(Orb.initialize, (beneficiary, name, symbol, tokenURI));\\n        ERC1967Proxy proxy = new ERC1967Proxy(versions[1], initializeCalldata);\\n        orbs[orbCount] = address(proxy);\\n        IOwnershipTransferrable(orbs[orbCount]).transferOwnership(msg.sender);\\n\\n        emit OrbCreation(orbCount, address(proxy));\\n\\n        orbCount++;\\n    }\\n\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n    //  FUNCTIONS: UPGRADING\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n    /// @notice  Registers a new version of the Orb implementation contract. The version number must be exactly one\\n    ///          higher than the previous version number, and the implementation address must be non-zero. Versions can\\n    ///          be un-registered by setting the implementation address to 0; only the latest version can be\\n    ///          un-registered.\\n    /// @param   version_          Version number of the new implementation contract.\\n    /// @param   implementation_   Address of the new implementation contract.\\n    /// @param   upgradeCalldata_  Initialization calldata to be used for upgrading to the new implementation contract.\\n    function registerVersion(uint256 version_, address implementation_, bytes calldata upgradeCalldata_)\\n        external\\n        virtual\\n        onlyOwner\\n    {\\n        if (version_ < latestVersion && implementation_ == address(0)) {\\n            revert InvalidVersion();\\n        }\\n        if (version_ > latestVersion + 1) {\\n            revert InvalidVersion();\\n        }\\n        versions[version_] = implementation_;\\n        upgradeCalldata[version_] = upgradeCalldata_;\\n        if (version_ > latestVersion) {\\n            latestVersion = version_;\\n        }\\n        if (version_ == latestVersion && implementation_ == address(0)) {\\n            latestVersion--;\\n        }\\n        emit VersionRegistration(version_, implementation_);\\n    }\\n\\n    /// @notice  Returns the version of the Orb Pond. Internal constant `_VERSION` will be increased with each upgrade.\\n    /// @return  orbPondVersion  Version of the Orb Pond contract.\\n    function version() public view virtual returns (uint256 orbPondVersion) {\\n        return _VERSION;\\n    }\\n\\n    /// @dev  Authorizes `owner()` to upgrade this OrbPond contract.\\n    // solhint-disable no-empty-blocks\\n    function _authorizeUpgrade(address newImplementation) internal override onlyOwner {}\\n}\\n\"\r\n    },\r\n    \"src/OrbPondV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.20;\\n\\nimport {ERC1967Proxy} from \\\"../lib/openzeppelin-contracts/contracts/proxy/ERC1967/ERC1967Proxy.sol\\\";\\nimport {ClonesUpgradeable} from \\\"../lib/openzeppelin-contracts-upgradeable/contracts/proxy/ClonesUpgradeable.sol\\\";\\n\\nimport {PaymentSplitter} from \\\"./CustomPaymentSplitter.sol\\\";\\nimport {OrbPond} from \\\"./OrbPond.sol\\\";\\nimport {IOwnershipTransferrable} from \\\"./IOwnershipTransferrable.sol\\\";\\nimport {Orb} from \\\"./Orb.sol\\\";\\n\\n/// @title   Orb Pond - The Orb Factory\\n/// @author  Jonas Lekevicius\\n/// @notice  Orbs come from a Pond. The Orb Pond is used to efficiently create new Orbs, and track \u201cofficial\u201d Orbs,\\n///          supported by the Orb Land system. The Orb Pond is also used to register allowed Orb upgrade\\n///          implementations, and keeps a reference to an Orb Invocation Registry used by all Orbs created with this\\n///          Orb Pond.\\n/// @dev     Uses `Ownable`'s `owner()` to limit the creation of new Orbs to the administrator and for upgrades.\\n///          V2 adds these changes:\\n///          - `orbInitialVersion` field for new Orb creation and `setOrbInitialVersion()` function to set it. This\\n///            allows to specify which version of the Orb implementation to use for new Orbs.\\n///          - `beneficiaryWithdrawalAddresses` mapping to authorize addresses to be used as\\n///            `beneficiaryWithdrawalAddress` on Orbs, `authorizeWithdrawalAddress()` function to set it, and\\n///            `beneficiaryWithdrawalAddressPermitted()` function to check if address is authorized.\\n/// @custom:security-contact security@orb.land\\ncontract OrbPondV2 is OrbPond {\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n    //  EVENTS\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n    event OrbInitialVersionUpdate(uint256 previousInitialVersion, uint256 indexed newInitialVersion);\\n    event WithdrawalAddressAuthorization(address indexed withdrawalAddress, bool indexed authorized);\\n\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n    //  STORAGE\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n    /// Orb Pond version. Value: 2.\\n    uint256 private constant _VERSION = 2;\\n\\n    /// New Orb version\\n    uint256 public orbInitialVersion;\\n\\n    /// Addresses authorized to be used as beneficiaryWithdrawal address\\n    mapping(address withdrawalAddress => bool isPermitted) public beneficiaryWithdrawalAddresses;\\n\\n    /// Gap used to prevent storage collisions.\\n    uint256[100] private __gap;\\n\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n    //  INITIALIZER\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n    /// @custom:oz-upgrades-unsafe-allow constructor\\n    constructor() {\\n        _disableInitializers();\\n    }\\n\\n    /// @notice  Reinitializes the contract with provided initial value for `orbInitialVersion`.\\n    /// @param   orbInitialVersion_  Registered Orb implementation version to be used for new Orbs.\\n    function initializeV2(uint256 orbInitialVersion_) public reinitializer(2) {\\n        orbInitialVersion = orbInitialVersion_;\\n    }\\n\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n    //  FUNCTIONS: ORB CREATION\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n    /// @notice  Creates a new Orb together with a PaymentSplitter, and emits an event with the Orb's address.\\n    /// @param   payees_       Beneficiaries of the Orb's PaymentSplitter.\\n    /// @param   shares_       Shares of the Orb's PaymentSplitter.\\n    /// @param   name          Name of the Orb, used for display purposes. Suggestion: \\\"NameOrb\\\".\\n    /// @param   symbol        Symbol of the Orb, used for display purposes. Suggestion: \\\"ORB\\\".\\n    /// @param   tokenURI      Initial tokenURI of the Orb, used as part of ERC-721 tokenURI.\\n    function createOrb(\\n        address[] memory payees_,\\n        uint256[] memory shares_,\\n        string memory name,\\n        string memory symbol,\\n        string memory tokenURI\\n    ) external virtual override onlyOwner {\\n        address beneficiary = ClonesUpgradeable.clone(paymentSplitterImplementation);\\n        PaymentSplitter(payable(beneficiary)).initialize(payees_, shares_);\\n\\n        bytes memory initializeCalldata = abi.encodeCall(Orb.initialize, (beneficiary, name, symbol, tokenURI));\\n        ERC1967Proxy proxy = new ERC1967Proxy(versions[orbInitialVersion], initializeCalldata);\\n        orbs[orbCount] = address(proxy);\\n        IOwnershipTransferrable(orbs[orbCount]).transferOwnership(msg.sender);\\n\\n        emit OrbCreation(orbCount, address(proxy));\\n\\n        orbCount++;\\n    }\\n\\n    /// @notice  Sets the registered Orb implementation version to be used for new Orbs.\\n    /// @param   orbInitialVersion_  Registered Orb implementation version number to be used for new Orbs.\\n    function setOrbInitialVersion(uint256 orbInitialVersion_) external virtual onlyOwner {\\n        if (orbInitialVersion_ > latestVersion) {\\n            revert InvalidVersion();\\n        }\\n        uint256 previousInitialVersion = orbInitialVersion;\\n        orbInitialVersion = orbInitialVersion_;\\n        emit OrbInitialVersionUpdate(previousInitialVersion, orbInitialVersion_);\\n    }\\n\\n    /// @notice  Returns the version of the Orb Pond. Internal constant `_VERSION` will be increased with each upgrade.\\n    /// @return  orbPondVersion  Version of the Orb Pond contract.\\n    function version() public view virtual override returns (uint256 orbPondVersion) {\\n        return _VERSION;\\n    }\\n\\n    /// @notice Returns if address can be used as beneficiary withdrawal address on Orbs.\\n    /// @param beneficiaryWithdrawalAddress Address to check. Zero address is always permitted.\\n    function beneficiaryWithdrawalAddressPermitted(address beneficiaryWithdrawalAddress)\\n        external\\n        virtual\\n        returns (bool isBeneficiaryWithdrawalAddressPermitted)\\n    {\\n        return\\n            beneficiaryWithdrawalAddress == address(0) || beneficiaryWithdrawalAddresses[beneficiaryWithdrawalAddress];\\n    }\\n\\n    /// @notice  Allows the owner to authorize permitted beneficiary withdrawal addresses.\\n    /// @param   addressToAuthorize  Address to authorize (likely contract).\\n    /// @param   authorizationValue  Boolean value to set the authorization to.\\n    function authorizeWithdrawalAddress(address addressToAuthorize, bool authorizationValue)\\n        external\\n        virtual\\n        onlyOwner\\n    {\\n        beneficiaryWithdrawalAddresses[addressToAuthorize] = authorizationValue;\\n        emit WithdrawalAddressAuthorization(addressToAuthorize, authorizationValue);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 20000\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"InvalidVersion\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"AdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"beacon\",\"type\":\"address\"}],\"name\":\"BeaconUpgraded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"orbId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"orbAddress\",\"type\":\"address\"}],\"name\":\"OrbCreation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"previousInitialVersion\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"newInitialVersion\",\"type\":\"uint256\"}],\"name\":\"OrbInitialVersionUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"Upgraded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"versionNumber\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"VersionRegistration\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"withdrawalAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"authorized\",\"type\":\"bool\"}],\"name\":\"WithdrawalAddressAuthorization\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addressToAuthorize\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"authorizationValue\",\"type\":\"bool\"}],\"name\":\"authorizeWithdrawalAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"beneficiaryWithdrawalAddress\",\"type\":\"address\"}],\"name\":\"beneficiaryWithdrawalAddressPermitted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isBeneficiaryWithdrawalAddressPermitted\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"withdrawalAddress\",\"type\":\"address\"}],\"name\":\"beneficiaryWithdrawalAddresses\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isPermitted\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"payees_\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"shares_\",\"type\":\"uint256[]\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"tokenURI\",\"type\":\"string\"}],\"name\":\"createOrb\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"registry_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"paymentSplitterImplementation_\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"orbInitialVersion_\",\"type\":\"uint256\"}],\"name\":\"initializeV2\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"latestVersion\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"orbCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"orbInitialVersion\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"orbId\",\"type\":\"uint256\"}],\"name\":\"orbs\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"orbAddress\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paymentSplitterImplementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proxiableUUID\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"version_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"implementation_\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"upgradeCalldata_\",\"type\":\"bytes\"}],\"name\":\"registerVersion\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"registry\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"orbInitialVersion_\",\"type\":\"uint256\"}],\"name\":\"setOrbInitialVersion\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"versionNumber\",\"type\":\"uint256\"}],\"name\":\"upgradeCalldata\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"upgradeCalldata\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"}],\"name\":\"upgradeTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"upgradeToAndCall\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"orbPondVersion\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"versionNumber\",\"type\":\"uint256\"}],\"name\":\"versions\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "OrbPondV2", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "20000", "ConstructorArguments": "", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}