{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/ethereum/NftCreatorVerifier.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport { INftCreatorVerifier, DeployLimitedEditionNftParams, DeployTimedEditionNftParams } from \\\"src/ethereum/INftCreatorVerifier.sol\\\";\\nimport { CrossDomainOrigin } from \\\"src/shared/CrossDomainOrigin.sol\\\";\\nimport { ICrossDomainMessenger } from \\\"src/shared/ICrossDomainMessenger.sol\\\";\\nimport { IOpEditionNftFactory, DeployLimitedEditionNftParams as OpDeployLimitedEditionNftParams, DeployTimedEditionNftParams as OpDeployTimedEditionNftParams } from \\\"src/op/IOpEditionNftFactory.sol\\\";\\nimport { ICreatorRegistry } from \\\"src/ethereum/ICreatorRegistry.sol\\\";\\nimport { EditionType } from \\\"src/shared/EditionType.sol\\\";\\nimport { Ownable } from \\\"openzeppelin-contracts/contracts/access/Ownable.sol\\\";\\n\\ncontract NftCreatorVerifier is INftCreatorVerifier, Ownable {\\n    address private _creatorRegistry;\\n    mapping(uint256 => address) private _opChainIdToOpEditionNftFactory;\\n\\n    modifier onlyNftCreator(address nftAddress_, uint256 tokenId_) {\\n        if (ICreatorRegistry(_creatorRegistry).getCreatorOf(nftAddress_, tokenId_) != msg.sender) {\\n            revert CallerNotNftCreator(nftAddress_, tokenId_, msg.sender);\\n        }\\n\\n        _;\\n    }\\n\\n    modifier onlyRegisteredEditionNftChainId(uint256 editionNftChainId_) {\\n        if (_opChainIdToOpEditionNftFactory[editionNftChainId_] == address(0)) {\\n            revert UnregisteredOpChainId(editionNftChainId_);\\n        }\\n\\n        _;\\n    }\\n\\n    constructor(address owner_, address creatorRegistry_) {\\n        _transferOwnership(owner_);\\n        _creatorRegistry = creatorRegistry_;\\n    }\\n\\n    function deployTimedEditionNft(\\n        DeployTimedEditionNftParams calldata params_\\n    )\\n        external\\n        onlyNftCreator(params_.originalNftAddress, params_.originalNftTokenId)\\n        onlyRegisteredEditionNftChainId(params_.editionNftChainId)\\n    {\\n        bytes memory message = abi.encodeCall(\\n            IOpEditionNftFactory(address(0)).deployTimedEditionNft,\\n            (\\n                OpDeployTimedEditionNftParams({\\n                    creator: msg.sender,\\n                    originalNftAddress: params_.originalNftAddress,\\n                    originalNftTokenId: params_.originalNftTokenId,\\n                    endMintingBlockNumber: params_.endMintingBlockNumber,\\n                    mintPrice: params_.mintPrice,\\n                    name: params_.name,\\n                    symbol: params_.symbol,\\n                    description: params_.description,\\n                    collectionImageUri: params_.collectionImageUri\\n                })\\n            )\\n        );\\n\\n        ICrossDomainMessenger(CrossDomainOrigin.crossDomainMessenger(params_.editionNftChainId)).sendMessage(\\n            _opChainIdToOpEditionNftFactory[params_.editionNftChainId],\\n            message,\\n            // The first 1.92M gas is free\\n            // https://community.optimism.io/docs/developers/bridge/messaging/#for-l1-%E2%87%92-l2-transactions\\n            1920000\\n        );\\n\\n        emit DeployEditionNftMessageSent(\\n            params_.editionNftChainId,\\n            params_.originalNftAddress,\\n            params_.originalNftTokenId,\\n            msg.sender,\\n            EditionType.Timed\\n        );\\n    }\\n\\n    function deployLimitedEditionNft(\\n        DeployLimitedEditionNftParams calldata params_\\n    )\\n        external\\n        onlyNftCreator(params_.originalNftAddress, params_.originalNftTokenId)\\n        onlyRegisteredEditionNftChainId(params_.editionNftChainId)\\n    {\\n        bytes memory message = abi.encodeCall(\\n            IOpEditionNftFactory(address(0)).deployLimitedEditionNft,\\n            (\\n                OpDeployLimitedEditionNftParams({\\n                    creator: msg.sender,\\n                    originalNftAddress: params_.originalNftAddress,\\n                    originalNftTokenId: params_.originalNftTokenId,\\n                    supplyLimit: params_.supplyLimit,\\n                    mintPrice: params_.mintPrice,\\n                    name: params_.name,\\n                    symbol: params_.symbol,\\n                    description: params_.description,\\n                    collectionImageUri: params_.collectionImageUri\\n                })\\n            )\\n        );\\n\\n        ICrossDomainMessenger(CrossDomainOrigin.crossDomainMessenger(params_.editionNftChainId)).sendMessage(\\n            _opChainIdToOpEditionNftFactory[params_.editionNftChainId],\\n            message,\\n            // The first 1.92M gas is free\\n            // https://community.optimism.io/docs/developers/bridge/messaging/#for-l1-%E2%87%92-l2-transactions\\n            1920000\\n        );\\n\\n        emit DeployEditionNftMessageSent(\\n            params_.editionNftChainId,\\n            params_.originalNftAddress,\\n            params_.originalNftTokenId,\\n            msg.sender,\\n            EditionType.Limited\\n        );\\n    }\\n\\n    function setOpEditionNftFactory(uint256 opChainId_, address opEditionNftFactory_) external override onlyOwner {\\n        _opChainIdToOpEditionNftFactory[opChainId_] = opEditionNftFactory_;\\n    }\\n\\n    function creatorRegistry() external view returns (address) {\\n        return _creatorRegistry;\\n    }\\n\\n    function opEditionNftFactory(uint256 opChainId_) external view returns (address) {\\n        return _opChainIdToOpEditionNftFactory[opChainId_];\\n    }\\n}\\n\"\r\n    },\r\n    \"src/ethereum/INftCreatorVerifier.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport { EditionType } from \\\"src/shared/EditionType.sol\\\";\\n\\nstruct DeployLimitedEditionNftParams {\\n    uint256 editionNftChainId;\\n    address originalNftAddress;\\n    uint256 originalNftTokenId;\\n    string name;\\n    string symbol;\\n    string description;\\n    string collectionImageUri;\\n    uint256 supplyLimit;\\n    uint256 mintPrice;\\n}\\n\\nstruct DeployTimedEditionNftParams {\\n    uint256 editionNftChainId;\\n    address originalNftAddress;\\n    uint256 originalNftTokenId;\\n    string name;\\n    string symbol;\\n    string description;\\n    string collectionImageUri;\\n    uint256 endMintingBlockNumber;\\n    uint256 mintPrice;\\n}\\n\\ninterface INftCreatorVerifier {\\n    error CallerNotNftCreator(address nftAddress_, uint256 tokenId_, address caller_);\\n    error UnregisteredOpChainId(uint256 opChainId_);\\n\\n    event DeployEditionNftMessageSent(\\n        uint256 indexed editionNftChainId_,\\n        address indexed originalNftAddress_,\\n        uint256 originalNftTokenId_,\\n        address indexed creator_,\\n        EditionType editionType_\\n    );\\n\\n    function deployTimedEditionNft(DeployTimedEditionNftParams calldata params_) external;\\n\\n    function deployLimitedEditionNft(DeployLimitedEditionNftParams calldata params_) external;\\n\\n    function creatorRegistry() external view returns (address);\\n\\n    function opEditionNftFactory(uint256 opChainId_) external view returns (address);\\n\\n    function setOpEditionNftFactory(uint256 opChainId_, address opEditionNftFactory_) external;\\n}\\n\"\r\n    },\r\n    \"src/shared/CrossDomainOrigin.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\n// Reference: https://github.com/ethereum-optimism/optimism-tutorial/blob/main/cross-dom-comm/contracts/Greeter.sol\\n\\nimport { ICrossDomainMessenger } from \\\"src/shared/ICrossDomainMessenger.sol\\\";\\n\\nlibrary CrossDomainOrigin {\\n    /**\\n     * Returns the CrossDomainMessenger for the given destinationOpChainId_\\n     **/\\n    function crossDomainMessenger(uint256 crossDomainChainId_) internal view returns (address cdmAddr) {\\n        // Get the cross domain messenger's address each time.\\n        // This is less resource intensive than writing to storage.\\n\\n        // Mainnet -> Optimism\\n        if (block.chainid == 1 && crossDomainChainId_ == 10) cdmAddr = 0x25ace71c97B33Cc4729CF772ae268934F7ab5fA1;\\n\\n        // Mainnet -> Base\\n        if (block.chainid == 1 && crossDomainChainId_ == 8453) cdmAddr = 0x866E82a600A1414e583f7F13623F1aC5d58b0Afa;\\n\\n        // Mainnet -> Zora\\n        if (block.chainid == 1 && crossDomainChainId_ == 7777777) cdmAddr = 0xdC40a14d9abd6F410226f1E6de71aE03441ca506;\\n\\n        // Goerli -> Goerli Optimism\\n        if (block.chainid == 5 && crossDomainChainId_ == 420) cdmAddr = 0x5086d1eEF304eb5284A0f6720f79403b4e9bE294;\\n\\n        // Goerli -> Goerli Base\\n        if (block.chainid == 5 && crossDomainChainId_ == 84531) cdmAddr = 0x8e5693140eA606bcEB98761d9beB1BC87383706D;\\n\\n        // Goerli -> Goerli Zora\\n        if (block.chainid == 5 && crossDomainChainId_ == 999) cdmAddr = 0xD87342e16352D33170557A7dA1e5fB966a60FafC;\\n\\n        // Op Stack\\n        if (\\n            // Optimism -> Mainnet\\n            (block.chainid == 10 && crossDomainChainId_ == 1) ||\\n            // Base -> Mainnet\\n            (block.chainid == 8453 && crossDomainChainId_ == 1) ||\\n            // Zora -> Mainnet\\n            (block.chainid == 7777777 && crossDomainChainId_ == 1) ||\\n            // Goerli Optimism -> Goerli\\n            (block.chainid == 420 && crossDomainChainId_ == 5) ||\\n            // Goerli Base -> Goerli\\n            (block.chainid == 84531 && crossDomainChainId_ == 5) ||\\n            // Goerli Zora -> Goerli\\n            (block.chainid == 999 && crossDomainChainId_ == 5)\\n        ) cdmAddr = 0x4200000000000000000000000000000000000007;\\n    }\\n\\n    function getCrossDomainMessageSender(uint256 crossDomainChainId_) internal view returns (address) {\\n        // Get the cross domain messenger's address each time.\\n        // This is less resource intensive than writing to storage.\\n        address cdmAddr = crossDomainMessenger(crossDomainChainId_);\\n\\n        // If this isn't a cross domain message\\n        if (msg.sender != cdmAddr) {\\n            revert(\\\"Not crosschain call\\\");\\n        }\\n\\n        // If it is a cross domain message, find out where it is from\\n        return ICrossDomainMessenger(cdmAddr).xDomainMessageSender();\\n    }\\n}\\n\"\r\n    },\r\n    \"src/shared/ICrossDomainMessenger.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.13;\\n\\ninterface ICrossDomainMessenger {\\n    /**********\\n     * Events *\\n     **********/\\n\\n    event SentMessage(address indexed target, address sender, bytes message, uint256 messageNonce, uint256 gasLimit);\\n    event RelayedMessage(bytes32 indexed msgHash);\\n    event FailedRelayedMessage(bytes32 indexed msgHash);\\n\\n    /*************\\n     * Variables *\\n     *************/\\n\\n    function xDomainMessageSender() external view returns (address);\\n\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n    /**\\n     * Sends a cross domain message to the target messenger.\\n     * @param _target Target contract address.\\n     * @param _message Message to send to the target.\\n     * @param _gasLimit Gas limit for the provided message.\\n     */\\n    function sendMessage(address _target, bytes calldata _message, uint32 _gasLimit) external;\\n}\\n\"\r\n    },\r\n    \"src/op/IOpEditionNftFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport { EditionType } from \\\"src/shared/EditionType.sol\\\";\\n\\nstruct DeployLimitedEditionNftParams {\\n    address creator;\\n    address originalNftAddress;\\n    uint256 originalNftTokenId;\\n    uint256 supplyLimit;\\n    uint256 mintPrice;\\n    string name;\\n    string symbol;\\n    string description;\\n    string collectionImageUri;\\n}\\n\\nstruct DeployTimedEditionNftParams {\\n    address creator;\\n    address originalNftAddress;\\n    uint256 originalNftTokenId;\\n    uint256 endMintingBlockNumber;\\n    uint256 mintPrice;\\n    string name;\\n    string symbol;\\n    string description;\\n    string collectionImageUri;\\n}\\n\\ninterface IOpEditionNftFactory {\\n    error CallerNotEthereumNftCreatorVerifier();\\n    error EditionNftAlreadyDeployed();\\n\\n    event DeployEditionNft(\\n        uint256 indexed originalNftChainId_,\\n        address indexed originalNftAddress_,\\n        uint256 originalNftTokenId_,\\n        address indexed creator_,\\n        EditionType editionType_,\\n        address editionNftAddress_\\n    );\\n\\n    function deployLimitedEditionNft(DeployLimitedEditionNftParams calldata params_) external returns (address);\\n\\n    function deployTimedEditionNft(DeployTimedEditionNftParams calldata params_) external returns (address);\\n\\n    function l1ChainId() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"src/ethereum/ICreatorRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\ninterface ICreatorRegistry {\\n    function getCreatorOf(address nftContract_, uint256 tokenId_) external view returns (address);\\n}\\n\"\r\n    },\r\n    \"src/shared/EditionType.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nenum EditionType {\\n    Limited,\\n    Timed\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts-upgradeable/lib/erc4626-tests/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"openzeppelin/=lib/openzeppelin-contracts-upgradeable/contracts/\",\r\n      \"optimism/=lib/optimism/\",\r\n      \"solmate/=lib/solmate/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"creatorRegistry_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nftAddress_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"caller_\",\"type\":\"address\"}],\"name\":\"CallerNotNftCreator\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"opChainId_\",\"type\":\"uint256\"}],\"name\":\"UnregisteredOpChainId\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"editionNftChainId_\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"originalNftAddress_\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"originalNftTokenId_\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"creator_\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"enum EditionType\",\"name\":\"editionType_\",\"type\":\"uint8\"}],\"name\":\"DeployEditionNftMessageSent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"creatorRegistry\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"editionNftChainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"originalNftAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"originalNftTokenId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"collectionImageUri\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"supplyLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mintPrice\",\"type\":\"uint256\"}],\"internalType\":\"struct DeployLimitedEditionNftParams\",\"name\":\"params_\",\"type\":\"tuple\"}],\"name\":\"deployLimitedEditionNft\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"editionNftChainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"originalNftAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"originalNftTokenId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"collectionImageUri\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"endMintingBlockNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mintPrice\",\"type\":\"uint256\"}],\"internalType\":\"struct DeployTimedEditionNftParams\",\"name\":\"params_\",\"type\":\"tuple\"}],\"name\":\"deployTimedEditionNft\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"opChainId_\",\"type\":\"uint256\"}],\"name\":\"opEditionNftFactory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"opChainId_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"opEditionNftFactory_\",\"type\":\"address\"}],\"name\":\"setOpEditionNftFactory\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "NftCreatorVerifier", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000ffd89dc8e615fa5ace414884519782693bc50be1000000000000000000000000d2c7e9e3b3692a45e9e4b2aede047c6606b222c1", "EVMVersion": "london", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}