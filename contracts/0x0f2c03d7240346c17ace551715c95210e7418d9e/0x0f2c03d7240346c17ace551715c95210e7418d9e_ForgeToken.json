{"SourceCode": "/**`\r\n *Submitted for verification at polygonscan.com on 2023-04-26\r\n*/\r\n\r\n// SPDX-License-Identifier: MIT\r\n// File: Forge Token/Forge_ERC721.sol\r\n\r\n// Contract based on https://docs.openzeppelin.com/contracts/4.x/erc721\r\n\r\npragma solidity ^0.8.4;\r\n\r\ninterface IERC721Receiver {\r\n    function onERC721Received(\r\n        address _operator,\r\n        address _from,\r\n        uint256 _tokenId,\r\n        bytes memory _data\r\n    ) external returns(bytes4);\r\n}\r\n\r\n\r\n//=============================================================================\r\n/// @title Forge_ERC721\r\n/// @dev Implementation of the ERC-721 Non-Fungible Token Standard.\r\n///  - This implementation was created to support giving tokens attribute data\r\n///  without increasing the gas cost of minting.\r\n///  - This implementation also enables tokenOfOwnerByIndex and totalSupply.\r\n/// @author Forge Inc.\r\n//=============================================================================\r\nabstract contract Forge_ERC721 {\r\n    //-------------------------------------------------------------------------\r\n    /// @title TokenData\r\n    /// @dev A data structure containing information about a specific token ID.\r\n    ///  - Initializing TokenData costs the same amount of gas as initializing\r\n    ///  _owners for the token ID in the OpenZeppelin ERC721 implementation.\r\n    //-------------------------------------------------------------------------\r\n    struct TokenData {\r\n        // The owner of this token. An address takes up 20 bytes.\r\n        address tokenOwner;\r\n        // The index of this token in OwnerData's tokensOwned array. Max value 65536.\r\n        uint16 tokenIndex;\r\n        // Leftover to fill with arbitrary data by the implementation contract.\r\n        uint80 extraData;\r\n    }\r\n\r\n    //-------------------------------------------------------------------------\r\n    /// @title OwnerData\r\n    /// @dev A data structure containing information about a specific address.\r\n    ///  - Initialized the first time an owner either receives a token or sets\r\n    ///  an address approved operator. The expected-case is that OwnerData is\r\n    ///  initialized when an owner mints their first token. \r\n    ///  - Initializing OwnerData costs the same amount of gas as initializing\r\n    ///  _balances for the owner in the OpenZeppelin ERC721 implementation.\r\n    //-------------------------------------------------------------------------\r\n    struct OwnerData {\r\n        // An array containing the token ids of all tokens owned by this owner\r\n        uint24[] tokensOwned;\r\n        // A mapping of addresses to if they are approved operators for this owner\r\n        mapping (address=>bool) operatorApprovals;\r\n    }\r\n\r\n    // Token name\r\n    string public name;\r\n    // Token symbol\r\n    string public symbol;\r\n\r\n    // An array containing TokenData for all tokens ever minted.\r\n    // A token's identifier is used to index directly to its data, so the\r\n    // order of _tokenData must never be modified.\r\n    TokenData[] internal _tokenData;\r\n    // A mapping containing OwnerData for all addresses\r\n    mapping (address=>OwnerData) internal _ownerData;\r\n    // A mapping containing approved addresses for each token ID\r\n    mapping (uint=>address) private _tokenApprovals;\r\n    // Number of burned tokens, used to calculate total supply\r\n    uint internal _burnedTokens;\r\n\r\n    //-------------------------------------------------------------------------\r\n    /// @dev This emits when ownership of any NFT changes by any mechanism.\r\n    ///  This event also emits when NFTs are created (`from` == 0) and\r\n    ///  destroyed (`to` == 0). Also indicates that the approved address for\r\n    ///  the NFT is reset to none.\r\n    //-------------------------------------------------------------------------\r\n    event Transfer(\r\n        address indexed _from,\r\n        address indexed _to,\r\n        uint256 indexed _tokenId\r\n    );\r\n    \r\n    //-------------------------------------------------------------------------\r\n    /// @dev This emits when the approved address for an NFT is changed or\r\n    ///  reaffirmed. The zero address indicates there is no approved address.\r\n    //-------------------------------------------------------------------------\r\n    event Approval(\r\n        address indexed _owner,\r\n        address indexed _approved,\r\n        uint256 indexed _tokenId\r\n    );\r\n\r\n    //-------------------------------------------------------------------------\r\n    /// @dev This emits when an operator is enabled or disabled for an owner.\r\n    ///  The operator can transfer all NFTs of the owner.\r\n    //-------------------------------------------------------------------------\r\n    event ApprovalForAll(\r\n        address indexed _owner,\r\n        address indexed _operator,\r\n        bool _approved\r\n    );\r\n\r\n    //-------------------------------------------------------------------------\r\n    /// @dev Throws if a token does not exist or has been burned\r\n    //-------------------------------------------------------------------------\r\n    modifier exists(uint _tokenId) {\r\n        require(\r\n            _tokenId < _tokenData.length && \r\n            _tokenData[_tokenId].tokenOwner != address(0),\r\n            \"ERC721: Token with this ID does not exist\"\r\n        );\r\n        _;\r\n    }\r\n    \r\n    //-------------------------------------------------------------------------\r\n    /// @dev Initializes the contract, setting the token collection's `name`\r\n    ///  and `symbol`.\r\n    //-------------------------------------------------------------------------\r\n    constructor(string memory _name, string memory _symbol) {\r\n        _tokenData.push(TokenData(address(0),0,0));\r\n        name = _name;\r\n        symbol = _symbol;\r\n    }\r\n\r\n\r\n    //=========================================================================\r\n    // PUBLIC FUNCTIONS\r\n    //=========================================================================\r\n    //-------------------------------------------------------------------------\r\n    /// @notice Transfers the ownership of an NFT from one address to another\r\n    ///  -- THE CALLER IS RESPONSIBLE TO CONFIRM THAT `_to` IS CAPABLE OF \r\n    ///  RECEIVING NFTS OR ELSE THEY MAY BE PERMANENTLY LOST\r\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\r\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\r\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\r\n    ///  `_tokenId` is not a valid NFT.\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n    //-------------------------------------------------------------------------\r\n    function transferFrom(address _from, address _to, uint _tokenId)\r\n        public\r\n        exists(_tokenId)\r\n    {\r\n        address tokenOwner = _tokenData[_tokenId].tokenOwner;\r\n        require(\r\n            msg.sender == tokenOwner ||\r\n            msg.sender == _tokenApprovals[_tokenId] ||\r\n            _ownerData[tokenOwner].operatorApprovals[msg.sender],\r\n            \"ERC721: Sender not owner or approved operator for this token\"\r\n        );\r\n        require(\r\n            _from == tokenOwner,\r\n            \"ERC721: _from parameter is not the owner of this token\"\r\n        );\r\n\r\n        _transfer(_to, _tokenId);\r\n    }\r\n    \r\n    function safeTransferFrom(address _from, address _to, uint _tokenId)\r\n        external\r\n    {\r\n        safeTransferFrom(_from, _to, _tokenId, \"\");\r\n    }\r\n    \r\n    //-------------------------------------------------------------------------\r\n    /// @notice Transfers the ownership of an NFT from one address to another\r\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\r\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\r\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\r\n    ///  `_tokenId` is not a valid NFT. When transfer is complete, this function\r\n    ///  checks if `_to` is a smart contract (code size > 0). If so, it calls\r\n    ///  `onERC721Received` on `_to` and throws if the return value is not\r\n    ///  `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n    /// @param _data Additional data with no specified format, sent to `_to`\r\n    //-------------------------------------------------------------------------\r\n    function safeTransferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint _tokenId,\r\n        bytes memory _data\r\n    )\r\n        public\r\n        exists(_tokenId)\r\n    {\r\n        address tokenOwner = _tokenData[_tokenId].tokenOwner;\r\n        require(\r\n            msg.sender == tokenOwner ||\r\n            msg.sender == _tokenApprovals[_tokenId] ||\r\n            _ownerData[tokenOwner].operatorApprovals[msg.sender],\r\n            \"ERC721: Sender not owner or approved operator for this token\"\r\n        );\r\n        require(\r\n            _from == tokenOwner,\r\n            \"ERC721: _from parameter is not the owner of this token\"\r\n        );\r\n\r\n        _transfer(_to, _tokenId);\r\n\r\n        require(\r\n            _checkOnERC721Received(address(0), _to, _tokenId, _data),\r\n            \"ERC721: transfer to non ERC721Receiver implementer\"\r\n        );\r\n    }\r\n\r\n    //-------------------------------------------------------------------------\r\n    /// @notice Change or reaffirm the approved address for an NFT\r\n    /// @dev The zero address indicates there is no approved address.\r\n    ///  Throws unless `msg.sender` is the current NFT owner, or an\r\n    ///  authorized operator of the current owner.\r\n    /// @param _approved The new approved NFT controller\r\n    /// @param _tokenId The NFT to approve\r\n    //-------------------------------------------------------------------------\r\n    function approve(address _approved, uint256 _tokenId)\r\n        public\r\n        exists(_tokenId)\r\n    {\r\n        address tokenOwner = _tokenData[_tokenId].tokenOwner;\r\n        require(\r\n            msg.sender == tokenOwner ||\r\n            _ownerData[tokenOwner].operatorApprovals[msg.sender],\r\n            \"ERC721: Sender does not own this token\"\r\n        );\r\n        _tokenApprovals[_tokenId] = _approved;\r\n        emit Approval(_tokenData[_tokenId].tokenOwner, _approved, _tokenId);\r\n    }\r\n\r\n    //-------------------------------------------------------------------------\r\n    /// @notice Enable or disable approval for a third party (\"operator\") to\r\n    ///  manage all of `msg.sender`'s tokens\r\n    /// @dev Emits the ApprovalForAll event. The contract MUST allow\r\n    ///  multiple operators per owner.\r\n    /// @param _operator Address to add to the set of authorized operators\r\n    /// @param _approved True if the operator is approved, false to revoke approval\r\n    //-------------------------------------------------------------------------\r\n    function setApprovalForAll(address _operator, bool _approved) external {\r\n        _ownerData[msg.sender].operatorApprovals[_operator] = _approved;\r\n        emit ApprovalForAll(msg.sender, _operator, _approved);\r\n    }\r\n    \r\n    //-------------------------------------------------------------------------\r\n    /// @notice Query if a contract implements an interface\r\n    /// @param interfaceID The interface identifier, as specified in ERC-165\r\n    /// @dev Interface identification is specified in ERC-165. This function\r\n    ///  uses less than 30,000 gas.\r\n    /// @return bool True if the contract implements `interfaceID` and\r\n    ///  `interfaceID` is not 0xffffffff\r\n    //-------------------------------------------------------------------------\r\n    function supportsInterface(bytes4 interfaceID) external pure returns (bool) {\r\n        return (\r\n            interfaceID == 0x01ffc9a7 || // ERC165\r\n            interfaceID == 0x80ac58cd || // ERC721\r\n            interfaceID == 0x5b5e139f // ERC721Metadata\r\n        );\r\n    }\r\n\r\n\r\n    //=========================================================================\r\n    // PUBLIC VIEW FUNCTIONS\r\n    //=========================================================================\r\n    //-------------------------------------------------------------------------\r\n    /// @notice Get the number of valid NFTs tracked by this contract, where\r\n    ///  each one of them has an assigned and queryable owner not equal to\r\n    ///  the zero address.\r\n    /// @return uint Total number of valid NFTs tracked by this contract.\r\n    //-------------------------------------------------------------------------\r\n    function totalSupply() external view returns (uint) {\r\n        return _tokenData.length - _burnedTokens - 1;\r\n    }\r\n\r\n    //-------------------------------------------------------------------------\r\n    /// @notice Find the owner of an NFT\r\n    /// @dev NFTs assigned to zero address are considered invalid, and queries\r\n    ///  about them do throw.\r\n    /// @param _tokenId The identifier for an NFT\r\n    /// @return address The address of the owner of the NFT\r\n    //-------------------------------------------------------------------------\r\n    function ownerOf(uint _tokenId)\r\n        external\r\n        view\r\n        exists(_tokenId)\r\n        returns (address)\r\n    {\r\n        return _tokenData[_tokenId].tokenOwner;\r\n    }\r\n\r\n    //-------------------------------------------------------------------------\r\n    /// @notice Count all NFTs assigned to an owner\r\n    /// @dev NFTs assigned to the zero address are considered invalid, and\r\n    ///  this function throws for queries about the zero address.\r\n    /// @param _owner The address of the owner to query\r\n    /// @return uint The number of NFTs owned by `_owner`, possibly zero\r\n    //-------------------------------------------------------------------------\r\n    function balanceOf(address _owner) external view returns (uint) {\r\n        require (_owner != address(0), \"Invalid balance query\");\r\n        return _ownerData[_owner].tokensOwned.length;\r\n    }\r\n\r\n    //-------------------------------------------------------------------------\r\n    /// @notice Enumerate NFTs assigned to an owner\r\n    /// @dev Throws if `_index` >= `balanceOf(_owner)` or if\r\n    ///  `_owner` is the zero address, representing invalid NFTs.\r\n    /// @param _owner  The address of the owner to query\r\n    /// @param _index A counter less than `balanceOf(_owner)`\r\n    /// @return The token identifier for the `_index`th NFT assigned to\r\n    ///  `_owner`, (sort order not specified)\r\n    //-------------------------------------------------------------------------\r\n    function tokenOfOwnerByIndex(address _owner, uint256 _index)\r\n        external\r\n        view\r\n        returns (uint24)\r\n    {\r\n        require (\r\n            _owner != address(0),\r\n            \"ERC721Enumerable: Invalid owner address\"\r\n        );\r\n        require (\r\n            _index < _ownerData[_owner].tokensOwned.length,\r\n            \"ERC721Enumerable: Invalid index\"\r\n        );\r\n        return _ownerData[_owner].tokensOwned[_index];\r\n    }\r\n\r\n    //-------------------------------------------------------------------------\r\n    /// @notice Enumerate NFTs assigned to an owner\r\n    /// @dev Throws if `_index` >= `balanceOf(_owner)` or if\r\n    ///  `_owner` is the zero address, representing invalid NFTs.\r\n    /// @param _owner  The address of the owner to query\r\n    /// @return uint24[] The token identifiers for the tokens owned by `_owner`,\r\n    ///   (sort order not specified)\r\n    //-------------------------------------------------------------------------\r\n    function tokensOfOwner(address _owner)\r\n        external\r\n        view\r\n        returns (uint24[] memory)\r\n    {\r\n        require (\r\n            _owner != address(0),\r\n            \"ERC721Enumerable: Invalid owner address\"\r\n        );\r\n        return _ownerData[_owner].tokensOwned;\r\n    }\r\n\r\n    //-------------------------------------------------------------------------\r\n    /// @notice Get the approved address for a single NFT\r\n    /// @dev Throws if `_tokenId` is not a valid NFT.\r\n    /// @param _tokenId The NFT to find the approved address for\r\n    /// @return address The approved address for this NFT, or the zero address\r\n    ///  if there is none\r\n    //-------------------------------------------------------------------------\r\n    function getApproved(uint _tokenId)\r\n        external\r\n        view\r\n        exists(_tokenId)\r\n        returns (address)\r\n    {\r\n        return _tokenApprovals[_tokenId];\r\n    }\r\n\r\n    //-------------------------------------------------------------------------\r\n    /// @notice Query if an address is an authorized operator for another address\r\n    /// @param _owner The address that owns the NFTs\r\n    /// @param _operator The address that acts on behalf of the owner\r\n    /// @return bool True if `_operator` is an approved operator for `_owner`\r\n    //-------------------------------------------------------------------------\r\n    function isApprovedForAll(address _owner, address _operator)\r\n        external\r\n        view\r\n        returns (bool)\r\n    {\r\n        return _ownerData[_owner].operatorApprovals[_operator];\r\n    }\r\n    \r\n    //-------------------------------------------------------------------------\r\n    /// @notice A distinct Uniform Resource Identifier (URI) for a given token.\r\n    /// @dev Throws if `_tokenId` is not a valid NFT\r\n    /// @param _tokenId The identifier for an NFT\r\n    /// @return string The URI of the specified token\r\n    //-------------------------------------------------------------------------\r\n    function tokenURI(uint256 _tokenId)\r\n        public\r\n        view\r\n        virtual\r\n        returns (string memory);\r\n\r\n\r\n    //=========================================================================\r\n    // INTERNAL / PRIVATE FUNCTIONS\r\n    //=========================================================================\r\n    function _transfer(address _to, uint _tokenId) private {\r\n        TokenData storage tokenData = _tokenData[_tokenId];\r\n        address from = tokenData.tokenOwner;\r\n        \r\n        // modify `from` owner data\r\n        OwnerData storage ownerData = _ownerData[from];\r\n        uint numberOfTokensOwned = ownerData.tokensOwned.length;\r\n        if (tokenData.tokenIndex < numberOfTokensOwned - 1) {\r\n            uint24 lastOwnedToken = ownerData.tokensOwned[numberOfTokensOwned - 1];\r\n            // swap token to transfer with last owned token in ownerData array\r\n            ownerData.tokensOwned[tokenData.tokenIndex] = lastOwnedToken;\r\n            // set index of last owned token to the swapped index\r\n            _tokenData[lastOwnedToken].tokenIndex = tokenData.tokenIndex;\r\n        }\r\n        // pop the owned token array\r\n        ownerData.tokensOwned.pop();\r\n\r\n        // modify `to` owner data\r\n        if (_to != address(0)) {\r\n            // set token index to the new owner's token position\r\n            tokenData.tokenIndex = uint16(_ownerData[_to].tokensOwned.length);\r\n            // add token to new owner's owned token array\r\n            _ownerData[_to].tokensOwned.push(uint24(_tokenId));\r\n        }\r\n        \r\n        // set the ownership of the token\r\n        tokenData.tokenOwner = _to;\r\n\r\n        // reset approval\r\n        _tokenApprovals[_tokenId] = address(0);\r\n\r\n        // emit transfer event\r\n        emit Transfer(from, _to, _tokenId);\r\n    }\r\n\r\n    //-------------------------------------------------------------------------\r\n    /// @dev Safely mints a new token and transfers it to `to`. If `to` refers\r\n    ///  to a smart contract, it must implement {IERC721Receiver-onERC721Received},\r\n    ///  which is called upon a safe transfer. Emits a {Transfer} event.\r\n    /// @param _to target address that will receive the token\r\n    /// @param _extraData arbitrary data to be handled by the\r\n    ///  implementation contract.\r\n    /// @param _data arbitrary data to be handled by the receiver.\r\n    //-------------------------------------------------------------------------\r\n    function _safeMint(address _to, uint80 _extraData, bytes memory _data)\r\n        internal\r\n    {\r\n        uint24 tokenId = uint24(_tokenData.length);\r\n        uint16 tokenIndex = uint16(_ownerData[_to].tokensOwned.length);\r\n        _tokenData.push(TokenData(_to, tokenIndex, _extraData));\r\n\r\n        // add token to new owner's owned token array\r\n        _ownerData[_to].tokensOwned.push(tokenId);\r\n\r\n        // emit transfer event\r\n        emit Transfer(address(0), _to, tokenId);\r\n\r\n        require(\r\n            _checkOnERC721Received(address(0), _to, tokenId, _data),\r\n            \"ERC721: transfer to non ERC721Receiver implementer\"\r\n        );\r\n    }    \r\n\r\n    //-------------------------------------------------------------------------\r\n    /// @dev Equivalent to `_safeMint(to, quantity, '')`.\r\n    //-------------------------------------------------------------------------\r\n    function _safeMint(address _to, uint80 _extraData) internal {\r\n        _safeMint(_to, _extraData, \"\");\r\n    }\r\n\r\n    //-------------------------------------------------------------------------\r\n    /// @dev Destroys `tokenId`. The approval is cleared when the token is\r\n    ///  burned. This is an internal function that does not check if the sender\r\n    ///  is authorized to operate on the token. Throws if `tokenId` does not\r\n    ///  exist. Emits a {Transfer} event.\r\n    /// @param _tokenId The token to burn\r\n    //-------------------------------------------------------------------------\r\n    function _burn(uint _tokenId) internal exists(_tokenId) {\r\n        _tokenApprovals[_tokenId] = address(0);\r\n        _transfer(address(0), _tokenId);\r\n        ++_burnedTokens;\r\n    }\r\n\r\n    //-------------------------------------------------------------------------\r\n    /// @dev Internal function to invoke {IERC721Receiver-onERC721Received} on\r\n    /// a target address.\r\n    /// @param _from address representing the previous owner of the given token ID\r\n    /// @param _to target address that will receive the token\r\n    /// @param _tokenId uint256 ID of the token to be transferred\r\n    /// @param _data bytes optional data to send along with the call\r\n    /// @return bool whether the call correctly returned the expected magic value\r\n    //-------------------------------------------------------------------------\r\n    function _checkOnERC721Received(\r\n        address _from,\r\n        address _to,\r\n        uint256 _tokenId,\r\n        bytes memory _data\r\n    ) private returns (bool) {\r\n        if (_to.code.length > 0) {\r\n            try IERC721Receiver(_to).onERC721Received(msg.sender, _from, _tokenId, _data) returns (bytes4 retval) {\r\n                return retval == IERC721Receiver.onERC721Received.selector;\r\n            } catch (bytes memory reason) {\r\n                if (reason.length == 0) {\r\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\r\n                } else {\r\n                    /// @solidity memory-safe-assembly\r\n                    assembly {\r\n                        revert(add(32, reason), mload(reason))\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n}\r\n// File: @openzeppelin/contracts/utils/Context.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/access/Ownable.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the sender is not the owner.\r\n     */\r\n    function _checkOwner() internal view virtual {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n// File: Forge Token/ForgeToken.sol\r\n\r\n// Contract based on https://docs.openzeppelin.com/contracts/4.x/erc721\r\n\r\npragma solidity ^0.8.4;\r\n\r\n\r\n\r\ninterface Forge_Metadata {\r\n    function tokenURI(uint _tokenId) external view returns(string memory);\r\n}\r\n\r\ninterface IRandomizer {\r\n    function getRandomSeed(\r\n        address userAddress,\r\n        uint256 nonce,\r\n        uint256 lastExtradata,\r\n        bytes calldata signature\r\n    ) external view returns (bytes32);\r\n}\r\n\r\n//-----------------------------------------------------------------------------\r\n/// @title FORGE LAUNCH TOKEN\r\n//-----------------------------------------------------------------------------\r\ncontract ForgeToken is Forge_ERC721, Ownable {\r\n\r\n    struct TokenAttributes {\r\n        uint16 xp;\r\n        bool isSpecialVariant;\r\n    }\r\n\r\n    uint private constant _NUM_XP_VALUES = 10;\r\n    // [0064 = 100, 01F4 = 500, 03E8 = 1000, 1388 = 5000, 1D4C = 7500, 2710 = 10000, 3A98 = 15000, 4E20 = 20000, 61A8 = 25000, 7FF8 = 32760]\r\n    bytes32 private constant _XP_VALUES = 0x006401F403E813881D4C27103A984E2061A87FF8000000000000000000000000;\r\n    // 02 = ~1%, 05 = ~2%, 0D = ~5%, 1A = ~10%, 33 = ~20%\r\n    bytes32 private constant _XP_OCCURRENCE_RATES = 0x1A3333331A1A0D05050200000000000000000000000000000000000000000000;\r\n    // 13/256 = ~5%\r\n    uint8 private constant _SPECIAL_VARIANT_RATE = 13;\r\n\r\n    Forge_Metadata public metadataContract = Forge_Metadata(0x31d64a222ad81004613C4Bb830733438877D8E21);\r\n\r\n    address public minterAddress = 0x86FeD702bCAF26f0b41476a58d4E88242654146E;\r\n\r\n    // Oct 16 2023 at 12:30:00 UTC\r\n    uint256 public dropStartTime = 1697459400;\r\n\r\n    // Approx 6 months\r\n    uint256 public dropDuration = 4380 hours;\r\n\r\n    uint256 public supplyLimit = 3333;\r\n    uint256 public reservedMints = 433;\r\n\r\n\r\n    // In order to ensure each owner only mints once per signature, each mint\r\n    // is assigned a unique nonce. Subsequent mint attempts with the same\r\n    // nonce will fail.\r\n    mapping(uint256 => bool) public usedNonces;\r\n\r\n    // Randomizer contract\r\n    IRandomizer private _randomizerContract;\r\n    uint256 private _specialVariants = 0;\r\n\r\n    //-------------------------------------------------------------------------\r\n    /// @dev This emits when XP is burned from a Forge Token\r\n    //-------------------------------------------------------------------------\r\n    event BurnXp(uint _tokenId, uint16 _amountBurned);\r\n\r\n    constructor() Forge_ERC721(\"ForgeToken\", \"FORGE\") {}\r\n\r\n    //-------------------------------------------------------------------------\r\n    /// @notice Sets a new address to be the Minter\r\n    /// @dev Throws if sender is not the contract owner\r\n    /// @param _newMinter The new address to be the Minter\r\n    //-------------------------------------------------------------------------\r\n    function setMinterAddress(address _newMinter) external onlyOwner {\r\n        minterAddress = _newMinter;\r\n    }\r\n\r\n    //-------------------------------------------------------------------------\r\n    /// @notice Replaces the current metadata contract reference with a new one\r\n    /// @dev Throws if sender is not the contract owner\r\n    /// @param _contractAddress The address of the metadata contract\r\n    //-------------------------------------------------------------------------\r\n    function setMetadataContract(address _contractAddress) external onlyOwner {\r\n        metadataContract = Forge_Metadata(_contractAddress);\r\n    }\r\n\r\n    //-------------------------------------------------------------------------\r\n    /// @notice Sets the randomizer contract address\r\n    /// @dev Throws if sender is not the contract owner\r\n    /// @param _contractAddress The address of the randomizer contract\r\n    //-------------------------------------------------------------------------\r\n    function setRandomizerContract(address _contractAddress) external onlyOwner {\r\n        _randomizerContract = IRandomizer(_contractAddress);\r\n    }\r\n\r\n    //-------------------------------------------------------------------------\r\n    /// @notice Sets the start time where minting is allowed\r\n    /// @dev Throws if sender is not the contract owner\r\n    /// @param _dropStartTime The new timestamp in seconds\r\n    //-------------------------------------------------------------------------\r\n    function setDropStartTime(uint256 _dropStartTime) external onlyOwner {\r\n        require(\r\n            _dropStartTime >= block.timestamp,\r\n            \"Drop start time must be later than now\"\r\n        );\r\n        dropStartTime = _dropStartTime;\r\n    }\r\n\r\n    //-------------------------------------------------------------------------\r\n    /// @notice Sets the duration where minting is allowed\r\n    /// @dev Throws if sender is not the contract owner\r\n    /// @param _dropDuration The new duration in seconds\r\n    //-------------------------------------------------------------------------\r\n    function setDropDuration(uint256 _dropDuration) external onlyOwner {\r\n        require (_dropDuration > 0, \"Drop duration must be greater than zero\");\r\n        dropDuration = _dropDuration;\r\n    }\r\n\r\n    //-------------------------------------------------------------------------\r\n    /// @notice Sets the supply limit to a higher number\r\n    /// @dev Throws if `_newSupplyLimit` is less than current supply limit.\r\n    ///  Throws if sender is not the contract owner.\r\n    /// @param _newSupplyLimit The new supply limit\r\n    //-------------------------------------------------------------------------\r\n    function increaseSupplyLimit(uint256 _newSupplyLimit) external onlyOwner {\r\n        require (\r\n            block.timestamp <= dropStartTime + dropDuration,\r\n            \"Drop ended, increasing supply limit no longer allowed\"\r\n        );\r\n        require (\r\n            _newSupplyLimit > supplyLimit, \r\n            \"New supply limit must be greater than previous supply limit\"\r\n        );\r\n        supplyLimit = _newSupplyLimit;\r\n    }\r\n\r\n    //-------------------------------------------------------------------------\r\n    /// @notice Mints a new Forge Badge for the sender.\r\n    ///  Validates using a signature signed by the minter\r\n    ///  The token ID of the new badge is determined by the totalSupply when\r\n    ///  minted. Randomly rolls XP and specialVariant value.\r\n    /// @dev Throws if there's a signer address mismatch\r\n    /// @param _nonce A unique ID used to guard against double-mints\r\n    /// @param _sig The signature of the recipient of the minted NFT\r\n    //-------------------------------------------------------------------------\r\n    function safeMint(uint256 _nonce, bytes memory _sig) external {\r\n        require(block.timestamp >= dropStartTime, \"Drop not started\");\r\n        require(block.timestamp <= dropStartTime + dropDuration, \"Drop ended\");\r\n        require(tx.origin == msg.sender, \"Transaction origin not from sender\");\r\n        require(\r\n            _tokenData.length - 1 < supplyLimit - reservedMints,\r\n            \"Collection has minted out\"\r\n        );\r\n        require(!usedNonces[_nonce], \"Nonce already used\");\r\n\r\n        // validate message\r\n        bytes32 message = _generateMessage(msg.sender, _nonce, address(this));\r\n        require(\r\n            _recoverSigner(message, _sig) == minterAddress,\r\n            \"Signer address mismatch\"\r\n        );\r\n\r\n        // Generate random seed\r\n        bytes32 randomSeed = _randomizerContract.getRandomSeed(\r\n            msg.sender,\r\n            _nonce,\r\n            uint256(_tokenData[_tokenData.length - 1].extraData),\r\n            _sig\r\n        );\r\n\r\n        // Roll attributes\r\n        uint16 xpValue = _calculateXpValue(uint8(randomSeed[0]));\r\n        // Also check if used special variants are less than 5% of supply limit\r\n        bool isSpecialVariant = (\r\n            uint8(randomSeed[1]) < _SPECIAL_VARIANT_RATE &&\r\n            _specialVariants < supplyLimit * 13 / 256\r\n        );\r\n        if (isSpecialVariant) {\r\n            ++_specialVariants;\r\n        }\r\n\r\n        uint40 packedAttributes = (uint24(xpValue) << 8) + (isSpecialVariant ? 1 : 0);\r\n\r\n        // mint the new token\r\n        usedNonces[_nonce] = true;\r\n        _safeMint(msg.sender, packedAttributes);\r\n    }\r\n\r\n    //-------------------------------------------------------------------------\r\n    /// @notice Mints a new Forge Badge for a given address only by the minter.\r\n    ///  The token ID of the new badge is determined by the totalSupply when\r\n    ///  minted. Randomly rolls XP and specialVariant value.\r\n    /// @dev Throws if there's a signer address mismatch\r\n    /// @param _nonce A unique ID used to guard against double-mints\r\n    /// @param _to address of the recipient of the minted NFT\r\n    //-------------------------------------------------------------------------\r\n    function safeMint(uint256 _nonce, address _to) external {\r\n        require(msg.sender == minterAddress, \"Only minterAddress can mint\");\r\n        require(reservedMints > 0, \"No more tokens in reserve\");\r\n        require(!usedNonces[_nonce], \"Nonce already used\");\r\n\r\n        // Generate random seed\r\n        bytes32 randomSeed = keccak256(\r\n            abi.encodePacked(\r\n                block.timestamp,\r\n                _to,\r\n                _tokenData.length\r\n            )\r\n        );\r\n\r\n        // Roll attributes\r\n        uint16 xpValue = _calculateXpValue(uint8(randomSeed[0]));\r\n        bool isSpecialVariant = uint8(randomSeed[1]) < _SPECIAL_VARIANT_RATE;\r\n        uint40 packedAttributes = (uint24(xpValue) << 8) + (isSpecialVariant ? 1 : 0);\r\n\r\n        // mint the new token\r\n        usedNonces[_nonce] = true;\r\n        _safeMint(_to, packedAttributes);\r\n\r\n        --reservedMints;\r\n    }\r\n\r\n    //-------------------------------------------------------------------------\r\n    /// @notice Burns an existing Forge Badge. Its XP value will be emitted as\r\n    ///  an event.\r\n    /// @dev Throws if sender is not the owner of the specified token.\r\n    /// @param _tokenId The ID of the token to burn\r\n    //-------------------------------------------------------------------------\r\n    function burn(uint _tokenId) external {\r\n        require (\r\n            msg.sender == _tokenData[_tokenId].tokenOwner,\r\n            \"Sender must own token to burn\"\r\n        );\r\n\r\n        TokenAttributes memory attributes = tokenAttributes(_tokenId);\r\n\r\n        uint16 amountBurned = attributes.xp;\r\n\r\n        _burn(_tokenId);\r\n\r\n        emit BurnXp(_tokenId, amountBurned);\r\n    }\r\n\r\n    //-------------------------------------------------------------------------\r\n    /// @notice Gets the attributes of a given token\r\n    /// @param _tokenId The ID of the token to query\r\n    //-------------------------------------------------------------------------\r\n    function tokenAttributes(uint _tokenId) \r\n        public\r\n        view\r\n        exists(_tokenId)\r\n        returns(TokenAttributes memory attributes)\r\n    {\r\n        uint tokenData = _tokenData[_tokenId].extraData;\r\n        // extraData ends in 1 if the token is a special variant\r\n        attributes.isSpecialVariant = tokenData % 2 == 1;\r\n        attributes.xp = uint16(tokenData >> 8);\r\n    }\r\n\r\n    //-------------------------------------------------------------------------\r\n    /// @dev delegates tokenURI to external smart contract\r\n    //-------------------------------------------------------------------------\r\n    function tokenURI(uint _tokenId)\r\n        public\r\n        view\r\n        override\r\n        returns (string memory)\r\n    {\r\n        return metadataContract.tokenURI(_tokenId);\r\n    }\r\n\r\n    //-------------------------------------------------------------------------\r\n    // Takes a random number from 0 to 255 and returns an xp value\r\n    //-------------------------------------------------------------------------\r\n    function _calculateXpValue(uint8 _rand)\r\n        private\r\n        pure\r\n        returns (uint16)\r\n    {\r\n        // get index from occurrence rates\r\n        uint index;\r\n        for (uint i = 0; i < _NUM_XP_VALUES; ++i) {\r\n            if (_rand < uint8(_XP_OCCURRENCE_RATES[i])) {\r\n                index = i;\r\n                break;\r\n            }\r\n            _rand -= uint8(_XP_OCCURRENCE_RATES[i]);\r\n        }\r\n\r\n        // convert index into a bytes16 value\r\n        uint16 xpValue = uint16(uint8(_XP_VALUES[index * 2])) << 8;\r\n        xpValue += uint8(_XP_VALUES[index * 2 + 1]);\r\n\r\n        return xpValue;\r\n    }\r\n\r\n    //-------------------------------------------------------------------------\r\n    // Takes a message and signature and retrieves the signer address\r\n    //-------------------------------------------------------------------------\r\n    function _recoverSigner(bytes32 _message, bytes memory _sig)\r\n        private\r\n        pure\r\n        returns (address)\r\n    {\r\n        require(_sig.length == 65, \"Length of signature must be 65\");\r\n\r\n        // split signature\r\n        uint8 v;\r\n        bytes32 r;\r\n        bytes32 s;\r\n        assembly {\r\n            // first 32 bytes, after the length prefix\r\n            r := mload(add(_sig, 32))\r\n            // second 32 bytes\r\n            s := mload(add(_sig, 64))\r\n            // final byte (first byte of the next 32 bytes)\r\n            v := byte(0, mload(add(_sig, 96)))\r\n        }\r\n\r\n        // return the address from the given signature by calculating a\r\n        // recovery function of ECDSA\r\n        return ecrecover(_message, v, r, s);\r\n    }\r\n\r\n    //-------------------------------------------------------------------------\r\n    // Builds an encoded message with a prefixed hash to mimic the behavior\r\n    // of eth_sign.\r\n    //-------------------------------------------------------------------------\r\n    function _generateMessage(address _sender, uint _nonce, address _contract)\r\n        private\r\n        pure\r\n        returns (bytes32 message)\r\n    {\r\n        message = keccak256(abi.encodePacked(_sender, _nonce, _contract));\r\n        message = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", message));\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"_amountBurned\",\"type\":\"uint16\"}],\"name\":\"BurnXp\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_approved\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dropDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dropStartTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newSupplyLimit\",\"type\":\"uint256\"}],\"name\":\"increaseSupplyLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"metadataContract\",\"outputs\":[{\"internalType\":\"contract Forge_Metadata\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minterAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reservedMints\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nonce\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"safeMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_sig\",\"type\":\"bytes\"}],\"name\":\"safeMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_dropDuration\",\"type\":\"uint256\"}],\"name\":\"setDropDuration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_dropStartTime\",\"type\":\"uint256\"}],\"name\":\"setDropStartTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contractAddress\",\"type\":\"address\"}],\"name\":\"setMetadataContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newMinter\",\"type\":\"address\"}],\"name\":\"setMinterAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contractAddress\",\"type\":\"address\"}],\"name\":\"setRandomizerContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"supplyLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenAttributes\",\"outputs\":[{\"components\":[{\"internalType\":\"uint16\",\"name\":\"xp\",\"type\":\"uint16\"},{\"internalType\":\"bool\",\"name\":\"isSpecialVariant\",\"type\":\"bool\"}],\"internalType\":\"struct ForgeToken.TokenAttributes\",\"name\":\"attributes\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"internalType\":\"uint24\",\"name\":\"\",\"type\":\"uint24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"tokensOfOwner\",\"outputs\":[{\"internalType\":\"uint24[]\",\"name\":\"\",\"type\":\"uint24[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"usedNonces\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "ForgeToken", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://47082ee072ea47773af03c17deb69717821bda263ea33adb35f23d7990a7ff93"}