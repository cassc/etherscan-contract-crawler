{"SourceCode": "{\"g2.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface IERC20 {\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to {approve}. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the value of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the value of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves a `value` amount of tokens from the caller\\u0027s account to `to`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transfer(address to, uint256 value) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when {approve} or {transferFrom} are called.\\r\\n     */\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\r\\n     * caller\\u0027s tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address spender, uint256 value) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\r\\n     * allowance mechanism. `value` is then deducted from the caller\\u0027s\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\r\\n}\\r\\n\\r\\npragma solidity ^0.8.7;\\r\\n\\r\\nimport \\\"./VRFCoordinatorV2Interface.sol\\\";\\r\\nimport \\\"./VRFConsumerBaseV2.sol\\\";\\r\\n\\r\\ncontract Bet is VRFConsumerBaseV2 {\\r\\n    VRFCoordinatorV2Interface COORDINATOR;\\r\\n\\r\\n    uint64 s_subscriptionId;\\r\\n\\r\\n    IERC20 public token;\\r\\n\\r\\n    address vrfCoordinator = 0x271682DEB8C4E0901D1a1550aD2e64D568E69909;\\r\\n\\r\\n    bytes32 keyHash = 0xff8dedfbfa60af186cf3c830acbc32c05aae823045ae5ea7da1e45fbfaba4f92;\\r\\n\\r\\n    uint32 callbackGasLimit = 500000;\\r\\n\\r\\n    uint16 requestConfirmations = 3;\\r\\n    uint256 public vRes ; \\r\\n\\r\\n    uint32 numWords =  1;\\r\\n\\r\\n    uint256[] public s_randomWords;\\r\\n    uint256 public s_requestId;\\r\\n    uint16 public setterN = 0; \\r\\n    uint256 public maxbet = 250000*10**18;\\r\\n\\r\\n\\r\\n    mapping(uint256 =\\u003e address) private _wagerInit; \\r\\n    mapping(address =\\u003e uint256) private _wagerInitAmount;\\r\\n    mapping(address =\\u003e uint16) public LatestRes; \\r\\n    mapping(address =\\u003e uint16) private CanPlay ; \\r\\n\\r\\n    \\r\\n    address s_owner;  \\r\\n    address public creator =  0x3945A69a6635676B031702f411639c5C41262225;\\r\\n\\r\\n    constructor(uint64 subscriptionId) VRFConsumerBaseV2(vrfCoordinator) {\\r\\n        COORDINATOR = VRFCoordinatorV2Interface(vrfCoordinator);\\r\\n        s_owner = msg.sender;\\r\\n        s_subscriptionId = subscriptionId;\\r\\n        \\r\\n    }\\r\\n    function SetToken(IERC20 _token)public {\\r\\n        require(msg.sender == creator);\\r\\n        require(setterN == 0);\\r\\n        token = _token;\\r\\n        setterN = 1 ; \\r\\n    }\\r\\n\\r\\n    function ChangeMaxBet(uint256 change_value)public {\\r\\n        require(msg.sender== creator);\\r\\n        maxbet = change_value;\\r\\n    }\\r\\n\\r\\n    \\r\\n    function Changeclimit(uint32 change_value)public {\\r\\n        require(msg.sender== creator);\\r\\n        callbackGasLimit = change_value;\\r\\n    }\\r\\n\\r\\n    function Changekey(bytes32 change_value)public {\\r\\n        require(msg.sender== creator);\\r\\n        keyHash = change_value;\\r\\n    }\\r\\n\\r\\n    function retrieveERC20Asset(address assetAddress) external {\\r\\n        // Ensure that only the creator can call this function\\r\\n        require(msg.sender == creator, \\\"Only the creator can retrieve assets\\\");\\r\\n\\r\\n        IERC20 asset = IERC20(assetAddress);\\r\\n        uint256 balance = asset.balanceOf(address(this));\\r\\n        \\r\\n        // If there\\u0027s any asset balance, transfer it to the creator\\r\\n        require(asset.transfer(creator, balance), \\\"Transfer failed\\\");\\r\\n    }\\r\\n\\r\\n\\r\\n    function requestRandomWords(uint256 _amount) external {\\r\\n        require(CanPlay[msg.sender]==0, \\u0027bet already placed\\u0027);\\r\\n        require(_amount \\u003cmaxbet, \\u0027too big\\u0027);\\r\\n        require((_amount/10000)*10000 == _amount, \\u0027too small\\u0027);\\r\\n        require(token.balanceOf(msg.sender) \\u003e= _amount);\\r\\n        require(token.balanceOf(address(this)) \\u003e= _amount*6);\\r\\n        token.transferFrom(msg.sender,address(this) , _amount);\\r\\n\\r\\n        s_requestId = COORDINATOR.requestRandomWords(\\r\\n            keyHash,\\r\\n            s_subscriptionId,\\r\\n            requestConfirmations,\\r\\n            callbackGasLimit,\\r\\n            numWords\\r\\n        );\\r\\n    \\r\\n        _wagerInit[s_requestId] = msg.sender;\\r\\n        _wagerInitAmount[msg.sender] = _amount;   \\r\\n\\r\\n        LatestRes[msg.sender] = 0 ; \\r\\n        CanPlay[msg.sender] = 1; \\r\\n    }\\r\\n\\r\\n    function fulfillRandomWords  (\\r\\n       uint256 s_requestId, /* requestId */\\r\\n       uint256[] memory randomWords\\r\\n    ) internal override {\\r\\n    uint256 s_randomRange = (randomWords[0] % 100) + 1;\\r\\n    _settleBet(s_requestId,s_randomRange);\\r\\n   }\\r\\n\\r\\n   function _settleBet(uint256 requestId, uint256 randomNumber) private {\\r\\n        address _user = _wagerInit[requestId];\\r\\n        require(_user != address(0), \\u0027 record does not exist\\u0027);\\r\\n\\r\\n        uint256 _amountWagered = _wagerInitAmount[_user];\\r\\n\\r\\n        vRes = randomNumber ; \\r\\n            \\r\\n        if (randomNumber \\u003e 40 \\u0026\\u0026 randomNumber \\u003c 70){\\r\\n            //10 percent\\r\\n            uint WinAmount = (_amountWagered/100) *10 ; \\r\\n            token.transfer( _user, _amountWagered + WinAmount);\\r\\n            LatestRes[_user] = 1 ;\\r\\n            \\r\\n        } else if (randomNumber \\u003e 69 \\u0026\\u0026 randomNumber \\u003c 80 ){\\r\\n            //60 percent\\r\\n            uint WinAmount = (_amountWagered/100) *60 ; \\r\\n            token.transfer( _user, _amountWagered + WinAmount);\\r\\n            LatestRes[_user] = 2 ;\\r\\n\\r\\n        } else if (randomNumber \\u003e 79 \\u0026\\u0026 randomNumber \\u003c 95){\\r\\n            //2x\\r\\n            uint WinAmount = _amountWagered*2;\\r\\n            token.transfer( _user, WinAmount);\\r\\n            LatestRes[_user] = 3 ;\\r\\n\\r\\n        } else if(randomNumber \\u003e 94 \\u0026\\u0026 randomNumber \\u003c 98){\\r\\n            //3x\\r\\n            uint WinAmount = _amountWagered*3;\\r\\n            token.transfer( _user, WinAmount);\\r\\n            LatestRes[_user] = 4 ;\\r\\n\\r\\n        } else if(randomNumber\\u003e97){\\r\\n            //5x\\r\\n            uint WinAmount = _amountWagered*5;\\r\\n            token.transfer( _user, WinAmount);\\r\\n            LatestRes[_user] = 5 ;\\r\\n        }\\r\\n        else {\\r\\n            LatestRes[_user] =9 ; \\r\\n        }\\r\\n        CanPlay[_user] = 0; \\r\\n        }\\r\\n\\r\\n        \\r\\n}\"},\"VRFConsumerBaseV2.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\n/** ****************************************************************************\\r\\n * @notice Interface for contracts using VRF randomness\\r\\n * *****************************************************************************\\r\\n * @dev PURPOSE\\r\\n *\\r\\n * @dev Reggie the Random Oracle (not his real job) wants to provide randomness\\r\\n * @dev to Vera the verifier in such a way that Vera can be sure he\\u0027s not\\r\\n * @dev making his output up to suit himself. Reggie provides Vera a public key\\r\\n * @dev to which he knows the secret key. Each time Vera provides a seed to\\r\\n * @dev Reggie, he gives back a value which is computed completely\\r\\n * @dev deterministically from the seed and the secret key.\\r\\n *\\r\\n * @dev Reggie provides a proof by which Vera can verify that the output was\\r\\n * @dev correctly computed once Reggie tells it to her, but without that proof,\\r\\n * @dev the output is indistinguishable to her from a uniform random sample\\r\\n * @dev from the output space.\\r\\n *\\r\\n * @dev The purpose of this contract is to make it easy for unrelated contracts\\r\\n * @dev to talk to Vera the verifier about the work Reggie is doing, to provide\\r\\n * @dev simple access to a verifiable source of randomness. It ensures 2 things:\\r\\n * @dev 1. The fulfillment came from the VRFCoordinator\\r\\n * @dev 2. The consumer contract implements fulfillRandomWords.\\r\\n * *****************************************************************************\\r\\n * @dev USAGE\\r\\n *\\r\\n * @dev Calling contracts must inherit from VRFConsumerBase, and can\\r\\n * @dev initialize VRFConsumerBase\\u0027s attributes in their constructor as\\r\\n * @dev shown:\\r\\n *\\r\\n * @dev   contract VRFConsumer {\\r\\n * @dev     constructor(\\u003cother arguments\\u003e, address _vrfCoordinator, address _link)\\r\\n * @dev       VRFConsumerBase(_vrfCoordinator) public {\\r\\n * @dev         \\u003cinitialization with other arguments goes here\\u003e\\r\\n * @dev       }\\r\\n * @dev   }\\r\\n *\\r\\n * @dev The oracle will have given you an ID for the VRF keypair they have\\r\\n * @dev committed to (let\\u0027s call it keyHash). Create subscription, fund it\\r\\n * @dev and your consumer contract as a consumer of it (see VRFCoordinatorInterface\\r\\n * @dev subscription management functions).\\r\\n * @dev Call requestRandomWords(keyHash, subId, minimumRequestConfirmations,\\r\\n * @dev callbackGasLimit, numWords),\\r\\n * @dev see (VRFCoordinatorInterface for a description of the arguments).\\r\\n *\\r\\n * @dev Once the VRFCoordinator has received and validated the oracle\\u0027s response\\r\\n * @dev to your request, it will call your contract\\u0027s fulfillRandomWords method.\\r\\n *\\r\\n * @dev The randomness argument to fulfillRandomWords is a set of random words\\r\\n * @dev generated from your requestId and the blockHash of the request.\\r\\n *\\r\\n * @dev If your contract could have concurrent requests open, you can use the\\r\\n * @dev requestId returned from requestRandomWords to track which response is associated\\r\\n * @dev with which randomness request.\\r\\n * @dev See \\\"SECURITY CONSIDERATIONS\\\" for principles to keep in mind,\\r\\n * @dev if your contract could have multiple requests in flight simultaneously.\\r\\n *\\r\\n * @dev Colliding `requestId`s are cryptographically impossible as long as seeds\\r\\n * @dev differ.\\r\\n *\\r\\n * *****************************************************************************\\r\\n * @dev SECURITY CONSIDERATIONS\\r\\n *\\r\\n * @dev A method with the ability to call your fulfillRandomness method directly\\r\\n * @dev could spoof a VRF response with any random value, so it\\u0027s critical that\\r\\n * @dev it cannot be directly called by anything other than this base contract\\r\\n * @dev (specifically, by the VRFConsumerBase.rawFulfillRandomness method).\\r\\n *\\r\\n * @dev For your users to trust that your contract\\u0027s random behavior is free\\r\\n * @dev from malicious interference, it\\u0027s best if you can write it so that all\\r\\n * @dev behaviors implied by a VRF response are executed *during* your\\r\\n * @dev fulfillRandomness method. If your contract must store the response (or\\r\\n * @dev anything derived from it) and use it later, you must ensure that any\\r\\n * @dev user-significant behavior which depends on that stored value cannot be\\r\\n * @dev manipulated by a subsequent VRF request.\\r\\n *\\r\\n * @dev Similarly, both miners and the VRF oracle itself have some influence\\r\\n * @dev over the order in which VRF responses appear on the blockchain, so if\\r\\n * @dev your contract could have multiple VRF requests in flight simultaneously,\\r\\n * @dev you must ensure that the order in which the VRF responses arrive cannot\\r\\n * @dev be used to manipulate your contract\\u0027s user-significant behavior.\\r\\n *\\r\\n * @dev Since the block hash of the block which contains the requestRandomness\\r\\n * @dev call is mixed into the input to the VRF *last*, a sufficiently powerful\\r\\n * @dev miner could, in principle, fork the blockchain to evict the block\\r\\n * @dev containing the request, forcing the request to be included in a\\r\\n * @dev different block with a different hash, and therefore a different input\\r\\n * @dev to the VRF. However, such an attack would incur a substantial economic\\r\\n * @dev cost. This cost scales with the number of blocks the VRF oracle waits\\r\\n * @dev until it calls responds to a request. It is for this reason that\\r\\n * @dev that you can signal to an oracle you\\u0027d like them to wait longer before\\r\\n * @dev responding to the request (however this is not enforced in the contract\\r\\n * @dev and so remains effective only in the case of unmodified oracle software).\\r\\n */\\r\\nabstract contract VRFConsumerBaseV2 {\\r\\n  error OnlyCoordinatorCanFulfill(address have, address want);\\r\\n  address private immutable vrfCoordinator;\\r\\n\\r\\n  /**\\r\\n   * @param _vrfCoordinator address of VRFCoordinator contract\\r\\n   */\\r\\n  constructor(address _vrfCoordinator) {\\r\\n    vrfCoordinator = _vrfCoordinator;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @notice fulfillRandomness handles the VRF response. Your contract must\\r\\n   * @notice implement it. See \\\"SECURITY CONSIDERATIONS\\\" above for important\\r\\n   * @notice principles to keep in mind when implementing your fulfillRandomness\\r\\n   * @notice method.\\r\\n   *\\r\\n   * @dev VRFConsumerBaseV2 expects its subcontracts to have a method with this\\r\\n   * @dev signature, and will call it once it has verified the proof\\r\\n   * @dev associated with the randomness. (It is triggered via a call to\\r\\n   * @dev rawFulfillRandomness, below.)\\r\\n   *\\r\\n   * @param requestId The Id initially returned by requestRandomness\\r\\n   * @param randomWords the VRF output expanded to the requested number of words\\r\\n   */\\r\\n  function fulfillRandomWords(uint256 requestId, uint256[] memory randomWords) internal virtual;\\r\\n\\r\\n  // rawFulfillRandomness is called by VRFCoordinator when it receives a valid VRF\\r\\n  // proof. rawFulfillRandomness then calls fulfillRandomness, after validating\\r\\n  // the origin of the call\\r\\n  function rawFulfillRandomWords(uint256 requestId, uint256[] memory randomWords) external {\\r\\n    if (msg.sender != vrfCoordinator) {\\r\\n      revert OnlyCoordinatorCanFulfill(msg.sender, vrfCoordinator);\\r\\n    }\\r\\n    fulfillRandomWords(requestId, randomWords);\\r\\n  }\\r\\n}\"},\"VRFCoordinatorV2Interface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface VRFCoordinatorV2Interface {\\r\\n  /**\\r\\n   * @notice Get configuration relevant for making requests\\r\\n   * @return minimumRequestConfirmations global min for request confirmations\\r\\n   * @return maxGasLimit global max for request gas limit\\r\\n   * @return s_provingKeyHashes list of registered key hashes\\r\\n   */\\r\\n  function getRequestConfig() external view returns (uint16, uint32, bytes32[] memory);\\r\\n\\r\\n  /**\\r\\n   * @notice Request a set of random words.\\r\\n   * @param keyHash - Corresponds to a particular oracle job which uses\\r\\n   * that key for generating the VRF proof. Different keyHash\\u0027s have different gas price\\r\\n   * ceilings, so you can select a specific one to bound your maximum per request cost.\\r\\n   * @param subId  - The ID of the VRF subscription. Must be funded\\r\\n   * with the minimum subscription balance required for the selected keyHash.\\r\\n   * @param minimumRequestConfirmations - How many blocks you\\u0027d like the\\r\\n   * oracle to wait before responding to the request. See SECURITY CONSIDERATIONS\\r\\n   * for why you may want to request more. The acceptable range is\\r\\n   * [minimumRequestBlockConfirmations, 200].\\r\\n   * @param callbackGasLimit - How much gas you\\u0027d like to receive in your\\r\\n   * fulfillRandomWords callback. Note that gasleft() inside fulfillRandomWords\\r\\n   * may be slightly less than this amount because of gas used calling the function\\r\\n   * (argument decoding etc.), so you may need to request slightly more than you expect\\r\\n   * to have inside fulfillRandomWords. The acceptable range is\\r\\n   * [0, maxGasLimit]\\r\\n   * @param numWords - The number of uint256 random values you\\u0027d like to receive\\r\\n   * in your fulfillRandomWords callback. Note these numbers are expanded in a\\r\\n   * secure way by the VRFCoordinator from a single random value supplied by the oracle.\\r\\n   * @return requestId - A unique identifier of the request. Can be used to match\\r\\n   * a request to a response in fulfillRandomWords.\\r\\n   */\\r\\n  function requestRandomWords(\\r\\n    bytes32 keyHash,\\r\\n    uint64 subId,\\r\\n    uint16 minimumRequestConfirmations,\\r\\n    uint32 callbackGasLimit,\\r\\n    uint32 numWords\\r\\n  ) external returns (uint256 requestId);\\r\\n\\r\\n  /**\\r\\n   * @notice Create a VRF subscription.\\r\\n   * @return subId - A unique subscription id.\\r\\n   * @dev You can manage the consumer set dynamically with addConsumer/removeConsumer.\\r\\n   * @dev Note to fund the subscription, use transferAndCall. For example\\r\\n   * @dev  LINKTOKEN.transferAndCall(\\r\\n   * @dev    address(COORDINATOR),\\r\\n   * @dev    amount,\\r\\n   * @dev    abi.encode(subId));\\r\\n   */\\r\\n  function createSubscription() external returns (uint64 subId);\\r\\n\\r\\n  /**\\r\\n   * @notice Get a VRF subscription.\\r\\n   * @param subId - ID of the subscription\\r\\n   * @return balance - LINK balance of the subscription in juels.\\r\\n   * @return reqCount - number of requests for this subscription, determines fee tier.\\r\\n   * @return owner - owner of the subscription.\\r\\n   * @return consumers - list of consumer address which are able to use this subscription.\\r\\n   */\\r\\n  function getSubscription(\\r\\n    uint64 subId\\r\\n  ) external view returns (uint96 balance, uint64 reqCount, address owner, address[] memory consumers);\\r\\n\\r\\n  /**\\r\\n   * @notice Request subscription owner transfer.\\r\\n   * @param subId - ID of the subscription\\r\\n   * @param newOwner - proposed new owner of the subscription\\r\\n   */\\r\\n  function requestSubscriptionOwnerTransfer(uint64 subId, address newOwner) external;\\r\\n\\r\\n  /**\\r\\n   * @notice Request subscription owner transfer.\\r\\n   * @param subId - ID of the subscription\\r\\n   * @dev will revert if original owner of subId has\\r\\n   * not requested that msg.sender become the new owner.\\r\\n   */\\r\\n  function acceptSubscriptionOwnerTransfer(uint64 subId) external;\\r\\n\\r\\n  /**\\r\\n   * @notice Add a consumer to a VRF subscription.\\r\\n   * @param subId - ID of the subscription\\r\\n   * @param consumer - New consumer which can use the subscription\\r\\n   */\\r\\n  function addConsumer(uint64 subId, address consumer) external;\\r\\n\\r\\n  /**\\r\\n   * @notice Remove a consumer from a VRF subscription.\\r\\n   * @param subId - ID of the subscription\\r\\n   * @param consumer - Consumer to remove from the subscription\\r\\n   */\\r\\n  function removeConsumer(uint64 subId, address consumer) external;\\r\\n\\r\\n  /**\\r\\n   * @notice Cancel a subscription\\r\\n   * @param subId - ID of the subscription\\r\\n   * @param to - Where to send the remaining LINK to\\r\\n   */\\r\\n  function cancelSubscription(uint64 subId, address to) external;\\r\\n\\r\\n  /*\\r\\n   * @notice Check to see if there exists a request commitment consumers\\r\\n   * for all consumers and keyhashes for a given sub.\\r\\n   * @param subId - ID of the subscription\\r\\n   * @return true if there exists at least one unfulfilled request for the subscription, false\\r\\n   * otherwise.\\r\\n   */\\r\\n  function pendingRequestExists(uint64 subId) external view returns (bool);\\r\\n}\"}}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"subscriptionId\",\"type\":\"uint64\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"have\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"want\",\"type\":\"address\"}],\"name\":\"OnlyCoordinatorCanFulfill\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"change_value\",\"type\":\"uint256\"}],\"name\":\"ChangeMaxBet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"change_value\",\"type\":\"uint32\"}],\"name\":\"Changeclimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"change_value\",\"type\":\"bytes32\"}],\"name\":\"Changekey\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"LatestRes\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"SetToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"creator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxbet\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"requestId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"randomWords\",\"type\":\"uint256[]\"}],\"name\":\"rawFulfillRandomWords\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"requestRandomWords\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"assetAddress\",\"type\":\"address\"}],\"name\":\"retrieveERC20Asset\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"s_randomWords\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"s_requestId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setterN\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vRes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Bet", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000331", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://b377730c1ce9a829702fa1d9f25ef95949056ee2c307e25f6cfc98011f656685"}