{"SourceCode": "//SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.6.12;\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\nlibrary Address {\r\n    function isContract(address account) internal view returns (bool) {\r\n        uint256 size;\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n      return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return _functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        return _functionCallWithValue(target, data, value, errorMessage);\r\n    }\r\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            if (returndata.length > 0) {\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0) { // Return data is optional\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n    function _msgData() internal view virtual returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    constructor () internal {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n    modifier onlyOwner() {\r\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\ninterface IERC20Token is IERC20 {\r\n    function maxSupply() external view returns (uint256);\r\n    function issue(address account, uint256 amount) external returns (bool);\r\n    function burn(uint256 amount) external returns (bool);\r\n}\r\n\r\ncontract DevAward {\r\n    // dev line release\r\n    address public dev;\r\n    uint256 public devStartBlock;\r\n    uint256 public devAccAwards;\r\n    uint256 public devPerBlock;\r\n    uint256 public MaxAvailAwards;\r\n    uint256 public claimedIncentives;\r\n}\r\n\r\ncontract AwardInfo {\r\n    struct TaxInfo {\r\n        uint256 epoch;\r\n        uint256 amount;\r\n    }\r\n\r\n    struct UserInfo {\r\n        uint256 freeAmount;\r\n        uint256 taxHead;     // queue head element index\r\n        uint256 taxTail;     // queue tail next element index\r\n        bool notEmpty;       // whether taxList is empty where taxHead = taxTail\r\n        TaxInfo[] taxList;\r\n    }\r\n\r\n    // tax epoch info\r\n    uint256 public taxEpoch = 9;     // tax epoch and user taxlist max length\r\n    uint256 public epUnit = 1 weeks;  // epoch unit => week\r\n\r\n    // user info\r\n    mapping(address => UserInfo) internal userInfo;\r\n\r\n    // tax treasury address\r\n    address public treasury;\r\n}\r\n\r\ncontract AwardContract is DevAward, AwardInfo, Ownable {\r\n\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for IERC20Token;\r\n\r\n    // platform token\r\n    IERC20Token public platformToken;\r\n    mapping(address => bool) public governors;\r\n    modifier onlyGovernor{\r\n        require(governors[_msgSender()], \"AwardContract: caller is not the governor\");\r\n        _;\r\n    }\r\n\r\n    event AddFreeAward(address user, uint256 amount);\r\n    event AddAward(address user, uint256 amount);\r\n    event Withdraw(address user, uint256 amount, uint256 tax);\r\n\r\n    constructor(\r\n        IERC20Token _platformToken,\r\n        uint256 _taxEpoch,\r\n        address _treasury,\r\n        address _dev,\r\n        uint256 _devStartBlock,\r\n        uint256 _devPerBlock\r\n    ) public {\r\n        require(_taxEpoch > 0, \"AwardContract: taxEpoch invalid\");\r\n        require(_dev != address(0), \"AwardContract: dev invalid\");\r\n        require(address(_platformToken) != address(0), \"AwardContract: platform token invalid\");\r\n        require(_devStartBlock != 0, \"AwardContract: dev start block invalid\");\r\n\r\n        platformToken = _platformToken;\r\n        taxEpoch = _taxEpoch;\r\n        governors[_msgSender()] = true;\r\n\r\n        // get tax fee\r\n        treasury = _treasury;\r\n        // dev info\r\n        dev = _dev;\r\n        // Dev can receive 10% of platformToken\r\n        MaxAvailAwards = platformToken.maxSupply().mul(10).div(100);\r\n        devPerBlock = _devPerBlock;\r\n        devStartBlock = _devStartBlock;\r\n    }\r\n\r\n    // get user total rewards\r\n    function getUserTotalAwards(address user) view public returns (uint256){\r\n        UserInfo memory info = userInfo[user];\r\n        uint256 amount = info.freeAmount;\r\n        if (info.notEmpty) {\r\n            uint256 cursor = info.taxHead;\r\n            while (true) {\r\n                amount = amount.add(info.taxList[cursor].amount);\r\n                cursor = cursor.add(1).mod(taxEpoch);\r\n                if (cursor == info.taxTail) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return amount;\r\n    }\r\n\r\n    // get user free rewards amount\r\n    function getCurrentFreeAwards(address user) view public returns (uint256){\r\n        uint256 rebaseEp = getCurrEpoch().sub(taxEpoch);\r\n        UserInfo memory info = userInfo[user];\r\n        uint256 amount = info.freeAmount;\r\n        if (info.notEmpty) {\r\n            uint256 cursor = info.taxHead;\r\n            while (info.taxList[cursor].epoch <= rebaseEp) {\r\n                amount = amount.add(info.taxList[cursor].amount);\r\n                cursor = cursor.add(1).mod(taxEpoch);\r\n                if (cursor == info.taxTail) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return amount;\r\n    }\r\n\r\n    // get available awards\r\n    function getUserAvailAwards(address user) view public returns (uint256){\r\n        uint256 current = getCurrEpoch();\r\n        uint256 rebaseEp = current.sub(taxEpoch);\r\n        UserInfo memory info = userInfo[user];\r\n        uint256 amount = info.freeAmount;\r\n        if (info.notEmpty) {\r\n            uint256 _ep = taxEpoch.add(1);\r\n            uint256 cursor = info.taxHead;\r\n            while (true) {\r\n                if (info.taxList[cursor].epoch > rebaseEp) {\r\n                    uint rate = current.sub(info.taxList[cursor].epoch).add(1).mul(1e12).div(_ep);\r\n                    uint256 available = info.taxList[cursor].amount.mul(rate).div(1e12);\r\n                    amount = amount.add(available);\r\n                } else {\r\n                    amount = amount.add(info.taxList[cursor].amount);\r\n                }\r\n                cursor = cursor.add(1).mod(taxEpoch);\r\n                if (cursor == info.taxTail) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return amount;\r\n    }\r\n\r\n    // estimate gas\r\n    function estimateTax(uint256 _amount) view external returns (uint256){\r\n        uint256 _current = getCurrEpoch();\r\n        uint256 tax = 0;\r\n        UserInfo memory user = userInfo[msg.sender];\r\n        if (user.freeAmount >= _amount) {\r\n            return 0;\r\n        }\r\n        else {\r\n            uint256 current = _current;\r\n            uint256 arrears = _amount.sub(user.freeAmount);\r\n            uint256 _head = user.taxHead;\r\n            uint256 _ep = taxEpoch.add(1);\r\n            while (user.notEmpty) {\r\n                // non-levied tax rate\r\n                TaxInfo memory taxInfo = user.taxList[_head];\r\n                uint rate = current.sub(taxInfo.epoch).add(1).mul(1e12).div(_ep);\r\n                if (rate > 1e12) {\r\n                    rate = 1e12;\r\n                }\r\n                uint256 available = taxInfo.amount.mul(rate).div(1e12);\r\n                if (available >= arrears) {\r\n                    uint256 newAmount = arrears.mul(1e12).div(rate);\r\n                    tax = tax.add(newAmount.sub(arrears));\r\n                    arrears = 0;\r\n                    break;\r\n                }\r\n                else {\r\n                    arrears = arrears.sub(available);\r\n                    tax = tax.add(taxInfo.amount.sub(available));\r\n                    _head = _head.add(1).mod(taxEpoch);\r\n                    if (_head == user.taxTail) {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            require(arrears == 0, \"AwardContract: Insufficient Balance\");\r\n            return tax;\r\n        }\r\n    }\r\n\r\n    // add governor\r\n    function addGovernor(address governor) onlyOwner external {\r\n        governors[governor] = true;\r\n    }\r\n\r\n    // remove governor\r\n    function removeGovernor(address governor) onlyOwner external {\r\n        governors[governor] = false;\r\n    }\r\n\r\n    // dev get rewards\r\n    function claimDevAwards() external {\r\n        require(msg.sender == dev, \"AwardContract: only dev can receive awards\");\r\n        require(devAccAwards < MaxAvailAwards, \"AwardContract: dev awards exceed permitted amount\");\r\n        uint256 amount = block.number.sub(devStartBlock).mul(devPerBlock);\r\n        uint256 rewards = amount.sub(devAccAwards);\r\n        if (amount > MaxAvailAwards) {\r\n            rewards = MaxAvailAwards.sub(devAccAwards);\r\n        }\r\n        safeIssue(dev, rewards, \"AwardContract: dev claim awards failed\");\r\n        devAccAwards = devAccAwards.add(rewards);\r\n    }\r\n\r\n    // add free amount\r\n    function addFreeAward(address _user, uint256 _amount) onlyGovernor external {\r\n        UserInfo storage user = userInfo[_user];\r\n        user.freeAmount = user.freeAmount.add(_amount);\r\n        emit AddFreeAward(_user, _amount);\r\n    }\r\n\r\n    // add award\r\n    function addAward(address _user, uint256 _amount) onlyGovernor public {\r\n        uint256 current = getCurrEpoch();\r\n        // get epoch\r\n        UserInfo storage user = userInfo[_user];\r\n        //\r\n        if (user.taxList.length == 0) {\r\n            user.taxList.push(TaxInfo({\r\n            epoch : current,\r\n            amount : _amount\r\n            }));\r\n            user.taxHead = 0;\r\n            user.taxTail = 1;\r\n            user.notEmpty = true;\r\n        }\r\n        else {\r\n            // taxList not full\r\n            if (user.notEmpty) {\r\n                uint256 end;\r\n                if (user.taxTail == 0) {\r\n                    end = user.taxList.length - 1;\r\n                } else {\r\n                    end = user.taxTail.sub(1);\r\n                }\r\n                if (user.taxList[end].epoch >= current) {\r\n                    user.taxList[end].amount = user.taxList[end].amount.add(_amount);\r\n                } else {\r\n                    if (user.taxList.length < taxEpoch) {\r\n                        user.taxList.push(TaxInfo({\r\n                        epoch : current,\r\n                        amount : _amount\r\n                        }));\r\n                    } else {\r\n                        if (user.taxHead == user.taxTail) {\r\n                            rebase(user, current);\r\n                        }\r\n                        user.taxList[user.taxTail].epoch = current;\r\n                        user.taxList[user.taxTail].amount = _amount;\r\n                    }\r\n                    user.taxTail = user.taxTail.add(1).mod(taxEpoch);\r\n                }\r\n            } else {// user.taxHead == user.taxTail\r\n                if (user.taxList.length < taxEpoch) {\r\n                    user.taxList.push(TaxInfo({\r\n                    epoch : current,\r\n                    amount : _amount\r\n                    }));\r\n                } else {\r\n                    user.taxList[user.taxTail].epoch = current;\r\n                    user.taxList[user.taxTail].amount = _amount;\r\n                }\r\n                user.taxTail = user.taxTail.add(1).mod(taxEpoch);\r\n                user.notEmpty = true;\r\n            }\r\n        }\r\n        emit AddAward(_user, _amount);\r\n    }\r\n\r\n    // batch add awards\r\n    function batchAddAwards(address[] memory _users, uint256[] memory _amounts) onlyGovernor external {\r\n        require(_users.length == _amounts.length, \"AwardContract: params invalid\");\r\n        for (uint i = 0; i < _users.length; i++) {\r\n            addAward(_users[i], _amounts[i]);\r\n        }\r\n    }\r\n\r\n    function withdraw(uint256 _amount) external {\r\n        uint256 current = getCurrEpoch();\r\n        uint256 _destroy = 0;\r\n        // get base time\r\n        UserInfo storage user = userInfo[msg.sender];\r\n        // rebase\r\n        rebase(user, current);\r\n\r\n        if (user.freeAmount >= _amount) {\r\n            user.freeAmount = user.freeAmount.sub(_amount);\r\n        }\r\n        else {\r\n            uint256 arrears = _amount.sub(user.freeAmount);\r\n            user.freeAmount = 0;\r\n            uint256 _head = user.taxHead;\r\n            uint256 _ep = taxEpoch.add(1);\r\n            while (user.notEmpty) {\r\n                // non-levied tax rate\r\n                uint rate = current.sub(user.taxList[_head].epoch).add(1).mul(1e12).div(_ep);\r\n\r\n                uint256 available = user.taxList[_head].amount.mul(rate).div(1e12);\r\n                // available token\r\n                if (available >= arrears) {\r\n                    uint256 newAmount = arrears.mul(1e12).div(rate);\r\n                    user.taxList[_head].amount = user.taxList[_head].amount.sub(newAmount);\r\n                    _destroy = _destroy.add(newAmount.sub(arrears));\r\n                    arrears = 0;\r\n                    break;\r\n                }\r\n                else {\r\n                    arrears = arrears.sub(available);\r\n                    _destroy = _destroy.add(user.taxList[_head].amount.sub(available));\r\n                    _head = _head.add(1).mod(taxEpoch);\r\n                    if (_head == user.taxTail) {\r\n                        user.notEmpty = false;\r\n                    }\r\n                }\r\n            }\r\n            user.taxHead = _head;\r\n            require(arrears == 0, \"AwardContract: Insufficient Balance\");\r\n            safeIssue(treasury, _destroy, \"AwardContract: levy tax failed\");\r\n        }\r\n        safeIssue(msg.sender, _amount, \"AwardContract: claim awards failed\");\r\n        emit Withdraw(msg.sender, _amount, _destroy);\r\n    }\r\n\r\n    function pendingIncentives() view public returns (uint256){\r\n        uint256 startBlock = 11210456;   // It's staking start block\r\n        if (block.number <= startBlock) return 0;\r\n\r\n        uint256 maxIncent = 745000 * 10 ** 18;\r\n        uint256 incents = block.number.sub(startBlock).mul(15 * 10 ** 16);\r\n        if (incents > maxIncent) {\r\n            return maxIncent.sub(claimedIncentives);\r\n        } else {\r\n            return incents.sub(claimedIncentives);\r\n        }\r\n    }\r\n\r\n    function claimIncentives(address to, uint256 amount) external {\r\n        require(msg.sender == dev, \"AwardContract: unauthorized\");\r\n        require(to != dev, \"AwardContract: dev so greedy\");\r\n        uint256 pending = pendingIncentives();\r\n        require(amount <= pending, \"AwardContract: incentives exceed\");\r\n        safeIssue(to, amount, \"AwardContract: claim incentives err\");\r\n        claimedIncentives = claimedIncentives.add(amount);\r\n    }\r\n\r\n    function destroy(uint256 amount) onlyGovernor external {\r\n        safeIssue(treasury, amount, \"AwardContract: levy tax failed\");\r\n    }\r\n\r\n    function getCurrEpoch() internal view returns (uint256) {\r\n        return now.div(epUnit);\r\n    }\r\n\r\n    function safeIssue(address user, uint256 amount, string memory err) internal {\r\n        if (amount > 0) {\r\n            require(amount.add(platformToken.totalSupply()) <= platformToken.maxSupply(), \"AwardContract: awards exceeds maxSupply\");\r\n            require(platformToken.issue(user, amount), err);\r\n        }\r\n    }\r\n\r\n    function rebase(UserInfo storage _user, uint256 _current) internal {\r\n        uint256 rebaseEp = _current.sub(taxEpoch);\r\n        uint256 head = _user.taxHead;\r\n        while (_user.notEmpty && _user.taxList[head].epoch <= rebaseEp) {\r\n            _user.freeAmount = _user.freeAmount.add(_user.taxList[head].amount);\r\n            head = head.add(1).mod(taxEpoch);\r\n            if (head == _user.taxTail) {\r\n                _user.notEmpty = false;\r\n            }\r\n        }\r\n        _user.taxHead = head;\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IERC20Token\",\"name\":\"_platformToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_taxEpoch\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_treasury\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_dev\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_devStartBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_devPerBlock\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"AddAward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"AddFreeAward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tax\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MaxAvailAwards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"addAward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"addFreeAward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"governor\",\"type\":\"address\"}],\"name\":\"addGovernor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_users\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"}],\"name\":\"batchAddAwards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimDevAwards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"claimIncentives\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimedIncentives\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"destroy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dev\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"devAccAwards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"devPerBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"devStartBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"epUnit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"estimateTax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getCurrentFreeAwards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserAvailAwards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserTotalAwards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"governors\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingIncentives\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"platformToken\",\"outputs\":[{\"internalType\":\"contract IERC20Token\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"governor\",\"type\":\"address\"}],\"name\":\"removeGovernor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"taxEpoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasury\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "AwardContract", "CompilerVersion": "v0.6.12+commit.27d51765", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000e1b583dc66e0a24fd9af2dc665f6f5e48978e10600000000000000000000000000000000000000000000000000000000000000090000000000000000000000007ca6eea4df49c315534fee8dc43e0660540cd9ea000000000000000000000000667911bc8b5775616ebcf13d49734cff96d4ec390000000000000000000000000000000000000000000000000000000000b1549b00000000000000000000000000000000000000000000000004e28e2290f00000", "EVMVersion": "Default", "Library": "", "LicenseType": "Unlicense", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://a51897cf8f72196b48d14c35bd2f9f73775695e1324ed39557caf4e26551ce23"}