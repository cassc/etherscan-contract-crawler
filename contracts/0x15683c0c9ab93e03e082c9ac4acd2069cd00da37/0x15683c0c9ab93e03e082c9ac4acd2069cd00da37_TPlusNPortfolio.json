{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/portfolios/TPlusNPortfolio.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: BSD 3-Clause\\npragma solidity 0.8.13;\\n\\nimport {EntityBaseTokenTransferor} from \\\"../EntityBaseTokenTransferor.sol\\\";\\nimport {TPlusNAsset} from \\\"./TPlusNAsset.sol\\\";\\nimport {Registry} from \\\"../Registry.sol\\\";\\nimport {Entity} from \\\"../Entity.sol\\\";\\nimport {Portfolio} from \\\"../Portfolio.sol\\\";\\nimport {ERC20} from \\\"solmate/tokens/ERC20.sol\\\";\\nimport {Math} from \\\"../lib/Math.sol\\\";\\nimport {SafeTransferLib} from \\\"solmate/utils/SafeTransferLib.sol\\\";\\n\\n/// ENUMS\\nenum ConsolidationOperation {\\n    Deposit,\\n    Redeem\\n}\\n\\n/// STRUCTS\\n/**\\n * @notice Arguments for constructor. Using a struct to avoid stack too deep error.\\n * @param _registry Endaoment registry.\\n * @param _receiptAsset Address of the receipt asset. Should normally be a `TPlusNAsset` contract.\\n * @param _shareTokenName Name of ERC20 portfolio share token.\\n * @param _shareTokenSymbol Symbol of ERC20 portfolio share token.\\n * @param _ebtt Address of the EBTT contract.\\n * @param _processor Address to automatically route deposit base token to.\\n * @param _minDeposit Minimum base token amount allowed for a valid deposit.\\n * @param _cap Maximum amount of assets this portfolio can hold.\\n * @param _feeTreasury Address of treasury that should receive fees.\\n * @param _depositFee Percentage fee as ZOC that should go to treasury on deposit. (100 = 1%).\\n * @param _redemptionFee Percentage fee as ZOC that should go to treasury on redemption. (100 = 1%).\\n * @param _aumRate Percentage fee per second (as WAD) that should accrue to treasury as AUM fee. (1e16 = 1%).\\n */\\nstruct ConstructorArgs {\\n    Registry registry;\\n    address receiptAsset;\\n    string shareTokenName;\\n    string shareTokenSymbol;\\n    EntityBaseTokenTransferor ebtt;\\n    address processor;\\n    uint256 minDeposit;\\n    uint256 cap;\\n    address feeTreasury;\\n    uint256 depositFee;\\n    uint256 redemptionFee;\\n    uint256 aumRate;\\n}\\n\\n/**\\n * @notice Struct representing a single consolidation for a deposit/purchase or redeem/sale operation.\\n * @param operation The type of consolidation operation - deposit/purchase or redeem/sale.\\n * @param entity The entity whose pending balance should be consolidated.\\n * @param amountBaseToken The amount of base token to consolidate. For purchases, this is the amount of base token used. For sales, this is the amount of base token received.\\n * @param amountAssets The amount of assets to consolidate. For purchases, this is the amount of assets purchased. For sales, this is the amount of assets sold.\\n */\\nstruct Consolidation {\\n    ConsolidationOperation operation;\\n    Entity entity;\\n    uint256 amountBaseToken;\\n    uint256 amountAssets;\\n}\\n\\ncontract TPlusNPortfolio is Portfolio {\\n    using SafeTransferLib for ERC20;\\n    using Math for uint256;\\n\\n    /// STATE\\n\\n    /// @notice The EBTT contract.\\n    EntityBaseTokenTransferor public immutable ebtt;\\n    /// @notice The address to automatically route base tokens from and to on deposits and sales.\\n    address public processor;\\n    /// @notice Minimum base token amount that can be deposited.\\n    uint256 public minDeposit;\\n    /// @notice Maintenance flag to pause functionality.\\n    bool public underMaintenance;\\n    /// @notice Pending purchase balance of base tokens per address.\\n    mapping(Entity => uint256) public pendingPurchaseBalance;\\n    /// @notice Pending sale assets per address.\\n    mapping(Entity => uint256) public pendingSaleAssets;\\n\\n    /// ERRORS\\n\\n    /// @notice Emitted when deposit is below minimum.\\n    error MinDeposit();\\n    /// @notice Emitted when called under maintenance.\\n    error UnderMaintenance();\\n    /// @notice Emitted when informed entity parameter is bad (e.g. missing information, duplicated entities).\\n    error BadEntityInput();\\n    /// @notice Emitted when insufficient balances on consolidation.\\n    error InsufficientBalance();\\n\\n    /// EVENTS\\n\\n    /// @notice Emitted when processor is set.\\n    event ProcessorSet(address newProcessor);\\n    /// @notice Emitted when minDeposit is set.\\n    event MinDepositSet(uint256 newMinDeposit);\\n    /// @notice Emitted when underMaintenance is set.\\n    event UnderMaintenanceSet(bool newUnderMaintenance);\\n    /// @notice Emitted when a deposit/purchase consolidation is made.\\n    event DepositConsolidated(\\n        Entity indexed entity, uint256 amountBaseToken, uint256 amountAssets, uint256 amountShares\\n    );\\n    /// @notice Emitted when a correction mint is made.\\n    event CorrectionShareMinted(Entity indexed entity, uint256 amountShares);\\n    /// @notice Emitted when a correction burn is made.\\n    event CorrectionShareBurned(Entity indexed entity, uint256 amountShares);\\n    /// @notice Emitted when a redemption/sale consolidation is made.\\n    event RedeemConsolidated(Entity indexed entity, uint256 amountBaseToken, uint256 amountAssets, uint256 fee);\\n\\n    /**\\n     * @param _args Constructor arguments struct.\\n     * @dev Args are passed in a struct to avoid stack too deep errors.\\n     * @dev The `true` parameter is to set this portfolio as `async` in the parent `Portfolio` contract. Async portfolios handle share lifecycle differently.\\n     * @dev EBTT is required to properly process payments back to entites on sale consolidations.\\n     * @dev While `cap` is not enforced in contract, its value can be utilized by UI to implement the behavior.\\n     */\\n    constructor(ConstructorArgs memory _args)\\n        Portfolio(\\n            _args.registry,\\n            _args.receiptAsset,\\n            _args.shareTokenName,\\n            _args.shareTokenSymbol,\\n            true, // Async portfolio, hence setting `_async` to true\\n            _args.cap,\\n            _args.feeTreasury,\\n            _args.depositFee,\\n            _args.redemptionFee,\\n            _args.aumRate\\n        )\\n    {\\n        // Approve EBTT to transfer this portfolio's balance for sale consolidations\\n        ebtt = _args.ebtt;\\n        baseToken.safeApprove(address(ebtt), type(uint256).max);\\n\\n        processor = _args.processor;\\n        emit ProcessorSet(processor);\\n\\n        minDeposit = _args.minDeposit;\\n        emit MinDepositSet(minDeposit);\\n    }\\n\\n    /**\\n     * @inheritdoc Portfolio\\n     */\\n    function _getAsset(address _receiptAsset) internal pure override returns (address) {\\n        return _receiptAsset;\\n    }\\n\\n    /**\\n     * @inheritdoc Portfolio\\n     */\\n    function convertReceiptAssetsToAssets(uint256 _receiptAssets) public pure override returns (uint256) {\\n        return _receiptAssets;\\n    }\\n\\n    /**\\n     * @inheritdoc Portfolio\\n     * @notice T+N portfolios do not enforce cap onchain.\\n     * @dev Cap is not enforced because async portfolios do not have direct access to the spot price of the asset, hence not being able to determine a cap syncronously to deposits.\\n     * @dev While `cap` is not enforced in contract, it is settable in the constructor so external logic can read and utilize it.\\n     */\\n    function _checkCap() internal pure override {}\\n\\n    /**\\n     * @inheritdoc Portfolio\\n     * @dev As an `async` portfolio, T+N portfolio do not mint shares on `deposit`, rather handling it on consolidations.\\n     * @dev Deposits smaller than `minDeposit` revert.\\n     */\\n    function _deposit(uint256 _amountBaseToken, bytes calldata /* _data */ )\\n        internal\\n        override\\n        returns (uint256, /* shares */ uint256, /* assets */ uint256 /* fee */ )\\n    {\\n        // Check if deposit is above minimum\\n        if (_amountBaseToken < minDeposit) revert MinDeposit();\\n        // Check if under maintenance\\n        if (underMaintenance) revert UnderMaintenance();\\n\\n        // Calculate fee and net amount to be deposited and used for purchase\\n        // TODO: move deposit fee logic to `Portfolio`, for all portfolios\\n        (uint256 _amountIn, uint256 _amountFee) = _calculateFee(_amountBaseToken, depositFee);\\n\\n        // Transfer amount from entity to `processor`\\n        baseToken.safeTransferFrom(msg.sender, processor, _amountIn);\\n\\n        // Transfer fee to treasury\\n        baseToken.safeTransferFrom(msg.sender, feeTreasury, _amountFee);\\n\\n        // Update pending balance\\n        unchecked {\\n            // Unchecked: no realistic amount of base token will overflow\\n            pendingPurchaseBalance[Entity(payable(msg.sender))] += _amountIn;\\n        }\\n\\n        // No acquired shares or assets, and base token fee amount\\n        return (0, 0, _amountFee);\\n    }\\n\\n    /**\\n     * @inheritdoc Portfolio\\n     * @notice Returns (0, 0) to signal that no asset and base token are produced on reddem for T+N.\\n     */\\n    function _redeem(uint256 _amountShares, bytes calldata /* _data */ )\\n        internal\\n        override\\n        returns (uint256, /* assetsOut */ uint256 /* baseTokenOut */ )\\n    {\\n        // Check if under maintenance\\n        if (underMaintenance) revert UnderMaintenance();\\n\\n        // Verify how many assets this amount of shares is worth\\n        // This assumes `takeAUMFees` was already called in the wrapping `Portfolio.redeem` call\\n        uint256 _amountAssets = convertToAssets(_amountShares);\\n\\n        // Update pending asset amount to sell\\n        unchecked {\\n            // Unchecked: asset total supply is capped at type(uint256).max, so an individual balance will also never overflow\\n            pendingSaleAssets[Entity(payable(msg.sender))] += _amountAssets;\\n        }\\n\\n        // Burn asset to maintain correct supply in portfolio's balance\\n        // This is important so AUM fees are charged proportional to the asset balance that still\\n        // belongs to the portfolio. This also implies that once an entity performs a redeem,\\n        // we won't charge/be entitled to any AUM fees on that portion of the assets.\\n        TPlusNAsset(receiptAsset).burn(_amountAssets);\\n\\n        // Return the amount of assets out and 0 base token for a T+N redemption\\n        return (_amountAssets, 0);\\n    }\\n\\n    /**\\n     * @notice Consolidates pending purchase balances into shares, based on the amount of assets effectively purchased.\\n     * @param _entity The entity whose pending balance should be consolidated.\\n     * @param _amountBaseToken The amount of base token to consolidate.\\n     * @param _amountAssets The amount of assets this amount of base token was capable of purchasing.\\n     * @dev The value of _amountAssets must be chosen carefully to avoid rounding errors e.g. 1 ether = 1 \\\"real world\\\" asset is a good choice.\\n     */\\n    function _consolidateDeposit(Entity _entity, uint256 _amountBaseToken, uint256 _amountAssets) private {\\n        // Decrease pending balance\\n        // Checked: we want to revert on underflow\\n        pendingPurchaseBalance[_entity] -= _amountBaseToken;\\n\\n        // Mint shares proportional to the amount of assets produced\\n        // \u26a0\ufe0f Share calculation must happen before all mints to avoid wrong values\\n        uint256 _amountShares = convertToShares(_amountAssets);\\n        _mint(address(_entity), _amountShares);\\n\\n        // Mint the receipt asset equal to the amount of asset produced, since the portfolio\\n        // controls the supply of the receipt asset\\n        TPlusNAsset(receiptAsset).mint(address(this), _amountAssets);\\n\\n        // Emit\\n        emit DepositConsolidated(_entity, _amountBaseToken, _amountAssets, _amountShares);\\n    }\\n\\n    /**\\n     * @notice Consolidate pending sale/redeemed assets into base token, based on the amount of assets effectively sold. Transfers base token to entity.\\n     * @param _entity The entity whose pending asset balance should be consolidated.\\n     * @param _amountBaseToken The amount of base token the sale of the asset amount was capable of selling for.\\n     * @param _amountAssets The amount of assets that effectively got sold.\\n     * @dev Method will revert if portfolio does not have enough base token in its balance to transfer to entity and treasury.\\n     */\\n    function _consolidateRedeem(Entity _entity, uint256 _amountBaseToken, uint256 _amountAssets) private {\\n        // Checked: Desired underflow if larger\\n        pendingSaleAssets[_entity] -= _amountAssets;\\n\\n        // Get net and fee values\\n        (uint256 _amountOut, uint256 _amountFee) = _calculateFee(_amountBaseToken, redemptionFee);\\n\\n        // Transfer sale-produced base token amount to entity\\n        // Uses EBTT contract to circumvent any fee or events being triggered incorrectly\\n        ebtt.transferFromPortfolio(_entity, _amountOut);\\n\\n        // Transfer fee to treasury\\n        baseToken.safeTransfer(feeTreasury, _amountFee);\\n\\n        // Emit\\n        emit RedeemConsolidated(_entity, _amountOut, _amountAssets, _amountFee);\\n    }\\n\\n    /**\\n     * @notice Consolidate pending balances into shares or base token, based on the amount of assets effectively purchased or sold.\\n     * @param _consolidations Array of `Consolidation` structs to process.\\n     */\\n    function _consolidate(Consolidation[] calldata _consolidations) private {\\n        for (uint256 i = 0; i < _consolidations.length; ++i) {\\n            if (_consolidations[i].operation == ConsolidationOperation.Deposit) {\\n                _consolidateDeposit(\\n                    _consolidations[i].entity, _consolidations[i].amountBaseToken, _consolidations[i].amountAssets\\n                );\\n            } else {\\n                _consolidateRedeem(\\n                    _consolidations[i].entity, _consolidations[i].amountBaseToken, _consolidations[i].amountAssets\\n                );\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Perform consolidation while skipping any accrual operations.\\n     * @param _consolidations Array of `Consolidation` structs to process.\\n     * @dev Reverts if the contract does not have enough base token to transfer to the entity and treasury on a redeem consolidation.\\n     */\\n    function consolidateNoAccrual(Consolidation[] calldata _consolidations) external requiresAuth {\\n        // AUM fees must be taken whenever the balance of assets changes\\n        takeAumFees();\\n        // Consolidate\\n        _consolidate(_consolidations);\\n    }\\n\\n    /**\\n     * @notice Endaoment role authed method to consolidate pending purchases and sales while distributing accrued assets.\\n     * @param _consolidations Array of `Consolidation` structs to process.\\n     * @param _accruedAssets Amount of assets accrued since last consolidation.\\n     * @dev Reverts if the contract does not have enough base token to transfer to the entity and treasury on a redeem consolidation.\\n     */\\n    function consolidateWithAccrual(Consolidation[] calldata _consolidations, uint256 _accruedAssets)\\n        external\\n        requiresAuth\\n    {\\n        // AUM fees must be taken whenever the balance of assets changes\\n        takeAumFees();\\n\\n        // Given how the operational flow of how T+N works, accruals are simply the minting of the underlying asset\\n        // This *must* be done before any consolidation, to properly reflect the contribution of each existing entity's\\n        // position to produce the accrued assets\\n        TPlusNAsset(receiptAsset).mint(address(this), _accruedAssets);\\n\\n        // Consolidate\\n        _consolidate(_consolidations);\\n    }\\n\\n    /**\\n     * @notice Endaoment role authed method to mint shares to an entity. Used solely for correcting share balances in case of errors.\\n     * @param _entity The entity to mint shares to.\\n     * @param _amount The amount of shares to mint.\\n     * @dev This method is only callable by Endaoment roles, and used only in case of error corrections.\\n     */\\n    function correctionMint(Entity _entity, uint256 _amount) external requiresAuth {\\n        _mint(address(_entity), _amount);\\n\\n        emit CorrectionShareMinted(_entity, _amount);\\n    }\\n\\n    /**\\n     * @notice Endaoment role authed method to burn shares from an entity. Used solely for correcting share balances in case of errors.\\n     * @param _entity The entity to burn shares from.\\n     * @param _amount The amount of shares to burn.\\n     * @dev This method is only callable by Endaoment roles, and used only in case of error corrections.\\n     */\\n    function correctionBurn(Entity _entity, uint256 _amount) external requiresAuth {\\n        _burn(address(_entity), _amount);\\n\\n        emit CorrectionShareBurned(_entity, _amount);\\n    }\\n\\n    // @inheritdoc Portfolio\\n    function _exit(\\n        uint256,\\n        /* _amount */\\n        bytes calldata /* _data */\\n    ) internal pure override returns (uint256, /* actualAssetsOut */ uint256 /* baseTokenOut */ ) {\\n        // Noop\\n        return (0, 0);\\n    }\\n\\n    /**\\n     * @notice Endaoment role authed method to set the processor address.\\n     * @param _processor Address to automatically route deposit base token to.\\n     */\\n    function setProcessor(address _processor) external requiresAuth {\\n        processor = _processor;\\n        emit ProcessorSet(_processor);\\n    }\\n\\n    /**\\n     * @notice Role authed method to set the minimum base token amount allowed for a valid deposit.\\n     * @param _min Minimum base token amount allowed for a valid deposit.\\n     */\\n    function setMinDeposit(uint256 _min) external requiresAuth {\\n        minDeposit = _min;\\n        emit MinDepositSet(_min);\\n    }\\n\\n    /**\\n     * @notice Role authed method to set the maintenance flag.\\n     * @param _underMaintenance Maintenance flag to pause functionality.\\n     */\\n    function setUnderMaintenance(bool _underMaintenance) external requiresAuth {\\n        underMaintenance = _underMaintenance;\\n        emit UnderMaintenanceSet(_underMaintenance);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/EntityBaseTokenTransferor.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: BSD 3-Clause\\npragma solidity >=0.8.0;\\n\\nimport {EndaomentAuth} from \\\"./lib/auth/EndaomentAuth.sol\\\";\\nimport {Registry} from \\\"./Registry.sol\\\";\\nimport {Entity} from \\\"./Entity.sol\\\";\\nimport {Portfolio} from \\\"./Portfolio.sol\\\";\\nimport {ERC20} from \\\"solmate/tokens/ERC20.sol\\\";\\nimport \\\"solmate/utils/SafeTransferLib.sol\\\";\\n\\n/**\\n * @notice An Endaoment ecosystem contract capabale of transfering base tokens to Endaoment entities, updating their balances without triggering fees or emitting misleading events.\\n * @dev This is due to this contract being enabled as a valid entity on the `Registry` and capable of calling `receiveTransfer` on entities.\\n */\\ncontract EntityBaseTokenTransferor is EndaomentAuth {\\n    using SafeTransferLib for ERC20;\\n\\n    /// STRUCTS\\n    struct EntityTransfer {\\n        Entity entity;\\n        uint256 amount;\\n    }\\n\\n    /// STATE\\n    /// @notice The Endaoment registry contract\\n    Registry public immutable registry;\\n\\n    /// ERRORS\\n    /// @notice Error when the transfer destination isn't a valid and enabled Endaoment entity.\\n    error InvalidEntity();\\n    /// @notice Error when the transfer source isn't a valid and enabled Endaoment portfolio.\\n    error InvalidPortfolio();\\n    /// @notice Error when a call to another contract fails.\\n    error CallFailed(bytes response);\\n\\n    /// EVENTS\\n    /// @notice Emitted when a transfer is made to an Endaoment entity.\\n    event TransferredToEntity(address indexed from, Entity indexed entity, uint256 amount);\\n\\n    /**\\n     * @param _registry The Endaoment registry contract\\n     */\\n    constructor(Registry _registry) {\\n        __initEndaomentAuth(_registry, \\\"\\\");\\n        registry = _registry;\\n    }\\n\\n    /**\\n     * Modifier to only allow valid and active Endaoment entities as transfer destinations.\\n     * @param _entity The attempted entity\\n     */\\n    modifier isActiveEntity(Entity _entity) {\\n        _checkEntity(_entity);\\n        _;\\n    }\\n\\n    /**\\n     * Modifier to only allow valid and active Endaoment portfolios as callers.\\n     */\\n    modifier isActivePortfolioCaller() {\\n        if (!registry.isActivePortfolio(Portfolio(msg.sender))) revert InvalidPortfolio();\\n        _;\\n    }\\n\\n    /**\\n     * Check if an entity is valid and active\\n     * @param _entity The entity to check\\n     */\\n    function _checkEntity(Entity _entity) private view {\\n        if (!registry.isActiveEntity(_entity)) revert InvalidEntity();\\n    }\\n\\n    /**\\n     * Transfer base token from caller and consolidate balance of the Endaoment entity.\\n     * @param _entity The entity to transfer to.\\n     * @param _amount The amount to transfer.\\n     * @notice This functions exists so Endaoment admins can transfer arbitrary amounts of base tokens to entities without triggering fees.\\n     * @dev Caller must pre `approve` this contract to transfer the desired amount.\\n     */\\n    function transferFromCaller(Entity _entity, uint256 _amount) external requiresAuth isActiveEntity(_entity) {\\n        _transferToEntity(msg.sender, _entity, _amount);\\n    }\\n\\n    /**\\n     * Batch transfer base token from caller and consolidate balance of the receiving Endaoment entities.\\n     * @param _entityTransfers The entity transfers to make.\\n     * @notice This functions exists so Endaoment admins can transfer arbitrary amounts of base tokens to entities without triggering fees.\\n     * @dev Caller must pre `approve` this contract to transfer the desired amount.\\n     */\\n    function batchTransferFromCaller(EntityTransfer[] calldata _entityTransfers) external requiresAuth {\\n        for (uint256 i = 0; i < _entityTransfers.length; ++i) {\\n            EntityTransfer memory _transfer = _entityTransfers[i];\\n            _checkEntity(_transfer.entity);\\n            _transferToEntity(msg.sender, _transfer.entity, _transfer.amount);\\n        }\\n    }\\n\\n    /**\\n     * Transfer base token from an Endaoment portfolio to an Endaoment entity.\\n     * @param _entity The entity to transfer to.\\n     * @param _amount The amount to transfer.\\n     * @notice This functions exists so Endaoment portfolios can transfer arbitrary amounts of base tokens to entities without triggering fees.\\n     * An example of this use case is for T+N portfolios and their async nature of transferring base tokens back to entities on sale consolidation.\\n     * @dev This function is only callable by active Endaoment portfolios.\\n     * @dev Portfolio caller must pre `approve` this contract to transfer the desired amount.\\n     */\\n    function transferFromPortfolio(Entity _entity, uint256 _amount)\\n        external\\n        isActivePortfolioCaller\\n        isActiveEntity(_entity)\\n    {\\n        _transferToEntity(msg.sender, _entity, _amount);\\n    }\\n\\n    /**\\n     * Batch transfer base token from an Endaoment portfolio to Endaoment entities.\\n     * @param _entityTransfers The entity transfers to make.\\n     * @notice This functions exists so Endaoment portfolios can transfer arbitrary amounts of base tokens to entities without triggering fees.\\n     * @dev This function is only callable by active Endaoment portfolios.\\n     * @dev Portfolio caller must pre `approve` this contract to transfer the desired amount.\\n     */\\n    function batchTransferFromPortfolio(EntityTransfer[] calldata _entityTransfers) external isActivePortfolioCaller {\\n        for (uint256 i = 0; i < _entityTransfers.length; ++i) {\\n            EntityTransfer memory _transfer = _entityTransfers[i];\\n            _checkEntity(_transfer.entity);\\n            _transferToEntity(msg.sender, _transfer.entity, _transfer.amount);\\n        }\\n    }\\n\\n    /**\\n     * Transfer base token to an Endaoment entity.\\n     * @param _from The address to transfer from.\\n     * @param _entity The entity to transfer to.\\n     * @param _amount The amount to transfer.\\n     */\\n    function _transferToEntity(address _from, Entity _entity, uint256 _amount) private {\\n        // Emit event\\n        emit TransferredToEntity(_from, _entity, _amount);\\n\\n        // Update entity balance through receiving\\n        _entity.receiveTransfer(_amount);\\n\\n        // Transfer to entity, transferring from approved balance from the caller\\n        registry.baseToken().safeTransferFrom(_from, address(_entity), _amount);\\n    }\\n\\n    /**\\n     * Make arbitrary calls to other contracts as this contract.\\n     * @param _target The target contract.\\n     * @param _value The ETH value to send.\\n     * @param _data The calldata.\\n     * @return _response The response from the call.\\n     * @notice This function exists so Endaoment admins can make arbitrary calls to other contracts as this contract, specially if to unlock incorrectly sent assets.\\n     */\\n    function callAsContract(address _target, uint256 _value, bytes memory _data)\\n        external\\n        payable\\n        requiresAuth\\n        returns (bytes memory)\\n    {\\n        (bool _success, bytes memory _response) = payable(_target).call{value: _value}(_data);\\n        if (!_success) revert CallFailed(_response);\\n        return _response;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/portfolios/TPlusNAsset.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: BSD 3-Clause\\npragma solidity 0.8.13;\\n\\nimport {ERC20} from \\\"solmate/tokens/ERC20.sol\\\";\\n\\n/// @title TPlusNAsset\\n/// @notice An ERC20 contract used by TPlusNPortfolio contracts to represent their underlying asset\\ncontract TPlusNAsset is ERC20 {\\n    /// STATE\\n\\n    /// @notice Address of the Endaoment Portfolio / Minter.\\n    address public portfolio;\\n\\n    /// EVENTS\\n    event PortfolioSet(address indexed newPortfolio);\\n\\n    /// ERRORS\\n\\n    /// @notice Emitted when bad caller on portfolio-only calls.\\n    error OnlyPortfolio();\\n\\n    constructor(string memory _name, string memory _symbol, address _portfolio) ERC20(_name, _symbol, 18) {\\n        portfolio = _portfolio;\\n        emit PortfolioSet(_portfolio);\\n    }\\n\\n    /// MODIFIERS\\n\\n    /**\\n     * @notice Make function only callable by the owning portfolio.\\n     */\\n    modifier onlyPortfolio() {\\n        _onlyPortfolio();\\n        _;\\n    }\\n\\n    /**\\n     * @notice Internal function to check that the caller is the owning portfolio.\\n     * @dev Added for gas savings.\\n     */\\n    function _onlyPortfolio() private view {\\n        if (msg.sender != portfolio) revert OnlyPortfolio();\\n    }\\n\\n    /**\\n     * @notice Mint assets for a given address.\\n     * @param _to The address to mint to.\\n     * @param _amount The amount to mint.\\n     * @dev Only callable by the owning portfolio.\\n     */\\n    function mint(address _to, uint256 _amount) external onlyPortfolio {\\n        _mint(_to, _amount);\\n    }\\n\\n    /**\\n     * @notice Burn assets from a given address.\\n     * @param _from The address to burn from.\\n     * @param _amount The amount to burn.\\n     * @dev Only callable by the owning portfolio.\\n     */\\n    function burn(address _from, uint256 _amount) external onlyPortfolio {\\n        _burn(_from, _amount);\\n    }\\n\\n    /**\\n     * @notice Burn assets from the caller.\\n     * @param _amount The amount to burn.\\n     * @dev Callable by anyone since it burns from the caller's balance.\\n     */\\n    function burn(uint256 _amount) external {\\n        _burn(msg.sender, _amount);\\n    }\\n\\n    /**\\n     * @notice Update the owning portfolio\\n     * @param _newPortfolio The new portfolio address\\n     * @notice Should be rarely used but can be in case of a portfolio migration, to be able to use the same asset contract\\n     * @dev Only callable by the current portfolio\\n     */\\n    function setPortfolio(address _newPortfolio) external onlyPortfolio {\\n        portfolio = _newPortfolio;\\n        emit PortfolioSet(_newPortfolio);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/Registry.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: BSD 3-Clause\\npragma solidity 0.8.13;\\n\\nimport {Math} from \\\"./lib/Math.sol\\\";\\nimport {ERC20} from \\\"solmate/tokens/ERC20.sol\\\";\\nimport {Auth, Authority} from \\\"./lib/auth/Auth.sol\\\";\\nimport {SafeTransferLib} from \\\"solmate/utils/SafeTransferLib.sol\\\";\\n\\nimport {RegistryAuth} from \\\"./RegistryAuth.sol\\\";\\nimport {Entity} from \\\"./Entity.sol\\\";\\nimport {ISwapWrapper} from \\\"./interfaces/ISwapWrapper.sol\\\";\\nimport {Portfolio} from \\\"./Portfolio.sol\\\";\\n\\n// --- Errors ---\\nerror Unauthorized();\\nerror UnsupportedSwapper();\\n\\n/**\\n * @notice Registry entity - manages Factory and Entity state info.\\n */\\ncontract Registry is RegistryAuth {\\n    // --- Storage ---\\n\\n    /// @notice Treasury address can receives fees.\\n    address public treasury;\\n\\n    /// @notice Base Token address is the stable coin contract used throughout the system.\\n    ERC20 public immutable baseToken;\\n\\n    /// @notice Mapping of approved factory contracts that are allowed to register new Entities.\\n    mapping(address => bool) public isApprovedFactory;\\n    /// @notice Mapping of active status of entities.\\n    mapping(Entity => bool) public isActiveEntity;\\n\\n    /// @notice Maps entity type to donation fee percentage stored as a zoc, where type(uint32).max represents 0.\\n    mapping(uint8 => uint32) defaultDonationFee;\\n    /// @notice Maps specific entity receiver to donation fee percentage stored as a zoc.\\n    mapping(Entity => uint32) donationFeeReceiverOverride;\\n\\n    /// @notice Maps entity type to payout fee percentage stored as a zoc, where type(uint32).max represents 0.\\n    mapping(uint8 => uint32) defaultPayoutFee;\\n    /// @notice Maps specific entity sender to payout fee percentage stored as a zoc.\\n    mapping(Entity => uint32) payoutFeeOverride;\\n\\n    /// @notice Maps sender entity type to receiver entity type to fee percentage as a zoc.\\n    mapping(uint8 => mapping(uint8 => uint32)) defaultTransferFee;\\n    /// @notice Maps specific entity sender to receiver entity type to fee percentage as a zoc.\\n    mapping(Entity => mapping(uint8 => uint32)) transferFeeSenderOverride;\\n    /// @notice Maps sender entity type to specific entity receiver to fee percentage as a zoc.\\n    mapping(uint8 => mapping(Entity => uint32)) transferFeeReceiverOverride;\\n    /// @notice Maps swap wrappers to their enabled/disabled status.\\n\\n    mapping(ISwapWrapper => bool) public isSwapperSupported;\\n    /// @notice Maps portfolios to their enabled/disabled status.\\n    mapping(Portfolio => bool) public isActivePortfolio;\\n\\n    // --- Events ---\\n\\n    /// @notice The event emitted when a factory is approved (whitelisted) or has it's approval removed.\\n    event FactoryApprovalSet(address indexed factory, bool isApproved);\\n\\n    /// @notice The event emitted when an entity is set active or inactive.\\n    event EntityStatusSet(address indexed entity, bool isActive);\\n\\n    /// @notice The event emitted when a swap wrapper is set active or inactive.\\n    event SwapWrapperStatusSet(address indexed swapWrapper, bool isSupported);\\n\\n    /// @notice The event emitted when a portfolio is set active or inactive.\\n    event PortfolioStatusSet(address indexed portfolio, bool isActive);\\n\\n    /// @notice Emitted when a default donation fee is set for an entity type.\\n    event DefaultDonationFeeSet(uint8 indexed entityType, uint32 fee);\\n\\n    /// @notice Emitted when a donation fee override is set for a specific receiving entity.\\n    event DonationFeeReceiverOverrideSet(address indexed entity, uint32 fee);\\n\\n    /// @notice Emitted when a default payout fee is set for an entity type.\\n    event DefaultPayoutFeeSet(uint8 indexed entityType, uint32 fee);\\n\\n    /// @notice Emitted when a payout fee override is set for a specific sender entity.\\n    event PayoutFeeOverrideSet(address indexed entity, uint32 fee);\\n\\n    /// @notice Emitted when a default transfer fee is set for transfers between entity types.\\n    event DefaultTransferFeeSet(uint8 indexed fromEntityType, uint8 indexed toEntityType, uint32 fee);\\n\\n    /// @notice Emitted when a transfer fee override is set for transfers from an entity to a specific entityType.\\n    event TransferFeeSenderOverrideSet(address indexed fromEntity, uint8 indexed toEntityType, uint32 fee);\\n\\n    /// @notice Emitted when a transfer fee override is set for transfers from an entityType to an entity.\\n    event TransferFeeReceiverOverrideSet(uint8 indexed fromEntityType, address indexed toEntity, uint32 fee);\\n\\n    /// @notice Emitted when the registry treasury contract is changed\\n    event TreasuryChanged(address oldTreasury, address indexed newTreasury);\\n\\n    /**\\n     * @notice Modifier for methods that require auth and that the manager cannot access.\\n     * @dev Overridden from Auth.sol. Reason: use custom error.\\n     */\\n    modifier requiresAuth() override {\\n        if (!isAuthorized(msg.sender, msg.sig)) revert Unauthorized();\\n\\n        _;\\n    }\\n\\n    // --- Constructor ---\\n    constructor(address _admin, address _treasury, ERC20 _baseToken) RegistryAuth(_admin, Authority(address(this))) {\\n        treasury = _treasury;\\n        emit TreasuryChanged(address(0), _treasury);\\n        baseToken = _baseToken;\\n    }\\n\\n    // --- Internal fns ---\\n\\n    /**\\n     * @notice Fee parsing to convert the special \\\"type(uint32).max\\\" value to zero, and zero to the \\\"max\\\".\\n     * @dev After converting, \\\"type(uint32).max\\\" will cause overflow/revert when used as a fee percentage multiplier and zero will mean no fee.\\n     * @param _value The value to be converted.\\n     * @return The parsed fee to use.\\n     */\\n    function _parseFeeWithFlip(uint32 _value) private pure returns (uint32) {\\n        if (_value == 0) {\\n            return type(uint32).max;\\n        } else if (_value == type(uint32).max) {\\n            return 0;\\n        } else {\\n            return _value;\\n        }\\n    }\\n\\n    // --- External fns ---\\n\\n    /**\\n     * @notice Sets a new Endaoment treasury address.\\n     * @param _newTreasury The new treasury.\\n     */\\n    function setTreasury(address _newTreasury) external requiresAuth {\\n        emit TreasuryChanged(treasury, _newTreasury);\\n        treasury = _newTreasury;\\n    }\\n\\n    /**\\n     * @notice Sets the approval state of a factory. Grants the factory permissions to set entity status.\\n     * @param _factory The factory whose approval state is to be updated.\\n     * @param _isApproved True if the factory should be approved, false otherwise.\\n     */\\n    function setFactoryApproval(address _factory, bool _isApproved) external requiresAuth {\\n        isApprovedFactory[_factory] = _isApproved;\\n        emit FactoryApprovalSet(address(_factory), _isApproved);\\n    }\\n\\n    /**\\n     * @notice Sets the enable/disable state of an Entity.\\n     * @param _entity The entity whose active state is to be updated.\\n     * @param _isActive True if the entity should be active, false otherwise.\\n     */\\n    function setEntityStatus(Entity _entity, bool _isActive) external requiresAuth {\\n        isActiveEntity[_entity] = _isActive;\\n        emit EntityStatusSet(address(_entity), _isActive);\\n    }\\n\\n    /**\\n     * @notice Sets Entity as active. This is a special method to be called only by approved factories.\\n     * Other callers should use `setEntityStatus` instead.\\n     * @param _entity The entity.\\n     */\\n    function setEntityActive(Entity _entity) external {\\n        if (!isApprovedFactory[msg.sender]) revert Unauthorized();\\n        isActiveEntity[_entity] = true;\\n        emit EntityStatusSet(address(_entity), true);\\n    }\\n\\n    /**\\n     * @notice Sets the enable/disable state of a Portfolio.\\n     * @param _portfolio Portfolio.\\n     * @param _isActive True if setting portfolio to active, false otherwise.\\n     */\\n    function setPortfolioStatus(Portfolio _portfolio, bool _isActive) external requiresAuth {\\n        isActivePortfolio[_portfolio] = _isActive;\\n        emit PortfolioStatusSet(address(_portfolio), _isActive);\\n    }\\n\\n    /**\\n     * @notice Gets default donation fee pct (as a zoc) for an Entity.\\n     * @param _entity The receiving entity of the donation for which the fee is being fetched.\\n     * @return uint32 The default donation fee for the entity's type.\\n     * @dev Makes use of _parseFeeWithFlip, so if no default exists, \\\"max\\\" will be returned.\\n     */\\n    function getDonationFee(Entity _entity) external view returns (uint32) {\\n        return _parseFeeWithFlip(defaultDonationFee[_entity.entityType()]);\\n    }\\n\\n    /**\\n     * @notice Gets lowest possible donation fee pct (as a zoc) for an Entity, among default and override.\\n     * @param _entity The receiving entity of the donation for which the fee is being fetched.\\n     * @return uint32 The minimum of the default donation fee and the receiver's fee override.\\n     * @dev Makes use of _parseFeeWithFlip, so if no default or override exists, \\\"max\\\" will be returned.\\n     */\\n    function getDonationFeeWithOverrides(Entity _entity) external view returns (uint32) {\\n        uint32 _default = _parseFeeWithFlip(defaultDonationFee[_entity.entityType()]);\\n        uint32 _receiverOverride = _parseFeeWithFlip(donationFeeReceiverOverride[_entity]);\\n        return _receiverOverride < _default ? _receiverOverride : _default;\\n    }\\n\\n    /**\\n     * @notice Gets default payout fee pct (as a zoc) for an Entity.\\n     * @param _entity The sender entity of the payout for which the fee is being fetched.\\n     * @return uint32 The default payout fee for the entity's type.\\n     * @dev Makes use of _parseFeeWithFlip, so if no default exists, \\\"max\\\" will be returned.\\n     */\\n    function getPayoutFee(Entity _entity) external view returns (uint32) {\\n        return _parseFeeWithFlip(defaultPayoutFee[_entity.entityType()]);\\n    }\\n\\n    /**\\n     * @notice Gets lowest possible payout fee pct (as a zoc) for an Entity, among default and override.\\n     * @param _entity The sender entity of the payout for which the fee is being fetched.\\n     * @return uint32 The minimum of the default payout fee and the sender's fee override.\\n     * @dev Makes use of _parseFeeWithFlip, so if no default or override exists, \\\"max\\\" will be returned.\\n     */\\n    function getPayoutFeeWithOverrides(Entity _entity) external view returns (uint32) {\\n        uint32 _default = _parseFeeWithFlip(defaultPayoutFee[_entity.entityType()]);\\n        uint32 _senderOverride = _parseFeeWithFlip(payoutFeeOverride[_entity]);\\n        return _senderOverride < _default ? _senderOverride : _default;\\n    }\\n\\n    /**\\n     * @notice Gets default transfer fee pct (as a zoc) between sender & receiver Entities.\\n     * @param _sender The sending entity of the transfer for which the fee is being fetched.\\n     * @param _receiver The receiving entity of the transfer for which the fee is being fetched.\\n     * @return uint32 The default transfer fee.\\n     * @dev Makes use of _parseFeeWithFlip, so if no default exists, \\\"type(uint32).max\\\" will be returned.\\n     */\\n    function getTransferFee(Entity _sender, Entity _receiver) external view returns (uint32) {\\n        return _parseFeeWithFlip(defaultTransferFee[_sender.entityType()][_receiver.entityType()]);\\n    }\\n\\n    /**\\n     * @notice Gets lowest possible transfer fee pct (as a zoc) between sender & receiver Entities, among default and overrides.\\n     * @param _sender The sending entity of the transfer for which the fee is being fetched.\\n     * @param _receiver The receiving entity of the transfer for which the fee is being fetched.\\n     * @return uint32 The minimum of the default transfer fee, and sender and receiver overrides.\\n     * @dev Makes use of _parseFeeWithFlip, so if no default or overrides exist, \\\"type(uint32).max\\\" will be returned.\\n     */\\n    function getTransferFeeWithOverrides(Entity _sender, Entity _receiver) external view returns (uint32) {\\n        uint32 _default = _parseFeeWithFlip(defaultTransferFee[_sender.entityType()][_receiver.entityType()]);\\n        uint32 _senderOverride = _parseFeeWithFlip(transferFeeSenderOverride[_sender][_receiver.entityType()]);\\n        uint32 _receiverOverride = _parseFeeWithFlip(transferFeeReceiverOverride[_sender.entityType()][_receiver]);\\n\\n        uint32 _lowestFee = _default;\\n        _lowestFee = _senderOverride < _lowestFee ? _senderOverride : _lowestFee;\\n        _lowestFee = _receiverOverride < _lowestFee ? _receiverOverride : _lowestFee;\\n        return _lowestFee;\\n    }\\n\\n    /**\\n     * @notice Sets the default donation fee for an entity type.\\n     * @param _entityType Entity type.\\n     * @param _fee The fee percentage to be set (a zoc).\\n     */\\n    function setDefaultDonationFee(uint8 _entityType, uint32 _fee) external requiresAuth {\\n        defaultDonationFee[_entityType] = _parseFeeWithFlip(_fee);\\n        emit DefaultDonationFeeSet(_entityType, _fee);\\n    }\\n\\n    /**\\n     * @notice Sets the donation fee receiver override for a specific entity.\\n     * @param _entity Entity.\\n     * @param _fee The overriding fee (a zoc).\\n     */\\n    function setDonationFeeReceiverOverride(Entity _entity, uint32 _fee) external requiresAuth {\\n        donationFeeReceiverOverride[_entity] = _parseFeeWithFlip(_fee);\\n        emit DonationFeeReceiverOverrideSet(address(_entity), _fee);\\n    }\\n\\n    /**\\n     * @notice Sets the default payout fee for an entity type.\\n     * @param _entityType Entity type.\\n     * @param _fee The fee percentage to be set (a zoc).\\n     */\\n    function setDefaultPayoutFee(uint8 _entityType, uint32 _fee) external requiresAuth {\\n        defaultPayoutFee[_entityType] = _parseFeeWithFlip(_fee);\\n        emit DefaultPayoutFeeSet(_entityType, _fee);\\n    }\\n\\n    /**\\n     * @notice Sets the payout fee override for a specific entity.\\n     * @param _entity Entity.\\n     * @param _fee The overriding fee (a zoc).\\n     */\\n    function setPayoutFeeOverride(Entity _entity, uint32 _fee) external requiresAuth {\\n        payoutFeeOverride[_entity] = _parseFeeWithFlip(_fee);\\n        emit PayoutFeeOverrideSet(address(_entity), _fee);\\n    }\\n\\n    /**\\n     * @notice Sets the default transfer fee for transfers from one specific entity type to another.\\n     * @param _fromEntityType The entityType making the transfer.\\n     * @param _toEntityType The receiving entityType.\\n     * @param _fee The transfer fee percentage (a zoc).\\n     */\\n    function setDefaultTransferFee(uint8 _fromEntityType, uint8 _toEntityType, uint32 _fee) external requiresAuth {\\n        defaultTransferFee[_fromEntityType][_toEntityType] = _parseFeeWithFlip(_fee);\\n        emit DefaultTransferFeeSet(_fromEntityType, _toEntityType, _fee);\\n    }\\n\\n    /**\\n     * @notice Sets the transfer fee override for transfers from one specific entity to entities of a given type.\\n     * @param _fromEntity The entity making the transfer.\\n     * @param _toEntityType The receiving entityType.\\n     * @param _fee The overriding fee percentage (a zoc).\\n     */\\n    function setTransferFeeSenderOverride(Entity _fromEntity, uint8 _toEntityType, uint32 _fee) external requiresAuth {\\n        transferFeeSenderOverride[_fromEntity][_toEntityType] = _parseFeeWithFlip(_fee);\\n        emit TransferFeeSenderOverrideSet(address(_fromEntity), _toEntityType, _fee);\\n    }\\n\\n    /**\\n     * @notice Sets the transfer fee override for transfers from entities of a given type to a specific entity.\\n     * @param _fromEntityType The entityType making the transfer.\\n     * @param _toEntity The receiving entity.\\n     * @param _fee The overriding fee percentage (a zoc).\\n     */\\n    function setTransferFeeReceiverOverride(uint8 _fromEntityType, Entity _toEntity, uint32 _fee)\\n        external\\n        requiresAuth\\n    {\\n        transferFeeReceiverOverride[_fromEntityType][_toEntity] = _parseFeeWithFlip(_fee);\\n        emit TransferFeeReceiverOverrideSet(_fromEntityType, address(_toEntity), _fee);\\n    }\\n\\n    /**\\n     * @notice Sets the enable/disable state of a SwapWrapper. System owners must ensure meticulous review of SwapWrappers before approving them.\\n     * @param _swapWrapper A contract that implements ISwapWrapper.\\n     * @param _supported `true` if supported, `false` if unsupported.\\n     */\\n    function setSwapWrapperStatus(ISwapWrapper _swapWrapper, bool _supported) external requiresAuth {\\n        isSwapperSupported[_swapWrapper] = _supported;\\n        emit SwapWrapperStatusSet(address(_swapWrapper), _supported);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/Entity.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: BSD 3-Clause\\npragma solidity >=0.8.0;\\n\\nimport \\\"solmate/tokens/ERC20.sol\\\";\\nimport \\\"solmate/utils/SafeTransferLib.sol\\\";\\nimport \\\"./lib/ReentrancyGuard.sol\\\";\\n\\nimport {Registry} from \\\"./Registry.sol\\\";\\nimport {ISwapWrapper} from \\\"./interfaces/ISwapWrapper.sol\\\";\\nimport {EndaomentAuth} from \\\"./lib/auth/EndaomentAuth.sol\\\";\\nimport {Portfolio} from \\\"./Portfolio.sol\\\";\\nimport {Math} from \\\"./lib/Math.sol\\\";\\n\\nerror EntityInactive();\\nerror PortfolioInactive();\\nerror InsufficientFunds();\\nerror InvalidAction();\\nerror BalanceMismatch();\\nerror CallFailed(bytes response);\\n\\n/**\\n * @notice Entity contract inherited by Org and Fund contracts (and all future kinds of Entities).\\n */\\nabstract contract Entity is EndaomentAuth, ReentrancyGuard {\\n    using Math for uint256;\\n    using SafeTransferLib for ERC20;\\n\\n    /// @notice The base registry to which the entity is connected.\\n    Registry public registry;\\n\\n    /// @notice The entity's manager.\\n    address public manager;\\n\\n    // @notice The base token used for tracking the entity's fund balance.\\n    ERC20 public baseToken;\\n\\n    /// @notice The current balance for the entity, denominated in the base token's units.\\n    uint256 public balance;\\n\\n    /// @notice Placeholder address used in swapping method to denote usage of ETH instead of a token.\\n    address public constant ETH_PLACEHOLDER = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n\\n    /// @notice Emitted when manager is set.\\n    event EntityManagerSet(address indexed oldManager, address indexed newManager);\\n\\n    /// @notice Emitted when a donation is made.\\n    event EntityDonationReceived(\\n        address indexed from,\\n        address indexed to,\\n        address indexed tokenIn,\\n        uint256 amountIn,\\n        uint256 amountReceived,\\n        uint256 amountFee\\n    );\\n\\n    /// @notice Emitted when a payout is made from an entity.\\n    event EntityValuePaidOut(address indexed from, address indexed to, uint256 amountSent, uint256 amountFee);\\n\\n    /// @notice Emitted when a transfer is made between entities.\\n    event EntityValueTransferred(address indexed from, address indexed to, uint256 amountReceived, uint256 amountFee);\\n\\n    /// @notice Emitted when a base token reconciliation completes\\n    event EntityBalanceReconciled(address indexed entity, uint256 amountReceived, uint256 amountFee);\\n\\n    /// @notice Emitted when a base token balance is used to correct the internal contract balance.\\n    event EntityBalanceCorrected(address indexed entity, uint256 newBalance);\\n\\n    /// @notice Emitted when a portfolio deposit is made.\\n    event EntityDeposit(address indexed portfolio, uint256 baseTokenDeposited, uint256 sharesReceived);\\n\\n    /// @notice Emitted when a portfolio share redemption is made.\\n    event EntityRedeem(address indexed portfolio, uint256 sharesRedeemed, uint256 baseTokenReceived);\\n\\n    /// @notice Emitted when ether is received.\\n    event EntityEthReceived(address indexed sender, uint256 amount);\\n\\n    /**\\n     * @notice Modifier for methods that require auth and that the manager can access.\\n     * @dev Uses the same condition as `requiresAuth` but with added manager access.\\n     */\\n    modifier requiresManager() {\\n        if (msg.sender != manager && !isAuthorized(msg.sender, msg.sig)) revert Unauthorized();\\n        _;\\n    }\\n\\n    /// @notice Each entity will implement this function to allow a caller to interrogate what kind of entity it is.\\n    function entityType() public pure virtual returns (uint8);\\n\\n    /**\\n     * @notice One time method to be called at deployment to configure the contract. Required so Entity\\n     * contracts can be deployed as minimal proxies (clones).\\n     * @param _registry The registry to host the Entity.\\n     * @param _manager The address of the Entity's manager.\\n     */\\n    function __initEntity(Registry _registry, address _manager) internal {\\n        // Call to EndaomentAuth's initialize function ensures that this can't be called again\\n        __initEndaomentAuth(_registry, bytes20(bytes.concat(\\\"entity\\\", bytes1(entityType()))));\\n        __initReentrancyGuard();\\n        registry = _registry;\\n        manager = _manager;\\n        baseToken = _registry.baseToken();\\n    }\\n\\n    /**\\n     * @notice Set a new manager for this entity.\\n     * @param _manager Address of new manager.\\n     * @dev Callable by current manager or permissioned role.\\n     */\\n    function setManager(address _manager) external virtual requiresManager {\\n        emit EntityManagerSet(manager, _manager);\\n        manager = _manager;\\n    }\\n\\n    /**\\n     * @notice Receives a donated amount of base tokens to be added to the entity's balance. Transfers default fee to treasury.\\n     * @param _amount Amount donated in base token.\\n     * @dev Reverts if the donation fee percentage is larger than 100% (equal to 1e4 when represented as a zoc).\\n     * @dev Reverts if the token transfer fails.\\n     */\\n    function donate(uint256 _amount) external virtual {\\n        uint32 _feeMultiplier = registry.getDonationFee(this);\\n        _donateWithFeeMultiplier(_amount, _feeMultiplier);\\n    }\\n\\n    /**\\n     * @notice Receives a donated amount of base tokens to be added to the entity's balance. Transfers default or overridden fee to treasury.\\n     * @param _amount Amount donated in base token.\\n     * @dev Reverts if the donation fee percentage is larger than 100% (equal to 1e4 when represented as a zoc).\\n     * @dev Reverts if the token transfer fails.\\n     */\\n    function donateWithOverrides(uint256 _amount) external virtual {\\n        uint32 _feeMultiplier = registry.getDonationFeeWithOverrides(this);\\n        _donateWithFeeMultiplier(_amount, _feeMultiplier);\\n    }\\n\\n    /**\\n     * @notice Receives a donated amount of base tokens to be added to the entity's balance.\\n     * This method can be called by permissioned actors to make a donation with a manually specified fee.\\n     * @param _amount Amount donated in base token.\\n     * @param _feeOverride Fee percentage as zoc.\\n     * @dev Reverts if the transfer fee percentage is larger than 100% (equal to 1e4 when represented as a zoc).\\n     * @dev Reverts if the token transfer fails.\\n     * @dev Reverts with `Unauthorized` if the `msg.sender` is not a privileged role.\\n     */\\n    function donateWithAdminOverrides(uint256 _amount, uint32 _feeOverride) external virtual requiresAuth {\\n        _donateWithFeeMultiplier(_amount, _feeOverride);\\n    }\\n\\n    /**\\n     * @notice Receives a donated amount of base tokens to be added to the entity's balance. Transfers fee calculated by fee multiplier to treasury.\\n     * @param _amount Amount donated in base token.\\n     * @param _feeMultiplier Value indicating the percentage of the Endaoment donation fee to go to the Endaoment treasury.\\n     * @dev Reverts if the donation fee percentage is larger than 100% (equal to 1e4 when represented as a zoc).\\n     * @dev Reverts if the token transfer fails.\\n     */\\n    function _donateWithFeeMultiplier(uint256 _amount, uint32 _feeMultiplier) internal virtual {\\n        (uint256 _netAmount, uint256 _fee) = _calculateFee(_amount, _feeMultiplier);\\n        baseToken.safeTransferFrom(msg.sender, registry.treasury(), _fee);\\n        baseToken.safeTransferFrom(msg.sender, address(this), _netAmount);\\n\\n        unchecked {\\n            // unchecked as no possibility of overflow with baseToken precision\\n            balance += _netAmount;\\n        }\\n        emit EntityDonationReceived(msg.sender, address(this), address(baseToken), _amount, _amount, _fee);\\n    }\\n\\n    /**\\n     * @notice Receive a donated amount of ETH or ERC20 tokens, swaps them to base tokens, and adds the output to the\\n     * entity's balance. Fee calculated using default rate and sent to treasury.\\n     * @param _swapWrapper The swap wrapper to use for the donation. Must be whitelisted on the Registry.\\n     * @param _tokenIn The address of the ERC20 token to swap and donate, or ETH_PLACEHOLDER if donating ETH.\\n     * @param _amountIn The amount of tokens or ETH being swapped and donated.\\n     * @param _data Additional call data required by the ISwapWrapper being used.\\n     */\\n    function swapAndDonate(ISwapWrapper _swapWrapper, address _tokenIn, uint256 _amountIn, bytes calldata _data)\\n        external\\n        payable\\n        virtual\\n    {\\n        uint32 _feeMultiplier = registry.getDonationFee(this);\\n        _swapAndDonateWithFeeMultiplier(_swapWrapper, _tokenIn, _amountIn, _data, _feeMultiplier);\\n    }\\n\\n    /**\\n     * @notice Receive a donated amount of ETH or ERC20 tokens, swaps them to base tokens, and adds the output to the\\n     * entity's balance. Fee calculated using override rate and sent to treasury.\\n     * @param _swapWrapper The swap wrapper to use for the donation. Must be whitelisted on the Registry.\\n     * @param _tokenIn The address of the ERC20 token to swap and donate, or ETH_PLACEHOLDER if donating ETH.\\n     * @param _amountIn The amount of tokens or ETH being swapped and donated.\\n     * @param _data Additional call data required by the ISwapWrapper being used.\\n     */\\n    function swapAndDonateWithOverrides(\\n        ISwapWrapper _swapWrapper,\\n        address _tokenIn,\\n        uint256 _amountIn,\\n        bytes calldata _data\\n    ) external payable virtual {\\n        uint32 _feeMultiplier = registry.getDonationFeeWithOverrides(this);\\n        _swapAndDonateWithFeeMultiplier(_swapWrapper, _tokenIn, _amountIn, _data, _feeMultiplier);\\n    }\\n\\n    /// @dev Internal helper implementing swap and donate functionality for any fee multiplier provided.\\n    function _swapAndDonateWithFeeMultiplier(\\n        ISwapWrapper _swapWrapper,\\n        address _tokenIn,\\n        uint256 _amountIn,\\n        bytes calldata _data,\\n        uint32 _feeMultiplier\\n    ) internal virtual nonReentrant {\\n        if (!registry.isSwapperSupported(_swapWrapper)) revert InvalidAction();\\n\\n        // THINK: do we need a re-entrancy guard on this method?\\n        if (_tokenIn != ETH_PLACEHOLDER) {\\n            ERC20(_tokenIn).safeTransferFrom(msg.sender, address(this), _amountIn);\\n            ERC20(_tokenIn).safeApprove(address(_swapWrapper), 0);\\n            ERC20(_tokenIn).safeApprove(address(_swapWrapper), _amountIn);\\n        }\\n\\n        uint256 _amountOut =\\n            _swapWrapper.swap{value: msg.value}(_tokenIn, address(baseToken), address(this), _amountIn, _data);\\n\\n        (uint256 _netAmount, uint256 _fee) = _calculateFee(_amountOut, _feeMultiplier);\\n\\n        baseToken.safeTransfer(registry.treasury(), _fee);\\n\\n        unchecked {\\n            // unchecked as no possibility of overflow with baseToken precision\\n            balance += _netAmount;\\n        }\\n\\n        if (balance > baseToken.balanceOf(address(this))) revert BalanceMismatch();\\n\\n        emit EntityDonationReceived(msg.sender, address(this), _tokenIn, _amountIn, _amountOut, _fee);\\n    }\\n\\n    /**\\n     * @notice Transfers an amount of base tokens from one entity to another. Transfers default fee to treasury.\\n     * @param _to The entity to receive the tokens.\\n     * @param _amount Contains the amount being donated (denominated in the base token's units).\\n     * @dev Reverts if the entity is inactive or if the token transfer fails.\\n     * @dev Reverts if the transfer fee percentage is larger than 100% (equal to 1e4 when represented as a zoc).\\n     * @dev Reverts with `Unauthorized` if the `msg.sender` is not the entity manager or a privileged role.\\n     * @dev Renamed from `transfer` to distinguish from ERC20 transfer in 3rd party tools.\\n     */\\n    function transferToEntity(Entity _to, uint256 _amount) external virtual requiresManager {\\n        uint32 _feeMultiplier = registry.getTransferFee(this, _to);\\n        _transferWithFeeMultiplier(_to, _amount, _feeMultiplier);\\n    }\\n\\n    /**\\n     * @notice Transfers an amount of base tokens from one entity to another. Transfers default or overridden fee to treasury.\\n     * @param _to The entity to receive the tokens.\\n     * @param _amount Contains the amount being donated (denominated in the base token's units).\\n     * @dev Reverts if the entity is inactive or if the token transfer fails.\\n     * @dev Reverts if the transfer fee percentage is larger than 100% (equal to 1e4 when represented as a zoc).\\n     * @dev Reverts with `Unauthorized` if the `msg.sender` is not the entity manager or a privileged role.\\n     */\\n    function transferToEntityWithOverrides(Entity _to, uint256 _amount) external virtual requiresManager {\\n        uint32 _feeMultiplier = registry.getTransferFeeWithOverrides(this, _to);\\n        _transferWithFeeMultiplier(_to, _amount, _feeMultiplier);\\n    }\\n\\n    /**\\n     * @notice Transfers an amount of base tokens from one entity to another. Transfers fee specified by a privileged role.\\n     * @param _to The entity to receive the tokens.\\n     * @param _amount Contains the amount being donated (denominated in the base token's units).\\n     * @param _feeOverride Admin override configured by an Admin\\n     * @dev Reverts if the entity is inactive or if the token transfer fails.\\n     * @dev Reverts if the transfer fee percentage is larger than 100% (equal to 1e4 when represented as a zoc).\\n     * @dev Reverts with `Unauthorized` if the `msg.sender` is not a privileged role.\\n     */\\n    function transferToEntityWithAdminOverrides(Entity _to, uint256 _amount, uint32 _feeOverride)\\n        external\\n        virtual\\n        requiresAuth\\n    {\\n        _transferWithFeeMultiplier(_to, _amount, _feeOverride);\\n    }\\n\\n    /**\\n     * @notice Transfers an amount of base tokens from one entity to another. Transfers fee calculated by fee multiplier to treasury.\\n     * @param _to The entity to receive the tokens.\\n     * @param _amount Contains the amount being donated (denominated in the base token's units).\\n     * @param _feeMultiplier Value indicating the percentage of the Endaoment donation fee to go to the Endaoment treasury.\\n     * @dev Reverts with 'Inactive' if the entity sending the transfer or the entity receiving the transfer is inactive.\\n     * @dev Reverts if the transfer fee percentage is larger than 100% (equal to 1e4 when represented as a zoc).\\n     * @dev Reverts with `Unauthorized` if the `msg.sender` is not the entity manager or a privileged role.\\n     * @dev Reverts if the token transfer fails.\\n     */\\n    function _transferWithFeeMultiplier(Entity _to, uint256 _amount, uint32 _feeMultiplier) internal virtual {\\n        if (!registry.isActiveEntity(this) || !registry.isActiveEntity(_to)) revert EntityInactive();\\n        if (balance < _amount) revert InsufficientFunds();\\n\\n        (uint256 _netAmount, uint256 _fee) = _calculateFee(_amount, _feeMultiplier);\\n        baseToken.safeTransfer(registry.treasury(), _fee);\\n        baseToken.safeTransfer(address(_to), _netAmount);\\n\\n        unchecked {\\n            // unchecked as no possibility of overflow with baseToken precision\\n            balance -= _amount;\\n            _to.receiveTransfer(_netAmount);\\n        }\\n        emit EntityValueTransferred(address(this), address(_to), _amount, _fee);\\n    }\\n\\n    /**\\n     * @notice Updates the receiving entity balance on a transfer.\\n     * @param _transferAmount The amount being received on the transfer.\\n     * @dev This function is external, but is restricted such that it can only be called by other entities.\\n     */\\n    function receiveTransfer(uint256 _transferAmount) external virtual {\\n        if (!registry.isActiveEntity(Entity(payable(msg.sender)))) revert EntityInactive();\\n        unchecked {\\n            // Cannot overflow with realistic balances.\\n            balance += _transferAmount;\\n        }\\n    }\\n\\n    /**\\n     * @notice Deposits an amount of Entity's `baseToken` into an Endaoment-approved Portfolio.\\n     * @param _portfolio An Endaoment-approved portfolio.\\n     * @param _amount Amount of `baseToken` to deposit into the portfolio.\\n     * @param _data Data required by a portfolio to deposit.\\n     * @return _shares Amount of portfolio share tokens Entity received as a result of this deposit.\\n     */\\n    function portfolioDeposit(Portfolio _portfolio, uint256 _amount, bytes calldata _data)\\n        external\\n        virtual\\n        requiresManager\\n        returns (uint256)\\n    {\\n        if (!registry.isActivePortfolio(_portfolio)) revert PortfolioInactive();\\n        balance -= _amount;\\n        baseToken.safeApprove(address(_portfolio), _amount);\\n        uint256 _shares = _portfolio.deposit(_amount, _data);\\n        emit EntityDeposit(address(_portfolio), _amount, _shares);\\n        return _shares;\\n    }\\n\\n    /**\\n     * @notice Redeems an amount of Entity's portfolio shares for an amount of `baseToken`.\\n     * @param _portfolio An Endaoment-approved portfolio.\\n     * @param _shares Amount of share tokens to redeem.\\n     * @param _data Data required by a portfolio to redeem.\\n     * @return _received Amount of `baseToken` Entity received as a result of this redemption.\\n     */\\n    function portfolioRedeem(Portfolio _portfolio, uint256 _shares, bytes calldata _data)\\n        external\\n        virtual\\n        requiresManager\\n        returns (uint256)\\n    {\\n        if (!registry.isActivePortfolio(_portfolio)) revert PortfolioInactive();\\n        uint256 _received = _portfolio.redeem(_shares, _data);\\n        // unchecked: a realistic balance can never overflow a uint256\\n        unchecked {\\n            balance += _received;\\n        }\\n        emit EntityRedeem(address(_portfolio), _shares, _received);\\n        return _received;\\n    }\\n\\n    /**\\n     * @notice This method should be called to reconcile the Entity's internal baseToken accounting with the baseToken contract's accounting.\\n     * There are a 2 situations where calling this method is appropriate:\\n     * 1. To process amounts of baseToken that arrived at this Entity through methods besides Entity:donate or Entity:transfer. For example,\\n     * if this Entity receives a normal ERC20 transfer of baseToken, the amount received will be unavailable for Entity use until this method\\n     * is called to adjust the balance and process fees. OrgFundFactory.sol:_donate makes use of this method to do this as well.\\n     * 2. Unusually, the Entity's perspective of balance could be lower than `baseToken.balanceOf(this)`. This could happen if\\n     * Entity:callAsEntity is used to transfer baseToken. In this case, this method provides a way of correcting the Entity's internal balance.\\n     */\\n    function reconcileBalance() external virtual {\\n        uint256 _tokenBalance = baseToken.balanceOf(address(this));\\n\\n        if (_tokenBalance >= balance) {\\n            uint256 _sweepAmount = _tokenBalance - balance;\\n            uint32 _feeMultiplier = registry.getDonationFeeWithOverrides(this);\\n            (uint256 _netAmount, uint256 _fee) = _calculateFee(_sweepAmount, _feeMultiplier);\\n\\n            baseToken.safeTransfer(registry.treasury(), _fee);\\n            unchecked {\\n                balance += _netAmount;\\n            }\\n            emit EntityBalanceReconciled(address(this), _sweepAmount, _fee);\\n        } else {\\n            // Handle abnormal scenario where _tokenBalance < balance (see method docs)\\n            balance = _tokenBalance;\\n            emit EntityBalanceCorrected(address(this), _tokenBalance);\\n        }\\n    }\\n\\n    /**\\n     * @notice Takes stray tokens or ETH sent directly to this Entity, swaps them for base token, then adds them to the\\n     * Entity's balance after paying the appropriate fee to the treasury.\\n     * @param _swapWrapper The swap wrapper to use to convert the assets. Must be whitelisted on the Registry.\\n     * @param _tokenIn The address of the ERC20 token to swap, or ETH_PLACEHOLDER if ETH.\\n     * @param _amountIn The amount of tokens or ETH being swapped and added to the balance.\\n     * @param _data Additional call data required by the ISwapWrapper being used.\\n     */\\n    function swapAndReconcileBalance(\\n        ISwapWrapper _swapWrapper,\\n        address _tokenIn,\\n        uint256 _amountIn,\\n        bytes calldata _data\\n    ) external virtual nonReentrant requiresManager {\\n        if (!registry.isSwapperSupported(_swapWrapper)) revert InvalidAction();\\n\\n        uint32 _feeMultiplier = registry.getDonationFeeWithOverrides(this);\\n\\n        if (_tokenIn != ETH_PLACEHOLDER) {\\n            ERC20(_tokenIn).safeApprove(address(_swapWrapper), 0);\\n            ERC20(_tokenIn).safeApprove(address(_swapWrapper), _amountIn);\\n        }\\n\\n        // Send value only if token in is ETH\\n        uint256 _value = _tokenIn == ETH_PLACEHOLDER ? _amountIn : 0;\\n\\n        uint256 _amountOut =\\n            _swapWrapper.swap{value: _value}(_tokenIn, address(baseToken), address(this), _amountIn, _data);\\n\\n        (uint256 _netAmount, uint256 _fee) = _calculateFee(_amountOut, _feeMultiplier);\\n        baseToken.safeTransfer(registry.treasury(), _fee);\\n\\n        unchecked {\\n            // unchecked as no possibility of overflow with baseToken precision\\n            balance += _netAmount;\\n        }\\n\\n        if (balance > baseToken.balanceOf(address(this))) revert BalanceMismatch();\\n\\n        emit EntityBalanceReconciled(address(this), _amountOut, _fee);\\n    }\\n\\n    /**\\n     * @notice Permissioned method that allows Endaoment admin to make arbitrary calls acting as this Entity.\\n     * @param _target The address to which the call will be made.\\n     * @param _value The ETH value that should be forwarded with the call.\\n     * @param _data The calldata that will be sent with the call.\\n     * @return _return The data returned by the call.\\n     */\\n    function callAsEntity(address _target, uint256 _value, bytes memory _data)\\n        external\\n        payable\\n        virtual\\n        requiresAuth\\n        returns (bytes memory)\\n    {\\n        (bool _success, bytes memory _response) = payable(_target).call{value: _value}(_data);\\n        if (!_success) revert CallFailed(_response);\\n        return _response;\\n    }\\n\\n    /**\\n     * @notice Pays out an amount of base tokens from the entity to an address. Transfers the fee calculated by the\\n     * default fee multiplier to the treasury.\\n     * @param _to The address to receive the tokens.\\n     * @param _amount Amount donated in base token.\\n     * @dev Reverts with `Unauthorized` if the `msg.sender` is not a privileged role.\\n     * @dev Reverts if the fee percentage is larger than 100% (equal to 1e4 when represented as a zoc).\\n     * @dev Reverts if the token transfer fails.\\n     */\\n    function payout(address _to, uint256 _amount) external virtual requiresAuth {\\n        uint32 _feeMultiplier = registry.getPayoutFee(this);\\n        _payoutWithFeeMultiplier(_to, _amount, _feeMultiplier);\\n    }\\n\\n    /**\\n     * @notice Pays out an amount of base tokens from the entity to an address. Transfers the fee calculated by the\\n     * default fee multiplier to the treasury.\\n     * @param _amount Amount donated in base token.\\n     * @dev Reverts with `Unauthorized` if the `msg.sender` is not a privileged role.\\n     * @dev Reverts if the fee percentage is larger than 100% (equal to 1e4 when represented as a zoc).\\n     * @dev Reverts if the token transfer fails.\\n     */\\n    function payoutWithOverrides(address _to, uint256 _amount) external virtual requiresAuth {\\n        uint32 _feeMultiplier = registry.getPayoutFeeWithOverrides(this);\\n        _payoutWithFeeMultiplier(_to, _amount, _feeMultiplier);\\n    }\\n\\n    /**\\n     * @notice Pays out an amount of base tokens from the entity to an address. Transfers fee specified by a privileged role.\\n     * @param _amount Amount donated in base token.\\n     * @param _feeOverride Payout override configured by an Admin\\n     * @dev Reverts with `Unauthorized` if the `msg.sender` is not a privileged role.\\n     * @dev Reverts if the fee percentage is larger than 100% (equal to 1e4 when represented as a zoc).\\n     * @dev Reverts if the token transfer fails.\\n     */\\n    function payoutWithAdminOverrides(address _to, uint256 _amount, uint32 _feeOverride)\\n        external\\n        virtual\\n        requiresAuth\\n    {\\n        _payoutWithFeeMultiplier(_to, _amount, _feeOverride);\\n    }\\n\\n    /**\\n     * @notice Pays out an amount of base tokens from the entity to an address. Transfers the fee calculated by fee multiplier to the treasury.\\n     * @param _to The address to receive the tokens.\\n     * @param _amount Contains the amount being paid out (denominated in the base token's units).\\n     * @param _feeMultiplier Value indicating the percentage of the Endaoment fee to go to the Endaoment treasury.\\n     * @dev Reverts if the token transfer fails.\\n     * @dev Reverts if the fee percentage is larger than 100% (equal to 1e4 when represented as a zoc).\\n     */\\n    function _payoutWithFeeMultiplier(address _to, uint256 _amount, uint32 _feeMultiplier) internal virtual {\\n        if (balance < _amount) revert InsufficientFunds();\\n\\n        (uint256 _netAmount, uint256 _fee) = _calculateFee(_amount, _feeMultiplier);\\n        baseToken.safeTransfer(registry.treasury(), _fee);\\n        baseToken.safeTransfer(address(_to), _netAmount);\\n\\n        unchecked {\\n            // unchecked because we've already validated that amount is less than or equal to the balance\\n            balance -= _amount;\\n        }\\n        emit EntityValuePaidOut(address(this), _to, _amount, _fee);\\n    }\\n\\n    /// @dev Internal helper method to calculate the fee on a base token amount for a given fee multiplier.\\n    function _calculateFee(uint256 _amount, uint256 _feeMultiplier)\\n        internal\\n        pure\\n        virtual\\n        returns (uint256 _netAmount, uint256 _fee)\\n    {\\n        if (_feeMultiplier > Math.ZOC) revert InvalidAction();\\n        unchecked {\\n            // unchecked as no possibility of overflow with baseToken precision\\n            _fee = _amount.zocmul(_feeMultiplier);\\n            // unchecked as the _feeMultiplier check with revert above protects against overflow\\n            _netAmount = _amount - _fee;\\n        }\\n    }\\n\\n    receive() external payable virtual {\\n        emit EntityEthReceived(msg.sender, msg.value);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/Portfolio.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: BSD 3-Clause\\npragma solidity >=0.8.0;\\n\\nimport {ReentrancyGuard} from \\\"solmate/utils/ReentrancyGuard.sol\\\";\\nimport {ERC20} from \\\"solmate/tokens/ERC20.sol\\\";\\nimport {SafeTransferLib} from \\\"solmate/utils/SafeTransferLib.sol\\\";\\nimport {Registry} from \\\"./Registry.sol\\\";\\nimport {Entity} from \\\"./Entity.sol\\\";\\nimport {EndaomentAuth} from \\\"./lib/auth/EndaomentAuth.sol\\\";\\nimport {Math} from \\\"./lib/Math.sol\\\";\\n\\nabstract contract Portfolio is ERC20, EndaomentAuth, ReentrancyGuard {\\n    using Math for uint256;\\n    using SafeTransferLib for ERC20;\\n\\n    Registry public immutable registry;\\n    bool public immutable async;\\n    uint256 public cap;\\n    address public feeTreasury;\\n    uint256 public depositFee;\\n    uint256 public redemptionFee;\\n    address public immutable asset;\\n    address public immutable receiptAsset;\\n    ERC20 public immutable baseToken;\\n    bool public didShutdown;\\n    uint256 public timestampAumFeesTaken;\\n    uint256 public aumRate;\\n    uint256 internal constant MAX_AUM_RATE = 3168808782;\\n\\n    error InvalidSwapper();\\n    error InvalidRate();\\n    error TransferDisallowed();\\n    error DepositAfterShutdown();\\n    error DidShutdown();\\n    error NotEntity();\\n    error BadCheckCapImplementation();\\n    error ExceedsCap();\\n    error PercentageOver100();\\n    error RoundsToZero();\\n    error Slippage();\\n    error CallFailed(bytes response);\\n\\n    /// @notice `sender` has exchanged `assets` (after fees) for `shares`, and transferred those `shares` to `receiver`.\\n    /// The sender paid a total of `depositAmount` and was charged `fee` for the transaction.\\n    event Deposit(\\n        address indexed sender,\\n        address indexed receiver,\\n        uint256 assets,\\n        uint256 shares,\\n        uint256 depositAmount,\\n        uint256 fee\\n    );\\n\\n    /// @notice `sender` has exchanged `shares` for `assets`, and transferred those `assets` to `receiver`.\\n    /// The sender received a net of `redeemedAmount` after the conversion of `assets` into base tokens\\n    /// and was charged `fee` for the transaction.\\n    event Redeem(\\n        address indexed sender,\\n        address indexed receiver,\\n        uint256 assets,\\n        uint256 shares,\\n        uint256 redeemedAmount,\\n        uint256 fee\\n    );\\n\\n    /// @notice Event emitted when `cap` is set.\\n    event CapSet(uint256 cap);\\n\\n    /// @notice Event emitted when `depositFee` is set.\\n    event DepositFeeSet(uint256 fee);\\n\\n    /// @notice Event emitted when `redemptionFee` is set.\\n    event RedemptionFeeSet(uint256 fee);\\n\\n    /// @notice Event emitted when `feeTreasury` is set.\\n    event FeeTreasurySet(address feeTreasury);\\n\\n    /// @notice Event emitted when management takes fees.\\n    event FeesTaken(uint256 amount);\\n\\n    /// @notice Event emitted when AUM fees are taken.\\n    event AumFeesTaken(uint256 feeAmount, uint256 timeDelta);\\n\\n    /// @notice Event emitted when `aumRate` is set.\\n    event AumRateSet(uint256 rate);\\n\\n    /// @notice Event emitted when admin forcefully swaps portfolio asset balance for baseToken.\\n    event Shutdown(uint256 assetAmount, uint256 baseTokenOut);\\n\\n    /**\\n     * @param _registry Endaoment registry.\\n     * @param _receiptAsset Address of token that the portfolio receives from a deposit.\\n     * @param _name Name of the ERC20 Portfolio share tokens.\\n     * @param _async Whether the portfolio is async for deposits and redeems. Typically used for T+N portfolios\\n     * @param _symbol Symbol of the ERC20 Portfolio share tokens.\\n     * @param _cap Amount in baseToken that value of totalAssets should not exceed.\\n     * @param _depositFee Percentage fee as ZOC that will go to treasury on asset deposit.\\n     * @param _redemptionFee Percentage fee as ZOC that will go to treasury on share redemption.\\n     * @param _aumRate Percentage fee per second (as WAD) that should accrue to treasury as AUM fee. (1e16 = 1%).\\n     */\\n    constructor(\\n        Registry _registry,\\n        address _receiptAsset,\\n        string memory _name,\\n        string memory _symbol,\\n        bool _async,\\n        uint256 _cap,\\n        address _feeTreasury,\\n        uint256 _depositFee,\\n        uint256 _redemptionFee,\\n        uint256 _aumRate\\n    ) ERC20(_name, _symbol, ERC20(_getAsset(_receiptAsset)).decimals()) {\\n        __initEndaomentAuth(_registry, \\\"portfolio\\\");\\n        registry = _registry;\\n\\n        async = _async;\\n\\n        feeTreasury = _feeTreasury;\\n        emit FeeTreasurySet(_feeTreasury);\\n\\n        if (_redemptionFee > Math.ZOC) revert PercentageOver100();\\n        redemptionFee = _redemptionFee;\\n        emit RedemptionFeeSet(_redemptionFee);\\n\\n        if (_depositFee > Math.ZOC) revert PercentageOver100();\\n        depositFee = _depositFee;\\n        emit DepositFeeSet(_depositFee);\\n\\n        cap = _cap;\\n        emit CapSet(_cap);\\n\\n        receiptAsset = _receiptAsset;\\n        asset = _getAsset(_receiptAsset);\\n        baseToken = registry.baseToken();\\n\\n        if (_aumRate > MAX_AUM_RATE) revert InvalidRate();\\n        aumRate = _aumRate;\\n        emit AumRateSet(_aumRate);\\n\\n        timestampAumFeesTaken = block.timestamp;\\n    }\\n\\n    /**\\n     * @notice Returns the underlying asset for the `receiptAsset`.\\n     * @param _receiptAsset Address of token that the portfolio receives from a deposit.\\n     * @return Address of the underlying asset.\\n     */\\n    function _getAsset(address _receiptAsset) internal view virtual returns (address);\\n\\n    /**\\n     * @notice Function used to determine whether an Entity is active on the registry.\\n     * @param _entity The Entity.\\n     */\\n    function _isEntity(Entity _entity) internal view returns (bool) {\\n        return registry.isActiveEntity(_entity);\\n    }\\n\\n    /**\\n     * @notice Set the Portfolio cap.\\n     * @param _amount Amount, denominated in baseToken.\\n     */\\n    function setCap(uint256 _amount) external requiresAuth {\\n        cap = _amount;\\n        emit CapSet(_amount);\\n    }\\n\\n    /**\\n     * @notice Set deposit fee.\\n     * @param _pct Percentage as ZOC (e.g. 1000 = 10%).\\n     */\\n    function setDepositFee(uint256 _pct) external requiresAuth {\\n        if (_pct > Math.ZOC) revert PercentageOver100();\\n        depositFee = _pct;\\n        emit DepositFeeSet(_pct);\\n    }\\n\\n    /**\\n     * @notice Set redemption fee.\\n     * @param _pct Percentage as ZOC (e.g. 1000 = 10%).\\n     */\\n    function setRedemptionFee(uint256 _pct) external requiresAuth {\\n        if (_pct > Math.ZOC) revert PercentageOver100();\\n        redemptionFee = _pct;\\n        emit RedemptionFeeSet(_pct);\\n    }\\n\\n    /**\\n     * @notice Set fee treasury.\\n     * @param _feeTreasury Address of the treasury that should receive fees.\\n     *\\n     */\\n    function setFeeTreasury(address _feeTreasury) external requiresAuth {\\n        feeTreasury = _feeTreasury;\\n        emit FeeTreasurySet(_feeTreasury);\\n    }\\n\\n    /**\\n     * @notice Set AUM rate.\\n     * @param _pct Percentage *per second* as WAD (e.g. .01e18 / 365.25 days = 1% per year).\\n     */\\n    function setAumRate(uint256 _pct) external requiresAuth {\\n        // check to make sure _pct isn't above 10% over a year (.1e18 / 365.25 days = 3168808782 per second)\\n        if (_pct > MAX_AUM_RATE) revert InvalidRate();\\n        takeAumFees();\\n        aumRate = _pct;\\n        emit AumRateSet(_pct);\\n    }\\n\\n    /**\\n     * @notice Total amount of the underlying asset that is managed by the Portfolio.\\n     * @return Total amount of the underlying asset.\\n     */\\n    function totalAssets() public view returns (uint256) {\\n        return convertReceiptAssetsToAssets(totalReceiptAssets());\\n    }\\n\\n    /**\\n     * @notice Total amount of the receipt asset that is managed by the Portfolio.\\n     * @return Total amount of the receipt asset.\\n     */\\n    function totalReceiptAssets() public view returns (uint256) {\\n        return ERC20(receiptAsset).balanceOf(address(this));\\n    }\\n\\n    /**\\n     * @notice Calculates the equivalent amount of assets for the given amount of receipt assets.\\n     * @param _receiptAssets Amount of receipt assets to convert.\\n     * @return Amount of assets.\\n     */\\n    function convertReceiptAssetsToAssets(uint256 _receiptAssets) public view virtual returns (uint256);\\n\\n    /**\\n     * @notice Takes some amount of receipt assets from this portfolio as management fee.\\n     * @param _amountReceiptAssets Amount of receipt assets to take.\\n     */\\n    function takeFees(uint256 _amountReceiptAssets) external requiresAuth {\\n        ERC20(receiptAsset).safeTransfer(feeTreasury, _amountReceiptAssets);\\n        emit FeesTaken(_amountReceiptAssets);\\n    }\\n\\n    /**\\n     * @notice Takes accrued percentage of assets from this portfolio as AUM fee.\\n     */\\n    function takeAumFees() public {\\n        if (didShutdown) return _takeAumFeesShutdown();\\n        uint256 _totalReceiptAssets = totalReceiptAssets();\\n        uint256 _period = block.timestamp - timestampAumFeesTaken;\\n        uint256 _feeAmount = _calculateAumFee(_totalReceiptAssets, _period);\\n        if (_feeAmount > _totalReceiptAssets) _feeAmount = _totalReceiptAssets;\\n        if (_feeAmount > 0 || totalSupply == 0) {\\n            // in either case, we want to set `timestampAumFeesTaken`...\\n            timestampAumFeesTaken = block.timestamp;\\n            // but we only want to transfer/emit on non-zero amount\\n            if (_feeAmount > 0) {\\n                ERC20(receiptAsset).safeTransfer(feeTreasury, _feeAmount);\\n                emit AumFeesTaken(_feeAmount, _period);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Takes accrued percentage of post-shutdown baseToken from this portfolio as AUM fee.\\n     */\\n    function _takeAumFeesShutdown() internal {\\n        uint256 _totalAssets = baseToken.balanceOf(address(this));\\n        uint256 _period = block.timestamp - timestampAumFeesTaken;\\n        uint256 _feeAmount = _calculateAumFee(_totalAssets, _period);\\n        if (_feeAmount > _totalAssets) _feeAmount = _totalAssets;\\n        // in `takeAumFees`, the following conditional checks totalSupply as well, solving a first deposit corner case.\\n        // In this case, we don't need to check, because deposits aren't allowed after shutdown.\\n        if (_feeAmount > 0) {\\n            timestampAumFeesTaken = block.timestamp;\\n            baseToken.safeTransfer(feeTreasury, _feeAmount);\\n            emit AumFeesTaken(_feeAmount, _period);\\n        }\\n    }\\n\\n    /**\\n     * @notice Exchange `_amountBaseToken` for some amount of Portfolio shares.\\n     * @param _amountBaseToken The amount of the Entity's baseToken to deposit.\\n     * @param _data Data that the portfolio needs to make the deposit. In some cases, this will be swap parameters.\\n     * The first 32 bytes of this data should be the ABI-encoded `minSharesOut`.\\n     * @return shares The amount of shares that this deposit yields to the Entity.\\n     * @dev If the portfolio is `async`, shares will not be minted on deposit. Instead, each async\\n     * portfolio will have a unique implementation that will handle the minting of those shares\\n     * elsewhere e.g. T+N portfolios perform minting in consolidations.\\n     */\\n    function deposit(uint256 _amountBaseToken, bytes calldata _data) external nonReentrant returns (uint256) {\\n        // All portfolios should revert on deposit after shutdown\\n        if (didShutdown) revert DepositAfterShutdown();\\n\\n        // All portfolios should revert on a deposit from a non-entity (or inactive one)\\n        if (!_isEntity(Entity(payable(msg.sender)))) revert NotEntity();\\n\\n        // All portfolios should take AUM fees\\n        takeAumFees();\\n\\n        // All portfolios should make a deposit\\n        // All transferring of baseToken and share calculation should occur inside _deposit\\n        // TODO: move fee taking logic here instead of `_deposit` for all portfolios and update tests\\n        (uint256 _shares, uint256 _assets, uint256 _fee) = _deposit(_amountBaseToken, _data);\\n\\n        // Only sync portfolios require minting and share amount checking on deposit\\n        if (!async) {\\n            if (_shares < abi.decode(_data, (uint256))) revert Slippage();\\n            if (_shares == 0) revert RoundsToZero();\\n\\n            // mint shares\\n            _mint(msg.sender, _shares);\\n        }\\n\\n        // And check cap\\n        _checkCap();\\n\\n        // And emit an event\\n        emit Deposit(msg.sender, msg.sender, _assets, _shares, _amountBaseToken, _fee);\\n\\n        return _shares;\\n    }\\n\\n    /**\\n     * @notice Check to make sure the cap has not been exceeded.\\n     * @dev Most portfolios have the same asset and baseToken, so the _checkCap implementation here is written to accomodate\\n     * that situation. For portfolios where that is not the case, this method needs to be overwritten to ensure the cap\\n     * (denominated in baseToken) is properly compared to the number of assets.\\n     */\\n    function _checkCap() internal virtual {\\n        if (asset != address(baseToken)) revert BadCheckCapImplementation();\\n        if (totalAssets() > cap) revert ExceedsCap();\\n    }\\n\\n    /**\\n     * @notice Exchange `_amountIn` for some amount of Portfolio shares.\\n     * @dev Should include the transferring of baseToken and conversion to shares.\\n     * @param _amountIn The amount of the Entity's baseToken to deposit.\\n     * @param _data Data that the portfolio needs to make the deposit. In some cases, this will be swap parameters.\\n     * @return shares The amount of shares that this deposit yields to the Entity.\\n     * @return assets The amount of assets that this deposit yields to the portfolio.\\n     * @return fee The baseToken fee that this deposit yields to the treasury.\\n     */\\n    function _deposit(uint256 _amountIn, bytes calldata _data)\\n        internal\\n        virtual\\n        returns (uint256 shares, uint256 assets, uint256 fee);\\n\\n    /**\\n     * @notice Exchange `_amountShares` for some amount of baseToken.\\n     * @param _amountShares The amount of the Entity's portfolio shares to exchange.\\n     * @param _data Data that the portfolio needs to make the redemption. In some cases, this will be swap parameters.\\n     * @return baseTokenOut The amount of baseToken that this redemption yields to the Entity.\\n     */\\n    function redeem(uint256 _amountShares, bytes calldata _data)\\n        external\\n        nonReentrant\\n        returns (uint256 /* baseTokenOut */ )\\n    {\\n        // All redeems should take AUM fees\\n        takeAumFees();\\n\\n        // All portfolios should handle redemption after shutdown\\n        if (didShutdown) return _redeemShutdown(_amountShares);\\n\\n        // All portfolios should handle the actual redeem of shares\\n        (uint256 _assetsOut, uint256 _baseTokenOut) = _redeem(_amountShares, _data);\\n\\n        // All portfolios should burn the redeemed shares from the caller\\n        _burn(msg.sender, _amountShares);\\n\\n        // Portfolios must signal amount of assets being redeemed, which must be non-zero\\n        if (_assetsOut == 0) revert RoundsToZero();\\n\\n        // Any portfolio that outputs base token should transfer to caller and charge fee for treasury\\n        uint256 _netAmount;\\n        uint256 _fee;\\n        if (_baseTokenOut > 0) {\\n            (_netAmount, _fee) = _calculateFee(_baseTokenOut, redemptionFee);\\n            baseToken.safeTransfer(feeTreasury, _fee);\\n            baseToken.safeTransfer(msg.sender, _netAmount);\\n        }\\n\\n        // And emit an event\\n        emit Redeem(msg.sender, msg.sender, _assetsOut, _amountShares, _netAmount, _fee);\\n\\n        return _netAmount;\\n    }\\n\\n    /**\\n     * @notice Exchange `_amountShares` for some amount of Portfolio assets.\\n     * @param _amountShares The amount of portfolio shares to exchange.\\n     * @param _data Data that the portfolio needs to redeem the assets. In some cases, this will be swap parameters.\\n     * @return assetsOut The amount of assets that this redemption yielded (and then converted to baseToken).\\n     * @return baseTokenOut Amount in baseToken to which these assets were converted.\\n     */\\n    function _redeem(uint256 _amountShares, bytes calldata _data)\\n        internal\\n        virtual\\n        returns (uint256 assetsOut, uint256 baseTokenOut);\\n\\n    /**\\n     * @notice Handles redemption after shutdown, exchanging shares for baseToken.\\n     * @param _amountShares Shares being redeemed.\\n     * @return Amount of baseToken received.\\n     */\\n    function _redeemShutdown(uint256 _amountShares) internal returns (uint256) {\\n        uint256 _baseTokenOut = convertToAssetsShutdown(_amountShares);\\n        _burn(msg.sender, _amountShares);\\n        (uint256 _netAmount, uint256 _fee) = _calculateFee(_baseTokenOut, redemptionFee);\\n        baseToken.safeTransfer(feeTreasury, _fee);\\n        baseToken.safeTransfer(msg.sender, _netAmount);\\n        emit Redeem(msg.sender, msg.sender, _baseTokenOut, _amountShares, _netAmount, _fee);\\n        return _netAmount;\\n    }\\n\\n    /**\\n     * @notice Calculates the amount of shares that the Portfolio should exchange for the amount of assets provided.\\n     * @param _assets Amount of assets.\\n     * @return Amount of shares.\\n     */\\n    function convertToShares(uint256 _assets) public view returns (uint256) {\\n        uint256 _supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\\n        return _supply == 0 ? _assets : _assets.mulDivDown(_supply, totalAssets());\\n    }\\n\\n    /**\\n     * @notice Calculates the amount of assets that the Portfolio should exchange for the amount of shares provided.\\n     * @param _shares Amount of shares.\\n     * @return Amount of assets.\\n     */\\n    function convertToAssets(uint256 _shares) public view returns (uint256) {\\n        uint256 _supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\\n        return _supply == 0 ? _shares : _shares.mulDivDown(totalAssets(), _supply);\\n    }\\n\\n    /**\\n     * @notice Calculates the amount of baseToken that the Portfolio should exchange for the amount of shares provided.\\n     * Used only if the Portfolio has shut down.\\n     * @dev Rounding down here favors the portfolio, so the user gets slightly less and the portfolio gets slightly more,\\n     * that way it prevents a situation where the user is owed x but the vault only has x - epsilon, where epsilon is\\n     * some tiny number due to rounding error.\\n     * @param _shares Amount of shares.\\n     * @return Amount of baseToken.\\n     */\\n    function convertToAssetsShutdown(uint256 _shares) public view returns (uint256) {\\n        uint256 _supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\\n        return _supply == 0 ? _shares : _shares.mulDivDown(baseToken.balanceOf(address(this)), _supply);\\n    }\\n\\n    /**\\n     * @notice Exit out all assets of portfolio for baseToken. Must persist a mechanism for entities to redeem their shares for baseToken.\\n     * @param _data Data that the portfolio needs to exit from asset.  Consult the portfolio's `_exit` method to determine\\n     * the correct format for this data.\\n     * @return baseTokenOut The amount of baseToken that this exit yielded.\\n     */\\n    function shutdown(bytes calldata _data) external requiresAuth returns (uint256 baseTokenOut) {\\n        if (didShutdown) revert DidShutdown();\\n        didShutdown = true;\\n        uint256 _assetsOut = totalAssets();\\n        // In most cases, _actualAssetsOut will equal _assetsOut, but in SingleTokenPortfolio, it may be less.\\n        (uint256 _actualAssetsOut, uint256 _baseTokenOut) = _exit(_assetsOut, _data);\\n        emit Shutdown(_actualAssetsOut, _baseTokenOut);\\n        return _baseTokenOut;\\n    }\\n\\n    /**\\n     * @notice Convert some amount of asset into baseToken, either partially or fully exiting the portfolio asset.\\n     * @dev This method is used in `redeem` and `shutdown` calls.\\n     * @param _amount The amount of the Entity's portfolio asset to exchange.\\n     * @param _data Data that the portfolio needs to exit from asset. In some cases, this will be swap parameters. Consult the portfolio's\\n     * `_exit` method to determine the correct format for this data.\\n     * @return actualAssetsOut The amount of assets that were exited. In most cases, this will be equal to `_amount`, but may differ\\n     * by some errorMarginPct in SingleTokenPortfolio.\\n     * @return baseTokenOut The amount of baseToken that this exit yielded.\\n     */\\n    function _exit(uint256 _amount, bytes calldata _data)\\n        internal\\n        virtual\\n        returns (uint256 actualAssetsOut, uint256 baseTokenOut);\\n\\n    /// @notice `transfer` disabled on Portfolio tokens.\\n    function transfer(\\n        address, // to\\n        uint256 // amount\\n    ) public pure override returns (bool) {\\n        revert TransferDisallowed();\\n    }\\n\\n    /// @notice `transferFrom` disabled on Portfolio tokens.\\n    function transferFrom(\\n        address,\\n        /* from */\\n        address,\\n        /* to */\\n        uint256 /* amount */\\n    ) public pure override returns (bool) {\\n        revert TransferDisallowed();\\n    }\\n\\n    /// @notice `approve` disabled on Portfolio tokens.\\n    function approve(\\n        address,\\n        /* to */\\n        uint256 /* amount */\\n    ) public pure override returns (bool) {\\n        revert TransferDisallowed();\\n    }\\n\\n    /// @notice `permit` disabled on Portfolio tokens.\\n    function permit(\\n        address, /* owner */\\n        address, /* spender */\\n        uint256, /* value */\\n        uint256, /* deadline */\\n        uint8, /* v */\\n        bytes32, /* r */\\n        bytes32 /* s */\\n    ) public pure override {\\n        revert TransferDisallowed();\\n    }\\n\\n    /**\\n     * @notice Permissioned method that allows Endaoment admin to make arbitrary calls acting as this Portfolio.\\n     * @param _target The address to which the call will be made.\\n     * @param _value The ETH value that should be forwarded with the call.\\n     * @param _data The calldata that will be sent with the call.\\n     * @return _return The data returned by the call.\\n     */\\n    function callAsPortfolio(address _target, uint256 _value, bytes memory _data)\\n        external\\n        payable\\n        requiresAuth\\n        returns (bytes memory)\\n    {\\n        (bool _success, bytes memory _response) = payable(_target).call{value: _value}(_data);\\n        if (!_success) revert CallFailed(_response);\\n        return _response;\\n    }\\n\\n    /**\\n     * @notice Internal helper method to calculate the fee on a base token amount for a given fee multiplier.\\n     * @param _amount Amount of baseToken.\\n     * @param _feeMultiplier Multiplier (as zoc) to apply to the amount.\\n     * @return _netAmount The amount of baseToken after the fee is applied.\\n     * @return _fee The amount of baseToken to be taken as a fee.\\n     */\\n    function _calculateFee(uint256 _amount, uint256 _feeMultiplier)\\n        internal\\n        pure\\n        returns (uint256 _netAmount, uint256 _fee)\\n    {\\n        if (_feeMultiplier > Math.ZOC) revert PercentageOver100();\\n        unchecked {\\n            // unchecked as no possibility of overflow with baseToken precision\\n            _fee = _amount.zocmul(_feeMultiplier);\\n            // unchecked as the _feeMultiplier check with revert above protects against overflow\\n            _netAmount = _amount - _fee;\\n        }\\n    }\\n\\n    /**\\n     * @notice Helper method to calculate AUM fee based on assets and time elapsed.\\n     * @param _totalAssets Assets over which to calculate AUM fee.\\n     * @param _period Seconds elapsed since AUM fee was last taken.\\n     * @dev We chose to calculate using simple interest rather than compound interest because the error was small and\\n     * simple interest is easier to calculate, reason about, and test.\\n     * @return _aumFee The amount of baseToken to be taken as AUM fee.\\n     */\\n    function _calculateAumFee(uint256 _totalAssets, uint256 _period) internal view returns (uint256) {\\n        if (_totalAssets == 0 || aumRate == 0 || _period == 0) return 0;\\n        // _period * aumRate is safe; max expected aum rate * 10 years of seconds is just over 1 WAD\\n        return _totalAssets.mulWadDown(_period * aumRate);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/tokens/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\\nabstract contract ERC20 {\\n    /*///////////////////////////////////////////////////////////////\\n                                  EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /*///////////////////////////////////////////////////////////////\\n                             METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    uint8 public immutable decimals;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                             EIP-2612 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    bytes32 public constant PERMIT_TYPEHASH =\\n        keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\");\\n\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\n\\n    mapping(address => uint256) public nonces;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n\\n        INITIAL_CHAIN_ID = block.chainid;\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        balanceOf[msg.sender] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\n\\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\\n\\n        balanceOf[from] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              EIP-2612 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        require(deadline >= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\n\\n        // Unchecked because the only math done is incrementing\\n        // the owner's nonce which cannot realistically overflow.\\n        unchecked {\\n            bytes32 digest = keccak256(\\n                abi.encodePacked(\\n                    \\\"\\\\x19\\\\x01\\\",\\n                    DOMAIN_SEPARATOR(),\\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\\n                )\\n            );\\n\\n            address recoveredAddress = ecrecover(digest, v, r, s);\\n\\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"INVALID_SIGNER\\\");\\n\\n            allowance[recoveredAddress][spender] = value;\\n        }\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\n    }\\n\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                    keccak256(bytes(name)),\\n                    keccak256(\\\"1\\\"),\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                       INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        totalSupply += amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        balanceOf[from] -= amount;\\n\\n        // Cannot underflow because a user's balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply -= amount;\\n        }\\n\\n        emit Transfer(from, address(0), amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/lib/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD 3-Clause\\npragma solidity 0.8.13;\\n\\nlibrary Math {\\n    uint256 internal constant ZOC = 1e4;\\n\\n    /**\\n     * @dev Multiply 2 numbers where at least one is a zoc, return product in original units of the other number.\\n     */\\n    function zocmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        z = x * y;\\n        unchecked {\\n            z /= ZOC;\\n        }\\n    }\\n\\n    // Below is WAD math from solmate's FixedPointMathLib.\\n    // https://github.com/Rari-Capital/solmate/blob/c8278b3cb948cffda3f1de5a401858035f262060/src/utils/FixedPointMathLib.sol\\n\\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\\n\\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\\n    }\\n\\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\\n    }\\n\\n    // For tokens with 6 decimals like USDC, these scale by 1e6 (one million).\\n    function mulMilDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, y, 1e6); // Equivalent to (x * y) / 1e6 rounded down.\\n    }\\n\\n    function divMilDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, 1e6, y); // Equivalent to (x * 1e6) / y rounded down.\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                    LOW LEVEL FIXED POINT OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function mulDivDown(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 z) {\\n        assembly {\\n            // Store x * y in z for now.\\n            z := mul(x, y)\\n\\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) { revert(0, 0) }\\n\\n            // Divide z by the denominator.\\n            z := div(z, denominator)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/utils/SafeTransferLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"../tokens/ERC20.sol\\\";\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n/// @author Modified from Gnosis (https://github.com/gnosis/gp-v2-contracts/blob/main/src/contracts/libraries/GPv2SafeERC20.sol)\\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\\nlibrary SafeTransferLib {\\n    /*///////////////////////////////////////////////////////////////\\n                            ETH OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        bool callStatus;\\n\\n        assembly {\\n            // Transfer the ETH and store if it succeeded or not.\\n            callStatus := call(gas(), to, amount, 0, 0, 0, 0)\\n        }\\n\\n        require(callStatus, \\\"ETH_TRANSFER_FAILED\\\");\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                           ERC20 OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferFrom(\\n        ERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool callStatus;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata to memory piece by piece:\\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000) // Begin with the function selector.\\n            mstore(add(freeMemoryPointer, 4), and(from, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \\\"from\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 68), amount) // Finally append the \\\"amount\\\" argument. No mask as it's a full 32 byte value.\\n\\n            // Call the token and store if it succeeded or not.\\n            // We use 100 because the calldata length is 4 + 32 * 3.\\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 100, 0, 0)\\n        }\\n\\n        require(didLastOptionalReturnCallSucceed(callStatus), \\\"TRANSFER_FROM_FAILED\\\");\\n    }\\n\\n    function safeTransfer(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool callStatus;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata to memory piece by piece:\\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000) // Begin with the function selector.\\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Finally append the \\\"amount\\\" argument. No mask as it's a full 32 byte value.\\n\\n            // Call the token and store if it succeeded or not.\\n            // We use 68 because the calldata length is 4 + 32 * 2.\\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 68, 0, 0)\\n        }\\n\\n        require(didLastOptionalReturnCallSucceed(callStatus), \\\"TRANSFER_FAILED\\\");\\n    }\\n\\n    function safeApprove(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool callStatus;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata to memory piece by piece:\\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000) // Begin with the function selector.\\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Finally append the \\\"amount\\\" argument. No mask as it's a full 32 byte value.\\n\\n            // Call the token and store if it succeeded or not.\\n            // We use 68 because the calldata length is 4 + 32 * 2.\\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 68, 0, 0)\\n        }\\n\\n        require(didLastOptionalReturnCallSucceed(callStatus), \\\"APPROVE_FAILED\\\");\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                         INTERNAL HELPER LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function didLastOptionalReturnCallSucceed(bool callStatus) private pure returns (bool success) {\\n        assembly {\\n            // Get how many bytes the call returned.\\n            let returnDataSize := returndatasize()\\n\\n            // If the call reverted:\\n            if iszero(callStatus) {\\n                // Copy the revert message into memory.\\n                returndatacopy(0, 0, returnDataSize)\\n\\n                // Revert with the same message.\\n                revert(0, returnDataSize)\\n            }\\n\\n            switch returnDataSize\\n            case 32 {\\n                // Copy the return data into memory.\\n                returndatacopy(0, 0, returnDataSize)\\n\\n                // Set success to whether it returned true.\\n                success := iszero(iszero(mload(0)))\\n            }\\n            case 0 {\\n                // There was no return data.\\n                success := 1\\n            }\\n            default {\\n                // It returned some malformed input.\\n                success := 0\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/lib/auth/EndaomentAuth.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport {RolesAuthority} from \\\"./authorities/RolesAuthority.sol\\\";\\n\\n/**\\n * @notice An abstract Auth that contracts in the Endaoment ecosystem can inherit from. It is based on\\n * the `Auth.sol` contract from Solmate, but does not inherit from it. Most of the functionality\\n * is either slightly different, or not needed. In particular:\\n * - EndaomentAuth uses an initializer such that it can be deployed with minimal proxies.\\n * - EndaomentAuth contracts reference a RolesAuthority, not just an Authority, when looking up permissions.\\n *   In the Endaoment ecosystem, this is assumed to be the Registry.\\n * - EndaomentAuth contracts do not have an owner, but instead grant ubiquitous permission to its RoleAuthority's\\n *   owner. In the Endaoment ecosystem, this is assumed to be the board of directors multi-sig.\\n * - EndaomentAuth contracts can optionally declare themselves a \\\"special target\\\" at deploy time. Instead of passing\\n *   their address to the authority when looking up their permissions, they'll instead pass the special target bytes.\\n *   See documentation on `specialTarget` for more information.\\n *\\n */\\nabstract contract EndaomentAuth {\\n    /// @notice Thrown when an account without proper permissions calls a privileged method.\\n    error Unauthorized();\\n\\n    /// @notice Thrown if there is an attempt to deploy with address 0 as the authority.\\n    error InvalidAuthority();\\n\\n    /// @notice Thrown if there is a second call to initialize.\\n    error AlreadyInitialized();\\n\\n    /// @notice The contract used to source permissions for accounts targeting this contract.\\n    RolesAuthority public authority;\\n\\n    /**\\n     * @notice If set to a non-zero value, this contract will pass these byes as the target contract\\n     * to the RolesAuthority's `canCall` method, rather than its own contract. This allows a single\\n     * RolesAuthority permission to manage permissions simultaneously for a group of contracts that\\n     * identify themselves as a certain type. For example: set a permission for all \\\"entity\\\" contracts.\\n     */\\n    bytes20 public specialTarget;\\n\\n    /**\\n     * @notice One time method to be called at deployment to configure the contract. Required so EndaomentAuth\\n     * contracts can be deployed as minimal proxies (clones).\\n     * @param _authority Contract that will be used to source permissions for accounts targeting this contract.\\n     * @param _specialTarget The bytes that this contract will pass as the \\\"target\\\" when looking up permissions\\n     * from the authority. If set to empty bytes, this contract will pass its own address instead.\\n     */\\n    function __initEndaomentAuth(RolesAuthority _authority, bytes20 _specialTarget) internal virtual {\\n        if (address(_authority) == address(0)) revert InvalidAuthority();\\n        if (address(authority) != address(0)) revert AlreadyInitialized();\\n        authority = _authority;\\n        specialTarget = _specialTarget;\\n    }\\n\\n    /**\\n     * @notice Modifier for methods that require authorization to execute.\\n     */\\n    modifier requiresAuth() virtual {\\n        if (!isAuthorized(msg.sender, msg.sig)) revert Unauthorized();\\n        _;\\n    }\\n\\n    /**\\n     * @notice Internal method that asks the authority whether the caller has permission to execute a method.\\n     * @param user The account attempting to call a permissioned method on this contract\\n     * @param functionSig The signature hash of the permissioned method being invoked.\\n     */\\n    function isAuthorized(address user, bytes4 functionSig) internal view virtual returns (bool) {\\n        RolesAuthority auth = authority; // Memoizing authority saves us a warm SLOAD, around 100 gas.\\n        address _target = specialTarget == \\\"\\\" ? address(this) : address(specialTarget);\\n\\n        // The caller has permission on authority, or the caller is the RolesAuthority owner\\n        return auth.canCall(user, _target, functionSig) || user == auth.owner();\\n    }\\n}\\n\"\r\n    },\r\n    \"src/lib/auth/Auth.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n// This contract is modified from Solmate only to make requiresAuth virtual on line 26\\n\\n/// @notice Provides a flexible and updatable auth pattern which is completely separate from application logic.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/auth/Auth.sol)\\n/// @author Modified from Dappsys (https://github.com/dapphub/ds-auth/blob/master/src/auth.sol)\\nabstract contract Auth {\\n    event OwnerUpdated(address indexed user, address indexed newOwner);\\n\\n    event AuthorityUpdated(address indexed user, Authority indexed newAuthority);\\n\\n    address public owner;\\n\\n    Authority public authority;\\n\\n    constructor(address _owner, Authority _authority) {\\n        owner = _owner;\\n        authority = _authority;\\n\\n        emit OwnerUpdated(msg.sender, _owner);\\n        emit AuthorityUpdated(msg.sender, _authority);\\n    }\\n\\n    modifier requiresAuth() virtual {\\n        require(isAuthorized(msg.sender, msg.sig), \\\"UNAUTHORIZED\\\");\\n\\n        _;\\n    }\\n\\n    function isAuthorized(address user, bytes4 functionSig) internal view virtual returns (bool) {\\n        Authority auth = authority; // Memoizing authority saves us a warm SLOAD, around 100 gas.\\n\\n        // Checking if the caller is the owner only after calling the authority saves gas in most cases, but be\\n        // aware that this makes protected functions uncallable even to the owner if the authority is out of order.\\n        return (address(auth) != address(0) && auth.canCall(user, address(this), functionSig)) || user == owner;\\n    }\\n\\n    function setAuthority(Authority newAuthority) public virtual {\\n        // We check if the caller is the owner first because we want to ensure they can\\n        // always swap out the authority even if it's reverting or using up a lot of gas.\\n        require(msg.sender == owner || authority.canCall(msg.sender, address(this), msg.sig));\\n\\n        authority = newAuthority;\\n\\n        emit AuthorityUpdated(msg.sender, newAuthority);\\n    }\\n\\n    function setOwner(address newOwner) public virtual requiresAuth {\\n        owner = newOwner;\\n\\n        emit OwnerUpdated(msg.sender, newOwner);\\n    }\\n}\\n\\n/// @notice A generic interface for a contract which provides authorization data to an Auth instance.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/auth/Auth.sol)\\n/// @author Modified from Dappsys (https://github.com/dapphub/ds-auth/blob/master/src/auth.sol)\\ninterface Authority {\\n    function canCall(address user, address target, bytes4 functionSig) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"src/RegistryAuth.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: BSD 3-Clause\\npragma solidity 0.8.13;\\n\\nimport {Auth, Authority} from \\\"./lib/auth/Auth.sol\\\";\\nimport {RolesAuthority} from \\\"./lib/auth/authorities/RolesAuthority.sol\\\";\\n\\n// --- Errors ---\\nerror OwnershipInvalid();\\n\\n/**\\n * @notice RegistryAuth - contract to control ownership of the Registry.\\n */\\ncontract RegistryAuth is RolesAuthority {\\n    /// @notice Emitted when the first step of an ownership transfer (proposal) is done.\\n    event OwnershipTransferProposed(address indexed user, address indexed newOwner);\\n\\n    /// @notice Emitted when the second step of an ownership transfer (claim) is done.\\n    event OwnershipChanged(address indexed owner, address indexed newOwner);\\n\\n    // --- Storage ---\\n    /// @notice Pending owner for 2 step ownership transfer\\n    address public pendingOwner;\\n\\n    // --- Constructor ---\\n    constructor(address _owner, Authority _authority) RolesAuthority(_owner, _authority) {}\\n\\n    /**\\n     * @notice Starts the 2 step process of transferring registry authorization to a new owner.\\n     * @param _newOwner Proposed new owner of registry authorization.\\n     */\\n    function transferOwnership(address _newOwner) external requiresAuth {\\n        pendingOwner = _newOwner;\\n\\n        emit OwnershipTransferProposed(msg.sender, _newOwner);\\n    }\\n\\n    /**\\n     * @notice Completes the 2 step process of transferring registry authorization to a new owner.\\n     * This function must be called by the proposed new owner.\\n     */\\n    function claimOwnership() external {\\n        if (msg.sender != pendingOwner) revert OwnershipInvalid();\\n        emit OwnershipChanged(owner, pendingOwner);\\n        owner = pendingOwner;\\n        pendingOwner = address(0);\\n    }\\n\\n    /**\\n     * @notice Old approach of setting a new owner in a single step.\\n     * @dev This function throws an error to force use of the new 2-step approach.\\n     */\\n    function setOwner(address /*newOwner*/ ) public view override requiresAuth {\\n        revert OwnershipInvalid();\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ISwapWrapper.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: BSD 3-Clause\\npragma solidity >=0.8.0;\\n\\nerror ETHAmountInMismatch();\\n\\n/**\\n * @notice ISwapWrapper is the interface that all swap wrappers should implement.\\n * This will be used to support swap protocols like Uniswap V2 and V3, Sushiswap, 1inch, etc.\\n */\\ninterface ISwapWrapper {\\n    /// @notice Event emitted after a successful swap.\\n    event WrapperSwapExecuted(\\n        address indexed tokenIn,\\n        address indexed tokenOut,\\n        address sender,\\n        address indexed recipient,\\n        uint256 amountIn,\\n        uint256 amountOut\\n    );\\n\\n    /// @notice Name of swap wrapper for UX readability.\\n    function name() external returns (string memory);\\n\\n    /**\\n     * @notice Swap function. Generally we expect the implementer to call some exactAmountIn-like swap method, and so the documentation\\n     * is written with this in mind. However, the method signature is general enough to support exactAmountOut swaps as well.\\n     * @param _tokenIn Token to be swapped (or 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE for ETH).\\n     * @param _tokenOut Token to receive (or 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE for ETH).\\n     * @param _recipient Receiver of `_tokenOut`.\\n     * @param _amount Amount of `_tokenIn` that should be swapped.\\n     * @param _data Additional data that the swap wrapper may require to execute the swap.\\n     * @return Amount of _tokenOut received.\\n     */\\n    function swap(address _tokenIn, address _tokenOut, address _recipient, uint256 _amount, bytes calldata _data)\\n        external\\n        payable\\n        returns (uint256);\\n}\\n\"\r\n    },\r\n    \"src/lib/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Gas optimized reentrancy protection for smart contracts.\\n/// @author Modified Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/ReentrancyGuard.sol)\\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol)\\nabstract contract ReentrancyGuard {\\n    uint256 private reentrancyStatus;\\n\\n    error Reentrancy();\\n\\n    function __initReentrancyGuard() internal {\\n        if (reentrancyStatus != 0) revert Reentrancy();\\n        reentrancyStatus = 1;\\n    }\\n\\n    modifier nonReentrant() {\\n        if (reentrancyStatus != 1) revert Reentrancy();\\n\\n        reentrancyStatus = 2;\\n\\n        _;\\n\\n        reentrancyStatus = 1;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Gas optimized reentrancy protection for smart contracts.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/ReentrancyGuard.sol)\\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol)\\nabstract contract ReentrancyGuard {\\n    uint256 private reentrancyStatus = 1;\\n\\n    modifier nonReentrant() {\\n        require(reentrancyStatus == 1, \\\"REENTRANCY\\\");\\n\\n        reentrancyStatus = 2;\\n\\n        _;\\n\\n        reentrancyStatus = 1;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/lib/auth/authorities/RolesAuthority.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n// This contract is modified from Solmate only to import modified Auth.sol on line 5\\nimport {Auth, Authority} from \\\"../Auth.sol\\\";\\n\\n/// @notice Role based Authority that supports up to 256 roles.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/auth/authorities/RolesAuthority.sol)\\n/// @author Modified from Dappsys (https://github.com/dapphub/ds-roles/blob/master/src/roles.sol)\\ncontract RolesAuthority is Auth, Authority {\\n    /*///////////////////////////////////////////////////////////////\\n                                  EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event UserRoleUpdated(address indexed user, uint8 indexed role, bool enabled);\\n\\n    event PublicCapabilityUpdated(address indexed target, bytes4 indexed functionSig, bool enabled);\\n\\n    event RoleCapabilityUpdated(uint8 indexed role, address indexed target, bytes4 indexed functionSig, bool enabled);\\n\\n    /*///////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(address _owner, Authority _authority) Auth(_owner, _authority) {}\\n\\n    /*///////////////////////////////////////////////////////////////\\n                            ROLE/USER STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    mapping(address => bytes32) public getUserRoles;\\n\\n    mapping(address => mapping(bytes4 => bool)) public isCapabilityPublic;\\n\\n    mapping(address => mapping(bytes4 => bytes32)) public getRolesWithCapability;\\n\\n    function doesUserHaveRole(address user, uint8 role) public view virtual returns (bool) {\\n        return (uint256(getUserRoles[user]) >> role) & 1 != 0;\\n    }\\n\\n    function doesRoleHaveCapability(uint8 role, address target, bytes4 functionSig)\\n        public\\n        view\\n        virtual\\n        returns (bool)\\n    {\\n        return (uint256(getRolesWithCapability[target][functionSig]) >> role) & 1 != 0;\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                          AUTHORIZATION LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function canCall(address user, address target, bytes4 functionSig) public view virtual override returns (bool) {\\n        return isCapabilityPublic[target][functionSig]\\n            || bytes32(0) != getUserRoles[user] & getRolesWithCapability[target][functionSig];\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                  ROLE CAPABILITY CONFIGURATION LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function setPublicCapability(address target, bytes4 functionSig, bool enabled) public virtual requiresAuth {\\n        isCapabilityPublic[target][functionSig] = enabled;\\n\\n        emit PublicCapabilityUpdated(target, functionSig, enabled);\\n    }\\n\\n    function setRoleCapability(uint8 role, address target, bytes4 functionSig, bool enabled)\\n        public\\n        virtual\\n        requiresAuth\\n    {\\n        if (enabled) {\\n            getRolesWithCapability[target][functionSig] |= bytes32(1 << role);\\n        } else {\\n            getRolesWithCapability[target][functionSig] &= ~bytes32(1 << role);\\n        }\\n\\n        emit RoleCapabilityUpdated(role, target, functionSig, enabled);\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                      USER ROLE ASSIGNMENT LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function setUserRole(address user, uint8 role, bool enabled) public virtual requiresAuth {\\n        if (enabled) {\\n            getUserRoles[user] |= bytes32(1 << role);\\n        } else {\\n            getUserRoles[user] &= ~bytes32(1 << role);\\n        }\\n\\n        emit UserRoleUpdated(user, role, enabled);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"murky/=lib/murky/src/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"solmate/=lib/solmate/src/\",\r\n      \"weird-erc20/=lib/solmate/lib/weird-erc20/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 9999999\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"components\":[{\"internalType\":\"contract Registry\",\"name\":\"registry\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiptAsset\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"shareTokenName\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"shareTokenSymbol\",\"type\":\"string\"},{\"internalType\":\"contract EntityBaseTokenTransferor\",\"name\":\"ebtt\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"processor\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cap\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"feeTreasury\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"depositFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"redemptionFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"aumRate\",\"type\":\"uint256\"}],\"internalType\":\"struct ConstructorArgs\",\"name\":\"_args\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AlreadyInitialized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BadCheckCapImplementation\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BadEntityInput\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"response\",\"type\":\"bytes\"}],\"name\":\"CallFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DepositAfterShutdown\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DidShutdown\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ExceedsCap\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidAuthority\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidRate\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSwapper\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MinDeposit\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotEntity\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PercentageOver100\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RoundsToZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Slippage\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferDisallowed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Unauthorized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnderMaintenance\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"feeAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timeDelta\",\"type\":\"uint256\"}],\"name\":\"AumFeesTaken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"}],\"name\":\"AumRateSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cap\",\"type\":\"uint256\"}],\"name\":\"CapSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract Entity\",\"name\":\"entity\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountShares\",\"type\":\"uint256\"}],\"name\":\"CorrectionShareBurned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract Entity\",\"name\":\"entity\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountShares\",\"type\":\"uint256\"}],\"name\":\"CorrectionShareMinted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"depositAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract Entity\",\"name\":\"entity\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountBaseToken\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountAssets\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountShares\",\"type\":\"uint256\"}],\"name\":\"DepositConsolidated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"DepositFeeSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"feeTreasury\",\"type\":\"address\"}],\"name\":\"FeeTreasurySet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"FeesTaken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newMinDeposit\",\"type\":\"uint256\"}],\"name\":\"MinDepositSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newProcessor\",\"type\":\"address\"}],\"name\":\"ProcessorSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"redeemedAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"Redeem\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract Entity\",\"name\":\"entity\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountBaseToken\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountAssets\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"RedeemConsolidated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"RedemptionFeeSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assetAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"baseTokenOut\",\"type\":\"uint256\"}],\"name\":\"Shutdown\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"newUnderMaintenance\",\"type\":\"bool\"}],\"name\":\"UnderMaintenanceSet\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERMIT_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"asset\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"async\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"aumRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"authority\",\"outputs\":[{\"internalType\":\"contract RolesAuthority\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseToken\",\"outputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_target\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"callAsPortfolio\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"enum ConsolidationOperation\",\"name\":\"operation\",\"type\":\"uint8\"},{\"internalType\":\"contract Entity\",\"name\":\"entity\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountBaseToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountAssets\",\"type\":\"uint256\"}],\"internalType\":\"struct Consolidation[]\",\"name\":\"_consolidations\",\"type\":\"tuple[]\"}],\"name\":\"consolidateNoAccrual\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"enum ConsolidationOperation\",\"name\":\"operation\",\"type\":\"uint8\"},{\"internalType\":\"contract Entity\",\"name\":\"entity\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountBaseToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountAssets\",\"type\":\"uint256\"}],\"internalType\":\"struct Consolidation[]\",\"name\":\"_consolidations\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"_accruedAssets\",\"type\":\"uint256\"}],\"name\":\"consolidateWithAccrual\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_receiptAssets\",\"type\":\"uint256\"}],\"name\":\"convertReceiptAssetsToAssets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_shares\",\"type\":\"uint256\"}],\"name\":\"convertToAssets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_shares\",\"type\":\"uint256\"}],\"name\":\"convertToAssetsShutdown\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_assets\",\"type\":\"uint256\"}],\"name\":\"convertToShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Entity\",\"name\":\"_entity\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"correctionBurn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Entity\",\"name\":\"_entity\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"correctionMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amountBaseToken\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"deposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"didShutdown\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ebtt\",\"outputs\":[{\"internalType\":\"contract EntityBaseTokenTransferor\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeTreasury\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Entity\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"pendingPurchaseBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Entity\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"pendingSaleAssets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"processor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"receiptAsset\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amountShares\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"redeem\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"redemptionFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"registry\",\"outputs\":[{\"internalType\":\"contract Registry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pct\",\"type\":\"uint256\"}],\"name\":\"setAumRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"setCap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pct\",\"type\":\"uint256\"}],\"name\":\"setDepositFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeTreasury\",\"type\":\"address\"}],\"name\":\"setFeeTreasury\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_min\",\"type\":\"uint256\"}],\"name\":\"setMinDeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_processor\",\"type\":\"address\"}],\"name\":\"setProcessor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pct\",\"type\":\"uint256\"}],\"name\":\"setRedemptionFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_underMaintenance\",\"type\":\"bool\"}],\"name\":\"setUnderMaintenance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"shutdown\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"baseTokenOut\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"specialTarget\",\"outputs\":[{\"internalType\":\"bytes20\",\"name\":\"\",\"type\":\"bytes20\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"takeAumFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amountReceiptAssets\",\"type\":\"uint256\"}],\"name\":\"takeFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timestampAumFeesTaken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalAssets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalReceiptAssets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"underMaintenance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "TPlusNPortfolio", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "9999999", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000000002000000000000000000000000094106ca9c7e567109a1d39413052887d1f41218300000000000000000000000044ccce78b08c97a07fc3758e24f7bd8e808365f7000000000000000000000000000000000000000000000000000000000000018000000000000000000000000000000000000000000000000000000000000001e00000000000000000000000002113363253ecb409a816ddfed305dadc51e560fb000000000000000000000000899e57d9858e39c64fbb24fa7d9d0f993158e178000000000000000000000000000000000000000000000000000000001dcd6500ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000000000000000000000010fb0bbece3c5b893563bcb8850403eacaeae30c00000000000000000000000000000000000000000000000000000000000000190000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000971a8ad00000000000000000000000000000000000000000000000000000000000000325350445220504f5254464f4c494f2041474752454741544520424f4e442045544620506f7274666f6c696f2053686172657300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000007535041422d505300000000000000000000000000000000000000000000000000", "EVMVersion": "london", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}