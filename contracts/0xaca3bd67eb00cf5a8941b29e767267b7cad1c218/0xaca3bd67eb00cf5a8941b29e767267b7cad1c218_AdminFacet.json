{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/sol-scripts/deploy/UpgradeMainnetOct2023.s.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.21;\\n\\nimport {IDiamondCut} from \\\"diamond/contracts/interfaces/IDiamondCut.sol\\\";\\nimport {ISignature} from \\\"../../interface/ISignature.sol\\\";\\nimport {IKairos} from \\\"../../interface/IKairos.sol\\\";\\n\\n// solhint-disable no-console\\nimport {console} from \\\"forge-std/console.sol\\\";\\nimport {Script} from \\\"forge-std/Script.sol\\\";\\n\\nimport {BorrowFacet} from \\\"../../BorrowFacet.sol\\\";\\nimport {ContractsCreator} from \\\"../../ContractsCreator.sol\\\";\\nimport {RepayFacet} from \\\"../../RepayFacet.sol\\\";\\nimport {AdminFacet} from \\\"../../AdminFacet.sol\\\";\\n\\ncontract UpgradeMainnetOct2023 is Script, ContractsCreator {\\n    function run() public {\\n        // IKairos kairos = IKairos(0xa7fc58e0594C2e8ecEfFADCE2B3d606Baf782520); // ethereum mainnet\\n        // IKairos kairos = IKairos(0x873b6390626ce29976372779ec2722e0117ec375); // polygon mainnet\\n\\n        uint256 privateKey = vm.envUint(\\\"DEPLOYER_KEY\\\");\\n        bytes4[] memory borrowSelectorsToDelete = new bytes4[](2);\\n        borrowSelectorsToDelete[0] = 0x1fbc8a74; // old offerDigest\\n        borrowSelectorsToDelete[1] = 0xb1ce7a6a; // old borrow\\n        bytes4[] memory singleBorrowSelectorToUpgrade = new bytes4[](1);\\n        singleBorrowSelectorToUpgrade[0] = BorrowFacet.onERC721Received.selector;\\n        bytes4[] memory borrowSelectorsToAdd = new bytes4[](4);\\n        borrowSelectorsToAdd[0] = ISignature.apiCoSignedPayloadDigest.selector;\\n        borrowSelectorsToAdd[1] = BorrowFacet.transferBorrowerRights.selector;\\n        borrowSelectorsToAdd[2] = BorrowFacet.borrow.selector;\\n        borrowSelectorsToAdd[3] = ISignature.offerDigest.selector;\\n        bytes4[] memory singleRepaySelectorToAdd = new bytes4[](1);\\n        singleRepaySelectorToAdd[0] = RepayFacet.toRepay.selector;\\n        bytes4[] memory singleAdminSelectorToAdd = new bytes4[](1);\\n        singleAdminSelectorToAdd[0] = AdminFacet.setApiAddress.selector;\\n        IDiamondCut.FacetCut[] memory facetCuts = new IDiamondCut.FacetCut[](5);\\n\\n        vm.startBroadcast(privateKey);\\n        borrow = new BorrowFacet();\\n        repay = new RepayFacet();\\n        admin = new AdminFacet();\\n\\n        facetCuts[0] = getRemoveFacetCut(borrowSelectorsToDelete);\\n        facetCuts[1] = getUpgradeFacetCut(address(borrow), singleBorrowSelectorToUpgrade);\\n        facetCuts[2] = getAddFacetCut(address(borrow), borrowSelectorsToAdd);\\n        facetCuts[3] = getAddFacetCut(address(repay), singleRepaySelectorToAdd);\\n        facetCuts[4] = getAddFacetCut(address(admin), singleAdminSelectorToAdd);\\n\\n        vm.stopBroadcast();\\n\\n        console.logBytes(abi.encodeWithSelector(IDiamondCut.diamondCut.selector, facetCuts, address(0), new bytes(0)));\\n\\n        // kairos.setApiAddress(0xc0e8DD6b53DF5451EB35A00707ae2b0675F41Bd3); // prod api signer\\n    }\\n}\\n\"\r\n    },\r\n    \"../../node_modules/diamond/contracts/interfaces/IDiamondCut.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\n\\nimport { IDiamond } from \\\"./IDiamond.sol\\\";\\n\\ninterface IDiamondCut is IDiamond {    \\n\\n    /// @notice Add/replace/remove any number of functions and optionally execute\\n    ///         a function with delegatecall\\n    /// @param _diamondCut Contains the facet addresses and function selectors\\n    /// @param _init The address of the contract or facet to execute _calldata\\n    /// @param _calldata A function call, including function selector and arguments\\n    ///                  _calldata is executed with delegatecall on _init\\n    function diamondCut(\\n        FacetCut[] calldata _diamondCut,\\n        address _init,\\n        bytes calldata _calldata\\n    ) external;    \\n}\\n\"\r\n    },\r\n    \"src/interface/ISignature.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.21;\\n\\nimport {Offer, ApiCoSignedPayload} from \\\"../DataStructure/Objects.sol\\\";\\n\\ninterface ISignature {\\n    function offerDigest(Offer memory offer) external view returns (bytes32);\\n\\n    function apiCoSignedPayloadDigest(ApiCoSignedPayload memory apiPayload) external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"src/interface/IKairos.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.21;\\n\\nimport {IDiamondLoupe} from \\\"diamond/contracts/interfaces/IDiamondLoupe.sol\\\";\\nimport {IDiamondCut} from \\\"diamond/contracts/interfaces/IDiamondCut.sol\\\";\\n\\nimport {IAdminFacet} from \\\"./IAdminFacet.sol\\\";\\nimport {IAuctionFacet} from \\\"./IAuctionFacet.sol\\\";\\nimport {IBorrowFacet} from \\\"./IBorrowFacet.sol\\\";\\nimport {IClaimFacet} from \\\"./IClaimFacet.sol\\\";\\nimport {IOwnershipFacet} from \\\"./IOwnershipFacet.sol\\\";\\nimport {IProtocolFacet} from \\\"./IProtocolFacet.sol\\\";\\nimport {IRepayFacet} from \\\"./IRepayFacet.sol\\\";\\nimport {ISupplyPositionFacet} from \\\"./ISupplyPositionFacet.sol\\\";\\n\\n/* solhint-disable-next-line no-empty-blocks */\\ninterface IKairos is\\n    IDiamondLoupe,\\n    IDiamondCut,\\n    IAdminFacet,\\n    IAuctionFacet,\\n    IBorrowFacet,\\n    IClaimFacet,\\n    IOwnershipFacet,\\n    IProtocolFacet,\\n    IRepayFacet,\\n    ISupplyPositionFacet\\n{\\n\\n}\\n\"\r\n    },\r\n    \"../../node_modules/forge-std/src/console.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.4.22 <0.9.0;\\n\\nlibrary console {\\n    address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\\n\\n    function _sendLogPayload(bytes memory payload) private view {\\n        uint256 payloadLength = payload.length;\\n        address consoleAddress = CONSOLE_ADDRESS;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let payloadStart := add(payload, 32)\\n            let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\\n        }\\n    }\\n\\n    function log() internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log()\\\"));\\n    }\\n\\n    function logInt(int p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(int)\\\", p0));\\n    }\\n\\n    function logUint(uint p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint)\\\", p0));\\n    }\\n\\n    function logString(string memory p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n    }\\n\\n    function logBool(bool p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n    }\\n\\n    function logAddress(address p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n    }\\n\\n    function logBytes(bytes memory p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes)\\\", p0));\\n    }\\n\\n    function logBytes1(bytes1 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes1)\\\", p0));\\n    }\\n\\n    function logBytes2(bytes2 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes2)\\\", p0));\\n    }\\n\\n    function logBytes3(bytes3 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes3)\\\", p0));\\n    }\\n\\n    function logBytes4(bytes4 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes4)\\\", p0));\\n    }\\n\\n    function logBytes5(bytes5 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes5)\\\", p0));\\n    }\\n\\n    function logBytes6(bytes6 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes6)\\\", p0));\\n    }\\n\\n    function logBytes7(bytes7 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes7)\\\", p0));\\n    }\\n\\n    function logBytes8(bytes8 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes8)\\\", p0));\\n    }\\n\\n    function logBytes9(bytes9 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes9)\\\", p0));\\n    }\\n\\n    function logBytes10(bytes10 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes10)\\\", p0));\\n    }\\n\\n    function logBytes11(bytes11 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes11)\\\", p0));\\n    }\\n\\n    function logBytes12(bytes12 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes12)\\\", p0));\\n    }\\n\\n    function logBytes13(bytes13 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes13)\\\", p0));\\n    }\\n\\n    function logBytes14(bytes14 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes14)\\\", p0));\\n    }\\n\\n    function logBytes15(bytes15 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes15)\\\", p0));\\n    }\\n\\n    function logBytes16(bytes16 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes16)\\\", p0));\\n    }\\n\\n    function logBytes17(bytes17 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes17)\\\", p0));\\n    }\\n\\n    function logBytes18(bytes18 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes18)\\\", p0));\\n    }\\n\\n    function logBytes19(bytes19 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes19)\\\", p0));\\n    }\\n\\n    function logBytes20(bytes20 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes20)\\\", p0));\\n    }\\n\\n    function logBytes21(bytes21 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes21)\\\", p0));\\n    }\\n\\n    function logBytes22(bytes22 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes22)\\\", p0));\\n    }\\n\\n    function logBytes23(bytes23 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes23)\\\", p0));\\n    }\\n\\n    function logBytes24(bytes24 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes24)\\\", p0));\\n    }\\n\\n    function logBytes25(bytes25 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes25)\\\", p0));\\n    }\\n\\n    function logBytes26(bytes26 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes26)\\\", p0));\\n    }\\n\\n    function logBytes27(bytes27 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes27)\\\", p0));\\n    }\\n\\n    function logBytes28(bytes28 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes28)\\\", p0));\\n    }\\n\\n    function logBytes29(bytes29 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes29)\\\", p0));\\n    }\\n\\n    function logBytes30(bytes30 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes30)\\\", p0));\\n    }\\n\\n    function logBytes31(bytes31 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes31)\\\", p0));\\n    }\\n\\n    function logBytes32(bytes32 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes32)\\\", p0));\\n    }\\n\\n    function log(uint p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint)\\\", p0));\\n    }\\n\\n    function log(string memory p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n    }\\n\\n    function log(bool p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n    }\\n\\n    function log(address p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n    }\\n\\n    function log(uint p0, uint p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint)\\\", p0, p1));\\n    }\\n\\n    function log(uint p0, string memory p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string)\\\", p0, p1));\\n    }\\n\\n    function log(uint p0, bool p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool)\\\", p0, p1));\\n    }\\n\\n    function log(uint p0, address p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, uint p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, string memory p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, bool p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, address p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, uint p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, string memory p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, bool p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, address p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, uint p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, string memory p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, bool p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, address p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address)\\\", p0, p1));\\n    }\\n\\n    function log(uint p0, uint p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, uint p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, uint p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, uint p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, string memory p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, string memory p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, string memory p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, string memory p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, bool p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, bool p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, bool p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, bool p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, address p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, address p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, address p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, address p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, uint p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n}\"\r\n    },\r\n    \"../../node_modules/forge-std/src/Script.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.2 <0.9.0;\\n\\n// \ud83d\udcac ABOUT\\n// Forge Std's default Script.\\n\\n// \ud83e\udde9 MODULES\\nimport {console} from \\\"./console.sol\\\";\\nimport {console2} from \\\"./console2.sol\\\";\\nimport {safeconsole} from \\\"./safeconsole.sol\\\";\\nimport {StdChains} from \\\"./StdChains.sol\\\";\\nimport {StdCheatsSafe} from \\\"./StdCheats.sol\\\";\\nimport {stdJson} from \\\"./StdJson.sol\\\";\\nimport {stdMath} from \\\"./StdMath.sol\\\";\\nimport {StdStorage, stdStorageSafe} from \\\"./StdStorage.sol\\\";\\nimport {StdStyle} from \\\"./StdStyle.sol\\\";\\nimport {StdUtils} from \\\"./StdUtils.sol\\\";\\nimport {VmSafe} from \\\"./Vm.sol\\\";\\n\\n// \ud83d\udce6 BOILERPLATE\\nimport {ScriptBase} from \\\"./Base.sol\\\";\\n\\n// \u2b50\ufe0f SCRIPT\\nabstract contract Script is ScriptBase, StdChains, StdCheatsSafe, StdUtils {\\n    // Note: IS_SCRIPT() must return true.\\n    bool public IS_SCRIPT = true;\\n}\\n\"\r\n    },\r\n    \"src/BorrowFacet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.21;\\n\\nimport {IERC721} from \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\n\\nimport {IBorrowFacet} from \\\"./interface/IBorrowFacet.sol\\\";\\n\\nimport {BorrowHandlers} from \\\"./BorrowLogic/BorrowHandlers.sol\\\";\\nimport {BorrowArg, NFToken, Offer, OfferArg} from \\\"./DataStructure/Objects.sol\\\";\\nimport {protocolStorage} from \\\"./DataStructure/Global.sol\\\";\\nimport {Loan} from \\\"./DataStructure/Storage.sol\\\";\\nimport {NotBorrowerOfTheLoan} from \\\"./DataStructure/Errors.sol\\\";\\n\\n/// @notice public facing methods for borrowing\\n/// @dev contract handles all borrowing logic through inheritance\\ncontract BorrowFacet is IBorrowFacet, BorrowHandlers {\\n    /// @notice borrow using sent NFT as collateral without needing approval through transfer callback\\n    /// @param from account that owned the NFT before transfer\\n    /// @param tokenId token identifier of the NFT sent according to the NFT implementation contract\\n    /// @param data abi encoded arguments for the loan\\n    /// @return selector `this.onERC721Received.selector` ERC721-compliant response, signaling compatibility\\n    /// @dev param data must be of format OfferArg[]\\n    function onERC721Received(\\n        address, // operator\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4) {\\n        OfferArg[] memory args = abi.decode(data, (OfferArg[]));\\n\\n        // `from` will be considered the borrower, and the NFT will be transferred to the Kairos contract\\n        // the `operator` that called `safeTransferFrom` is ignored\\n        useCollateral(args, from, NFToken({implem: IERC721(msg.sender), id: tokenId}));\\n\\n        return this.onERC721Received.selector;\\n    }\\n\\n    /// @notice take loans, take ownership of NFTs specified as collateral, sends borrowed money to caller\\n    /// @param args list of arguments specifying at which terms each collateral should be used\\n    /// @return loanIds list of loan ids created\\n    function borrow(BorrowArg[] calldata args) external returns (uint256[] memory loanIds) {\\n        loanIds = new uint256[](args.length);\\n\\n        for (uint256 i = 0; i < args.length; i++) {\\n            args[i].nft.implem.transferFrom(msg.sender, address(this), args[i].nft.id);\\n            uint256 loan = useCollateral(args[i].args, msg.sender, args[i].nft);\\n            loanIds[i] = loan;\\n        }\\n\\n        return loanIds;\\n    }\\n\\n    /// @notice transfer borrow rights on a loan to another account, the new borrower will receive the collateral\\n    ///     on repayment or will be able to claim a share of the collateral sale on liquidation\\n    /// @param loanId id of the loan\\n    /// @param newBorrower account that will receive the rights\\n    function transferBorrowerRights(uint256 loanId, address newBorrower) external {\\n        Loan storage loan = protocolStorage().loan[loanId];\\n\\n        if (loan.borrower != msg.sender) {\\n            revert NotBorrowerOfTheLoan(loanId);\\n        }\\n\\n        loan.borrower = newBorrower;\\n\\n        emit TransferBorrowRights(loanId, msg.sender, newBorrower);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/ContractsCreator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.21;\\n\\nimport {OwnershipFacet} from \\\"diamond/contracts/facets/OwnershipFacet.sol\\\";\\nimport {DiamondCutFacet} from \\\"diamond/contracts/facets/DiamondCutFacet.sol\\\";\\nimport {IDiamond} from \\\"diamond/contracts/interfaces/IDiamond.sol\\\";\\nimport {IDiamondCut} from \\\"diamond/contracts/interfaces/IDiamondCut.sol\\\";\\nimport {DiamondLoupeFacet} from \\\"diamond/contracts/facets/DiamondLoupeFacet.sol\\\";\\n\\nimport {AdminFacet} from \\\"./AdminFacet.sol\\\";\\nimport {AuctionFacet} from \\\"./AuctionFacet.sol\\\";\\nimport {BorrowFacet} from \\\"./BorrowFacet.sol\\\";\\nimport {ClaimFacet} from \\\"./ClaimFacet.sol\\\";\\nimport {Initializer} from \\\"./Initializer.sol\\\";\\nimport {ProtocolFacet} from \\\"./ProtocolFacet.sol\\\";\\nimport {RepayFacet} from \\\"./RepayFacet.sol\\\";\\nimport {SupplyPositionFacet} from \\\"./SupplyPositionFacet.sol\\\";\\n/* solhint-disable-next-line max-line-length */\\nimport {adminFS, auctionFS, claimFS, borrowFS, cutFS, loupeFS, protoFS, ownershipFS, repayFS, supplyPositionFS} from \\\"./utils/FuncSelectors.h.sol\\\";\\n\\n/// @notice handles uinitialized deployment of all contracts of the protocol and exposes facet cuts\\n/// @dev for production, the 3 contracts imported from diamonds don't have to be redeployed as they are already\\n///      existing on most chain, modify deploy script accordingly\\ncontract ContractsCreator {\\n    Initializer internal initializer;\\n    DiamondCutFacet internal cut;\\n    OwnershipFacet internal ownership;\\n    DiamondLoupeFacet internal loupe;\\n    AdminFacet internal admin;\\n    BorrowFacet internal borrow;\\n    SupplyPositionFacet internal supplyPosition;\\n    ProtocolFacet internal protocol;\\n    RepayFacet internal repay;\\n    AuctionFacet internal auction;\\n    ClaimFacet internal claim;\\n\\n    /// @notice deploys all contracts uninitialized\\n    function createContracts() internal {\\n        admin = new AdminFacet();\\n        cut = new DiamondCutFacet();\\n        loupe = new DiamondLoupeFacet();\\n        ownership = new OwnershipFacet();\\n        repay = new RepayFacet();\\n        borrow = new BorrowFacet();\\n        supplyPosition = new SupplyPositionFacet();\\n        protocol = new ProtocolFacet();\\n        initializer = new Initializer();\\n        auction = new AuctionFacet();\\n        claim = new ClaimFacet();\\n    }\\n\\n    /// @notice get all facet cuts to add to add to a diamond to create kairos\\n    /// @return facetCuts the list of facet cuts\\n    /* solhint-disable-next-line function-max-lines */\\n    function getFacetCuts() internal view returns (IDiamondCut.FacetCut[] memory) {\\n        IDiamondCut.FacetCut[] memory facetCuts = new IDiamondCut.FacetCut[](10);\\n\\n        facetCuts[0] = getAddFacetCut(address(loupe), loupeFS());\\n        facetCuts[1] = getAddFacetCut(address(ownership), ownershipFS());\\n        facetCuts[2] = getAddFacetCut(address(cut), cutFS());\\n        facetCuts[3] = getAddFacetCut(address(borrow), borrowFS());\\n        facetCuts[4] = getAddFacetCut(address(supplyPosition), supplyPositionFS());\\n        facetCuts[5] = getAddFacetCut(address(protocol), protoFS());\\n        facetCuts[6] = getAddFacetCut(address(repay), repayFS());\\n        facetCuts[7] = getAddFacetCut(address(auction), auctionFS());\\n        facetCuts[8] = getAddFacetCut(address(claim), claimFS());\\n        facetCuts[9] = getAddFacetCut(address(admin), adminFS());\\n\\n        return facetCuts;\\n    }\\n\\n    function getAddFacetCut(\\n        address facet,\\n        bytes4[] memory selectors\\n    ) internal pure returns (IDiamondCut.FacetCut memory) {\\n        return\\n            IDiamond.FacetCut({facetAddress: facet, action: IDiamond.FacetCutAction.Add, functionSelectors: selectors});\\n    }\\n\\n    function getUpgradeFacetCut(\\n        address facet,\\n        bytes4[] memory selectors\\n    ) internal pure returns (IDiamondCut.FacetCut memory) {\\n        return\\n            IDiamond.FacetCut({\\n                facetAddress: facet,\\n                action: IDiamond.FacetCutAction.Replace,\\n                functionSelectors: selectors\\n            });\\n    }\\n\\n    function getRemoveFacetCut(bytes4[] memory selectors) internal pure returns (IDiamondCut.FacetCut memory) {\\n        return\\n            IDiamond.FacetCut({\\n                facetAddress: address(0),\\n                action: IDiamond.FacetCutAction.Remove,\\n                functionSelectors: selectors\\n            });\\n    }\\n}\\n\"\r\n    },\r\n    \"src/RepayFacet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.21;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nimport {IRepayFacet} from \\\"./interface/IRepayFacet.sol\\\";\\n\\nimport {Loan, Protocol} from \\\"./DataStructure/Storage.sol\\\";\\nimport {LoanAlreadyRepaid} from \\\"./DataStructure/Errors.sol\\\";\\nimport {protocolStorage} from \\\"./DataStructure/Global.sol\\\";\\nimport {Ray} from \\\"./DataStructure/Objects.sol\\\";\\nimport {RayMath} from \\\"./utils/RayMath.sol\\\";\\nimport {Erc20CheckedTransfer} from \\\"./utils/Erc20CheckedTransfer.sol\\\";\\n\\n/// @notice handles repayment with interests of loans\\ncontract RepayFacet is IRepayFacet {\\n    using RayMath for Ray;\\n    using RayMath for uint256;\\n    using Erc20CheckedTransfer for IERC20;\\n\\n    /// @notice repay one or multiple loans, gives collaterals back\\n    /// @dev repay on behalf is activated, the collateral goes to the original borrower\\n    /// @param loanIds identifiers of loans to repay\\n    function repay(uint256[] memory loanIds) external {\\n        Protocol storage proto = protocolStorage();\\n        Loan storage loan;\\n        uint256 amountTransferred;\\n\\n        for (uint256 i = 0; i < loanIds.length; i++) {\\n            loan = proto.loan[loanIds[i]];\\n            // loan.payment.paid may be at 0 and considered repaid in case of an auction sale executed at price 0\\n\\n            amountTransferred = toRepay(loan, loanIds[i]);\\n            loan.payment.paid = amountTransferred;\\n            loan.payment.borrowerClaimed = true;\\n            loan.assetLent.checkedTransferFrom(msg.sender, address(this), amountTransferred);\\n            loan.collateral.implem.safeTransferFrom(address(this), loan.borrower, loan.collateral.id);\\n            emit Repay(loanIds[i]);\\n        }\\n    }\\n\\n    function toRepay(uint256 loanId) external view returns (uint256 amount) {\\n        Loan storage loan = protocolStorage().loan[loanId];\\n        amount = toRepay(loan, loanId);\\n    }\\n\\n    function toRepay(Loan storage loan, uint256 loanId) internal view returns (uint256 repayAmount) {\\n        uint256 lent;\\n        uint256 interests;\\n\\n        if (loan.payment.paid > 0 || loan.payment.borrowerClaimed || loan.payment.liquidated) {\\n            revert LoanAlreadyRepaid(loanId);\\n        }\\n        lent = loan.lent;\\n        /* if the linear interests are very low due to a short time elapsed, the minimal interests amount to repay\\n            is applied as an anti ddos mechanism */\\n        interests = RayMath.max(\\n            /* during the interests calculus, we can consider that (block.timestamp - loan.startDate)\\n                won't exceed 1e10 (>100 years) and interest per second (unwrapped value) won't exceed\\n                1e27 (corresponding to an amount to repay doubling after 1 second), we can deduce that\\n                (loan.interestPerSecond.mul(block.timestamp - loan.startDate)) is capped by 1e10 * 1e27 = 1e37\\n                we want to avoid the interests calculus to overflow so the result must not exceed 1e77\\n                as (1e77 < type(uint256).max). So we can allow `lent` to go as high as 1e40, but not above.\\n                This explains why borrowing throws on loan.lent > 1e40, as this realisticly avoids\\n                repaying being impossible due to an overflow. */\\n            /* the interest per second is a share of what has been lent to add to the interests each second. The\\n                next line accrues linearly */\\n            lent.mul(loan.interestPerSecond.mul(block.timestamp - loan.startDate)),\\n            loan.payment.minInterestsToRepay\\n        );\\n        repayAmount = lent + interests;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/AdminFacet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.21;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nimport {IOwnershipFacet} from \\\"./interface/IOwnershipFacet.sol\\\";\\nimport {IAdminFacet} from \\\"./interface/IAdminFacet.sol\\\";\\nimport {Ray} from \\\"./DataStructure/Objects.sol\\\";\\nimport {Protocol} from \\\"./DataStructure/Storage.sol\\\";\\nimport {protocolStorage, supplyPositionMetadataStorage, ONE, apiCoSignerStorage} from \\\"./DataStructure/Global.sol\\\";\\nimport {CallerIsNotOwner} from \\\"./DataStructure/Errors.sol\\\";\\nimport {RayMath} from \\\"./utils/RayMath.sol\\\";\\n\\n/// @notice admin-only setters for global protocol parameters\\ncontract AdminFacet is IAdminFacet {\\n    using RayMath for Ray;\\n\\n    /// @notice restrict a method access to the protocol owner only\\n    modifier onlyOwner() {\\n        // the admin/owner is the same account that can upgrade the protocol.\\n        address admin = IOwnershipFacet(address(this)).owner();\\n        if (msg.sender != admin) {\\n            revert CallerIsNotOwner(admin);\\n        }\\n        _;\\n    }\\n\\n    /// @notice sets the time it takes to auction prices to fall to 0 for future loans\\n    /// @param newAuctionDuration number of seconds of the duration\\n    function setAuctionDuration(uint256 newAuctionDuration) external onlyOwner {\\n        protocolStorage().auction.duration = newAuctionDuration;\\n        emit NewAuctionDuration(newAuctionDuration);\\n    }\\n\\n    /// @notice sets the factor applied to the loan to value setting initial price of auction for future loans\\n    /// @param newAuctionPriceFactor the new factor multiplied to the loan to value\\n    function setAuctionPriceFactor(Ray newAuctionPriceFactor) external onlyOwner {\\n        // see auction facet for the rationale of this check\\n        require(newAuctionPriceFactor.gte(ONE.mul(5).div(2)), \\\"\\\");\\n        protocolStorage().auction.priceFactor = newAuctionPriceFactor;\\n        emit NewAuctionPriceFactor(newAuctionPriceFactor);\\n    }\\n\\n    /// @notice creates a new tranche at a new identifier for lenders to provide offers for\\n    /// @param newTranche the interest rate of the new tranche\\n    function createTranche(Ray newTranche) external onlyOwner returns (uint256 newTrancheId) {\\n        Protocol storage proto = protocolStorage();\\n\\n        newTrancheId = proto.nbOfTranches++;\\n        proto.tranche[newTrancheId] = newTranche;\\n\\n        emit NewTranche(newTranche, newTrancheId);\\n    }\\n\\n    /* Both minimal offer cost and lower amount per offer lower bound are anti ddos mechanisms used to prevent the\\n    borrowers to spam the minting of supply positions that lenders would have no incentive to claim the corresponding\\n    dust funds from due to gas costs. The minimal offer cost mainly prevents this for claims after repayment, the amount\\n    per offer lower bound mainly prevents this for claims after liquidation. The governance setting those parameters\\n    effectively makes new erc20 available to use on the platform (they are disallowed otherwise). This should not\\n    be done for any fee-on-transfer token. */\\n\\n    /// @notice updates the minimum amount to repay per used loan offer when borrowing a certain currency\\n    /// @param currency the erc20 on which a new minimum borrow cost will take effect\\n    /// @param newMinOfferCost the new minimum amount that will need to be repaid per loan offer used\\n    function setMinOfferCost(IERC20 currency, uint256 newMinOfferCost) external onlyOwner {\\n        protocolStorage().minOfferCost[currency] = newMinOfferCost;\\n        emit NewMininimumOfferCost(currency, newMinOfferCost);\\n    }\\n\\n    /// @notice updates the borrow amount lower bound per offer for one currency\\n    /// @param currency the erc20 on which a new borrow amount lower bound is taking effect\\n    /// @param newLowerBound the new lower bound\\n    function setBorrowAmountPerOfferLowerBound(IERC20 currency, uint256 newLowerBound) external onlyOwner {\\n        protocolStorage().offerBorrowAmountLowerBound[currency] = newLowerBound;\\n        emit NewBorrowAmountPerOfferLowerBound(currency, newLowerBound);\\n    }\\n\\n    /// @notice updates the base metadata uri to which the token id will be appended to get the metadata uri\\n    /// @param baseMetadataUri the new base metadata uri\\n    function setBaseMetadataUri(string calldata baseMetadataUri) external onlyOwner {\\n        supplyPositionMetadataStorage().baseUri = baseMetadataUri;\\n    }\\n\\n    /// @notice updates the address of the api co-signer\\n    /// @param apiAddress the new address of the api co-signer\\n    function setApiAddress(address apiAddress) external onlyOwner {\\n        apiCoSignerStorage().apiAddress = apiAddress;\\n        emit NewApiAddress(apiAddress);\\n    }\\n}\\n\"\r\n    },\r\n    \"../../node_modules/diamond/contracts/interfaces/IDiamond.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\n\\ninterface IDiamond {\\n    enum FacetCutAction {Add, Replace, Remove}\\n    // Add=0, Replace=1, Remove=2\\n\\n    struct FacetCut {\\n        address facetAddress;\\n        FacetCutAction action;\\n        bytes4[] functionSelectors;\\n    }\\n\\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\\n}\"\r\n    },\r\n    \"src/DataStructure/Objects.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.21;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {IERC721} from \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\n\\n/// @notice file for type definitions not used in storage\\n\\n/// @notice 27-decimals fixed point unsigned number\\ntype Ray is uint256;\\n\\n/// @notice Arguments to buy the collateral of one loan\\n/// @param loanId loan identifier\\n/// @param to address that will receive the collateral\\n/// @param maxPrice maximum price to pay for the collateral\\nstruct BuyArg {\\n    uint256 loanId;\\n    address to;\\n    uint256 maxPrice;\\n}\\n\\n/// @notice Arguments to borrow from one collateral\\n/// @param nft asset to use as collateral\\n/// @param args arguments for the borrow parameters of the offers to use with the collateral\\nstruct BorrowArg {\\n    NFToken nft;\\n    OfferArg[] args;\\n}\\n\\n/// @notice Arguments for the borrow parameters of an offer\\n/// @dev '-' means n^th\\n/// @param apiCoSignedPayload api validation info and lender signature\\n/// @param apiSignature - of the api co-signed payload\\n/// @param amount - to borrow from this offer\\n/// @param merkleProof - that the NFT intended to be used as collateral is in the list of accepted NFTs\\n/// @param offer intended for usage in the loan\\nstruct OfferArg {\\n    ApiCoSignedPayload apiCoSignedPayload;\\n    bytes apiSignature;\\n    uint256 amount;\\n    bytes32[] merkleProof;\\n    Offer offer;\\n}\\n\\n/// @notice EIP-712 payload signed by the API to confirm validity of a lender signed offer\\n/// @param inclusionLimitDate date after which the signature is invalid\\n/// @param lenderSignature the EIP-712 lender signed digest of the Offer object agreed upon\\nstruct ApiCoSignedPayload {\\n    uint256 inclusionLimitDate;\\n    bytes lenderSignature;\\n}\\n\\n/// @notice Data on collateral state during the matching process of a NFT\\n///     with multiple offers\\n/// @param matched proportion from 0 to 1 of the collateral value matched by offers\\n/// @param assetLent - ERC20 that the protocol will send as loan\\n/// @param tranche identifier of the interest rate tranche that will be used for the loan\\n/// @param minOfferDuration minimal duration among offers used\\n/// @param minOfferLoanToValue\\n/// @param maxOfferLoanToValue\\n/// @param from original owner of the nft (borrower in most cases)\\n/// @param nft the collateral asset\\n/// @param loanId loan identifier\\nstruct CollateralState {\\n    Ray matched;\\n    IERC20 assetLent;\\n    uint256 tranche;\\n    uint256 minOfferDuration;\\n    uint256 minOfferLoanToValue;\\n    uint256 maxOfferLoanToValue;\\n    address from;\\n    NFToken nft;\\n    uint256 loanId;\\n}\\n\\n/// @notice Loan offer\\n/// @param assetToLend address of the ERC-20 to lend\\n/// @param loanToValue amount to lend per collateral\\n/// @param duration in seconds, time before mandatory repayment after loan start\\n/// @param expirationDate date after which the offer can't be used\\n/// @param tranche identifier of the interest rate tranche\\n/// @param nftListMerkleRoot merkle root of the list of NFTs accepted as collateral\\nstruct Offer {\\n    IERC20 assetToLend;\\n    uint256 loanToValue;\\n    uint256 duration;\\n    uint256 expirationDate;\\n    uint256 tranche;\\n    bytes32 nftListMerkleRoot;\\n}\\n\\n/// @title Non Fungible Token\\n/// @notice describes an ERC721 compliant token, can be used as single spec\\n///     I.e Collateral type accepting one specific NFT\\n/// @dev found in storgae\\n/// @param implem address of the NFT contract\\n/// @param id token identifier\\nstruct NFToken {\\n    IERC721 implem;\\n    uint256 id;\\n}\\n\"\r\n    },\r\n    \"../../node_modules/diamond/contracts/interfaces/IDiamondLoupe.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\n\\n// A loupe is a small magnifying glass used to look at diamonds.\\n// These functions look at diamonds\\ninterface IDiamondLoupe {\\n    /// These functions are expected to be called frequently\\n    /// by tools.\\n\\n    struct Facet {\\n        address facetAddress;\\n        bytes4[] functionSelectors;\\n    }\\n\\n    /// @notice Gets all facet addresses and their four byte function selectors.\\n    /// @return facets_ Facet\\n    function facets() external view returns (Facet[] memory facets_);\\n\\n    /// @notice Gets all the function selectors supported by a specific facet.\\n    /// @param _facet The facet address.\\n    /// @return facetFunctionSelectors_\\n    function facetFunctionSelectors(address _facet) external view returns (bytes4[] memory facetFunctionSelectors_);\\n\\n    /// @notice Get all the facet addresses used by a diamond.\\n    /// @return facetAddresses_\\n    function facetAddresses() external view returns (address[] memory facetAddresses_);\\n\\n    /// @notice Gets the facet that supports the given selector.\\n    /// @dev If facet is not found return address(0).\\n    /// @param _functionSelector The function selector.\\n    /// @return facetAddress_ The facet address.\\n    function facetAddress(bytes4 _functionSelector) external view returns (address facetAddress_);\\n}\\n\"\r\n    },\r\n    \"src/interface/IAdminFacet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.21;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nimport {Ray} from \\\"../DataStructure/Objects.sol\\\";\\n\\ninterface IAdminFacet {\\n    /// @notice duration of future auctions has been updated\\n    /// @param newAuctionDuration duration of liquidation for new loans\\n    event NewAuctionDuration(uint256 indexed newAuctionDuration);\\n\\n    /// @notice initial price factor of future auctions has been updated\\n    /// @param newAuctionPriceFactor factor of loan to value setting initial price of auctions\\n    event NewAuctionPriceFactor(Ray indexed newAuctionPriceFactor);\\n\\n    /// @notice a new interest rate tranche has been created\\n    /// @param tranche the interest rate of the new tranche, in multiplier per second\\n    /// @param newTrancheId identifier of the new tranche\\n    event NewTranche(Ray indexed tranche, uint256 indexed newTrancheId);\\n\\n    /// @notice the minimum cost to repay per used loan offer\\n    ///     when borrowing a certain currency has been updated\\n    /// @param currency the erc20 on which a new minimum borrow cost is taking effect\\n    /// @param newMinOfferCost the new minimum amount that will need to be repaid per loan offer used\\n    event NewMininimumOfferCost(IERC20 indexed currency, uint256 indexed newMinOfferCost);\\n\\n    /// @notice the borrow amount lower bound per offer has been updated\\n    /// @param currency the erc20 on which a new borrow amount lower bound is taking effect\\n    /// @param newLowerBound the new lower bound\\n    event NewBorrowAmountPerOfferLowerBound(IERC20 indexed currency, uint256 indexed newLowerBound);\\n\\n    /// @notice the key of the api co-signing offers for validation has been updated\\n    /// @param apiAddress the new address (corresponding to the new key) of the api\\n    event NewApiAddress(address apiAddress);\\n\\n    function setAuctionDuration(uint256 newAuctionDuration) external;\\n\\n    function setAuctionPriceFactor(Ray newAuctionPriceFactor) external;\\n\\n    function createTranche(Ray newTranche) external returns (uint256 newTrancheId);\\n\\n    function setMinOfferCost(IERC20 currency, uint256 newMinOfferCost) external;\\n\\n    function setBorrowAmountPerOfferLowerBound(IERC20 currency, uint256 newLowerBound) external;\\n\\n    function setBaseMetadataUri(string calldata baseMetadataUri) external;\\n\\n    function setApiAddress(address apiAddress) external;\\n}\\n\"\r\n    },\r\n    \"src/interface/IAuctionFacet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.21;\\n\\nimport {BuyArg} from \\\"../DataStructure/Objects.sol\\\";\\n\\ninterface IAuctionFacet {\\n    /// @notice a NFT collateral has been sold as part of a liquidation\\n    /// @param loanId identifier of the loan previously backed by the sold collateral\\n    /// @param args arguments NFT sold\\n    event Buy(uint256 indexed loanId, bytes args);\\n\\n    function buy(BuyArg[] memory args) external;\\n\\n    function price(uint256 loanId) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"src/interface/IBorrowFacet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.21;\\n\\nimport {IERC721Receiver} from \\\"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\\\";\\n\\nimport {IBorrowHandlers} from \\\"./IBorrowHandlers.sol\\\";\\n\\nimport {BorrowArg} from \\\"../DataStructure/Objects.sol\\\";\\n\\ninterface IBorrowFacet is IBorrowHandlers, IERC721Receiver {\\n    /// @notice `from` transferred its borrow rights on loan of id `loanId` to `to`\\n    /// @param loanId id of the loan\\n    /// @param from account that transferred its rights\\n    /// @param to account that received the rights\\n    event TransferBorrowRights(uint256 indexed loanId, address indexed from, address indexed to);\\n\\n    function borrow(BorrowArg[] calldata args) external returns (uint256[] memory loanIds);\\n\\n    function transferBorrowerRights(uint256 loanId, address newBorrower) external;\\n}\\n\"\r\n    },\r\n    \"src/interface/IClaimFacet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.21;\\n\\ninterface IClaimEmitter {\\n    /// @notice some liquidity has been claimed as principal plus interests or share of liquidation\\n    /// @param claimant who received the liquidity\\n    /// @param claimed amount sent\\n    /// @param loanId loan identifier where the claim rights come from\\n    event Claim(address indexed claimant, uint256 indexed claimed, uint256 indexed loanId);\\n}\\n\\ninterface IClaimFacet is IClaimEmitter {\\n    function claim(uint256[] calldata positionIds) external returns (uint256 sent);\\n\\n    function claimAsBorrower(uint256[] calldata loanIds) external returns (uint256 sent);\\n}\\n\"\r\n    },\r\n    \"src/interface/IOwnershipFacet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.21;\\n\\ninterface IOwnershipFacet {\\n    function transferOwnership(address _newOwner) external;\\n\\n    function owner() external view returns (address owner_);\\n}\\n\"\r\n    },\r\n    \"src/interface/IProtocolFacet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.21;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nimport {Ray} from \\\"../DataStructure/Objects.sol\\\";\\nimport {Loan} from \\\"../DataStructure/Storage.sol\\\";\\n\\ninterface IProtocolFacet {\\n    function getRateOfTranche(uint256 id) external view returns (Ray rate);\\n\\n    function getParameters()\\n        external\\n        view\\n        returns (Ray auctionPriceFactor, uint256 auctionDuration, uint256 nbOfLoans, uint256 nbOfTranches);\\n\\n    function getLoan(uint256 id) external view returns (Loan memory);\\n\\n    function getMinOfferCostAndBorrowableAmount(\\n        IERC20 currency\\n    ) external view returns (uint256 minOfferCost, uint256 offerBorrowAmountLowerBound);\\n}\\n\"\r\n    },\r\n    \"src/interface/IRepayFacet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.21;\\n\\ninterface IRepayFacet {\\n    /// @notice a loan has been repaid with interests by its borrower\\n    /// @param loanId loan identifier\\n    event Repay(uint256 indexed loanId);\\n\\n    function repay(uint256[] memory loanIds) external;\\n\\n    function toRepay(uint256 loanId) external view returns (uint256 amount);\\n}\\n\"\r\n    },\r\n    \"src/interface/ISupplyPositionFacet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.21;\\n\\nimport {IERC721} from \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport {Provision} from \\\"../DataStructure/Storage.sol\\\";\\n\\ninterface ISupplyPositionFacet is IERC721 {\\n    function position(uint256) external view returns (Provision memory);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"../../node_modules/forge-std/src/console2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.4.22 <0.9.0;\\n\\n/// @dev The original console.sol uses `int` and `uint` for computing function selectors, but it should\\n/// use `int256` and `uint256`. This modified version fixes that. This version is recommended\\n/// over `console.sol` if you don't need compatibility with Hardhat as the logs will show up in\\n/// forge stack traces. If you do need compatibility with Hardhat, you must use `console.sol`.\\n/// Reference: https://github.com/NomicFoundation/hardhat/issues/2178\\nlibrary console2 {\\n    address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\\n\\n    function _castLogPayloadViewToPure(\\n        function(bytes memory) internal view fnIn\\n    ) internal pure returns (function(bytes memory) internal pure fnOut) {\\n        assembly {\\n            fnOut := fnIn\\n        }\\n    }\\n\\n    function _sendLogPayload(bytes memory payload) internal pure {\\n        _castLogPayloadViewToPure(_sendLogPayloadView)(payload);\\n    }\\n\\n    function _sendLogPayloadView(bytes memory payload) private view {\\n        uint256 payloadLength = payload.length;\\n        address consoleAddress = CONSOLE_ADDRESS;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let payloadStart := add(payload, 32)\\n            let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\\n        }\\n    }\\n\\n    function log() internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log()\\\"));\\n    }\\n\\n    function logInt(int256 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(int256)\\\", p0));\\n    }\\n\\n    function logUint(uint256 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256)\\\", p0));\\n    }\\n\\n    function logString(string memory p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n    }\\n\\n    function logBool(bool p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n    }\\n\\n    function logAddress(address p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n    }\\n\\n    function logBytes(bytes memory p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes)\\\", p0));\\n    }\\n\\n    function logBytes1(bytes1 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes1)\\\", p0));\\n    }\\n\\n    function logBytes2(bytes2 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes2)\\\", p0));\\n    }\\n\\n    function logBytes3(bytes3 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes3)\\\", p0));\\n    }\\n\\n    function logBytes4(bytes4 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes4)\\\", p0));\\n    }\\n\\n    function logBytes5(bytes5 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes5)\\\", p0));\\n    }\\n\\n    function logBytes6(bytes6 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes6)\\\", p0));\\n    }\\n\\n    function logBytes7(bytes7 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes7)\\\", p0));\\n    }\\n\\n    function logBytes8(bytes8 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes8)\\\", p0));\\n    }\\n\\n    function logBytes9(bytes9 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes9)\\\", p0));\\n    }\\n\\n    function logBytes10(bytes10 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes10)\\\", p0));\\n    }\\n\\n    function logBytes11(bytes11 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes11)\\\", p0));\\n    }\\n\\n    function logBytes12(bytes12 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes12)\\\", p0));\\n    }\\n\\n    function logBytes13(bytes13 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes13)\\\", p0));\\n    }\\n\\n    function logBytes14(bytes14 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes14)\\\", p0));\\n    }\\n\\n    function logBytes15(bytes15 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes15)\\\", p0));\\n    }\\n\\n    function logBytes16(bytes16 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes16)\\\", p0));\\n    }\\n\\n    function logBytes17(bytes17 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes17)\\\", p0));\\n    }\\n\\n    function logBytes18(bytes18 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes18)\\\", p0));\\n    }\\n\\n    function logBytes19(bytes19 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes19)\\\", p0));\\n    }\\n\\n    function logBytes20(bytes20 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes20)\\\", p0));\\n    }\\n\\n    function logBytes21(bytes21 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes21)\\\", p0));\\n    }\\n\\n    function logBytes22(bytes22 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes22)\\\", p0));\\n    }\\n\\n    function logBytes23(bytes23 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes23)\\\", p0));\\n    }\\n\\n    function logBytes24(bytes24 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes24)\\\", p0));\\n    }\\n\\n    function logBytes25(bytes25 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes25)\\\", p0));\\n    }\\n\\n    function logBytes26(bytes26 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes26)\\\", p0));\\n    }\\n\\n    function logBytes27(bytes27 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes27)\\\", p0));\\n    }\\n\\n    function logBytes28(bytes28 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes28)\\\", p0));\\n    }\\n\\n    function logBytes29(bytes29 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes29)\\\", p0));\\n    }\\n\\n    function logBytes30(bytes30 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes30)\\\", p0));\\n    }\\n\\n    function logBytes31(bytes31 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes31)\\\", p0));\\n    }\\n\\n    function logBytes32(bytes32 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes32)\\\", p0));\\n    }\\n\\n    function log(uint256 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256)\\\", p0));\\n    }\\n\\n    function log(int256 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(int256)\\\", p0));\\n    }\\n\\n    function log(string memory p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n    }\\n\\n    function log(bool p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n    }\\n\\n    function log(address p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n    }\\n\\n    function log(uint256 p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, int256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,int256)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n}\"\r\n    },\r\n    \"../../node_modules/forge-std/src/safeconsole.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.2 <0.9.0;\\n\\n/// @author philogy <https://github.com/philogy>\\n/// @dev Code generated automatically by script.\\nlibrary safeconsole {\\n    uint256 constant CONSOLE_ADDR = 0x000000000000000000000000000000000000000000636F6e736F6c652e6c6f67;\\n\\n    // Credit to [0age](https://twitter.com/z0age/status/1654922202930888704) and [0xdapper](https://github.com/foundry-rs/forge-std/pull/374)\\n    // for the view-to-pure log trick.\\n    function _sendLogPayload(uint256 offset, uint256 size) private pure {\\n        function(uint256, uint256) internal view fnIn = _sendLogPayloadView;\\n        function(uint256, uint256) internal pure pureSendLogPayload;\\n        assembly {\\n            pureSendLogPayload := fnIn\\n        }\\n        pureSendLogPayload(offset, size);\\n    }\\n\\n    function _sendLogPayloadView(uint256 offset, uint256 size) private view {\\n        assembly {\\n            pop(staticcall(gas(), CONSOLE_ADDR, offset, size, 0x0, 0x0))\\n        }\\n    }\\n\\n    function _memcopy(uint256 fromOffset, uint256 toOffset, uint256 length) private pure {\\n        function(uint256, uint256, uint256) internal view fnIn = _memcopyView;\\n        function(uint256, uint256, uint256) internal pure pureMemcopy;\\n        assembly {\\n            pureMemcopy := fnIn\\n        }\\n        pureMemcopy(fromOffset, toOffset, length);\\n    }\\n\\n    function _memcopyView(uint256 fromOffset, uint256 toOffset, uint256 length) private view {\\n        assembly {\\n            pop(staticcall(gas(), 0x4, fromOffset, length, toOffset, length))\\n        }\\n    }\\n\\n    function logMemory(uint256 offset, uint256 length) internal pure {\\n        if (offset >= 0x60) {\\n            // Sufficient memory before slice to prepare call header.\\n            bytes32 m0;\\n            bytes32 m1;\\n            bytes32 m2;\\n            assembly {\\n                m0 := mload(sub(offset, 0x60))\\n                m1 := mload(sub(offset, 0x40))\\n                m2 := mload(sub(offset, 0x20))\\n                // Selector of `logBytes(bytes)`.\\n                mstore(sub(offset, 0x60), 0xe17bf956)\\n                mstore(sub(offset, 0x40), 0x20)\\n                mstore(sub(offset, 0x20), length)\\n            }\\n            _sendLogPayload(offset - 0x44, length + 0x44);\\n            assembly {\\n                mstore(sub(offset, 0x60), m0)\\n                mstore(sub(offset, 0x40), m1)\\n                mstore(sub(offset, 0x20), m2)\\n            }\\n        } else {\\n            // Insufficient space, so copy slice forward, add header and reverse.\\n            bytes32 m0;\\n            bytes32 m1;\\n            bytes32 m2;\\n            uint256 endOffset = offset + length;\\n            assembly {\\n                m0 := mload(add(endOffset, 0x00))\\n                m1 := mload(add(endOffset, 0x20))\\n                m2 := mload(add(endOffset, 0x40))\\n            }\\n            _memcopy(offset, offset + 0x60, length);\\n            assembly {\\n                // Selector of `logBytes(bytes)`.\\n                mstore(add(offset, 0x00), 0xe17bf956)\\n                mstore(add(offset, 0x20), 0x20)\\n                mstore(add(offset, 0x40), length)\\n            }\\n            _sendLogPayload(offset + 0x1c, length + 0x44);\\n            _memcopy(offset + 0x60, offset, length);\\n            assembly {\\n                mstore(add(endOffset, 0x00), m0)\\n                mstore(add(endOffset, 0x20), m1)\\n                mstore(add(endOffset, 0x40), m2)\\n            }\\n        }\\n    }\\n\\n    function log(address p0) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            // Selector of `log(address)`.\\n            mstore(0x00, 0x2c2ecbc2)\\n            mstore(0x20, p0)\\n        }\\n        _sendLogPayload(0x1c, 0x24);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n        }\\n    }\\n\\n    function log(bool p0) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            // Selector of `log(bool)`.\\n            mstore(0x00, 0x32458eed)\\n            mstore(0x20, p0)\\n        }\\n        _sendLogPayload(0x1c, 0x24);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n        }\\n    }\\n\\n    function log(uint256 p0) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            // Selector of `log(uint256)`.\\n            mstore(0x00, 0xf82c50f1)\\n            mstore(0x20, p0)\\n        }\\n        _sendLogPayload(0x1c, 0x24);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n        }\\n    }\\n\\n    function log(bytes32 p0) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(string)`.\\n            mstore(0x00, 0x41304fac)\\n            mstore(0x20, 0x20)\\n            writeString(0x40, p0)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(address p0, address p1) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            // Selector of `log(address,address)`.\\n            mstore(0x00, 0xdaf0d4aa)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n        }\\n        _sendLogPayload(0x1c, 0x44);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n        }\\n    }\\n\\n    function log(address p0, bool p1) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            // Selector of `log(address,bool)`.\\n            mstore(0x00, 0x75b605d3)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n        }\\n        _sendLogPayload(0x1c, 0x44);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n        }\\n    }\\n\\n    function log(address p0, uint256 p1) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            // Selector of `log(address,uint256)`.\\n            mstore(0x00, 0x8309e8a8)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n        }\\n        _sendLogPayload(0x1c, 0x44);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n        }\\n    }\\n\\n    function log(address p0, bytes32 p1) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,string)`.\\n            mstore(0x00, 0x759f86bb)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x40)\\n            writeString(0x60, p1)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, address p1) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            // Selector of `log(bool,address)`.\\n            mstore(0x00, 0x853c4849)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n        }\\n        _sendLogPayload(0x1c, 0x44);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n        }\\n    }\\n\\n    function log(bool p0, bool p1) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            // Selector of `log(bool,bool)`.\\n            mstore(0x00, 0x2a110e83)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n        }\\n        _sendLogPayload(0x1c, 0x44);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n        }\\n    }\\n\\n    function log(bool p0, uint256 p1) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            // Selector of `log(bool,uint256)`.\\n            mstore(0x00, 0x399174d3)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n        }\\n        _sendLogPayload(0x1c, 0x44);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n        }\\n    }\\n\\n    function log(bool p0, bytes32 p1) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,string)`.\\n            mstore(0x00, 0x8feac525)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x40)\\n            writeString(0x60, p1)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, address p1) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            // Selector of `log(uint256,address)`.\\n            mstore(0x00, 0x69276c86)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n        }\\n        _sendLogPayload(0x1c, 0x44);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n        }\\n    }\\n\\n    function log(uint256 p0, bool p1) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            // Selector of `log(uint256,bool)`.\\n            mstore(0x00, 0x1c9d7eb3)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n        }\\n        _sendLogPayload(0x1c, 0x44);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n        }\\n    }\\n\\n    function log(uint256 p0, uint256 p1) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            // Selector of `log(uint256,uint256)`.\\n            mstore(0x00, 0xf666715a)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n        }\\n        _sendLogPayload(0x1c, 0x44);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n        }\\n    }\\n\\n    function log(uint256 p0, bytes32 p1) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,string)`.\\n            mstore(0x00, 0x643fd0df)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x40)\\n            writeString(0x60, p1)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bytes32 p0, address p1) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(string,address)`.\\n            mstore(0x00, 0x319af333)\\n            mstore(0x20, 0x40)\\n            mstore(0x40, p1)\\n            writeString(0x60, p0)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bool p1) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(string,bool)`.\\n            mstore(0x00, 0xc3b55635)\\n            mstore(0x20, 0x40)\\n            mstore(0x40, p1)\\n            writeString(0x60, p0)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bytes32 p0, uint256 p1) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(string,uint256)`.\\n            mstore(0x00, 0xb60e72cc)\\n            mstore(0x20, 0x40)\\n            mstore(0x40, p1)\\n            writeString(0x60, p0)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bytes32 p1) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,string)`.\\n            mstore(0x00, 0x4b5c4277)\\n            mstore(0x20, 0x40)\\n            mstore(0x40, 0x80)\\n            writeString(0x60, p0)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, address p1, address p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(address,address,address)`.\\n            mstore(0x00, 0x018c84c2)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(address p0, address p1, bool p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(address,address,bool)`.\\n            mstore(0x00, 0xf2a66286)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(address p0, address p1, uint256 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(address,address,uint256)`.\\n            mstore(0x00, 0x17fe6185)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(address p0, address p1, bytes32 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            // Selector of `log(address,address,string)`.\\n            mstore(0x00, 0x007150be)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x60)\\n            writeString(0x80, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xa4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n        }\\n    }\\n\\n    function log(address p0, bool p1, address p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(address,bool,address)`.\\n            mstore(0x00, 0xf11699ed)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(address p0, bool p1, bool p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(address,bool,bool)`.\\n            mstore(0x00, 0xeb830c92)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(address,bool,uint256)`.\\n            mstore(0x00, 0x9c4f99fb)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(address p0, bool p1, bytes32 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            // Selector of `log(address,bool,string)`.\\n            mstore(0x00, 0x212255cc)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x60)\\n            writeString(0x80, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xa4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n        }\\n    }\\n\\n    function log(address p0, uint256 p1, address p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(address,uint256,address)`.\\n            mstore(0x00, 0x7bc0d848)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(address,uint256,bool)`.\\n            mstore(0x00, 0x678209a8)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(address,uint256,uint256)`.\\n            mstore(0x00, 0xb69bcaf6)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(address p0, uint256 p1, bytes32 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            // Selector of `log(address,uint256,string)`.\\n            mstore(0x00, 0xa1f2e8aa)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x60)\\n            writeString(0x80, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xa4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n        }\\n    }\\n\\n    function log(address p0, bytes32 p1, address p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            // Selector of `log(address,string,address)`.\\n            mstore(0x00, 0xf08744e8)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x60)\\n            mstore(0x60, p2)\\n            writeString(0x80, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xa4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n        }\\n    }\\n\\n    function log(address p0, bytes32 p1, bool p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            // Selector of `log(address,string,bool)`.\\n            mstore(0x00, 0xcf020fb1)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x60)\\n            mstore(0x60, p2)\\n            writeString(0x80, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xa4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n        }\\n    }\\n\\n    function log(address p0, bytes32 p1, uint256 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            // Selector of `log(address,string,uint256)`.\\n            mstore(0x00, 0x67dd6ff1)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x60)\\n            mstore(0x60, p2)\\n            writeString(0x80, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xa4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n        }\\n    }\\n\\n    function log(address p0, bytes32 p1, bytes32 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            // Selector of `log(address,string,string)`.\\n            mstore(0x00, 0xfb772265)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x60)\\n            mstore(0x60, 0xa0)\\n            writeString(0x80, p1)\\n            writeString(0xc0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xe4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n        }\\n    }\\n\\n    function log(bool p0, address p1, address p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(bool,address,address)`.\\n            mstore(0x00, 0xd2763667)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(bool p0, address p1, bool p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(bool,address,bool)`.\\n            mstore(0x00, 0x18c9c746)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(bool,address,uint256)`.\\n            mstore(0x00, 0x5f7b9afb)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(bool p0, address p1, bytes32 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            // Selector of `log(bool,address,string)`.\\n            mstore(0x00, 0xde9a9270)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x60)\\n            writeString(0x80, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xa4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n        }\\n    }\\n\\n    function log(bool p0, bool p1, address p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(bool,bool,address)`.\\n            mstore(0x00, 0x1078f68d)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(bool p0, bool p1, bool p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(bool,bool,bool)`.\\n            mstore(0x00, 0x50709698)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(bool,bool,uint256)`.\\n            mstore(0x00, 0x12f21602)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(bool p0, bool p1, bytes32 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            // Selector of `log(bool,bool,string)`.\\n            mstore(0x00, 0x2555fa46)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x60)\\n            writeString(0x80, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xa4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n        }\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(bool,uint256,address)`.\\n            mstore(0x00, 0x088ef9d2)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(bool,uint256,bool)`.\\n            mstore(0x00, 0xe8defba9)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(bool,uint256,uint256)`.\\n            mstore(0x00, 0x37103367)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(bool p0, uint256 p1, bytes32 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            // Selector of `log(bool,uint256,string)`.\\n            mstore(0x00, 0xc3fc3970)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x60)\\n            writeString(0x80, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xa4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n        }\\n    }\\n\\n    function log(bool p0, bytes32 p1, address p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            // Selector of `log(bool,string,address)`.\\n            mstore(0x00, 0x9591b953)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x60)\\n            mstore(0x60, p2)\\n            writeString(0x80, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xa4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n        }\\n    }\\n\\n    function log(bool p0, bytes32 p1, bool p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            // Selector of `log(bool,string,bool)`.\\n            mstore(0x00, 0xdbb4c247)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x60)\\n            mstore(0x60, p2)\\n            writeString(0x80, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xa4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n        }\\n    }\\n\\n    function log(bool p0, bytes32 p1, uint256 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            // Selector of `log(bool,string,uint256)`.\\n            mstore(0x00, 0x1093ee11)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x60)\\n            mstore(0x60, p2)\\n            writeString(0x80, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xa4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n        }\\n    }\\n\\n    function log(bool p0, bytes32 p1, bytes32 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            // Selector of `log(bool,string,string)`.\\n            mstore(0x00, 0xb076847f)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x60)\\n            mstore(0x60, 0xa0)\\n            writeString(0x80, p1)\\n            writeString(0xc0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xe4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n        }\\n    }\\n\\n    function log(uint256 p0, address p1, address p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(uint256,address,address)`.\\n            mstore(0x00, 0xbcfd9be0)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(uint256,address,bool)`.\\n            mstore(0x00, 0x9b6ec042)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(uint256,address,uint256)`.\\n            mstore(0x00, 0x5a9b5ed5)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(uint256 p0, address p1, bytes32 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            // Selector of `log(uint256,address,string)`.\\n            mstore(0x00, 0x63cb41f9)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x60)\\n            writeString(0x80, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xa4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n        }\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(uint256,bool,address)`.\\n            mstore(0x00, 0x35085f7b)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(uint256,bool,bool)`.\\n            mstore(0x00, 0x20718650)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(uint256,bool,uint256)`.\\n            mstore(0x00, 0x20098014)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(uint256 p0, bool p1, bytes32 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            // Selector of `log(uint256,bool,string)`.\\n            mstore(0x00, 0x85775021)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x60)\\n            writeString(0x80, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xa4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n        }\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(uint256,uint256,address)`.\\n            mstore(0x00, 0x5c96b331)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(uint256,uint256,bool)`.\\n            mstore(0x00, 0x4766da72)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(uint256,uint256,uint256)`.\\n            mstore(0x00, 0xd1ed7a3c)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bytes32 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            // Selector of `log(uint256,uint256,string)`.\\n            mstore(0x00, 0x71d04af2)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x60)\\n            writeString(0x80, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xa4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n        }\\n    }\\n\\n    function log(uint256 p0, bytes32 p1, address p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            // Selector of `log(uint256,string,address)`.\\n            mstore(0x00, 0x7afac959)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x60)\\n            mstore(0x60, p2)\\n            writeString(0x80, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xa4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n        }\\n    }\\n\\n    function log(uint256 p0, bytes32 p1, bool p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            // Selector of `log(uint256,string,bool)`.\\n            mstore(0x00, 0x4ceda75a)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x60)\\n            mstore(0x60, p2)\\n            writeString(0x80, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xa4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n        }\\n    }\\n\\n    function log(uint256 p0, bytes32 p1, uint256 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            // Selector of `log(uint256,string,uint256)`.\\n            mstore(0x00, 0x37aa7d4c)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x60)\\n            mstore(0x60, p2)\\n            writeString(0x80, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xa4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n        }\\n    }\\n\\n    function log(uint256 p0, bytes32 p1, bytes32 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            // Selector of `log(uint256,string,string)`.\\n            mstore(0x00, 0xb115611f)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x60)\\n            mstore(0x60, 0xa0)\\n            writeString(0x80, p1)\\n            writeString(0xc0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xe4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n        }\\n    }\\n\\n    function log(bytes32 p0, address p1, address p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            // Selector of `log(string,address,address)`.\\n            mstore(0x00, 0xfcec75e0)\\n            mstore(0x20, 0x60)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            writeString(0x80, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xa4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n        }\\n    }\\n\\n    function log(bytes32 p0, address p1, bool p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            // Selector of `log(string,address,bool)`.\\n            mstore(0x00, 0xc91d5ed4)\\n            mstore(0x20, 0x60)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            writeString(0x80, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xa4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n        }\\n    }\\n\\n    function log(bytes32 p0, address p1, uint256 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            // Selector of `log(string,address,uint256)`.\\n            mstore(0x00, 0x0d26b925)\\n            mstore(0x20, 0x60)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            writeString(0x80, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xa4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n        }\\n    }\\n\\n    function log(bytes32 p0, address p1, bytes32 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            // Selector of `log(string,address,string)`.\\n            mstore(0x00, 0xe0e9ad4f)\\n            mstore(0x20, 0x60)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0xa0)\\n            writeString(0x80, p0)\\n            writeString(0xc0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xe4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bool p1, address p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            // Selector of `log(string,bool,address)`.\\n            mstore(0x00, 0x932bbb38)\\n            mstore(0x20, 0x60)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            writeString(0x80, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xa4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bool p1, bool p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            // Selector of `log(string,bool,bool)`.\\n            mstore(0x00, 0x850b7ad6)\\n            mstore(0x20, 0x60)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            writeString(0x80, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xa4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bool p1, uint256 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            // Selector of `log(string,bool,uint256)`.\\n            mstore(0x00, 0xc95958d6)\\n            mstore(0x20, 0x60)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            writeString(0x80, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xa4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bool p1, bytes32 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            // Selector of `log(string,bool,string)`.\\n            mstore(0x00, 0xe298f47d)\\n            mstore(0x20, 0x60)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0xa0)\\n            writeString(0x80, p0)\\n            writeString(0xc0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xe4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n        }\\n    }\\n\\n    function log(bytes32 p0, uint256 p1, address p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            // Selector of `log(string,uint256,address)`.\\n            mstore(0x00, 0x1c7ec448)\\n            mstore(0x20, 0x60)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            writeString(0x80, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xa4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n        }\\n    }\\n\\n    function log(bytes32 p0, uint256 p1, bool p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            // Selector of `log(string,uint256,bool)`.\\n            mstore(0x00, 0xca7733b1)\\n            mstore(0x20, 0x60)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            writeString(0x80, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xa4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n        }\\n    }\\n\\n    function log(bytes32 p0, uint256 p1, uint256 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            // Selector of `log(string,uint256,uint256)`.\\n            mstore(0x00, 0xca47c4eb)\\n            mstore(0x20, 0x60)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            writeString(0x80, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xa4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n        }\\n    }\\n\\n    function log(bytes32 p0, uint256 p1, bytes32 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            // Selector of `log(string,uint256,string)`.\\n            mstore(0x00, 0x5970e089)\\n            mstore(0x20, 0x60)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0xa0)\\n            writeString(0x80, p0)\\n            writeString(0xc0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xe4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bytes32 p1, address p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            // Selector of `log(string,string,address)`.\\n            mstore(0x00, 0x95ed0195)\\n            mstore(0x20, 0x60)\\n            mstore(0x40, 0xa0)\\n            mstore(0x60, p2)\\n            writeString(0x80, p0)\\n            writeString(0xc0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xe4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bytes32 p1, bool p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            // Selector of `log(string,string,bool)`.\\n            mstore(0x00, 0xb0e0f9b5)\\n            mstore(0x20, 0x60)\\n            mstore(0x40, 0xa0)\\n            mstore(0x60, p2)\\n            writeString(0x80, p0)\\n            writeString(0xc0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xe4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bytes32 p1, uint256 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            // Selector of `log(string,string,uint256)`.\\n            mstore(0x00, 0x5821efa1)\\n            mstore(0x20, 0x60)\\n            mstore(0x40, 0xa0)\\n            mstore(0x60, p2)\\n            writeString(0x80, p0)\\n            writeString(0xc0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xe4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bytes32 p1, bytes32 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        bytes32 m9;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            m9 := mload(0x120)\\n            // Selector of `log(string,string,string)`.\\n            mstore(0x00, 0x2ced7cef)\\n            mstore(0x20, 0x60)\\n            mstore(0x40, 0xa0)\\n            mstore(0x60, 0xe0)\\n            writeString(0x80, p0)\\n            writeString(0xc0, p1)\\n            writeString(0x100, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x124);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n            mstore(0x120, m9)\\n        }\\n    }\\n\\n    function log(address p0, address p1, address p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,address,address,address)`.\\n            mstore(0x00, 0x665bf134)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(address p0, address p1, address p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,address,address,bool)`.\\n            mstore(0x00, 0x0e378994)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(address p0, address p1, address p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,address,address,uint256)`.\\n            mstore(0x00, 0x94250d77)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(address p0, address p1, address p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(address,address,address,string)`.\\n            mstore(0x00, 0xf808da20)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x80)\\n            writeString(0xa0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, address p1, bool p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,address,bool,address)`.\\n            mstore(0x00, 0x9f1bc36e)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(address p0, address p1, bool p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,address,bool,bool)`.\\n            mstore(0x00, 0x2cd4134a)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(address p0, address p1, bool p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,address,bool,uint256)`.\\n            mstore(0x00, 0x3971e78c)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(address p0, address p1, bool p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(address,address,bool,string)`.\\n            mstore(0x00, 0xaa6540c8)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x80)\\n            writeString(0xa0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,address,uint256,address)`.\\n            mstore(0x00, 0x8da6def5)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,address,uint256,bool)`.\\n            mstore(0x00, 0x9b4254e2)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,address,uint256,uint256)`.\\n            mstore(0x00, 0xbe553481)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(address,address,uint256,string)`.\\n            mstore(0x00, 0xfdb4f990)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x80)\\n            writeString(0xa0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, address p1, bytes32 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(address,address,string,address)`.\\n            mstore(0x00, 0x8f736d16)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, address p1, bytes32 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(address,address,string,bool)`.\\n            mstore(0x00, 0x6f1a594e)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, address p1, bytes32 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(address,address,string,uint256)`.\\n            mstore(0x00, 0xef1cefe7)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, address p1, bytes32 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(address,address,string,string)`.\\n            mstore(0x00, 0x21bdaf25)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, 0xc0)\\n            writeString(0xa0, p2)\\n            writeString(0xe0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(address p0, bool p1, address p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,bool,address,address)`.\\n            mstore(0x00, 0x660375dd)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(address p0, bool p1, address p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,bool,address,bool)`.\\n            mstore(0x00, 0xa6f50b0f)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(address p0, bool p1, address p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,bool,address,uint256)`.\\n            mstore(0x00, 0xa75c59de)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(address p0, bool p1, address p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(address,bool,address,string)`.\\n            mstore(0x00, 0x2dd778e6)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x80)\\n            writeString(0xa0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, bool p1, bool p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,bool,bool,address)`.\\n            mstore(0x00, 0xcf394485)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(address p0, bool p1, bool p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,bool,bool,bool)`.\\n            mstore(0x00, 0xcac43479)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(address p0, bool p1, bool p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,bool,bool,uint256)`.\\n            mstore(0x00, 0x8c4e5de6)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(address p0, bool p1, bool p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(address,bool,bool,string)`.\\n            mstore(0x00, 0xdfc4a2e8)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x80)\\n            writeString(0xa0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,bool,uint256,address)`.\\n            mstore(0x00, 0xccf790a1)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,bool,uint256,bool)`.\\n            mstore(0x00, 0xc4643e20)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,bool,uint256,uint256)`.\\n            mstore(0x00, 0x386ff5f4)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(address,bool,uint256,string)`.\\n            mstore(0x00, 0x0aa6cfad)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x80)\\n            writeString(0xa0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, bool p1, bytes32 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(address,bool,string,address)`.\\n            mstore(0x00, 0x19fd4956)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, bool p1, bytes32 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(address,bool,string,bool)`.\\n            mstore(0x00, 0x50ad461d)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, bool p1, bytes32 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(address,bool,string,uint256)`.\\n            mstore(0x00, 0x80e6a20b)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, bool p1, bytes32 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(address,bool,string,string)`.\\n            mstore(0x00, 0x475c5c33)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, 0xc0)\\n            writeString(0xa0, p2)\\n            writeString(0xe0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,uint256,address,address)`.\\n            mstore(0x00, 0x478d1c62)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,uint256,address,bool)`.\\n            mstore(0x00, 0xa1bcc9b3)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,uint256,address,uint256)`.\\n            mstore(0x00, 0x100f650e)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(address,uint256,address,string)`.\\n            mstore(0x00, 0x1da986ea)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x80)\\n            writeString(0xa0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,uint256,bool,address)`.\\n            mstore(0x00, 0xa31bfdcc)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,uint256,bool,bool)`.\\n            mstore(0x00, 0x3bf5e537)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,uint256,bool,uint256)`.\\n            mstore(0x00, 0x22f6b999)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(address,uint256,bool,string)`.\\n            mstore(0x00, 0xc5ad85f9)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x80)\\n            writeString(0xa0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,uint256,uint256,address)`.\\n            mstore(0x00, 0x20e3984d)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,uint256,uint256,bool)`.\\n            mstore(0x00, 0x66f1bc67)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,uint256,uint256,uint256)`.\\n            mstore(0x00, 0x34f0e636)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(address,uint256,uint256,string)`.\\n            mstore(0x00, 0x4a28c017)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x80)\\n            writeString(0xa0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, uint256 p1, bytes32 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(address,uint256,string,address)`.\\n            mstore(0x00, 0x5c430d47)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, uint256 p1, bytes32 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(address,uint256,string,bool)`.\\n            mstore(0x00, 0xcf18105c)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, uint256 p1, bytes32 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(address,uint256,string,uint256)`.\\n            mstore(0x00, 0xbf01f891)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, uint256 p1, bytes32 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(address,uint256,string,string)`.\\n            mstore(0x00, 0x88a8c406)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, 0xc0)\\n            writeString(0xa0, p2)\\n            writeString(0xe0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(address p0, bytes32 p1, address p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(address,string,address,address)`.\\n            mstore(0x00, 0x0d36fa20)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, bytes32 p1, address p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(address,string,address,bool)`.\\n            mstore(0x00, 0x0df12b76)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, bytes32 p1, address p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(address,string,address,uint256)`.\\n            mstore(0x00, 0x457fe3cf)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, bytes32 p1, address p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(address,string,address,string)`.\\n            mstore(0x00, 0xf7e36245)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0xc0)\\n            writeString(0xa0, p1)\\n            writeString(0xe0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(address p0, bytes32 p1, bool p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(address,string,bool,address)`.\\n            mstore(0x00, 0x205871c2)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, bytes32 p1, bool p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(address,string,bool,bool)`.\\n            mstore(0x00, 0x5f1d5c9f)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, bytes32 p1, bool p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(address,string,bool,uint256)`.\\n            mstore(0x00, 0x515e38b6)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, bytes32 p1, bool p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(address,string,bool,string)`.\\n            mstore(0x00, 0xbc0b61fe)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0xc0)\\n            writeString(0xa0, p1)\\n            writeString(0xe0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(address p0, bytes32 p1, uint256 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(address,string,uint256,address)`.\\n            mstore(0x00, 0x63183678)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, bytes32 p1, uint256 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(address,string,uint256,bool)`.\\n            mstore(0x00, 0x0ef7e050)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, bytes32 p1, uint256 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(address,string,uint256,uint256)`.\\n            mstore(0x00, 0x1dc8e1b8)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, bytes32 p1, uint256 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(address,string,uint256,string)`.\\n            mstore(0x00, 0x448830a8)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0xc0)\\n            writeString(0xa0, p1)\\n            writeString(0xe0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(address p0, bytes32 p1, bytes32 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(address,string,string,address)`.\\n            mstore(0x00, 0xa04e2f87)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, 0xc0)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n            writeString(0xe0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(address p0, bytes32 p1, bytes32 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(address,string,string,bool)`.\\n            mstore(0x00, 0x35a5071f)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, 0xc0)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n            writeString(0xe0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(address p0, bytes32 p1, bytes32 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(address,string,string,uint256)`.\\n            mstore(0x00, 0x159f8927)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, 0xc0)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n            writeString(0xe0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(address p0, bytes32 p1, bytes32 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        bytes32 m9;\\n        bytes32 m10;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            m9 := mload(0x120)\\n            m10 := mload(0x140)\\n            // Selector of `log(address,string,string,string)`.\\n            mstore(0x00, 0x5d02c50b)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, 0xc0)\\n            mstore(0x80, 0x100)\\n            writeString(0xa0, p1)\\n            writeString(0xe0, p2)\\n            writeString(0x120, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x144);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n            mstore(0x120, m9)\\n            mstore(0x140, m10)\\n        }\\n    }\\n\\n    function log(bool p0, address p1, address p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,address,address,address)`.\\n            mstore(0x00, 0x1d14d001)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, address p1, address p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,address,address,bool)`.\\n            mstore(0x00, 0x46600be0)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, address p1, address p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,address,address,uint256)`.\\n            mstore(0x00, 0x0c66d1be)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, address p1, address p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(bool,address,address,string)`.\\n            mstore(0x00, 0xd812a167)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x80)\\n            writeString(0xa0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bool p0, address p1, bool p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,address,bool,address)`.\\n            mstore(0x00, 0x1c41a336)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, address p1, bool p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,address,bool,bool)`.\\n            mstore(0x00, 0x6a9c478b)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, address p1, bool p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,address,bool,uint256)`.\\n            mstore(0x00, 0x07831502)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, address p1, bool p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(bool,address,bool,string)`.\\n            mstore(0x00, 0x4a66cb34)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x80)\\n            writeString(0xa0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,address,uint256,address)`.\\n            mstore(0x00, 0x136b05dd)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,address,uint256,bool)`.\\n            mstore(0x00, 0xd6019f1c)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,address,uint256,uint256)`.\\n            mstore(0x00, 0x7bf181a1)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(bool,address,uint256,string)`.\\n            mstore(0x00, 0x51f09ff8)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x80)\\n            writeString(0xa0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bool p0, address p1, bytes32 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(bool,address,string,address)`.\\n            mstore(0x00, 0x6f7c603e)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bool p0, address p1, bytes32 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(bool,address,string,bool)`.\\n            mstore(0x00, 0xe2bfd60b)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bool p0, address p1, bytes32 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(bool,address,string,uint256)`.\\n            mstore(0x00, 0xc21f64c7)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bool p0, address p1, bytes32 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(bool,address,string,string)`.\\n            mstore(0x00, 0xa73c1db6)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, 0xc0)\\n            writeString(0xa0, p2)\\n            writeString(0xe0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bool p0, bool p1, address p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,bool,address,address)`.\\n            mstore(0x00, 0xf4880ea4)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, bool p1, address p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,bool,address,bool)`.\\n            mstore(0x00, 0xc0a302d8)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, bool p1, address p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,bool,address,uint256)`.\\n            mstore(0x00, 0x4c123d57)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, bool p1, address p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(bool,bool,address,string)`.\\n            mstore(0x00, 0xa0a47963)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x80)\\n            writeString(0xa0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,bool,bool,address)`.\\n            mstore(0x00, 0x8c329b1a)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,bool,bool,bool)`.\\n            mstore(0x00, 0x3b2a5ce0)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,bool,bool,uint256)`.\\n            mstore(0x00, 0x6d7045c1)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(bool,bool,bool,string)`.\\n            mstore(0x00, 0x2ae408d4)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x80)\\n            writeString(0xa0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,bool,uint256,address)`.\\n            mstore(0x00, 0x54a7a9a0)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,bool,uint256,bool)`.\\n            mstore(0x00, 0x619e4d0e)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,bool,uint256,uint256)`.\\n            mstore(0x00, 0x0bb00eab)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(bool,bool,uint256,string)`.\\n            mstore(0x00, 0x7dd4d0e0)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x80)\\n            writeString(0xa0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bool p0, bool p1, bytes32 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(bool,bool,string,address)`.\\n            mstore(0x00, 0xf9ad2b89)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bool p0, bool p1, bytes32 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(bool,bool,string,bool)`.\\n            mstore(0x00, 0xb857163a)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bool p0, bool p1, bytes32 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(bool,bool,string,uint256)`.\\n            mstore(0x00, 0xe3a9ca2f)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bool p0, bool p1, bytes32 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(bool,bool,string,string)`.\\n            mstore(0x00, 0x6d1e8751)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, 0xc0)\\n            writeString(0xa0, p2)\\n            writeString(0xe0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,uint256,address,address)`.\\n            mstore(0x00, 0x26f560a8)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,uint256,address,bool)`.\\n            mstore(0x00, 0xb4c314ff)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,uint256,address,uint256)`.\\n            mstore(0x00, 0x1537dc87)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(bool,uint256,address,string)`.\\n            mstore(0x00, 0x1bb3b09a)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x80)\\n            writeString(0xa0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,uint256,bool,address)`.\\n            mstore(0x00, 0x9acd3616)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,uint256,bool,bool)`.\\n            mstore(0x00, 0xceb5f4d7)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,uint256,bool,uint256)`.\\n            mstore(0x00, 0x7f9bbca2)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(bool,uint256,bool,string)`.\\n            mstore(0x00, 0x9143dbb1)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x80)\\n            writeString(0xa0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,uint256,uint256,address)`.\\n            mstore(0x00, 0x00dd87b9)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,uint256,uint256,bool)`.\\n            mstore(0x00, 0xbe984353)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,uint256,uint256,uint256)`.\\n            mstore(0x00, 0x374bb4b2)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(bool,uint256,uint256,string)`.\\n            mstore(0x00, 0x8e69fb5d)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x80)\\n            writeString(0xa0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bool p0, uint256 p1, bytes32 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(bool,uint256,string,address)`.\\n            mstore(0x00, 0xfedd1fff)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bool p0, uint256 p1, bytes32 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(bool,uint256,string,bool)`.\\n            mstore(0x00, 0xe5e70b2b)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bool p0, uint256 p1, bytes32 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(bool,uint256,string,uint256)`.\\n            mstore(0x00, 0x6a1199e2)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bool p0, uint256 p1, bytes32 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(bool,uint256,string,string)`.\\n            mstore(0x00, 0xf5bc2249)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, 0xc0)\\n            writeString(0xa0, p2)\\n            writeString(0xe0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bool p0, bytes32 p1, address p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(bool,string,address,address)`.\\n            mstore(0x00, 0x2b2b18dc)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bool p0, bytes32 p1, address p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(bool,string,address,bool)`.\\n            mstore(0x00, 0x6dd434ca)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bool p0, bytes32 p1, address p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(bool,string,address,uint256)`.\\n            mstore(0x00, 0xa5cada94)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bool p0, bytes32 p1, address p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(bool,string,address,string)`.\\n            mstore(0x00, 0x12d6c788)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0xc0)\\n            writeString(0xa0, p1)\\n            writeString(0xe0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bool p0, bytes32 p1, bool p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(bool,string,bool,address)`.\\n            mstore(0x00, 0x538e06ab)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bool p0, bytes32 p1, bool p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(bool,string,bool,bool)`.\\n            mstore(0x00, 0xdc5e935b)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bool p0, bytes32 p1, bool p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(bool,string,bool,uint256)`.\\n            mstore(0x00, 0x1606a393)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bool p0, bytes32 p1, bool p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(bool,string,bool,string)`.\\n            mstore(0x00, 0x483d0416)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0xc0)\\n            writeString(0xa0, p1)\\n            writeString(0xe0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bool p0, bytes32 p1, uint256 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(bool,string,uint256,address)`.\\n            mstore(0x00, 0x1596a1ce)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bool p0, bytes32 p1, uint256 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(bool,string,uint256,bool)`.\\n            mstore(0x00, 0x6b0e5d53)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bool p0, bytes32 p1, uint256 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(bool,string,uint256,uint256)`.\\n            mstore(0x00, 0x28863fcb)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bool p0, bytes32 p1, uint256 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(bool,string,uint256,string)`.\\n            mstore(0x00, 0x1ad96de6)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0xc0)\\n            writeString(0xa0, p1)\\n            writeString(0xe0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bool p0, bytes32 p1, bytes32 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(bool,string,string,address)`.\\n            mstore(0x00, 0x97d394d8)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, 0xc0)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n            writeString(0xe0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bool p0, bytes32 p1, bytes32 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(bool,string,string,bool)`.\\n            mstore(0x00, 0x1e4b87e5)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, 0xc0)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n            writeString(0xe0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bool p0, bytes32 p1, bytes32 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(bool,string,string,uint256)`.\\n            mstore(0x00, 0x7be0c3eb)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, 0xc0)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n            writeString(0xe0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bool p0, bytes32 p1, bytes32 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        bytes32 m9;\\n        bytes32 m10;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            m9 := mload(0x120)\\n            m10 := mload(0x140)\\n            // Selector of `log(bool,string,string,string)`.\\n            mstore(0x00, 0x1762e32a)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, 0xc0)\\n            mstore(0x80, 0x100)\\n            writeString(0xa0, p1)\\n            writeString(0xe0, p2)\\n            writeString(0x120, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x144);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n            mstore(0x120, m9)\\n            mstore(0x140, m10)\\n        }\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,address,address,address)`.\\n            mstore(0x00, 0x2488b414)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,address,address,bool)`.\\n            mstore(0x00, 0x091ffaf5)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,address,address,uint256)`.\\n            mstore(0x00, 0x736efbb6)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(uint256,address,address,string)`.\\n            mstore(0x00, 0x031c6f73)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x80)\\n            writeString(0xa0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,address,bool,address)`.\\n            mstore(0x00, 0xef72c513)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,address,bool,bool)`.\\n            mstore(0x00, 0xe351140f)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,address,bool,uint256)`.\\n            mstore(0x00, 0x5abd992a)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(uint256,address,bool,string)`.\\n            mstore(0x00, 0x90fb06aa)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x80)\\n            writeString(0xa0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,address,uint256,address)`.\\n            mstore(0x00, 0x15c127b5)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,address,uint256,bool)`.\\n            mstore(0x00, 0x5f743a7c)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,address,uint256,uint256)`.\\n            mstore(0x00, 0x0c9cd9c1)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(uint256,address,uint256,string)`.\\n            mstore(0x00, 0xddb06521)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x80)\\n            writeString(0xa0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(uint256 p0, address p1, bytes32 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(uint256,address,string,address)`.\\n            mstore(0x00, 0x9cba8fff)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(uint256 p0, address p1, bytes32 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(uint256,address,string,bool)`.\\n            mstore(0x00, 0xcc32ab07)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(uint256 p0, address p1, bytes32 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(uint256,address,string,uint256)`.\\n            mstore(0x00, 0x46826b5d)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(uint256 p0, address p1, bytes32 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(uint256,address,string,string)`.\\n            mstore(0x00, 0x3e128ca3)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, 0xc0)\\n            writeString(0xa0, p2)\\n            writeString(0xe0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,bool,address,address)`.\\n            mstore(0x00, 0xa1ef4cbb)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,bool,address,bool)`.\\n            mstore(0x00, 0x454d54a5)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,bool,address,uint256)`.\\n            mstore(0x00, 0x078287f5)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(uint256,bool,address,string)`.\\n            mstore(0x00, 0xade052c7)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x80)\\n            writeString(0xa0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,bool,bool,address)`.\\n            mstore(0x00, 0x69640b59)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,bool,bool,bool)`.\\n            mstore(0x00, 0xb6f577a1)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,bool,bool,uint256)`.\\n            mstore(0x00, 0x7464ce23)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(uint256,bool,bool,string)`.\\n            mstore(0x00, 0xdddb9561)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x80)\\n            writeString(0xa0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,bool,uint256,address)`.\\n            mstore(0x00, 0x88cb6041)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,bool,uint256,bool)`.\\n            mstore(0x00, 0x91a02e2a)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,bool,uint256,uint256)`.\\n            mstore(0x00, 0xc6acc7a8)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(uint256,bool,uint256,string)`.\\n            mstore(0x00, 0xde03e774)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x80)\\n            writeString(0xa0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(uint256 p0, bool p1, bytes32 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(uint256,bool,string,address)`.\\n            mstore(0x00, 0xef529018)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(uint256 p0, bool p1, bytes32 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(uint256,bool,string,bool)`.\\n            mstore(0x00, 0xeb928d7f)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(uint256 p0, bool p1, bytes32 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(uint256,bool,string,uint256)`.\\n            mstore(0x00, 0x2c1d0746)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(uint256 p0, bool p1, bytes32 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(uint256,bool,string,string)`.\\n            mstore(0x00, 0x68c8b8bd)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, 0xc0)\\n            writeString(0xa0, p2)\\n            writeString(0xe0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,uint256,address,address)`.\\n            mstore(0x00, 0x56a5d1b1)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,uint256,address,bool)`.\\n            mstore(0x00, 0x15cac476)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,uint256,address,uint256)`.\\n            mstore(0x00, 0x88f6e4b2)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(uint256,uint256,address,string)`.\\n            mstore(0x00, 0x6cde40b8)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x80)\\n            writeString(0xa0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,uint256,bool,address)`.\\n            mstore(0x00, 0x9a816a83)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,uint256,bool,bool)`.\\n            mstore(0x00, 0xab085ae6)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,uint256,bool,uint256)`.\\n            mstore(0x00, 0xeb7f6fd2)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(uint256,uint256,bool,string)`.\\n            mstore(0x00, 0xa5b4fc99)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x80)\\n            writeString(0xa0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,uint256,uint256,address)`.\\n            mstore(0x00, 0xfa8185af)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,uint256,uint256,bool)`.\\n            mstore(0x00, 0xc598d185)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,uint256,uint256,uint256)`.\\n            mstore(0x00, 0x193fb800)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(uint256,uint256,uint256,string)`.\\n            mstore(0x00, 0x59cfcbe3)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x80)\\n            writeString(0xa0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bytes32 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(uint256,uint256,string,address)`.\\n            mstore(0x00, 0x42d21db7)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bytes32 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(uint256,uint256,string,bool)`.\\n            mstore(0x00, 0x7af6ab25)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bytes32 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(uint256,uint256,string,uint256)`.\\n            mstore(0x00, 0x5da297eb)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bytes32 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(uint256,uint256,string,string)`.\\n            mstore(0x00, 0x27d8afd2)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, 0xc0)\\n            writeString(0xa0, p2)\\n            writeString(0xe0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(uint256 p0, bytes32 p1, address p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(uint256,string,address,address)`.\\n            mstore(0x00, 0x6168ed61)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(uint256 p0, bytes32 p1, address p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(uint256,string,address,bool)`.\\n            mstore(0x00, 0x90c30a56)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(uint256 p0, bytes32 p1, address p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(uint256,string,address,uint256)`.\\n            mstore(0x00, 0xe8d3018d)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(uint256 p0, bytes32 p1, address p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(uint256,string,address,string)`.\\n            mstore(0x00, 0x9c3adfa1)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0xc0)\\n            writeString(0xa0, p1)\\n            writeString(0xe0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(uint256 p0, bytes32 p1, bool p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(uint256,string,bool,address)`.\\n            mstore(0x00, 0xae2ec581)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(uint256 p0, bytes32 p1, bool p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(uint256,string,bool,bool)`.\\n            mstore(0x00, 0xba535d9c)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(uint256 p0, bytes32 p1, bool p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(uint256,string,bool,uint256)`.\\n            mstore(0x00, 0xcf009880)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(uint256 p0, bytes32 p1, bool p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(uint256,string,bool,string)`.\\n            mstore(0x00, 0xd2d423cd)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0xc0)\\n            writeString(0xa0, p1)\\n            writeString(0xe0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(uint256 p0, bytes32 p1, uint256 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(uint256,string,uint256,address)`.\\n            mstore(0x00, 0x3b2279b4)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(uint256 p0, bytes32 p1, uint256 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(uint256,string,uint256,bool)`.\\n            mstore(0x00, 0x691a8f74)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(uint256 p0, bytes32 p1, uint256 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(uint256,string,uint256,uint256)`.\\n            mstore(0x00, 0x82c25b74)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(uint256 p0, bytes32 p1, uint256 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(uint256,string,uint256,string)`.\\n            mstore(0x00, 0xb7b914ca)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0xc0)\\n            writeString(0xa0, p1)\\n            writeString(0xe0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(uint256 p0, bytes32 p1, bytes32 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(uint256,string,string,address)`.\\n            mstore(0x00, 0xd583c602)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, 0xc0)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n            writeString(0xe0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(uint256 p0, bytes32 p1, bytes32 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(uint256,string,string,bool)`.\\n            mstore(0x00, 0xb3a6b6bd)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, 0xc0)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n            writeString(0xe0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(uint256 p0, bytes32 p1, bytes32 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(uint256,string,string,uint256)`.\\n            mstore(0x00, 0xb028c9bd)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, 0xc0)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n            writeString(0xe0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(uint256 p0, bytes32 p1, bytes32 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        bytes32 m9;\\n        bytes32 m10;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            m9 := mload(0x120)\\n            m10 := mload(0x140)\\n            // Selector of `log(uint256,string,string,string)`.\\n            mstore(0x00, 0x21ad0683)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, 0xc0)\\n            mstore(0x80, 0x100)\\n            writeString(0xa0, p1)\\n            writeString(0xe0, p2)\\n            writeString(0x120, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x144);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n            mstore(0x120, m9)\\n            mstore(0x140, m10)\\n        }\\n    }\\n\\n    function log(bytes32 p0, address p1, address p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,address,address,address)`.\\n            mstore(0x00, 0xed8f28f6)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bytes32 p0, address p1, address p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,address,address,bool)`.\\n            mstore(0x00, 0xb59dbd60)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bytes32 p0, address p1, address p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,address,address,uint256)`.\\n            mstore(0x00, 0x8ef3f399)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bytes32 p0, address p1, address p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(string,address,address,string)`.\\n            mstore(0x00, 0x800a1c67)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0xc0)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bytes32 p0, address p1, bool p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,address,bool,address)`.\\n            mstore(0x00, 0x223603bd)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bytes32 p0, address p1, bool p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,address,bool,bool)`.\\n            mstore(0x00, 0x79884c2b)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bytes32 p0, address p1, bool p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,address,bool,uint256)`.\\n            mstore(0x00, 0x3e9f866a)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bytes32 p0, address p1, bool p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(string,address,bool,string)`.\\n            mstore(0x00, 0x0454c079)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0xc0)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bytes32 p0, address p1, uint256 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,address,uint256,address)`.\\n            mstore(0x00, 0x63fb8bc5)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bytes32 p0, address p1, uint256 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,address,uint256,bool)`.\\n            mstore(0x00, 0xfc4845f0)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bytes32 p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,address,uint256,uint256)`.\\n            mstore(0x00, 0xf8f51b1e)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bytes32 p0, address p1, uint256 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(string,address,uint256,string)`.\\n            mstore(0x00, 0x5a477632)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0xc0)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bytes32 p0, address p1, bytes32 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(string,address,string,address)`.\\n            mstore(0x00, 0xaabc9a31)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0xc0)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bytes32 p0, address p1, bytes32 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(string,address,string,bool)`.\\n            mstore(0x00, 0x5f15d28c)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0xc0)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bytes32 p0, address p1, bytes32 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(string,address,string,uint256)`.\\n            mstore(0x00, 0x91d1112e)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0xc0)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bytes32 p0, address p1, bytes32 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        bytes32 m9;\\n        bytes32 m10;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            m9 := mload(0x120)\\n            m10 := mload(0x140)\\n            // Selector of `log(string,address,string,string)`.\\n            mstore(0x00, 0x245986f2)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0xc0)\\n            mstore(0x80, 0x100)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p2)\\n            writeString(0x120, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x144);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n            mstore(0x120, m9)\\n            mstore(0x140, m10)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bool p1, address p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,bool,address,address)`.\\n            mstore(0x00, 0x33e9dd1d)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bool p1, address p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,bool,address,bool)`.\\n            mstore(0x00, 0x958c28c6)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bool p1, address p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,bool,address,uint256)`.\\n            mstore(0x00, 0x5d08bb05)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bool p1, address p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(string,bool,address,string)`.\\n            mstore(0x00, 0x2d8e33a4)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0xc0)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bool p1, bool p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,bool,bool,address)`.\\n            mstore(0x00, 0x7190a529)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bool p1, bool p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,bool,bool,bool)`.\\n            mstore(0x00, 0x895af8c5)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bool p1, bool p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,bool,bool,uint256)`.\\n            mstore(0x00, 0x8e3f78a9)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bool p1, bool p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(string,bool,bool,string)`.\\n            mstore(0x00, 0x9d22d5dd)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0xc0)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bool p1, uint256 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,bool,uint256,address)`.\\n            mstore(0x00, 0x935e09bf)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bool p1, uint256 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,bool,uint256,bool)`.\\n            mstore(0x00, 0x8af7cf8a)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,bool,uint256,uint256)`.\\n            mstore(0x00, 0x64b5bb67)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bool p1, uint256 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(string,bool,uint256,string)`.\\n            mstore(0x00, 0x742d6ee7)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0xc0)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bool p1, bytes32 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(string,bool,string,address)`.\\n            mstore(0x00, 0xe0625b29)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0xc0)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bool p1, bytes32 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(string,bool,string,bool)`.\\n            mstore(0x00, 0x3f8a701d)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0xc0)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bool p1, bytes32 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(string,bool,string,uint256)`.\\n            mstore(0x00, 0x24f91465)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0xc0)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bool p1, bytes32 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        bytes32 m9;\\n        bytes32 m10;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            m9 := mload(0x120)\\n            m10 := mload(0x140)\\n            // Selector of `log(string,bool,string,string)`.\\n            mstore(0x00, 0xa826caeb)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0xc0)\\n            mstore(0x80, 0x100)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p2)\\n            writeString(0x120, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x144);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n            mstore(0x120, m9)\\n            mstore(0x140, m10)\\n        }\\n    }\\n\\n    function log(bytes32 p0, uint256 p1, address p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,uint256,address,address)`.\\n            mstore(0x00, 0x5ea2b7ae)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bytes32 p0, uint256 p1, address p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,uint256,address,bool)`.\\n            mstore(0x00, 0x82112a42)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bytes32 p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,uint256,address,uint256)`.\\n            mstore(0x00, 0x4f04fdc6)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bytes32 p0, uint256 p1, address p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(string,uint256,address,string)`.\\n            mstore(0x00, 0x9ffb2f93)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0xc0)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bytes32 p0, uint256 p1, bool p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,uint256,bool,address)`.\\n            mstore(0x00, 0xe0e95b98)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bytes32 p0, uint256 p1, bool p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,uint256,bool,bool)`.\\n            mstore(0x00, 0x354c36d6)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bytes32 p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,uint256,bool,uint256)`.\\n            mstore(0x00, 0xe41b6f6f)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bytes32 p0, uint256 p1, bool p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(string,uint256,bool,string)`.\\n            mstore(0x00, 0xabf73a98)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0xc0)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bytes32 p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,uint256,uint256,address)`.\\n            mstore(0x00, 0xe21de278)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bytes32 p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,uint256,uint256,bool)`.\\n            mstore(0x00, 0x7626db92)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bytes32 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,uint256,uint256,uint256)`.\\n            mstore(0x00, 0xa7a87853)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bytes32 p0, uint256 p1, uint256 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(string,uint256,uint256,string)`.\\n            mstore(0x00, 0x854b3496)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0xc0)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bytes32 p0, uint256 p1, bytes32 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(string,uint256,string,address)`.\\n            mstore(0x00, 0x7c4632a4)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0xc0)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bytes32 p0, uint256 p1, bytes32 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(string,uint256,string,bool)`.\\n            mstore(0x00, 0x7d24491d)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0xc0)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bytes32 p0, uint256 p1, bytes32 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(string,uint256,string,uint256)`.\\n            mstore(0x00, 0xc67ea9d1)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0xc0)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bytes32 p0, uint256 p1, bytes32 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        bytes32 m9;\\n        bytes32 m10;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            m9 := mload(0x120)\\n            m10 := mload(0x140)\\n            // Selector of `log(string,uint256,string,string)`.\\n            mstore(0x00, 0x5ab84e1f)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0xc0)\\n            mstore(0x80, 0x100)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p2)\\n            writeString(0x120, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x144);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n            mstore(0x120, m9)\\n            mstore(0x140, m10)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bytes32 p1, address p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(string,string,address,address)`.\\n            mstore(0x00, 0x439c7bef)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, 0xc0)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bytes32 p1, address p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(string,string,address,bool)`.\\n            mstore(0x00, 0x5ccd4e37)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, 0xc0)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bytes32 p1, address p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(string,string,address,uint256)`.\\n            mstore(0x00, 0x7cc3c607)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, 0xc0)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bytes32 p1, address p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        bytes32 m9;\\n        bytes32 m10;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            m9 := mload(0x120)\\n            m10 := mload(0x140)\\n            // Selector of `log(string,string,address,string)`.\\n            mstore(0x00, 0xeb1bff80)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, 0xc0)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x100)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p1)\\n            writeString(0x120, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x144);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n            mstore(0x120, m9)\\n            mstore(0x140, m10)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bytes32 p1, bool p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(string,string,bool,address)`.\\n            mstore(0x00, 0xc371c7db)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, 0xc0)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bytes32 p1, bool p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(string,string,bool,bool)`.\\n            mstore(0x00, 0x40785869)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, 0xc0)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bytes32 p1, bool p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(string,string,bool,uint256)`.\\n            mstore(0x00, 0xd6aefad2)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, 0xc0)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bytes32 p1, bool p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        bytes32 m9;\\n        bytes32 m10;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            m9 := mload(0x120)\\n            m10 := mload(0x140)\\n            // Selector of `log(string,string,bool,string)`.\\n            mstore(0x00, 0x5e84b0ea)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, 0xc0)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x100)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p1)\\n            writeString(0x120, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x144);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n            mstore(0x120, m9)\\n            mstore(0x140, m10)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bytes32 p1, uint256 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(string,string,uint256,address)`.\\n            mstore(0x00, 0x1023f7b2)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, 0xc0)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bytes32 p1, uint256 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(string,string,uint256,bool)`.\\n            mstore(0x00, 0xc3a8a654)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, 0xc0)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bytes32 p1, uint256 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(string,string,uint256,uint256)`.\\n            mstore(0x00, 0xf45d7d2c)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, 0xc0)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bytes32 p1, uint256 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        bytes32 m9;\\n        bytes32 m10;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            m9 := mload(0x120)\\n            m10 := mload(0x140)\\n            // Selector of `log(string,string,uint256,string)`.\\n            mstore(0x00, 0x5d1a971a)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, 0xc0)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x100)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p1)\\n            writeString(0x120, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x144);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n            mstore(0x120, m9)\\n            mstore(0x140, m10)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bytes32 p1, bytes32 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        bytes32 m9;\\n        bytes32 m10;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            m9 := mload(0x120)\\n            m10 := mload(0x140)\\n            // Selector of `log(string,string,string,address)`.\\n            mstore(0x00, 0x6d572f44)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, 0xc0)\\n            mstore(0x60, 0x100)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p1)\\n            writeString(0x120, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x144);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n            mstore(0x120, m9)\\n            mstore(0x140, m10)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bytes32 p1, bytes32 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        bytes32 m9;\\n        bytes32 m10;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            m9 := mload(0x120)\\n            m10 := mload(0x140)\\n            // Selector of `log(string,string,string,bool)`.\\n            mstore(0x00, 0x2c1754ed)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, 0xc0)\\n            mstore(0x60, 0x100)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p1)\\n            writeString(0x120, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x144);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n            mstore(0x120, m9)\\n            mstore(0x140, m10)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bytes32 p1, bytes32 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        bytes32 m9;\\n        bytes32 m10;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            m9 := mload(0x120)\\n            m10 := mload(0x140)\\n            // Selector of `log(string,string,string,uint256)`.\\n            mstore(0x00, 0x8eafb02b)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, 0xc0)\\n            mstore(0x60, 0x100)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p1)\\n            writeString(0x120, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x144);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n            mstore(0x120, m9)\\n            mstore(0x140, m10)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bytes32 p1, bytes32 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        bytes32 m9;\\n        bytes32 m10;\\n        bytes32 m11;\\n        bytes32 m12;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            m9 := mload(0x120)\\n            m10 := mload(0x140)\\n            m11 := mload(0x160)\\n            m12 := mload(0x180)\\n            // Selector of `log(string,string,string,string)`.\\n            mstore(0x00, 0xde68f20a)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, 0xc0)\\n            mstore(0x60, 0x100)\\n            mstore(0x80, 0x140)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p1)\\n            writeString(0x120, p2)\\n            writeString(0x160, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x184);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n            mstore(0x120, m9)\\n            mstore(0x140, m10)\\n            mstore(0x160, m11)\\n            mstore(0x180, m12)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"../../node_modules/forge-std/src/StdChains.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.2 <0.9.0;\\n\\nimport {VmSafe} from \\\"./Vm.sol\\\";\\n\\n/**\\n * StdChains provides information about EVM compatible chains that can be used in scripts/tests.\\n * For each chain, the chain's name, chain ID, and a default RPC URL are provided. Chains are\\n * identified by their alias, which is the same as the alias in the `[rpc_endpoints]` section of\\n * the `foundry.toml` file. For best UX, ensure the alias in the `foundry.toml` file match the\\n * alias used in this contract, which can be found as the first argument to the\\n * `setChainWithDefaultRpcUrl` call in the `initializeStdChains` function.\\n *\\n * There are two main ways to use this contract:\\n *   1. Set a chain with `setChain(string memory chainAlias, ChainData memory chain)` or\\n *      `setChain(string memory chainAlias, Chain memory chain)`\\n *   2. Get a chain with `getChain(string memory chainAlias)` or `getChain(uint256 chainId)`.\\n *\\n * The first time either of those are used, chains are initialized with the default set of RPC URLs.\\n * This is done in `initializeStdChains`, which uses `setChainWithDefaultRpcUrl`. Defaults are recorded in\\n * `defaultRpcUrls`.\\n *\\n * The `setChain` function is straightforward, and it simply saves off the given chain data.\\n *\\n * The `getChain` methods use `getChainWithUpdatedRpcUrl` to return a chain. For example, let's say\\n * we want to retrieve the RPC URL for `mainnet`:\\n *   - If you have specified data with `setChain`, it will return that.\\n *   - If you have configured a mainnet RPC URL in `foundry.toml`, it will return the URL, provided it\\n *     is valid (e.g. a URL is specified, or an environment variable is given and exists).\\n *   - If neither of the above conditions is met, the default data is returned.\\n *\\n * Summarizing the above, the prioritization hierarchy is `setChain` -> `foundry.toml` -> environment variable -> defaults.\\n */\\nabstract contract StdChains {\\n    VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(\\\"hevm cheat code\\\")))));\\n\\n    bool private stdChainsInitialized;\\n\\n    struct ChainData {\\n        string name;\\n        uint256 chainId;\\n        string rpcUrl;\\n    }\\n\\n    struct Chain {\\n        // The chain name.\\n        string name;\\n        // The chain's Chain ID.\\n        uint256 chainId;\\n        // The chain's alias. (i.e. what gets specified in `foundry.toml`).\\n        string chainAlias;\\n        // A default RPC endpoint for this chain.\\n        // NOTE: This default RPC URL is included for convenience to facilitate quick tests and\\n        // experimentation. Do not use this RPC URL for production test suites, CI, or other heavy\\n        // usage as you will be throttled and this is a disservice to others who need this endpoint.\\n        string rpcUrl;\\n    }\\n\\n    // Maps from the chain's alias (matching the alias in the `foundry.toml` file) to chain data.\\n    mapping(string => Chain) private chains;\\n    // Maps from the chain's alias to it's default RPC URL.\\n    mapping(string => string) private defaultRpcUrls;\\n    // Maps from a chain ID to it's alias.\\n    mapping(uint256 => string) private idToAlias;\\n\\n    bool private fallbackToDefaultRpcUrls = true;\\n\\n    // The RPC URL will be fetched from config or defaultRpcUrls if possible.\\n    function getChain(string memory chainAlias) internal virtual returns (Chain memory chain) {\\n        require(bytes(chainAlias).length != 0, \\\"StdChains getChain(string): Chain alias cannot be the empty string.\\\");\\n\\n        initializeStdChains();\\n        chain = chains[chainAlias];\\n        require(\\n            chain.chainId != 0,\\n            string(abi.encodePacked(\\\"StdChains getChain(string): Chain with alias \\\\\\\"\\\", chainAlias, \\\"\\\\\\\" not found.\\\"))\\n        );\\n\\n        chain = getChainWithUpdatedRpcUrl(chainAlias, chain);\\n    }\\n\\n    function getChain(uint256 chainId) internal virtual returns (Chain memory chain) {\\n        require(chainId != 0, \\\"StdChains getChain(uint256): Chain ID cannot be 0.\\\");\\n        initializeStdChains();\\n        string memory chainAlias = idToAlias[chainId];\\n\\n        chain = chains[chainAlias];\\n\\n        require(\\n            chain.chainId != 0,\\n            string(abi.encodePacked(\\\"StdChains getChain(uint256): Chain with ID \\\", vm.toString(chainId), \\\" not found.\\\"))\\n        );\\n\\n        chain = getChainWithUpdatedRpcUrl(chainAlias, chain);\\n    }\\n\\n    // set chain info, with priority to argument's rpcUrl field.\\n    function setChain(string memory chainAlias, ChainData memory chain) internal virtual {\\n        require(\\n            bytes(chainAlias).length != 0,\\n            \\\"StdChains setChain(string,ChainData): Chain alias cannot be the empty string.\\\"\\n        );\\n\\n        require(chain.chainId != 0, \\\"StdChains setChain(string,ChainData): Chain ID cannot be 0.\\\");\\n\\n        initializeStdChains();\\n        string memory foundAlias = idToAlias[chain.chainId];\\n\\n        require(\\n            bytes(foundAlias).length == 0 || keccak256(bytes(foundAlias)) == keccak256(bytes(chainAlias)),\\n            string(\\n                abi.encodePacked(\\n                    \\\"StdChains setChain(string,ChainData): Chain ID \\\",\\n                    vm.toString(chain.chainId),\\n                    \\\" already used by \\\\\\\"\\\",\\n                    foundAlias,\\n                    \\\"\\\\\\\".\\\"\\n                )\\n            )\\n        );\\n\\n        uint256 oldChainId = chains[chainAlias].chainId;\\n        delete idToAlias[oldChainId];\\n\\n        chains[chainAlias] =\\n            Chain({name: chain.name, chainId: chain.chainId, chainAlias: chainAlias, rpcUrl: chain.rpcUrl});\\n        idToAlias[chain.chainId] = chainAlias;\\n    }\\n\\n    // set chain info, with priority to argument's rpcUrl field.\\n    function setChain(string memory chainAlias, Chain memory chain) internal virtual {\\n        setChain(chainAlias, ChainData({name: chain.name, chainId: chain.chainId, rpcUrl: chain.rpcUrl}));\\n    }\\n\\n    function _toUpper(string memory str) private pure returns (string memory) {\\n        bytes memory strb = bytes(str);\\n        bytes memory copy = new bytes(strb.length);\\n        for (uint256 i = 0; i < strb.length; i++) {\\n            bytes1 b = strb[i];\\n            if (b >= 0x61 && b <= 0x7A) {\\n                copy[i] = bytes1(uint8(b) - 32);\\n            } else {\\n                copy[i] = b;\\n            }\\n        }\\n        return string(copy);\\n    }\\n\\n    // lookup rpcUrl, in descending order of priority:\\n    // current -> config (foundry.toml) -> environment variable -> default\\n    function getChainWithUpdatedRpcUrl(string memory chainAlias, Chain memory chain) private returns (Chain memory) {\\n        if (bytes(chain.rpcUrl).length == 0) {\\n            try vm.rpcUrl(chainAlias) returns (string memory configRpcUrl) {\\n                chain.rpcUrl = configRpcUrl;\\n            } catch (bytes memory err) {\\n                string memory envName = string(abi.encodePacked(_toUpper(chainAlias), \\\"_RPC_URL\\\"));\\n                if (fallbackToDefaultRpcUrls) {\\n                    chain.rpcUrl = vm.envOr(envName, defaultRpcUrls[chainAlias]);\\n                } else {\\n                    chain.rpcUrl = vm.envString(envName);\\n                }\\n                // distinguish 'not found' from 'cannot read'\\n                bytes memory notFoundError =\\n                    abi.encodeWithSignature(\\\"CheatCodeError\\\", string(abi.encodePacked(\\\"invalid rpc url \\\", chainAlias)));\\n                if (keccak256(notFoundError) != keccak256(err) || bytes(chain.rpcUrl).length == 0) {\\n                    /// @solidity memory-safe-assembly\\n                    assembly {\\n                        revert(add(32, err), mload(err))\\n                    }\\n                }\\n            }\\n        }\\n        return chain;\\n    }\\n\\n    function setFallbackToDefaultRpcUrls(bool useDefault) internal {\\n        fallbackToDefaultRpcUrls = useDefault;\\n    }\\n\\n    function initializeStdChains() private {\\n        if (stdChainsInitialized) return;\\n\\n        stdChainsInitialized = true;\\n\\n        // If adding an RPC here, make sure to test the default RPC URL in `testRpcs`\\n        setChainWithDefaultRpcUrl(\\\"anvil\\\", ChainData(\\\"Anvil\\\", 31337, \\\"http://127.0.0.1:8545\\\"));\\n        setChainWithDefaultRpcUrl(\\n            \\\"mainnet\\\", ChainData(\\\"Mainnet\\\", 1, \\\"https://mainnet.infura.io/v3/b9794ad1ddf84dfb8c34d6bb5dca2001\\\")\\n        );\\n        setChainWithDefaultRpcUrl(\\n            \\\"goerli\\\", ChainData(\\\"Goerli\\\", 5, \\\"https://goerli.infura.io/v3/b9794ad1ddf84dfb8c34d6bb5dca2001\\\")\\n        );\\n        setChainWithDefaultRpcUrl(\\n            \\\"sepolia\\\", ChainData(\\\"Sepolia\\\", 11155111, \\\"https://sepolia.infura.io/v3/b9794ad1ddf84dfb8c34d6bb5dca2001\\\")\\n        );\\n        setChainWithDefaultRpcUrl(\\\"optimism\\\", ChainData(\\\"Optimism\\\", 10, \\\"https://mainnet.optimism.io\\\"));\\n        setChainWithDefaultRpcUrl(\\\"optimism_goerli\\\", ChainData(\\\"Optimism Goerli\\\", 420, \\\"https://goerli.optimism.io\\\"));\\n        setChainWithDefaultRpcUrl(\\\"arbitrum_one\\\", ChainData(\\\"Arbitrum One\\\", 42161, \\\"https://arb1.arbitrum.io/rpc\\\"));\\n        setChainWithDefaultRpcUrl(\\n            \\\"arbitrum_one_goerli\\\", ChainData(\\\"Arbitrum One Goerli\\\", 421613, \\\"https://goerli-rollup.arbitrum.io/rpc\\\")\\n        );\\n        setChainWithDefaultRpcUrl(\\\"arbitrum_nova\\\", ChainData(\\\"Arbitrum Nova\\\", 42170, \\\"https://nova.arbitrum.io/rpc\\\"));\\n        setChainWithDefaultRpcUrl(\\\"polygon\\\", ChainData(\\\"Polygon\\\", 137, \\\"https://polygon-rpc.com\\\"));\\n        setChainWithDefaultRpcUrl(\\n            \\\"polygon_mumbai\\\", ChainData(\\\"Polygon Mumbai\\\", 80001, \\\"https://rpc-mumbai.maticvigil.com\\\")\\n        );\\n        setChainWithDefaultRpcUrl(\\\"avalanche\\\", ChainData(\\\"Avalanche\\\", 43114, \\\"https://api.avax.network/ext/bc/C/rpc\\\"));\\n        setChainWithDefaultRpcUrl(\\n            \\\"avalanche_fuji\\\", ChainData(\\\"Avalanche Fuji\\\", 43113, \\\"https://api.avax-test.network/ext/bc/C/rpc\\\")\\n        );\\n        setChainWithDefaultRpcUrl(\\n            \\\"bnb_smart_chain\\\", ChainData(\\\"BNB Smart Chain\\\", 56, \\\"https://bsc-dataseed1.binance.org\\\")\\n        );\\n        setChainWithDefaultRpcUrl(\\n            \\\"bnb_smart_chain_testnet\\\",\\n            ChainData(\\\"BNB Smart Chain Testnet\\\", 97, \\\"https://rpc.ankr.com/bsc_testnet_chapel\\\")\\n        );\\n        setChainWithDefaultRpcUrl(\\\"gnosis_chain\\\", ChainData(\\\"Gnosis Chain\\\", 100, \\\"https://rpc.gnosischain.com\\\"));\\n        setChainWithDefaultRpcUrl(\\\"moonbeam\\\", ChainData(\\\"Moonbeam\\\", 1284, \\\"https://rpc.api.moonbeam.network\\\"));\\n        setChainWithDefaultRpcUrl(\\n            \\\"moonriver\\\", ChainData(\\\"Moonriver\\\", 1285, \\\"https://rpc.api.moonriver.moonbeam.network\\\")\\n        );\\n        setChainWithDefaultRpcUrl(\\\"moonbase\\\", ChainData(\\\"Moonbase\\\", 1287, \\\"https://rpc.testnet.moonbeam.network\\\"));\\n        setChainWithDefaultRpcUrl(\\\"base_goerli\\\", ChainData(\\\"Base Goerli\\\", 84531, \\\"https://goerli.base.org\\\"));\\n        setChainWithDefaultRpcUrl(\\\"base\\\", ChainData(\\\"Base\\\", 8453, \\\"https://mainnet.base.org\\\"));\\n    }\\n\\n    // set chain info, with priority to chainAlias' rpc url in foundry.toml\\n    function setChainWithDefaultRpcUrl(string memory chainAlias, ChainData memory chain) private {\\n        string memory rpcUrl = chain.rpcUrl;\\n        defaultRpcUrls[chainAlias] = rpcUrl;\\n        chain.rpcUrl = \\\"\\\";\\n        setChain(chainAlias, chain);\\n        chain.rpcUrl = rpcUrl; // restore argument\\n    }\\n}\\n\"\r\n    },\r\n    \"../../node_modules/forge-std/src/StdCheats.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.2 <0.9.0;\\n\\npragma experimental ABIEncoderV2;\\n\\nimport {StdStorage, stdStorage} from \\\"./StdStorage.sol\\\";\\nimport {console2} from \\\"./console2.sol\\\";\\nimport {Vm} from \\\"./Vm.sol\\\";\\n\\nabstract contract StdCheatsSafe {\\n    Vm private constant vm = Vm(address(uint160(uint256(keccak256(\\\"hevm cheat code\\\")))));\\n\\n    uint256 private constant UINT256_MAX =\\n        115792089237316195423570985008687907853269984665640564039457584007913129639935;\\n\\n    bool private gasMeteringOff;\\n\\n    // Data structures to parse Transaction objects from the broadcast artifact\\n    // that conform to EIP1559. The Raw structs is what is parsed from the JSON\\n    // and then converted to the one that is used by the user for better UX.\\n\\n    struct RawTx1559 {\\n        string[] arguments;\\n        address contractAddress;\\n        string contractName;\\n        // json value name = function\\n        string functionSig;\\n        bytes32 hash;\\n        // json value name = tx\\n        RawTx1559Detail txDetail;\\n        // json value name = type\\n        string opcode;\\n    }\\n\\n    struct RawTx1559Detail {\\n        AccessList[] accessList;\\n        bytes data;\\n        address from;\\n        bytes gas;\\n        bytes nonce;\\n        address to;\\n        bytes txType;\\n        bytes value;\\n    }\\n\\n    struct Tx1559 {\\n        string[] arguments;\\n        address contractAddress;\\n        string contractName;\\n        string functionSig;\\n        bytes32 hash;\\n        Tx1559Detail txDetail;\\n        string opcode;\\n    }\\n\\n    struct Tx1559Detail {\\n        AccessList[] accessList;\\n        bytes data;\\n        address from;\\n        uint256 gas;\\n        uint256 nonce;\\n        address to;\\n        uint256 txType;\\n        uint256 value;\\n    }\\n\\n    // Data structures to parse Transaction objects from the broadcast artifact\\n    // that DO NOT conform to EIP1559. The Raw structs is what is parsed from the JSON\\n    // and then converted to the one that is used by the user for better UX.\\n\\n    struct TxLegacy {\\n        string[] arguments;\\n        address contractAddress;\\n        string contractName;\\n        string functionSig;\\n        string hash;\\n        string opcode;\\n        TxDetailLegacy transaction;\\n    }\\n\\n    struct TxDetailLegacy {\\n        AccessList[] accessList;\\n        uint256 chainId;\\n        bytes data;\\n        address from;\\n        uint256 gas;\\n        uint256 gasPrice;\\n        bytes32 hash;\\n        uint256 nonce;\\n        bytes1 opcode;\\n        bytes32 r;\\n        bytes32 s;\\n        uint256 txType;\\n        address to;\\n        uint8 v;\\n        uint256 value;\\n    }\\n\\n    struct AccessList {\\n        address accessAddress;\\n        bytes32[] storageKeys;\\n    }\\n\\n    // Data structures to parse Receipt objects from the broadcast artifact.\\n    // The Raw structs is what is parsed from the JSON\\n    // and then converted to the one that is used by the user for better UX.\\n\\n    struct RawReceipt {\\n        bytes32 blockHash;\\n        bytes blockNumber;\\n        address contractAddress;\\n        bytes cumulativeGasUsed;\\n        bytes effectiveGasPrice;\\n        address from;\\n        bytes gasUsed;\\n        RawReceiptLog[] logs;\\n        bytes logsBloom;\\n        bytes status;\\n        address to;\\n        bytes32 transactionHash;\\n        bytes transactionIndex;\\n    }\\n\\n    struct Receipt {\\n        bytes32 blockHash;\\n        uint256 blockNumber;\\n        address contractAddress;\\n        uint256 cumulativeGasUsed;\\n        uint256 effectiveGasPrice;\\n        address from;\\n        uint256 gasUsed;\\n        ReceiptLog[] logs;\\n        bytes logsBloom;\\n        uint256 status;\\n        address to;\\n        bytes32 transactionHash;\\n        uint256 transactionIndex;\\n    }\\n\\n    // Data structures to parse the entire broadcast artifact, assuming the\\n    // transactions conform to EIP1559.\\n\\n    struct EIP1559ScriptArtifact {\\n        string[] libraries;\\n        string path;\\n        string[] pending;\\n        Receipt[] receipts;\\n        uint256 timestamp;\\n        Tx1559[] transactions;\\n        TxReturn[] txReturns;\\n    }\\n\\n    struct RawEIP1559ScriptArtifact {\\n        string[] libraries;\\n        string path;\\n        string[] pending;\\n        RawReceipt[] receipts;\\n        TxReturn[] txReturns;\\n        uint256 timestamp;\\n        RawTx1559[] transactions;\\n    }\\n\\n    struct RawReceiptLog {\\n        // json value = address\\n        address logAddress;\\n        bytes32 blockHash;\\n        bytes blockNumber;\\n        bytes data;\\n        bytes logIndex;\\n        bool removed;\\n        bytes32[] topics;\\n        bytes32 transactionHash;\\n        bytes transactionIndex;\\n        bytes transactionLogIndex;\\n    }\\n\\n    struct ReceiptLog {\\n        // json value = address\\n        address logAddress;\\n        bytes32 blockHash;\\n        uint256 blockNumber;\\n        bytes data;\\n        uint256 logIndex;\\n        bytes32[] topics;\\n        uint256 transactionIndex;\\n        uint256 transactionLogIndex;\\n        bool removed;\\n    }\\n\\n    struct TxReturn {\\n        string internalType;\\n        string value;\\n    }\\n\\n    struct Account {\\n        address addr;\\n        uint256 key;\\n    }\\n\\n    enum AddressType {\\n        Payable,\\n        NonPayable,\\n        ZeroAddress,\\n        Precompile,\\n        ForgeAddress\\n    }\\n\\n    // Checks that `addr` is not blacklisted by token contracts that have a blacklist.\\n    function assumeNotBlacklisted(address token, address addr) internal view virtual {\\n        // Nothing to check if `token` is not a contract.\\n        uint256 tokenCodeSize;\\n        assembly {\\n            tokenCodeSize := extcodesize(token)\\n        }\\n        require(tokenCodeSize > 0, \\\"StdCheats assumeNotBlacklisted(address,address): Token address is not a contract.\\\");\\n\\n        bool success;\\n        bytes memory returnData;\\n\\n        // 4-byte selector for `isBlacklisted(address)`, used by USDC.\\n        (success, returnData) = token.staticcall(abi.encodeWithSelector(0xfe575a87, addr));\\n        vm.assume(!success || abi.decode(returnData, (bool)) == false);\\n\\n        // 4-byte selector for `isBlackListed(address)`, used by USDT.\\n        (success, returnData) = token.staticcall(abi.encodeWithSelector(0xe47d6060, addr));\\n        vm.assume(!success || abi.decode(returnData, (bool)) == false);\\n    }\\n\\n    // Checks that `addr` is not blacklisted by token contracts that have a blacklist.\\n    // This is identical to `assumeNotBlacklisted(address,address)` but with a different name, for\\n    // backwards compatibility, since this name was used in the original PR which has already has\\n    // a release. This function can be removed in a future release once we want a breaking change.\\n    function assumeNoBlacklisted(address token, address addr) internal view virtual {\\n        assumeNotBlacklisted(token, addr);\\n    }\\n\\n    function assumeAddressIsNot(address addr, AddressType addressType) internal virtual {\\n        if (addressType == AddressType.Payable) {\\n            assumeNotPayable(addr);\\n        } else if (addressType == AddressType.NonPayable) {\\n            assumePayable(addr);\\n        } else if (addressType == AddressType.ZeroAddress) {\\n            assumeNotZeroAddress(addr);\\n        } else if (addressType == AddressType.Precompile) {\\n            assumeNotPrecompile(addr);\\n        } else if (addressType == AddressType.ForgeAddress) {\\n            assumeNotForgeAddress(addr);\\n        }\\n    }\\n\\n    function assumeAddressIsNot(address addr, AddressType addressType1, AddressType addressType2) internal virtual {\\n        assumeAddressIsNot(addr, addressType1);\\n        assumeAddressIsNot(addr, addressType2);\\n    }\\n\\n    function assumeAddressIsNot(\\n        address addr,\\n        AddressType addressType1,\\n        AddressType addressType2,\\n        AddressType addressType3\\n    ) internal virtual {\\n        assumeAddressIsNot(addr, addressType1);\\n        assumeAddressIsNot(addr, addressType2);\\n        assumeAddressIsNot(addr, addressType3);\\n    }\\n\\n    function assumeAddressIsNot(\\n        address addr,\\n        AddressType addressType1,\\n        AddressType addressType2,\\n        AddressType addressType3,\\n        AddressType addressType4\\n    ) internal virtual {\\n        assumeAddressIsNot(addr, addressType1);\\n        assumeAddressIsNot(addr, addressType2);\\n        assumeAddressIsNot(addr, addressType3);\\n        assumeAddressIsNot(addr, addressType4);\\n    }\\n\\n    // This function checks whether an address, `addr`, is payable. It works by sending 1 wei to\\n    // `addr` and checking the `success` return value.\\n    // NOTE: This function may result in state changes depending on the fallback/receive logic\\n    // implemented by `addr`, which should be taken into account when this function is used.\\n    function _isPayable(address addr) private returns (bool) {\\n        require(\\n            addr.balance < UINT256_MAX,\\n            \\\"StdCheats _isPayable(address): Balance equals max uint256, so it cannot receive any more funds\\\"\\n        );\\n        uint256 origBalanceTest = address(this).balance;\\n        uint256 origBalanceAddr = address(addr).balance;\\n\\n        vm.deal(address(this), 1);\\n        (bool success,) = payable(addr).call{value: 1}(\\\"\\\");\\n\\n        // reset balances\\n        vm.deal(address(this), origBalanceTest);\\n        vm.deal(addr, origBalanceAddr);\\n\\n        return success;\\n    }\\n\\n    // NOTE: This function may result in state changes depending on the fallback/receive logic\\n    // implemented by `addr`, which should be taken into account when this function is used. See the\\n    // `_isPayable` method for more information.\\n    function assumePayable(address addr) internal virtual {\\n        vm.assume(_isPayable(addr));\\n    }\\n\\n    function assumeNotPayable(address addr) internal virtual {\\n        vm.assume(!_isPayable(addr));\\n    }\\n\\n    function assumeNotZeroAddress(address addr) internal pure virtual {\\n        vm.assume(addr != address(0));\\n    }\\n\\n    function assumeNotPrecompile(address addr) internal pure virtual {\\n        assumeNotPrecompile(addr, _pureChainId());\\n    }\\n\\n    function assumeNotPrecompile(address addr, uint256 chainId) internal pure virtual {\\n        // Note: For some chains like Optimism these are technically predeploys (i.e. bytecode placed at a specific\\n        // address), but the same rationale for excluding them applies so we include those too.\\n\\n        // These should be present on all EVM-compatible chains.\\n        vm.assume(addr < address(0x1) || addr > address(0x9));\\n\\n        // forgefmt: disable-start\\n        if (chainId == 10 || chainId == 420) {\\n            // https://github.com/ethereum-optimism/optimism/blob/eaa371a0184b56b7ca6d9eb9cb0a2b78b2ccd864/op-bindings/predeploys/addresses.go#L6-L21\\n            vm.assume(addr < address(0x4200000000000000000000000000000000000000) || addr > address(0x4200000000000000000000000000000000000800));\\n        } else if (chainId == 42161 || chainId == 421613) {\\n            // https://developer.arbitrum.io/useful-addresses#arbitrum-precompiles-l2-same-on-all-arb-chains\\n            vm.assume(addr < address(0x0000000000000000000000000000000000000064) || addr > address(0x0000000000000000000000000000000000000068));\\n        } else if (chainId == 43114 || chainId == 43113) {\\n            // https://github.com/ava-labs/subnet-evm/blob/47c03fd007ecaa6de2c52ea081596e0a88401f58/precompile/params.go#L18-L59\\n            vm.assume(addr < address(0x0100000000000000000000000000000000000000) || addr > address(0x01000000000000000000000000000000000000ff));\\n            vm.assume(addr < address(0x0200000000000000000000000000000000000000) || addr > address(0x02000000000000000000000000000000000000FF));\\n            vm.assume(addr < address(0x0300000000000000000000000000000000000000) || addr > address(0x03000000000000000000000000000000000000Ff));\\n        }\\n        // forgefmt: disable-end\\n    }\\n\\n    function assumeNotForgeAddress(address addr) internal pure virtual {\\n        // vm, console, and Create2Deployer addresses\\n        vm.assume(\\n            addr != address(vm) && addr != 0x000000000000000000636F6e736F6c652e6c6f67\\n                && addr != 0x4e59b44847b379578588920cA78FbF26c0B4956C\\n        );\\n    }\\n\\n    function readEIP1559ScriptArtifact(string memory path)\\n        internal\\n        view\\n        virtual\\n        returns (EIP1559ScriptArtifact memory)\\n    {\\n        string memory data = vm.readFile(path);\\n        bytes memory parsedData = vm.parseJson(data);\\n        RawEIP1559ScriptArtifact memory rawArtifact = abi.decode(parsedData, (RawEIP1559ScriptArtifact));\\n        EIP1559ScriptArtifact memory artifact;\\n        artifact.libraries = rawArtifact.libraries;\\n        artifact.path = rawArtifact.path;\\n        artifact.timestamp = rawArtifact.timestamp;\\n        artifact.pending = rawArtifact.pending;\\n        artifact.txReturns = rawArtifact.txReturns;\\n        artifact.receipts = rawToConvertedReceipts(rawArtifact.receipts);\\n        artifact.transactions = rawToConvertedEIPTx1559s(rawArtifact.transactions);\\n        return artifact;\\n    }\\n\\n    function rawToConvertedEIPTx1559s(RawTx1559[] memory rawTxs) internal pure virtual returns (Tx1559[] memory) {\\n        Tx1559[] memory txs = new Tx1559[](rawTxs.length);\\n        for (uint256 i; i < rawTxs.length; i++) {\\n            txs[i] = rawToConvertedEIPTx1559(rawTxs[i]);\\n        }\\n        return txs;\\n    }\\n\\n    function rawToConvertedEIPTx1559(RawTx1559 memory rawTx) internal pure virtual returns (Tx1559 memory) {\\n        Tx1559 memory transaction;\\n        transaction.arguments = rawTx.arguments;\\n        transaction.contractName = rawTx.contractName;\\n        transaction.functionSig = rawTx.functionSig;\\n        transaction.hash = rawTx.hash;\\n        transaction.txDetail = rawToConvertedEIP1559Detail(rawTx.txDetail);\\n        transaction.opcode = rawTx.opcode;\\n        return transaction;\\n    }\\n\\n    function rawToConvertedEIP1559Detail(RawTx1559Detail memory rawDetail)\\n        internal\\n        pure\\n        virtual\\n        returns (Tx1559Detail memory)\\n    {\\n        Tx1559Detail memory txDetail;\\n        txDetail.data = rawDetail.data;\\n        txDetail.from = rawDetail.from;\\n        txDetail.to = rawDetail.to;\\n        txDetail.nonce = _bytesToUint(rawDetail.nonce);\\n        txDetail.txType = _bytesToUint(rawDetail.txType);\\n        txDetail.value = _bytesToUint(rawDetail.value);\\n        txDetail.gas = _bytesToUint(rawDetail.gas);\\n        txDetail.accessList = rawDetail.accessList;\\n        return txDetail;\\n    }\\n\\n    function readTx1559s(string memory path) internal view virtual returns (Tx1559[] memory) {\\n        string memory deployData = vm.readFile(path);\\n        bytes memory parsedDeployData = vm.parseJson(deployData, \\\".transactions\\\");\\n        RawTx1559[] memory rawTxs = abi.decode(parsedDeployData, (RawTx1559[]));\\n        return rawToConvertedEIPTx1559s(rawTxs);\\n    }\\n\\n    function readTx1559(string memory path, uint256 index) internal view virtual returns (Tx1559 memory) {\\n        string memory deployData = vm.readFile(path);\\n        string memory key = string(abi.encodePacked(\\\".transactions[\\\", vm.toString(index), \\\"]\\\"));\\n        bytes memory parsedDeployData = vm.parseJson(deployData, key);\\n        RawTx1559 memory rawTx = abi.decode(parsedDeployData, (RawTx1559));\\n        return rawToConvertedEIPTx1559(rawTx);\\n    }\\n\\n    // Analogous to readTransactions, but for receipts.\\n    function readReceipts(string memory path) internal view virtual returns (Receipt[] memory) {\\n        string memory deployData = vm.readFile(path);\\n        bytes memory parsedDeployData = vm.parseJson(deployData, \\\".receipts\\\");\\n        RawReceipt[] memory rawReceipts = abi.decode(parsedDeployData, (RawReceipt[]));\\n        return rawToConvertedReceipts(rawReceipts);\\n    }\\n\\n    function readReceipt(string memory path, uint256 index) internal view virtual returns (Receipt memory) {\\n        string memory deployData = vm.readFile(path);\\n        string memory key = string(abi.encodePacked(\\\".receipts[\\\", vm.toString(index), \\\"]\\\"));\\n        bytes memory parsedDeployData = vm.parseJson(deployData, key);\\n        RawReceipt memory rawReceipt = abi.decode(parsedDeployData, (RawReceipt));\\n        return rawToConvertedReceipt(rawReceipt);\\n    }\\n\\n    function rawToConvertedReceipts(RawReceipt[] memory rawReceipts) internal pure virtual returns (Receipt[] memory) {\\n        Receipt[] memory receipts = new Receipt[](rawReceipts.length);\\n        for (uint256 i; i < rawReceipts.length; i++) {\\n            receipts[i] = rawToConvertedReceipt(rawReceipts[i]);\\n        }\\n        return receipts;\\n    }\\n\\n    function rawToConvertedReceipt(RawReceipt memory rawReceipt) internal pure virtual returns (Receipt memory) {\\n        Receipt memory receipt;\\n        receipt.blockHash = rawReceipt.blockHash;\\n        receipt.to = rawReceipt.to;\\n        receipt.from = rawReceipt.from;\\n        receipt.contractAddress = rawReceipt.contractAddress;\\n        receipt.effectiveGasPrice = _bytesToUint(rawReceipt.effectiveGasPrice);\\n        receipt.cumulativeGasUsed = _bytesToUint(rawReceipt.cumulativeGasUsed);\\n        receipt.gasUsed = _bytesToUint(rawReceipt.gasUsed);\\n        receipt.status = _bytesToUint(rawReceipt.status);\\n        receipt.transactionIndex = _bytesToUint(rawReceipt.transactionIndex);\\n        receipt.blockNumber = _bytesToUint(rawReceipt.blockNumber);\\n        receipt.logs = rawToConvertedReceiptLogs(rawReceipt.logs);\\n        receipt.logsBloom = rawReceipt.logsBloom;\\n        receipt.transactionHash = rawReceipt.transactionHash;\\n        return receipt;\\n    }\\n\\n    function rawToConvertedReceiptLogs(RawReceiptLog[] memory rawLogs)\\n        internal\\n        pure\\n        virtual\\n        returns (ReceiptLog[] memory)\\n    {\\n        ReceiptLog[] memory logs = new ReceiptLog[](rawLogs.length);\\n        for (uint256 i; i < rawLogs.length; i++) {\\n            logs[i].logAddress = rawLogs[i].logAddress;\\n            logs[i].blockHash = rawLogs[i].blockHash;\\n            logs[i].blockNumber = _bytesToUint(rawLogs[i].blockNumber);\\n            logs[i].data = rawLogs[i].data;\\n            logs[i].logIndex = _bytesToUint(rawLogs[i].logIndex);\\n            logs[i].topics = rawLogs[i].topics;\\n            logs[i].transactionIndex = _bytesToUint(rawLogs[i].transactionIndex);\\n            logs[i].transactionLogIndex = _bytesToUint(rawLogs[i].transactionLogIndex);\\n            logs[i].removed = rawLogs[i].removed;\\n        }\\n        return logs;\\n    }\\n\\n    // Deploy a contract by fetching the contract bytecode from\\n    // the artifacts directory\\n    // e.g. `deployCode(code, abi.encode(arg1,arg2,arg3))`\\n    function deployCode(string memory what, bytes memory args) internal virtual returns (address addr) {\\n        bytes memory bytecode = abi.encodePacked(vm.getCode(what), args);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            addr := create(0, add(bytecode, 0x20), mload(bytecode))\\n        }\\n\\n        require(addr != address(0), \\\"StdCheats deployCode(string,bytes): Deployment failed.\\\");\\n    }\\n\\n    function deployCode(string memory what) internal virtual returns (address addr) {\\n        bytes memory bytecode = vm.getCode(what);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            addr := create(0, add(bytecode, 0x20), mload(bytecode))\\n        }\\n\\n        require(addr != address(0), \\\"StdCheats deployCode(string): Deployment failed.\\\");\\n    }\\n\\n    /// @dev deploy contract with value on construction\\n    function deployCode(string memory what, bytes memory args, uint256 val) internal virtual returns (address addr) {\\n        bytes memory bytecode = abi.encodePacked(vm.getCode(what), args);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            addr := create(val, add(bytecode, 0x20), mload(bytecode))\\n        }\\n\\n        require(addr != address(0), \\\"StdCheats deployCode(string,bytes,uint256): Deployment failed.\\\");\\n    }\\n\\n    function deployCode(string memory what, uint256 val) internal virtual returns (address addr) {\\n        bytes memory bytecode = vm.getCode(what);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            addr := create(val, add(bytecode, 0x20), mload(bytecode))\\n        }\\n\\n        require(addr != address(0), \\\"StdCheats deployCode(string,uint256): Deployment failed.\\\");\\n    }\\n\\n    // creates a labeled address and the corresponding private key\\n    function makeAddrAndKey(string memory name) internal virtual returns (address addr, uint256 privateKey) {\\n        privateKey = uint256(keccak256(abi.encodePacked(name)));\\n        addr = vm.addr(privateKey);\\n        vm.label(addr, name);\\n    }\\n\\n    // creates a labeled address\\n    function makeAddr(string memory name) internal virtual returns (address addr) {\\n        (addr,) = makeAddrAndKey(name);\\n    }\\n\\n    // Destroys an account immediately, sending the balance to beneficiary.\\n    // Destroying means: balance will be zero, code will be empty, and nonce will be 0\\n    // This is similar to selfdestruct but not identical: selfdestruct destroys code and nonce\\n    // only after tx ends, this will run immediately.\\n    function destroyAccount(address who, address beneficiary) internal virtual {\\n        uint256 currBalance = who.balance;\\n        vm.etch(who, abi.encode());\\n        vm.deal(who, 0);\\n        vm.resetNonce(who);\\n\\n        uint256 beneficiaryBalance = beneficiary.balance;\\n        vm.deal(beneficiary, currBalance + beneficiaryBalance);\\n    }\\n\\n    // creates a struct containing both a labeled address and the corresponding private key\\n    function makeAccount(string memory name) internal virtual returns (Account memory account) {\\n        (account.addr, account.key) = makeAddrAndKey(name);\\n    }\\n\\n    function deriveRememberKey(string memory mnemonic, uint32 index)\\n        internal\\n        virtual\\n        returns (address who, uint256 privateKey)\\n    {\\n        privateKey = vm.deriveKey(mnemonic, index);\\n        who = vm.rememberKey(privateKey);\\n    }\\n\\n    function _bytesToUint(bytes memory b) private pure returns (uint256) {\\n        require(b.length <= 32, \\\"StdCheats _bytesToUint(bytes): Bytes length exceeds 32.\\\");\\n        return abi.decode(abi.encodePacked(new bytes(32 - b.length), b), (uint256));\\n    }\\n\\n    function isFork() internal view virtual returns (bool status) {\\n        try vm.activeFork() {\\n            status = true;\\n        } catch (bytes memory) {}\\n    }\\n\\n    modifier skipWhenForking() {\\n        if (!isFork()) {\\n            _;\\n        }\\n    }\\n\\n    modifier skipWhenNotForking() {\\n        if (isFork()) {\\n            _;\\n        }\\n    }\\n\\n    modifier noGasMetering() {\\n        vm.pauseGasMetering();\\n        // To prevent turning gas monitoring back on with nested functions that use this modifier,\\n        // we check if gasMetering started in the off position. If it did, we don't want to turn\\n        // it back on until we exit the top level function that used the modifier\\n        //\\n        // i.e. funcA() noGasMetering { funcB() }, where funcB has noGasMetering as well.\\n        // funcA will have `gasStartedOff` as false, funcB will have it as true,\\n        // so we only turn metering back on at the end of the funcA\\n        bool gasStartedOff = gasMeteringOff;\\n        gasMeteringOff = true;\\n\\n        _;\\n\\n        // if gas metering was on when this modifier was called, turn it back on at the end\\n        if (!gasStartedOff) {\\n            gasMeteringOff = false;\\n            vm.resumeGasMetering();\\n        }\\n    }\\n\\n    // We use this complex approach of `_viewChainId` and `_pureChainId` to ensure there are no\\n    // compiler warnings when accessing chain ID in any solidity version supported by forge-std. We\\n    // can't simply access the chain ID in a normal view or pure function because the solc View Pure\\n    // Checker changed `chainid` from pure to view in 0.8.0.\\n    function _viewChainId() private view returns (uint256 chainId) {\\n        // Assembly required since `block.chainid` was introduced in 0.8.0.\\n        assembly {\\n            chainId := chainid()\\n        }\\n\\n        address(this); // Silence warnings in older Solc versions.\\n    }\\n\\n    function _pureChainId() private pure returns (uint256 chainId) {\\n        function() internal view returns (uint256) fnIn = _viewChainId;\\n        function() internal pure returns (uint256) pureChainId;\\n        assembly {\\n            pureChainId := fnIn\\n        }\\n        chainId = pureChainId();\\n    }\\n}\\n\\n// Wrappers around cheatcodes to avoid footguns\\nabstract contract StdCheats is StdCheatsSafe {\\n    using stdStorage for StdStorage;\\n\\n    StdStorage private stdstore;\\n    Vm private constant vm = Vm(address(uint160(uint256(keccak256(\\\"hevm cheat code\\\")))));\\n    address private constant CONSOLE2_ADDRESS = 0x000000000000000000636F6e736F6c652e6c6f67;\\n\\n    // Skip forward or rewind time by the specified number of seconds\\n    function skip(uint256 time) internal virtual {\\n        vm.warp(block.timestamp + time);\\n    }\\n\\n    function rewind(uint256 time) internal virtual {\\n        vm.warp(block.timestamp - time);\\n    }\\n\\n    // Setup a prank from an address that has some ether\\n    function hoax(address msgSender) internal virtual {\\n        vm.deal(msgSender, 1 << 128);\\n        vm.prank(msgSender);\\n    }\\n\\n    function hoax(address msgSender, uint256 give) internal virtual {\\n        vm.deal(msgSender, give);\\n        vm.prank(msgSender);\\n    }\\n\\n    function hoax(address msgSender, address origin) internal virtual {\\n        vm.deal(msgSender, 1 << 128);\\n        vm.prank(msgSender, origin);\\n    }\\n\\n    function hoax(address msgSender, address origin, uint256 give) internal virtual {\\n        vm.deal(msgSender, give);\\n        vm.prank(msgSender, origin);\\n    }\\n\\n    // Start perpetual prank from an address that has some ether\\n    function startHoax(address msgSender) internal virtual {\\n        vm.deal(msgSender, 1 << 128);\\n        vm.startPrank(msgSender);\\n    }\\n\\n    function startHoax(address msgSender, uint256 give) internal virtual {\\n        vm.deal(msgSender, give);\\n        vm.startPrank(msgSender);\\n    }\\n\\n    // Start perpetual prank from an address that has some ether\\n    // tx.origin is set to the origin parameter\\n    function startHoax(address msgSender, address origin) internal virtual {\\n        vm.deal(msgSender, 1 << 128);\\n        vm.startPrank(msgSender, origin);\\n    }\\n\\n    function startHoax(address msgSender, address origin, uint256 give) internal virtual {\\n        vm.deal(msgSender, give);\\n        vm.startPrank(msgSender, origin);\\n    }\\n\\n    function changePrank(address msgSender) internal virtual {\\n        console2_log(\\\"changePrank is deprecated. Please use vm.startPrank instead.\\\");\\n        vm.stopPrank();\\n        vm.startPrank(msgSender);\\n    }\\n\\n    function changePrank(address msgSender, address txOrigin) internal virtual {\\n        vm.stopPrank();\\n        vm.startPrank(msgSender, txOrigin);\\n    }\\n\\n    // The same as Vm's `deal`\\n    // Use the alternative signature for ERC20 tokens\\n    function deal(address to, uint256 give) internal virtual {\\n        vm.deal(to, give);\\n    }\\n\\n    // Set the balance of an account for any ERC20 token\\n    // Use the alternative signature to update `totalSupply`\\n    function deal(address token, address to, uint256 give) internal virtual {\\n        deal(token, to, give, false);\\n    }\\n\\n    // Set the balance of an account for any ERC1155 token\\n    // Use the alternative signature to update `totalSupply`\\n    function dealERC1155(address token, address to, uint256 id, uint256 give) internal virtual {\\n        dealERC1155(token, to, id, give, false);\\n    }\\n\\n    function deal(address token, address to, uint256 give, bool adjust) internal virtual {\\n        // get current balance\\n        (, bytes memory balData) = token.staticcall(abi.encodeWithSelector(0x70a08231, to));\\n        uint256 prevBal = abi.decode(balData, (uint256));\\n\\n        // update balance\\n        stdstore.target(token).sig(0x70a08231).with_key(to).checked_write(give);\\n\\n        // update total supply\\n        if (adjust) {\\n            (, bytes memory totSupData) = token.staticcall(abi.encodeWithSelector(0x18160ddd));\\n            uint256 totSup = abi.decode(totSupData, (uint256));\\n            if (give < prevBal) {\\n                totSup -= (prevBal - give);\\n            } else {\\n                totSup += (give - prevBal);\\n            }\\n            stdstore.target(token).sig(0x18160ddd).checked_write(totSup);\\n        }\\n    }\\n\\n    function dealERC1155(address token, address to, uint256 id, uint256 give, bool adjust) internal virtual {\\n        // get current balance\\n        (, bytes memory balData) = token.staticcall(abi.encodeWithSelector(0x00fdd58e, to, id));\\n        uint256 prevBal = abi.decode(balData, (uint256));\\n\\n        // update balance\\n        stdstore.target(token).sig(0x00fdd58e).with_key(to).with_key(id).checked_write(give);\\n\\n        // update total supply\\n        if (adjust) {\\n            (, bytes memory totSupData) = token.staticcall(abi.encodeWithSelector(0xbd85b039, id));\\n            require(\\n                totSupData.length != 0,\\n                \\\"StdCheats deal(address,address,uint,uint,bool): target contract is not ERC1155Supply.\\\"\\n            );\\n            uint256 totSup = abi.decode(totSupData, (uint256));\\n            if (give < prevBal) {\\n                totSup -= (prevBal - give);\\n            } else {\\n                totSup += (give - prevBal);\\n            }\\n            stdstore.target(token).sig(0xbd85b039).with_key(id).checked_write(totSup);\\n        }\\n    }\\n\\n    function dealERC721(address token, address to, uint256 id) internal virtual {\\n        // check if token id is already minted and the actual owner.\\n        (bool successMinted, bytes memory ownerData) = token.staticcall(abi.encodeWithSelector(0x6352211e, id));\\n        require(successMinted, \\\"StdCheats deal(address,address,uint,bool): id not minted.\\\");\\n\\n        // get owner current balance\\n        (, bytes memory fromBalData) =\\n            token.staticcall(abi.encodeWithSelector(0x70a08231, abi.decode(ownerData, (address))));\\n        uint256 fromPrevBal = abi.decode(fromBalData, (uint256));\\n\\n        // get new user current balance\\n        (, bytes memory toBalData) = token.staticcall(abi.encodeWithSelector(0x70a08231, to));\\n        uint256 toPrevBal = abi.decode(toBalData, (uint256));\\n\\n        // update balances\\n        stdstore.target(token).sig(0x70a08231).with_key(abi.decode(ownerData, (address))).checked_write(--fromPrevBal);\\n        stdstore.target(token).sig(0x70a08231).with_key(to).checked_write(++toPrevBal);\\n\\n        // update owner\\n        stdstore.target(token).sig(0x6352211e).with_key(id).checked_write(to);\\n    }\\n\\n    function deployCodeTo(string memory what, address where) internal virtual {\\n        deployCodeTo(what, \\\"\\\", 0, where);\\n    }\\n\\n    function deployCodeTo(string memory what, bytes memory args, address where) internal virtual {\\n        deployCodeTo(what, args, 0, where);\\n    }\\n\\n    function deployCodeTo(string memory what, bytes memory args, uint256 value, address where) internal virtual {\\n        bytes memory creationCode = vm.getCode(what);\\n        vm.etch(where, abi.encodePacked(creationCode, args));\\n        (bool success, bytes memory runtimeBytecode) = where.call{value: value}(\\\"\\\");\\n        require(success, \\\"StdCheats deployCodeTo(string,bytes,uint256,address): Failed to create runtime bytecode.\\\");\\n        vm.etch(where, runtimeBytecode);\\n    }\\n\\n    // Used to prevent the compilation of console, which shortens the compilation time when console is not used elsewhere.\\n    function console2_log(string memory p0) private view {\\n        (bool status,) = address(CONSOLE2_ADDRESS).staticcall(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n        status;\\n    }\\n}\\n\"\r\n    },\r\n    \"../../node_modules/forge-std/src/StdJson.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0 <0.9.0;\\n\\npragma experimental ABIEncoderV2;\\n\\nimport {VmSafe} from \\\"./Vm.sol\\\";\\n\\n// Helpers for parsing and writing JSON files\\n// To parse:\\n// ```\\n// using stdJson for string;\\n// string memory json = vm.readFile(\\\"some_peth\\\");\\n// json.parseUint(\\\"<json_path>\\\");\\n// ```\\n// To write:\\n// ```\\n// using stdJson for string;\\n// string memory json = \\\"deploymentArtifact\\\";\\n// Contract contract = new Contract();\\n// json.serialize(\\\"contractAddress\\\", address(contract));\\n// json = json.serialize(\\\"deploymentTimes\\\", uint(1));\\n// // store the stringified JSON to the 'json' variable we have been using as a key\\n// // as we won't need it any longer\\n// string memory json2 = \\\"finalArtifact\\\";\\n// string memory final = json2.serialize(\\\"depArtifact\\\", json);\\n// final.write(\\\"<some_path>\\\");\\n// ```\\n\\nlibrary stdJson {\\n    VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(\\\"hevm cheat code\\\")))));\\n\\n    function parseRaw(string memory json, string memory key) internal pure returns (bytes memory) {\\n        return vm.parseJson(json, key);\\n    }\\n\\n    function readUint(string memory json, string memory key) internal pure returns (uint256) {\\n        return vm.parseJsonUint(json, key);\\n    }\\n\\n    function readUintArray(string memory json, string memory key) internal pure returns (uint256[] memory) {\\n        return vm.parseJsonUintArray(json, key);\\n    }\\n\\n    function readInt(string memory json, string memory key) internal pure returns (int256) {\\n        return vm.parseJsonInt(json, key);\\n    }\\n\\n    function readIntArray(string memory json, string memory key) internal pure returns (int256[] memory) {\\n        return vm.parseJsonIntArray(json, key);\\n    }\\n\\n    function readBytes32(string memory json, string memory key) internal pure returns (bytes32) {\\n        return vm.parseJsonBytes32(json, key);\\n    }\\n\\n    function readBytes32Array(string memory json, string memory key) internal pure returns (bytes32[] memory) {\\n        return vm.parseJsonBytes32Array(json, key);\\n    }\\n\\n    function readString(string memory json, string memory key) internal pure returns (string memory) {\\n        return vm.parseJsonString(json, key);\\n    }\\n\\n    function readStringArray(string memory json, string memory key) internal pure returns (string[] memory) {\\n        return vm.parseJsonStringArray(json, key);\\n    }\\n\\n    function readAddress(string memory json, string memory key) internal pure returns (address) {\\n        return vm.parseJsonAddress(json, key);\\n    }\\n\\n    function readAddressArray(string memory json, string memory key) internal pure returns (address[] memory) {\\n        return vm.parseJsonAddressArray(json, key);\\n    }\\n\\n    function readBool(string memory json, string memory key) internal pure returns (bool) {\\n        return vm.parseJsonBool(json, key);\\n    }\\n\\n    function readBoolArray(string memory json, string memory key) internal pure returns (bool[] memory) {\\n        return vm.parseJsonBoolArray(json, key);\\n    }\\n\\n    function readBytes(string memory json, string memory key) internal pure returns (bytes memory) {\\n        return vm.parseJsonBytes(json, key);\\n    }\\n\\n    function readBytesArray(string memory json, string memory key) internal pure returns (bytes[] memory) {\\n        return vm.parseJsonBytesArray(json, key);\\n    }\\n\\n    function serialize(string memory jsonKey, string memory key, bool value) internal returns (string memory) {\\n        return vm.serializeBool(jsonKey, key, value);\\n    }\\n\\n    function serialize(string memory jsonKey, string memory key, bool[] memory value)\\n        internal\\n        returns (string memory)\\n    {\\n        return vm.serializeBool(jsonKey, key, value);\\n    }\\n\\n    function serialize(string memory jsonKey, string memory key, uint256 value) internal returns (string memory) {\\n        return vm.serializeUint(jsonKey, key, value);\\n    }\\n\\n    function serialize(string memory jsonKey, string memory key, uint256[] memory value)\\n        internal\\n        returns (string memory)\\n    {\\n        return vm.serializeUint(jsonKey, key, value);\\n    }\\n\\n    function serialize(string memory jsonKey, string memory key, int256 value) internal returns (string memory) {\\n        return vm.serializeInt(jsonKey, key, value);\\n    }\\n\\n    function serialize(string memory jsonKey, string memory key, int256[] memory value)\\n        internal\\n        returns (string memory)\\n    {\\n        return vm.serializeInt(jsonKey, key, value);\\n    }\\n\\n    function serialize(string memory jsonKey, string memory key, address value) internal returns (string memory) {\\n        return vm.serializeAddress(jsonKey, key, value);\\n    }\\n\\n    function serialize(string memory jsonKey, string memory key, address[] memory value)\\n        internal\\n        returns (string memory)\\n    {\\n        return vm.serializeAddress(jsonKey, key, value);\\n    }\\n\\n    function serialize(string memory jsonKey, string memory key, bytes32 value) internal returns (string memory) {\\n        return vm.serializeBytes32(jsonKey, key, value);\\n    }\\n\\n    function serialize(string memory jsonKey, string memory key, bytes32[] memory value)\\n        internal\\n        returns (string memory)\\n    {\\n        return vm.serializeBytes32(jsonKey, key, value);\\n    }\\n\\n    function serialize(string memory jsonKey, string memory key, bytes memory value) internal returns (string memory) {\\n        return vm.serializeBytes(jsonKey, key, value);\\n    }\\n\\n    function serialize(string memory jsonKey, string memory key, bytes[] memory value)\\n        internal\\n        returns (string memory)\\n    {\\n        return vm.serializeBytes(jsonKey, key, value);\\n    }\\n\\n    function serialize(string memory jsonKey, string memory key, string memory value)\\n        internal\\n        returns (string memory)\\n    {\\n        return vm.serializeString(jsonKey, key, value);\\n    }\\n\\n    function serialize(string memory jsonKey, string memory key, string[] memory value)\\n        internal\\n        returns (string memory)\\n    {\\n        return vm.serializeString(jsonKey, key, value);\\n    }\\n\\n    function write(string memory jsonKey, string memory path) internal {\\n        vm.writeJson(jsonKey, path);\\n    }\\n\\n    function write(string memory jsonKey, string memory path, string memory valueKey) internal {\\n        vm.writeJson(jsonKey, path, valueKey);\\n    }\\n}\\n\"\r\n    },\r\n    \"../../node_modules/forge-std/src/StdMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.2 <0.9.0;\\n\\nlibrary stdMath {\\n    int256 private constant INT256_MIN = -57896044618658097711785492504343953926634992332820282019728792003956564819968;\\n\\n    function abs(int256 a) internal pure returns (uint256) {\\n        // Required or it will fail when `a = type(int256).min`\\n        if (a == INT256_MIN) {\\n            return 57896044618658097711785492504343953926634992332820282019728792003956564819968;\\n        }\\n\\n        return uint256(a > 0 ? a : -a);\\n    }\\n\\n    function delta(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a - b : b - a;\\n    }\\n\\n    function delta(int256 a, int256 b) internal pure returns (uint256) {\\n        // a and b are of the same sign\\n        // this works thanks to two's complement, the left-most bit is the sign bit\\n        if ((a ^ b) > -1) {\\n            return delta(abs(a), abs(b));\\n        }\\n\\n        // a and b are of opposite signs\\n        return abs(a) + abs(b);\\n    }\\n\\n    function percentDelta(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 absDelta = delta(a, b);\\n\\n        return absDelta * 1e18 / b;\\n    }\\n\\n    function percentDelta(int256 a, int256 b) internal pure returns (uint256) {\\n        uint256 absDelta = delta(a, b);\\n        uint256 absB = abs(b);\\n\\n        return absDelta * 1e18 / absB;\\n    }\\n}\\n\"\r\n    },\r\n    \"../../node_modules/forge-std/src/StdStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.2 <0.9.0;\\n\\nimport {Vm} from \\\"./Vm.sol\\\";\\n\\nstruct StdStorage {\\n    mapping(address => mapping(bytes4 => mapping(bytes32 => uint256))) slots;\\n    mapping(address => mapping(bytes4 => mapping(bytes32 => bool))) finds;\\n    bytes32[] _keys;\\n    bytes4 _sig;\\n    uint256 _depth;\\n    address _target;\\n    bytes32 _set;\\n}\\n\\nlibrary stdStorageSafe {\\n    event SlotFound(address who, bytes4 fsig, bytes32 keysHash, uint256 slot);\\n    event WARNING_UninitedSlot(address who, uint256 slot);\\n\\n    Vm private constant vm = Vm(address(uint160(uint256(keccak256(\\\"hevm cheat code\\\")))));\\n\\n    function sigs(string memory sigStr) internal pure returns (bytes4) {\\n        return bytes4(keccak256(bytes(sigStr)));\\n    }\\n\\n    /// @notice find an arbitrary storage slot given a function sig, input data, address of the contract and a value to check against\\n    // slot complexity:\\n    //  if flat, will be bytes32(uint256(uint));\\n    //  if map, will be keccak256(abi.encode(key, uint(slot)));\\n    //  if deep map, will be keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))));\\n    //  if map struct, will be bytes32(uint256(keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))))) + structFieldDepth);\\n    function find(StdStorage storage self) internal returns (uint256) {\\n        address who = self._target;\\n        bytes4 fsig = self._sig;\\n        uint256 field_depth = self._depth;\\n        bytes32[] memory ins = self._keys;\\n\\n        // calldata to test against\\n        if (self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]) {\\n            return self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))];\\n        }\\n        bytes memory cald = abi.encodePacked(fsig, flatten(ins));\\n        vm.record();\\n        bytes32 fdat;\\n        {\\n            (, bytes memory rdat) = who.staticcall(cald);\\n            fdat = bytesToBytes32(rdat, 32 * field_depth);\\n        }\\n\\n        (bytes32[] memory reads,) = vm.accesses(address(who));\\n        if (reads.length == 1) {\\n            bytes32 curr = vm.load(who, reads[0]);\\n            if (curr == bytes32(0)) {\\n                emit WARNING_UninitedSlot(who, uint256(reads[0]));\\n            }\\n            if (fdat != curr) {\\n                require(\\n                    false,\\n                    \\\"stdStorage find(StdStorage): Packed slot. This would cause dangerous overwriting and currently isn't supported.\\\"\\n                );\\n            }\\n            emit SlotFound(who, fsig, keccak256(abi.encodePacked(ins, field_depth)), uint256(reads[0]));\\n            self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = uint256(reads[0]);\\n            self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = true;\\n        } else if (reads.length > 1) {\\n            for (uint256 i = 0; i < reads.length; i++) {\\n                bytes32 prev = vm.load(who, reads[i]);\\n                if (prev == bytes32(0)) {\\n                    emit WARNING_UninitedSlot(who, uint256(reads[i]));\\n                }\\n                if (prev != fdat) {\\n                    continue;\\n                }\\n                bytes32 new_val = ~prev;\\n                // store\\n                vm.store(who, reads[i], new_val);\\n                bool success;\\n                {\\n                    bytes memory rdat;\\n                    (success, rdat) = who.staticcall(cald);\\n                    fdat = bytesToBytes32(rdat, 32 * field_depth);\\n                }\\n\\n                if (success && fdat == new_val) {\\n                    // we found which of the slots is the actual one\\n                    emit SlotFound(who, fsig, keccak256(abi.encodePacked(ins, field_depth)), uint256(reads[i]));\\n                    self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = uint256(reads[i]);\\n                    self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = true;\\n                    vm.store(who, reads[i], prev);\\n                    break;\\n                }\\n                vm.store(who, reads[i], prev);\\n            }\\n        } else {\\n            revert(\\\"stdStorage find(StdStorage): No storage use detected for target.\\\");\\n        }\\n\\n        require(\\n            self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))],\\n            \\\"stdStorage find(StdStorage): Slot(s) not found.\\\"\\n        );\\n\\n        delete self._target;\\n        delete self._sig;\\n        delete self._keys;\\n        delete self._depth;\\n\\n        return self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))];\\n    }\\n\\n    function target(StdStorage storage self, address _target) internal returns (StdStorage storage) {\\n        self._target = _target;\\n        return self;\\n    }\\n\\n    function sig(StdStorage storage self, bytes4 _sig) internal returns (StdStorage storage) {\\n        self._sig = _sig;\\n        return self;\\n    }\\n\\n    function sig(StdStorage storage self, string memory _sig) internal returns (StdStorage storage) {\\n        self._sig = sigs(_sig);\\n        return self;\\n    }\\n\\n    function with_key(StdStorage storage self, address who) internal returns (StdStorage storage) {\\n        self._keys.push(bytes32(uint256(uint160(who))));\\n        return self;\\n    }\\n\\n    function with_key(StdStorage storage self, uint256 amt) internal returns (StdStorage storage) {\\n        self._keys.push(bytes32(amt));\\n        return self;\\n    }\\n\\n    function with_key(StdStorage storage self, bytes32 key) internal returns (StdStorage storage) {\\n        self._keys.push(key);\\n        return self;\\n    }\\n\\n    function depth(StdStorage storage self, uint256 _depth) internal returns (StdStorage storage) {\\n        self._depth = _depth;\\n        return self;\\n    }\\n\\n    function read(StdStorage storage self) private returns (bytes memory) {\\n        address t = self._target;\\n        uint256 s = find(self);\\n        return abi.encode(vm.load(t, bytes32(s)));\\n    }\\n\\n    function read_bytes32(StdStorage storage self) internal returns (bytes32) {\\n        return abi.decode(read(self), (bytes32));\\n    }\\n\\n    function read_bool(StdStorage storage self) internal returns (bool) {\\n        int256 v = read_int(self);\\n        if (v == 0) return false;\\n        if (v == 1) return true;\\n        revert(\\\"stdStorage read_bool(StdStorage): Cannot decode. Make sure you are reading a bool.\\\");\\n    }\\n\\n    function read_address(StdStorage storage self) internal returns (address) {\\n        return abi.decode(read(self), (address));\\n    }\\n\\n    function read_uint(StdStorage storage self) internal returns (uint256) {\\n        return abi.decode(read(self), (uint256));\\n    }\\n\\n    function read_int(StdStorage storage self) internal returns (int256) {\\n        return abi.decode(read(self), (int256));\\n    }\\n\\n    function parent(StdStorage storage self) internal returns (uint256, bytes32) {\\n        address who = self._target;\\n        uint256 field_depth = self._depth;\\n        vm.startMappingRecording();\\n        uint256 child = find(self) - field_depth;\\n        (bool found, bytes32 key, bytes32 parent_slot) = vm.getMappingKeyAndParentOf(who, bytes32(child));\\n        if (!found) {\\n            revert(\\n                \\\"stdStorage read_bool(StdStorage): Cannot find parent. Make sure you give a slot and startMappingRecording() has been called.\\\"\\n            );\\n        }\\n        return (uint256(parent_slot), key);\\n    }\\n\\n    function root(StdStorage storage self) internal returns (uint256) {\\n        address who = self._target;\\n        uint256 field_depth = self._depth;\\n        vm.startMappingRecording();\\n        uint256 child = find(self) - field_depth;\\n        bool found;\\n        bytes32 root_slot;\\n        bytes32 parent_slot;\\n        (found,, parent_slot) = vm.getMappingKeyAndParentOf(who, bytes32(child));\\n        if (!found) {\\n            revert(\\n                \\\"stdStorage read_bool(StdStorage): Cannot find parent. Make sure you give a slot and startMappingRecording() has been called.\\\"\\n            );\\n        }\\n        while (found) {\\n            root_slot = parent_slot;\\n            (found,, parent_slot) = vm.getMappingKeyAndParentOf(who, bytes32(root_slot));\\n        }\\n        return uint256(root_slot);\\n    }\\n\\n    function bytesToBytes32(bytes memory b, uint256 offset) private pure returns (bytes32) {\\n        bytes32 out;\\n\\n        uint256 max = b.length > 32 ? 32 : b.length;\\n        for (uint256 i = 0; i < max; i++) {\\n            out |= bytes32(b[offset + i] & 0xFF) >> (i * 8);\\n        }\\n        return out;\\n    }\\n\\n    function flatten(bytes32[] memory b) private pure returns (bytes memory) {\\n        bytes memory result = new bytes(b.length * 32);\\n        for (uint256 i = 0; i < b.length; i++) {\\n            bytes32 k = b[i];\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                mstore(add(result, add(32, mul(32, i))), k)\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n\\nlibrary stdStorage {\\n    Vm private constant vm = Vm(address(uint160(uint256(keccak256(\\\"hevm cheat code\\\")))));\\n\\n    function sigs(string memory sigStr) internal pure returns (bytes4) {\\n        return stdStorageSafe.sigs(sigStr);\\n    }\\n\\n    function find(StdStorage storage self) internal returns (uint256) {\\n        return stdStorageSafe.find(self);\\n    }\\n\\n    function target(StdStorage storage self, address _target) internal returns (StdStorage storage) {\\n        return stdStorageSafe.target(self, _target);\\n    }\\n\\n    function sig(StdStorage storage self, bytes4 _sig) internal returns (StdStorage storage) {\\n        return stdStorageSafe.sig(self, _sig);\\n    }\\n\\n    function sig(StdStorage storage self, string memory _sig) internal returns (StdStorage storage) {\\n        return stdStorageSafe.sig(self, _sig);\\n    }\\n\\n    function with_key(StdStorage storage self, address who) internal returns (StdStorage storage) {\\n        return stdStorageSafe.with_key(self, who);\\n    }\\n\\n    function with_key(StdStorage storage self, uint256 amt) internal returns (StdStorage storage) {\\n        return stdStorageSafe.with_key(self, amt);\\n    }\\n\\n    function with_key(StdStorage storage self, bytes32 key) internal returns (StdStorage storage) {\\n        return stdStorageSafe.with_key(self, key);\\n    }\\n\\n    function depth(StdStorage storage self, uint256 _depth) internal returns (StdStorage storage) {\\n        return stdStorageSafe.depth(self, _depth);\\n    }\\n\\n    function checked_write(StdStorage storage self, address who) internal {\\n        checked_write(self, bytes32(uint256(uint160(who))));\\n    }\\n\\n    function checked_write(StdStorage storage self, uint256 amt) internal {\\n        checked_write(self, bytes32(amt));\\n    }\\n\\n    function checked_write_int(StdStorage storage self, int256 val) internal {\\n        checked_write(self, bytes32(uint256(val)));\\n    }\\n\\n    function checked_write(StdStorage storage self, bool write) internal {\\n        bytes32 t;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            t := write\\n        }\\n        checked_write(self, t);\\n    }\\n\\n    function checked_write(StdStorage storage self, bytes32 set) internal {\\n        address who = self._target;\\n        bytes4 fsig = self._sig;\\n        uint256 field_depth = self._depth;\\n        bytes32[] memory ins = self._keys;\\n\\n        bytes memory cald = abi.encodePacked(fsig, flatten(ins));\\n        if (!self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]) {\\n            find(self);\\n        }\\n        bytes32 slot = bytes32(self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]);\\n\\n        bytes32 fdat;\\n        {\\n            (, bytes memory rdat) = who.staticcall(cald);\\n            fdat = bytesToBytes32(rdat, 32 * field_depth);\\n        }\\n        bytes32 curr = vm.load(who, slot);\\n\\n        if (fdat != curr) {\\n            require(\\n                false,\\n                \\\"stdStorage find(StdStorage): Packed slot. This would cause dangerous overwriting and currently isn't supported.\\\"\\n            );\\n        }\\n        vm.store(who, slot, set);\\n        delete self._target;\\n        delete self._sig;\\n        delete self._keys;\\n        delete self._depth;\\n    }\\n\\n    function read_bytes32(StdStorage storage self) internal returns (bytes32) {\\n        return stdStorageSafe.read_bytes32(self);\\n    }\\n\\n    function read_bool(StdStorage storage self) internal returns (bool) {\\n        return stdStorageSafe.read_bool(self);\\n    }\\n\\n    function read_address(StdStorage storage self) internal returns (address) {\\n        return stdStorageSafe.read_address(self);\\n    }\\n\\n    function read_uint(StdStorage storage self) internal returns (uint256) {\\n        return stdStorageSafe.read_uint(self);\\n    }\\n\\n    function read_int(StdStorage storage self) internal returns (int256) {\\n        return stdStorageSafe.read_int(self);\\n    }\\n\\n    function parent(StdStorage storage self) internal returns (uint256, bytes32) {\\n        return stdStorageSafe.parent(self);\\n    }\\n\\n    function root(StdStorage storage self) internal returns (uint256) {\\n        return stdStorageSafe.root(self);\\n    }\\n\\n    // Private function so needs to be copied over\\n    function bytesToBytes32(bytes memory b, uint256 offset) private pure returns (bytes32) {\\n        bytes32 out;\\n\\n        uint256 max = b.length > 32 ? 32 : b.length;\\n        for (uint256 i = 0; i < max; i++) {\\n            out |= bytes32(b[offset + i] & 0xFF) >> (i * 8);\\n        }\\n        return out;\\n    }\\n\\n    // Private function so needs to be copied over\\n    function flatten(bytes32[] memory b) private pure returns (bytes memory) {\\n        bytes memory result = new bytes(b.length * 32);\\n        for (uint256 i = 0; i < b.length; i++) {\\n            bytes32 k = b[i];\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                mstore(add(result, add(32, mul(32, i))), k)\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"../../node_modules/forge-std/src/StdStyle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.4.22 <0.9.0;\\n\\nimport {VmSafe} from \\\"./Vm.sol\\\";\\n\\nlibrary StdStyle {\\n    VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(\\\"hevm cheat code\\\")))));\\n\\n    string constant RED = \\\"\\\\u001b[91m\\\";\\n    string constant GREEN = \\\"\\\\u001b[92m\\\";\\n    string constant YELLOW = \\\"\\\\u001b[93m\\\";\\n    string constant BLUE = \\\"\\\\u001b[94m\\\";\\n    string constant MAGENTA = \\\"\\\\u001b[95m\\\";\\n    string constant CYAN = \\\"\\\\u001b[96m\\\";\\n    string constant BOLD = \\\"\\\\u001b[1m\\\";\\n    string constant DIM = \\\"\\\\u001b[2m\\\";\\n    string constant ITALIC = \\\"\\\\u001b[3m\\\";\\n    string constant UNDERLINE = \\\"\\\\u001b[4m\\\";\\n    string constant INVERSE = \\\"\\\\u001b[7m\\\";\\n    string constant RESET = \\\"\\\\u001b[0m\\\";\\n\\n    function styleConcat(string memory style, string memory self) private pure returns (string memory) {\\n        return string(abi.encodePacked(style, self, RESET));\\n    }\\n\\n    function red(string memory self) internal pure returns (string memory) {\\n        return styleConcat(RED, self);\\n    }\\n\\n    function red(uint256 self) internal pure returns (string memory) {\\n        return red(vm.toString(self));\\n    }\\n\\n    function red(int256 self) internal pure returns (string memory) {\\n        return red(vm.toString(self));\\n    }\\n\\n    function red(address self) internal pure returns (string memory) {\\n        return red(vm.toString(self));\\n    }\\n\\n    function red(bool self) internal pure returns (string memory) {\\n        return red(vm.toString(self));\\n    }\\n\\n    function redBytes(bytes memory self) internal pure returns (string memory) {\\n        return red(vm.toString(self));\\n    }\\n\\n    function redBytes32(bytes32 self) internal pure returns (string memory) {\\n        return red(vm.toString(self));\\n    }\\n\\n    function green(string memory self) internal pure returns (string memory) {\\n        return styleConcat(GREEN, self);\\n    }\\n\\n    function green(uint256 self) internal pure returns (string memory) {\\n        return green(vm.toString(self));\\n    }\\n\\n    function green(int256 self) internal pure returns (string memory) {\\n        return green(vm.toString(self));\\n    }\\n\\n    function green(address self) internal pure returns (string memory) {\\n        return green(vm.toString(self));\\n    }\\n\\n    function green(bool self) internal pure returns (string memory) {\\n        return green(vm.toString(self));\\n    }\\n\\n    function greenBytes(bytes memory self) internal pure returns (string memory) {\\n        return green(vm.toString(self));\\n    }\\n\\n    function greenBytes32(bytes32 self) internal pure returns (string memory) {\\n        return green(vm.toString(self));\\n    }\\n\\n    function yellow(string memory self) internal pure returns (string memory) {\\n        return styleConcat(YELLOW, self);\\n    }\\n\\n    function yellow(uint256 self) internal pure returns (string memory) {\\n        return yellow(vm.toString(self));\\n    }\\n\\n    function yellow(int256 self) internal pure returns (string memory) {\\n        return yellow(vm.toString(self));\\n    }\\n\\n    function yellow(address self) internal pure returns (string memory) {\\n        return yellow(vm.toString(self));\\n    }\\n\\n    function yellow(bool self) internal pure returns (string memory) {\\n        return yellow(vm.toString(self));\\n    }\\n\\n    function yellowBytes(bytes memory self) internal pure returns (string memory) {\\n        return yellow(vm.toString(self));\\n    }\\n\\n    function yellowBytes32(bytes32 self) internal pure returns (string memory) {\\n        return yellow(vm.toString(self));\\n    }\\n\\n    function blue(string memory self) internal pure returns (string memory) {\\n        return styleConcat(BLUE, self);\\n    }\\n\\n    function blue(uint256 self) internal pure returns (string memory) {\\n        return blue(vm.toString(self));\\n    }\\n\\n    function blue(int256 self) internal pure returns (string memory) {\\n        return blue(vm.toString(self));\\n    }\\n\\n    function blue(address self) internal pure returns (string memory) {\\n        return blue(vm.toString(self));\\n    }\\n\\n    function blue(bool self) internal pure returns (string memory) {\\n        return blue(vm.toString(self));\\n    }\\n\\n    function blueBytes(bytes memory self) internal pure returns (string memory) {\\n        return blue(vm.toString(self));\\n    }\\n\\n    function blueBytes32(bytes32 self) internal pure returns (string memory) {\\n        return blue(vm.toString(self));\\n    }\\n\\n    function magenta(string memory self) internal pure returns (string memory) {\\n        return styleConcat(MAGENTA, self);\\n    }\\n\\n    function magenta(uint256 self) internal pure returns (string memory) {\\n        return magenta(vm.toString(self));\\n    }\\n\\n    function magenta(int256 self) internal pure returns (string memory) {\\n        return magenta(vm.toString(self));\\n    }\\n\\n    function magenta(address self) internal pure returns (string memory) {\\n        return magenta(vm.toString(self));\\n    }\\n\\n    function magenta(bool self) internal pure returns (string memory) {\\n        return magenta(vm.toString(self));\\n    }\\n\\n    function magentaBytes(bytes memory self) internal pure returns (string memory) {\\n        return magenta(vm.toString(self));\\n    }\\n\\n    function magentaBytes32(bytes32 self) internal pure returns (string memory) {\\n        return magenta(vm.toString(self));\\n    }\\n\\n    function cyan(string memory self) internal pure returns (string memory) {\\n        return styleConcat(CYAN, self);\\n    }\\n\\n    function cyan(uint256 self) internal pure returns (string memory) {\\n        return cyan(vm.toString(self));\\n    }\\n\\n    function cyan(int256 self) internal pure returns (string memory) {\\n        return cyan(vm.toString(self));\\n    }\\n\\n    function cyan(address self) internal pure returns (string memory) {\\n        return cyan(vm.toString(self));\\n    }\\n\\n    function cyan(bool self) internal pure returns (string memory) {\\n        return cyan(vm.toString(self));\\n    }\\n\\n    function cyanBytes(bytes memory self) internal pure returns (string memory) {\\n        return cyan(vm.toString(self));\\n    }\\n\\n    function cyanBytes32(bytes32 self) internal pure returns (string memory) {\\n        return cyan(vm.toString(self));\\n    }\\n\\n    function bold(string memory self) internal pure returns (string memory) {\\n        return styleConcat(BOLD, self);\\n    }\\n\\n    function bold(uint256 self) internal pure returns (string memory) {\\n        return bold(vm.toString(self));\\n    }\\n\\n    function bold(int256 self) internal pure returns (string memory) {\\n        return bold(vm.toString(self));\\n    }\\n\\n    function bold(address self) internal pure returns (string memory) {\\n        return bold(vm.toString(self));\\n    }\\n\\n    function bold(bool self) internal pure returns (string memory) {\\n        return bold(vm.toString(self));\\n    }\\n\\n    function boldBytes(bytes memory self) internal pure returns (string memory) {\\n        return bold(vm.toString(self));\\n    }\\n\\n    function boldBytes32(bytes32 self) internal pure returns (string memory) {\\n        return bold(vm.toString(self));\\n    }\\n\\n    function dim(string memory self) internal pure returns (string memory) {\\n        return styleConcat(DIM, self);\\n    }\\n\\n    function dim(uint256 self) internal pure returns (string memory) {\\n        return dim(vm.toString(self));\\n    }\\n\\n    function dim(int256 self) internal pure returns (string memory) {\\n        return dim(vm.toString(self));\\n    }\\n\\n    function dim(address self) internal pure returns (string memory) {\\n        return dim(vm.toString(self));\\n    }\\n\\n    function dim(bool self) internal pure returns (string memory) {\\n        return dim(vm.toString(self));\\n    }\\n\\n    function dimBytes(bytes memory self) internal pure returns (string memory) {\\n        return dim(vm.toString(self));\\n    }\\n\\n    function dimBytes32(bytes32 self) internal pure returns (string memory) {\\n        return dim(vm.toString(self));\\n    }\\n\\n    function italic(string memory self) internal pure returns (string memory) {\\n        return styleConcat(ITALIC, self);\\n    }\\n\\n    function italic(uint256 self) internal pure returns (string memory) {\\n        return italic(vm.toString(self));\\n    }\\n\\n    function italic(int256 self) internal pure returns (string memory) {\\n        return italic(vm.toString(self));\\n    }\\n\\n    function italic(address self) internal pure returns (string memory) {\\n        return italic(vm.toString(self));\\n    }\\n\\n    function italic(bool self) internal pure returns (string memory) {\\n        return italic(vm.toString(self));\\n    }\\n\\n    function italicBytes(bytes memory self) internal pure returns (string memory) {\\n        return italic(vm.toString(self));\\n    }\\n\\n    function italicBytes32(bytes32 self) internal pure returns (string memory) {\\n        return italic(vm.toString(self));\\n    }\\n\\n    function underline(string memory self) internal pure returns (string memory) {\\n        return styleConcat(UNDERLINE, self);\\n    }\\n\\n    function underline(uint256 self) internal pure returns (string memory) {\\n        return underline(vm.toString(self));\\n    }\\n\\n    function underline(int256 self) internal pure returns (string memory) {\\n        return underline(vm.toString(self));\\n    }\\n\\n    function underline(address self) internal pure returns (string memory) {\\n        return underline(vm.toString(self));\\n    }\\n\\n    function underline(bool self) internal pure returns (string memory) {\\n        return underline(vm.toString(self));\\n    }\\n\\n    function underlineBytes(bytes memory self) internal pure returns (string memory) {\\n        return underline(vm.toString(self));\\n    }\\n\\n    function underlineBytes32(bytes32 self) internal pure returns (string memory) {\\n        return underline(vm.toString(self));\\n    }\\n\\n    function inverse(string memory self) internal pure returns (string memory) {\\n        return styleConcat(INVERSE, self);\\n    }\\n\\n    function inverse(uint256 self) internal pure returns (string memory) {\\n        return inverse(vm.toString(self));\\n    }\\n\\n    function inverse(int256 self) internal pure returns (string memory) {\\n        return inverse(vm.toString(self));\\n    }\\n\\n    function inverse(address self) internal pure returns (string memory) {\\n        return inverse(vm.toString(self));\\n    }\\n\\n    function inverse(bool self) internal pure returns (string memory) {\\n        return inverse(vm.toString(self));\\n    }\\n\\n    function inverseBytes(bytes memory self) internal pure returns (string memory) {\\n        return inverse(vm.toString(self));\\n    }\\n\\n    function inverseBytes32(bytes32 self) internal pure returns (string memory) {\\n        return inverse(vm.toString(self));\\n    }\\n}\\n\"\r\n    },\r\n    \"../../node_modules/forge-std/src/StdUtils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.2 <0.9.0;\\n\\npragma experimental ABIEncoderV2;\\n\\nimport {IMulticall3} from \\\"./interfaces/IMulticall3.sol\\\";\\nimport {VmSafe} from \\\"./Vm.sol\\\";\\n\\nabstract contract StdUtils {\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                     CONSTANTS\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    IMulticall3 private constant multicall = IMulticall3(0xcA11bde05977b3631167028862bE2a173976CA11);\\n    VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(\\\"hevm cheat code\\\")))));\\n    address private constant CONSOLE2_ADDRESS = 0x000000000000000000636F6e736F6c652e6c6f67;\\n    uint256 private constant INT256_MIN_ABS =\\n        57896044618658097711785492504343953926634992332820282019728792003956564819968;\\n    uint256 private constant SECP256K1_ORDER =\\n        115792089237316195423570985008687907852837564279074904382605163141518161494337;\\n    uint256 private constant UINT256_MAX =\\n        115792089237316195423570985008687907853269984665640564039457584007913129639935;\\n\\n    // Used by default when deploying with create2, https://github.com/Arachnid/deterministic-deployment-proxy.\\n    address private constant CREATE2_FACTORY = 0x4e59b44847b379578588920cA78FbF26c0B4956C;\\n\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                 INTERNAL FUNCTIONS\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    function _bound(uint256 x, uint256 min, uint256 max) internal pure virtual returns (uint256 result) {\\n        require(min <= max, \\\"StdUtils bound(uint256,uint256,uint256): Max is less than min.\\\");\\n        // If x is between min and max, return x directly. This is to ensure that dictionary values\\n        // do not get shifted if the min is nonzero. More info: https://github.com/foundry-rs/forge-std/issues/188\\n        if (x >= min && x <= max) return x;\\n\\n        uint256 size = max - min + 1;\\n\\n        // If the value is 0, 1, 2, 3, wrap that to min, min+1, min+2, min+3. Similarly for the UINT256_MAX side.\\n        // This helps ensure coverage of the min/max values.\\n        if (x <= 3 && size > x) return min + x;\\n        if (x >= UINT256_MAX - 3 && size > UINT256_MAX - x) return max - (UINT256_MAX - x);\\n\\n        // Otherwise, wrap x into the range [min, max], i.e. the range is inclusive.\\n        if (x > max) {\\n            uint256 diff = x - max;\\n            uint256 rem = diff % size;\\n            if (rem == 0) return max;\\n            result = min + rem - 1;\\n        } else if (x < min) {\\n            uint256 diff = min - x;\\n            uint256 rem = diff % size;\\n            if (rem == 0) return min;\\n            result = max - rem + 1;\\n        }\\n    }\\n\\n    function bound(uint256 x, uint256 min, uint256 max) internal view virtual returns (uint256 result) {\\n        result = _bound(x, min, max);\\n        console2_log(\\\"Bound Result\\\", result);\\n    }\\n\\n    function _bound(int256 x, int256 min, int256 max) internal pure virtual returns (int256 result) {\\n        require(min <= max, \\\"StdUtils bound(int256,int256,int256): Max is less than min.\\\");\\n\\n        // Shifting all int256 values to uint256 to use _bound function. The range of two types are:\\n        // int256 : -(2**255) ~ (2**255 - 1)\\n        // uint256:     0     ~ (2**256 - 1)\\n        // So, add 2**255, INT256_MIN_ABS to the integer values.\\n        //\\n        // If the given integer value is -2**255, we cannot use `-uint256(-x)` because of the overflow.\\n        // So, use `~uint256(x) + 1` instead.\\n        uint256 _x = x < 0 ? (INT256_MIN_ABS - ~uint256(x) - 1) : (uint256(x) + INT256_MIN_ABS);\\n        uint256 _min = min < 0 ? (INT256_MIN_ABS - ~uint256(min) - 1) : (uint256(min) + INT256_MIN_ABS);\\n        uint256 _max = max < 0 ? (INT256_MIN_ABS - ~uint256(max) - 1) : (uint256(max) + INT256_MIN_ABS);\\n\\n        uint256 y = _bound(_x, _min, _max);\\n\\n        // To move it back to int256 value, subtract INT256_MIN_ABS at here.\\n        result = y < INT256_MIN_ABS ? int256(~(INT256_MIN_ABS - y) + 1) : int256(y - INT256_MIN_ABS);\\n    }\\n\\n    function bound(int256 x, int256 min, int256 max) internal view virtual returns (int256 result) {\\n        result = _bound(x, min, max);\\n        console2_log(\\\"Bound result\\\", vm.toString(result));\\n    }\\n\\n    function boundPrivateKey(uint256 privateKey) internal pure virtual returns (uint256 result) {\\n        result = _bound(privateKey, 1, SECP256K1_ORDER - 1);\\n    }\\n\\n    function bytesToUint(bytes memory b) internal pure virtual returns (uint256) {\\n        require(b.length <= 32, \\\"StdUtils bytesToUint(bytes): Bytes length exceeds 32.\\\");\\n        return abi.decode(abi.encodePacked(new bytes(32 - b.length), b), (uint256));\\n    }\\n\\n    /// @dev Compute the address a contract will be deployed at for a given deployer address and nonce\\n    /// @notice adapted from Solmate implementation (https://github.com/Rari-Capital/solmate/blob/main/src/utils/LibRLP.sol)\\n    function computeCreateAddress(address deployer, uint256 nonce) internal pure virtual returns (address) {\\n        // forgefmt: disable-start\\n        // The integer zero is treated as an empty byte string, and as a result it only has a length prefix, 0x80, computed via 0x80 + 0.\\n        // A one byte integer uses its own value as its length prefix, there is no additional \\\"0x80 + length\\\" prefix that comes before it.\\n        if (nonce == 0x00)      return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd6), bytes1(0x94), deployer, bytes1(0x80))));\\n        if (nonce <= 0x7f)      return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd6), bytes1(0x94), deployer, uint8(nonce))));\\n\\n        // Nonces greater than 1 byte all follow a consistent encoding scheme, where each value is preceded by a prefix of 0x80 + length.\\n        if (nonce <= 2**8 - 1)  return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd7), bytes1(0x94), deployer, bytes1(0x81), uint8(nonce))));\\n        if (nonce <= 2**16 - 1) return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd8), bytes1(0x94), deployer, bytes1(0x82), uint16(nonce))));\\n        if (nonce <= 2**24 - 1) return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd9), bytes1(0x94), deployer, bytes1(0x83), uint24(nonce))));\\n        // forgefmt: disable-end\\n\\n        // More details about RLP encoding can be found here: https://eth.wiki/fundamentals/rlp\\n        // 0xda = 0xc0 (short RLP prefix) + 0x16 (length of: 0x94 ++ proxy ++ 0x84 ++ nonce)\\n        // 0x94 = 0x80 + 0x14 (0x14 = the length of an address, 20 bytes, in hex)\\n        // 0x84 = 0x80 + 0x04 (0x04 = the bytes length of the nonce, 4 bytes, in hex)\\n        // We assume nobody can have a nonce large enough to require more than 32 bytes.\\n        return addressFromLast20Bytes(\\n            keccak256(abi.encodePacked(bytes1(0xda), bytes1(0x94), deployer, bytes1(0x84), uint32(nonce)))\\n        );\\n    }\\n\\n    function computeCreate2Address(bytes32 salt, bytes32 initcodeHash, address deployer)\\n        internal\\n        pure\\n        virtual\\n        returns (address)\\n    {\\n        return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xff), deployer, salt, initcodeHash)));\\n    }\\n\\n    /// @dev returns the address of a contract created with CREATE2 using the default CREATE2 deployer\\n    function computeCreate2Address(bytes32 salt, bytes32 initCodeHash) internal pure returns (address) {\\n        return computeCreate2Address(salt, initCodeHash, CREATE2_FACTORY);\\n    }\\n\\n    /// @dev returns the hash of the init code (creation code + no args) used in CREATE2 with no constructor arguments\\n    /// @param creationCode the creation code of a contract C, as returned by type(C).creationCode\\n    function hashInitCode(bytes memory creationCode) internal pure returns (bytes32) {\\n        return hashInitCode(creationCode, \\\"\\\");\\n    }\\n\\n    /// @dev returns the hash of the init code (creation code + ABI-encoded args) used in CREATE2\\n    /// @param creationCode the creation code of a contract C, as returned by type(C).creationCode\\n    /// @param args the ABI-encoded arguments to the constructor of C\\n    function hashInitCode(bytes memory creationCode, bytes memory args) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(creationCode, args));\\n    }\\n\\n    // Performs a single call with Multicall3 to query the ERC-20 token balances of the given addresses.\\n    function getTokenBalances(address token, address[] memory addresses)\\n        internal\\n        virtual\\n        returns (uint256[] memory balances)\\n    {\\n        uint256 tokenCodeSize;\\n        assembly {\\n            tokenCodeSize := extcodesize(token)\\n        }\\n        require(tokenCodeSize > 0, \\\"StdUtils getTokenBalances(address,address[]): Token address is not a contract.\\\");\\n\\n        // ABI encode the aggregate call to Multicall3.\\n        uint256 length = addresses.length;\\n        IMulticall3.Call[] memory calls = new IMulticall3.Call[](length);\\n        for (uint256 i = 0; i < length; ++i) {\\n            // 0x70a08231 = bytes4(\\\"balanceOf(address)\\\"))\\n            calls[i] = IMulticall3.Call({target: token, callData: abi.encodeWithSelector(0x70a08231, (addresses[i]))});\\n        }\\n\\n        // Make the aggregate call.\\n        (, bytes[] memory returnData) = multicall.aggregate(calls);\\n\\n        // ABI decode the return data and return the balances.\\n        balances = new uint256[](length);\\n        for (uint256 i = 0; i < length; ++i) {\\n            balances[i] = abi.decode(returnData[i], (uint256));\\n        }\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                 PRIVATE FUNCTIONS\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    function addressFromLast20Bytes(bytes32 bytesValue) private pure returns (address) {\\n        return address(uint160(uint256(bytesValue)));\\n    }\\n\\n    // Used to prevent the compilation of console, which shortens the compilation time when console is not used elsewhere.\\n\\n    function console2_log(string memory p0, uint256 p1) private view {\\n        (bool status,) = address(CONSOLE2_ADDRESS).staticcall(abi.encodeWithSignature(\\\"log(string,uint256)\\\", p0, p1));\\n        status;\\n    }\\n\\n    function console2_log(string memory p0, string memory p1) private view {\\n        (bool status,) = address(CONSOLE2_ADDRESS).staticcall(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\n        status;\\n    }\\n}\\n\"\r\n    },\r\n    \"../../node_modules/forge-std/src/Vm.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.2 <0.9.0;\\n\\npragma experimental ABIEncoderV2;\\n\\n// Cheatcodes are marked as view/pure/none using the following rules:\\n// 0. A call's observable behaviour includes its return value, logs, reverts and state writes,\\n// 1. If you can influence a later call's observable behaviour, you're neither `view` nor `pure (you are modifying some state be it the EVM, interpreter, filesystem, etc),\\n// 2. Otherwise if you can be influenced by an earlier call, or if reading some state, you're `view`,\\n// 3. Otherwise you're `pure`.\\n\\ninterface VmSafe {\\n    enum CallerMode {\\n        None,\\n        Broadcast,\\n        RecurrentBroadcast,\\n        Prank,\\n        RecurrentPrank\\n    }\\n\\n    struct Log {\\n        bytes32[] topics;\\n        bytes data;\\n        address emitter;\\n    }\\n\\n    struct Rpc {\\n        string key;\\n        string url;\\n    }\\n\\n    struct DirEntry {\\n        string errorMessage;\\n        string path;\\n        uint64 depth;\\n        bool isDir;\\n        bool isSymlink;\\n    }\\n\\n    struct FsMetadata {\\n        bool isDir;\\n        bool isSymlink;\\n        uint256 length;\\n        bool readOnly;\\n        uint256 modified;\\n        uint256 accessed;\\n        uint256 created;\\n    }\\n\\n    struct Wallet {\\n        address addr;\\n        uint256 publicKeyX;\\n        uint256 publicKeyY;\\n        uint256 privateKey;\\n    }\\n\\n    struct FfiResult {\\n        int32 exit_code;\\n        bytes stdout;\\n        bytes stderr;\\n    }\\n\\n    // Derives a private key from the name, labels the account with that name, and returns the wallet\\n    function createWallet(string calldata walletLabel) external returns (Wallet memory wallet);\\n    // Generates a wallet from the private key and returns the wallet\\n    function createWallet(uint256 privateKey) external returns (Wallet memory wallet);\\n    // Generates a wallet from the private key, labels the account with that name, and returns the wallet\\n    function createWallet(uint256 privateKey, string calldata walletLabel) external returns (Wallet memory wallet);\\n    // Signs data, (Wallet, digest) => (v, r, s)\\n    function sign(Wallet calldata wallet, bytes32 digest) external returns (uint8 v, bytes32 r, bytes32 s);\\n    // Get nonce for a Wallet\\n    function getNonce(Wallet calldata wallet) external returns (uint64 nonce);\\n\\n    // Loads a storage slot from an address\\n    function load(address target, bytes32 slot) external view returns (bytes32 data);\\n    // Signs data\\n    function sign(uint256 privateKey, bytes32 digest) external pure returns (uint8 v, bytes32 r, bytes32 s);\\n    // Gets the address for a given private key\\n    function addr(uint256 privateKey) external pure returns (address keyAddr);\\n    // Gets the nonce of an account\\n    function getNonce(address account) external view returns (uint64 nonce);\\n    // Performs a foreign function call via the terminal\\n    function ffi(string[] calldata commandInput) external returns (bytes memory result);\\n    // Performs a foreign function call via terminal and returns the exit code, stdout, and stderr\\n    function tryFfi(string[] calldata commandInput) external returns (FfiResult memory result);\\n    // Sets environment variables\\n    function setEnv(string calldata name, string calldata value) external;\\n    // Reads environment variables, (name) => (value)\\n    function envBool(string calldata name) external view returns (bool value);\\n    function envUint(string calldata name) external view returns (uint256 value);\\n    function envInt(string calldata name) external view returns (int256 value);\\n    function envAddress(string calldata name) external view returns (address value);\\n    function envBytes32(string calldata name) external view returns (bytes32 value);\\n    function envString(string calldata name) external view returns (string memory value);\\n    function envBytes(string calldata name) external view returns (bytes memory value);\\n    // Reads environment variables as arrays\\n    function envBool(string calldata name, string calldata delim) external view returns (bool[] memory value);\\n    function envUint(string calldata name, string calldata delim) external view returns (uint256[] memory value);\\n    function envInt(string calldata name, string calldata delim) external view returns (int256[] memory value);\\n    function envAddress(string calldata name, string calldata delim) external view returns (address[] memory value);\\n    function envBytes32(string calldata name, string calldata delim) external view returns (bytes32[] memory value);\\n    function envString(string calldata name, string calldata delim) external view returns (string[] memory value);\\n    function envBytes(string calldata name, string calldata delim) external view returns (bytes[] memory value);\\n    // Read environment variables with default value\\n    function envOr(string calldata name, bool defaultValue) external returns (bool value);\\n    function envOr(string calldata name, uint256 defaultValue) external returns (uint256 value);\\n    function envOr(string calldata name, int256 defaultValue) external returns (int256 value);\\n    function envOr(string calldata name, address defaultValue) external returns (address value);\\n    function envOr(string calldata name, bytes32 defaultValue) external returns (bytes32 value);\\n    function envOr(string calldata name, string calldata defaultValue) external returns (string memory value);\\n    function envOr(string calldata name, bytes calldata defaultValue) external returns (bytes memory value);\\n    // Read environment variables as arrays with default value\\n    function envOr(string calldata name, string calldata delim, bool[] calldata defaultValue)\\n        external\\n        returns (bool[] memory value);\\n    function envOr(string calldata name, string calldata delim, uint256[] calldata defaultValue)\\n        external\\n        returns (uint256[] memory value);\\n    function envOr(string calldata name, string calldata delim, int256[] calldata defaultValue)\\n        external\\n        returns (int256[] memory value);\\n    function envOr(string calldata name, string calldata delim, address[] calldata defaultValue)\\n        external\\n        returns (address[] memory value);\\n    function envOr(string calldata name, string calldata delim, bytes32[] calldata defaultValue)\\n        external\\n        returns (bytes32[] memory value);\\n    function envOr(string calldata name, string calldata delim, string[] calldata defaultValue)\\n        external\\n        returns (string[] memory value);\\n    function envOr(string calldata name, string calldata delim, bytes[] calldata defaultValue)\\n        external\\n        returns (bytes[] memory value);\\n    // Records all storage reads and writes\\n    function record() external;\\n    // Gets all accessed reads and write slot from a recording session, for a given address\\n    function accesses(address target) external returns (bytes32[] memory readSlots, bytes32[] memory writeSlots);\\n    // Gets the _creation_ bytecode from an artifact file. Takes in the relative path to the json file\\n    function getCode(string calldata artifactPath) external view returns (bytes memory creationBytecode);\\n    // Gets the _deployed_ bytecode from an artifact file. Takes in the relative path to the json file\\n    function getDeployedCode(string calldata artifactPath) external view returns (bytes memory runtimeBytecode);\\n    // Labels an address in call traces\\n    function label(address account, string calldata newLabel) external;\\n    // Gets the label for the specified address\\n    function getLabel(address account) external returns (string memory currentLabel);\\n    // Using the address that calls the test contract, has the next call (at this call depth only) create a transaction that can later be signed and sent onchain\\n    function broadcast() external;\\n    // Has the next call (at this call depth only) create a transaction with the address provided as the sender that can later be signed and sent onchain\\n    function broadcast(address signer) external;\\n    // Has the next call (at this call depth only) create a transaction with the private key provided as the sender that can later be signed and sent onchain\\n    function broadcast(uint256 privateKey) external;\\n    // Using the address that calls the test contract, has all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain\\n    function startBroadcast() external;\\n    // Has all subsequent calls (at this call depth only) create transactions with the address provided that can later be signed and sent onchain\\n    function startBroadcast(address signer) external;\\n    // Has all subsequent calls (at this call depth only) create transactions with the private key provided that can later be signed and sent onchain\\n    function startBroadcast(uint256 privateKey) external;\\n    // Stops collecting onchain transactions\\n    function stopBroadcast() external;\\n\\n    // Get the path of the current project root.\\n    function projectRoot() external view returns (string memory path);\\n    // Reads the entire content of file to string. `path` is relative to the project root.\\n    function readFile(string calldata path) external view returns (string memory data);\\n    // Reads the entire content of file as binary. `path` is relative to the project root.\\n    function readFileBinary(string calldata path) external view returns (bytes memory data);\\n    // Reads next line of file to string.\\n    function readLine(string calldata path) external view returns (string memory line);\\n    // Writes data to file, creating a file if it does not exist, and entirely replacing its contents if it does.\\n    // `path` is relative to the project root.\\n    function writeFile(string calldata path, string calldata data) external;\\n    // Writes binary data to a file, creating a file if it does not exist, and entirely replacing its contents if it does.\\n    // `path` is relative to the project root.\\n    function writeFileBinary(string calldata path, bytes calldata data) external;\\n    // Writes line to file, creating a file if it does not exist.\\n    // `path` is relative to the project root.\\n    function writeLine(string calldata path, string calldata data) external;\\n    // Copies the contents of one file to another. This function will **overwrite** the contents of `to`.\\n    // On success, the total number of bytes copied is returned and it is equal to the length of the `to` file as reported by `metadata`.\\n    // Both `from` and `to` are relative to the project root.\\n    function copyFile(string calldata from, string calldata to) external returns (uint64 copied);\\n    // Closes file for reading, resetting the offset and allowing to read it from beginning with readLine.\\n    // `path` is relative to the project root.\\n    function closeFile(string calldata path) external;\\n    // Removes a file from the filesystem.\\n    // This cheatcode will revert in the following situations, but is not limited to just these cases:\\n    // - `path` points to a directory.\\n    // - The file doesn't exist.\\n    // - The user lacks permissions to remove the file.\\n    // `path` is relative to the project root.\\n    function removeFile(string calldata path) external;\\n    // Creates a new, empty directory at the provided path.\\n    // This cheatcode will revert in the following situations, but is not limited to just these cases:\\n    // - User lacks permissions to modify `path`.\\n    // - A parent of the given path doesn't exist and `recursive` is false.\\n    // - `path` already exists and `recursive` is false.\\n    // `path` is relative to the project root.\\n    function createDir(string calldata path, bool recursive) external;\\n    // Removes a directory at the provided path.\\n    // This cheatcode will revert in the following situations, but is not limited to just these cases:\\n    // - `path` doesn't exist.\\n    // - `path` isn't a directory.\\n    // - User lacks permissions to modify `path`.\\n    // - The directory is not empty and `recursive` is false.\\n    // `path` is relative to the project root.\\n    function removeDir(string calldata path, bool recursive) external;\\n    // Reads the directory at the given path recursively, up to `max_depth`.\\n    // `max_depth` defaults to 1, meaning only the direct children of the given directory will be returned.\\n    // Follows symbolic links if `follow_links` is true.\\n    function readDir(string calldata path) external view returns (DirEntry[] memory entries);\\n    function readDir(string calldata path, uint64 maxDepth) external view returns (DirEntry[] memory entries);\\n    function readDir(string calldata path, uint64 maxDepth, bool followLinks)\\n        external\\n        view\\n        returns (DirEntry[] memory entries);\\n    // Reads a symbolic link, returning the path that the link points to.\\n    // This cheatcode will revert in the following situations, but is not limited to just these cases:\\n    // - `path` is not a symbolic link.\\n    // - `path` does not exist.\\n    function readLink(string calldata linkPath) external view returns (string memory targetPath);\\n    // Given a path, query the file system to get information about a file, directory, etc.\\n    function fsMetadata(string calldata path) external view returns (FsMetadata memory metadata);\\n    // Returns true if the given path points to an existing entity, else returns false\\n    function exists(string calldata path) external returns (bool result);\\n    // Returns true if the path exists on disk and is pointing at a regular file, else returns false\\n    function isFile(string calldata path) external returns (bool result);\\n    // Returns true if the path exists on disk and is pointing at a directory, else returns false\\n    function isDir(string calldata path) external returns (bool result);\\n\\n    // Convert values to a string\\n    function toString(address value) external pure returns (string memory stringifiedValue);\\n    function toString(bytes calldata value) external pure returns (string memory stringifiedValue);\\n    function toString(bytes32 value) external pure returns (string memory stringifiedValue);\\n    function toString(bool value) external pure returns (string memory stringifiedValue);\\n    function toString(uint256 value) external pure returns (string memory stringifiedValue);\\n    function toString(int256 value) external pure returns (string memory stringifiedValue);\\n    // Convert values from a string\\n    function parseBytes(string calldata stringifiedValue) external pure returns (bytes memory parsedValue);\\n    function parseAddress(string calldata stringifiedValue) external pure returns (address parsedValue);\\n    function parseUint(string calldata stringifiedValue) external pure returns (uint256 parsedValue);\\n    function parseInt(string calldata stringifiedValue) external pure returns (int256 parsedValue);\\n    function parseBytes32(string calldata stringifiedValue) external pure returns (bytes32 parsedValue);\\n    function parseBool(string calldata stringifiedValue) external pure returns (bool parsedValue);\\n    // Record all the transaction logs\\n    function recordLogs() external;\\n    // Gets all the recorded logs\\n    function getRecordedLogs() external returns (Log[] memory logs);\\n    // Derive a private key from a provided mnenomic string (or mnenomic file path) at the derivation path m/44'/60'/0'/0/{index}\\n    function deriveKey(string calldata mnemonic, uint32 index) external pure returns (uint256 privateKey);\\n    // Derive a private key from a provided mnenomic string (or mnenomic file path) at {derivationPath}{index}\\n    function deriveKey(string calldata mnemonic, string calldata derivationPath, uint32 index)\\n        external\\n        pure\\n        returns (uint256 privateKey);\\n    // Adds a private key to the local forge wallet and returns the address\\n    function rememberKey(uint256 privateKey) external returns (address keyAddr);\\n    //\\n    // parseJson\\n    //\\n    // ----\\n    // In case the returned value is a JSON object, it's encoded as a ABI-encoded tuple. As JSON objects\\n    // don't have the notion of ordered, but tuples do, they JSON object is encoded with it's fields ordered in\\n    // ALPHABETICAL order. That means that in order to successfully decode the tuple, we need to define a tuple that\\n    // encodes the fields in the same order, which is alphabetical. In the case of Solidity structs, they are encoded\\n    // as tuples, with the attributes in the order in which they are defined.\\n    // For example: json = { 'a': 1, 'b': 0xa4tb......3xs}\\n    // a: uint256\\n    // b: address\\n    // To decode that json, we need to define a struct or a tuple as follows:\\n    // struct json = { uint256 a; address b; }\\n    // If we defined a json struct with the opposite order, meaning placing the address b first, it would try to\\n    // decode the tuple in that order, and thus fail.\\n    // ----\\n    // Given a string of JSON, return it as ABI-encoded\\n    function parseJson(string calldata json, string calldata key) external pure returns (bytes memory abiEncodedData);\\n    function parseJson(string calldata json) external pure returns (bytes memory abiEncodedData);\\n\\n    // The following parseJson cheatcodes will do type coercion, for the type that they indicate.\\n    // For example, parseJsonUint will coerce all values to a uint256. That includes stringified numbers '12'\\n    // and hex numbers '0xEF'.\\n    // Type coercion works ONLY for discrete values or arrays. That means that the key must return a value or array, not\\n    // a JSON object.\\n    function parseJsonUint(string calldata json, string calldata key) external pure returns (uint256);\\n    function parseJsonUintArray(string calldata json, string calldata key) external pure returns (uint256[] memory);\\n    function parseJsonInt(string calldata json, string calldata key) external pure returns (int256);\\n    function parseJsonIntArray(string calldata json, string calldata key) external pure returns (int256[] memory);\\n    function parseJsonBool(string calldata json, string calldata key) external pure returns (bool);\\n    function parseJsonBoolArray(string calldata json, string calldata key) external pure returns (bool[] memory);\\n    function parseJsonAddress(string calldata json, string calldata key) external pure returns (address);\\n    function parseJsonAddressArray(string calldata json, string calldata key)\\n        external\\n        pure\\n        returns (address[] memory);\\n    function parseJsonString(string calldata json, string calldata key) external pure returns (string memory);\\n    function parseJsonStringArray(string calldata json, string calldata key) external pure returns (string[] memory);\\n    function parseJsonBytes(string calldata json, string calldata key) external pure returns (bytes memory);\\n    function parseJsonBytesArray(string calldata json, string calldata key) external pure returns (bytes[] memory);\\n    function parseJsonBytes32(string calldata json, string calldata key) external pure returns (bytes32);\\n    function parseJsonBytes32Array(string calldata json, string calldata key)\\n        external\\n        pure\\n        returns (bytes32[] memory);\\n\\n    // Checks if a key exists in a JSON or TOML object.\\n    function keyExists(string calldata json, string calldata key) external view returns (bool);\\n\\n    // Returns array of keys for a JSON object\\n    function parseJsonKeys(string calldata json, string calldata key) external returns (string[] memory keys);\\n\\n    // Serialize a key and value to a JSON object stored in-memory that can be later written to a file\\n    // It returns the stringified version of the specific JSON file up to that moment.\\n    function serializeBool(string calldata objectKey, string calldata valueKey, bool value)\\n        external\\n        returns (string memory json);\\n    function serializeUint(string calldata objectKey, string calldata valueKey, uint256 value)\\n        external\\n        returns (string memory json);\\n    function serializeInt(string calldata objectKey, string calldata valueKey, int256 value)\\n        external\\n        returns (string memory json);\\n    function serializeAddress(string calldata objectKey, string calldata valueKey, address value)\\n        external\\n        returns (string memory json);\\n    function serializeBytes32(string calldata objectKey, string calldata valueKey, bytes32 value)\\n        external\\n        returns (string memory json);\\n    function serializeString(string calldata objectKey, string calldata valueKey, string calldata value)\\n        external\\n        returns (string memory json);\\n    function serializeBytes(string calldata objectKey, string calldata valueKey, bytes calldata value)\\n        external\\n        returns (string memory json);\\n\\n    function serializeBool(string calldata objectKey, string calldata valueKey, bool[] calldata values)\\n        external\\n        returns (string memory json);\\n    function serializeUint(string calldata objectKey, string calldata valueKey, uint256[] calldata values)\\n        external\\n        returns (string memory json);\\n    function serializeInt(string calldata objectKey, string calldata valueKey, int256[] calldata values)\\n        external\\n        returns (string memory json);\\n    function serializeAddress(string calldata objectKey, string calldata valueKey, address[] calldata values)\\n        external\\n        returns (string memory json);\\n    function serializeBytes32(string calldata objectKey, string calldata valueKey, bytes32[] calldata values)\\n        external\\n        returns (string memory json);\\n    function serializeString(string calldata objectKey, string calldata valueKey, string[] calldata values)\\n        external\\n        returns (string memory json);\\n    function serializeBytes(string calldata objectKey, string calldata valueKey, bytes[] calldata values)\\n        external\\n        returns (string memory json);\\n\\n    //\\n    // writeJson\\n    //\\n    // ----\\n    // Write a serialized JSON object to a file. If the file exists, it will be overwritten.\\n    // Let's assume we want to write the following JSON to a file:\\n    //\\n    // { \\\"boolean\\\": true, \\\"number\\\": 342, \\\"object\\\": { \\\"title\\\": \\\"finally json serialization\\\" } }\\n    //\\n    // ```\\n    //  string memory json1 = \\\"some key\\\";\\n    //  vm.serializeBool(json1, \\\"boolean\\\", true);\\n    //  vm.serializeBool(json1, \\\"number\\\", uint256(342));\\n    //  json2 = \\\"some other key\\\";\\n    //  string memory output = vm.serializeString(json2, \\\"title\\\", \\\"finally json serialization\\\");\\n    //  string memory finalJson = vm.serialize(json1, \\\"object\\\", output);\\n    //  vm.writeJson(finalJson, \\\"./output/example.json\\\");\\n    // ```\\n    // The critical insight is that every invocation of serialization will return the stringified version of the JSON\\n    // up to that point. That means we can construct arbitrary JSON objects and then use the return stringified version\\n    // to serialize them as values to another JSON object.\\n    //\\n    // json1 and json2 are simply keys used by the backend to keep track of the objects. So vm.serializeJson(json1,..)\\n    // will find the object in-memory that is keyed by \\\"some key\\\".\\n    function writeJson(string calldata json, string calldata path) external;\\n    // Write a serialized JSON object to an **existing** JSON file, replacing a value with key = <value_key>\\n    // This is useful to replace a specific value of a JSON file, without having to parse the entire thing\\n    function writeJson(string calldata json, string calldata path, string calldata valueKey) external;\\n    // Returns the RPC url for the given alias\\n    function rpcUrl(string calldata rpcAlias) external view returns (string memory json);\\n    // Returns all rpc urls and their aliases `[alias, url][]`\\n    function rpcUrls() external view returns (string[2][] memory urls);\\n    // Returns all rpc urls and their aliases as structs.\\n    function rpcUrlStructs() external view returns (Rpc[] memory urls);\\n    // If the condition is false, discard this run's fuzz inputs and generate new ones.\\n    function assume(bool condition) external pure;\\n    // Pauses gas metering (i.e. gas usage is not counted). Noop if already paused.\\n    function pauseGasMetering() external;\\n    // Resumes gas metering (i.e. gas usage is counted again). Noop if already on.\\n    function resumeGasMetering() external;\\n    // Starts recording all map SSTOREs for later retrieval.\\n    function startMappingRecording() external;\\n    // Stops recording all map SSTOREs for later retrieval and clears the recorded data.\\n    function stopMappingRecording() external;\\n    // Gets the number of elements in the mapping at the given slot, for a given address.\\n    function getMappingLength(address target, bytes32 mappingSlot) external returns (uint256 length);\\n    // Gets the elements at index idx of the mapping at the given slot, for a given address. The\\n    // index must be less than the length of the mapping (i.e. the number of keys in the mapping).\\n    function getMappingSlotAt(address target, bytes32 mappingSlot, uint256 idx) external returns (bytes32 value);\\n    // Gets the map key and parent of a mapping at a given slot, for a given address.\\n    function getMappingKeyAndParentOf(address target, bytes32 elementSlot)\\n        external\\n        returns (bool found, bytes32 key, bytes32 parent);\\n    // Writes a breakpoint to jump to in the debugger\\n    function breakpoint(string calldata char) external;\\n    // Writes a conditional breakpoint to jump to in the debugger\\n    function breakpoint(string calldata char, bool value) external;\\n    // Suspends execution of the main thread for `duration` milliseconds\\n    function sleep(uint256 duration) external;\\n}\\n\\ninterface Vm is VmSafe {\\n    // Sets block.timestamp\\n    function warp(uint256 newTimestamp) external;\\n    // Sets block.height\\n    function roll(uint256 newHeight) external;\\n    // Sets block.basefee\\n    function fee(uint256 newBasefee) external;\\n    // Sets block.difficulty\\n    // Not available on EVM versions from Paris onwards. Use `prevrandao` instead.\\n    // If used on unsupported EVM versions it will revert.\\n    function difficulty(uint256 newDifficulty) external;\\n    // Sets block.prevrandao\\n    // Not available on EVM versions before Paris. Use `difficulty` instead.\\n    // If used on unsupported EVM versions it will revert.\\n    function prevrandao(bytes32 newPrevrandao) external;\\n    // Sets block.chainid\\n    function chainId(uint256 newChainId) external;\\n    // Sets tx.gasprice\\n    function txGasPrice(uint256 newGasPrice) external;\\n    // Stores a value to an address' storage slot.\\n    function store(address target, bytes32 slot, bytes32 value) external;\\n    // Sets the nonce of an account; must be higher than the current nonce of the account\\n    function setNonce(address account, uint64 newNonce) external;\\n    // Sets the nonce of an account to an arbitrary value\\n    function setNonceUnsafe(address account, uint64 newNonce) external;\\n    // Resets the nonce of an account to 0 for EOAs and 1 for contract accounts\\n    function resetNonce(address account) external;\\n    // Sets the *next* call's msg.sender to be the input address\\n    function prank(address msgSender) external;\\n    // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called\\n    function startPrank(address msgSender) external;\\n    // Sets the *next* call's msg.sender to be the input address, and the tx.origin to be the second input\\n    function prank(address msgSender, address txOrigin) external;\\n    // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called, and the tx.origin to be the second input\\n    function startPrank(address msgSender, address txOrigin) external;\\n    // Resets subsequent calls' msg.sender to be `address(this)`\\n    function stopPrank() external;\\n    // Reads the current `msg.sender` and `tx.origin` from state and reports if there is any active caller modification\\n    function readCallers() external returns (CallerMode callerMode, address msgSender, address txOrigin);\\n    // Sets an address' balance\\n    function deal(address account, uint256 newBalance) external;\\n    // Sets an address' code\\n    function etch(address target, bytes calldata newRuntimeBytecode) external;\\n    // Marks a test as skipped. Must be called at the top of the test.\\n    function skip(bool skipTest) external;\\n    // Expects an error on next call\\n    function expectRevert(bytes calldata revertData) external;\\n    function expectRevert(bytes4 revertData) external;\\n    function expectRevert() external;\\n\\n    // Prepare an expected log with all four checks enabled.\\n    // Call this function, then emit an event, then call a function. Internally after the call, we check if\\n    // logs were emitted in the expected order with the expected topics and data.\\n    // Second form also checks supplied address against emitting contract.\\n    function expectEmit() external;\\n    function expectEmit(address emitter) external;\\n\\n    // Prepare an expected log with (bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData).\\n    // Call this function, then emit an event, then call a function. Internally after the call, we check if\\n    // logs were emitted in the expected order with the expected topics and data (as specified by the booleans).\\n    // Second form also checks supplied address against emitting contract.\\n    function expectEmit(bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData) external;\\n    function expectEmit(bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData, address emitter)\\n        external;\\n\\n    // Mocks a call to an address, returning specified data.\\n    // Calldata can either be strict or a partial match, e.g. if you only\\n    // pass a Solidity selector to the expected calldata, then the entire Solidity\\n    // function will be mocked.\\n    function mockCall(address callee, bytes calldata data, bytes calldata returnData) external;\\n    // Mocks a call to an address with a specific msg.value, returning specified data.\\n    // Calldata match takes precedence over msg.value in case of ambiguity.\\n    function mockCall(address callee, uint256 msgValue, bytes calldata data, bytes calldata returnData) external;\\n    // Reverts a call to an address with specified revert data.\\n    function mockCallRevert(address callee, bytes calldata data, bytes calldata revertData) external;\\n    // Reverts a call to an address with a specific msg.value, with specified revert data.\\n    function mockCallRevert(address callee, uint256 msgValue, bytes calldata data, bytes calldata revertData)\\n        external;\\n    // Clears all mocked calls\\n    function clearMockedCalls() external;\\n    // Expects a call to an address with the specified calldata.\\n    // Calldata can either be a strict or a partial match\\n    function expectCall(address callee, bytes calldata data) external;\\n    // Expects given number of calls to an address with the specified calldata.\\n    function expectCall(address callee, bytes calldata data, uint64 count) external;\\n    // Expects a call to an address with the specified msg.value and calldata\\n    function expectCall(address callee, uint256 msgValue, bytes calldata data) external;\\n    // Expects given number of calls to an address with the specified msg.value and calldata\\n    function expectCall(address callee, uint256 msgValue, bytes calldata data, uint64 count) external;\\n    // Expect a call to an address with the specified msg.value, gas, and calldata.\\n    function expectCall(address callee, uint256 msgValue, uint64 gas, bytes calldata data) external;\\n    // Expects given number of calls to an address with the specified msg.value, gas, and calldata.\\n    function expectCall(address callee, uint256 msgValue, uint64 gas, bytes calldata data, uint64 count) external;\\n    // Expect a call to an address with the specified msg.value and calldata, and a *minimum* amount of gas.\\n    function expectCallMinGas(address callee, uint256 msgValue, uint64 minGas, bytes calldata data) external;\\n    // Expect given number of calls to an address with the specified msg.value and calldata, and a *minimum* amount of gas.\\n    function expectCallMinGas(address callee, uint256 msgValue, uint64 minGas, bytes calldata data, uint64 count)\\n        external;\\n    // Only allows memory writes to offsets [0x00, 0x60) \u222a [min, max) in the current subcontext. If any other\\n    // memory is written to, the test will fail. Can be called multiple times to add more ranges to the set.\\n    function expectSafeMemory(uint64 min, uint64 max) external;\\n    // Only allows memory writes to offsets [0x00, 0x60) \u222a [min, max) in the next created subcontext.\\n    // If any other memory is written to, the test will fail. Can be called multiple times to add more ranges\\n    // to the set.\\n    function expectSafeMemoryCall(uint64 min, uint64 max) external;\\n    // Sets block.coinbase\\n    function coinbase(address newCoinbase) external;\\n    // Snapshot the current state of the evm.\\n    // Returns the id of the snapshot that was created.\\n    // To revert a snapshot use `revertTo`\\n    function snapshot() external returns (uint256 snapshotId);\\n    // Revert the state of the EVM to a previous snapshot\\n    // Takes the snapshot id to revert to.\\n    // This deletes the snapshot and all snapshots taken after the given snapshot id.\\n    function revertTo(uint256 snapshotId) external returns (bool success);\\n    // Creates a new fork with the given endpoint and block and returns the identifier of the fork\\n    function createFork(string calldata urlOrAlias, uint256 blockNumber) external returns (uint256 forkId);\\n    // Creates a new fork with the given endpoint and the _latest_ block and returns the identifier of the fork\\n    function createFork(string calldata urlOrAlias) external returns (uint256 forkId);\\n    // Creates a new fork with the given endpoint and at the block the given transaction was mined in, replays all transaction mined in the block before the transaction,\\n    // and returns the identifier of the fork\\n    function createFork(string calldata urlOrAlias, bytes32 txHash) external returns (uint256 forkId);\\n    // Creates _and_ also selects a new fork with the given endpoint and block and returns the identifier of the fork\\n    function createSelectFork(string calldata urlOrAlias, uint256 blockNumber) external returns (uint256 forkId);\\n    // Creates _and_ also selects new fork with the given endpoint and at the block the given transaction was mined in, replays all transaction mined in the block before\\n    // the transaction, returns the identifier of the fork\\n    function createSelectFork(string calldata urlOrAlias, bytes32 txHash) external returns (uint256 forkId);\\n    // Creates _and_ also selects a new fork with the given endpoint and the latest block and returns the identifier of the fork\\n    function createSelectFork(string calldata urlOrAlias) external returns (uint256 forkId);\\n    // Takes a fork identifier created by `createFork` and sets the corresponding forked state as active.\\n    function selectFork(uint256 forkId) external;\\n    /// Returns the identifier of the currently active fork. Reverts if no fork is currently active.\\n    function activeFork() external view returns (uint256 forkId);\\n    // Updates the currently active fork to given block number\\n    // This is similar to `roll` but for the currently active fork\\n    function rollFork(uint256 blockNumber) external;\\n    // Updates the currently active fork to given transaction\\n    // this will `rollFork` with the number of the block the transaction was mined in and replays all transaction mined before it in the block\\n    function rollFork(bytes32 txHash) external;\\n    // Updates the given fork to given block number\\n    function rollFork(uint256 forkId, uint256 blockNumber) external;\\n    // Updates the given fork to block number of the given transaction and replays all transaction mined before it in the block\\n    function rollFork(uint256 forkId, bytes32 txHash) external;\\n    // Marks that the account(s) should use persistent storage across fork swaps in a multifork setup\\n    // Meaning, changes made to the state of this account will be kept when switching forks\\n    function makePersistent(address account) external;\\n    function makePersistent(address account0, address account1) external;\\n    function makePersistent(address account0, address account1, address account2) external;\\n    function makePersistent(address[] calldata accounts) external;\\n    // Revokes persistent status from the address, previously added via `makePersistent`\\n    function revokePersistent(address account) external;\\n    function revokePersistent(address[] calldata accounts) external;\\n    // Returns true if the account is marked as persistent\\n    function isPersistent(address account) external view returns (bool persistent);\\n    // In forking mode, explicitly grant the given address cheatcode access\\n    function allowCheatcodes(address account) external;\\n    // Fetches the given transaction from the active fork and executes it on the current state\\n    function transact(bytes32 txHash) external;\\n    // Fetches the given transaction from the given fork and executes it on the current state\\n    function transact(uint256 forkId, bytes32 txHash) external;\\n}\\n\"\r\n    },\r\n    \"../../node_modules/forge-std/src/Base.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.2 <0.9.0;\\n\\nimport {StdStorage} from \\\"./StdStorage.sol\\\";\\nimport {Vm, VmSafe} from \\\"./Vm.sol\\\";\\n\\nabstract contract CommonBase {\\n    // Cheat code address, 0x7109709ECfa91a80626fF3989D68f67F5b1DD12D.\\n    address internal constant VM_ADDRESS = address(uint160(uint256(keccak256(\\\"hevm cheat code\\\"))));\\n    // console.sol and console2.sol work by executing a staticcall to this address.\\n    address internal constant CONSOLE = 0x000000000000000000636F6e736F6c652e6c6f67;\\n    // Used when deploying with create2, https://github.com/Arachnid/deterministic-deployment-proxy.\\n    address internal constant CREATE2_FACTORY = 0x4e59b44847b379578588920cA78FbF26c0B4956C;\\n    // Default address for tx.origin and msg.sender, 0x1804c8AB1F12E6bbf3894d4083f33e07309d1f38.\\n    address internal constant DEFAULT_SENDER = address(uint160(uint256(keccak256(\\\"foundry default caller\\\"))));\\n    // Address of the test contract, deployed by the DEFAULT_SENDER.\\n    address internal constant DEFAULT_TEST_CONTRACT = 0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f;\\n    // Deterministic deployment address of the Multicall3 contract.\\n    address internal constant MULTICALL3_ADDRESS = 0xcA11bde05977b3631167028862bE2a173976CA11;\\n    // The order of the secp256k1 curve.\\n    uint256 internal constant SECP256K1_ORDER =\\n        115792089237316195423570985008687907852837564279074904382605163141518161494337;\\n\\n    uint256 internal constant UINT256_MAX =\\n        115792089237316195423570985008687907853269984665640564039457584007913129639935;\\n\\n    Vm internal constant vm = Vm(VM_ADDRESS);\\n    StdStorage internal stdstore;\\n}\\n\\nabstract contract TestBase is CommonBase {}\\n\\nabstract contract ScriptBase is CommonBase {\\n    VmSafe internal constant vmSafe = VmSafe(VM_ADDRESS);\\n}\\n\"\r\n    },\r\n    \"../../node_modules/@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"src/BorrowLogic/BorrowHandlers.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.21;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nimport {IBorrowHandlers} from \\\"../interface/IBorrowHandlers.sol\\\";\\n\\nimport {BorrowCheckers} from \\\"./BorrowCheckers.sol\\\";\\nimport {CollateralState, NFToken, OfferArg, Ray} from \\\"../DataStructure/Objects.sol\\\";\\nimport {Loan, Payment, Protocol, Provision, Auction} from \\\"../DataStructure/Storage.sol\\\";\\nimport {ONE, protocolStorage} from \\\"../DataStructure/Global.sol\\\";\\nimport {RayMath} from \\\"../utils/RayMath.sol\\\";\\nimport {Erc20CheckedTransfer} from \\\"../utils/Erc20CheckedTransfer.sol\\\";\\nimport {SafeMint} from \\\"../SupplyPositionLogic/SafeMint.sol\\\";\\n// solhint-disable-next-line max-line-length\\nimport {RequestedAmountTooHigh, UnsafeAmountLent, MultipleOffersUsed, ShareMatchedIsTooLow} from \\\"../DataStructure/Errors.sol\\\";\\n\\n/// @notice handles usage of entities to borrow with\\nabstract contract BorrowHandlers is IBorrowHandlers, BorrowCheckers, SafeMint {\\n    using RayMath for uint256;\\n    using RayMath for Ray;\\n    using Erc20CheckedTransfer for IERC20;\\n\\n    Ray private immutable minShareLent;\\n\\n    constructor() {\\n        /* see testWorstCaseEstimatedValue() in RayMath.t.sol for the test showing worst case considered values\\n        in the return value calculation of AuctionFacet.sol's price(uint256 loanId) method */\\n        minShareLent = ONE.div(100_000_000);\\n    }\\n\\n    /// @notice handles usage of a loan offer to borrow from\\n    /// @param arg arguments for the usage of this offer\\n    /// @param collatState tracked state of the matching of the collateral\\n    /// @return collateralState updated `collatState` after usage of the offer\\n    /// @return signer computed signer of `arg`\\n    function useOffer(\\n        OfferArg memory arg,\\n        CollateralState memory collatState\\n    ) internal view returns (CollateralState memory, address) {\\n        address signer = checkOfferArg(arg);\\n        Ray shareMatched;\\n\\n        checkCollateral(arg.offer, collatState.nft, arg.merkleProof);\\n\\n        // we keep track of the share of the maximum value (`loanToValue`) proposed by an offer used by the borrower.\\n        shareMatched = arg.amount.div(arg.offer.loanToValue);\\n\\n        // a 0 share or too low can lead to DOS, cf https://github.com/sherlock-audit/2023-02-kairos-judging/issues/76\\n        if (shareMatched.lt(minShareLent)) {\\n            revert ShareMatchedIsTooLow(arg.offer, arg.amount);\\n        }\\n\\n        collatState.matched = collatState.matched.add(shareMatched);\\n\\n        /* we consider that lenders are acquiring shares of the NFT used as collateral by lending the amount\\n        corresponding to shareMatched. We check this process is not ditributing more shares than the full NFT value. */\\n        if (collatState.matched.gt(ONE)) {\\n            revert RequestedAmountTooHigh(\\n                arg.amount,\\n                arg.offer.loanToValue.mul(ONE.sub(collatState.matched.sub(shareMatched))),\\n                arg.offer\\n            );\\n        }\\n\\n        return (collatState, signer);\\n    }\\n\\n    /// @notice handles usage of one collateral to back a loan request\\n    /// @param args arguments for usage of one or multiple loan offers\\n    /// @param from borrower for this loan\\n    /// @param nft collateral to use\\n    /// @return loanId the id of the loan created backed by provided collateral\\n    function useCollateral(OfferArg[] memory args, address from, NFToken memory nft) internal returns (uint256 loanId) {\\n        address signer;\\n        CollateralState memory collatState = initializedCollateralState(args[0], from, nft);\\n\\n        /* following the sherlock audit, we found some possible manipulations in multi offers loans. This condition is\\n        change-minimized prevention to this, keeping the code as close to the reviewed version as possible. An optimized\\n        Kairos Loan v2 will soon be published. */\\n        if (args.length > 1) {\\n            revert MultipleOffersUsed();\\n        }\\n\\n        (collatState, signer) = useOffer(args[0], collatState);\\n        uint256 lent = args[0].amount;\\n\\n        // cf RepayFacet for the rationale of this check. We prevent repaying being impossible due to an overflow in the\\n        // interests to repay calculation.\\n        if (lent > 1e40) {\\n            revert UnsafeAmountLent(lent);\\n        }\\n        Loan memory loan = initializedLoan(collatState, from, nft, lent);\\n        protocolStorage().loan[collatState.loanId] = loan;\\n\\n        // transferring the borrowed funds from the lender to the borrower\\n        collatState.assetLent.checkedTransferFrom(signer, collatState.from, lent);\\n\\n        /* issuing supply position NFT to the signer of the loan offer with metadatas\\n        The only position of the loan is not minted in useOffer but in the end of this functions as a way to better\\n        follow the checks-effects-interactions pattern as it includes an external call, to prevent unforseen\\n        consequences of a reentrency. */\\n        safeMint(signer, Provision({amount: lent, share: collatState.matched, loanId: collatState.loanId}));\\n\\n        emit Borrow(collatState.loanId, abi.encode(loan));\\n\\n        return collatState.loanId;\\n    }\\n\\n    /// @notice initializes the collateral state memory struct used to keep track of the collateralization and other\\n    ///     health checks variables during the issuance of a loan\\n    /// @param firstOfferArg the first struct of arguments for an offer among potentially multiple used loan offers\\n    /// @param from I.e borrower\\n    /// @param nft - used as collateral\\n    /// @return collatState the initialized collateral state struct\\n    function initializedCollateralState(\\n        OfferArg memory firstOfferArg,\\n        address from,\\n        NFToken memory nft\\n    ) internal returns (CollateralState memory) {\\n        return\\n            CollateralState({\\n                matched: Ray.wrap(0),\\n                assetLent: firstOfferArg.offer.assetToLend,\\n                tranche: firstOfferArg.offer.tranche,\\n                minOfferDuration: firstOfferArg.offer.duration,\\n                minOfferLoanToValue: firstOfferArg.offer.loanToValue,\\n                maxOfferLoanToValue: firstOfferArg.offer.loanToValue,\\n                from: from,\\n                nft: nft,\\n                loanId: ++protocolStorage().nbOfLoans // returns incremented value (also increments in storage)\\n            });\\n    }\\n\\n    /// @notice initializes the loan struct representing borrowed funds from one NFT collateral, will be stored\\n    /// @param collatState contains info on share of the collateral value used by the borrower\\n    /// @param nft - used as collateral\\n    /// @param lent amount lent/borrowed\\n    /// @return loan tne initialized loan to store\\n    function initializedLoan(\\n        CollateralState memory collatState,\\n        address from,\\n        NFToken memory nft,\\n        uint256 lent\\n    ) internal view returns (Loan memory) {\\n        Protocol storage proto = protocolStorage();\\n\\n        /* the shortest offered duration determines the max date of repayment to make sure all loan offer terms are\\n        respected */\\n        uint256 endDate = block.timestamp + collatState.minOfferDuration;\\n        Payment memory notPaid; // not paid as it corresponds to the meaning of the uninitialized struct\\n\\n        /* the minimum interests amount to repay is used as anti ddos mechanism to prevent borrowers to produce lots of\\n        dust supply positions that the lenders will have to pay gas to claim. as each position can be used to claim\\n        funds separetely and induce a gas cost. With a design approach similar to the auction parameters setting,\\n        this minimal cost is set at borrow time to avoid bad surprises arising from governance setting new parameters\\n        during the loan life. cf docs for more details. */\\n        notPaid.minInterestsToRepay = proto.minOfferCost[collatState.assetLent];\\n\\n        return\\n            Loan({\\n                assetLent: collatState.assetLent,\\n                lent: lent,\\n                shareLent: collatState.matched,\\n                startDate: block.timestamp,\\n                endDate: endDate,\\n                /* auction parameters are copied from protocol parameters to the loan storage as a way to prevent\\n                a governance-initiated change of terms to modify the terms a borrower chose to accept or change the\\n                price of an NFT being sold abruptly during the course of an auction. */\\n                auction: Auction({duration: proto.auction.duration, priceFactor: proto.auction.priceFactor}),\\n                /* the interest rate is stored as a value instead of the tranche id as a precaution in case of a change\\n                in the interest rate mechanisms due to contract upgrade */\\n                interestPerSecond: proto.tranche[collatState.tranche],\\n                borrower: from,\\n                collateral: nft,\\n                payment: notPaid\\n            });\\n    }\\n}\\n\"\r\n    },\r\n    \"src/DataStructure/Global.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.21;\\n\\nimport {Protocol, SupplyPosition, SupplyPositionOffChainMetadata, ApiCoSigner} from \\\"./Storage.sol\\\";\\nimport {Ray} from \\\"./Objects.sol\\\";\\n\\n/* rationale of the naming of the hash is to use kairos loan's ENS as domain, the subject of the storage struct as\\nsubdomain and the version to anticipate upgrade. Order is revered compared to urls as it's the usage in code such as in\\njava imports */\\nbytes32 constant PROTOCOL_SP = keccak256(\\\"eth.kairosloan.protocol.v1.0\\\");\\nbytes32 constant SUPPLY_SP = keccak256(\\\"eth.kairosloan.supply-position.v1.0\\\");\\nbytes32 constant POSITION_OFF_CHAIN_METADATA_SP = keccak256(\\\"eth.kairosloan.position-off-chain-metadata.v1.0\\\");\\nbytes32 constant API_CO_SIGNER_SP = keccak256(\\\"eth.kairosloan.api-cosigning.v1.0\\\");\\n\\n/* Ray is chosed as the only fixed-point decimals approach as it allow extreme and versatile precision accross erc20s\\nand timeframes */\\nuint256 constant RAY = 1e27;\\nRay constant ONE = Ray.wrap(RAY);\\nRay constant ZERO = Ray.wrap(0);\\n\\n/* solhint-disable func-visibility */\\n\\n/// @dev getters of storage regions of the contract for specified usage\\n\\n/* we access storage only through functions in facets following the diamond storage pattern */\\n\\nfunction protocolStorage() pure returns (Protocol storage protocol) {\\n    bytes32 position = PROTOCOL_SP;\\n    /* solhint-disable-next-line no-inline-assembly */\\n    assembly {\\n        protocol.slot := position\\n    }\\n}\\n\\nfunction supplyPositionStorage() pure returns (SupplyPosition storage sp) {\\n    bytes32 position = SUPPLY_SP;\\n    /* solhint-disable-next-line no-inline-assembly */\\n    assembly {\\n        sp.slot := position\\n    }\\n}\\n\\nfunction supplyPositionMetadataStorage() pure returns (SupplyPositionOffChainMetadata storage position) {\\n    bytes32 position_off_chain_metadata_sp = POSITION_OFF_CHAIN_METADATA_SP;\\n    /* solhint-disable-next-line no-inline-assembly */\\n    assembly {\\n        position.slot := position_off_chain_metadata_sp\\n    }\\n}\\n\\nfunction apiCoSignerStorage() pure returns (ApiCoSigner storage apiCoSigner) {\\n    /* solhint-disable-next-line no-inline-assembly */\\n    bytes32 position = API_CO_SIGNER_SP;\\n    assembly {\\n        apiCoSigner.slot := position\\n    }\\n}\\n\"\r\n    },\r\n    \"src/DataStructure/Storage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.21;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {NFToken, Ray} from \\\"./Objects.sol\\\";\\n\\n/// @notice type definitions of data permanently stored\\n\\n/// @notice Parameters affecting liquidations by dutch auctions. The current auction parameters\\n///         are assigned to new loans at borrow time and can't be modified during the loan life.\\n/// @param duration number of seconds after the auction start when the price hits 0\\n/// @param priceFactor multiplier of the mean tvl used as start price for the auction\\nstruct Auction {\\n    uint256 duration;\\n    Ray priceFactor;\\n}\\n\\n/// @notice General protocol\\n/// @param nbOfLoans total number of loans ever issued (active and ended)\\n/// @param nbOfTranches total number of interest rates tranches ever created (active and inactive)\\n/// @param auctionParams - sets auctions duration and initial prices\\n/// @param tranche interest rate of tranche of provided id, in multiplier per second\\n///         I.e lent * time since loan start * tranche = interests to repay\\n/// @param loan - of id -\\n/// @param minOfferCost minimum amount repaid per offer used in a loan\\n/// @param offerBorrowAmountLowerBound borrow amount per offer has to be strightly higher than this value\\nstruct Protocol {\\n    uint256 nbOfLoans;\\n    uint256 nbOfTranches;\\n    Auction auction;\\n    mapping(uint256 => Ray) tranche;\\n    mapping(uint256 => Loan) loan;\\n    mapping(IERC20 => uint256) minOfferCost;\\n    mapping(IERC20 => uint256) offerBorrowAmountLowerBound;\\n}\\n\\n/// @notice Issued Loan (corresponding to one collateral)\\n/// @param assetLent currency lent\\n/// @param lent total amount lent\\n/// @param shareLent between 0 and 1, the share of the collateral value lent\\n/// @param startDate timestamp of the borrowing transaction\\n/// @param endDate timestamp after which sale starts & repay is impossible\\n/// @param auction duration and price factor of the collateral auction in case of liquidation\\n/// @param interestPerSecond share of the amount lent added to the debt per second\\n/// @param borrower borrowing account\\n/// @param collateral NFT asset used as collateral\\n/// @param payment data on the payment, a non-0 payment.paid value means the loan lifecyle is over\\nstruct Loan {\\n    IERC20 assetLent;\\n    uint256 lent;\\n    Ray shareLent;\\n    uint256 startDate;\\n    uint256 endDate;\\n    Auction auction;\\n    Ray interestPerSecond;\\n    address borrower;\\n    NFToken collateral;\\n    Payment payment;\\n}\\n\\n/// @notice tracking of the payment state of a loan\\n/// @param paid amount sent on the tx closing the loan, non-zero value means loan's lifecycle is over\\n/// @param minInterestsToRepay minimum amount of interests that the borrower will need to repay\\n/// @param liquidated this loan has been closed at the liquidation stage, the collateral has been sold\\n/// @param borrowerClaimed borrower claimed his rights on this loan (either collateral or share of liquidation)\\nstruct Payment {\\n    uint256 paid;\\n    uint256 minInterestsToRepay;\\n    bool liquidated;\\n    bool borrowerClaimed;\\n}\\n\\n/// @notice storage for the ERC721 compliant supply position facet. Related NFTs represent supplier positions\\n/// @param name - of the NFT collection\\n/// @param symbol - of the NFT collection\\n/// @param totalSupply number of supply position ever issued - not decreased on burn\\n/// @param owner - of nft of id -\\n/// @param balance number of positions owned by -\\n/// @param tokenApproval address approved to transfer position of id - on behalf of its owner\\n/// @param operatorApproval address is approved to transfer all positions of - on his behalf\\n/// @param provision supply position metadata\\nstruct SupplyPosition {\\n    string name;\\n    string symbol;\\n    uint256 totalSupply;\\n    mapping(uint256 => address) owner;\\n    mapping(address => uint256) balance;\\n    mapping(uint256 => address) tokenApproval;\\n    mapping(address => mapping(address => bool)) operatorApproval;\\n    mapping(uint256 => Provision) provision;\\n}\\n\\n/// @notice storage for the ERC721 compliant supply position facet. Related NFTs represent supplier positions\\n/// @param baseUri - base uri\\nstruct SupplyPositionOffChainMetadata {\\n    string baseUri;\\n}\\n\\n/// @notice data on a liquidity provision from a supply offer in one existing loan\\n/// @param amount - supplied for this provision\\n/// @param share - of the collateral matched by this provision\\n/// @param loanId identifier of the loan the liquidity went to\\nstruct Provision {\\n    uint256 amount;\\n    Ray share;\\n    uint256 loanId;\\n}\\n\\n/// @notice storage for the api co-validation of signed offers\\n/// @param apiAddress - address of the api (corresponding to the key used to co-sign offers)\\nstruct ApiCoSigner {\\n    address apiAddress;\\n}\\n\"\r\n    },\r\n    \"src/DataStructure/Errors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.21;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {NFToken, Offer, ApiCoSignedPayload} from \\\"./Objects.sol\\\";\\n\\nerror BadCollateral(Offer offer, NFToken providedNft);\\nerror ERC20TransferFailed(IERC20 token, address from, address to);\\nerror OfferHasExpired(Offer offer, uint256 expirationDate);\\nerror RequestedAmountIsUnderMinimum(Offer offer, uint256 requested, uint256 lowerBound);\\nerror RequestedAmountTooHigh(uint256 requested, uint256 offered, Offer offer);\\nerror LoanAlreadyRepaid(uint256 loanId);\\nerror LoanNotRepaidOrLiquidatedYet(uint256 loanId);\\nerror NotBorrowerOfTheLoan(uint256 loanId);\\nerror BorrowerAlreadyClaimed(uint256 loanId);\\nerror CallerIsNotOwner(address admin);\\nerror InvalidTranche(uint256 nbOfTranches);\\nerror CollateralIsNotLiquidableYet(uint256 endDate, uint256 loanId);\\nerror UnsafeAmountLent(uint256 lent);\\nerror MultipleOffersUsed();\\nerror PriceOverMaximum(uint256 maxPrice, uint256 price);\\nerror CurrencyNotSupported(IERC20 currency);\\nerror ShareMatchedIsTooLow(Offer offer, uint256 requested);\\nerror InvalidApiCoSignature(ApiCoSignedPayload apiSignedPayload, bytes apiSignature);\\nerror ApiCoSignatureExpired(uint256 inclusionLimitDate, uint256 blockTimestamp);\\nerror CallerIsNotTheBalancerVault();\\n\"\r\n    },\r\n    \"../../node_modules/diamond/contracts/facets/OwnershipFacet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport { LibDiamond } from \\\"../libraries/LibDiamond.sol\\\";\\nimport { IERC173 } from \\\"../interfaces/IERC173.sol\\\";\\n\\ncontract OwnershipFacet is IERC173 {\\n    function transferOwnership(address _newOwner) external override {\\n        LibDiamond.enforceIsContractOwner();\\n        LibDiamond.setContractOwner(_newOwner);\\n    }\\n\\n    function owner() external override view returns (address owner_) {\\n        owner_ = LibDiamond.contractOwner();\\n    }\\n}\\n\"\r\n    },\r\n    \"../../node_modules/diamond/contracts/facets/DiamondCutFacet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\n\\nimport { IDiamondCut } from \\\"../interfaces/IDiamondCut.sol\\\";\\nimport { LibDiamond } from \\\"../libraries/LibDiamond.sol\\\";\\n\\n// Remember to add the loupe functions from DiamondLoupeFacet to the diamond.\\n// The loupe functions are required by the EIP2535 Diamonds standard\\n\\ncontract DiamondCutFacet is IDiamondCut {\\n    /// @notice Add/replace/remove any number of functions and optionally execute\\n    ///         a function with delegatecall\\n    /// @param _diamondCut Contains the facet addresses and function selectors\\n    /// @param _init The address of the contract or facet to execute _calldata\\n    /// @param _calldata A function call, including function selector and arguments\\n    ///                  _calldata is executed with delegatecall on _init\\n    function diamondCut(\\n        FacetCut[] calldata _diamondCut,\\n        address _init,\\n        bytes calldata _calldata\\n    ) external override {\\n        LibDiamond.enforceIsContractOwner();\\n        LibDiamond.diamondCut(_diamondCut, _init, _calldata);\\n    }\\n}\\n\"\r\n    },\r\n    \"../../node_modules/diamond/contracts/facets/DiamondLoupeFacet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\n\\n// The functions in DiamondLoupeFacet MUST be added to a diamond.\\n// The EIP-2535 Diamond standard requires these functions.\\n\\nimport { LibDiamond } from  \\\"../libraries/LibDiamond.sol\\\";\\nimport { IDiamondLoupe } from \\\"../interfaces/IDiamondLoupe.sol\\\";\\nimport { IERC165 } from \\\"../interfaces/IERC165.sol\\\";\\n\\ncontract DiamondLoupeFacet is IDiamondLoupe, IERC165 {\\n    // Diamond Loupe Functions\\n    ////////////////////////////////////////////////////////////////////\\n    /// These functions are expected to be called frequently by tools.\\n    //\\n    // struct Facet {\\n    //     address facetAddress;\\n    //     bytes4[] functionSelectors;\\n    // }\\n    /// @notice Gets all facets and their selectors.\\n    /// @return facets_ Facet\\n    function facets() external override view returns (Facet[] memory facets_) {\\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\\n        uint256 selectorCount = ds.selectors.length;\\n        // create an array set to the maximum size possible\\n        facets_ = new Facet[](selectorCount);\\n        // create an array for counting the number of selectors for each facet\\n        uint16[] memory numFacetSelectors = new uint16[](selectorCount);\\n        // total number of facets\\n        uint256 numFacets;\\n        // loop through function selectors\\n        for (uint256 selectorIndex; selectorIndex < selectorCount; selectorIndex++) {\\n            bytes4 selector = ds.selectors[selectorIndex];\\n            address facetAddress_ = ds.facetAddressAndSelectorPosition[selector].facetAddress;\\n            bool continueLoop = false;\\n            // find the functionSelectors array for selector and add selector to it\\n            for (uint256 facetIndex; facetIndex < numFacets; facetIndex++) {\\n                if (facets_[facetIndex].facetAddress == facetAddress_) {\\n                    facets_[facetIndex].functionSelectors[numFacetSelectors[facetIndex]] = selector;                                   \\n                    numFacetSelectors[facetIndex]++;\\n                    continueLoop = true;\\n                    break;\\n                }\\n            }\\n            // if functionSelectors array exists for selector then continue loop\\n            if (continueLoop) {\\n                continueLoop = false;\\n                continue;\\n            }\\n            // create a new functionSelectors array for selector\\n            facets_[numFacets].facetAddress = facetAddress_;\\n            facets_[numFacets].functionSelectors = new bytes4[](selectorCount);\\n            facets_[numFacets].functionSelectors[0] = selector;\\n            numFacetSelectors[numFacets] = 1;\\n            numFacets++;\\n        }\\n        for (uint256 facetIndex; facetIndex < numFacets; facetIndex++) {\\n            uint256 numSelectors = numFacetSelectors[facetIndex];\\n            bytes4[] memory selectors = facets_[facetIndex].functionSelectors;\\n            // setting the number of selectors\\n            assembly {\\n                mstore(selectors, numSelectors)\\n            }\\n        }\\n        // setting the number of facets\\n        assembly {\\n            mstore(facets_, numFacets)\\n        }\\n    }\\n\\n    /// @notice Gets all the function selectors supported by a specific facet.\\n    /// @param _facet The facet address.\\n    /// @return _facetFunctionSelectors The selectors associated with a facet address.\\n    function facetFunctionSelectors(address _facet) external override view returns (bytes4[] memory _facetFunctionSelectors) {\\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\\n        uint256 selectorCount = ds.selectors.length;\\n        uint256 numSelectors;\\n        _facetFunctionSelectors = new bytes4[](selectorCount);\\n        // loop through function selectors\\n        for (uint256 selectorIndex; selectorIndex < selectorCount; selectorIndex++) {\\n            bytes4 selector = ds.selectors[selectorIndex];\\n            address facetAddress_ = ds.facetAddressAndSelectorPosition[selector].facetAddress;\\n            if (_facet == facetAddress_) {\\n                _facetFunctionSelectors[numSelectors] = selector;\\n                numSelectors++;\\n            }\\n        }\\n        // Set the number of selectors in the array\\n        assembly {\\n            mstore(_facetFunctionSelectors, numSelectors)\\n        }\\n    }\\n\\n    /// @notice Get all the facet addresses used by a diamond.\\n    /// @return facetAddresses_\\n    function facetAddresses() external override view returns (address[] memory facetAddresses_) {\\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\\n        uint256 selectorCount = ds.selectors.length;\\n        // create an array set to the maximum size possible\\n        facetAddresses_ = new address[](selectorCount);\\n        uint256 numFacets;\\n        // loop through function selectors\\n        for (uint256 selectorIndex; selectorIndex < selectorCount; selectorIndex++) {\\n            bytes4 selector = ds.selectors[selectorIndex];\\n            address facetAddress_ = ds.facetAddressAndSelectorPosition[selector].facetAddress;\\n            bool continueLoop = false;\\n            // see if we have collected the address already and break out of loop if we have\\n            for (uint256 facetIndex; facetIndex < numFacets; facetIndex++) {\\n                if (facetAddress_ == facetAddresses_[facetIndex]) {\\n                    continueLoop = true;\\n                    break;\\n                }\\n            }\\n            // continue loop if we already have the address\\n            if (continueLoop) {\\n                continueLoop = false;\\n                continue;\\n            }\\n            // include address\\n            facetAddresses_[numFacets] = facetAddress_;\\n            numFacets++;\\n        }\\n        // Set the number of facet addresses in the array\\n        assembly {\\n            mstore(facetAddresses_, numFacets)\\n        }\\n    }\\n\\n    /// @notice Gets the facet address that supports the given selector.\\n    /// @dev If facet is not found return address(0).\\n    /// @param _functionSelector The function selector.\\n    /// @return facetAddress_ The facet address.\\n    function facetAddress(bytes4 _functionSelector) external override view returns (address facetAddress_) {\\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\\n        facetAddress_ = ds.facetAddressAndSelectorPosition[_functionSelector].facetAddress;\\n    }\\n\\n    // This implements ERC-165.\\n    function supportsInterface(bytes4 _interfaceId) external override view returns (bool) {\\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\\n        return ds.supportedInterfaces[_interfaceId];\\n    }\\n}\\n\"\r\n    },\r\n    \"src/AuctionFacet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.21;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nimport {IAuctionFacet} from \\\"./interface/IAuctionFacet.sol\\\";\\n\\nimport {BuyArg, NFToken, Ray} from \\\"./DataStructure/Objects.sol\\\";\\nimport {Loan, Protocol, Provision, SupplyPosition} from \\\"./DataStructure/Storage.sol\\\";\\nimport {RayMath} from \\\"./utils/RayMath.sol\\\";\\nimport {Erc20CheckedTransfer} from \\\"./utils/Erc20CheckedTransfer.sol\\\";\\nimport {SafeMint} from \\\"./SupplyPositionLogic/SafeMint.sol\\\";\\nimport {protocolStorage, supplyPositionStorage, ONE, ZERO} from \\\"./DataStructure/Global.sol\\\";\\n// solhint-disable-next-line max-line-length\\nimport {LoanAlreadyRepaid, CollateralIsNotLiquidableYet, PriceOverMaximum} from \\\"./DataStructure/Errors.sol\\\";\\n\\n/// @notice handles sale of collaterals being liquidated, following a dutch auction starting at repayment date\\ncontract AuctionFacet is IAuctionFacet, SafeMint {\\n    using RayMath for Ray;\\n    using RayMath for uint256;\\n    using Erc20CheckedTransfer for IERC20;\\n\\n    /// @notice buy one or multiple NFTs in liquidation\\n    /// @param args arguments on what and how to buy\\n    function buy(BuyArg[] memory args) external {\\n        for (uint256 i = 0; i < args.length; i++) {\\n            useLoan(args[i]);\\n        }\\n    }\\n\\n    /// @notice gets the price to buy the underlying collateral of the loan\\n    /// @param loanId identifier of the loan\\n    /// @return price computed price\\n    function price(uint256 loanId) public view returns (uint256) {\\n        Loan storage loan = protocolStorage().loan[loanId];\\n        uint256 loanEndDate = loan.endDate;\\n        checkLoanStatus(loanId);\\n        uint256 timeSinceLiquidable = block.timestamp - loanEndDate;\\n\\n        /* the decreasing factor controls the evolution of the price from its initial value to 0 (and staying at 0)\\n        over the course of the auction duration */\\n        Ray decreasingFactor = timeSinceLiquidable >= loan.auction.duration\\n            ? ZERO\\n            : ONE.sub(timeSinceLiquidable.div(loan.auction.duration));\\n\\n        uint256 estimatedValue = loan.lent.div(loan.shareLent);\\n\\n        /* by mutliplying the estimated price by some factor and slowly decreasing this price over time we aim to\\n        make sure a liquidator will buy the NFT at fair market price. */\\n        return estimatedValue.mul(loan.auction.priceFactor).mul(decreasingFactor);\\n    }\\n\\n    /// @notice handles buying one NFT\\n    /// @param arg arguments on what and how to buy\\n    function useLoan(BuyArg memory arg) internal {\\n        Loan storage loan = protocolStorage().loan[arg.loanId];\\n\\n        uint256 toPay = price(arg.loanId); // includes checks on loan status\\n\\n        if (toPay > arg.maxPrice) {\\n            /* in case of a reorg, the transaction can be included at a block timestamp date earlier than actual\\n            transaction signature date, resulting in a price unexpectedly high. */\\n            revert PriceOverMaximum(arg.maxPrice, toPay);\\n        }\\n\\n        /* store as liquidated and paid before transfers to avoid malicious reentrency, following\\n        checks-effects-interactions pattern */\\n        loan.payment.liquidated = true;\\n        loan.payment.paid = toPay;\\n        loan.assetLent.checkedTransferFrom(msg.sender, address(this), toPay);\\n        loan.collateral.implem.safeTransferFrom(address(this), arg.to, loan.collateral.id);\\n\\n        emit Buy(arg.loanId, abi.encode(arg));\\n    }\\n\\n    /// @notice checks that loan is liquidable, revert if not\\n    /// @param loanId identifier of the loan\\n    function checkLoanStatus(uint256 loanId) internal view {\\n        Loan storage loan = protocolStorage().loan[loanId];\\n\\n        if (block.timestamp <= loan.endDate) {\\n            revert CollateralIsNotLiquidableYet(loan.endDate, loanId);\\n        }\\n        if (loan.payment.paid != 0 || loan.payment.liquidated) {\\n            revert LoanAlreadyRepaid(loanId);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/ClaimFacet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.21;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nimport {IClaimFacet} from \\\"./interface/IClaimFacet.sol\\\";\\nimport {BorrowerAlreadyClaimed, LoanNotRepaidOrLiquidatedYet, NotBorrowerOfTheLoan} from \\\"./DataStructure/Errors.sol\\\";\\nimport {ERC721CallerIsNotOwner} from \\\"./DataStructure/ERC721Errors.sol\\\";\\nimport {Loan, Protocol, Provision, SupplyPosition} from \\\"./DataStructure/Storage.sol\\\";\\nimport {ONE, protocolStorage, supplyPositionStorage} from \\\"./DataStructure/Global.sol\\\";\\nimport {Ray} from \\\"./DataStructure/Objects.sol\\\";\\nimport {RayMath} from \\\"./utils/RayMath.sol\\\";\\nimport {Erc20CheckedTransfer} from \\\"./utils/Erc20CheckedTransfer.sol\\\";\\nimport {SafeMint} from \\\"./SupplyPositionLogic/SafeMint.sol\\\";\\n\\n/// @notice claims supplier and borrower rights on loans or supply positions\\ncontract ClaimFacet is IClaimFacet, SafeMint {\\n    using RayMath for Ray;\\n    using RayMath for uint256;\\n    using Erc20CheckedTransfer for IERC20;\\n\\n    /// @notice claims principal plus interests or liquidation share due as a supplier\\n    /// @param positionIds identifiers of one or multiple supply position to burn\\n    /// @return sent amount sent\\n    function claim(uint256[] calldata positionIds) external returns (uint256 sent) {\\n        Protocol storage proto = protocolStorage();\\n        SupplyPosition storage sp = supplyPositionStorage();\\n        Loan storage loan;\\n        Provision storage provision;\\n        uint256 loanId;\\n        uint256 sentTemp;\\n\\n        for (uint256 i = 0; i < positionIds.length; i++) {\\n            if (sp.owner[positionIds[i]] != msg.sender) {\\n                revert ERC721CallerIsNotOwner();\\n            }\\n            _burn(positionIds[i]);\\n            provision = sp.provision[positionIds[i]];\\n            loanId = provision.loanId;\\n            loan = proto.loan[loanId];\\n\\n            if (loan.payment.liquidated) {\\n                sentTemp = sendShareOfSaleAsSupplier(loan, provision);\\n            } else {\\n                if (loan.payment.paid == 0) {\\n                    revert LoanNotRepaidOrLiquidatedYet(loanId);\\n                }\\n                sentTemp = sendInterests(loan, provision);\\n            }\\n            emit Claim(msg.sender, sentTemp, loanId);\\n            sent += sentTemp;\\n        }\\n    }\\n\\n    /// @notice claims share of liquidation due to a borrower who's collateral has been sold\\n    /// @param loanIds loan identifiers of one or multiple loans where the borrower wants to claim liquidation share\\n    /// @return sent amount sent\\n    function claimAsBorrower(uint256[] calldata loanIds) external returns (uint256 sent) {\\n        Protocol storage proto = protocolStorage();\\n        Loan storage loan;\\n        uint256 sentTemp;\\n        uint256 loanId;\\n\\n        for (uint256 i = 0; i < loanIds.length; i++) {\\n            loanId = loanIds[i];\\n            loan = proto.loan[loanId];\\n            if (loan.borrower != msg.sender) {\\n                revert NotBorrowerOfTheLoan(loanId);\\n            }\\n            if (loan.payment.borrowerClaimed) {\\n                revert BorrowerAlreadyClaimed(loanId);\\n            }\\n            if (loan.payment.liquidated) {\\n                loan.payment.borrowerClaimed = true;\\n                // 1 - shareLent = share belonging to the borrower (not used as collateral)\\n                sentTemp = loan.payment.paid.mul(ONE.sub(loan.shareLent));\\n            } else {\\n                revert LoanNotRepaidOrLiquidatedYet(loanId);\\n            }\\n            if (sentTemp > 0) {\\n                /* the function may be called to store that the borrower claimed its due, but if this due is of 0 there\\n                is no point in emitting a transfer and claim event */\\n                loan.assetLent.checkedTransfer(msg.sender, sentTemp);\\n                sent += sentTemp;\\n                emit Claim(msg.sender, sentTemp, loanId);\\n                // sentTemp is reassigned or the execution reverts on next loop\\n            }\\n        }\\n    }\\n\\n    /// @notice sends principal plus interests of the loan to `msg.sender`\\n    /// @param loan - to calculate amount from\\n    /// @param provision liquidity provision for this loan\\n    /// @return sent amount sent\\n    function sendInterests(Loan storage loan, Provision storage provision) internal returns (uint256 sent) {\\n        uint256 interests = loan.payment.paid - loan.lent;\\n        if (interests == loan.payment.minInterestsToRepay) {\\n            // this is the case if the loan is repaid shortly after issuance\\n            // each lender gets its minimal interest, as an anti ddos measure to spam offer\\n            sent = provision.amount + interests;\\n        } else {\\n            /* provision.amount / lent = share of the interests belonging to the lender. The parenthesis make the\\n            calculus in the order that maximizes precison */\\n            sent = provision.amount + (interests * (provision.amount)) / loan.lent;\\n        }\\n        loan.assetLent.checkedTransfer(msg.sender, sent);\\n    }\\n\\n    /// @notice sends liquidation share due to `msg.sender` as a supplier\\n    /// @param loan - from which the collateral were liquidated\\n    /// @param provision liquidity provisioned by this loan by the supplier\\n    /// @return sent amount sent\\n    function sendShareOfSaleAsSupplier(Loan storage loan, Provision storage provision) internal returns (uint256 sent) {\\n        // in the case of a liqudidation, provision.share is considered the share of the NFT acquired by the lender\\n        sent = loan.payment.paid.mul(provision.share);\\n        loan.assetLent.checkedTransfer(msg.sender, sent);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/Initializer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.21;\\n\\n// Derived from Nick Mudge's DiamondInit from the reference diamond implementation\\n\\nimport {IERC721} from \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport {LibDiamond} from \\\"diamond/contracts/libraries/LibDiamond.sol\\\";\\nimport {IDiamondLoupe} from \\\"diamond/contracts/interfaces/IDiamondLoupe.sol\\\";\\nimport {IDiamondCut} from \\\"diamond/contracts/interfaces/IDiamondCut.sol\\\";\\nimport {IERC173} from \\\"diamond/contracts/interfaces/IERC173.sol\\\";\\nimport {IERC165} from \\\"diamond/contracts/interfaces/IERC165.sol\\\";\\n\\nimport {ONE, protocolStorage, supplyPositionStorage} from \\\"./DataStructure/Global.sol\\\";\\nimport {Ray} from \\\"./DataStructure/Objects.sol\\\";\\nimport {Protocol, SupplyPosition} from \\\"./DataStructure/Storage.sol\\\";\\nimport {RayMath} from \\\"./utils/RayMath.sol\\\";\\n\\n/// @notice initilizes the kairos protocol\\ncontract Initializer {\\n    using RayMath for Ray;\\n\\n    /// @notice initilizes the kairos protocol\\n    /// @dev specify this method in diamond constructor\\n    function init() external {\\n        // adding ERC165 data\\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\\n        ds.supportedInterfaces[type(IERC165).interfaceId] = true;\\n        ds.supportedInterfaces[type(IDiamondCut).interfaceId] = true;\\n        ds.supportedInterfaces[type(IDiamondLoupe).interfaceId] = true;\\n        ds.supportedInterfaces[type(IERC173).interfaceId] = true;\\n\\n        // initializing protocol\\n        Protocol storage proto = protocolStorage();\\n\\n        proto.tranche[0] = ONE.div(10).mul(4).div(365 days); // 40% APR\\n        proto.nbOfTranches = 1;\\n        proto.auction.priceFactor = ONE.mul(3);\\n        proto.auction.duration = 3 days;\\n\\n        // initializing supply position nft collection\\n        SupplyPosition storage sp = supplyPositionStorage();\\n        sp.name = \\\"Kairos Supply Position\\\";\\n        sp.symbol = \\\"KSP\\\";\\n        ds.supportedInterfaces[type(IERC721).interfaceId] = true;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/ProtocolFacet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.21;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nimport {IProtocolFacet} from \\\"./interface/IProtocolFacet.sol\\\";\\n\\nimport {Loan, Protocol} from \\\"./DataStructure/Storage.sol\\\";\\nimport {protocolStorage} from \\\"./DataStructure/Global.sol\\\";\\nimport {Ray} from \\\"./DataStructure/Objects.sol\\\";\\n\\n/// @notice external loupe functions exposing protocol storage\\ncontract ProtocolFacet is IProtocolFacet {\\n    /// @notice gets the rate of tranche `id`\\n    /// @param id rate identifier\\n    /// @return rate the rate of the tranche, as a Ray, multiplier per second of the amount to repay (non compounding)\\n    ///         I.e lent * time since loan start * tranche = interests to repay\\n    function getRateOfTranche(uint256 id) external view returns (Ray rate) {\\n        return protocolStorage().tranche[id];\\n    }\\n\\n    /// @notice gets current values of parameters impacting loans behavior and total number of loans (active and ended)\\n    /// @return auctionPriceFactor factor multiplied with the loan to value of a loan to get initial price\\n    ///         of a collateral on sale\\n    /// @return auctionDuration number of seconds after the auction start when the price hits 0\\n    /// @return nbOfLoans total number of loans ever issued (active and ended)\\n    /// @return nbOfTranches total number of interest rates tranches ever created (active and inactive)\\n    function getParameters()\\n        external\\n        view\\n        returns (Ray auctionPriceFactor, uint256 auctionDuration, uint256 nbOfLoans, uint256 nbOfTranches)\\n    {\\n        Protocol storage proto = protocolStorage();\\n        auctionPriceFactor = proto.auction.priceFactor;\\n        auctionDuration = proto.auction.duration;\\n        nbOfLoans = proto.nbOfLoans;\\n        nbOfTranches = proto.nbOfTranches;\\n    }\\n\\n    /// @notice get loan metadata\\n    /// @param id loan identifier\\n    /// @return loan the corresponding loan\\n    function getLoan(uint256 id) external view returns (Loan memory) {\\n        return protocolStorage().loan[id];\\n    }\\n\\n    /// @notice get the minimal amount to repay per offer used in loan and minimum amount to borrow per offer.\\n    ///     Gives currently active settings, may not concern loans already issued.\\n    /// @param currency the erc20 asset lent on which the parameters apply\\n    /// @return minOfferCost the minimal amount to repay per offer used in loan\\n    /// @return offerBorrowAmountLowerBound  minimum amount to borrow per offer used in loan\\n    function getMinOfferCostAndBorrowableAmount(\\n        IERC20 currency\\n    ) external view returns (uint256 minOfferCost, uint256 offerBorrowAmountLowerBound) {\\n        Protocol storage proto = protocolStorage();\\n        minOfferCost = proto.minOfferCost[currency];\\n        offerBorrowAmountLowerBound = proto.offerBorrowAmountLowerBound[currency];\\n    }\\n}\\n\"\r\n    },\r\n    \"src/SupplyPositionFacet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.21;\\n\\nimport {DiamondERC721} from \\\"./SupplyPositionLogic/DiamondERC721.sol\\\";\\nimport {ERC721InvalidTokenId} from \\\"./DataStructure/ERC721Errors.sol\\\";\\nimport {SupplyPosition, Provision} from \\\"./DataStructure/Storage.sol\\\";\\nimport {supplyPositionStorage, supplyPositionMetadataStorage} from \\\"./DataStructure/Global.sol\\\";\\nimport {Strings} from \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\n\\n/// @notice NFT collection facet for transferable tradable non fungible supply positions\\ncontract SupplyPositionFacet is DiamondERC721 {\\n    // constructor equivalent is in the Initializer contract\\n    using Strings for uint256;\\n\\n    /// @notice get metadata on provision linked to the supply position\\n    /// @param tokenId token identifier of the supply position\\n    /// @return provision metadata\\n    function position(uint256 tokenId) external view returns (Provision memory) {\\n        SupplyPosition storage sp = supplyPositionStorage();\\n\\n        if (tokenId > sp.totalSupply) {\\n            revert ERC721InvalidTokenId();\\n        }\\n\\n        return sp.provision[tokenId];\\n    }\\n\\n    /// @notice total number of supply positions ever minted (counting burned ones)\\n    /// @return totalSupply the number\\n    function totalSupply() external view returns (uint256) {\\n        return supplyPositionStorage().totalSupply;\\n    }\\n\\n    /// @notice get the token URI for a given token identifier\\n    /// @param tokenId token identifier of the supply position\\n    /// @return URI univeral resource identifier of the token metadata\\n    function tokenURI(uint256 tokenId) external view returns (string memory) {\\n        _ownerOf(tokenId); // revert on invalid tokenId\\n        return string(abi.encodePacked(supplyPositionMetadataStorage().baseUri, tokenId.toString()));\\n    }\\n}\\n\"\r\n    },\r\n    \"src/utils/FuncSelectors.h.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.21;\\n\\nimport {IDiamondCut} from \\\"diamond/contracts/interfaces/IDiamondCut.sol\\\";\\nimport {IDiamondLoupe} from \\\"diamond/contracts/interfaces/IDiamondLoupe.sol\\\";\\nimport {IERC721} from \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport {IERC165} from \\\"diamond/contracts/interfaces/IERC165.sol\\\";\\nimport {OwnershipFacet} from \\\"diamond/contracts/facets/OwnershipFacet.sol\\\";\\nimport {IERC721Receiver} from \\\"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\\\";\\n\\nimport {IAuctionFacet} from \\\"../interface/IAuctionFacet.sol\\\";\\nimport {IBorrowFacet} from \\\"../interface/IBorrowFacet.sol\\\";\\nimport {IClaimFacet} from \\\"../interface/IClaimFacet.sol\\\";\\nimport {IProtocolFacet} from \\\"../interface/IProtocolFacet.sol\\\";\\nimport {IRepayFacet} from \\\"../interface/IRepayFacet.sol\\\";\\nimport {IAdminFacet} from \\\"../interface/IAdminFacet.sol\\\";\\nimport {ISignature} from \\\"../interface/ISignature.sol\\\";\\n\\nimport {SupplyPositionFacet} from \\\"../SupplyPositionFacet.sol\\\";\\nimport {DiamondERC721} from \\\"../SupplyPositionLogic/DiamondERC721.sol\\\";\\n\\n/* solhint-disable func-visibility */\\n\\n/// @notice This file is for function selectors getters of facets\\n/// @dev create a new function for each new facet and update them\\n///     according to their interface\\n\\nfunction loupeFS() pure returns (bytes4[] memory) {\\n    bytes4[] memory functionSelectors = new bytes4[](5);\\n\\n    functionSelectors[0] = IDiamondLoupe.facets.selector;\\n    functionSelectors[1] = IDiamondLoupe.facetFunctionSelectors.selector;\\n    functionSelectors[2] = IDiamondLoupe.facetAddresses.selector;\\n    functionSelectors[3] = IDiamondLoupe.facetAddress.selector;\\n    functionSelectors[4] = IERC165.supportsInterface.selector;\\n\\n    return functionSelectors;\\n}\\n\\nfunction ownershipFS() pure returns (bytes4[] memory) {\\n    bytes4[] memory functionSelectors = new bytes4[](2);\\n\\n    functionSelectors[0] = OwnershipFacet.transferOwnership.selector;\\n    functionSelectors[1] = OwnershipFacet.owner.selector;\\n\\n    return functionSelectors;\\n}\\n\\nfunction cutFS() pure returns (bytes4[] memory) {\\n    bytes4[] memory functionSelectors = new bytes4[](1);\\n\\n    functionSelectors[0] = IDiamondCut.diamondCut.selector;\\n\\n    return functionSelectors;\\n}\\n\\nfunction borrowFS() pure returns (bytes4[] memory) {\\n    bytes4[] memory functionSelectors = new bytes4[](5);\\n\\n    functionSelectors[0] = IERC721Receiver.onERC721Received.selector;\\n    functionSelectors[1] = ISignature.offerDigest.selector;\\n    functionSelectors[2] = ISignature.apiCoSignedPayloadDigest.selector;\\n    functionSelectors[3] = IBorrowFacet.borrow.selector;\\n    functionSelectors[4] = IBorrowFacet.transferBorrowerRights.selector;\\n\\n    return functionSelectors;\\n}\\n\\nfunction supplyPositionFS() pure returns (bytes4[] memory) {\\n    bytes4[] memory functionSelectors = new bytes4[](14);\\n\\n    functionSelectors[0] = IERC721.balanceOf.selector;\\n    functionSelectors[1] = IERC721.ownerOf.selector;\\n    functionSelectors[2] = DiamondERC721.name.selector;\\n    functionSelectors[3] = DiamondERC721.symbol.selector;\\n    functionSelectors[4] = IERC721.approve.selector;\\n    functionSelectors[5] = IERC721.getApproved.selector;\\n    functionSelectors[6] = IERC721.setApprovalForAll.selector;\\n    functionSelectors[7] = IERC721.isApprovedForAll.selector;\\n    functionSelectors[8] = IERC721.transferFrom.selector;\\n    functionSelectors[9] = getSelector(\\\"safeTransferFrom(address,address,uint256)\\\");\\n    functionSelectors[10] = getSelector(\\\"safeTransferFrom(address,address,uint256,bytes)\\\");\\n    functionSelectors[11] = SupplyPositionFacet.position.selector;\\n    functionSelectors[12] = SupplyPositionFacet.totalSupply.selector;\\n    functionSelectors[13] = SupplyPositionFacet.tokenURI.selector;\\n\\n    return functionSelectors;\\n}\\n\\n/// @notice protocol facet function selectors\\nfunction protoFS() pure returns (bytes4[] memory) {\\n    bytes4[] memory functionSelectors = new bytes4[](4);\\n\\n    functionSelectors[0] = IProtocolFacet.getRateOfTranche.selector;\\n    functionSelectors[1] = IProtocolFacet.getParameters.selector;\\n    functionSelectors[2] = IProtocolFacet.getLoan.selector;\\n    functionSelectors[3] = IProtocolFacet.getMinOfferCostAndBorrowableAmount.selector;\\n\\n    return functionSelectors;\\n}\\n\\nfunction repayFS() pure returns (bytes4[] memory) {\\n    bytes4[] memory functionSelectors = new bytes4[](2);\\n\\n    functionSelectors[0] = IRepayFacet.repay.selector;\\n    functionSelectors[1] = IRepayFacet.toRepay.selector;\\n\\n    return functionSelectors;\\n}\\n\\nfunction auctionFS() pure returns (bytes4[] memory) {\\n    bytes4[] memory functionSelectors = new bytes4[](2);\\n\\n    functionSelectors[0] = IAuctionFacet.buy.selector;\\n    functionSelectors[1] = IAuctionFacet.price.selector;\\n\\n    return functionSelectors;\\n}\\n\\nfunction claimFS() pure returns (bytes4[] memory) {\\n    bytes4[] memory functionSelectors = new bytes4[](2);\\n\\n    functionSelectors[0] = IClaimFacet.claim.selector;\\n    functionSelectors[1] = IClaimFacet.claimAsBorrower.selector;\\n\\n    return functionSelectors;\\n}\\n\\nfunction adminFS() pure returns (bytes4[] memory) {\\n    bytes4[] memory functionSelectors = new bytes4[](7);\\n\\n    functionSelectors[0] = IAdminFacet.setAuctionDuration.selector;\\n    functionSelectors[1] = IAdminFacet.setAuctionPriceFactor.selector;\\n    functionSelectors[2] = IAdminFacet.createTranche.selector;\\n    functionSelectors[3] = IAdminFacet.setMinOfferCost.selector;\\n    functionSelectors[4] = IAdminFacet.setBorrowAmountPerOfferLowerBound.selector;\\n    functionSelectors[5] = IAdminFacet.setBaseMetadataUri.selector;\\n    functionSelectors[6] = IAdminFacet.setApiAddress.selector;\\n\\n    return functionSelectors;\\n}\\n\\nfunction getSelector(string memory _func) pure returns (bytes4) {\\n    return bytes4(keccak256(bytes(_func)));\\n}\\n\\nfunction copyNSelectors(bytes4[] memory initialSelectors, uint256 numberToCopy) pure returns (bytes4[] memory) {\\n    bytes4[] memory functionSelectors = new bytes4[](numberToCopy);\\n\\n    for (uint256 i = 0; i < numberToCopy; i++) {\\n        functionSelectors[i] = initialSelectors[i];\\n    }\\n\\n    return functionSelectors;\\n}\\n\"\r\n    },\r\n    \"../../node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"src/utils/RayMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.21;\\n\\nimport {RAY} from \\\"../DataStructure/Global.sol\\\";\\nimport {Ray} from \\\"../DataStructure/Objects.sol\\\";\\n\\n/// @notice Manipulates fixed-point unsigned decimals numbers\\n/// @dev all uints are considered integers (no wad)\\nlibrary RayMath {\\n    // ~~~ calculus ~~~ //\\n\\n    /// @notice `a` plus `b`\\n    /// @return result\\n    function add(Ray a, Ray b) internal pure returns (Ray) {\\n        return Ray.wrap(Ray.unwrap(a) + Ray.unwrap(b));\\n    }\\n\\n    /// @notice `a` minus `b`\\n    /// @return result\\n    function sub(Ray a, Ray b) internal pure returns (Ray) {\\n        return Ray.wrap(Ray.unwrap(a) - Ray.unwrap(b));\\n    }\\n\\n    /// @notice `a` times `b`\\n    /// @return result\\n    function mul(Ray a, Ray b) internal pure returns (Ray) {\\n        return Ray.wrap((Ray.unwrap(a) * Ray.unwrap(b)) / RAY);\\n    }\\n\\n    /// @notice `a` times `b`\\n    /// @return result\\n    function mul(Ray a, uint256 b) internal pure returns (Ray) {\\n        return Ray.wrap(Ray.unwrap(a) * b);\\n    }\\n\\n    /// @notice `a` times `b`\\n    /// @return result\\n    function mul(uint256 a, Ray b) internal pure returns (uint256) {\\n        return (a * Ray.unwrap(b)) / RAY;\\n    }\\n\\n    /// @notice `a` divided by `b`\\n    /// @return result\\n    function div(Ray a, Ray b) internal pure returns (Ray) {\\n        return Ray.wrap((Ray.unwrap(a) * RAY) / Ray.unwrap(b));\\n    }\\n\\n    /// @notice `a` divided by `b`\\n    /// @return result\\n    function div(Ray a, uint256 b) internal pure returns (Ray) {\\n        return Ray.wrap(Ray.unwrap(a) / b);\\n    }\\n\\n    /// @notice `a` divided by `b`\\n    /// @return result\\n    function div(uint256 a, Ray b) internal pure returns (uint256) {\\n        return (a * RAY) / Ray.unwrap(b);\\n    }\\n\\n    /// @notice `a` divided by `b`\\n    /// @return result\\n    function div(uint256 a, uint256 b) internal pure returns (Ray) {\\n        return Ray.wrap((a * RAY) / b);\\n    }\\n\\n    // ~~~ comparisons ~~~ //\\n\\n    /// @notice is `a` less than `b`\\n    /// @return result\\n    function lt(Ray a, Ray b) internal pure returns (bool) {\\n        return Ray.unwrap(a) < Ray.unwrap(b);\\n    }\\n\\n    /// @notice is `a` greater than `b`\\n    /// @return result\\n    function gt(Ray a, Ray b) internal pure returns (bool) {\\n        return Ray.unwrap(a) > Ray.unwrap(b);\\n    }\\n\\n    /// @notice is `a` greater or equal to `b`\\n    /// @return result\\n    function gte(Ray a, Ray b) internal pure returns (bool) {\\n        return Ray.unwrap(a) >= Ray.unwrap(b);\\n    }\\n\\n    /// @notice is `a` equal to `b`\\n    /// @return result\\n    function eq(Ray a, Ray b) internal pure returns (bool) {\\n        return Ray.unwrap(a) == Ray.unwrap(b);\\n    }\\n\\n    // ~~~ uint256 method ~~~ //\\n\\n    /// @notice highest value among `a` and `b`\\n    /// @return maximum\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/utils/Erc20CheckedTransfer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.21;\\n\\nimport {SafeERC20} from \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\n/// @notice library to safely transfer ERC20 tokens, including not entirely compliant tokens like BNB and USDT\\n/// @dev avoids bugs due to tokens not following the erc20 standard by not returning a boolean\\n///     or by reverting on 0 amount transfers. Does not support fee on transfer tokens\\nlibrary Erc20CheckedTransfer {\\n    using SafeERC20 for IERC20;\\n\\n    /// @notice executes only if amount is greater than zero\\n    /// @param amount amount to check\\n    modifier skipZeroAmount(uint256 amount) {\\n        if (amount > 0) {\\n            _;\\n        }\\n    }\\n\\n    /// @notice safely transfers\\n    /// @param currency ERC20 to transfer\\n    /// @param from sender\\n    /// @param to recipient\\n    /// @param amount amount to transfer\\n    function checkedTransferFrom(\\n        IERC20 currency,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal skipZeroAmount(amount) {\\n        currency.safeTransferFrom(from, to, amount);\\n    }\\n\\n    /// @notice safely transfers\\n    /// @param currency ERC20 to transfer\\n    /// @param to recipient\\n    /// @param amount amount to transfer\\n    function checkedTransfer(IERC20 currency, address to, uint256 amount) internal skipZeroAmount(amount) {\\n        currency.safeTransfer(to, amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"../../node_modules/@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"src/interface/IBorrowHandlers.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.21;\\n\\nimport {IBorrowCheckers} from \\\"./IBorrowCheckers.sol\\\";\\n\\n/* solhint-disable-next-line no-empty-blocks */\\ninterface IBorrowHandlers is IBorrowCheckers {\\n    /// @notice one loan has been initiated\\n    /// @param loanId id of the loan\\n    /// @param loan the loan created\\n    event Borrow(uint256 indexed loanId, bytes loan);\\n}\\n\"\r\n    },\r\n    \"../../node_modules/forge-std/src/interfaces/IMulticall3.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.2 <0.9.0;\\n\\npragma experimental ABIEncoderV2;\\n\\ninterface IMulticall3 {\\n    struct Call {\\n        address target;\\n        bytes callData;\\n    }\\n\\n    struct Call3 {\\n        address target;\\n        bool allowFailure;\\n        bytes callData;\\n    }\\n\\n    struct Call3Value {\\n        address target;\\n        bool allowFailure;\\n        uint256 value;\\n        bytes callData;\\n    }\\n\\n    struct Result {\\n        bool success;\\n        bytes returnData;\\n    }\\n\\n    function aggregate(Call[] calldata calls)\\n        external\\n        payable\\n        returns (uint256 blockNumber, bytes[] memory returnData);\\n\\n    function aggregate3(Call3[] calldata calls) external payable returns (Result[] memory returnData);\\n\\n    function aggregate3Value(Call3Value[] calldata calls) external payable returns (Result[] memory returnData);\\n\\n    function blockAndAggregate(Call[] calldata calls)\\n        external\\n        payable\\n        returns (uint256 blockNumber, bytes32 blockHash, Result[] memory returnData);\\n\\n    function getBasefee() external view returns (uint256 basefee);\\n\\n    function getBlockHash(uint256 blockNumber) external view returns (bytes32 blockHash);\\n\\n    function getBlockNumber() external view returns (uint256 blockNumber);\\n\\n    function getChainId() external view returns (uint256 chainid);\\n\\n    function getCurrentBlockCoinbase() external view returns (address coinbase);\\n\\n    function getCurrentBlockDifficulty() external view returns (uint256 difficulty);\\n\\n    function getCurrentBlockGasLimit() external view returns (uint256 gaslimit);\\n\\n    function getCurrentBlockTimestamp() external view returns (uint256 timestamp);\\n\\n    function getEthBalance(address addr) external view returns (uint256 balance);\\n\\n    function getLastBlockHash() external view returns (bytes32 blockHash);\\n\\n    function tryAggregate(bool requireSuccess, Call[] calldata calls)\\n        external\\n        payable\\n        returns (Result[] memory returnData);\\n\\n    function tryBlockAndAggregate(bool requireSuccess, Call[] calldata calls)\\n        external\\n        payable\\n        returns (uint256 blockNumber, bytes32 blockHash, Result[] memory returnData);\\n}\\n\"\r\n    },\r\n    \"../../node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"src/BorrowLogic/BorrowCheckers.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.21;\\n\\nimport {ECDSA} from \\\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\\\";\\nimport {MerkleProof} from \\\"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\\\";\\n\\nimport {IBorrowCheckers} from \\\"../interface/IBorrowCheckers.sol\\\";\\n\\nimport {Signature} from \\\"../Signature.sol\\\";\\nimport {NFTokenUtils} from \\\"../utils/NFTokenUtils.sol\\\";\\nimport {Offer, OfferArg, NFToken, ApiCoSignedPayload} from \\\"../../src/DataStructure/Objects.sol\\\";\\nimport {Protocol} from \\\"../../src/DataStructure/Storage.sol\\\";\\nimport {protocolStorage, apiCoSignerStorage} from \\\"../../src/DataStructure/Global.sol\\\";\\n// solhint-disable-next-line max-line-length\\nimport {BadCollateral, OfferHasExpired, RequestedAmountIsUnderMinimum, CurrencyNotSupported, InvalidTranche, InvalidApiCoSignature, ApiCoSignatureExpired} from \\\"../../src/DataStructure/Errors.sol\\\";\\n\\n/// @notice handles checks to verify validity of a loan request\\nabstract contract BorrowCheckers is IBorrowCheckers, Signature {\\n    using NFTokenUtils for NFToken;\\n    using MerkleProof for bytes32[];\\n\\n    /// @notice checks arguments validity for usage of one Offer\\n    /// @param arg arguments for the Offer\\n    /// @return signer computed signer of `arg.signature` according to `arg.offer`\\n    function checkOfferArg(OfferArg memory arg) internal view returns (address signer) {\\n        Protocol storage proto = protocolStorage();\\n\\n        /* it is statistically impossible to forge a signature that would lead to finding a signer that does not aggrees\\n        to the signed loan offer and that usage wouldn't revert due to the absence of approved funds to mobilize. This\\n        is how we know the signer address can't be the wrong one without leading to a revert. */\\n        signer = ECDSA.recover(offerDigest(arg.offer), arg.apiCoSignedPayload.lenderSignature);\\n\\n        checkApiValidation(arg.apiCoSignedPayload, arg.apiSignature);\\n\\n        /* we use a lower bound, I.e the actual amount must be strictly higher that this bound as a way to prevent a 0\\n        amount to be used even in the case of an uninitialized parameter for a given erc20. This bound set by governance\\n        is used as an anti-ddos measure to prevent borrowers to spam the creation of supply positions not worth to claim\\n        by lenders from a gas cost perspective after a liquidation. more info in docs */\\n        uint256 amountLowerBound = proto.offerBorrowAmountLowerBound[arg.offer.assetToLend];\\n\\n        // only erc20s for which the governance has set minimum thresholds are safe to use\\n        if (amountLowerBound == 0 || proto.minOfferCost[arg.offer.assetToLend] == 0) {\\n            revert CurrencyNotSupported(arg.offer.assetToLend);\\n        }\\n\\n        if (!(arg.amount > amountLowerBound)) {\\n            revert RequestedAmountIsUnderMinimum(arg.offer, arg.amount, amountLowerBound);\\n        }\\n        /* the offer expiration date is meant to be used by lenders as a way to manage the evolution of market\\n        conditions */\\n        if (block.timestamp > arg.offer.expirationDate) {\\n            revert OfferHasExpired(arg.offer, arg.offer.expirationDate);\\n        }\\n\\n        /* as tranches can't be deactivated, checking the number of tranches allows us to deduce if the tranche id is\\n        valid */\\n        if (arg.offer.tranche >= proto.nbOfTranches) {\\n            revert InvalidTranche(proto.nbOfTranches);\\n        }\\n    }\\n\\n    /// @notice checks collateral validity regarding the offer\\n    /// @param offer loan offer which validity should be checked for the provided collateral\\n    /// @param providedNft nft sent to be used as collateral\\n    /// @param merkleProof proof that providedNft is contained in the list referenced by offer\\n    function checkCollateral(\\n        Offer memory offer,\\n        NFToken memory providedNft,\\n        bytes32[] memory merkleProof\\n    ) internal pure {\\n        // we check the lender indeed approves the usage of its offer for the collateral used\\n        if (!merkleProof.verify(offer.nftListMerkleRoot, keccak256(abi.encode(providedNft)))) {\\n            revert BadCollateral(offer, providedNft);\\n        }\\n    }\\n\\n    /// @notice checks the api co-signed validation\\n    /// @param apiCoSignedPayload the payload to check, limit date and lender signature\\n    /// @param apiSignature the signature of the payload, by the api key\\n    function checkApiValidation(ApiCoSignedPayload memory apiCoSignedPayload, bytes memory apiSignature) internal view {\\n        if (\\n            apiCoSignerStorage().apiAddress != ECDSA.recover(apiCoSignedPayloadDigest(apiCoSignedPayload), apiSignature)\\n        ) {\\n            revert InvalidApiCoSignature(apiCoSignedPayload, apiSignature);\\n        }\\n\\n        if (block.timestamp > apiCoSignedPayload.inclusionLimitDate) {\\n            revert ApiCoSignatureExpired(apiCoSignedPayload.inclusionLimitDate, block.timestamp);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/SupplyPositionLogic/SafeMint.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.21;\\n\\nimport {NFTUtils} from \\\"./NFTUtils.sol\\\";\\nimport {Provision, SupplyPosition} from \\\"../DataStructure/Storage.sol\\\";\\nimport {supplyPositionStorage} from \\\"../DataStructure/Global.sol\\\";\\n\\n/// @notice safeMint internal method added to base ERC721 implementation for supply position minting\\n/// @dev inherit this to make an ERC721-compliant facet with added feature internal safeMint\\ncontract SafeMint is NFTUtils {\\n    /// @notice mints a new supply position to `to`\\n    /// @param to receiver of the position\\n    /// @param provision metadata of the supply position\\n    /// @return tokenId identifier of the supply position\\n    function safeMint(address to, Provision memory provision) internal returns (uint256 tokenId) {\\n        SupplyPosition storage sp = supplyPositionStorage();\\n\\n        tokenId = ++sp.totalSupply;\\n        sp.provision[tokenId] = provision;\\n        _safeMint(to, tokenId);\\n    }\\n}\\n\"\r\n    },\r\n    \"../../node_modules/diamond/contracts/libraries/LibDiamond.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\nimport { IDiamond } from \\\"../interfaces/IDiamond.sol\\\";\\nimport { IDiamondCut } from \\\"../interfaces/IDiamondCut.sol\\\";\\n\\n// Remember to add the loupe functions from DiamondLoupeFacet to the diamond.\\n// The loupe functions are required by the EIP2535 Diamonds standard\\n\\nerror NoSelectorsGivenToAdd();\\nerror NotContractOwner(address _user, address _contractOwner);\\nerror NoSelectorsProvidedForFacetForCut(address _facetAddress);\\nerror CannotAddSelectorsToZeroAddress(bytes4[] _selectors);\\nerror NoBytecodeAtAddress(address _contractAddress, string _message);\\nerror IncorrectFacetCutAction(uint8 _action);\\nerror CannotAddFunctionToDiamondThatAlreadyExists(bytes4 _selector);\\nerror CannotReplaceFunctionsFromFacetWithZeroAddress(bytes4[] _selectors);\\nerror CannotReplaceImmutableFunction(bytes4 _selector);\\nerror CannotReplaceFunctionWithTheSameFunctionFromTheSameFacet(bytes4 _selector);\\nerror CannotReplaceFunctionThatDoesNotExists(bytes4 _selector);\\nerror RemoveFacetAddressMustBeZeroAddress(address _facetAddress);\\nerror CannotRemoveFunctionThatDoesNotExist(bytes4 _selector);\\nerror CannotRemoveImmutableFunction(bytes4 _selector);\\nerror InitializationFunctionReverted(address _initializationContractAddress, bytes _calldata);\\n\\nlibrary LibDiamond {\\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\\\"diamond.standard.diamond.storage\\\");\\n\\n    struct FacetAddressAndSelectorPosition {\\n        address facetAddress;\\n        uint16 selectorPosition;\\n    }\\n\\n    struct DiamondStorage {\\n        // function selector => facet address and selector position in selectors array\\n        mapping(bytes4 => FacetAddressAndSelectorPosition) facetAddressAndSelectorPosition;\\n        bytes4[] selectors;\\n        mapping(bytes4 => bool) supportedInterfaces;\\n        // owner of the contract\\n        address contractOwner;\\n    }\\n\\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\\n        bytes32 position = DIAMOND_STORAGE_POSITION;\\n        assembly {\\n            ds.slot := position\\n        }\\n    }\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    function setContractOwner(address _newOwner) internal {\\n        DiamondStorage storage ds = diamondStorage();\\n        address previousOwner = ds.contractOwner;\\n        ds.contractOwner = _newOwner;\\n        emit OwnershipTransferred(previousOwner, _newOwner);\\n    }\\n\\n    function contractOwner() internal view returns (address contractOwner_) {\\n        contractOwner_ = diamondStorage().contractOwner;\\n    }\\n\\n    function enforceIsContractOwner() internal view {\\n        if(msg.sender != diamondStorage().contractOwner) {\\n            revert NotContractOwner(msg.sender, diamondStorage().contractOwner);\\n        }        \\n    }\\n\\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\\n\\n    // Internal function version of diamondCut\\n    function diamondCut(\\n        IDiamondCut.FacetCut[] memory _diamondCut,\\n        address _init,\\n        bytes memory _calldata\\n    ) internal {\\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\\n            bytes4[] memory functionSelectors = _diamondCut[facetIndex].functionSelectors;\\n            address facetAddress = _diamondCut[facetIndex].facetAddress;\\n            if(functionSelectors.length == 0) {\\n                revert NoSelectorsProvidedForFacetForCut(facetAddress);\\n            }\\n            IDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;\\n            if (action == IDiamond.FacetCutAction.Add) {\\n                addFunctions(facetAddress, functionSelectors);\\n            } else if (action == IDiamond.FacetCutAction.Replace) {\\n                replaceFunctions(facetAddress, functionSelectors);\\n            } else if (action == IDiamond.FacetCutAction.Remove) {\\n                removeFunctions(facetAddress, functionSelectors);\\n            } else {\\n                revert IncorrectFacetCutAction(uint8(action));\\n            }\\n        }\\n        emit DiamondCut(_diamondCut, _init, _calldata);\\n        initializeDiamondCut(_init, _calldata);\\n    }\\n\\n    function addFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {        \\n        if(_facetAddress == address(0)) {\\n            revert CannotAddSelectorsToZeroAddress(_functionSelectors);\\n        }\\n        DiamondStorage storage ds = diamondStorage();\\n        uint16 selectorCount = uint16(ds.selectors.length);                \\n        enforceHasContractCode(_facetAddress, \\\"LibDiamondCut: Add facet has no code\\\");\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = ds.facetAddressAndSelectorPosition[selector].facetAddress;\\n            if(oldFacetAddress != address(0)) {\\n                revert CannotAddFunctionToDiamondThatAlreadyExists(selector);\\n            }            \\n            ds.facetAddressAndSelectorPosition[selector] = FacetAddressAndSelectorPosition(_facetAddress, selectorCount);\\n            ds.selectors.push(selector);\\n            selectorCount++;\\n        }\\n    }\\n\\n    function replaceFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {        \\n        DiamondStorage storage ds = diamondStorage();\\n        if(_facetAddress == address(0)) {\\n            revert CannotReplaceFunctionsFromFacetWithZeroAddress(_functionSelectors);\\n        }\\n        enforceHasContractCode(_facetAddress, \\\"LibDiamondCut: Replace facet has no code\\\");\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = ds.facetAddressAndSelectorPosition[selector].facetAddress;\\n            // can't replace immutable functions -- functions defined directly in the diamond in this case\\n            if(oldFacetAddress == address(this)) {\\n                revert CannotReplaceImmutableFunction(selector);\\n            }\\n            if(oldFacetAddress == _facetAddress) {\\n                revert CannotReplaceFunctionWithTheSameFunctionFromTheSameFacet(selector);\\n            }\\n            if(oldFacetAddress == address(0)) {\\n                revert CannotReplaceFunctionThatDoesNotExists(selector);\\n            }\\n            // replace old facet address\\n            ds.facetAddressAndSelectorPosition[selector].facetAddress = _facetAddress;\\n        }\\n    }\\n\\n    function removeFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {        \\n        DiamondStorage storage ds = diamondStorage();\\n        uint256 selectorCount = ds.selectors.length;\\n        if(_facetAddress != address(0)) {\\n            revert RemoveFacetAddressMustBeZeroAddress(_facetAddress);\\n        }        \\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            FacetAddressAndSelectorPosition memory oldFacetAddressAndSelectorPosition = ds.facetAddressAndSelectorPosition[selector];\\n            if(oldFacetAddressAndSelectorPosition.facetAddress == address(0)) {\\n                revert CannotRemoveFunctionThatDoesNotExist(selector);\\n            }\\n            \\n            \\n            // can't remove immutable functions -- functions defined directly in the diamond\\n            if(oldFacetAddressAndSelectorPosition.facetAddress == address(this)) {\\n                revert CannotRemoveImmutableFunction(selector);\\n            }\\n            // replace selector with last selector\\n            selectorCount--;\\n            if (oldFacetAddressAndSelectorPosition.selectorPosition != selectorCount) {\\n                bytes4 lastSelector = ds.selectors[selectorCount];\\n                ds.selectors[oldFacetAddressAndSelectorPosition.selectorPosition] = lastSelector;\\n                ds.facetAddressAndSelectorPosition[lastSelector].selectorPosition = oldFacetAddressAndSelectorPosition.selectorPosition;\\n            }\\n            // delete last selector\\n            ds.selectors.pop();\\n            delete ds.facetAddressAndSelectorPosition[selector];\\n        }\\n    }\\n\\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\\n        if (_init == address(0)) {\\n            return;\\n        }\\n        enforceHasContractCode(_init, \\\"LibDiamondCut: _init address has no code\\\");        \\n        (bool success, bytes memory error) = _init.delegatecall(_calldata);\\n        if (!success) {\\n            if (error.length > 0) {\\n                // bubble up error\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    let returndata_size := mload(error)\\n                    revert(add(32, error), returndata_size)\\n                }\\n            } else {\\n                revert InitializationFunctionReverted(_init, _calldata);\\n            }\\n        }        \\n    }\\n\\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\\n        uint256 contractSize;\\n        assembly {\\n            contractSize := extcodesize(_contract)\\n        }\\n        if(contractSize == 0) {\\n            revert NoBytecodeAtAddress(_contract, _errorMessage);\\n        }        \\n    }\\n}\\n\"\r\n    },\r\n    \"../../node_modules/diamond/contracts/interfaces/IERC173.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @title ERC-173 Contract Ownership Standard\\n///  Note: the ERC-165 identifier for this interface is 0x7f5828d0\\n/* is ERC165 */\\ninterface IERC173 {\\n    /// @dev This emits when ownership of a contract changes.\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /// @notice Get the address of the owner\\n    /// @return owner_ The address of the owner.\\n    function owner() external view returns (address owner_);\\n\\n    /// @notice Set the address of the new owner of the contract\\n    /// @dev Set _newOwner to address(0) to renounce any ownership.\\n    /// @param _newOwner The address of the new owner of the contract\\n    function transferOwnership(address _newOwner) external;\\n}\\n\"\r\n    },\r\n    \"../../node_modules/diamond/contracts/interfaces/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IERC165 {\\n    /// @notice Query if a contract implements an interface\\n    /// @param interfaceId The interface identifier, as specified in ERC-165\\n    /// @dev Interface identification is specified in ERC-165. This function\\n    ///  uses less than 30,000 gas.\\n    /// @return `true` if the contract implements `interfaceID` and\\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"src/DataStructure/ERC721Errors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.21;\\n\\nerror ERC721AddressZeroIsNotAValidOwner();\\nerror ERC721InvalidTokenId();\\nerror ERC721ApprovalToCurrentOwner();\\nerror ERC721CallerIsNotOwnerNorApprovedForAll();\\nerror ERC721CallerIsNotOwnerNorApproved();\\nerror ERC721TransferToNonERC721ReceiverImplementer();\\nerror ERC721MintToTheZeroAddress();\\nerror ERC721TokenAlreadyMinted();\\nerror ERC721TransferFromIncorrectOwner();\\nerror ERC721TransferToTheZeroAddress();\\nerror ERC721ApproveToCaller();\\nerror ERC721CallerIsNotOwner();\\n\"\r\n    },\r\n    \"src/SupplyPositionLogic/DiamondERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.21;\\n\\nimport {Address} from \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport {IERC721Receiver} from \\\"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\\\";\\nimport {IERC721} from \\\"../interface/IERC721.sol\\\";\\nimport {NFTUtils} from \\\"./NFTUtils.sol\\\";\\nimport {SupplyPosition} from \\\"../DataStructure/Storage.sol\\\";\\nimport {supplyPositionStorage} from \\\"../DataStructure/Global.sol\\\";\\nimport {ERC721AddressZeroIsNotAValidOwner, ERC721ApprovalToCurrentOwner, ERC721CallerIsNotOwnerNorApproved, ERC721CallerIsNotOwnerNorApprovedForAll} from \\\"../DataStructure/ERC721Errors.sol\\\";\\n\\n/// @title ERC721 Diamond Facet\\n/// @notice implements basic ERC721 for usage as a diamond facet\\n/// @dev based on OpenZeppelin's implementation\\n///     this is a minimalist implementation, notably missing are the\\n///     tokenURI, _baseURI, _beforeTokenTransfer and _afterTokenTransfer methods\\n/// @author Kairos protocol\\nabstract contract DiamondERC721 is IERC721, NFTUtils {\\n    using Address for address;\\n\\n    error Unauthorized();\\n\\n    // constructor equivalent is in the Initializer contract\\n\\n    /// @dev don't use this method for inclusion in the facet function selectors\\n    ///     prefer the LibDiamond implementation for this method\\n    ///     it is included here for IERC721-compliance\\n    /* solhint-disable-next-line no-empty-blocks */\\n    function supportsInterface(bytes4 interfaceId) public view returns (bool) {}\\n\\n    function balanceOf(address owner) public view virtual returns (uint256) {\\n        SupplyPosition storage sp = supplyPositionStorage();\\n\\n        if (owner == address(0)) {\\n            revert ERC721AddressZeroIsNotAValidOwner();\\n        }\\n        return sp.balance[owner];\\n    }\\n\\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\\n        return _ownerOf(tokenId);\\n    }\\n\\n    function name() public view virtual returns (string memory) {\\n        SupplyPosition storage sp = supplyPositionStorage();\\n\\n        return sp.name;\\n    }\\n\\n    function symbol() public view virtual returns (string memory) {\\n        SupplyPosition storage sp = supplyPositionStorage();\\n\\n        return sp.symbol;\\n    }\\n\\n    function approve(address to, uint256 tokenId) public virtual {\\n        address owner = ownerOf(tokenId);\\n        if (to == owner) {\\n            revert ERC721ApprovalToCurrentOwner();\\n        }\\n        if (msg.sender != owner && !isApprovedForAll(owner, msg.sender)) {\\n            revert ERC721CallerIsNotOwnerNorApprovedForAll();\\n        }\\n\\n        _approve(to, tokenId);\\n    }\\n\\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\\n        return _getApproved(tokenId);\\n    }\\n\\n    function setApprovalForAll(address operator, bool approved) public virtual {\\n        _setApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\\n        return _isApprovedForAll(owner, operator);\\n    }\\n\\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\\n        if (!_isApprovedOrOwner(msg.sender, tokenId)) {\\n            revert ERC721CallerIsNotOwnerNorApproved();\\n        }\\n\\n        _transfer(from, to, tokenId);\\n    }\\n\\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual {\\n        safeTransferFrom(from, to, tokenId, \\\"\\\");\\n    }\\n\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\\n        if (!_isApprovedOrOwner(msg.sender, tokenId)) {\\n            revert ERC721CallerIsNotOwnerNorApproved();\\n        }\\n        _safeTransfer(from, to, tokenId, data);\\n    }\\n}\\n\"\r\n    },\r\n    \"../../node_modules/@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/Math.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n}\\n\"\r\n    },\r\n    \"../../node_modules/@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../extensions/draft-IERC20Permit.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    function safePermit(\\n        IERC20Permit token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interface/IBorrowCheckers.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.21;\\n\\nimport {ISignature} from \\\"./ISignature.sol\\\";\\n\\n/* solhint-disable-next-line no-empty-blocks */\\ninterface IBorrowCheckers is ISignature {\\n\\n}\\n\"\r\n    },\r\n    \"../../node_modules/@openzeppelin/contracts/utils/cryptography/ECDSA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/ECDSA.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../Strings.sol\\\";\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    enum RecoverError {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS,\\n        InvalidSignatureV // Deprecated in v4.8\\n    }\\n\\n    function _throwError(RecoverError error) private pure {\\n        if (error == RecoverError.NoError) {\\n            return; // no error: do nothing\\n        } else if (error == RecoverError.InvalidSignature) {\\n            revert(\\\"ECDSA: invalid signature\\\");\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        } else if (error == RecoverError.InvalidSignatureS) {\\n            revert(\\\"ECDSA: invalid signature 's' value\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature` or error string. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return tryRecover(hash, v, r, s);\\n        } else {\\n            return (address(0), RecoverError.InvalidSignatureLength);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address, RecoverError) {\\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\\n        return tryRecover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\n     *\\n     * _Available since v4.2._\\n     */\\n    function recover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address, RecoverError) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (302): v \u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return (address(0), RecoverError.InvalidSignatureS);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        if (signer == address(0)) {\\n            return (address(0), RecoverError.InvalidSignature);\\n        }\\n\\n        return (signer, RecoverError.NoError);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n\\\", Strings.toString(s.length), s));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\n    }\\n}\\n\"\r\n    },\r\n    \"../../node_modules/@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/MerkleProof.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev These functions deal with verification of Merkle Tree proofs.\\n *\\n * The tree and the proofs can be generated using our\\n * https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\\n * You will find a quickstart guide in the readme.\\n *\\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\\n * hashing, or use a hash function other than keccak256 for hashing leaves.\\n * This is because the concatenation of a sorted pair of internal nodes in\\n * the merkle tree could be reinterpreted as a leaf value.\\n * OpenZeppelin's JavaScript library generates merkle trees that are safe\\n * against this attack out of the box.\\n */\\nlibrary MerkleProof {\\n    /**\\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\\n     * defined by `root`. For this, a `proof` must be provided, containing\\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\\n     */\\n    function verify(\\n        bytes32[] memory proof,\\n        bytes32 root,\\n        bytes32 leaf\\n    ) internal pure returns (bool) {\\n        return processProof(proof, leaf) == root;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {verify}\\n     *\\n     * _Available since v4.7._\\n     */\\n    function verifyCalldata(\\n        bytes32[] calldata proof,\\n        bytes32 root,\\n        bytes32 leaf\\n    ) internal pure returns (bool) {\\n        return processProofCalldata(proof, leaf) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\\n     * hash matches the root of the tree. When processing the proof, the pairs\\n     * of leafs & pre-images are assumed to be sorted.\\n     *\\n     * _Available since v4.4._\\n     */\\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            computedHash = _hashPair(computedHash, proof[i]);\\n        }\\n        return computedHash;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {processProof}\\n     *\\n     * _Available since v4.7._\\n     */\\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            computedHash = _hashPair(computedHash, proof[i]);\\n        }\\n        return computedHash;\\n    }\\n\\n    /**\\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a merkle tree defined by\\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\\n     *\\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\\n     *\\n     * _Available since v4.7._\\n     */\\n    function multiProofVerify(\\n        bytes32[] memory proof,\\n        bool[] memory proofFlags,\\n        bytes32 root,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bool) {\\n        return processMultiProof(proof, proofFlags, leaves) == root;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {multiProofVerify}\\n     *\\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\\n     *\\n     * _Available since v4.7._\\n     */\\n    function multiProofVerifyCalldata(\\n        bytes32[] calldata proof,\\n        bool[] calldata proofFlags,\\n        bytes32 root,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bool) {\\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\\n     * respectively.\\n     *\\n     * CAUTION: Not all merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\\n     *\\n     * _Available since v4.7._\\n     */\\n    function processMultiProof(\\n        bytes32[] memory proof,\\n        bool[] memory proofFlags,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bytes32 merkleRoot) {\\n        // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by\\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\\n        // the merkle tree.\\n        uint256 leavesLen = leaves.length;\\n        uint256 totalHashes = proofFlags.length;\\n\\n        // Check proof validity.\\n        require(leavesLen + proof.length - 1 == totalHashes, \\\"MerkleProof: invalid multiproof\\\");\\n\\n        // The xxxPos values are \\\"pointers\\\" to the next value to consume in each array. All accesses are done using\\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \\\"pop\\\".\\n        bytes32[] memory hashes = new bytes32[](totalHashes);\\n        uint256 leafPos = 0;\\n        uint256 hashPos = 0;\\n        uint256 proofPos = 0;\\n        // At each step, we compute the next hash using two values:\\n        // - a value from the \\\"main queue\\\". If not all leaves have been consumed, we get the next leaf, otherwise we\\n        //   get the next hash.\\n        // - depending on the flag, either another value for the \\\"main queue\\\" (merging branches) or an element from the\\n        //   `proof` array.\\n        for (uint256 i = 0; i < totalHashes; i++) {\\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\\n            hashes[i] = _hashPair(a, b);\\n        }\\n\\n        if (totalHashes > 0) {\\n            return hashes[totalHashes - 1];\\n        } else if (leavesLen > 0) {\\n            return leaves[0];\\n        } else {\\n            return proof[0];\\n        }\\n    }\\n\\n    /**\\n     * @dev Calldata version of {processMultiProof}.\\n     *\\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\\n     *\\n     * _Available since v4.7._\\n     */\\n    function processMultiProofCalldata(\\n        bytes32[] calldata proof,\\n        bool[] calldata proofFlags,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bytes32 merkleRoot) {\\n        // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by\\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\\n        // the merkle tree.\\n        uint256 leavesLen = leaves.length;\\n        uint256 totalHashes = proofFlags.length;\\n\\n        // Check proof validity.\\n        require(leavesLen + proof.length - 1 == totalHashes, \\\"MerkleProof: invalid multiproof\\\");\\n\\n        // The xxxPos values are \\\"pointers\\\" to the next value to consume in each array. All accesses are done using\\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \\\"pop\\\".\\n        bytes32[] memory hashes = new bytes32[](totalHashes);\\n        uint256 leafPos = 0;\\n        uint256 hashPos = 0;\\n        uint256 proofPos = 0;\\n        // At each step, we compute the next hash using two values:\\n        // - a value from the \\\"main queue\\\". If not all leaves have been consumed, we get the next leaf, otherwise we\\n        //   get the next hash.\\n        // - depending on the flag, either another value for the \\\"main queue\\\" (merging branches) or an element from the\\n        //   `proof` array.\\n        for (uint256 i = 0; i < totalHashes; i++) {\\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\\n            hashes[i] = _hashPair(a, b);\\n        }\\n\\n        if (totalHashes > 0) {\\n            return hashes[totalHashes - 1];\\n        } else if (leavesLen > 0) {\\n            return leaves[0];\\n        } else {\\n            return proof[0];\\n        }\\n    }\\n\\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\\n    }\\n\\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, a)\\n            mstore(0x20, b)\\n            value := keccak256(0x00, 0x40)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/Signature.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.21;\\n\\nimport {EIP712} from \\\"@openzeppelin/contracts/utils/cryptography/EIP712.sol\\\";\\n\\nimport {ISignature} from \\\"./interface/ISignature.sol\\\";\\n\\nimport {NFToken} from \\\"./DataStructure/Objects.sol\\\";\\nimport {Offer, ApiCoSignedPayload} from \\\"./DataStructure/Objects.sol\\\";\\n\\n/// @notice handles signature verification\\nabstract contract Signature is ISignature, EIP712 {\\n    bytes32 internal constant OFFER_TYPEHASH =\\n        keccak256(\\n            \\\"Offer(address assetToLend,uint256 loanToValue,uint256 duration,\\\"\\n            \\\"uint256 expirationDate,uint256 tranche,bytes32 nftListMerkleRoot)\\\"\\n        ); // strings based on ethers js output\\n    bytes32 internal constant API_CO_SIGNED_PAYLOAD_TYPEHASH =\\n        keccak256(\\\"ApiCoSignedPayload(uint256 inclusionLimitDate,bytes lenderSignature)\\\");\\n\\n    /* solhint-disable-next-line no-empty-blocks */\\n    constructor() EIP712(\\\"Kairos Loan protocol\\\", \\\"1.0\\\") {}\\n\\n    /// @notice computes EIP-712 compliant digest of a loan offer\\n    /// @param offer the loan offer signed/to sign by a supplier\\n    /// @return digest the digest, ecdsa sign as is to produce a valid loan offer signature\\n    function offerDigest(Offer memory offer) public view returns (bytes32) {\\n        return _hashTypedDataV4(typeHashOffer(offer));\\n    }\\n\\n    /// @notice computes EIP-712 hashStruct of an api co-signed payload\\n    /// @param apiPayload - to sign/signed by the api\\n    /// @return digest the digest, ecdsa sign as is to produce a valid api co validation\\n    function apiCoSignedPayloadDigest(ApiCoSignedPayload memory apiPayload) public view returns (bytes32) {\\n        return _hashTypedDataV4(typeHashApiCoSignedPayload(apiPayload));\\n    }\\n\\n    /// @notice computes EIP-712 hashStruct of an api co-signed payload\\n    /// @param apiPayload - to get the hash from\\n    /// @return typehash of the api co-signed payload\\n    function typeHashApiCoSignedPayload(ApiCoSignedPayload memory apiPayload) internal pure returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    API_CO_SIGNED_PAYLOAD_TYPEHASH,\\n                    apiPayload.inclusionLimitDate,\\n                    keccak256(abi.encodePacked(apiPayload.lenderSignature))\\n                )\\n            );\\n    }\\n\\n    /// @notice computes EIP-712 hashStruct of an offer\\n    /// @param offer the loan offer to hash\\n    /// @return the hashStruct\\n    function typeHashOffer(Offer memory offer) internal pure returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    OFFER_TYPEHASH,\\n                    offer.assetToLend,\\n                    offer.loanToValue,\\n                    offer.duration,\\n                    offer.expirationDate,\\n                    offer.tranche,\\n                    offer.nftListMerkleRoot\\n                )\\n            );\\n    }\\n}\\n\"\r\n    },\r\n    \"src/utils/NFTokenUtils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.21;\\n\\nimport {NFToken} from \\\"../DataStructure/Objects.sol\\\";\\n\\n/// @notice Manipulates NFTs\\nlibrary NFTokenUtils {\\n    /// @notice `a` is the the same NFT as `b`\\n    /// @return result\\n    function eq(NFToken memory a, NFToken memory b) internal pure returns (bool) {\\n        return (a.id == b.id && a.implem == b.implem);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/SupplyPositionLogic/NFTUtils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.21;\\n\\nimport {IERC721Receiver} from \\\"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\\\";\\nimport {Address} from \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\n\\nimport {IERC721Events} from \\\"../interface/IERC721Events.sol\\\";\\nimport {supplyPositionStorage} from \\\"../DataStructure/Global.sol\\\";\\nimport {SupplyPosition} from \\\"../DataStructure/Storage.sol\\\";\\nimport {ERC721ApproveToCaller, ERC721InvalidTokenId, ERC721TokenAlreadyMinted, ERC721MintToTheZeroAddress, ERC721TransferFromIncorrectOwner, ERC721TransferToNonERC721ReceiverImplementer, ERC721TransferToTheZeroAddress} from \\\"../DataStructure/ERC721Errors.sol\\\";\\n\\n/// @notice internal logic for DiamondERC721 adapted fo usage with diamond storage\\nabstract contract NFTUtils is IERC721Events {\\n    using Address for address;\\n\\n    function emitTransfer(address from, address to, uint256 tokenId) internal {\\n        emit Transfer(from, to, tokenId);\\n    }\\n\\n    function emitApproval(address owner, address approved, uint256 tokenId) internal {\\n        emit Approval(owner, approved, tokenId);\\n    }\\n\\n    function emitApprovalForAll(address owner, address operator, bool approved) internal {\\n        emit ApprovalForAll(owner, operator, approved);\\n    }\\n\\n    function _checkOnERC721Received(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) internal returns (bool) {\\n        if (to.isContract()) {\\n            try IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, data) returns (bytes4 retval) {\\n                return retval == IERC721Receiver.onERC721Received.selector;\\n            } catch (bytes memory reason) {\\n                if (reason.length == 0) {\\n                    revert ERC721TransferToNonERC721ReceiverImplementer();\\n                } else {\\n                    /* solhint-disable-next-line no-inline-assembly */\\n                    assembly {\\n                        revert(add(32, reason), mload(reason))\\n                    }\\n                }\\n            }\\n        } else {\\n            return true;\\n        }\\n    }\\n\\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal {\\n        _transfer(from, to, tokenId);\\n        if (!_checkOnERC721Received(from, to, tokenId, data)) {\\n            revert ERC721TransferToNonERC721ReceiverImplementer();\\n        }\\n    }\\n\\n    function _safeMint(address to, uint256 tokenId) internal {\\n        _safeMint(to, tokenId, \\\"\\\");\\n    }\\n\\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal {\\n        _mint(to, tokenId);\\n        if (!_checkOnERC721Received(address(0), to, tokenId, data)) {\\n            revert ERC721TransferToNonERC721ReceiverImplementer();\\n        }\\n    }\\n\\n    function _mint(address to, uint256 tokenId) internal {\\n        SupplyPosition storage sp = supplyPositionStorage();\\n\\n        if (to == address(0)) {\\n            revert ERC721MintToTheZeroAddress();\\n        }\\n        if (_exists(tokenId)) {\\n            revert ERC721TokenAlreadyMinted();\\n        }\\n\\n        sp.balance[to] += 1;\\n        sp.owner[tokenId] = to;\\n\\n        emitTransfer(address(0), to, tokenId);\\n    }\\n\\n    function _burn(uint256 tokenId) internal {\\n        SupplyPosition storage sp = supplyPositionStorage();\\n\\n        address owner = _ownerOf(tokenId);\\n\\n        // Clear approvals\\n        _approve(address(0), tokenId);\\n\\n        sp.balance[owner] -= 1;\\n        delete sp.owner[tokenId];\\n\\n        emitTransfer(owner, address(0), tokenId);\\n    }\\n\\n    function _transfer(address from, address to, uint256 tokenId) internal {\\n        SupplyPosition storage sp = supplyPositionStorage();\\n\\n        if (_ownerOf(tokenId) != from) {\\n            revert ERC721TransferFromIncorrectOwner();\\n        }\\n        if (to == address(0)) {\\n            revert ERC721TransferToTheZeroAddress();\\n        }\\n\\n        // Clear approvals from the previous owner\\n        _approve(address(0), tokenId);\\n\\n        sp.balance[from] -= 1;\\n        sp.balance[to] += 1;\\n        sp.owner[tokenId] = to;\\n\\n        emitTransfer(from, to, tokenId);\\n    }\\n\\n    function _approve(address to, uint256 tokenId) internal {\\n        SupplyPosition storage sp = supplyPositionStorage();\\n\\n        sp.tokenApproval[tokenId] = to;\\n        emitApproval(_ownerOf(tokenId), to, tokenId);\\n    }\\n\\n    function _setApprovalForAll(address owner, address operator, bool approved) internal {\\n        SupplyPosition storage sp = supplyPositionStorage();\\n\\n        if (owner == operator) {\\n            revert ERC721ApproveToCaller();\\n        }\\n        sp.operatorApproval[owner][operator] = approved;\\n        emitApprovalForAll(owner, operator, approved);\\n    }\\n\\n    function _exists(uint256 tokenId) internal view returns (bool) {\\n        SupplyPosition storage sp = supplyPositionStorage();\\n\\n        return sp.owner[tokenId] != address(0);\\n    }\\n\\n    function _ownerOf(uint256 tokenId) internal view returns (address) {\\n        SupplyPosition storage sp = supplyPositionStorage();\\n\\n        address owner = sp.owner[tokenId];\\n        if (owner == address(0)) {\\n            revert ERC721InvalidTokenId();\\n        }\\n        return owner;\\n    }\\n\\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {\\n        address owner = _ownerOf(tokenId);\\n        return (spender == owner || _isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\\n    }\\n\\n    function _getApproved(uint256 tokenId) internal view returns (address) {\\n        if (!_exists(tokenId)) {\\n            revert ERC721InvalidTokenId();\\n        }\\n\\n        return supplyPositionStorage().tokenApproval[tokenId];\\n    }\\n\\n    function _isApprovedForAll(address owner, address operator) internal view returns (bool) {\\n        return supplyPositionStorage().operatorApproval[owner][operator];\\n    }\\n}\\n\"\r\n    },\r\n    \"../../node_modules/@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interface/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.21;\\n\\nimport {IERC165} from \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\nimport {IERC721Events} from \\\"./IERC721Events.sol\\\";\\n\\n/**\\n * @dev Required interface without events of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165, IERC721Events {\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"../../node_modules/@openzeppelin/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1);\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator,\\n        Rounding rounding\\n    ) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10**64) {\\n                value /= 10**64;\\n                result += 64;\\n            }\\n            if (value >= 10**32) {\\n                value /= 10**32;\\n                result += 32;\\n            }\\n            if (value >= 10**16) {\\n                value /= 10**16;\\n                result += 16;\\n            }\\n            if (value >= 10**8) {\\n                value /= 10**8;\\n                result += 8;\\n            }\\n            if (value >= 10**4) {\\n                value /= 10**4;\\n                result += 4;\\n            }\\n            if (value >= 10**2) {\\n                value /= 10**2;\\n                result += 2;\\n            }\\n            if (value >= 10**1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"../../node_modules/@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"../../node_modules/@openzeppelin/contracts/utils/cryptography/EIP712.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/EIP712.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ECDSA.sol\\\";\\n\\n/**\\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\\n *\\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\\n *\\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\\n * ({_hashTypedDataV4}).\\n *\\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\\n * the chain id to protect against replay attacks on an eventual fork of the chain.\\n *\\n * NOTE: This contract implements the version of the encoding known as \\\"v4\\\", as implemented by the JSON RPC method\\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\\n *\\n * _Available since v3.4._\\n */\\nabstract contract EIP712 {\\n    /* solhint-disable var-name-mixedcase */\\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\\n    // invalidate the cached domain separator if the chain id changes.\\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\\n    uint256 private immutable _CACHED_CHAIN_ID;\\n    address private immutable _CACHED_THIS;\\n\\n    bytes32 private immutable _HASHED_NAME;\\n    bytes32 private immutable _HASHED_VERSION;\\n    bytes32 private immutable _TYPE_HASH;\\n\\n    /* solhint-enable var-name-mixedcase */\\n\\n    /**\\n     * @dev Initializes the domain separator and parameter caches.\\n     *\\n     * The meaning of `name` and `version` is specified in\\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\\n     *\\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\\n     * - `version`: the current major version of the signing domain.\\n     *\\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\\n     * contract upgrade].\\n     */\\n    constructor(string memory name, string memory version) {\\n        bytes32 hashedName = keccak256(bytes(name));\\n        bytes32 hashedVersion = keccak256(bytes(version));\\n        bytes32 typeHash = keccak256(\\n            \\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"\\n        );\\n        _HASHED_NAME = hashedName;\\n        _HASHED_VERSION = hashedVersion;\\n        _CACHED_CHAIN_ID = block.chainid;\\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\\n        _CACHED_THIS = address(this);\\n        _TYPE_HASH = typeHash;\\n    }\\n\\n    /**\\n     * @dev Returns the domain separator for the current chain.\\n     */\\n    function _domainSeparatorV4() internal view returns (bytes32) {\\n        if (address(this) == _CACHED_THIS && block.chainid == _CACHED_CHAIN_ID) {\\n            return _CACHED_DOMAIN_SEPARATOR;\\n        } else {\\n            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\\n        }\\n    }\\n\\n    function _buildDomainSeparator(\\n        bytes32 typeHash,\\n        bytes32 nameHash,\\n        bytes32 versionHash\\n    ) private view returns (bytes32) {\\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\\n    }\\n\\n    /**\\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\\n     * function returns the hash of the fully encoded EIP712 message for this domain.\\n     *\\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\\n     *\\n     * ```solidity\\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\\n     *     keccak256(\\\"Mail(address to,string contents)\\\"),\\n     *     mailTo,\\n     *     keccak256(bytes(mailContents))\\n     * )));\\n     * address signer = ECDSA.recover(digest, signature);\\n     * ```\\n     */\\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\\n        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interface/IERC721Events.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.21;\\n\\n/**\\n * @dev Required events of an ERC721 compliant contract.\\n */\\ninterface IERC721Events {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@openzeppelin/=../../node_modules/@openzeppelin/\",\r\n      \"forge-std/=../../node_modules/forge-std/src/\",\r\n      \"ds-test/=../../node_modules/ds-test/src/\",\r\n      \"diamond/=../../node_modules/diamond/\",\r\n      \"@kairos-loan-solidity-shared/=../../node_modules/@kairos-loan/solidity-shared/src/\",\r\n      \"@balancer-labs/=../../node_modules/@balancer-labs/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"}],\"name\":\"CallerIsNotOwner\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"apiAddress\",\"type\":\"address\"}],\"name\":\"NewApiAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"newAuctionDuration\",\"type\":\"uint256\"}],\"name\":\"NewAuctionDuration\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"Ray\",\"name\":\"newAuctionPriceFactor\",\"type\":\"uint256\"}],\"name\":\"NewAuctionPriceFactor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract IERC20\",\"name\":\"currency\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"newLowerBound\",\"type\":\"uint256\"}],\"name\":\"NewBorrowAmountPerOfferLowerBound\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract IERC20\",\"name\":\"currency\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"newMinOfferCost\",\"type\":\"uint256\"}],\"name\":\"NewMininimumOfferCost\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"Ray\",\"name\":\"tranche\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"newTrancheId\",\"type\":\"uint256\"}],\"name\":\"NewTranche\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"Ray\",\"name\":\"newTranche\",\"type\":\"uint256\"}],\"name\":\"createTranche\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"newTrancheId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"apiAddress\",\"type\":\"address\"}],\"name\":\"setApiAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newAuctionDuration\",\"type\":\"uint256\"}],\"name\":\"setAuctionDuration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"Ray\",\"name\":\"newAuctionPriceFactor\",\"type\":\"uint256\"}],\"name\":\"setAuctionPriceFactor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"baseMetadataUri\",\"type\":\"string\"}],\"name\":\"setBaseMetadataUri\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"currency\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"newLowerBound\",\"type\":\"uint256\"}],\"name\":\"setBorrowAmountPerOfferLowerBound\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"currency\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"newMinOfferCost\",\"type\":\"uint256\"}],\"name\":\"setMinOfferCost\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "AdminFacet", "CompilerVersion": "v0.8.21+commit.d9974bed", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "paris", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://159b10706ea094600698e4d55d234dab94bd0438e3cfcca1f09d261c85c0fda3"}