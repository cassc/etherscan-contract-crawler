{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {\r\n      \"src/Tokens/TradingTokenV1.sol:TradingTokenV1\": {\r\n        \"SafeMath\": \"0x27Cf55873A1d78323800B3e353Df5aCCdf2896Be\",\r\n        \"SafeERC20\": \"0x7804D4203Cad579e4fCF0509444a7B8a277C510E\"\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"src/Control/IOwnableV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n\\r\\n/**\\r\\n * @title Ownable\\r\\n * \\r\\n * parent for ownable contracts\\r\\n */\\r\\ninterface IOwnableV2 {\\r\\n  event OwnershipTransferred(address indexed oldOwner, address indexed newOwner);\\r\\n\\r\\n  function owner() external view returns (address);\\r\\n  function transferOwnership(address newOwner_) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"src/Control/IPausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport { IOwnableV2 } from \\\"./IOwnableV2.sol\\\";\\r\\n\\r\\ninterface IPausable is IOwnableV2 {\\r\\n  function paused() external view returns (bool);\\r\\n  function setPaused(bool value) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"src/Control/OwnableV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport { Context } from \\\"../library/Context.sol\\\";\\r\\nimport { IOwnableV2 } from \\\"./IOwnableV2.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title Ownable\\r\\n * \\r\\n * parent for ownable contracts\\r\\n */\\r\\nabstract contract OwnableV2 is IOwnableV2, Context {\\r\\n  constructor(address owner_) {\\r\\n    _owner_ = owner_;\\r\\n    emit OwnershipTransferred(address(0), _owner());\\r\\n  }\\r\\n\\r\\n  address internal _owner_;\\r\\n\\r\\n  function _owner() internal virtual view returns (address) {\\r\\n    return _owner_;\\r\\n  }\\r\\n\\r\\n  function owner() external virtual override view returns (address) {\\r\\n    return _owner();\\r\\n  }\\r\\n\\r\\n  modifier onlyOwner() {\\r\\n    require(_owner() == _msgSender(), \\\"Only the owner can execute this function\\\");\\r\\n    _;\\r\\n  }\\r\\n\\r\\n  function _transferOwnership(address newOwner_) internal virtual onlyOwner {\\r\\n    // keep track of old owner for event\\r\\n    address oldOwner = _owner();\\r\\n\\r\\n    // set the new owner\\r\\n    _owner_ = newOwner_;\\r\\n\\r\\n    // emit event about ownership change\\r\\n    emit OwnershipTransferred(oldOwner, _owner());\\r\\n  }\\r\\n\\r\\n  function transferOwnership(address newOwner_) external virtual override onlyOwner {\\r\\n    _transferOwnership(newOwner_);\\r\\n  }\\r\\n}\\r\\n\"\r\n    },\r\n    \"src/Fees/FeeCollector.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport { IFeeCollector } from \\\"./IFeeCollector.sol\\\";\\r\\nimport { Address } from \\\"../library/Address.sol\\\";\\r\\nimport { IFees } from \\\"./IFees.sol\\\";\\r\\nimport { OwnableV2 } from \\\"../Control/OwnableV2.sol\\\";\\r\\n\\r\\nabstract contract FeeCollector is IFeeCollector, OwnableV2 {\\r\\n  using Address for address payable;\\r\\n\\r\\n  IFees internal _fees;\\r\\n\\r\\n  uint256 internal _feePercentDenominator = 10 ** 18;\\r\\n\\r\\n  modifier takeFee(string memory feeType) {\\r\\n    bool exempt = _fees.isAddressExemptFromFees(_msgSender());\\r\\n    require(exempt || _fees.getFeeAmountForType(feeType) == msg.value, \\\"Incorrect fee\\\");\\r\\n    if (!exempt)\\r\\n      payable(address(_fees)).sendValue(msg.value);\\r\\n    _;\\r\\n  }\\r\\n\\r\\n  function feesContract() external view override returns (address) {\\r\\n    return address(_fees);\\r\\n  }\\r\\n\\r\\n  function _setFeesContract(address contractAddress) internal virtual {\\r\\n    _fees = IFees(contractAddress);\\r\\n  }\\r\\n\\r\\n  function setFeesContract(address contractAddress) external override onlyOwner {\\r\\n    _setFeesContract(contractAddress);\\r\\n  }\\r\\n\\r\\n  function feePercentDenominator() external view override returns (uint256) {\\r\\n    return _feePercentDenominator;\\r\\n  }\\r\\n\\r\\n  function setFeePercentDenominator(uint256 value) external virtual override onlyOwner {\\r\\n    _feePercentDenominator = value;\\r\\n  }\\r\\n\\r\\n  function _getFeePercentInRange(\\r\\n    string memory minFeeType,\\r\\n    string memory maxFeeType,\\r\\n    uint256 input,\\r\\n    uint256 percent\\r\\n  ) internal virtual view returns (uint256) {\\r\\n    uint256 feeMin = _fees.getFeeAmountForType(minFeeType);\\r\\n    uint256 feeMax = _fees.getFeeAmountForType(maxFeeType);\\r\\n\\r\\n    uint256 feeAmount = feeMin;\\r\\n    feeAmount += (feeMax - feeMin) * percent / _feePercentDenominator;\\r\\n\\r\\n    return input * feeAmount / _feePercentDenominator;\\r\\n  }\\r\\n\\r\\n  function getFeePercentInRange(\\r\\n    string memory minFeeType,\\r\\n    string memory maxFeeType,\\r\\n    uint256 input,\\r\\n    uint256 percent\\r\\n  ) external view override returns (uint256) {\\r\\n    return _getFeePercentInRange(minFeeType, maxFeeType, input, percent);\\r\\n  }\\r\\n\\r\\n  function _takeFeePercentInRange(\\r\\n    string memory minFeeType,\\r\\n    string memory maxFeeType,\\r\\n    uint256 amount,\\r\\n    uint256 percent\\r\\n  ) internal virtual {\\r\\n    require(\\r\\n      _getFeePercentInRange(minFeeType, maxFeeType, amount, percent) == msg.value,\\r\\n      \\\"Incorrect fee\\\"\\r\\n    );\\r\\n\\r\\n    if (!_fees.isAddressExemptFromFees(_msgSender()))\\r\\n      payable(address(_fees)).sendValue(msg.value);\\r\\n  }\\r\\n}\\r\\n\"\r\n    },\r\n    \"src/Fees/IFeeCollector.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport { IOwnableV2 } from \\\"../Control/IOwnableV2.sol\\\";\\r\\n\\r\\ninterface IFeeCollector is IOwnableV2 {\\r\\n  function feesContract() external view returns (address);\\r\\n  function setFeesContract(address contractAddress_) external;\\r\\n  function feePercentDenominator() external view returns (uint256);\\r\\n  function setFeePercentDenominator(uint256 value) external;\\r\\n  function getFeePercentInRange(\\r\\n    string memory minFeeType,\\r\\n    string memory maxFeeType,\\r\\n    uint256 input,\\r\\n    uint256 percent\\r\\n  ) external view returns (uint256 output);\\r\\n}\\r\\n\"\r\n    },\r\n    \"src/Fees/IFees.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport { IGovernable } from \\\"../Governance/IGovernable.sol\\\";\\r\\nimport { IPausable } from \\\"../Control/IPausable.sol\\\";\\r\\n\\r\\ninterface IFees is IGovernable, IPausable {\\r\\n  function getFeeAmountForType(string memory feeType) external view returns (uint256);\\r\\n  function setFeeAmountForType(string memory feeType, uint256 amount) external;\\r\\n  function setAddressExemptFromFees(address account, bool value) external;\\r\\n  function isAddressExemptFromFees(address account) external view returns (bool);\\r\\n  function feesDistributed() external view returns (uint256 total, uint256 treasury, uint256 staking);\\r\\n  function treasuryFeeAddress() external view returns (address);\\r\\n  function setTreasuryFeeAddress(address payable value) external;\\r\\n  function stakingFeeAddress() external view returns (address);\\r\\n  function setStakingFeeAddress(address payable value) external;\\r\\n  function getFees() external view returns (uint16 treasuryFee, uint16 stakingFee);\\r\\n  function setFees(uint16 treasuryFee, uint16 stakingFee) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"src/Governance/IGovernable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport { IOwnableV2 } from \\\"../Control/IOwnableV2.sol\\\";\\r\\n\\r\\ninterface IGovernable is IOwnableV2 {\\r\\n  event GovernorshipTransferred(address indexed oldGovernor, address indexed newGovernor);\\r\\n\\r\\n  function governor() external view returns (address);\\r\\n  function transferGovernorship(address newGovernor) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"src/Tokens/ITradingTokenV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface ITradingTokenV1 {\\n  event SwapTokensForETH(\\n    uint256 amountIn,\\n    address[] path\\n  );\\n  function launch() external payable;\\n  function getTokenData() external view returns (\\n    string memory name_, \\n    string memory symbol_, \\n    uint8 decimals_,\\n    uint256 totalSupply_,\\n    uint256 totalBalance_,\\n    uint256 launchedAt,\\n    address owner_,\\n    address dexPair\\n  );\\n}\\n\"\r\n    },\r\n    \"src/Tokens/TradingTokenV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier:MIT\\n\\npragma solidity ^0.8.10;\\n\\nimport { ITradingTokenV1 } from \\\"./ITradingTokenV1.sol\\\";\\nimport { IERC20 } from \\\"../library/IERC20.sol\\\";\\nimport { OwnableV2 } from \\\"../Control/OwnableV2.sol\\\";\\nimport { SafeMath } from \\\"../library/SafeMath.sol\\\";\\nimport { FeeCollector } from \\\"../Fees/FeeCollector.sol\\\";\\nimport { IUniswapV2Factory, IUniswapV2Pair, IUniswapV2Router02 } from \\\"../library/Dex.sol\\\";\\n\\ncontract TradingTokenV1 is ITradingTokenV1, IERC20, OwnableV2, FeeCollector {\\n\\n  using SafeMath for uint256;\\n\\n  string private _name;\\n  string private _symbol;\\n  uint8 private _decimals;\\n\\n  address public immutable deadAddress = 0x000000000000000000000000000000000000dEaD;\\n  address public immutable zeroAddress = 0x0000000000000000000000000000000000000000;\\n\\n  uint _buyDevelopmentTax;\\n  uint _buyLpTax;\\n  uint _buyRewardTax;\\n\\n  uint _sellDevelopmentTax;\\n  uint _sellLpTax;\\n  uint _sellRewardTax;\\n\\n  uint public _totalBuyFee;\\n  uint public _totalSellFee;\\n  \\n  uint feedenominator = 100;\\n\\n  address public developmentWallet;\\n  address public lpReceiverWallet;\\n  address public rewardWallet;\\n\\n  mapping (address => uint256) _balances;\\n  mapping (address => mapping (address => uint256)) private _allowances;\\n\\n  mapping (address => bool) public isExcludedFromFee;\\n  mapping (address => bool) public isMarketPair;\\n  mapping (address => bool) public isWalletLimitExempt;\\n  mapping (address => bool) public isTxLimitExempt;\\n\\n  uint256 private _totalSupply;\\n\\n  uint256 public _maxTxAmount;\\n  uint256 public _maxWallet;\\n\\n  uint256 public swapThreshold;\\n\\n  uint256 public launchedAt;\\n  bool public normalizeTrade;\\n\\n  bool tradingActive;\\n\\n  bool public swapEnabled = false;\\n  bool public swapByLimit = false;\\n  bool public enableTxLimit = false;\\n  bool public checkWalletLimit = false;\\n\\n  IUniswapV2Router02 public dexRouter;\\n  address public dexPair;\\n\\n  bool inSwap;\\n\\n  modifier onlyGuard() {\\n    require(msg.sender == lpReceiverWallet,\\\"Invalid Caller\\\");\\n    _;\\n  }\\n\\n  modifier swapping() {\\n    inSwap = true;\\n    _;\\n    inSwap = false;\\n  }\\n\\n  constructor(\\n    string memory name_, \\n    string memory symbol_, \\n    uint8 decimals_,\\n    uint256 totalSupply_,\\n    address owner_,\\n    uint256[] memory tokenData\\n  ) OwnableV2(owner_) {\\n    _name = name_;\\n    _symbol = symbol_;\\n    _decimals = decimals_;\\n    _totalSupply = totalSupply_ * 10**_decimals;\\n\\n    _buyDevelopmentTax = tokenData[3];\\n    _buyLpTax = tokenData[4];\\n    _buyRewardTax = tokenData[5];\\n    _sellDevelopmentTax = tokenData[6];\\n    _sellLpTax = tokenData[7];\\n    _sellRewardTax = tokenData[8];\\n\\n    _totalBuyFee = _buyDevelopmentTax.add(_buyLpTax).add(_buyRewardTax);\\n    _totalSellFee = _sellDevelopmentTax.add(_sellLpTax).add(_sellRewardTax);\\n\\n    developmentWallet = address(uint160(tokenData[1]));\\n    rewardWallet = address(uint160(tokenData[2]));\\n\\n    _maxTxAmount = _totalSupply.mul(tokenData[9]).div(100);\\n    _maxWallet = _totalSupply.mul(tokenData[10]).div(100);\\n\\n    swapThreshold = tokenData[11] * 10**_decimals;\\n\\n    IUniswapV2Router02 _dexRouter = IUniswapV2Router02(address(uint160(tokenData[0])));\\n\\n    dexRouter = _dexRouter;\\n    \\n    lpReceiverWallet = owner_;\\n\\n    isExcludedFromFee[address(this)] = true;\\n    isExcludedFromFee[owner_] = true;\\n    isExcludedFromFee[address(dexRouter)] = true;\\n\\n    isWalletLimitExempt[owner_] = true;\\n    isWalletLimitExempt[address(dexRouter)] = true;\\n    isWalletLimitExempt[address(this)] = true;\\n    isWalletLimitExempt[deadAddress] = true;\\n    isWalletLimitExempt[zeroAddress] = true;\\n    \\n    isTxLimitExempt[deadAddress] = true;\\n    isTxLimitExempt[zeroAddress] = true;\\n    isTxLimitExempt[owner_] = true;\\n    isTxLimitExempt[address(this)] = true;\\n    isTxLimitExempt[address(dexRouter)] = true;\\n\\n    _allowances[address(this)][address(dexRouter)] = ~uint256(0);\\n\\n    _balances[owner_] = _totalSupply;\\n    emit Transfer(address(0), owner_, _totalSupply);\\n  }\\n\\n  function name() external view returns (string memory) {\\n    return _name;\\n  }\\n\\n  function symbol() external view returns (string memory) {\\n    return _symbol;\\n  }\\n\\n  function decimals() external view returns (uint8) {\\n    return _decimals;\\n  }\\n\\n  function totalSupply() external view override returns (uint256) {\\n    return _totalSupply;\\n  }\\n\\n  function balanceOf(address account) external view override returns (uint256) {\\n     return _balances[account];   \\n  }\\n\\n  function allowance(address owner, address spender) external view override returns (uint256) {\\n    return _allowances[owner][spender];\\n  }\\n  \\n  function getCirculatingSupply() external view returns (uint256) {\\n    return _totalSupply.sub(_balances[deadAddress]).sub(_balances[zeroAddress]);\\n  }\\n\\n  function increaseAllowance(address spender, uint256 addedValue) external virtual returns (bool) {\\n    _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\\n    return true;\\n  }\\n\\n  function decreaseAllowance(address spender, uint256 subtractedValue) external virtual returns (bool) {\\n    _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \\\"ERC20: decreased allowance below zero\\\"));\\n    return true;\\n  }\\n\\n  function approve(address spender, uint256 amount) external override returns (bool) {\\n    _approve(_msgSender(), spender, amount);\\n    return true;\\n  }\\n\\n  function _approve(address owner, address spender, uint256 amount) private {\\n    require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n    require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n    _allowances[owner][spender] = amount;\\n    emit Approval(owner, spender, amount);\\n  }\\n\\n   //to recieve ETH from Router when swaping\\n  receive() external payable {}\\n\\n  function transfer(address recipient, uint256 amount) external override returns (bool) {\\n    _transfer(_msgSender(), recipient, amount);\\n    return true;\\n  }\\n\\n  function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {\\n    _transfer(sender, recipient, amount);\\n    _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \\\"ERC20: Exceeds allowance\\\"));\\n    return true;\\n  }\\n\\n  function _transfer(address sender, address recipient, uint256 amount) private returns (bool) {\\n\\n    require(sender != address(0));\\n    require(recipient != address(0));\\n    require(amount > 0);\\n  \\n    if (inSwap) {\\n      return _basicTransfer(sender, recipient, amount);\\n    }\\n    else {\\n\\n      if (!tradingActive) {\\n        require(isExcludedFromFee[sender] || isExcludedFromFee[recipient],\\\"Trading is not active.\\\");\\n      }\\n\\n      if (launchedAt != 0 && !normalizeTrade) {\\n        dynamicTaxSetter();\\n      }\\n\\n      uint256 contractTokenBalance = _balances[address(this)];\\n      bool overMinimumTokenBalance = contractTokenBalance >= swapThreshold;\\n\\n      if (\\n        overMinimumTokenBalance && \\n        !inSwap && \\n        !isMarketPair[sender] && \\n        swapEnabled &&\\n        !isExcludedFromFee[sender] &&\\n        !isExcludedFromFee[recipient]\\n        ) {\\n        swapBack(contractTokenBalance);\\n      }\\n\\n      if(!isTxLimitExempt[sender] && !isTxLimitExempt[recipient] && enableTxLimit) {\\n        require(amount <= _maxTxAmount, \\\"Exceeds maxTxAmount\\\");\\n      } \\n      \\n      _balances[sender] = _balances[sender].sub(amount, \\\"Insufficient Balance\\\");\\n\\n      uint256 finalAmount = shouldNotTakeFee(sender,recipient) ? amount : takeTaxFee(sender, recipient, amount);\\n\\n      if(checkWalletLimit && !isWalletLimitExempt[recipient]) {\\n        require(_balances[recipient].add(finalAmount) <= _maxWallet,\\\"Exceeds maxWallet\\\");\\n      }\\n\\n      _balances[recipient] = _balances[recipient].add(finalAmount);\\n\\n      emit Transfer(sender, recipient, finalAmount);\\n      return true;\\n\\n    }\\n\\n  }\\n\\n  function _basicTransfer(address sender, address recipient, uint256 amount) internal returns (bool) {\\n    _balances[sender] = _balances[sender].sub(amount, \\\"Insufficient Balance\\\");\\n    _balances[recipient] = _balances[recipient].add(amount);\\n    emit Transfer(sender, recipient, amount);\\n    return true;\\n  }\\n  \\n  function shouldNotTakeFee(address sender, address recipient) internal view returns (bool) {\\n    if(isExcludedFromFee[sender] || isExcludedFromFee[recipient]) {\\n      return true;\\n    }\\n    else if (isMarketPair[sender] || isMarketPair[recipient]) {\\n      return false;\\n    }\\n    else {\\n      return false;\\n    }\\n  }\\n\\n  function takeTaxFee(address sender, address recipient, uint256 amount) internal returns (uint256) {\\n    \\n    uint feeAmount;\\n\\n    unchecked {\\n\\n      if(isMarketPair[sender]) { \\n        feeAmount = amount.mul(_totalBuyFee).div(feedenominator);\\n      } \\n      else if(isMarketPair[recipient]) { \\n        feeAmount = amount.mul(_totalSellFee).div(feedenominator);\\n      }\\n\\n      if(feeAmount > 0) {\\n        _balances[address(this)] = _balances[address(this)].add(feeAmount);\\n        emit Transfer(sender, address(this), feeAmount);\\n      }\\n\\n      return amount.sub(feeAmount);\\n    }\\n    \\n  }\\n\\n  function launch() external payable onlyOwner {\\n    require(launchedAt == 0, \\\"Already launched!\\\");\\n    launchedAt = block.number;\\n    tradingActive = true;\\n\\n    uint tokenForLp = _balances[address(this)];\\n\\n    _buyDevelopmentTax = 1;\\n    _buyLpTax = 0;\\n    _buyRewardTax = 0;\\n\\n    _sellDevelopmentTax = 1;\\n    _sellLpTax = 0;\\n    _sellRewardTax = 0;\\n\\n    dexRouter.addLiquidityETH{ value: msg.value }(\\n      address(this),\\n      tokenForLp,\\n      0,\\n      0,\\n      _owner(),\\n      block.timestamp\\n    );\\n\\n    IUniswapV2Factory factory = IUniswapV2Factory(dexRouter.factory());\\n\\n    IUniswapV2Pair pair = IUniswapV2Pair(factory.getPair(address(this), dexRouter.WETH()));\\n\\n    dexPair = address(pair);\\n\\n    isMarketPair[address(dexPair)] = true;\\n    isWalletLimitExempt[address(dexPair)] = true;\\n    _allowances[address(this)][address(dexPair)] = ~uint256(0);\\n\\n    swapEnabled = true;\\n    enableTxLimit = true;\\n    checkWalletLimit =  true;\\n  }\\n\\n  function dynamicTaxSetter() internal {\\n    if (block.number <= launchedAt + 3) {\\n      dynamicSetter(99,99);\\n    }\\n    if (block.number > launchedAt + 3 && block.number <= launchedAt + 22) {\\n      dynamicSetter(45,45);\\n    }\\n    if (block.number > launchedAt + 22) {\\n      dynamicSetter(4,4);\\n      normalizeTrade = true;\\n    }\\n      \\n  }\\n\\n  function dynamicSetter(uint _buy, uint _Sell) internal {\\n    _totalBuyFee = _buy;\\n    _totalSellFee = _Sell;\\n  }\\n\\n\\n  function swapBack(uint contractBalance) internal swapping {\\n\\n    if(swapByLimit) contractBalance = swapThreshold;\\n\\n    uint256 totalShares = _totalBuyFee.add(_totalSellFee);\\n\\n    uint256 _liquidityShare = _buyLpTax.add(_sellLpTax);\\n    // uint256 _developmentShare = _buydevelopmentTax.add(_selldevelopmentTax);\\n    uint256 _rewardShare = _buyRewardTax.add(_sellRewardTax);\\n\\n    uint256 tokensForLP = contractBalance.mul(_liquidityShare).div(totalShares).div(2);\\n    uint256 tokensForSwap = contractBalance.sub(tokensForLP);\\n\\n    uint256 initialBalance = address(this).balance;\\n    swapTokensForEth(tokensForSwap);\\n    uint256 amountReceived = address(this).balance.sub(initialBalance);\\n\\n    uint256 totalETHFee = totalShares.sub(_liquidityShare.div(2));\\n    \\n    uint256 amountETHLiquidity = amountReceived.mul(_liquidityShare).div(totalETHFee).div(2);\\n    uint256 amountETHReward = amountReceived.mul(_rewardShare).div(totalETHFee);\\n    uint256 amountETHDevelopment = amountReceived.sub(amountETHLiquidity).sub(amountETHReward);\\n\\n     if(amountETHReward > 0)\\n      payable(rewardWallet).transfer(amountETHReward);\\n\\n    if(amountETHDevelopment > 0)\\n      payable(developmentWallet).transfer(amountETHDevelopment);\\n\\n    if(amountETHLiquidity > 0 && tokensForLP > 0)\\n      addLiquidity(tokensForLP, amountETHLiquidity);\\n\\n  }\\n\\n  function addLiquidity(uint256 tokenAmount, uint256 ethAmount) private {\\n    // approve token transfer to cover all possible scenarios\\n    _approve(address(this), address(dexRouter), tokenAmount);\\n\\n    // add the liquidity\\n    dexRouter.addLiquidityETH{value: ethAmount}(\\n      address(this),\\n      tokenAmount,\\n      0, // slippage is unavoidable\\n      0, // slippage is unavoidable\\n      lpReceiverWallet,\\n      block.timestamp\\n    );\\n  }\\n\\n  function swapTokensForEth(uint256 tokenAmount) private {\\n    // generate the uniswap pair path of token -> weth\\n    address[] memory path = new address[](2);\\n    path[0] = address(this);\\n    path[1] = dexRouter.WETH();\\n\\n    _approve(address(this), address(dexRouter), tokenAmount);\\n\\n    // make the swap\\n    dexRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(\\n      tokenAmount,\\n      0, // accept any amount of ETH\\n      path,\\n      address(this), // The contract\\n      block.timestamp\\n    );\\n    \\n    emit SwapTokensForETH(tokenAmount, path);\\n  }\\n\\n  function rescueFunds() external onlyGuard { \\n    (bool os,) = payable(msg.sender).call{value: address(this).balance}(\\\"\\\");\\n    require(os,\\\"Transaction Failed!!\\\");\\n  }\\n\\n  function rescueTokens(address _token, address recipient, uint _amount) external onlyGuard {\\n    require(_token != address(0), \\\"_token address cannot be 0\\\");\\n    uint256 _contractBalance = IERC20(_token).balanceOf(address(this));\\n    require(_contractBalance >= _amount, \\\"Insufficient token balance\\\");\\n    IERC20(_token).transfer(recipient, _amount);\\n  }\\n\\n  function setBuyFee(uint _developmentFee, uint _lpFee, uint _rewardFee) external onlyOwner {  \\n    _buyDevelopmentTax = _developmentFee;\\n    _buyLpTax = _lpFee;\\n    _buyRewardTax = _rewardFee;\\n\\n    _totalBuyFee = _buyDevelopmentTax.add(_buyLpTax).add(_buyRewardTax);\\n  }\\n\\n  function setSellFee(uint _developmentFee, uint _lpFee, uint _rewardFee) external onlyOwner {\\n    _sellDevelopmentTax = _developmentFee;\\n    _sellLpTax = _lpFee;\\n    _sellRewardTax = _rewardFee;\\n    _totalSellFee = _sellDevelopmentTax.add(_sellLpTax).add(_sellRewardTax);\\n  }\\n\\n  function removeLimits() external onlyGuard {\\n    enableTxLimit = false;\\n    checkWalletLimit =  false;\\n  }\\n\\n  function setEnableTxLimit(bool _status) external onlyOwner {\\n    enableTxLimit = _status;\\n  }\\n\\n  function setEnableWalletLimit(bool _status) external onlyOwner {\\n    checkWalletLimit = _status;\\n  }\\n\\n  function excludeFromFee(address _adr,bool _status) external onlyOwner {\\n    isExcludedFromFee[_adr] = _status;\\n  }\\n\\n  function excludeWalletLimit(address _adr,bool _status) external onlyOwner {\\n    isWalletLimitExempt[_adr] = _status;\\n  }\\n\\n  function excludeTxLimit(address _adr,bool _status) external onlyOwner {\\n    isTxLimitExempt[_adr] = _status;\\n  }\\n\\n  function setMaxWalletLimit(uint256 newLimit) external onlyOwner() {\\n    _maxWallet = newLimit;\\n  }\\n\\n  function setTxLimit(uint256 newLimit) external onlyOwner() {\\n    _maxTxAmount = newLimit;\\n  }\\n  \\n  function setDevelopmentWallet(address _newWallet) external onlyOwner {\\n    developmentWallet = _newWallet;\\n  }\\n\\n  function setLpWallet(address _newWallet) external onlyOwner {\\n    lpReceiverWallet = _newWallet;\\n  }\\n\\n  function setRewardWallet(address _newWallet) external onlyOwner {\\n    rewardWallet = _newWallet;\\n  }\\n\\n  function setMarketPair(address _pair, bool _status) external onlyOwner {\\n    isMarketPair[_pair] = _status;\\n    if(_status) {\\n      isWalletLimitExempt[_pair] = _status;\\n    }\\n  }\\n\\n  function setSwapBackSettings(uint _threshold, bool _enabled, bool _limited)\\n    external\\n    onlyGuard\\n  {\\n    swapEnabled = _enabled;\\n    swapByLimit = _limited;\\n    swapThreshold = _threshold;\\n  }\\n\\n  function setManualRouter(address _router) external onlyOwner {\\n    dexRouter = IUniswapV2Router02(_router);\\n  }\\n\\n  function setManualPair(address _pair) external onlyOwner {\\n    dexPair = _pair;\\n  }\\n\\n  function getTokenData() external view returns (\\n    string memory name_, \\n    string memory symbol_, \\n    uint8 decimals_,\\n    uint256 totalSupply_,\\n    uint256 totalBalance_,\\n    uint256 launchedAt_,\\n    address owner_,\\n    address dexPair_\\n  ) {\\n    name_ = _name;\\n    symbol_ = _symbol;\\n    decimals_ = _decimals;\\n    totalSupply_ = _totalSupply;\\n    totalBalance_ = _balances[address(this)];\\n    launchedAt_ = launchedAt;\\n    owner_ = _owner();\\n    dexPair_ = dexPair;\\n  }\\n}\"\r\n    },\r\n    \"src/library/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts v4.4.0 (utils/Address.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Collection of functions related to the address type\\r\\n */\\r\\nlibrary Address {\\r\\n    /**\\r\\n     * @dev Returns true if `account` is a contract.\\r\\n     *\\r\\n     * [IMPORTANT]\\r\\n     * ====\\r\\n     * It is unsafe to assume that an address for which this function returns\\r\\n     * false is an externally-owned account (EOA) and not a contract.\\r\\n     *\\r\\n     * Among others, `isContract` will return false for the following\\r\\n     * types of addresses:\\r\\n     *\\r\\n     *  - an externally-owned account\\r\\n     *  - a contract in construction\\r\\n     *  - an address where a contract will be created\\r\\n     *  - an address where a contract lived, but was destroyed\\r\\n     * ====\\r\\n     */\\r\\n    function isContract(address account) internal view returns (bool) {\\r\\n        // This method relies on extcodesize, which returns 0 for contracts in\\r\\n        // construction, since the code is only stored at the end of the\\r\\n        // constructor execution.\\r\\n\\r\\n        uint256 size;\\r\\n        assembly {\\r\\n            size := extcodesize(account)\\r\\n        }\\r\\n        return size > 0;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\r\\n     * `recipient`, forwarding all available gas and reverting on errors.\\r\\n     *\\r\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\r\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\r\\n     * imposed by `transfer`, making them unable to receive funds via\\r\\n     * `transfer`. {sendValue} removes this limitation.\\r\\n     *\\r\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\r\\n     *\\r\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\r\\n     * taken to not create reentrancy vulnerabilities. Consider using\\r\\n     * {ReentrancyGuard} or the\\r\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\r\\n     */\\r\\n    function sendValue(address payable recipient, uint256 amount) internal {\\r\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\r\\n\\r\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\r\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Performs a Solidity function call using a low level `call`. A\\r\\n     * plain `call` is an unsafe replacement for a function call: use this\\r\\n     * function instead.\\r\\n     *\\r\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\r\\n     * function (like regular Solidity function calls).\\r\\n     *\\r\\n     * Returns the raw returned data. To convert to the expected return value,\\r\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `target` must be a contract.\\r\\n     * - calling `target` with `data` must not revert.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\r\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\r\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCall(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        string memory errorMessage\\r\\n    ) internal returns (bytes memory) {\\r\\n        return functionCallWithValue(target, data, 0, errorMessage);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\r\\n     * but also transferring `value` wei to `target`.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - the calling contract must have an ETH balance of at least `value`.\\r\\n     * - the called Solidity function must be `payable`.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCallWithValue(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        uint256 value\\r\\n    ) internal returns (bytes memory) {\\r\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\r\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCallWithValue(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        uint256 value,\\r\\n        string memory errorMessage\\r\\n    ) internal returns (bytes memory) {\\r\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\r\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\r\\n\\r\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\r\\n        return verifyCallResult(success, returndata, errorMessage);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\r\\n     * but performing a static call.\\r\\n     *\\r\\n     * _Available since v3.3._\\r\\n     */\\r\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\r\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\r\\n     * but performing a static call.\\r\\n     *\\r\\n     * _Available since v3.3._\\r\\n     */\\r\\n    function functionStaticCall(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        string memory errorMessage\\r\\n    ) internal view returns (bytes memory) {\\r\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\r\\n\\r\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\r\\n        return verifyCallResult(success, returndata, errorMessage);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\r\\n     * but performing a delegate call.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\r\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\r\\n     * but performing a delegate call.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function functionDelegateCall(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        string memory errorMessage\\r\\n    ) internal returns (bytes memory) {\\r\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\r\\n\\r\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\r\\n        return verifyCallResult(success, returndata, errorMessage);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\r\\n     * revert reason using the provided one.\\r\\n     *\\r\\n     * _Available since v4.3._\\r\\n     */\\r\\n    function verifyCallResult(\\r\\n        bool success,\\r\\n        bytes memory returndata,\\r\\n        string memory errorMessage\\r\\n    ) internal pure returns (bytes memory) {\\r\\n        if (success) {\\r\\n            return returndata;\\r\\n        } else {\\r\\n            // Look for revert reason and bubble it up if present\\r\\n            if (returndata.length > 0) {\\r\\n                // The easiest way to bubble the revert reason is using memory via assembly\\r\\n\\r\\n                assembly {\\r\\n                    let returndata_size := mload(returndata)\\r\\n                    revert(add(32, returndata), returndata_size)\\r\\n                }\\r\\n            } else {\\r\\n                revert(errorMessage);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"src/library/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts v4.3.2 (utils/Context.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Provides information about the current execution context, including the\\r\\n * sender of the transaction and its data. While these are generally available\\r\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\r\\n * manner, since when dealing with meta-transactions the account sending and\\r\\n * paying for execution may not be the actual sender (as far as an application\\r\\n * is concerned).\\r\\n *\\r\\n * This contract is only required for intermediate, library-like contracts.\\r\\n */\\r\\nabstract contract Context {\\r\\n    function _msgSender() internal view virtual returns (address) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n\\r\\n    function _msgData() internal view virtual returns (bytes calldata) {\\r\\n        return msg.data;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"src/library/Dex.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity >=0.6.2;\\r\\n\\r\\ninterface IUniswapV2Factory {\\r\\n  event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\r\\n\\r\\n  function feeTo() external view returns (address);\\r\\n  function feeToSetter() external view returns (address);\\r\\n\\r\\n  function getPair(address tokenA, address tokenB) external view returns (address pair);\\r\\n  function allPairs(uint) external view returns (address pair);\\r\\n  function allPairsLength() external view returns (uint);\\r\\n\\r\\n  function createPair(address tokenA, address tokenB) external returns (address pair);\\r\\n\\r\\n  function setFeeTo(address) external;\\r\\n  function setFeeToSetter(address) external;\\r\\n}\\r\\n\\r\\ninterface IUniswapV2Pair {\\r\\n  event Approval(address indexed owner, address indexed spender, uint value);\\r\\n  event Transfer(address indexed from, address indexed to, uint value);\\r\\n\\r\\n  function name() external pure returns (string memory);\\r\\n  function symbol() external pure returns (string memory);\\r\\n  function decimals() external pure returns (uint8);\\r\\n  function totalSupply() external view returns (uint);\\r\\n  function balanceOf(address owner) external view returns (uint);\\r\\n  function allowance(address owner, address spender) external view returns (uint);\\r\\n\\r\\n  function approve(address spender, uint value) external returns (bool);\\r\\n  function transfer(address to, uint value) external returns (bool);\\r\\n  function transferFrom(address from, address to, uint value) external returns (bool);\\r\\n\\r\\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\\r\\n  function PERMIT_TYPEHASH() external pure returns (bytes32);\\r\\n  function nonces(address owner) external view returns (uint);\\r\\n\\r\\n  function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\r\\n\\r\\n  event Mint(address indexed sender, uint amount0, uint amount1);\\r\\n  event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\r\\n  event Swap(\\r\\n    address indexed sender,\\r\\n    uint amount0In,\\r\\n    uint amount1In,\\r\\n    uint amount0Out,\\r\\n    uint amount1Out,\\r\\n    address indexed to\\r\\n  );\\r\\n  event Sync(uint112 reserve0, uint112 reserve1);\\r\\n\\r\\n  function MINIMUM_LIQUIDITY() external pure returns (uint);\\r\\n  function factory() external view returns (address);\\r\\n  function token0() external view returns (address);\\r\\n  function token1() external view returns (address);\\r\\n  function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\r\\n  function price0CumulativeLast() external view returns (uint);\\r\\n  function price1CumulativeLast() external view returns (uint);\\r\\n  function kLast() external view returns (uint);\\r\\n\\r\\n  function mint(address to) external returns (uint liquidity);\\r\\n  function burn(address to) external returns (uint amount0, uint amount1);\\r\\n  function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\r\\n  function skim(address to) external;\\r\\n  function sync() external;\\r\\n\\r\\n  function initialize(address, address) external;\\r\\n}\\r\\n\\r\\ninterface IUniswapV2Router01 {\\r\\n  function factory() external pure returns (address);\\r\\n  function WETH() external pure returns (address);\\r\\n\\r\\n  function addLiquidity(\\r\\n    address tokenA,\\r\\n    address tokenB,\\r\\n    uint amountADesired,\\r\\n    uint amountBDesired,\\r\\n    uint amountAMin,\\r\\n    uint amountBMin,\\r\\n    address to,\\r\\n    uint deadline\\r\\n  ) external returns (uint amountA, uint amountB, uint liquidity);\\r\\n  function addLiquidityETH(\\r\\n    address token,\\r\\n    uint amountTokenDesired,\\r\\n    uint amountTokenMin,\\r\\n    uint amountETHMin,\\r\\n    address to,\\r\\n    uint deadline\\r\\n  ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\r\\n  function removeLiquidity(\\r\\n    address tokenA,\\r\\n    address tokenB,\\r\\n    uint liquidity,\\r\\n    uint amountAMin,\\r\\n    uint amountBMin,\\r\\n    address to,\\r\\n    uint deadline\\r\\n  ) external returns (uint amountA, uint amountB);\\r\\n  function removeLiquidityETH(\\r\\n    address token,\\r\\n    uint liquidity,\\r\\n    uint amountTokenMin,\\r\\n    uint amountETHMin,\\r\\n    address to,\\r\\n    uint deadline\\r\\n  ) external returns (uint amountToken, uint amountETH);\\r\\n  function removeLiquidityWithPermit(\\r\\n    address tokenA,\\r\\n    address tokenB,\\r\\n    uint liquidity,\\r\\n    uint amountAMin,\\r\\n    uint amountBMin,\\r\\n    address to,\\r\\n    uint deadline,\\r\\n    bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n  ) external returns (uint amountA, uint amountB);\\r\\n  function removeLiquidityETHWithPermit(\\r\\n    address token,\\r\\n    uint liquidity,\\r\\n    uint amountTokenMin,\\r\\n    uint amountETHMin,\\r\\n    address to,\\r\\n    uint deadline,\\r\\n    bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n  ) external returns (uint amountToken, uint amountETH);\\r\\n  function swapExactTokensForTokens(\\r\\n    uint amountIn,\\r\\n    uint amountOutMin,\\r\\n    address[] calldata path,\\r\\n    address to,\\r\\n    uint deadline\\r\\n  ) external returns (uint[] memory amounts);\\r\\n  function swapTokensForExactTokens(\\r\\n    uint amountOut,\\r\\n    uint amountInMax,\\r\\n    address[] calldata path,\\r\\n    address to,\\r\\n    uint deadline\\r\\n  ) external returns (uint[] memory amounts);\\r\\n  function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\r\\n    external\\r\\n    payable\\r\\n    returns (uint[] memory amounts);\\r\\n  function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\r\\n    external\\r\\n    returns (uint[] memory amounts);\\r\\n  function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\r\\n    external\\r\\n    returns (uint[] memory amounts);\\r\\n  function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\r\\n    external\\r\\n    payable\\r\\n    returns (uint[] memory amounts);\\r\\n\\r\\n  function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\r\\n  function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\r\\n  function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\r\\n  function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\r\\n  function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\r\\n}\\r\\n\\r\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\r\\n  function removeLiquidityETHSupportingFeeOnTransferTokens(\\r\\n    address token,\\r\\n    uint liquidity,\\r\\n    uint amountTokenMin,\\r\\n    uint amountETHMin,\\r\\n    address to,\\r\\n    uint deadline\\r\\n  ) external returns (uint amountETH);\\r\\n  function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\r\\n    address token,\\r\\n    uint liquidity,\\r\\n    uint amountTokenMin,\\r\\n    uint amountETHMin,\\r\\n    address to,\\r\\n    uint deadline,\\r\\n    bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n  ) external returns (uint amountETH);\\r\\n\\r\\n  function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\r\\n    uint amountIn,\\r\\n    uint amountOutMin,\\r\\n    address[] calldata path,\\r\\n    address to,\\r\\n    uint deadline\\r\\n  ) external;\\r\\n  function swapExactETHForTokensSupportingFeeOnTransferTokens(\\r\\n    uint amountOutMin,\\r\\n    address[] calldata path,\\r\\n    address to,\\r\\n    uint deadline\\r\\n  ) external payable;\\r\\n  function swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n    uint amountIn,\\r\\n    uint amountOutMin,\\r\\n    address[] calldata path,\\r\\n    address to,\\r\\n    uint deadline\\r\\n  ) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"src/library/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface IERC20 {\\r\\n  function name() external view returns (string memory);\\r\\n  function symbol() external view returns (string memory);\\r\\n  function totalSupply() external view returns (uint256);\\r\\n  function decimals() external view returns (uint8);\\r\\n  function balanceOf(address account) external view returns (uint256);\\r\\n  function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n  function allowance(address owner, address spender) external view returns (uint256);\\r\\n  function approve(address spender, uint256 amount) external returns (bool);\\r\\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\n\"\r\n    },\r\n    \"src/library/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nlibrary SafeMath {\\n\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\"\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name_\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol_\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"decimals_\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"totalSupply_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenData\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"}],\"name\":\"SwapTokensForETH\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_maxTxAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_maxWallet\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_totalBuyFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_totalSellFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"checkWalletLimit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deadAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"developmentWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dexPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dexRouter\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enableTxLimit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_adr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"excludeFromFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_adr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"excludeTxLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_adr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"excludeWalletLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feePercentDenominator\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feesContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCirculatingSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"minFeeType\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"maxFeeType\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"input\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"percent\",\"type\":\"uint256\"}],\"name\":\"getFeePercentInRange\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTokenData\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"name_\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol_\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"decimals_\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"totalSupply_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBalance_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"launchedAt_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dexPair_\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isExcludedFromFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isMarketPair\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isTxLimitExempt\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isWalletLimitExempt\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"launch\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"launchedAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lpReceiverWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"normalizeTrade\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"removeLimits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rescueFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"rescueTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_developmentFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lpFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_rewardFee\",\"type\":\"uint256\"}],\"name\":\"setBuyFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newWallet\",\"type\":\"address\"}],\"name\":\"setDevelopmentWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"setEnableTxLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"setEnableWalletLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setFeePercentDenominator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"setFeesContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newWallet\",\"type\":\"address\"}],\"name\":\"setLpWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pair\",\"type\":\"address\"}],\"name\":\"setManualPair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_router\",\"type\":\"address\"}],\"name\":\"setManualRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pair\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"setMarketPair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newLimit\",\"type\":\"uint256\"}],\"name\":\"setMaxWalletLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newWallet\",\"type\":\"address\"}],\"name\":\"setRewardWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_developmentFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lpFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_rewardFee\",\"type\":\"uint256\"}],\"name\":\"setSellFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_threshold\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_limited\",\"type\":\"bool\"}],\"name\":\"setSwapBackSettings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newLimit\",\"type\":\"uint256\"}],\"name\":\"setTxLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapByLimit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner_\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"zeroAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "TradingTokenV1", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000009000000000000000000000000000000000000000000000000000000003b9aca000000000000000000000000009a42a20d3e3a25c968c8a80ae5d2ab445920854c0000000000000000000000000000000000000000000000000000000000000140000000000000000000000000000000000000000000000000000000000000000c54726164696e67546f6b656e0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000654544f4b454e0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000007a250d5630b4cf539739df2c5dacb4c659f2488d0000000000000000000000009a42a20d3e3a25c968c8a80ae5d2ab445920854c0000000000000000000000009a42a20d3e3a25c968c8a80ae5d2ab445920854c00000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000007a120", "EVMVersion": "paris", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}