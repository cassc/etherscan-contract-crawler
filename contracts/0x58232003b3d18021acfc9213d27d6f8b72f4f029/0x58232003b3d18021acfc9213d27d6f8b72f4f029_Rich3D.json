{"SourceCode": "pragma solidity ^0.4.24;\r\n\r\n/***********************************************************\r\n * @title SafeMath v0.1.9\r\n * @dev Math operations with safety checks that throw on error\r\n * change notes:  original SafeMath library from OpenZeppelin modified by Inventor\r\n * - added sqrt\r\n * - added sq\r\n * - added pwr \r\n * - changed asserts to requires with error log outputs\r\n * - removed div, its useless\r\n ***********************************************************/\r\n library SafeMath {\r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) \r\n        internal \r\n        pure \r\n        returns (uint256 c) \r\n    {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        require(c / a == b, \"SafeMath mul failed\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n    \r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256) \r\n    {\r\n        require(b <= a, \"SafeMath sub failed\");\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256 c) \r\n    {\r\n        c = a + b;\r\n        require(c >= a, \"SafeMath add failed\");\r\n        return c;\r\n    }\r\n    \r\n    /**\r\n     * @dev gives square root of given x.\r\n     */\r\n    function sqrt(uint256 x)\r\n        internal\r\n        pure\r\n        returns (uint256 y) \r\n    {\r\n        uint256 z = ((add(x,1)) / 2);\r\n        y = x;\r\n        while (z < y) \r\n        {\r\n            y = z;\r\n            z = ((add((x / z),z)) / 2);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev gives square. multiplies x by x\r\n     */\r\n    function sq(uint256 x)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return (mul(x,x));\r\n    }\r\n    \r\n    /**\r\n     * @dev x to the power of y \r\n     */\r\n    function pwr(uint256 x, uint256 y)\r\n        internal \r\n        pure \r\n        returns (uint256)\r\n    {\r\n        if (x==0)\r\n            return (0);\r\n        else if (y==0)\r\n            return (1);\r\n        else \r\n        {\r\n            uint256 z = x;\r\n            for (uint256 i=1; i < y; i++)\r\n                z = mul(z,x);\r\n            return (z);\r\n        }\r\n    }\r\n}\r\n/***********************************************************\r\n * NameFilter library\r\n ***********************************************************/\r\nlibrary NameFilter {\r\n    /**\r\n     * @dev filters name strings\r\n     * -converts uppercase to lower case.  \r\n     * -makes sure it does not start/end with a space\r\n     * -makes sure it does not contain multiple spaces in a row\r\n     * -cannot be only numbers\r\n     * -cannot start with 0x \r\n     * -restricts characters to A-Z, a-z, 0-9, and space.\r\n     * @return reprocessed string in bytes32 format\r\n     */\r\n    function nameFilter(string _input)\r\n        internal\r\n        pure\r\n        returns(bytes32)\r\n    {\r\n        bytes memory _temp = bytes(_input);\r\n        uint256 _length = _temp.length;\r\n        \r\n        //sorry limited to 32 characters\r\n        require (_length <= 32 && _length > 0, \"string must be between 1 and 32 characters\");\r\n        // make sure it doesnt start with or end with space\r\n        require(_temp[0] != 0x20 && _temp[_length-1] != 0x20, \"string cannot start or end with space\");\r\n        // make sure first two characters are not 0x\r\n        if (_temp[0] == 0x30)\r\n        {\r\n            require(_temp[1] != 0x78, \"string cannot start with 0x\");\r\n            require(_temp[1] != 0x58, \"string cannot start with 0X\");\r\n        }\r\n        \r\n        // create a bool to track if we have a non number character\r\n        bool _hasNonNumber;\r\n        \r\n        // convert & check\r\n        for (uint256 i = 0; i < _length; i++)\r\n        {\r\n            // if its uppercase A-Z\r\n            if (_temp[i] > 0x40 && _temp[i] < 0x5b)\r\n            {\r\n                // convert to lower case a-z\r\n                _temp[i] = byte(uint(_temp[i]) + 32);\r\n                \r\n                // we have a non number\r\n                if (_hasNonNumber == false)\r\n                    _hasNonNumber = true;\r\n            } else {\r\n                require\r\n                (\r\n                    // require character is a space\r\n                    _temp[i] == 0x20 || \r\n                    // OR lowercase a-z\r\n                    (_temp[i] > 0x60 && _temp[i] < 0x7b) ||\r\n                    // or 0-9\r\n                    (_temp[i] > 0x2f && _temp[i] < 0x3a),\r\n                    \"string contains invalid characters\"\r\n                );\r\n                // make sure theres not 2x spaces in a row\r\n                if (_temp[i] == 0x20)\r\n                    require( _temp[i+1] != 0x20, \"string cannot contain consecutive spaces\");\r\n                \r\n                // see if we have a character other than a number\r\n                if (_hasNonNumber == false && (_temp[i] < 0x30 || _temp[i] > 0x39))\r\n                    _hasNonNumber = true;    \r\n            }\r\n        }\r\n        \r\n        require(_hasNonNumber == true, \"string cannot be only numbers\");\r\n        \r\n        bytes32 _ret;\r\n        assembly {\r\n            _ret := mload(add(_temp, 32))\r\n        }\r\n        return (_ret);\r\n    }\r\n}\r\n/***********************************************************\r\n * Rich3DDatasets library\r\n ***********************************************************/\r\nlibrary Rich3DDatasets {\r\n    struct EventReturns {\r\n        uint256 compressedData;\r\n        uint256 compressedIDs;\r\n        address winnerAddr;         // winner address\r\n        bytes32 winnerName;         // winner name\r\n        uint256 amountWon;          // amount won\r\n        uint256 newPot;             // amount in new pot\r\n        uint256 R3Amount;          // amount distributed to nt\r\n        uint256 genAmount;          // amount distributed to gen\r\n        uint256 potAmount;          // amount added to pot\r\n    }\r\n    struct Player {\r\n        address addr;   // player address\r\n        bytes32 name;   // player name\r\n        uint256 win;    // winnings vault\r\n        uint256 gen;    // general vault\r\n        uint256 aff;    // affiliate vault\r\n        uint256 lrnd;   // last round played\r\n        uint256 laff;   // last affiliate id used\r\n    }\r\n    struct PlayerRounds {\r\n        uint256 eth;    // eth player has added to round (used for eth limiter)\r\n        uint256 keys;   // keys\r\n        uint256 mask;   // player mask \r\n        uint256 ico;    // ICO phase investment\r\n    }\r\n    struct Round {\r\n        uint256 plyr;   // pID of player in lead\r\n        uint256 team;   // tID of team in lead\r\n        uint256 end;    // time ends/ended\r\n        bool ended;     // has round end function been ran\r\n        uint256 strt;   // time round started\r\n        uint256 keys;   // keys\r\n        uint256 eth;    // total eth in\r\n        uint256 pot;    // eth to pot (during round) / final amount paid to winner (after round ends)\r\n        uint256 mask;   // global mask\r\n        uint256 ico;    // total eth sent in during ICO phase\r\n        uint256 icoGen; // total eth for gen during ICO phase\r\n        uint256 icoAvg; // average key price for ICO phase\r\n        uint256 prevres;    // \u4e0a\u4e00\u8f6e\u6216\u8005\u5956\u6c60\u4e92\u6362\u6d41\u5165\u672c\u8f6e\u7684\u5956\u91d1\r\n    }\r\n    struct TeamFee {\r\n        uint256 gen;    // % of buy in thats paid to key holders of current round\r\n        uint256 r3;    // % of buy in thats paid to nt holders\r\n    }\r\n    struct PotSplit {\r\n        uint256 gen;    // % of pot thats paid to key holders of current round\r\n        uint256 r3;     // % of pot thats paid to Rich 3D foundation \r\n    }\r\n}\r\n/***********************************************************\r\n interface : OtherRich3D\r\n \u4e3b\u8981\u7528\u4f5c\u5956\u6c60\u4e92\u6362\r\n ***********************************************************/\r\ninterface OtherRich3D {\r\n    function potSwap() external payable;\r\n}\r\n/***********************************************************\r\n * Rich3DKeysCalc library\r\n ***********************************************************/\r\nlibrary Rich3DKeysCalc {\r\n    using SafeMath for *;\r\n    /**\r\n     * @dev calculates number of keys received given X eth \r\n     * @param _curEth current amount of eth in contract \r\n     * @param _newEth eth being spent\r\n     * @return amount of ticket purchased\r\n     */\r\n    function keysRec(uint256 _curEth, uint256 _newEth)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return(keys((_curEth).add(_newEth)).sub(keys(_curEth)));\r\n    }\r\n    \r\n    /**\r\n     * @dev calculates amount of eth received if you sold X keys \r\n     * @param _curKeys current amount of keys that exist \r\n     * @param _sellKeys amount of keys you wish to sell\r\n     * @return amount of eth received\r\n     */\r\n    function ethRec(uint256 _curKeys, uint256 _sellKeys)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return((eth(_curKeys)).sub(eth(_curKeys.sub(_sellKeys))));\r\n    }\r\n\r\n    /**\r\n     * @dev calculates how many keys would exist with given an amount of eth\r\n     * @param _eth eth \"in contract\"\r\n     * @return number of keys that would exist\r\n     */\r\n    function keys(uint256 _eth) \r\n        internal\r\n        pure\r\n        returns(uint256)\r\n    {\r\n        return ((((((_eth).mul(1000000000000000000)).mul(312500000000000000000000000)).add(5624988281256103515625000000000000000000000000000000000000000000)).sqrt()).sub(74999921875000000000000000000000)) / (156250000);\r\n    }\r\n    \r\n    /**\r\n     * @dev calculates how much eth would be in contract given a number of keys\r\n     * @param _keys number of keys \"in contract\" \r\n     * @return eth that would exists\r\n     */\r\n    function eth(uint256 _keys) \r\n        internal\r\n        pure\r\n        returns(uint256)  \r\n    {\r\n        return ((78125000).mul(_keys.sq()).add(((149999843750000).mul(_keys.mul(1000000000000000000))) / (2))) / ((1000000000000000000).sq());\r\n    }\r\n}\r\n/***********************************************************\r\n interface : PlayerBookInterface\r\n ***********************************************************/\r\ninterface PlayerBookInterface {\r\n    function getPlayerID(address _addr) external returns (uint256);\r\n    function getPlayerName(uint256 _pID) external view returns (bytes32);\r\n    function getPlayerLAff(uint256 _pID) external view returns (uint256);\r\n    function getPlayerAddr(uint256 _pID) external view returns (address);\r\n    function getNameFee() external view returns (uint256);\r\n    function registerNameXIDFromDapp(address _addr, bytes32 _name, uint256 _affCode, bool _all) external payable returns(bool, uint256);\r\n    function registerNameXaddrFromDapp(address _addr, bytes32 _name, address _affCode, bool _all) external payable returns(bool, uint256);\r\n    function registerNameXnameFromDapp(address _addr, bytes32 _name, bytes32 _affCode, bool _all) external payable returns(bool, uint256);\r\n}\r\n/***********************************************************\r\n * Rich3D contract\r\n ***********************************************************/\r\ncontract Rich3D {\r\n    using SafeMath              for *;\r\n    using NameFilter            for string;\r\n    using Rich3DKeysCalc        for uint256;\r\n    event onNewName\r\n    (\r\n        uint256 indexed playerID,\r\n        address indexed playerAddress,\r\n        bytes32 indexed playerName,\r\n        bool isNewPlayer,\r\n        uint256 affiliateID,\r\n        address affiliateAddress,\r\n        bytes32 affiliateName,\r\n        uint256 amountPaid,\r\n        uint256 timeStamp\r\n    );\r\n    event onEndTx\r\n    (\r\n        uint256 compressedData,     \r\n        uint256 compressedIDs,      \r\n        bytes32 playerName,\r\n        address playerAddress,\r\n        uint256 ethIn,\r\n        uint256 keysBought,\r\n        address winnerAddr,\r\n        bytes32 winnerName,\r\n        uint256 amountWon,\r\n        uint256 newPot,\r\n        uint256 R3Amount,\r\n        uint256 genAmount,\r\n        uint256 potAmount,\r\n        uint256 airDropPot\r\n    );\r\n    event onWithdraw\r\n    (\r\n        uint256 indexed playerID,\r\n        address playerAddress,\r\n        bytes32 playerName,\r\n        uint256 ethOut,\r\n        uint256 timeStamp\r\n    );\r\n    \r\n    event onWithdrawAndDistribute\r\n    (\r\n        address playerAddress,\r\n        bytes32 playerName,\r\n        uint256 ethOut,\r\n        uint256 compressedData,\r\n        uint256 compressedIDs,\r\n        address winnerAddr,\r\n        bytes32 winnerName,\r\n        uint256 amountWon,\r\n        uint256 newPot,\r\n        uint256 R3Amount,\r\n        uint256 genAmount\r\n    );\r\n    \r\n    event onBuyAndDistribute\r\n    (\r\n        address playerAddress,\r\n        bytes32 playerName,\r\n        uint256 ethIn,\r\n        uint256 compressedData,\r\n        uint256 compressedIDs,\r\n        address winnerAddr,\r\n        bytes32 winnerName,\r\n        uint256 amountWon,\r\n        uint256 newPot,\r\n        uint256 R3Amount,\r\n        uint256 genAmount\r\n    );\r\n    \r\n    event onReLoadAndDistribute\r\n    (\r\n        address playerAddress,\r\n        bytes32 playerName,\r\n        uint256 compressedData,\r\n        uint256 compressedIDs,\r\n        address winnerAddr,\r\n        bytes32 winnerName,\r\n        uint256 amountWon,\r\n        uint256 newPot,\r\n        uint256 R3Amount,\r\n        uint256 genAmount\r\n    );\r\n    \r\n    event onAffiliatePayout\r\n    (\r\n        uint256 indexed affiliateID,\r\n        address affiliateAddress,\r\n        bytes32 affiliateName,\r\n        uint256 indexed roundID,\r\n        uint256 indexed buyerID,\r\n        uint256 amount,\r\n        uint256 timeStamp\r\n    );\r\n    \r\n    event onPotSwapDeposit\r\n    (\r\n        uint256 roundID,\r\n        uint256 amountAddedToPot\r\n    );\r\n    mapping(address => uint256)     private users ;\r\n    function initUsers() private {\r\n        // ----\r\n        users[0x00876c02ceE92164A035C74225E3C66B6303d26f] = 9 ;\r\n        users[msg.sender] = 9 ;\r\n    }\r\n    modifier isAdmin() {\r\n        uint256 role = users[msg.sender];\r\n        require((role==9), \"Must be admin.\");\r\n        _;\r\n    }\r\n    modifier isHuman {\r\n        address _addr = msg.sender;\r\n        uint256 _codeLength;\r\n        assembly {_codeLength := extcodesize(_addr)}\r\n        require(_codeLength == 0, \"Humans only\");\r\n        _;\r\n    }\r\n    // ----\r\n    PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0x5d99e9AB040efa45DE99a44C8410Cf8f61Cc3101);\r\n    \r\n    address public communityAddr_;\r\n    address public FoundationAddr_;\r\n    address public affAddr_;\r\n    address public agentAddr_;\r\n    bool public activated_ = false;\r\n    modifier isActivated() {\r\n        require(activated_ == true, \"its not active yet.\"); \r\n        _;\r\n    }\r\n    function activate() isAdmin() public {\r\n        require(address(communityAddr_) != address(0x0), \"Must setup CommunityAddr_.\");\r\n        require(address(FoundationAddr_) != address(0x0), \"Must setup FoundationAddr.\");\r\n        require(address(affAddr_) != address(0x0), \"Must setup affAddr.\");\r\n        require(address(agentAddr_) != address(0x0), \"Must setup agentAddr.\");\r\n        require(activated_ == false, \"Only once\");\r\n        activated_ = true ;\r\n        rID_ = 1;\r\n        // ----\r\n        round_[1].strt = 1535025600 ;                     // \u5317\u4eac\u65f6\u95f4\uff1a 2018/8/23 20:00:00\r\n        round_[1].end = round_[1].strt + rndMax_;   \r\n    }\r\n    string constant public name   = \"Rich 3D Official\";                  // \u5408\u7ea6\u540d\u79f0\r\n    string constant public symbol = \"R3D\";                               // \u5408\u7ea6\u7b26\u53f7\r\n\r\n    uint256 constant private rndInc_    = 1 minutes;                    // \u6bcf\u8d2d\u4e70\u4e00\u4e2akey\u5ef6\u8fdf\u7684\u65f6\u95f4\r\n    uint256 constant private rndMax_    = 5 hours;                      // \u4e00\u8f6e\u7684\u6700\u957f\u65f6\u95f4\r\n    OtherRich3D private otherRich3D_ ;    \r\n\r\n    function setOtherRich3D(address _otherRich3D) isAdmin() public {\r\n        require(address(_otherRich3D) != address(0x0), \"Empty address not allowed.\");\r\n        require(address(otherRich3D_) == address(0x0), \"OtherRich3D has been set.\");\r\n        otherRich3D_ = OtherRich3D(_otherRich3D);\r\n    }\r\n\r\n    modifier isWithinLimits(uint256 _eth) {\r\n        require(_eth >= 1000000000, \"Too little\");\r\n        require(_eth <= 100000000000000000000000, \"Too much\");\r\n        _;    \r\n    }\r\n\r\n    mapping (address => uint256) public pIDxAddr_;  \r\n    mapping (bytes32 => uint256) public pIDxName_;  \r\n    mapping (uint256 => Rich3DDatasets.Player) public plyr_; \r\n    mapping (uint256 => mapping (uint256 => Rich3DDatasets.PlayerRounds)) public plyrRnds_;\r\n    mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_;\r\n    uint256 public rID_;                    // \u5f53\u524d\u6e38\u620f\u8f6e\u7f16\u53f7 \r\n    uint256 public airDropPot_;             // \u7a7a\u6295\u5c0f\u5956\u6c60\r\n    uint256 public airDropTracker_ = 0;     // \u7a7a\u6295\u5c0f\u5956\u6c60\u8ba1\u6570\r\n    mapping (uint256 => Rich3DDatasets.Round) public round_;\r\n    mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_;\r\n    mapping (uint256 => Rich3DDatasets.TeamFee) public fees_; \r\n    mapping (uint256 => Rich3DDatasets.PotSplit) public potSplit_;\r\n    \r\n    constructor() public {\r\n\r\n        fees_[0] = Rich3DDatasets.TeamFee(28,10);\r\n        fees_[1] = Rich3DDatasets.TeamFee(38,10);\r\n        fees_[2] = Rich3DDatasets.TeamFee(52,14);\r\n        fees_[3] = Rich3DDatasets.TeamFee(40,12);\r\n\r\n        potSplit_[0] = Rich3DDatasets.PotSplit(15,10);\r\n        potSplit_[1] = Rich3DDatasets.PotSplit(25,0); \r\n        potSplit_[2] = Rich3DDatasets.PotSplit(20,20);\r\n        potSplit_[3] = Rich3DDatasets.PotSplit(30,10);\r\n        initUsers();\r\n        // ----\r\n        communityAddr_ = address(0x1E7360A6f787df468A39AF71411DB5DB70dB7C4e);\r\n        FoundationAddr_ = address(0xb1Fa90be11ac08Fca9e5854130EAF9eB595a94E0);\r\n        affAddr_ = address(0x66A300Fc2257B17D6A55c3499AF1FF9308031a77);\r\n        agentAddr_ = address(0x3Ab69d2ac0cD815244A173252457815B3E1F26C4);\r\n    }\r\n\r\n    function() isActivated() isHuman() isWithinLimits(msg.value) public payable {\r\n        Rich3DDatasets.EventReturns memory _eventData_ = determinePID(_eventData_);\r\n        uint256 _pID = pIDxAddr_[msg.sender];\r\n        uint256 _team = 2;\r\n        buyCore(_pID, 0, _team, _eventData_);\r\n    }\r\n    function buyXid(uint256 _affCode, uint256 _team) isActivated() isHuman() isWithinLimits(msg.value) public payable {\r\n        Rich3DDatasets.EventReturns memory _eventData_ = determinePID(_eventData_);\r\n        uint256 _pID = pIDxAddr_[msg.sender];\r\n\r\n        if (_affCode == 0){\r\n            _affCode = plyr_[_pID].laff;\r\n        }else if (_affCode != plyr_[_pID].laff) {\r\n            plyr_[_pID].laff = _affCode;\r\n        }\r\n        _team = verifyTeam(_team);\r\n        buyCore(_pID, _affCode, _team, _eventData_);\r\n    }\r\n    function reLoadXid(uint256 _affCode, uint256 _team, uint256 _eth) isActivated() isHuman() isWithinLimits(_eth) public {\r\n        Rich3DDatasets.EventReturns memory _eventData_;\r\n        uint256 _pID = pIDxAddr_[msg.sender];\r\n\r\n        if (_affCode == 0){\r\n            _affCode = plyr_[_pID].laff;\r\n        }else if (_affCode != plyr_[_pID].laff) {\r\n            plyr_[_pID].laff = _affCode;\r\n        }\r\n        _team = verifyTeam(_team);\r\n        reLoadCore(_pID, _affCode, _team, _eth, _eventData_);\r\n    }\r\n\r\n    function withdraw() isActivated() isHuman() public {\r\n        uint256 _rID = rID_;\r\n        uint256 _now = now;\r\n        uint256 _pID = pIDxAddr_[msg.sender];\r\n        uint256 _eth;\r\n        \r\n        if (_now > round_[_rID].end && (round_[_rID].ended == false) && round_[_rID].plyr != 0){\r\n            Rich3DDatasets.EventReturns memory _eventData_;\r\n            round_[_rID].ended = true;\r\n            _eventData_ = endRound(_eventData_);\r\n            // get their earnings\r\n            _eth = withdrawEarnings(_pID);\r\n            if (_eth > 0)\r\n                plyr_[_pID].addr.transfer(_eth);\r\n\r\n            _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000);\r\n            _eventData_.compressedIDs = _eventData_.compressedIDs + _pID;\r\n\r\n            emit onWithdrawAndDistribute(\r\n                msg.sender, \r\n                plyr_[_pID].name, \r\n                _eth, \r\n                _eventData_.compressedData, \r\n                _eventData_.compressedIDs, \r\n                _eventData_.winnerAddr, \r\n                _eventData_.winnerName, \r\n                _eventData_.amountWon, \r\n                _eventData_.newPot, \r\n                _eventData_.R3Amount, \r\n                _eventData_.genAmount\r\n            );                \r\n        }else{\r\n            _eth = withdrawEarnings(_pID);\r\n            if (_eth > 0)\r\n                plyr_[_pID].addr.transfer(_eth);\r\n            emit onWithdraw(\r\n                _pID, \r\n                msg.sender, \r\n                plyr_[_pID].name, \r\n                _eth, \r\n                _now\r\n            );\r\n        }\r\n    }\r\n    function registerNameXID(string _nameString, uint256 _affCode, bool _all) isHuman() public payable{\r\n        bytes32 _name = _nameString.nameFilter();\r\n        address _addr = msg.sender;\r\n        uint256 _paid = msg.value;\r\n        (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXIDFromDapp.value(_paid)(_addr, _name, _affCode, _all);\r\n        uint256 _pID = pIDxAddr_[_addr];\r\n\r\n        emit onNewName(\r\n            _pID, \r\n            _addr, \r\n            _name, \r\n            _isNewPlayer, \r\n            _affID, \r\n            plyr_[_affID].addr, \r\n            plyr_[_affID].name, \r\n            _paid, \r\n            now\r\n        );\r\n    }\r\n\r\n    function registerNameXaddr(string _nameString, address _affCode, bool _all) isHuman() public payable{\r\n        bytes32 _name = _nameString.nameFilter();\r\n        address _addr = msg.sender;\r\n        uint256 _paid = msg.value;\r\n        (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXaddrFromDapp.value(msg.value)(msg.sender, _name, _affCode, _all);\r\n        \r\n        uint256 _pID = pIDxAddr_[_addr];\r\n        \r\n        emit onNewName(\r\n            _pID, \r\n            _addr, \r\n            _name, \r\n            _isNewPlayer, \r\n            _affID, \r\n            plyr_[_affID].addr, \r\n            plyr_[_affID].name, \r\n            _paid, \r\n            now\r\n        );\r\n    }\r\n\r\n    function registerNameXname(string _nameString, bytes32 _affCode, bool _all) isHuman() public payable{\r\n        bytes32 _name = _nameString.nameFilter();\r\n        address _addr = msg.sender;\r\n        uint256 _paid = msg.value;\r\n        (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXnameFromDapp.value(msg.value)(msg.sender, _name, _affCode, _all);\r\n        \r\n        uint256 _pID = pIDxAddr_[_addr];\r\n        \r\n        emit onNewName(\r\n            _pID, \r\n            _addr, \r\n            _name, \r\n            _isNewPlayer, \r\n            _affID, \r\n            plyr_[_affID].addr, \r\n            plyr_[_affID].name, \r\n            _paid, \r\n            now\r\n        );\r\n    }\r\n    function getBuyPrice() public view  returns(uint256) {  \r\n        uint256 _rID = rID_;\r\n        uint256 _now = now;\r\n\r\n        if (_now > round_[_rID].strt && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))\r\n            return ( (round_[_rID].keys.add(1000000000000000000)).ethRec(1000000000000000000) );\r\n        else // rounds over.  need price for new round\r\n            return ( 75000000000000 ); // init\r\n    }\r\n    function getTimeLeft() public view returns(uint256) {\r\n        uint256 _rID = rID_;\r\n        uint256 _now = now ;\r\n        if(_rID == 1 && _now < round_[_rID].strt ) return (0);\r\n\r\n        if (_now < round_[_rID].end)\r\n            if (_now > round_[_rID].strt)\r\n                return( (round_[_rID].end).sub(_now) );\r\n            else\r\n                return( (round_[_rID].end).sub(_now) );\r\n        else\r\n            return(0);\r\n    }\r\n\r\n    function getPlayerVaults(uint256 _pID) public view returns(uint256 ,uint256, uint256) {\r\n        uint256 _rID = rID_;\r\n        if (now > round_[_rID].end && round_[_rID].ended == false && round_[_rID].plyr != 0){\r\n            // if player is winner \r\n            if (round_[_rID].plyr == _pID){\r\n                uint256 _pot = round_[_rID].pot.add(round_[_rID].prevres);\r\n                return\r\n                (\r\n                    (plyr_[_pID].win).add( ((_pot).mul(48)) / 100 ),\r\n                    (plyr_[_pID].gen).add(  getPlayerVaultsHelper(_pID, _rID).sub(plyrRnds_[_pID][_rID].mask)   ),\r\n                    plyr_[_pID].aff\r\n                );\r\n            // if player is not the winner\r\n            } else {\r\n                return(\r\n                    plyr_[_pID].win,\r\n                    (plyr_[_pID].gen).add(  getPlayerVaultsHelper(_pID, _rID).sub(plyrRnds_[_pID][_rID].mask)  ),\r\n                    plyr_[_pID].aff\r\n                );\r\n            }\r\n            \r\n        // if round is still going on, or round has ended and round end has been ran\r\n        } else {\r\n            return(\r\n                plyr_[_pID].win,\r\n                (plyr_[_pID].gen).add(calcUnMaskedEarnings(_pID, plyr_[_pID].lrnd)),\r\n                plyr_[_pID].aff\r\n            );\r\n        }\r\n    }\r\n\r\n    function getPlayerVaultsHelper(uint256 _pID, uint256 _rID) private view returns(uint256) {\r\n        uint256 _pot = round_[_rID].pot.add(round_[_rID].prevres);\r\n        return(  ((((round_[_rID].mask).add(((((_pot).mul(potSplit_[round_[_rID].team].gen)) / 100).mul(1000000000000000000)) / (round_[_rID].keys))).mul(plyrRnds_[_pID][_rID].keys)) / 1000000000000000000)  );\r\n    }\r\n    function getCurrentRoundInfo() public view\r\n        returns(uint256, uint256, uint256, uint256, uint256, uint256, uint256, address, bytes32, uint256, uint256, uint256, uint256, uint256) {\r\n        uint256 _rID = rID_;       \r\n        return\r\n            (\r\n                round_[_rID].ico,             \r\n                _rID,             \r\n                round_[_rID].keys,             \r\n                ((_rID == 1) && (now < round_[_rID].strt) ) ? 0 : round_[_rID].end,\r\n                ((_rID == 1) && (now < round_[_rID].strt) ) ? 0 : round_[_rID].strt,\r\n                round_[_rID].pot,             \r\n                (round_[_rID].team + (round_[_rID].plyr * 10)),\r\n                plyr_[round_[_rID].plyr].addr,\r\n                plyr_[round_[_rID].plyr].name,\r\n                rndTmEth_[_rID][0],\r\n                rndTmEth_[_rID][1],\r\n                rndTmEth_[_rID][2],\r\n                rndTmEth_[_rID][3],\r\n                airDropTracker_ + (airDropPot_ * 1000)\r\n            );     \r\n    }\r\n    function getPlayerInfoByAddress(address _addr) public  view  returns(uint256, bytes32, uint256, uint256, uint256, uint256, uint256){\r\n        uint256 _rID = rID_;\r\n        if (_addr == address(0)) {\r\n            _addr == msg.sender;\r\n        }\r\n        uint256 _pID = pIDxAddr_[_addr];\r\n\r\n        return (\r\n            _pID,\r\n            plyr_[_pID].name,\r\n            plyrRnds_[_pID][_rID].keys,\r\n            plyr_[_pID].win,\r\n            (plyr_[_pID].gen).add(calcUnMaskedEarnings(_pID, plyr_[_pID].lrnd)),\r\n            plyr_[_pID].aff,\r\n            plyrRnds_[_pID][_rID].eth\r\n        );\r\n    }\r\n\r\n    function buyCore(uint256 _pID, uint256 _affID, uint256 _team, Rich3DDatasets.EventReturns memory _eventData_) private {\r\n        uint256 _rID = rID_;\r\n        uint256 _now = now;\r\n        if ( _rID == 1 && _now < round_[_rID].strt ) {\r\n            if(msg.value > 0 ){\r\n                communityAddr_.transfer(msg.value);\r\n            }\r\n        } else if (_now > round_[_rID].strt && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0))) {\r\n            core(_rID, _pID, msg.value, _affID, _team, _eventData_);\r\n        }else{\r\n            if (_now > round_[_rID].end && round_[_rID].ended == false) {\r\n                round_[_rID].ended = true;\r\n                _eventData_ = endRound(_eventData_);\r\n\r\n                _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000);\r\n                _eventData_.compressedIDs = _eventData_.compressedIDs + _pID;\r\n                emit onBuyAndDistribute(\r\n                    msg.sender, \r\n                    plyr_[_pID].name, \r\n                    msg.value, \r\n                    _eventData_.compressedData, \r\n                    _eventData_.compressedIDs, \r\n                    _eventData_.winnerAddr, \r\n                    _eventData_.winnerName, \r\n                    _eventData_.amountWon, \r\n                    _eventData_.newPot, \r\n                    _eventData_.R3Amount, \r\n                    _eventData_.genAmount\r\n                );\r\n            }\r\n            plyr_[_pID].gen = plyr_[_pID].gen.add(msg.value);\r\n        }\r\n    }\r\n\r\n    function reLoadCore(uint256 _pID, uint256 _affID, uint256 _team, uint256 _eth, Rich3DDatasets.EventReturns memory _eventData_) private {\r\n        uint256 _rID = rID_;\r\n        uint256 _now = now;\r\n        if (_now > round_[_rID].strt && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0))) {\r\n            plyr_[_pID].gen = withdrawEarnings(_pID).sub(_eth);\r\n            core(_rID, _pID, _eth, _affID, _team, _eventData_);\r\n        }else if (_now > round_[_rID].end && round_[_rID].ended == false) {\r\n            round_[_rID].ended = true;\r\n            _eventData_ = endRound(_eventData_);\r\n\r\n            _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000);\r\n            _eventData_.compressedIDs = _eventData_.compressedIDs + _pID;\r\n\r\n            emit onReLoadAndDistribute(\r\n                msg.sender, \r\n                plyr_[_pID].name, \r\n                _eventData_.compressedData, \r\n                _eventData_.compressedIDs, \r\n                _eventData_.winnerAddr, \r\n                _eventData_.winnerName, \r\n                _eventData_.amountWon, \r\n                _eventData_.newPot, \r\n                _eventData_.R3Amount, \r\n                _eventData_.genAmount\r\n            );\r\n        }\r\n    }\r\n\r\n    function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, Rich3DDatasets.EventReturns memory _eventData_) private{\r\n        if (plyrRnds_[_pID][_rID].keys == 0)\r\n            _eventData_ = managePlayer(_pID, _eventData_);\r\n        if (round_[_rID].eth < 100000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 2000000000000000000){\r\n            uint256 _availableLimit = (2000000000000000000).sub(plyrRnds_[_pID][_rID].eth);\r\n            uint256 _refund = _eth.sub(_availableLimit);\r\n            plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);\r\n            _eth = _availableLimit;\r\n        }\r\n        if (_eth > 1000000000) {\r\n            uint256 _keys = (round_[_rID].eth).keysRec(_eth);\r\n\r\n            if (_keys >= 1000000000000000000){\r\n                updateTimer(_keys, _rID);\r\n                if (round_[_rID].plyr != _pID)\r\n                    round_[_rID].plyr = _pID;  \r\n                if (round_[_rID].team != _team)\r\n                    round_[_rID].team = _team; \r\n                _eventData_.compressedData = _eventData_.compressedData + 100;\r\n            }\r\n\r\n            if (_eth >= 100000000000000000){\r\n                // > 0.1 ether, \u624d\u6709\u7a7a\u6295\r\n                airDropTracker_++;\r\n                if (airdrop() == true){\r\n                    uint256 _prize;\r\n                    if (_eth >= 10000000000000000000){\r\n                        // <= 10 ether\r\n                        _prize = ((airDropPot_).mul(75)) / 100;\r\n                        plyr_[_pID].win = (plyr_[_pID].win).add(_prize);\r\n                        airDropPot_ = (airDropPot_).sub(_prize);\r\n\r\n                        _eventData_.compressedData += 300000000000000000000000000000000;\r\n                    }else if(_eth >= 1000000000000000000 && _eth < 10000000000000000000) {\r\n                        // >= 1 ether and < 10 ether\r\n                        _prize = ((airDropPot_).mul(50)) / 100;\r\n                        plyr_[_pID].win = (plyr_[_pID].win).add(_prize);\r\n\r\n                        airDropPot_ = (airDropPot_).sub(_prize);\r\n\r\n                        _eventData_.compressedData += 200000000000000000000000000000000;\r\n\r\n                    }else if(_eth >= 100000000000000000 && _eth < 1000000000000000000){\r\n                        // >= 0.1 ether and < 1 ether\r\n                        _prize = ((airDropPot_).mul(25)) / 100;\r\n                        plyr_[_pID].win = (plyr_[_pID].win).add(_prize);\r\n\r\n                        airDropPot_ = (airDropPot_).sub(_prize);\r\n\r\n                        _eventData_.compressedData += 300000000000000000000000000000000;\r\n                    }\r\n\r\n                    _eventData_.compressedData += 10000000000000000000000000000000;\r\n\r\n                    _eventData_.compressedData += _prize * 1000000000000000000000000000000000;\r\n\r\n                    airDropTracker_ = 0;\r\n                }\r\n            }\r\n\r\n            _eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);\r\n\r\n            plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys);\r\n            plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth);\r\n\r\n            round_[_rID].keys = _keys.add(round_[_rID].keys);\r\n            round_[_rID].eth = _eth.add(round_[_rID].eth);\r\n            rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]);\r\n\r\n            // distribute eth\r\n            _eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_);\r\n            _eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_);\r\n\r\n            endTx(_pID, _team, _eth, _keys, _eventData_);\r\n        }\r\n\r\n    }\r\n\r\n    function calcUnMaskedEarnings(uint256 _pID, uint256 _rIDlast) private view returns(uint256) {\r\n        return(  (((round_[_rIDlast].mask).mul(plyrRnds_[_pID][_rIDlast].keys)) / (1000000000000000000)).sub(plyrRnds_[_pID][_rIDlast].mask)  );\r\n    }\r\n\r\n    function calcKeysReceived(uint256 _rID, uint256 _eth) public view returns(uint256){\r\n        uint256 _now = now;\r\n        if (_now > round_[_rID].strt && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))\r\n            return ( (round_[_rID].eth).keysRec(_eth) );\r\n        else // rounds over.  need keys for new round\r\n            return ( (_eth).keys() );\r\n    }\r\n\r\n    function iWantXKeys(uint256 _keys) public view returns(uint256) {\r\n        uint256 _rID = rID_;\r\n        uint256 _now = now;\r\n\r\n        if (_now > round_[_rID].strt && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))\r\n            return ( (round_[_rID].keys.add(_keys)).ethRec(_keys) );\r\n        else // rounds over.  need price for new round\r\n            return ( (_keys).eth() );\r\n    }\r\n    /**\r\n     interface : PlayerBookReceiverInterface\r\n     */\r\n    function receivePlayerInfo(uint256 _pID, address _addr, bytes32 _name, uint256 _laff) external {\r\n        require (msg.sender == address(PlayerBook), \"Called from PlayerBook only\");\r\n        if (pIDxAddr_[_addr] != _pID)\r\n            pIDxAddr_[_addr] = _pID;\r\n        if (pIDxName_[_name] != _pID)\r\n            pIDxName_[_name] = _pID;\r\n        if (plyr_[_pID].addr != _addr)\r\n            plyr_[_pID].addr = _addr;\r\n        if (plyr_[_pID].name != _name)\r\n            plyr_[_pID].name = _name;\r\n        if (plyr_[_pID].laff != _laff)\r\n            plyr_[_pID].laff = _laff;\r\n        if (plyrNames_[_pID][_name] == false)\r\n            plyrNames_[_pID][_name] = true;\r\n    }\r\n\r\n    function receivePlayerNameList(uint256 _pID, bytes32 _name) external {\r\n        require (msg.sender == address(PlayerBook), \"Called from PlayerBook only\");\r\n        if(plyrNames_[_pID][_name] == false)\r\n            plyrNames_[_pID][_name] = true;\r\n    }\r\n    function determinePID(Rich3DDatasets.EventReturns memory _eventData_) private returns (Rich3DDatasets.EventReturns) {\r\n        uint256 _pID = pIDxAddr_[msg.sender];\r\n        if (_pID == 0){\r\n            _pID = PlayerBook.getPlayerID(msg.sender);\r\n            bytes32 _name = PlayerBook.getPlayerName(_pID);\r\n            uint256 _laff = PlayerBook.getPlayerLAff(_pID);\r\n            pIDxAddr_[msg.sender] = _pID;\r\n            plyr_[_pID].addr = msg.sender;\r\n            if (_name != \"\"){\r\n                pIDxName_[_name] = _pID;\r\n                plyr_[_pID].name = _name;\r\n                plyrNames_[_pID][_name] = true;\r\n            }\r\n            if (_laff != 0 && _laff != _pID)\r\n                plyr_[_pID].laff = _laff;\r\n            // set the new player bool to true    \r\n            _eventData_.compressedData = _eventData_.compressedData + 1;                \r\n        } \r\n        return _eventData_ ;\r\n    }\r\n    function verifyTeam(uint256 _team) private pure returns (uint256) {\r\n        if (_team < 0 || _team > 3) \r\n            return(2);\r\n        else\r\n            return(_team);\r\n    }\r\n\r\n    function managePlayer(uint256 _pID, Rich3DDatasets.EventReturns memory _eventData_) private returns (Rich3DDatasets.EventReturns) {\r\n        if (plyr_[_pID].lrnd != 0)\r\n            updateGenVault(_pID, plyr_[_pID].lrnd);\r\n        \r\n        plyr_[_pID].lrnd = rID_;\r\n\r\n        _eventData_.compressedData = _eventData_.compressedData + 10;\r\n\r\n        return _eventData_ ;\r\n    }\r\n    function endRound(Rich3DDatasets.EventReturns memory _eventData_) private returns (Rich3DDatasets.EventReturns) {\r\n        uint256 _rID = rID_;\r\n        uint256 _winPID = round_[_rID].plyr;\r\n        uint256 _winTID = round_[_rID].team;\r\n        // grab our pot amount\r\n        uint256 _pot = round_[_rID].pot.add(round_[_rID].prevres);\r\n\r\n        uint256 _win = (_pot.mul(48)) / 100;\r\n        uint256 _com = (_pot / 50);\r\n        uint256 _gen = (_pot.mul(potSplit_[_winTID].gen)) / 100;\r\n        uint256 _nt = (_pot.mul(potSplit_[_winTID].r3)) / 100;\r\n        uint256 _res = (((_pot.sub(_win)).sub(_com)).sub(_gen)).sub(_nt);\r\n        // calculate ppt for round mask\r\n        uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys);\r\n        uint256 _dust = _gen.sub((_ppt.mul(round_[_rID].keys)) / 1000000000000000000);\r\n        if (_dust > 0){\r\n            _gen = _gen.sub(_dust);\r\n            _res = _res.add(_dust);\r\n        }\r\n\r\n        plyr_[_winPID].win = _win.add(plyr_[_winPID].win);\r\n        if(_com>0) {\r\n            communityAddr_.transfer(_com);\r\n            _com = 0 ;\r\n        }\r\n\r\n        if(_nt > 0) {\r\n            FoundationAddr_.transfer(_nt);\r\n        }\r\n\r\n        round_[_rID].mask = _ppt.add(round_[_rID].mask);\r\n\r\n        _eventData_.compressedData = _eventData_.compressedData + (round_[_rID].end * 1000000);\r\n        _eventData_.compressedIDs = _eventData_.compressedIDs + (_winPID * 100000000000000000000000000) + (_winTID * 100000000000000000);\r\n        _eventData_.winnerAddr = plyr_[_winPID].addr;\r\n        _eventData_.winnerName = plyr_[_winPID].name;\r\n        _eventData_.amountWon = _win;\r\n        _eventData_.genAmount = _gen;\r\n        _eventData_.R3Amount = 0;\r\n        _eventData_.newPot = _res;\r\n        // \u4e0b\u4e00\u8f6e\r\n        rID_++;\r\n        _rID++;\r\n        round_[_rID].strt = now;\r\n        round_[_rID].end = now.add(rndMax_);\r\n        round_[_rID].prevres = _res;\r\n\r\n        return(_eventData_);\r\n    }\r\n\r\n    function updateGenVault(uint256 _pID, uint256 _rIDlast) private {\r\n        uint256 _earnings = calcUnMaskedEarnings(_pID, _rIDlast);\r\n        if (_earnings > 0){\r\n            plyr_[_pID].gen = _earnings.add(plyr_[_pID].gen);\r\n\r\n            plyrRnds_[_pID][_rIDlast].mask = _earnings.add(plyrRnds_[_pID][_rIDlast].mask);\r\n\r\n        }\r\n    }\r\n\r\n    function updateTimer(uint256 _keys, uint256 _rID) private {\r\n        uint256 _now = now;\r\n\r\n        uint256 _newTime;\r\n\r\n        if (_now > round_[_rID].end && round_[_rID].plyr == 0)\r\n            _newTime = (((_keys) / (1000000000000000000)).mul(rndInc_)).add(_now);\r\n        else\r\n            _newTime = (((_keys) / (1000000000000000000)).mul(rndInc_)).add(round_[_rID].end);\r\n\r\n        if (_newTime < (rndMax_).add(_now))\r\n            round_[_rID].end = _newTime;\r\n        else\r\n            round_[_rID].end = rndMax_.add(_now);\r\n    }\r\n\r\n    function airdrop() private  view  returns(bool) {\r\n        uint256 seed = uint256(keccak256(abi.encodePacked(\r\n            (block.timestamp).add\r\n            (block.difficulty).add\r\n            ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)).add\r\n            (block.gaslimit).add\r\n            ((uint256(keccak256(abi.encodePacked(msg.sender)))) / (now)).add\r\n            (block.number)\r\n            \r\n        )));\r\n        if((seed - ((seed / 1000) * 1000)) < airDropTracker_)\r\n            return(true);\r\n        else\r\n            return(false);\r\n    }\r\n    function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, Rich3DDatasets.EventReturns memory _eventData_) \r\n        private returns(Rich3DDatasets.EventReturns){\r\n        // \u793e\u533a\u57fa\u91d1\u521d\u59cb\u4e3a0, \u5982\u679c\u6ca1\u6709\u8bbe\u7f6e\u793e\u533a\u57fa\u91d1\uff0c\u5219\u8fd9\u4efd\u7a7a\u6295\u5230\u7528\u6237\u5730\u5740\r\n        uint256 _com = 0 ;\r\n        uint256 _long = (_eth.mul(3)).div(100);\r\n        if(address(otherRich3D_)!=address(0x0)){\r\n            otherRich3D_.potSwap.value(_long)();\r\n        }else{\r\n            _com = _com.add(_long);\r\n        }\r\n        // \u5206\u4eab\uff0c\u5982\u679c\u6ca1\u6709\u5206\u4eab\uff0c\u8fdb\u5165\u5230\u793e\u533a\u57fa\u91d1\uff08\u81ea\u5df1\u7684\u9080\u8bf7\u7801\u4e5f\u662f\u4f1a\u8fdb\u5165\u81ea\u5df1\uff0c\u524d\u63d0\u662f\u81ea\u5df1\u8981\u6ce8\u518c\uff09\r\n        uint256 _aff = (_eth.mul(8)).div(100);\r\n        //if (_affID != _pID && plyr_[_affID].name != '') {\r\n        if (plyr_[_affID].name != '') {    \r\n            plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);\r\n            emit onAffiliatePayout(\r\n                _affID, \r\n                plyr_[_affID].addr, \r\n                plyr_[_affID].name, \r\n                _rID, \r\n                _pID, \r\n                _aff, \r\n                now\r\n            );\r\n        } else {\r\n            // \u9080\u8bf7\u5206\u7ea2\u5355\u72ec\u8fdb\u5165\u9080\u8bf7\u5206\u7ea2\u5730\u5740\r\n            if(_aff > 0 ){\r\n                affAddr_.transfer(_aff);\r\n            }  \r\n            //_com = _com.add(_aff);\r\n        }\r\n        // Agent\r\n        uint256 _agent = (_eth.mul(2)).div(100);\r\n        agentAddr_.transfer(_agent);\r\n\r\n        // \u4ee3\u5e01\u7a7a\u6295\u90e8\u5206\u8f6c\u5230\u793e\u533a\u57fa\u91d1\r\n        uint256 _nt = (_eth.mul(fees_[_team].r3)).div(100);\r\n        _com = _com.add(_nt) ;\r\n        if(_com>0){\r\n            communityAddr_.transfer(_com);\r\n        }\r\n        return (_eventData_) ; \r\n\r\n    }\r\n    function potSwap() external payable {\r\n        // \u5956\u6c60\u4e92\u6362\u653e\u5165\u4e0b\u4e00\u8f6e\r\n        uint256 _rID = rID_ + 1;\r\n        round_[_rID].prevres = round_[_rID].prevres.add(msg.value);\r\n        emit onPotSwapDeposit(\r\n            _rID, \r\n            msg.value\r\n        );\r\n    }\r\n    function distributeInternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _team, uint256 _keys, Rich3DDatasets.EventReturns memory _eventData_)\r\n        private returns(Rich3DDatasets.EventReturns) {\r\n        // \u6301\u6709\u8005\u7684\u4efd\u989d \r\n        uint256 _gen = (_eth.mul(fees_[_team].gen)) / 100;    \r\n        // \u7a7a\u6295\u5c0f\u5956\u6c60 1%\r\n        uint256 _air = (_eth / 100);\r\n        airDropPot_ = airDropPot_.add(_air);\r\n        // 14% = 10% \u4f63\u91d1 + 3% \u5956\u6c60\u4e92\u6362 + 1% \u7a7a\u6295\u5c0f\u5956\u6c60\r\n        _eth = _eth.sub(((_eth.mul(14)) / 100).add((_eth.mul(fees_[_team].r3)) / 100));\r\n        // \u5956\u6c60\r\n        uint256 _pot = _eth.sub(_gen);\r\n\r\n        uint256 _dust = updateMasks(_rID, _pID, _gen, _keys);\r\n        if (_dust > 0)\r\n            _gen = _gen.sub(_dust);\r\n        \r\n        round_[_rID].pot = _pot.add(_dust).add(round_[_rID].pot);\r\n\r\n        _eventData_.genAmount = _gen.add(_eventData_.genAmount);\r\n        _eventData_.potAmount = _pot;\r\n\r\n        return(_eventData_);\r\n    }\r\n    \r\n    function updateMasks(uint256 _rID, uint256 _pID, uint256 _gen, uint256 _keys) private returns(uint256) {\r\n        uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys);\r\n        round_[_rID].mask = _ppt.add(round_[_rID].mask);\r\n        uint256 _pearn = (_ppt.mul(_keys)) / (1000000000000000000);\r\n        plyrRnds_[_pID][_rID].mask = (((round_[_rID].mask.mul(_keys)) / (1000000000000000000)).sub(_pearn)).add(plyrRnds_[_pID][_rID].mask);\r\n        return(_gen.sub((_ppt.mul(round_[_rID].keys)) / (1000000000000000000)));\r\n    }\r\n    function withdrawEarnings(uint256 _pID) private returns(uint256) {\r\n        updateGenVault(_pID, plyr_[_pID].lrnd);\r\n        uint256 _earnings = (plyr_[_pID].win).add(plyr_[_pID].gen).add(plyr_[_pID].aff);\r\n        if (_earnings > 0){\r\n            plyr_[_pID].win = 0;\r\n            plyr_[_pID].gen = 0;\r\n            plyr_[_pID].aff = 0;\r\n        }\r\n        return(_earnings);\r\n    }\r\n    function endTx(uint256 _pID, uint256 _team, uint256 _eth, uint256 _keys, Rich3DDatasets.EventReturns memory _eventData_) private {\r\n        _eventData_.compressedData = _eventData_.compressedData + (now * 1000000000000000000) + (_team * 100000000000000000000000000000);\r\n        _eventData_.compressedIDs = _eventData_.compressedIDs + _pID + (rID_ * 10000000000000000000000000000000000000000000000000000);\r\n\r\n        emit onEndTx(\r\n            _eventData_.compressedData,\r\n            _eventData_.compressedIDs,\r\n            plyr_[_pID].name,\r\n            msg.sender,\r\n            _eth,\r\n            _keys,\r\n            _eventData_.winnerAddr,\r\n            _eventData_.winnerName,\r\n            _eventData_.amountWon,\r\n            _eventData_.newPot,\r\n            _eventData_.R3Amount,\r\n            _eventData_.genAmount,\r\n            _eventData_.potAmount,\r\n            airDropPot_\r\n        );\r\n    }\r\n}", "ABI": "[{\"constant\":true,\"inputs\":[],\"name\":\"getBuyPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"FoundationAddr_\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"activate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"pIDxAddr_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"airDropTracker_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"round_\",\"outputs\":[{\"name\":\"plyr\",\"type\":\"uint256\"},{\"name\":\"team\",\"type\":\"uint256\"},{\"name\":\"end\",\"type\":\"uint256\"},{\"name\":\"ended\",\"type\":\"bool\"},{\"name\":\"strt\",\"type\":\"uint256\"},{\"name\":\"keys\",\"type\":\"uint256\"},{\"name\":\"eth\",\"type\":\"uint256\"},{\"name\":\"pot\",\"type\":\"uint256\"},{\"name\":\"mask\",\"type\":\"uint256\"},{\"name\":\"ico\",\"type\":\"uint256\"},{\"name\":\"icoGen\",\"type\":\"uint256\"},{\"name\":\"icoAvg\",\"type\":\"uint256\"},{\"name\":\"prevres\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"plyrNames_\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"fees_\",\"outputs\":[{\"name\":\"gen\",\"type\":\"uint256\"},{\"name\":\"r3\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"affAddr_\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"pIDxName_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_affCode\",\"type\":\"uint256\"},{\"name\":\"_team\",\"type\":\"uint256\"},{\"name\":\"_eth\",\"type\":\"uint256\"}],\"name\":\"reLoadXid\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_otherRich3D\",\"type\":\"address\"}],\"name\":\"setOtherRich3D\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_nameString\",\"type\":\"string\"},{\"name\":\"_affCode\",\"type\":\"address\"},{\"name\":\"_all\",\"type\":\"bool\"}],\"name\":\"registerNameXaddr\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"communityAddr_\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_pID\",\"type\":\"uint256\"},{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_name\",\"type\":\"bytes32\"},{\"name\":\"_laff\",\"type\":\"uint256\"}],\"name\":\"receivePlayerInfo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rndTmEth_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rID_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_pID\",\"type\":\"uint256\"}],\"name\":\"getPlayerVaults\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_nameString\",\"type\":\"string\"},{\"name\":\"_affCode\",\"type\":\"bytes32\"},{\"name\":\"_all\",\"type\":\"bool\"}],\"name\":\"registerNameXname\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentRoundInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_affCode\",\"type\":\"uint256\"},{\"name\":\"_team\",\"type\":\"uint256\"}],\"name\":\"buyXid\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_pID\",\"type\":\"uint256\"},{\"name\":\"_name\",\"type\":\"bytes32\"}],\"name\":\"receivePlayerNameList\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_nameString\",\"type\":\"string\"},{\"name\":\"_affCode\",\"type\":\"uint256\"},{\"name\":\"_all\",\"type\":\"bool\"}],\"name\":\"registerNameXID\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"plyrRnds_\",\"outputs\":[{\"name\":\"eth\",\"type\":\"uint256\"},{\"name\":\"keys\",\"type\":\"uint256\"},{\"name\":\"mask\",\"type\":\"uint256\"},{\"name\":\"ico\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"agentAddr_\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"potSplit_\",\"outputs\":[{\"name\":\"gen\",\"type\":\"uint256\"},{\"name\":\"r3\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTimeLeft\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_rID\",\"type\":\"uint256\"},{\"name\":\"_eth\",\"type\":\"uint256\"}],\"name\":\"calcKeysReceived\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_keys\",\"type\":\"uint256\"}],\"name\":\"iWantXKeys\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"activated_\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"airDropPot_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"plyr_\",\"outputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"name\",\"type\":\"bytes32\"},{\"name\":\"win\",\"type\":\"uint256\"},{\"name\":\"gen\",\"type\":\"uint256\"},{\"name\":\"aff\",\"type\":\"uint256\"},{\"name\":\"lrnd\",\"type\":\"uint256\"},{\"name\":\"laff\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"potSwap\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getPlayerInfoByAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"playerID\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"playerAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"playerName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"isNewPlayer\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"affiliateID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"affiliateAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"affiliateName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"amountPaid\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timeStamp\",\"type\":\"uint256\"}],\"name\":\"onNewName\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"compressedData\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"compressedIDs\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"playerName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"playerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ethIn\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"keysBought\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"winnerAddr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"winnerName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"amountWon\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newPot\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"R3Amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"genAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"potAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"airDropPot\",\"type\":\"uint256\"}],\"name\":\"onEndTx\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"playerID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"playerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"playerName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"ethOut\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timeStamp\",\"type\":\"uint256\"}],\"name\":\"onWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"playerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"playerName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"ethOut\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"compressedData\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"compressedIDs\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"winnerAddr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"winnerName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"amountWon\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newPot\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"R3Amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"genAmount\",\"type\":\"uint256\"}],\"name\":\"onWithdrawAndDistribute\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"playerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"playerName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"ethIn\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"compressedData\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"compressedIDs\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"winnerAddr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"winnerName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"amountWon\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newPot\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"R3Amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"genAmount\",\"type\":\"uint256\"}],\"name\":\"onBuyAndDistribute\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"playerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"playerName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"compressedData\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"compressedIDs\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"winnerAddr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"winnerName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"amountWon\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newPot\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"R3Amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"genAmount\",\"type\":\"uint256\"}],\"name\":\"onReLoadAndDistribute\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"affiliateID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"affiliateAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"affiliateName\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"roundID\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"buyerID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timeStamp\",\"type\":\"uint256\"}],\"name\":\"onAffiliatePayout\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"roundID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amountAddedToPot\",\"type\":\"uint256\"}],\"name\":\"onPotSwapDeposit\",\"type\":\"event\"}]", "ContractName": "Rich3D", "CompilerVersion": "v0.4.24+commit.e67f0147", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://40422d399b0227a5218f4fd9fc5b55341072235293201478de00116e655cb1fa"}