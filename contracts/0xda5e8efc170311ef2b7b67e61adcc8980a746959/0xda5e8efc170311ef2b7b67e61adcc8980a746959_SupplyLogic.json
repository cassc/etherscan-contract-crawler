{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/libraries/logic/SupplyLogic.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.8.4;\\n\\nimport {IBurnLockMToken} from \\\"../../interfaces/IBurnLockMToken.sol\\\";\\n\\nimport {Errors} from \\\"../helpers/Errors.sol\\\";\\nimport {DataTypes} from \\\"../types/DataTypes.sol\\\";\\n\\nimport {IERC20Upgradeable} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\nimport {SafeERC20Upgradeable} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\\\";\\n\\nimport {ReserveLogic} from \\\"./ReserveLogic.sol\\\";\\nimport {ValidationLogic} from \\\"./ValidationLogic.sol\\\";\\n\\n/**\\n * @title SupplyLogic library\\n * @author MetaFire\\n * @notice Implements the logic to supply feature\\n */\\nlibrary SupplyLogic {\\n  using SafeERC20Upgradeable for IERC20Upgradeable;\\n  using ReserveLogic for DataTypes.ReserveData;\\n\\n  /**\\n   * @dev Emitted on deposit()\\n   * @param user The address initiating the deposit\\n   * @param amount The amount deposited\\n   * @param reserve The address of the underlying asset of the reserve\\n   * @param onBehalfOf The beneficiary of the deposit, receiving the mTokens\\n   * @param referral The referral code used\\n   **/\\n  event Deposit(\\n    address user,\\n    address indexed reserve,\\n    uint256 amount,\\n    address indexed onBehalfOf,\\n    uint8 period,\\n    uint16 indexed referral\\n  );\\n\\n  /**\\n   * @dev Emitted on withdraw()\\n   * @param user The address initiating the withdrawal, owner of mTokens\\n   * @param reserve The address of the underlyng asset being withdrawn\\n   * @param amount The amount to be withdrawn\\n   * @param to Address that will receive the underlying\\n   **/\\n  event Withdraw(address indexed user, address indexed reserve, uint256 amount, address indexed to, uint8 period);\\n\\n  /**\\n   * @notice Implements the supply feature. Through `deposit()`, users deposit assets to the protocol.\\n   * @dev Emits the `Deposit()` event.\\n   * @param reservesData The state of all the reserves\\n   * @param params The additional parameters needed to execute the deposit function\\n   */\\n  function executeDeposit(\\n    mapping(address => DataTypes.ReserveData) storage reservesData,\\n    DataTypes.ExecuteDepositParams memory params\\n  ) external {\\n    require(params.onBehalfOf != address(0), Errors.VL_INVALID_ONBEHALFOF_ADDRESS);\\n    uint8 period = uint8(params.period);\\n    DataTypes.ReserveData storage reserve = reservesData[params.asset];\\n    address mToken = reserve.mTokenAddresses[period];\\n    require(mToken != address(0), Errors.VL_INVALID_RESERVE_ADDRESS);\\n\\n    ValidationLogic.validateDeposit(reserve, params.amount);\\n\\n    reserve.updateState();\\n    reserve.updateInterestRates(params.asset, mToken, params.amount, 0);\\n\\n    IERC20Upgradeable(params.asset).safeTransferFrom(params.initiator, address(this), params.amount);\\n\\n    IBurnLockMToken(mToken).mint(params.onBehalfOf, params.amount, reserve.liquidityIndices[period]);\\n\\n    emit Deposit(params.initiator, params.asset, params.amount, params.onBehalfOf,uint8(params.period) ,params.referralCode);\\n  }\\n\\n  /**\\n   * @notice Implements the supply feature. Through `withdraw()`, users withdraw assets from the protocol.\\n   * @dev Emits the `Withdraw()` event.\\n   * @param reservesData The state of all the reserves\\n   * @param params The additional parameters needed to execute the withdraw function\\n   */\\n  function executeWithdraw(\\n    mapping(address => DataTypes.ReserveData) storage reservesData,\\n    DataTypes.ExecuteWithdrawParams memory params\\n  ) external returns (uint256) {\\n    require(params.to != address(0), Errors.VL_INVALID_TARGET_ADDRESS);\\n    uint8 period = uint8(params.period);\\n    DataTypes.ReserveData storage reserve = reservesData[params.asset];\\n    address mToken = reserve.mTokenAddresses[period];\\n    require(mToken != address(0), Errors.VL_INVALID_RESERVE_ADDRESS);\\n\\n    uint256 userBalance = IBurnLockMToken(mToken).balanceOf(params.initiator,params.period);\\n\\n    uint256 amountToWithdraw = params.amount;\\n\\n    if (params.amount == type(uint256).max) {\\n      amountToWithdraw = userBalance;\\n    }\\n\\n    ValidationLogic.validateWithdraw(reserve, amountToWithdraw, userBalance);\\n\\n    reserve.updateState();\\n\\n    reserve.updateInterestRates(params.asset, mToken, 0, amountToWithdraw);\\n\\n    IBurnLockMToken(mToken).burn(params.initiator, params.to, amountToWithdraw, reserve.liquidityIndices[period]);\\n\\n    IERC20Upgradeable(params.asset).safeTransfer(params.to, amountToWithdraw);\\n\\n    emit Withdraw(params.initiator, params.asset, amountToWithdraw, params.to, period);\\n\\n    return amountToWithdraw;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IBurnLockMToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.8.4;\\n\\nimport {ILendPoolAddressesProvider} from \\\"./ILendPoolAddressesProvider.sol\\\";\\nimport {IIncentivesController} from \\\"./IIncentivesController.sol\\\";\\nimport {IScaledBalanceToken} from \\\"./IScaledBalanceToken.sol\\\";\\n\\nimport {IERC20Upgradeable} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\nimport {IERC20MetadataUpgradeable} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\\\";\\n\\nimport {DataTypes} from \\\"../libraries/types/DataTypes.sol\\\";\\n\\ninterface IBurnLockMToken is IScaledBalanceToken, IERC20Upgradeable, IERC20MetadataUpgradeable {\\n  /**\\n   * @dev Emitted when an mToken is initialized\\n   * @param underlyingAsset The address of the underlying asset\\n   * @param pool The address of the associated lending pool\\n   * @param treasury The address of the treasury\\n   * @param incentivesController The address of the incentives controller for this mToken\\n   **/\\n  event Initialized(\\n    address indexed underlyingAsset,\\n    address indexed pool,\\n    address treasury,\\n    address incentivesController\\n  );\\n\\n  /**\\n   * @dev Initializes the mToken\\n   * @param addressProvider The address of the address provider where this mToken will be used\\n   * @param treasury The address of the MetaFire treasury, receiving the fees on this mToken\\n   * @param underlyingAsset The address of the underlying asset of this mToken\\n   * @param mTokenDecimals The decimals of this mToken\\n   * @param mTokenName The name of this mToken\\n   * @param mTokenSymbol The symbol of this mToken\\n   * @param lockPeriod The lock period of this mToken\\n   */\\n  function initialize(\\n    ILendPoolAddressesProvider addressProvider,\\n    address treasury,\\n    address underlyingAsset,\\n    uint8 mTokenDecimals,\\n    string calldata mTokenName,\\n    string calldata mTokenSymbol,\\n    uint256 lockPeriod\\n  ) external;\\n\\n  /**\\n   * @dev Emitted after the mint action\\n   * @param from The address performing the mint\\n   * @param value The amount being\\n   * @param index The new liquidity index of the reserve\\n   **/\\n  event Mint(address indexed from, uint256 value, uint256 index);\\n\\n  /**\\n   * @dev Mints `amount` mTokens to `user`\\n   * @param user The address receiving the minted tokens\\n   * @param amount The amount of tokens getting minted\\n   * @param index The new liquidity index of the reserve\\n   * @return `true` if the the previous balance of the user was 0\\n   */\\n  function mint(\\n    address user,\\n    uint256 amount,\\n    uint256 index\\n  ) external returns (bool);\\n\\n  /**\\n   * @dev Emitted after mTokens are burned\\n   * @param from The owner of the mTokens, getting them burned\\n   * @param target The address that will receive the underlying\\n   * @param value The amount being burned\\n   * @param index The new liquidity index of the reserve\\n   **/\\n  event Burn(address indexed from, address indexed target, uint256 value, uint256 index);\\n\\n  /**\\n   * @dev Emitted during the transfer action\\n   * @param from The user whose tokens are being transferred\\n   * @param to The recipient\\n   * @param value The amount being transferred\\n   * @param index The new liquidity index of the reserve\\n   **/\\n  event BalanceTransfer(address indexed from, address indexed to, uint256 value, uint256 index);\\n\\n  /**\\n   * @dev Burns mTokens from `user` and sends the equivalent amount of underlying to `receiverOfUnderlying`\\n   * @param user The owner of the mTokens, getting them burned\\n   * @param receiverOfUnderlying The address that will receive the underlying\\n   * @param amount The amount being burned\\n   * @param index The new liquidity index of the reserve\\n   **/\\n  function burn(\\n    address user,\\n    address receiverOfUnderlying,\\n    uint256 amount,\\n    uint256 index\\n  ) external;\\n\\n  function transferFrom(address from, address to, uint256 value, DataTypes.Period period) external returns (bool);\\n\\n  /**\\n   * @dev Calculates the balance of the user: principal balance + interest generated by the principal\\n   * @param user The user whose balance is calculated\\n   * @param period The period of the balance\\n   * @return The balance of the user\\n   **/\\n  function balanceOf(address user, DataTypes.Period period) external returns (uint256);\\n\\n  /**\\n   * @dev Mints mTokens to the reserve treasury\\n   * @param amount The amount of tokens getting minted\\n   * @param index The new liquidity index of the reserve\\n   */\\n  function mintToTreasury(uint256 amount, uint256 index) external;\\n\\n  /**\\n   * @dev Transfers the underlying asset to `target`. Used by the LendPool to transfer\\n   * assets in borrow(), withdraw() and flashLoan()\\n   * @param user The recipient of the underlying\\n   * @param amount The amount getting transferred\\n   * @return The amount transferred\\n   **/\\n  function transferUnderlyingTo(address user, uint256 amount) external returns (uint256);\\n\\n  /**\\n   * @dev Returns the address of the incentives controller contract\\n   **/\\n  function getIncentivesController() external view returns (IIncentivesController);\\n\\n  /**\\n   * @dev Returns the address of the underlying asset of this mToken\\n   **/\\n  function UNDERLYING_ASSET_ADDRESS() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/helpers/Errors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.8.4;\\n\\n/**\\n * @title Errors library\\n * @author MetaFire\\n * @notice Defines the error messages emitted by the different contracts of the MetaFire protocol\\n */\\nlibrary Errors {\\n  enum ReturnCode {\\n    SUCCESS,\\n    FAILED\\n  }\\n\\n  string public constant SUCCESS = \\\"0\\\";\\n\\n  //common errors\\n  string public constant CALLER_NOT_POOL_ADMIN = \\\"100\\\"; // 'The caller must be the pool admin'\\n  string public constant CALLER_NOT_ADDRESS_PROVIDER = \\\"101\\\";\\n  string public constant INVALID_FROM_BALANCE_AFTER_TRANSFER = \\\"102\\\";\\n  string public constant INVALID_TO_BALANCE_AFTER_TRANSFER = \\\"103\\\";\\n  string public constant CALLER_NOT_ONBEHALFOF_OR_IN_WHITELIST = \\\"104\\\";\\n\\n  //math library erros\\n  string public constant MATH_MULTIPLICATION_OVERFLOW = \\\"200\\\";\\n  string public constant MATH_ADDITION_OVERFLOW = \\\"201\\\";\\n  string public constant MATH_DIVISION_BY_ZERO = \\\"202\\\";\\n\\n  //validation & check errors\\n  string public constant VL_INVALID_AMOUNT = \\\"301\\\"; // 'Amount must be greater than 0'\\n  string public constant VL_NO_ACTIVE_RESERVE = \\\"302\\\"; // 'Action requires an active reserve'\\n  string public constant VL_RESERVE_FROZEN = \\\"303\\\"; // 'Action cannot be performed because the reserve is frozen'\\n  string public constant VL_NOT_ENOUGH_AVAILABLE_USER_BALANCE = \\\"304\\\"; // 'User cannot withdraw more than the available balance'\\n  string public constant VL_BORROWING_NOT_ENABLED = \\\"305\\\"; // 'Borrowing is not enabled'\\n  string public constant VL_COLLATERAL_BALANCE_IS_0 = \\\"306\\\"; // 'The collateral balance is 0'\\n  string public constant VL_HEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLD = \\\"307\\\"; // 'Health factor is lesser than the liquidation threshold'\\n  string public constant VL_COLLATERAL_CANNOT_COVER_NEW_BORROW = \\\"308\\\"; // 'There is not enough collateral to cover a new borrow'\\n  string public constant VL_NO_DEBT_OF_SELECTED_TYPE = \\\"309\\\"; // 'for repayment of stable debt, the user needs to have stable debt, otherwise, he needs to have variable debt'\\n  string public constant VL_NO_ACTIVE_NFT = \\\"310\\\";\\n  string public constant VL_NFT_FROZEN = \\\"311\\\";\\n  string public constant VL_SPECIFIED_CURRENCY_NOT_BORROWED_BY_USER = \\\"312\\\"; // 'User did not borrow the specified currency'\\n  string public constant VL_INVALID_HEALTH_FACTOR = \\\"313\\\";\\n  string public constant VL_INVALID_ONBEHALFOF_ADDRESS = \\\"314\\\";\\n  string public constant VL_INVALID_TARGET_ADDRESS = \\\"315\\\";\\n  string public constant VL_INVALID_RESERVE_ADDRESS = \\\"316\\\";\\n  string public constant VL_SPECIFIED_LOAN_NOT_BORROWED_BY_USER = \\\"317\\\";\\n  string public constant VL_SPECIFIED_RESERVE_NOT_BORROWED_BY_USER = \\\"318\\\";\\n  string public constant VL_HEALTH_FACTOR_HIGHER_THAN_LIQUIDATION_THRESHOLD = \\\"319\\\";\\n\\n  //lend pool errors\\n  string public constant LP_CALLER_NOT_LEND_POOL_CONFIGURATOR = \\\"400\\\"; // 'The caller of the function is not the lending pool configurator'\\n  string public constant LP_IS_PAUSED = \\\"401\\\"; // 'Pool is paused'\\n  string public constant LP_NO_MORE_RESERVES_ALLOWED = \\\"402\\\";\\n  string public constant LP_NOT_CONTRACT = \\\"403\\\";\\n  string public constant LP_BORROW_NOT_EXCEED_LIQUIDATION_THRESHOLD = \\\"404\\\";\\n  string public constant LP_BORROW_IS_EXCEED_LIQUIDATION_PRICE = \\\"405\\\";\\n  string public constant LP_NO_MORE_NFTS_ALLOWED = \\\"406\\\";\\n  string public constant LP_INVALIED_USER_NFT_AMOUNT = \\\"407\\\";\\n  string public constant LP_INCONSISTENT_PARAMS = \\\"408\\\";\\n  string public constant LP_NFT_IS_NOT_USED_AS_COLLATERAL = \\\"409\\\";\\n  string public constant LP_CALLER_MUST_BE_AN_MTOKEN = \\\"410\\\";\\n  string public constant LP_INVALIED_NFT_AMOUNT = \\\"411\\\";\\n  string public constant LP_NFT_HAS_USED_AS_COLLATERAL = \\\"412\\\";\\n  string public constant LP_DELEGATE_CALL_FAILED = \\\"413\\\";\\n  string public constant LP_AMOUNT_LESS_THAN_EXTRA_DEBT = \\\"414\\\";\\n  string public constant LP_AMOUNT_LESS_THAN_REDEEM_THRESHOLD = \\\"415\\\";\\n  string public constant LP_AMOUNT_GREATER_THAN_MAX_REPAY = \\\"416\\\";\\n  string public constant LP_NFT_TOKEN_ID_EXCEED_MAX_LIMIT = \\\"417\\\";\\n  string public constant LP_NFT_SUPPLY_NUM_EXCEED_MAX_LIMIT = \\\"418\\\";\\n  string public constant LP_CALLER_NOT_VALID_INTERCEPTOR = \\\"419\\\";\\n  string public constant LP_CALLER_NOT_VALID_LOCKER = \\\"420\\\";\\n\\n  //lend pool loan errors\\n  string public constant LPL_INVALID_LOAN_STATE = \\\"480\\\";\\n  string public constant LPL_INVALID_LOAN_AMOUNT = \\\"481\\\";\\n  string public constant LPL_INVALID_TAKEN_AMOUNT = \\\"482\\\";\\n  string public constant LPL_AMOUNT_OVERFLOW = \\\"483\\\";\\n  string public constant LPL_BID_PRICE_LESS_THAN_LIQUIDATION_PRICE = \\\"484\\\";\\n  string public constant LPL_BID_PRICE_LESS_THAN_HIGHEST_PRICE = \\\"485\\\";\\n  string public constant LPL_BID_REDEEM_DURATION_HAS_END = \\\"486\\\";\\n  string public constant LPL_BID_USER_NOT_SAME = \\\"487\\\";\\n  string public constant LPL_BID_REPAY_AMOUNT_NOT_ENOUGH = \\\"488\\\";\\n  string public constant LPL_BID_AUCTION_DURATION_HAS_END = \\\"489\\\";\\n  string public constant LPL_BID_AUCTION_DURATION_NOT_END = \\\"490\\\";\\n  string public constant LPL_BID_PRICE_LESS_THAN_BORROW = \\\"491\\\";\\n  string public constant LPL_INVALID_BIDDER_ADDRESS = \\\"492\\\";\\n  string public constant LPL_AMOUNT_LESS_THAN_BID_FINE = \\\"493\\\";\\n  string public constant LPL_INVALID_BID_FINE = \\\"494\\\";\\n\\n  //common token errors\\n  string public constant CT_CALLER_MUST_BE_LEND_POOL = \\\"500\\\"; // 'The caller of this function must be a lending pool'\\n  string public constant CT_INVALID_MINT_AMOUNT = \\\"501\\\"; //invalid amount to mint\\n  string public constant CT_INVALID_BURN_AMOUNT = \\\"502\\\"; //invalid amount to burn\\n  string public constant CT_BORROW_ALLOWANCE_NOT_ENOUGH = \\\"503\\\";\\n\\n  //reserve logic errors\\n  string public constant RL_RESERVE_ALREADY_INITIALIZED = \\\"601\\\"; // 'Reserve has already been initialized'\\n  string public constant RL_LIQUIDITY_INDEX_OVERFLOW = \\\"602\\\"; //  Liquidity index overflows uint128\\n  string public constant RL_VARIABLE_BORROW_INDEX_OVERFLOW = \\\"603\\\"; //  Variable borrow index overflows uint128\\n  string public constant RL_LIQUIDITY_RATE_OVERFLOW = \\\"604\\\"; //  Liquidity rate overflows uint128\\n  string public constant RL_VARIABLE_BORROW_RATE_OVERFLOW = \\\"605\\\"; //  Variable borrow rate overflows uint128\\n\\n  //configure errors\\n  string public constant LPC_RESERVE_LIQUIDITY_NOT_0 = \\\"700\\\"; // 'The liquidity of the reserve needs to be 0'\\n  string public constant LPC_INVALID_CONFIGURATION = \\\"701\\\"; // 'Invalid risk parameters for the reserve'\\n  string public constant LPC_CALLER_NOT_EMERGENCY_ADMIN = \\\"702\\\"; // 'The caller must be the emergency admin'\\n  string public constant LPC_INVALIED_BNFT_ADDRESS = \\\"703\\\";\\n  string public constant LPC_INVALIED_LOAN_ADDRESS = \\\"704\\\";\\n  string public constant LPC_NFT_LIQUIDITY_NOT_0 = \\\"705\\\";\\n\\n  //reserve config errors\\n  string public constant RC_INVALID_LTV = \\\"730\\\";\\n  string public constant RC_INVALID_LIQ_THRESHOLD = \\\"731\\\";\\n  string public constant RC_INVALID_LIQ_BONUS = \\\"732\\\";\\n  string public constant RC_INVALID_DECIMALS = \\\"733\\\";\\n  string public constant RC_INVALID_RESERVE_FACTOR = \\\"734\\\";\\n  string public constant RC_INVALID_REDEEM_DURATION = \\\"735\\\";\\n  string public constant RC_INVALID_AUCTION_DURATION = \\\"736\\\";\\n  string public constant RC_INVALID_REDEEM_FINE = \\\"737\\\";\\n  string public constant RC_INVALID_REDEEM_THRESHOLD = \\\"738\\\";\\n  string public constant RC_INVALID_MIN_BID_FINE = \\\"739\\\";\\n  string public constant RC_INVALID_MAX_BID_FINE = \\\"740\\\";\\n\\n  //address provider erros\\n  string public constant LPAPR_PROVIDER_NOT_REGISTERED = \\\"760\\\"; // 'Provider is not registered'\\n  string public constant LPAPR_INVALID_ADDRESSES_PROVIDER_ID = \\\"761\\\";\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/types/DataTypes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.8.4;\\n\\nlibrary DataTypes {\\n  \\n  enum Period {\\n    FourMonth,\\n    SevenMonth,\\n    ElevenMonth,\\n    ThirteenMonth\\n  }\\n\\n  // [0] - 4 month\\n  // [1] - 7 month\\n  // [2] - 11 month\\n  // [3] - 13 month\\n  struct ReserveData {\\n    //stores the reserve configuration\\n    ReserveConfigurationMap configuration;\\n    //the liquidity index. Expressed in ray\\n    uint128[4] liquidityIndices;\\n    //variable borrow index. Expressed in ray\\n    uint128 variableBorrowIndex;\\n    //the current supply rate. Expressed in ray\\n    uint128[4] currentLiquidityRates;\\n    //the current variable borrow rate. Expressed in ray\\n    uint128 currentVariableBorrowRate;\\n    uint40 lastUpdateTimestamp;\\n    //tokens addresses\\n    address[4] mTokenAddresses;\\n    address debtTokenAddress;\\n    //address of the interest rate strategy\\n    address interestRateAddress;\\n    //the id of the reserve. Represents the position in the list of the active reserves\\n    uint8 id;\\n  }\\n\\n  struct NftData {\\n    //stores the nft configuration\\n    NftConfigurationMap configuration;\\n    //address of the bNFT contract\\n    address bNftAddress;\\n    //the id of the nft. Represents the position in the list of the active nfts\\n    uint8 id;\\n    uint256 maxSupply;\\n    uint256 maxTokenId;\\n  }\\n\\n  struct ReserveConfigurationMap {\\n    //bit 0-15: LTV\\n    //bit 16-31: Liq. threshold\\n    //bit 32-47: Liq. bonus\\n    //bit 48-55: Decimals\\n    //bit 56: Reserve is active\\n    //bit 57: reserve is frozen\\n    //bit 58: borrowing is enabled\\n    //bit 59: stable rate borrowing enabled\\n    //bit 60-63: reserved\\n    //bit 64-79: reserve factor\\n    uint256 data;\\n  }\\n\\n  struct NftConfigurationMap {\\n    //bit 0-15: LTV\\n    //bit 16-31: Liq. threshold\\n    //bit 32-47: Liq. bonus\\n    //bit 56: NFT is active\\n    //bit 57: NFT is frozen\\n    uint256 data;\\n  }\\n\\n  /**\\n   * @dev Enum describing the current state of a loan\\n   * State change flow:\\n   *  Created -> Active -> Repaid\\n   *                    -> Auction -> Defaulted\\n   */\\n  enum LoanState {\\n    // We need a default that is not 'Created' - this is the zero value\\n    None,\\n    // The loan data is stored, but not initiated yet.\\n    Created,\\n    // The loan has been initialized, funds have been delivered to the borrower and the collateral is held.\\n    Active,\\n    // The loan is in auction, higest price liquidator will got chance to claim it.\\n    Auction,\\n    // The loan has been repaid, and the collateral has been returned to the borrower. This is a terminal state.\\n    Repaid,\\n    // The loan was delinquent and collateral claimed by the liquidator. This is a terminal state.\\n    Defaulted\\n  }\\n\\n  struct LoanData {\\n    //the id of the nft loan\\n    uint256 loanId;\\n    //the current state of the loan\\n    LoanState state;\\n    //address of borrower\\n    address borrower;\\n    //address of nft asset token\\n    address nftAsset;\\n    //the id of nft token\\n    uint256 nftTokenId;\\n    //address of reserve asset token\\n    address reserveAsset;\\n    //scaled borrow amount. Expressed in ray\\n    uint256 scaledAmount;\\n    //start time of first bid time\\n    uint256 bidStartTimestamp;\\n    //bidder address of higest bid\\n    address bidderAddress;\\n    //price of higest bid\\n    uint256 bidPrice;\\n    //borrow amount of loan\\n    uint256 bidBorrowAmount;\\n    //bidder address of first bid\\n    address firstBidderAddress;\\n  }\\n\\n  struct ExecuteDepositParams {\\n    address initiator;\\n    address asset;\\n    uint256 amount;\\n    address onBehalfOf;\\n    Period period;\\n    uint16 referralCode;\\n  }\\n\\n  struct ExecuteWithdrawParams {\\n    address initiator;\\n    address asset;\\n    uint256 amount;\\n    address to;\\n    Period period;\\n  }\\n\\n  struct ExecuteBorrowParams {\\n    address initiator;\\n    address asset;\\n    uint256 amount;\\n    address nftAsset;\\n    uint256 nftTokenId;\\n    address onBehalfOf;\\n    uint16 referralCode;\\n  }\\n\\n  struct ExecuteBatchBorrowParams {\\n    address initiator;\\n    address[] assets;\\n    uint256[] amounts;\\n    address[] nftAssets;\\n    uint256[] nftTokenIds;\\n    address onBehalfOf;\\n    uint16 referralCode;\\n  }\\n\\n  struct ExecuteRepayParams {\\n    address initiator;\\n    address nftAsset;\\n    uint256 nftTokenId;\\n    uint256 amount;\\n  }\\n\\n  struct ExecuteBatchRepayParams {\\n    address initiator;\\n    address[] nftAssets;\\n    uint256[] nftTokenIds;\\n    uint256[] amounts;\\n  }\\n\\n  struct ExecuteAuctionParams {\\n    address initiator;\\n    address nftAsset;\\n    uint256 nftTokenId;\\n    uint256 bidPrice;\\n    address onBehalfOf;\\n  }\\n\\n  struct ExecuteLiquidatingBuyParams {\\n    address initiator;\\n    address nftAsset;\\n    uint256 nftTokenId;\\n    uint256 liquidatingBuyPrice;\\n    address onBehalfOf;\\n  }\\n\\n  struct ExecuteRedeemParams {\\n    address initiator;\\n    address nftAsset;\\n    uint256 nftTokenId;\\n    uint256 amount;\\n    uint256 bidFine;\\n  }\\n\\n  struct ExecuteLiquidateParams {\\n    address initiator;\\n    address nftAsset;\\n    uint256 nftTokenId;\\n    uint256 amount;\\n  }\\n\\n  struct ExecuteLendPoolStates {\\n    uint256 pauseStartTime;\\n    uint256 pauseDurationTime;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/logic/ReserveLogic.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.8.4;\\n\\nimport {IMToken} from \\\"../../interfaces/IMToken.sol\\\";\\nimport {IDebtToken} from \\\"../../interfaces/IDebtToken.sol\\\";\\nimport {IInterestRate} from \\\"../../interfaces/IInterestRate.sol\\\";\\nimport {ReserveConfiguration} from \\\"../configuration/ReserveConfiguration.sol\\\";\\nimport {MathUtils} from \\\"../math/MathUtils.sol\\\";\\nimport {WadRayMath} from \\\"../math/WadRayMath.sol\\\";\\nimport {PercentageMath} from \\\"../math/PercentageMath.sol\\\";\\nimport {Errors} from \\\"../helpers/Errors.sol\\\";\\nimport {DataTypes} from \\\"../types/DataTypes.sol\\\";\\n\\nimport {IERC20Upgradeable} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\nimport {SafeERC20Upgradeable} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\\\";\\n\\n/**\\n * @title ReserveLogic library\\n * @author MetaFire\\n * @notice Implements the logic to update the reserves state\\n */\\nlibrary ReserveLogic {\\n  using WadRayMath for uint256;\\n  using PercentageMath for uint256;\\n  using SafeERC20Upgradeable for IERC20Upgradeable;\\n\\n  /**\\n   * @dev Emitted when the state of a reserve is updated\\n   * @param asset The address of the underlying asset of the reserve\\n   * @param liquidityRates The new liquidity rate list\\n   * @param variableBorrowRate The new variable borrow rate\\n   * @param liquidityIndices The new liquidity index\\n   * @param variableBorrowIndex The new variable borrow index\\n   **/\\n  event ReserveDataUpdated(\\n    address indexed asset,\\n    uint256[4] liquidityRates,\\n    uint256 variableBorrowRate,\\n    uint128[4] liquidityIndices,\\n    uint256 variableBorrowIndex\\n  );\\n\\n  using ReserveLogic for DataTypes.ReserveData;\\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\\n\\n  /**\\n   * @dev Returns the ongoing normalized income for the reserve\\n   * A value of 1e27 means there is no income. As time passes, the income is accrued\\n   * A value of 2*1e27 means for each unit of asset one unit of income has been accrued\\n   * @param reserve The reserve object\\n   * @return the normalized income. expressed in ray\\n   **/\\n   // @Todo: update timestamp choosing\\n  function getNormalizedIncome(DataTypes.ReserveData storage reserve, DataTypes.Period period) internal view returns (uint256) {\\n    uint8 period = uint8(period);\\n    uint40 timestamp = reserve.lastUpdateTimestamp;\\n\\n    //solium-disable-next-line\\n    if (timestamp == uint40(block.timestamp)) {\\n      //if the index was updated in the same block, no need to perform any calculation\\n      return reserve.liquidityIndices[period];\\n    }\\n\\n    uint256 cumulated = MathUtils.calculateLinearInterest(reserve.currentLiquidityRates[period], timestamp).rayMul(\\n      reserve.liquidityIndices[period]\\n    );\\n\\n    return cumulated;\\n  }\\n\\n  /**\\n   * @dev Returns the ongoing normalized variable debt for the reserve\\n   * A value of 1e27 means there is no debt. As time passes, the income is accrued\\n   * A value of 2*1e27 means that for each unit of debt, one unit worth of interest has been accumulated\\n   * @param reserve The reserve object\\n   * @return The normalized variable debt. expressed in ray\\n   **/\\n  function getNormalizedDebt(DataTypes.ReserveData storage reserve) internal view returns (uint256) {\\n    uint40 timestamp = reserve.lastUpdateTimestamp;\\n\\n    //solium-disable-next-line\\n    if (timestamp == uint40(block.timestamp)) {\\n      //if the index was updated in the same block, no need to perform any calculation\\n      return reserve.variableBorrowIndex;\\n    }\\n\\n    uint256 cumulated = MathUtils.calculateCompoundedInterest(reserve.currentVariableBorrowRate, timestamp).rayMul(\\n      reserve.variableBorrowIndex\\n    );\\n\\n    return cumulated;\\n  }\\n\\n  /**\\n   * @dev Updates the liquidity cumulative index and the variable borrow index.\\n   * @param reserve the reserve object\\n   **/\\n  function updateState(DataTypes.ReserveData storage reserve) internal {\\n    uint256 scaledVariableDebt = IDebtToken(reserve.debtTokenAddress).scaledTotalSupply();\\n    uint256 previousVariableBorrowIndex = reserve.variableBorrowIndex;\\n    uint128[4] memory previousLiquidityIndices = reserve.liquidityIndices;\\n    uint40 lastUpdatedTimestamp = reserve.lastUpdateTimestamp;\\n\\n    (uint256[4] memory newLiquidityIndices, uint256 newVariableBorrowIndex) = _updateIndexes(\\n      reserve,\\n      scaledVariableDebt,\\n      previousLiquidityIndices,\\n      previousVariableBorrowIndex,\\n      lastUpdatedTimestamp\\n    );\\n\\n    _mintToTreasury(\\n      reserve,\\n      scaledVariableDebt,\\n      previousVariableBorrowIndex,\\n      newLiquidityIndices,\\n      newVariableBorrowIndex,\\n      lastUpdatedTimestamp\\n    );\\n  }\\n\\n  /**\\n   * @dev Accumulates a predefined amount of asset to the reserve as a fixed, instantaneous income. Used for example to accumulate\\n   * the flashloan fee to the reserve, and spread it between all the depositors\\n   * @param reserve The reserve object\\n   * @param totalLiquidity The total liquidity available in the reserve\\n   * @param amount The amount to accomulate\\n   **/\\n  function cumulateToLiquidityIndex(\\n    DataTypes.ReserveData storage reserve,\\n    uint256 totalLiquidity,\\n    uint256 amount,\\n    uint8 period\\n  ) internal {\\n    uint256 amountToLiquidityRatio = amount.wadToRay().rayDiv(totalLiquidity.wadToRay());\\n\\n    uint256 result = amountToLiquidityRatio + (WadRayMath.ray());\\n\\n    result = result.rayMul(reserve.liquidityIndices[period]);\\n    require(result <= type(uint128).max, Errors.RL_LIQUIDITY_INDEX_OVERFLOW);\\n\\n    reserve.liquidityIndices[period] = uint128(result);\\n  }\\n\\n  /**\\n   * @dev Initializes a reserve\\n   * @param reserve The reserve object\\n   * @param mTokenAddresses The address of the overlying mToken contract\\n   * @param debtTokenAddress The address of the overlying debtToken contract\\n   * @param interestRateAddress The address of the interest rate strategy contract\\n   **/\\n  function init(\\n    DataTypes.ReserveData storage reserve,\\n    address[4] memory mTokenAddresses,\\n    address debtTokenAddress,\\n    address interestRateAddress\\n  ) external {\\n    for (uint256 i = 0; i < reserve.mTokenAddresses.length; i++) {\\n        require(reserve.mTokenAddresses[i] == address(0), Errors.RL_RESERVE_ALREADY_INITIALIZED);\\n    }\\n\\n    uint128[4] memory liquidityIndices = [uint128(WadRayMath.ray()),uint128(WadRayMath.ray()),uint128(WadRayMath.ray()),uint128(WadRayMath.ray())];\\n    \\n    reserve.liquidityIndices = liquidityIndices;\\n    reserve.variableBorrowIndex = uint128(WadRayMath.ray());\\n    reserve.mTokenAddresses = mTokenAddresses;\\n    reserve.debtTokenAddress = debtTokenAddress;\\n    reserve.interestRateAddress = interestRateAddress;\\n  }\\n\\n  struct UpdateInterestRatesLocalVars {\\n    uint256 availableLiquidity;\\n    uint256[4] newLiquidityRates;\\n    uint256 newVariableRate;\\n    uint256 totalVariableDebt;\\n  }\\n\\n  /**\\n   * @dev Updates the reserve current stable borrow rate, the current variable borrow rate and the current liquidity rate\\n   * @param reserve The address of the reserve to be updated\\n   * @param liquidityAdded The amount of liquidity added to the protocol (deposit or repay) in the previous action\\n   * @param liquidityTaken The amount of liquidity taken from the protocol (withdraw or borrow)\\n   **/\\n  function updateInterestRates(\\n    DataTypes.ReserveData storage reserve,\\n    address reserveAddress,\\n    address targetMTokenAddress,\\n    uint256 liquidityAdded,\\n    uint256 liquidityTaken\\n  ) internal {\\n    DataTypes.ReserveData memory _reserve = reserve;\\n    UpdateInterestRatesLocalVars memory vars;\\n    uint256 currentTotalLiquidity;\\n\\n    //calculates the total variable debt locally using the scaled borrow amount instead\\n    //of borrow amount(), as it's noticeably cheaper. Also, the index has been\\n    //updated by the previous updateState() call\\n    vars.totalVariableDebt = IDebtToken(reserve.debtTokenAddress).scaledTotalSupply().rayMul(\\n      reserve.variableBorrowIndex\\n    );\\n\\n    (vars.newLiquidityRates, vars.newVariableRate) = IInterestRate(reserve.interestRateAddress).calculateInterestRates(\\n      _reserve,\\n      targetMTokenAddress,\\n      liquidityAdded,\\n      liquidityTaken,\\n      vars.totalVariableDebt,\\n      reserve.configuration.getReserveFactor()\\n    );\\n\\n    require(vars.newVariableRate <= type(uint128).max, Errors.RL_VARIABLE_BORROW_RATE_OVERFLOW);\\n    for (uint256 i = 0; i < vars.newLiquidityRates.length; i++) {\\n      require(vars.newLiquidityRates[i] <= type(uint128).max, Errors.RL_LIQUIDITY_RATE_OVERFLOW);\\n      reserve.currentLiquidityRates[i] = uint128(vars.newLiquidityRates[i]);\\n    }\\n    \\n    \\n    reserve.currentVariableBorrowRate = uint128(vars.newVariableRate);\\n\\n    emit ReserveDataUpdated(\\n      reserveAddress,\\n      vars.newLiquidityRates,\\n      vars.newVariableRate,\\n      reserve.liquidityIndices,\\n      reserve.variableBorrowIndex\\n    );\\n  }\\n\\n  struct MintToTreasuryLocalVars {\\n    uint256 currentVariableDebt;\\n    uint256 previousVariableDebt;\\n    uint256 totalDebtAccrued;\\n    uint256 amountToMint;\\n    uint256 reserveFactor;\\n  }\\n\\n  /**\\n   * @dev Mints part of the repaid interest to the reserve treasury as a function of the reserveFactor for the\\n   * specific asset.\\n   * @param reserve The reserve reserve to be updated\\n   * @param scaledVariableDebt The current scaled total variable debt\\n   * @param previousVariableBorrowIndex The variable borrow index before the last accumulation of the interest\\n   * @param newLiquidityIndices The new liquidity index\\n   * @param newVariableBorrowIndex The variable borrow index after the last accumulation of the interest\\n   * @param timestamp The timestamp of the action\\n   **/\\n  function _mintToTreasury(\\n    DataTypes.ReserveData storage reserve,\\n    uint256 scaledVariableDebt,\\n    uint256 previousVariableBorrowIndex,\\n    uint256[4] memory newLiquidityIndices,\\n    uint256 newVariableBorrowIndex,\\n    uint40 timestamp\\n  ) internal {\\n    timestamp;\\n    MintToTreasuryLocalVars memory vars;\\n\\n    vars.reserveFactor = reserve.configuration.getReserveFactor();\\n\\n    if (vars.reserveFactor == 0) {\\n      return;\\n    }\\n\\n    //calculate the last principal variable debt\\n    vars.previousVariableDebt = scaledVariableDebt.rayMul(previousVariableBorrowIndex);\\n\\n    //calculate the new total supply after accumulation of the index\\n    vars.currentVariableDebt = scaledVariableDebt.rayMul(newVariableBorrowIndex);\\n\\n    //debt accrued is the sum of the current debt minus the sum of the debt at the last update\\n    vars.totalDebtAccrued = vars.currentVariableDebt - (vars.previousVariableDebt);\\n\\n    vars.amountToMint = vars.totalDebtAccrued.percentMul(vars.reserveFactor);\\n\\n    if (vars.amountToMint != 0) {\\n      IMToken(reserve.mTokenAddresses[0]).mintToTreasury(vars.amountToMint, newLiquidityIndices[0]);\\n    }\\n  }\\n\\n  /**\\n   * @dev Updates the reserve indexes and the timestamp of the update\\n   * @param reserve The reserve reserve to be updated\\n   * @param scaledVariableDebt The scaled variable debt\\n   * @param liquidityIndices The last stored liquidity index\\n   * @param variableBorrowIndex The last stored variable borrow index\\n   * @param timestamp The timestamp of the action\\n   **/\\n  function _updateIndexes(\\n    DataTypes.ReserveData storage reserve,\\n    uint256 scaledVariableDebt,\\n    uint128[4] memory liquidityIndices,\\n    uint256 variableBorrowIndex,\\n    uint40 timestamp\\n  ) internal returns (uint256[4] memory, uint256) {\\n    \\n    uint256 newVariableBorrowIndex = variableBorrowIndex;\\n\\n    uint256[4] memory newLiquidtyIndices;\\n\\n    for (uint8 i = 0; i < newLiquidtyIndices.length; i++) {\\n      newLiquidtyIndices[i] = liquidityIndices[i];\\n\\n      uint256 currentLiquidityRate = reserve.currentLiquidityRates[i];\\n      uint256 newLiquidityIndex = liquidityIndices[i];\\n      \\n      //only cumulating if there is any income being produced\\n      if (currentLiquidityRate > 0) {\\n        uint256 cumulatedLiquidityInterest = MathUtils.calculateLinearInterest(currentLiquidityRate, timestamp);\\n        newLiquidityIndex = cumulatedLiquidityInterest.rayMul(liquidityIndices[i]);\\n        require(newLiquidityIndex <= type(uint128).max, Errors.RL_LIQUIDITY_INDEX_OVERFLOW);\\n\\n        reserve.liquidityIndices[i] = uint128(newLiquidityIndex);\\n        newLiquidtyIndices[i] = newLiquidityIndex;\\n      }\\n    }\\n\\n    //as the liquidity rate might come only from stable rate loans, we need to ensure\\n    //that there is actual variable debt before accumulating\\n    if (scaledVariableDebt != 0 &&  (reserve.currentLiquidityRates[0] > 0 || reserve.currentLiquidityRates[1] > 0 || reserve.currentLiquidityRates[2] > 0 || reserve.currentLiquidityRates[3] > 0)) {\\n      uint256 cumulatedVariableBorrowInterest = MathUtils.calculateCompoundedInterest(\\n        reserve.currentVariableBorrowRate,\\n        timestamp\\n      );\\n      newVariableBorrowIndex = cumulatedVariableBorrowInterest.rayMul(variableBorrowIndex);\\n      require(newVariableBorrowIndex <= type(uint128).max, Errors.RL_VARIABLE_BORROW_INDEX_OVERFLOW);\\n      reserve.variableBorrowIndex = uint128(newVariableBorrowIndex);\\n    }\\n    \\n\\n    //solium-disable-next-line\\n    reserve.lastUpdateTimestamp = uint40(block.timestamp);\\n    return (newLiquidtyIndices, newVariableBorrowIndex);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/logic/ValidationLogic.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.8.4;\\n\\nimport {ReserveLogic} from \\\"./ReserveLogic.sol\\\";\\nimport {GenericLogic} from \\\"./GenericLogic.sol\\\";\\nimport {WadRayMath} from \\\"../math/WadRayMath.sol\\\";\\nimport {PercentageMath} from \\\"../math/PercentageMath.sol\\\";\\nimport {ReserveConfiguration} from \\\"../configuration/ReserveConfiguration.sol\\\";\\nimport {NftConfiguration} from \\\"../configuration/NftConfiguration.sol\\\";\\nimport {Errors} from \\\"../helpers/Errors.sol\\\";\\nimport {DataTypes} from \\\"../types/DataTypes.sol\\\";\\nimport {IInterestRate} from \\\"../../interfaces/IInterestRate.sol\\\";\\nimport {ILendPoolLoan} from \\\"../../interfaces/ILendPoolLoan.sol\\\";\\n\\nimport {IERC20Upgradeable} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\nimport {SafeERC20Upgradeable} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\\\";\\n\\n/**\\n * @title ValidationLogic library\\n * @author MetaFire\\n * @notice Implements functions to validate the different actions of the protocol\\n */\\nlibrary ValidationLogic {\\n  using ReserveLogic for DataTypes.ReserveData;\\n  using WadRayMath for uint256;\\n  using PercentageMath for uint256;\\n  using SafeERC20Upgradeable for IERC20Upgradeable;\\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\\n  using NftConfiguration for DataTypes.NftConfigurationMap;\\n\\n  /**\\n   * @dev Validates a deposit action\\n   * @param reserve The reserve object on which the user is depositing\\n   * @param amount The amount to be deposited\\n   */\\n  function validateDeposit(DataTypes.ReserveData storage reserve, uint256 amount) external view {\\n    (bool isActive, bool isFrozen, , ) = reserve.configuration.getFlags();\\n\\n    require(amount != 0, Errors.VL_INVALID_AMOUNT);\\n    require(isActive, Errors.VL_NO_ACTIVE_RESERVE);\\n    require(!isFrozen, Errors.VL_RESERVE_FROZEN);\\n  }\\n\\n  /**\\n   * @dev Validates a withdraw action\\n   * @param reserveData The reserve state\\n   * @param amount The amount to be withdrawn\\n   * @param userBalance The balance of the user\\n   */\\n  function validateWithdraw(\\n    DataTypes.ReserveData storage reserveData,\\n    uint256 amount,\\n    uint256 userBalance\\n  ) external view {\\n    require(amount != 0, Errors.VL_INVALID_AMOUNT);\\n    require(amount <= userBalance, Errors.VL_NOT_ENOUGH_AVAILABLE_USER_BALANCE);\\n\\n    (bool isActive, , , ) = reserveData.configuration.getFlags();\\n    require(isActive, Errors.VL_NO_ACTIVE_RESERVE);\\n  }\\n\\n  struct ValidateBorrowLocalVars {\\n    uint256 currentLtv;\\n    uint256 currentLiquidationThreshold;\\n    uint256 amountOfCollateralNeeded;\\n    uint256 userCollateralBalance;\\n    uint256 userBorrowBalance;\\n    uint256 availableLiquidity;\\n    uint256 healthFactor;\\n    bool isActive;\\n    bool isFrozen;\\n    bool borrowingEnabled;\\n    bool stableRateBorrowingEnabled;\\n    bool nftIsActive;\\n    bool nftIsFrozen;\\n    address loanReserveAsset;\\n    address loanBorrower;\\n  }\\n\\n  /**\\n   * @dev Validates a borrow action\\n   * @param reserveAsset The address of the asset to borrow\\n   * @param amount The amount to be borrowed\\n   * @param reserveData The reserve state from which the user is borrowing\\n   * @param nftData The state of the user for the specific nft\\n   */\\n  function validateBorrow(\\n    address user,\\n    address reserveAsset,\\n    uint256 amount,\\n    DataTypes.ReserveData storage reserveData,\\n    address nftAsset,\\n    DataTypes.NftData storage nftData,\\n    address loanAddress,\\n    uint256 loanId,\\n    address reserveOracle,\\n    address nftOracle\\n  ) external view {\\n    ValidateBorrowLocalVars memory vars;\\n\\n    for(uint256 i = 0; i < reserveData.mTokenAddresses.length; i++) {\\n      require(reserveData.mTokenAddresses[i] != address(0), Errors.VL_INVALID_RESERVE_ADDRESS);\\n    }\\n\\n    require(nftData.bNftAddress != address(0), Errors.LPC_INVALIED_BNFT_ADDRESS);\\n    require(amount > 0, Errors.VL_INVALID_AMOUNT);\\n\\n    if (loanId != 0) {\\n      DataTypes.LoanData memory loanData = ILendPoolLoan(loanAddress).getLoan(loanId);\\n\\n      require(loanData.state == DataTypes.LoanState.Active, Errors.LPL_INVALID_LOAN_STATE);\\n      require(reserveAsset == loanData.reserveAsset, Errors.VL_SPECIFIED_RESERVE_NOT_BORROWED_BY_USER);\\n      require(user == loanData.borrower, Errors.VL_SPECIFIED_LOAN_NOT_BORROWED_BY_USER);\\n    }\\n\\n    (vars.isActive, vars.isFrozen, vars.borrowingEnabled, vars.stableRateBorrowingEnabled) = reserveData\\n      .configuration\\n      .getFlags();\\n    require(vars.isActive, Errors.VL_NO_ACTIVE_RESERVE);\\n    require(!vars.isFrozen, Errors.VL_RESERVE_FROZEN);\\n    require(vars.borrowingEnabled, Errors.VL_BORROWING_NOT_ENABLED);\\n\\n    (vars.nftIsActive, vars.nftIsFrozen) = nftData.configuration.getFlags();\\n    require(vars.nftIsActive, Errors.VL_NO_ACTIVE_NFT);\\n    require(!vars.nftIsFrozen, Errors.VL_NFT_FROZEN);\\n\\n    (vars.currentLtv, vars.currentLiquidationThreshold, ) = nftData.configuration.getCollateralParams();\\n\\n    (vars.userCollateralBalance, vars.userBorrowBalance, vars.healthFactor) = GenericLogic.calculateLoanData(\\n      reserveAsset,\\n      reserveData,\\n      nftAsset,\\n      nftData,\\n      loanAddress,\\n      loanId,\\n      reserveOracle,\\n      nftOracle\\n    );\\n\\n    require(vars.userCollateralBalance > 0, Errors.VL_COLLATERAL_BALANCE_IS_0);\\n\\n    require(\\n      vars.healthFactor > GenericLogic.HEALTH_FACTOR_LIQUIDATION_THRESHOLD,\\n      Errors.VL_HEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLD\\n    );\\n\\n    //add the current already borrowed amount to the amount requested to calculate the total collateral needed.\\n    //LTV is calculated in percentage\\n    vars.amountOfCollateralNeeded = (vars.userBorrowBalance + amount).percentDiv(vars.currentLtv);\\n\\n    require(vars.amountOfCollateralNeeded <= vars.userCollateralBalance, Errors.VL_COLLATERAL_CANNOT_COVER_NEW_BORROW);\\n  }\\n\\n  /**\\n   * @dev Validates a repay action\\n   * @param reserveData The reserve state from which the user is repaying\\n   * @param amountSent The amount sent for the repayment. Can be an actual value or uint(-1)\\n   * @param borrowAmount The borrow balance of the user\\n   */\\n  function validateRepay(\\n    DataTypes.ReserveData storage reserveData,\\n    DataTypes.NftData storage nftData,\\n    DataTypes.LoanData memory loanData,\\n    uint256 amountSent,\\n    uint256 borrowAmount\\n  ) external view {\\n    require(nftData.bNftAddress != address(0), Errors.LPC_INVALIED_BNFT_ADDRESS);\\n\\n    for(uint256 i = 0; i < reserveData.mTokenAddresses.length; i++) {\\n      require(reserveData.mTokenAddresses[i] != address(0), Errors.VL_INVALID_RESERVE_ADDRESS);\\n    }\\n\\n    require(reserveData.configuration.getActive(), Errors.VL_NO_ACTIVE_RESERVE);\\n\\n    require(nftData.configuration.getActive(), Errors.VL_NO_ACTIVE_NFT);\\n\\n    require(amountSent > 0, Errors.VL_INVALID_AMOUNT);\\n\\n    require(borrowAmount > 0, Errors.VL_NO_DEBT_OF_SELECTED_TYPE);\\n\\n    require(loanData.state == DataTypes.LoanState.Active, Errors.LPL_INVALID_LOAN_STATE);\\n  }\\n\\n  /**\\n   * @dev Validates the auction action\\n   * @param reserveData The reserve data of the principal\\n   * @param nftData The nft data of the underlying nft\\n   * @param bidPrice Total variable debt balance of the user\\n   **/\\n  function validateAuction(\\n    DataTypes.ReserveData storage reserveData,\\n    DataTypes.NftData storage nftData,\\n    DataTypes.LoanData memory loanData,\\n    uint256 bidPrice\\n  ) internal view {\\n    require(nftData.bNftAddress != address(0), Errors.LPC_INVALIED_BNFT_ADDRESS);\\n    \\n    for(uint256 i = 0; i < reserveData.mTokenAddresses.length; i++) {\\n      require(reserveData.mTokenAddresses[i] != address(0), Errors.VL_INVALID_RESERVE_ADDRESS);\\n    }\\n\\n    require(reserveData.configuration.getActive(), Errors.VL_NO_ACTIVE_RESERVE);\\n\\n    require(nftData.configuration.getActive(), Errors.VL_NO_ACTIVE_NFT);\\n\\n    require(\\n      loanData.state == DataTypes.LoanState.Active || loanData.state == DataTypes.LoanState.Auction,\\n      Errors.LPL_INVALID_LOAN_STATE\\n    );\\n\\n    require(bidPrice > 0, Errors.VL_INVALID_AMOUNT);\\n  }\\n\\n  /**\\n   * @dev Validates the liquidating buy\\n   * @param reserveData The reserve data of the principal\\n   * @param nftData The data of the underlying NFT\\n   * @param loanData The loan data of the underlying NFT\\n   * @param liquidatingBuyPrice The liquidating buy price\\n   **/\\n  function validateLiquidatingBuy(\\n    DataTypes.ReserveData storage reserveData,\\n    DataTypes.NftData storage nftData,\\n    DataTypes.LoanData memory loanData,\\n    uint256 liquidatingBuyPrice\\n  ) internal view {\\n    require(nftData.bNftAddress != address(0), Errors.LPC_INVALIED_BNFT_ADDRESS);\\n    \\n    for(uint256 i = 0; i < reserveData.mTokenAddresses.length; i++) {\\n      require(reserveData.mTokenAddresses[i] != address(0), Errors.VL_INVALID_RESERVE_ADDRESS);\\n    }\\n\\n    require(reserveData.configuration.getActive(), Errors.VL_NO_ACTIVE_RESERVE);\\n\\n    require(nftData.configuration.getActive(), Errors.VL_NO_ACTIVE_NFT);\\n\\n    require(\\n      loanData.state == DataTypes.LoanState.Active,\\n      Errors.LPL_INVALID_LOAN_STATE\\n    );\\n\\n    require(liquidatingBuyPrice > 0, Errors.VL_INVALID_AMOUNT);\\n  }\\n\\n  /**\\n   * @dev Validates a redeem action\\n   * @param reserveData The reserve state\\n   * @param nftData The nft state\\n   */\\n  function validateRedeem(\\n    DataTypes.ReserveData storage reserveData,\\n    DataTypes.NftData storage nftData,\\n    DataTypes.LoanData memory loanData,\\n    uint256 amount\\n  ) external view {\\n    require(nftData.bNftAddress != address(0), Errors.LPC_INVALIED_BNFT_ADDRESS);\\n\\n    for(uint256 i = 0; i < reserveData.mTokenAddresses.length; i++) {\\n      require(reserveData.mTokenAddresses[i] != address(0), Errors.VL_INVALID_RESERVE_ADDRESS);\\n    }\\n\\n    require(reserveData.configuration.getActive(), Errors.VL_NO_ACTIVE_RESERVE);\\n\\n    require(nftData.configuration.getActive(), Errors.VL_NO_ACTIVE_NFT);\\n\\n    require(loanData.state == DataTypes.LoanState.Auction, Errors.LPL_INVALID_LOAN_STATE);\\n\\n    require(loanData.bidderAddress != address(0), Errors.LPL_INVALID_BIDDER_ADDRESS);\\n\\n    require(amount > 0, Errors.VL_INVALID_AMOUNT);\\n  }\\n\\n  /**\\n   * @dev Validates the liquidation action\\n   * @param reserveData The reserve data of the principal\\n   * @param nftData The data of the underlying NFT\\n   * @param loanData The loan data of the underlying NFT\\n   **/\\n  function validateLiquidate(\\n    DataTypes.ReserveData storage reserveData,\\n    DataTypes.NftData storage nftData,\\n    DataTypes.LoanData memory loanData\\n  ) internal view {\\n    require(nftData.bNftAddress != address(0), Errors.LPC_INVALIED_BNFT_ADDRESS);\\n\\n    for(uint256 i = 0; i < reserveData.mTokenAddresses.length; i++) {\\n      require(reserveData.mTokenAddresses[i] != address(0), Errors.VL_INVALID_RESERVE_ADDRESS);\\n    }\\n\\n    require(reserveData.configuration.getActive(), Errors.VL_NO_ACTIVE_RESERVE);\\n\\n    require(nftData.configuration.getActive(), Errors.VL_NO_ACTIVE_NFT);\\n\\n    require(loanData.state == DataTypes.LoanState.Auction, Errors.LPL_INVALID_LOAN_STATE);\\n\\n    require(loanData.bidderAddress != address(0), Errors.LPL_INVALID_BIDDER_ADDRESS);\\n  }\\n\\n  /**\\n   * @dev Validates an mToken transfer\\n   * @param from The user from which the mTokens are being transferred\\n   * @param reserveData The state of the reserve\\n   */\\n  function validateTransfer(address from, DataTypes.ReserveData storage reserveData) internal pure {\\n    from;\\n    reserveData;\\n  }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20Upgradeable {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20Upgradeable.sol\\\";\\nimport \\\"../extensions/draft-IERC20PermitUpgradeable.sol\\\";\\nimport \\\"../../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20Upgradeable {\\n    using AddressUpgradeable for address;\\n\\n    function safeTransfer(\\n        IERC20Upgradeable token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20Upgradeable token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20Upgradeable token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20Upgradeable token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20Upgradeable token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    function safePermit(\\n        IERC20PermitUpgradeable token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IIncentivesController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.8.4;\\n\\ninterface IIncentivesController {\\n  /**\\n   * @dev Called by the corresponding asset on any update that affects the rewards distribution\\n   * @param asset The address of the user\\n   * @param totalSupply The total supply of the asset in the lending pool\\n   * @param userBalance The balance of the user of the asset in the lending pool\\n   **/\\n  function handleAction(\\n    address asset,\\n    uint256 totalSupply,\\n    uint256 userBalance\\n  ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IScaledBalanceToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.8.4;\\n\\ninterface IScaledBalanceToken {\\n  /**\\n   * @dev Returns the scaled balance of the user. The scaled balance is the sum of all the\\n   * updated stored balance divided by the reserve's liquidity index at the moment of the update\\n   * @param user The user whose balance is calculated\\n   * @return The scaled balance of the user\\n   **/\\n  function scaledBalanceOf(address user) external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the scaled balance of the user and the scaled total supply.\\n   * @param user The address of the user\\n   * @return The scaled balance of the user\\n   * @return The scaled balance and the scaled total supply\\n   **/\\n  function getScaledUserBalanceAndSupply(address user) external view returns (uint256, uint256);\\n\\n  /**\\n   * @dev Returns the scaled total supply of the variable debt token. Represents sum(debt/index)\\n   * @return The scaled total supply\\n   **/\\n  function scaledTotalSupply() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ILendPoolAddressesProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.8.4;\\n\\n/**\\n * @title LendPoolAddressesProvider contract\\n * @dev Main registry of addresses part of or connected to the protocol, including permissioned roles\\n * - Acting also as factory of proxies and admin of those, so with right to change its implementations\\n * - Owned by the MetaFire Governance\\n * @author MetaFire\\n **/\\ninterface ILendPoolAddressesProvider {\\n  event MarketIdSet(string newMarketId);\\n  event LendPoolUpdated(address indexed newAddress, bytes encodedCallData);\\n  event ConfigurationAdminUpdated(address indexed newAddress);\\n  event EmergencyAdminUpdated(address indexed newAddress);\\n  event LendPoolConfiguratorUpdated(address indexed newAddress, bytes encodedCallData);\\n  event ReserveOracleUpdated(address indexed newAddress);\\n  event NftOracleUpdated(address indexed newAddress);\\n  event LendPoolLoanUpdated(address indexed newAddress, bytes encodedCallData);\\n  event ProxyCreated(bytes32 id, address indexed newAddress);\\n  event AddressSet(bytes32 id, address indexed newAddress, bool hasProxy, bytes encodedCallData);\\n  event BNFTRegistryUpdated(address indexed newAddress);\\n  event IncentivesControllerUpdated(address indexed newAddress);\\n  event UIDataProviderUpdated(address indexed newAddress);\\n  event MetaFireDataProviderUpdated(address indexed newAddress);\\n  event WalletBalanceProviderUpdated(address indexed newAddress);\\n\\n  function getMarketId() external view returns (string memory);\\n\\n  function setMarketId(string calldata marketId) external;\\n\\n  function setAddress(bytes32 id, address newAddress) external;\\n\\n  function setAddressAsProxy(\\n    bytes32 id,\\n    address impl,\\n    bytes memory encodedCallData\\n  ) external;\\n\\n  function getAddress(bytes32 id) external view returns (address);\\n\\n  function getLendPool() external view returns (address);\\n\\n  function setLendPoolImpl(address pool, bytes memory encodedCallData) external;\\n\\n  function getLendPoolConfigurator() external view returns (address);\\n\\n  function setLendPoolConfiguratorImpl(address configurator, bytes memory encodedCallData) external;\\n\\n  function getPoolAdmin() external view returns (address);\\n\\n  function setPoolAdmin(address admin) external;\\n\\n  function getEmergencyAdmin() external view returns (address);\\n\\n  function setEmergencyAdmin(address admin) external;\\n\\n  function getReserveOracle() external view returns (address);\\n\\n  function setReserveOracle(address reserveOracle) external;\\n\\n  function getNFTOracle() external view returns (address);\\n\\n  function setNFTOracle(address nftOracle) external;\\n\\n  function getLendPoolLoan() external view returns (address);\\n\\n  function setLendPoolLoanImpl(address loan, bytes memory encodedCallData) external;\\n\\n  function getBNFTRegistry() external view returns (address);\\n\\n  function setBNFTRegistry(address factory) external;\\n\\n  function getIncentivesController() external view returns (address);\\n\\n  function setIncentivesController(address controller) external;\\n\\n  function getUIDataProvider() external view returns (address);\\n\\n  function setUIDataProvider(address provider) external;\\n\\n  function getMetaFireDataProvider() external view returns (address);\\n\\n  function setMetaFireDataProvider(address provider) external;\\n\\n  function getWalletBalanceProvider() external view returns (address);\\n\\n  function setWalletBalanceProvider(address provider) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20Upgradeable.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IMToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.8.4;\\n\\nimport {ILendPoolAddressesProvider} from \\\"./ILendPoolAddressesProvider.sol\\\";\\nimport {IIncentivesController} from \\\"./IIncentivesController.sol\\\";\\nimport {IScaledBalanceToken} from \\\"./IScaledBalanceToken.sol\\\";\\n\\nimport {IERC20Upgradeable} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\nimport {IERC20MetadataUpgradeable} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\\\";\\n\\ninterface IMToken is IScaledBalanceToken, IERC20Upgradeable, IERC20MetadataUpgradeable {\\n  /**\\n   * @dev Emitted when an mToken is initialized\\n   * @param underlyingAsset The address of the underlying asset\\n   * @param pool The address of the associated lending pool\\n   * @param treasury The address of the treasury\\n   * @param incentivesController The address of the incentives controller for this mToken\\n   **/\\n  event Initialized(\\n    address indexed underlyingAsset,\\n    address indexed pool,\\n    address treasury,\\n    address incentivesController\\n  );\\n\\n  /**\\n   * @dev Initializes the mToken\\n   * @param addressProvider The address of the address provider where this mToken will be used\\n   * @param treasury The address of the MetaFire treasury, receiving the fees on this mToken\\n   * @param underlyingAsset The address of the underlying asset of this mToken\\n   */\\n  function initialize(\\n    ILendPoolAddressesProvider addressProvider,\\n    address treasury,\\n    address underlyingAsset,\\n    uint8 mTokenDecimals,\\n    string calldata mTokenName,\\n    string calldata mTokenSymbol\\n  ) external;\\n\\n  /**\\n   * @dev Emitted after the mint action\\n   * @param from The address performing the mint\\n   * @param value The amount being\\n   * @param index The new liquidity index of the reserve\\n   **/\\n  event Mint(address indexed from, uint256 value, uint256 index);\\n\\n  /**\\n   * @dev Mints `amount` mTokens to `user`\\n   * @param user The address receiving the minted tokens\\n   * @param amount The amount of tokens getting minted\\n   * @param index The new liquidity index of the reserve\\n   * @return `true` if the the previous balance of the user was 0\\n   */\\n  function mint(\\n    address user,\\n    uint256 amount,\\n    uint256 index\\n  ) external returns (bool);\\n\\n  /**\\n   * @dev Emitted after mTokens are burned\\n   * @param from The owner of the mTokens, getting them burned\\n   * @param target The address that will receive the underlying\\n   * @param value The amount being burned\\n   * @param index The new liquidity index of the reserve\\n   **/\\n  event Burn(address indexed from, address indexed target, uint256 value, uint256 index);\\n\\n  /**\\n   * @dev Emitted during the transfer action\\n   * @param from The user whose tokens are being transferred\\n   * @param to The recipient\\n   * @param value The amount being transferred\\n   * @param index The new liquidity index of the reserve\\n   **/\\n  event BalanceTransfer(address indexed from, address indexed to, uint256 value, uint256 index);\\n\\n  /**\\n   * @dev Burns mTokens from `user` and sends the equivalent amount of underlying to `receiverOfUnderlying`\\n   * @param user The owner of the mTokens, getting them burned\\n   * @param receiverOfUnderlying The address that will receive the underlying\\n   * @param amount The amount being burned\\n   * @param index The new liquidity index of the reserve\\n   **/\\n  function burn(\\n    address user,\\n    address receiverOfUnderlying,\\n    uint256 amount,\\n    uint256 index\\n  ) external;\\n\\n  /**\\n   * @dev Mints mTokens to the reserve treasury\\n   * @param amount The amount of tokens getting minted\\n   * @param index The new liquidity index of the reserve\\n   */\\n  function mintToTreasury(uint256 amount, uint256 index) external;\\n\\n  /**\\n   * @dev Transfers the underlying asset to `target`. Used by the LendPool to transfer\\n   * assets in borrow(), withdraw() and flashLoan()\\n   * @param user The recipient of the underlying\\n   * @param amount The amount getting transferred\\n   * @return The amount transferred\\n   **/\\n  function transferUnderlyingTo(address user, uint256 amount) external returns (uint256);\\n\\n  /**\\n   * @dev Returns the address of the incentives controller contract\\n   **/\\n  function getIncentivesController() external view returns (IIncentivesController);\\n\\n  /**\\n   * @dev Returns the address of the underlying asset of this mToken\\n   **/\\n  function UNDERLYING_ASSET_ADDRESS() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IDebtToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.8.4;\\n\\nimport {ILendPoolAddressesProvider} from \\\"../interfaces/ILendPoolAddressesProvider.sol\\\";\\nimport {IIncentivesController} from \\\"./IIncentivesController.sol\\\";\\nimport {IScaledBalanceToken} from \\\"./IScaledBalanceToken.sol\\\";\\n\\nimport {IERC20Upgradeable} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\nimport {IERC20MetadataUpgradeable} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\\\";\\n\\n/**\\n * @title IDebtToken\\n * @author MetaFire\\n * @notice Defines the basic interface for a debt token.\\n **/\\ninterface IDebtToken is IScaledBalanceToken, IERC20Upgradeable, IERC20MetadataUpgradeable {\\n  /**\\n   * @dev Emitted when a debt token is initialized\\n   * @param underlyingAsset The address of the underlying asset\\n   * @param pool The address of the associated lend pool\\n   * @param incentivesController The address of the incentives controller\\n   * @param debtTokenDecimals the decimals of the debt token\\n   * @param debtTokenName the name of the debt token\\n   * @param debtTokenSymbol the symbol of the debt token\\n   **/\\n  event Initialized(\\n    address indexed underlyingAsset,\\n    address indexed pool,\\n    address incentivesController,\\n    uint8 debtTokenDecimals,\\n    string debtTokenName,\\n    string debtTokenSymbol\\n  );\\n\\n  /**\\n   * @dev Initializes the debt token.\\n   * @param addressProvider The address of the lend pool\\n   * @param underlyingAsset The address of the underlying asset\\n   * @param debtTokenDecimals The decimals of the debtToken, same as the underlying asset's\\n   * @param debtTokenName The name of the token\\n   * @param debtTokenSymbol The symbol of the token\\n   */\\n  function initialize(\\n    ILendPoolAddressesProvider addressProvider,\\n    address underlyingAsset,\\n    uint8 debtTokenDecimals,\\n    string memory debtTokenName,\\n    string memory debtTokenSymbol\\n  ) external;\\n\\n  /**\\n   * @dev Emitted after the mint action\\n   * @param from The address performing the mint\\n   * @param value The amount to be minted\\n   * @param index The last index of the reserve\\n   **/\\n  event Mint(address indexed from, uint256 value, uint256 index);\\n\\n  /**\\n   * @dev Mints debt token to the `user` address\\n   * @param user The address receiving the borrowed underlying\\n   * @param amount The amount of debt being minted\\n   * @param index The variable debt index of the reserve\\n   * @return `true` if the the previous balance of the user is 0\\n   **/\\n  function mint(\\n    address user,\\n    address onBehalfOf,\\n    uint256 amount,\\n    uint256 index\\n  ) external returns (bool);\\n\\n  /**\\n   * @dev Emitted when variable debt is burnt\\n   * @param user The user which debt has been burned\\n   * @param amount The amount of debt being burned\\n   * @param index The index of the user\\n   **/\\n  event Burn(address indexed user, uint256 amount, uint256 index);\\n\\n  /**\\n   * @dev Burns user variable debt\\n   * @param user The user which debt is burnt\\n   * @param index The variable debt index of the reserve\\n   **/\\n  function burn(\\n    address user,\\n    uint256 amount,\\n    uint256 index\\n  ) external;\\n\\n  /**\\n   * @dev Returns the address of the incentives controller contract\\n   **/\\n  function getIncentivesController() external view returns (IIncentivesController);\\n\\n  /**\\n   * @dev delegates borrowing power to a user on the specific debt token\\n   * @param delegatee the address receiving the delegated borrowing power\\n   * @param amount the maximum amount being delegated. Delegation will still\\n   * respect the liquidation constraints (even if delegated, a delegatee cannot\\n   * force a delegator HF to go below 1)\\n   **/\\n  function approveDelegation(address delegatee, uint256 amount) external;\\n\\n  /**\\n   * @dev returns the borrow allowance of the user\\n   * @param fromUser The user to giving allowance\\n   * @param toUser The user to give allowance to\\n   * @return the current allowance of toUser\\n   **/\\n  function borrowAllowance(address fromUser, address toUser) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IInterestRate.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.8.4;\\n\\nimport {DataTypes} from \\\"../libraries/types/DataTypes.sol\\\";\\n\\n/**\\n * @title IInterestRate interface\\n * @dev Interface for the calculation of the interest rates\\n * @author MetaFire\\n */\\ninterface IInterestRate {\\n  function baseVariableBorrowRate() external view returns (uint256);\\n\\n  function getMaxVariableBorrowRate() external view returns (uint256);\\n\\n  function calculateInterestRates(\\n    DataTypes.ReserveData memory reserve,\\n    uint256 availableLiquidity,\\n    uint256 totalVariableDebt,\\n    uint256 reserveFactor,\\n    uint256[4] memory liquidities\\n  ) external view returns (uint256[4] memory liquidityRates, uint256 variableBorrowRate);\\n\\n  function calculateInterestRates(\\n    DataTypes.ReserveData memory reserve,\\n    address targetMToken,\\n    uint256 liquidityAdded,\\n    uint256 liquidityTaken,\\n    uint256 totalVariableDebt,\\n    uint256 reserveFactor\\n  ) external view returns (uint256[4] memory liquidityRates, uint256 variableBorrowRate);\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/math/MathUtils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.8.4;\\n\\nimport {WadRayMath} from \\\"./WadRayMath.sol\\\";\\n\\nlibrary MathUtils {\\n  using WadRayMath for uint256;\\n\\n  /// @dev Ignoring leap years\\n  uint256 internal constant SECONDS_PER_YEAR = 365 days;\\n\\n  /**\\n   * @dev Function to calculate the interest accumulated using a linear interest rate formula\\n   * @param rate The interest rate, in ray\\n   * @param lastUpdateTimestamp The timestamp of the last update of the interest\\n   * @return The interest rate linearly accumulated during the timeDelta, in ray\\n   **/\\n\\n  function calculateLinearInterest(uint256 rate, uint40 lastUpdateTimestamp) internal view returns (uint256) {\\n    //solium-disable-next-line\\n    uint256 timeDifference = block.timestamp - (uint256(lastUpdateTimestamp));\\n\\n    return ((rate * (timeDifference)) / SECONDS_PER_YEAR) + (WadRayMath.ray());\\n  }\\n\\n  /**\\n   * @dev Function to calculate the interest using a compounded interest rate formula\\n   * To avoid expensive exponentiation, the calculation is performed using a binomial approximation:\\n   *\\n   *  (1+x)^n = 1+n*x+[n/2*(n-1)]*x^2+[n/6*(n-1)*(n-2)*x^3...\\n   *\\n   * The approximation slightly underpays liquidity providers and undercharges borrowers, with the advantage of great gas cost reductions\\n   * The whitepaper contains reference to the approximation and a table showing the margin of error per different time periods\\n   *\\n   * @param rate The interest rate, in ray\\n   * @param lastUpdateTimestamp The timestamp of the last update of the interest\\n   * @return The interest rate compounded during the timeDelta, in ray\\n   **/\\n  function calculateCompoundedInterest(\\n    uint256 rate,\\n    uint40 lastUpdateTimestamp,\\n    uint256 currentTimestamp\\n  ) internal pure returns (uint256) {\\n    //solium-disable-next-line\\n    uint256 exp = currentTimestamp - (uint256(lastUpdateTimestamp));\\n\\n    if (exp == 0) {\\n      return WadRayMath.ray();\\n    }\\n\\n    uint256 expMinusOne = exp - 1;\\n\\n    uint256 expMinusTwo = exp > 2 ? exp - 2 : 0;\\n\\n    uint256 ratePerSecond = rate / SECONDS_PER_YEAR;\\n\\n    uint256 basePowerTwo = ratePerSecond.rayMul(ratePerSecond);\\n    uint256 basePowerThree = basePowerTwo.rayMul(ratePerSecond);\\n\\n    uint256 secondTerm = (exp * (expMinusOne) * (basePowerTwo)) / 2;\\n    uint256 thirdTerm = (exp * (expMinusOne) * (expMinusTwo) * (basePowerThree)) / 6;\\n\\n    return WadRayMath.ray() + (ratePerSecond * (exp)) + (secondTerm) + (thirdTerm);\\n  }\\n\\n  /**\\n   * @dev Calculates the compounded interest between the timestamp of the last update and the current block timestamp\\n   * @param rate The interest rate (in ray)\\n   * @param lastUpdateTimestamp The timestamp from which the interest accumulation needs to be calculated\\n   **/\\n  function calculateCompoundedInterest(uint256 rate, uint40 lastUpdateTimestamp) internal view returns (uint256) {\\n    return calculateCompoundedInterest(rate, lastUpdateTimestamp, block.timestamp);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/configuration/ReserveConfiguration.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.8.4;\\n\\nimport {Errors} from \\\"../helpers/Errors.sol\\\";\\nimport {DataTypes} from \\\"../types/DataTypes.sol\\\";\\n\\n/**\\n * @title ReserveConfiguration library\\n * @author MetaFire\\n * @notice Implements the bitmap logic to handle the reserve configuration\\n */\\nlibrary ReserveConfiguration {\\n  uint256 constant LTV_MASK =                   0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000; // prettier-ignore\\n  uint256 constant LIQUIDATION_THRESHOLD_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFF; // prettier-ignore\\n  uint256 constant LIQUIDATION_BONUS_MASK =     0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFFFFFF; // prettier-ignore\\n  uint256 constant DECIMALS_MASK =              0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00FFFFFFFFFFFF; // prettier-ignore\\n  uint256 constant ACTIVE_MASK =                0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFF; // prettier-ignore\\n  uint256 constant FROZEN_MASK =                0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFDFFFFFFFFFFFFFF; // prettier-ignore\\n  uint256 constant BORROWING_MASK =             0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFBFFFFFFFFFFFFFF; // prettier-ignore\\n  uint256 constant STABLE_BORROWING_MASK =      0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFFFFFFFFF; // prettier-ignore\\n  uint256 constant RESERVE_FACTOR_MASK =        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFFFFFFFFFFFFFF; // prettier-ignore\\n\\n  /// @dev For the LTV, the start bit is 0 (up to 15), hence no bitshifting is needed\\n  uint256 constant LIQUIDATION_THRESHOLD_START_BIT_POSITION = 16;\\n  uint256 constant LIQUIDATION_BONUS_START_BIT_POSITION = 32;\\n  uint256 constant RESERVE_DECIMALS_START_BIT_POSITION = 48;\\n  uint256 constant IS_ACTIVE_START_BIT_POSITION = 56;\\n  uint256 constant IS_FROZEN_START_BIT_POSITION = 57;\\n  uint256 constant BORROWING_ENABLED_START_BIT_POSITION = 58;\\n  uint256 constant STABLE_BORROWING_ENABLED_START_BIT_POSITION = 59;\\n  uint256 constant RESERVE_FACTOR_START_BIT_POSITION = 64;\\n\\n  uint256 constant MAX_VALID_LTV = 65535;\\n  uint256 constant MAX_VALID_LIQUIDATION_THRESHOLD = 65535;\\n  uint256 constant MAX_VALID_LIQUIDATION_BONUS = 65535;\\n  uint256 constant MAX_VALID_DECIMALS = 255;\\n  uint256 constant MAX_VALID_RESERVE_FACTOR = 65535;\\n\\n  /**\\n   * @dev Sets the Loan to Value of the reserve\\n   * @param self The reserve configuration\\n   * @param ltv the new ltv\\n   **/\\n  function setLtv(DataTypes.ReserveConfigurationMap memory self, uint256 ltv) internal pure {\\n    require(ltv <= MAX_VALID_LTV, Errors.RC_INVALID_LTV);\\n\\n    self.data = (self.data & LTV_MASK) | ltv;\\n  }\\n\\n  /**\\n   * @dev Gets the Loan to Value of the reserve\\n   * @param self The reserve configuration\\n   * @return The loan to value\\n   **/\\n  function getLtv(DataTypes.ReserveConfigurationMap storage self) internal view returns (uint256) {\\n    return self.data & ~LTV_MASK;\\n  }\\n\\n  /**\\n   * @dev Sets the liquidation threshold of the reserve\\n   * @param self The reserve configuration\\n   * @param threshold The new liquidation threshold\\n   **/\\n  function setLiquidationThreshold(DataTypes.ReserveConfigurationMap memory self, uint256 threshold) internal pure {\\n    require(threshold <= MAX_VALID_LIQUIDATION_THRESHOLD, Errors.RC_INVALID_LIQ_THRESHOLD);\\n\\n    self.data = (self.data & LIQUIDATION_THRESHOLD_MASK) | (threshold << LIQUIDATION_THRESHOLD_START_BIT_POSITION);\\n  }\\n\\n  /**\\n   * @dev Gets the liquidation threshold of the reserve\\n   * @param self The reserve configuration\\n   * @return The liquidation threshold\\n   **/\\n  function getLiquidationThreshold(DataTypes.ReserveConfigurationMap storage self) internal view returns (uint256) {\\n    return (self.data & ~LIQUIDATION_THRESHOLD_MASK) >> LIQUIDATION_THRESHOLD_START_BIT_POSITION;\\n  }\\n\\n  /**\\n   * @dev Sets the liquidation bonus of the reserve\\n   * @param self The reserve configuration\\n   * @param bonus The new liquidation bonus\\n   **/\\n  function setLiquidationBonus(DataTypes.ReserveConfigurationMap memory self, uint256 bonus) internal pure {\\n    require(bonus <= MAX_VALID_LIQUIDATION_BONUS, Errors.RC_INVALID_LIQ_BONUS);\\n\\n    self.data = (self.data & LIQUIDATION_BONUS_MASK) | (bonus << LIQUIDATION_BONUS_START_BIT_POSITION);\\n  }\\n\\n  /**\\n   * @dev Gets the liquidation bonus of the reserve\\n   * @param self The reserve configuration\\n   * @return The liquidation bonus\\n   **/\\n  function getLiquidationBonus(DataTypes.ReserveConfigurationMap storage self) internal view returns (uint256) {\\n    return (self.data & ~LIQUIDATION_BONUS_MASK) >> LIQUIDATION_BONUS_START_BIT_POSITION;\\n  }\\n\\n  /**\\n   * @dev Sets the decimals of the underlying asset of the reserve\\n   * @param self The reserve configuration\\n   * @param decimals The decimals\\n   **/\\n  function setDecimals(DataTypes.ReserveConfigurationMap memory self, uint256 decimals) internal pure {\\n    require(decimals <= MAX_VALID_DECIMALS, Errors.RC_INVALID_DECIMALS);\\n\\n    self.data = (self.data & DECIMALS_MASK) | (decimals << RESERVE_DECIMALS_START_BIT_POSITION);\\n  }\\n\\n  /**\\n   * @dev Gets the decimals of the underlying asset of the reserve\\n   * @param self The reserve configuration\\n   * @return The decimals of the asset\\n   **/\\n  function getDecimals(DataTypes.ReserveConfigurationMap storage self) internal view returns (uint256) {\\n    return (self.data & ~DECIMALS_MASK) >> RESERVE_DECIMALS_START_BIT_POSITION;\\n  }\\n\\n  /**\\n   * @dev Sets the active state of the reserve\\n   * @param self The reserve configuration\\n   * @param active The active state\\n   **/\\n  function setActive(DataTypes.ReserveConfigurationMap memory self, bool active) internal pure {\\n    self.data = (self.data & ACTIVE_MASK) | (uint256(active ? 1 : 0) << IS_ACTIVE_START_BIT_POSITION);\\n  }\\n\\n  /**\\n   * @dev Gets the active state of the reserve\\n   * @param self The reserve configuration\\n   * @return The active state\\n   **/\\n  function getActive(DataTypes.ReserveConfigurationMap storage self) internal view returns (bool) {\\n    return (self.data & ~ACTIVE_MASK) != 0;\\n  }\\n\\n  /**\\n   * @dev Sets the frozen state of the reserve\\n   * @param self The reserve configuration\\n   * @param frozen The frozen state\\n   **/\\n  function setFrozen(DataTypes.ReserveConfigurationMap memory self, bool frozen) internal pure {\\n    self.data = (self.data & FROZEN_MASK) | (uint256(frozen ? 1 : 0) << IS_FROZEN_START_BIT_POSITION);\\n  }\\n\\n  /**\\n   * @dev Gets the frozen state of the reserve\\n   * @param self The reserve configuration\\n   * @return The frozen state\\n   **/\\n  function getFrozen(DataTypes.ReserveConfigurationMap storage self) internal view returns (bool) {\\n    return (self.data & ~FROZEN_MASK) != 0;\\n  }\\n\\n  /**\\n   * @dev Enables or disables borrowing on the reserve\\n   * @param self The reserve configuration\\n   * @param enabled True if the borrowing needs to be enabled, false otherwise\\n   **/\\n  function setBorrowingEnabled(DataTypes.ReserveConfigurationMap memory self, bool enabled) internal pure {\\n    self.data = (self.data & BORROWING_MASK) | (uint256(enabled ? 1 : 0) << BORROWING_ENABLED_START_BIT_POSITION);\\n  }\\n\\n  /**\\n   * @dev Gets the borrowing state of the reserve\\n   * @param self The reserve configuration\\n   * @return The borrowing state\\n   **/\\n  function getBorrowingEnabled(DataTypes.ReserveConfigurationMap storage self) internal view returns (bool) {\\n    return (self.data & ~BORROWING_MASK) != 0;\\n  }\\n\\n  /**\\n   * @dev Enables or disables stable rate borrowing on the reserve\\n   * @param self The reserve configuration\\n   * @param enabled True if the stable rate borrowing needs to be enabled, false otherwise\\n   **/\\n  function setStableRateBorrowingEnabled(DataTypes.ReserveConfigurationMap memory self, bool enabled) internal pure {\\n    self.data =\\n      (self.data & STABLE_BORROWING_MASK) |\\n      (uint256(enabled ? 1 : 0) << STABLE_BORROWING_ENABLED_START_BIT_POSITION);\\n  }\\n\\n  /**\\n   * @dev Gets the stable rate borrowing state of the reserve\\n   * @param self The reserve configuration\\n   * @return The stable rate borrowing state\\n   **/\\n  function getStableRateBorrowingEnabled(DataTypes.ReserveConfigurationMap storage self) internal view returns (bool) {\\n    return (self.data & ~STABLE_BORROWING_MASK) != 0;\\n  }\\n\\n  /**\\n   * @dev Sets the reserve factor of the reserve\\n   * @param self The reserve configuration\\n   * @param reserveFactor The reserve factor\\n   **/\\n  function setReserveFactor(DataTypes.ReserveConfigurationMap memory self, uint256 reserveFactor) internal pure {\\n    require(reserveFactor <= MAX_VALID_RESERVE_FACTOR, Errors.RC_INVALID_RESERVE_FACTOR);\\n\\n    self.data = (self.data & RESERVE_FACTOR_MASK) | (reserveFactor << RESERVE_FACTOR_START_BIT_POSITION);\\n  }\\n\\n  /**\\n   * @dev Gets the reserve factor of the reserve\\n   * @param self The reserve configuration\\n   * @return The reserve factor\\n   **/\\n  function getReserveFactor(DataTypes.ReserveConfigurationMap storage self) internal view returns (uint256) {\\n    return (self.data & ~RESERVE_FACTOR_MASK) >> RESERVE_FACTOR_START_BIT_POSITION;\\n  }\\n\\n  /**\\n   * @dev Gets the configuration flags of the reserve\\n   * @param self The reserve configuration\\n   * @return The state flags representing active, frozen, borrowing enabled, stableRateBorrowing enabled\\n   **/\\n  function getFlags(DataTypes.ReserveConfigurationMap storage self)\\n    internal\\n    view\\n    returns (\\n      bool,\\n      bool,\\n      bool,\\n      bool\\n    )\\n  {\\n    uint256 dataLocal = self.data;\\n\\n    return (\\n      (dataLocal & ~ACTIVE_MASK) != 0,\\n      (dataLocal & ~FROZEN_MASK) != 0,\\n      (dataLocal & ~BORROWING_MASK) != 0,\\n      (dataLocal & ~STABLE_BORROWING_MASK) != 0\\n    );\\n  }\\n\\n  /**\\n   * @dev Gets the configuration paramters of the reserve\\n   * @param self The reserve configuration\\n   * @return The state params representing ltv, liquidation threshold, liquidation bonus, the reserve decimals\\n   **/\\n  function getParams(DataTypes.ReserveConfigurationMap storage self)\\n    internal\\n    view\\n    returns (\\n      uint256,\\n      uint256,\\n      uint256,\\n      uint256,\\n      uint256\\n    )\\n  {\\n    uint256 dataLocal = self.data;\\n\\n    return (\\n      dataLocal & ~LTV_MASK,\\n      (dataLocal & ~LIQUIDATION_THRESHOLD_MASK) >> LIQUIDATION_THRESHOLD_START_BIT_POSITION,\\n      (dataLocal & ~LIQUIDATION_BONUS_MASK) >> LIQUIDATION_BONUS_START_BIT_POSITION,\\n      (dataLocal & ~DECIMALS_MASK) >> RESERVE_DECIMALS_START_BIT_POSITION,\\n      (dataLocal & ~RESERVE_FACTOR_MASK) >> RESERVE_FACTOR_START_BIT_POSITION\\n    );\\n  }\\n\\n  /**\\n   * @dev Gets the configuration paramters of the reserve from a memory object\\n   * @param self The reserve configuration\\n   * @return The state params representing ltv, liquidation threshold, liquidation bonus, the reserve decimals\\n   **/\\n  function getParamsMemory(DataTypes.ReserveConfigurationMap memory self)\\n    internal\\n    pure\\n    returns (\\n      uint256,\\n      uint256,\\n      uint256,\\n      uint256,\\n      uint256\\n    )\\n  {\\n    return (\\n      self.data & ~LTV_MASK,\\n      (self.data & ~LIQUIDATION_THRESHOLD_MASK) >> LIQUIDATION_THRESHOLD_START_BIT_POSITION,\\n      (self.data & ~LIQUIDATION_BONUS_MASK) >> LIQUIDATION_BONUS_START_BIT_POSITION,\\n      (self.data & ~DECIMALS_MASK) >> RESERVE_DECIMALS_START_BIT_POSITION,\\n      (self.data & ~RESERVE_FACTOR_MASK) >> RESERVE_FACTOR_START_BIT_POSITION\\n    );\\n  }\\n\\n  /**\\n   * @dev Gets the configuration flags of the reserve from a memory object\\n   * @param self The reserve configuration\\n   * @return The state flags representing active, frozen, borrowing enabled, stableRateBorrowing enabled\\n   **/\\n  function getFlagsMemory(DataTypes.ReserveConfigurationMap memory self)\\n    internal\\n    pure\\n    returns (\\n      bool,\\n      bool,\\n      bool,\\n      bool\\n    )\\n  {\\n    return (\\n      (self.data & ~ACTIVE_MASK) != 0,\\n      (self.data & ~FROZEN_MASK) != 0,\\n      (self.data & ~BORROWING_MASK) != 0,\\n      (self.data & ~STABLE_BORROWING_MASK) != 0\\n    );\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/math/WadRayMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.8.4;\\n\\nimport {Errors} from \\\"../helpers/Errors.sol\\\";\\n\\n/**\\n * @title WadRayMath library\\n * @author MetaFire\\n * @dev Provides mul and div function for wads (decimal numbers with 18 digits precision) and rays (decimals with 27 digits)\\n **/\\n\\nlibrary WadRayMath {\\n  uint256 internal constant WAD = 1e18;\\n  uint256 internal constant HALF_WAD = WAD / 2;\\n\\n  uint256 internal constant RAY = 1e27;\\n  uint256 internal constant HALF_RAY = RAY / 2;\\n\\n  uint256 internal constant WAD_RAY_RATIO = 1e9;\\n\\n  /**\\n   * @return One ray, 1e27\\n   **/\\n  function ray() internal pure returns (uint256) {\\n    return RAY;\\n  }\\n\\n  /**\\n   * @return One wad, 1e18\\n   **/\\n\\n  function wad() internal pure returns (uint256) {\\n    return WAD;\\n  }\\n\\n  /**\\n   * @return Half ray, 1e27/2\\n   **/\\n  function halfRay() internal pure returns (uint256) {\\n    return HALF_RAY;\\n  }\\n\\n  /**\\n   * @return Half ray, 1e18/2\\n   **/\\n  function halfWad() internal pure returns (uint256) {\\n    return HALF_WAD;\\n  }\\n\\n  /**\\n   * @dev Multiplies two wad, rounding half up to the nearest wad\\n   * @param a Wad\\n   * @param b Wad\\n   * @return The result of a*b, in wad\\n   **/\\n  function wadMul(uint256 a, uint256 b) internal pure returns (uint256) {\\n    if (a == 0 || b == 0) {\\n      return 0;\\n    }\\n\\n    require(a <= (type(uint256).max - HALF_WAD) / b, Errors.MATH_MULTIPLICATION_OVERFLOW);\\n\\n    return (a * b + HALF_WAD) / WAD;\\n  }\\n\\n  /**\\n   * @dev Divides two wad, rounding half up to the nearest wad\\n   * @param a Wad\\n   * @param b Wad\\n   * @return The result of a/b, in wad\\n   **/\\n  function wadDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n    require(b != 0, Errors.MATH_DIVISION_BY_ZERO);\\n    uint256 halfB = b / 2;\\n\\n    require(a <= (type(uint256).max - halfB) / WAD, Errors.MATH_MULTIPLICATION_OVERFLOW);\\n\\n    return (a * WAD + halfB) / b;\\n  }\\n\\n  /**\\n   * @dev Multiplies two ray, rounding half up to the nearest ray\\n   * @param a Ray\\n   * @param b Ray\\n   * @return The result of a*b, in ray\\n   **/\\n  function rayMul(uint256 a, uint256 b) internal pure returns (uint256) {\\n    if (a == 0 || b == 0) {\\n      return 0;\\n    }\\n\\n    require(a <= (type(uint256).max - HALF_RAY) / b, Errors.MATH_MULTIPLICATION_OVERFLOW);\\n\\n    return (a * b + HALF_RAY) / RAY;\\n  }\\n\\n  /**\\n   * @dev Divides two ray, rounding half up to the nearest ray\\n   * @param a Ray\\n   * @param b Ray\\n   * @return The result of a/b, in ray\\n   **/\\n  function rayDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n    require(b != 0, Errors.MATH_DIVISION_BY_ZERO);\\n    uint256 halfB = b / 2;\\n\\n    require(a <= (type(uint256).max - halfB) / RAY, Errors.MATH_MULTIPLICATION_OVERFLOW);\\n\\n    return (a * RAY + halfB) / b;\\n  }\\n\\n  /**\\n   * @dev Casts ray down to wad\\n   * @param a Ray\\n   * @return a casted to wad, rounded half up to the nearest wad\\n   **/\\n  function rayToWad(uint256 a) internal pure returns (uint256) {\\n    uint256 halfRatio = WAD_RAY_RATIO / 2;\\n    uint256 result = halfRatio + a;\\n    require(result >= halfRatio, Errors.MATH_ADDITION_OVERFLOW);\\n\\n    return result / WAD_RAY_RATIO;\\n  }\\n\\n  /**\\n   * @dev Converts wad up to ray\\n   * @param a Wad\\n   * @return a converted in ray\\n   **/\\n  function wadToRay(uint256 a) internal pure returns (uint256) {\\n    uint256 result = a * WAD_RAY_RATIO;\\n    require(result / WAD_RAY_RATIO == a, Errors.MATH_MULTIPLICATION_OVERFLOW);\\n    return result;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/math/PercentageMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.8.4;\\n\\nimport {Errors} from \\\"../helpers/Errors.sol\\\";\\n\\n/**\\n * @title PercentageMath library\\n * @author MetaFire\\n * @notice Provides functions to perform percentage calculations\\n * @dev Percentages are defined by default with 2 decimals of precision (100.00). The precision is indicated by PERCENTAGE_FACTOR\\n * @dev Operations are rounded half up\\n **/\\n\\nlibrary PercentageMath {\\n  uint256 constant PERCENTAGE_FACTOR = 1e4; //percentage plus two decimals\\n  uint256 constant HALF_PERCENT = PERCENTAGE_FACTOR / 2;\\n  uint256 constant ONE_PERCENT = 1e2; //100, 1%\\n  uint256 constant TEN_PERCENT = 1e3; //1000, 10%\\n  uint256 constant ONE_THOUSANDTH_PERCENT = 1e1; //10, 0.1%\\n  uint256 constant ONE_TEN_THOUSANDTH_PERCENT = 1; //1, 0.01%\\n\\n  /**\\n   * @dev Executes a percentage multiplication\\n   * @param value The value of which the percentage needs to be calculated\\n   * @param percentage The percentage of the value to be calculated\\n   * @return The percentage of value\\n   **/\\n  function percentMul(uint256 value, uint256 percentage) internal pure returns (uint256) {\\n    if (value == 0 || percentage == 0) {\\n      return 0;\\n    }\\n\\n    require(value <= (type(uint256).max - HALF_PERCENT) / percentage, Errors.MATH_MULTIPLICATION_OVERFLOW);\\n\\n    return (value * percentage + HALF_PERCENT) / PERCENTAGE_FACTOR;\\n  }\\n\\n  /**\\n   * @dev Executes a percentage division\\n   * @param value The value of which the percentage needs to be calculated\\n   * @param percentage The percentage of the value to be calculated\\n   * @return The value divided the percentage\\n   **/\\n  function percentDiv(uint256 value, uint256 percentage) internal pure returns (uint256) {\\n    require(percentage != 0, Errors.MATH_DIVISION_BY_ZERO);\\n    uint256 halfPercentage = percentage / 2;\\n\\n    require(value <= (type(uint256).max - halfPercentage) / PERCENTAGE_FACTOR, Errors.MATH_MULTIPLICATION_OVERFLOW);\\n\\n    return (value * PERCENTAGE_FACTOR + halfPercentage) / percentage;\\n  }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-IERC20PermitUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20PermitUpgradeable {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ILendPoolLoan.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.8.4;\\n\\nimport {DataTypes} from \\\"../libraries/types/DataTypes.sol\\\";\\n\\ninterface ILendPoolLoan {\\n  /**\\n   * @dev Emitted on initialization to share location of dependent notes\\n   * @param pool The address of the associated lend pool\\n   */\\n  event Initialized(address indexed pool);\\n\\n  /**\\n   * @dev Emitted when a loan is created\\n   * @param user The address initiating the action\\n   */\\n  event LoanCreated(\\n    address indexed user,\\n    address indexed onBehalfOf,\\n    uint256 indexed loanId,\\n    address nftAsset,\\n    uint256 nftTokenId,\\n    address reserveAsset,\\n    uint256 amount,\\n    uint256 borrowIndex\\n  );\\n\\n  /**\\n   * @dev Emitted when a loan is updated\\n   * @param user The address initiating the action\\n   */\\n  event LoanUpdated(\\n    address indexed user,\\n    uint256 indexed loanId,\\n    address nftAsset,\\n    uint256 nftTokenId,\\n    address reserveAsset,\\n    uint256 amountAdded,\\n    uint256 amountTaken,\\n    uint256 borrowIndex\\n  );\\n\\n  /**\\n   * @dev Emitted when a loan is repaid by the borrower\\n   * @param user The address initiating the action\\n   */\\n  event LoanRepaid(\\n    address indexed user,\\n    uint256 indexed loanId,\\n    address nftAsset,\\n    uint256 nftTokenId,\\n    address reserveAsset,\\n    uint256 amount,\\n    uint256 borrowIndex\\n  );\\n\\n  /**\\n   * @dev Emitted when a loan is auction by the liquidator\\n   * @param user The address initiating the action\\n   */\\n  event LoanAuctioned(\\n    address indexed user,\\n    uint256 indexed loanId,\\n    address nftAsset,\\n    uint256 nftTokenId,\\n    uint256 amount,\\n    uint256 borrowIndex,\\n    address bidder,\\n    uint256 price,\\n    address previousBidder,\\n    uint256 previousPrice\\n  );\\n\\n  /**\\n   * @dev Emitted when a loan is liquidating bought by the liquidator\\n   * @param user The address initiating the action\\n   */\\n  event LoanLiquidatingBought(\\n    address indexed user,\\n    uint256 indexed loanId,\\n    address nftAsset,\\n    uint256 nftTokenId,\\n    uint256 amount,\\n    uint256 borrowIndex,\\n    address buyer,\\n    uint256 price\\n  );\\n\\n  /**\\n   * @dev Emitted when a loan is redeemed\\n   * @param user The address initiating the action\\n   */\\n  event LoanRedeemed(\\n    address indexed user,\\n    uint256 indexed loanId,\\n    address nftAsset,\\n    uint256 nftTokenId,\\n    address reserveAsset,\\n    uint256 amountTaken,\\n    uint256 borrowIndex\\n  );\\n\\n  /**\\n   * @dev Emitted when a loan is liquidate by the liquidator\\n   * @param user The address initiating the action\\n   */\\n  event LoanLiquidated(\\n    address indexed user,\\n    uint256 indexed loanId,\\n    address nftAsset,\\n    uint256 nftTokenId,\\n    address reserveAsset,\\n    uint256 amount,\\n    uint256 borrowIndex\\n  );\\n\\n  event LoanRepaidInterceptorUpdated(address nftAsset, uint256 tokenId, address indexed interceptor, bool approved);\\n\\n  function initNft(address nftAsset, address bNftAddress) external;\\n\\n  /**\\n   * @dev Create store a loan object with some params\\n   * @param initiator The address of the user initiating the borrow\\n   * @param onBehalfOf The address receiving the loan\\n   */\\n  function createLoan(\\n    address initiator,\\n    address onBehalfOf,\\n    address nftAsset,\\n    uint256 nftTokenId,\\n    address bNftAddress,\\n    address reserveAsset,\\n    uint256 amount,\\n    uint256 borrowIndex\\n  ) external returns (uint256);\\n\\n  /**\\n   * @dev Update the given loan with some params\\n   *\\n   * Requirements:\\n   *  - The caller must be a holder of the loan\\n   *  - The loan must be in state Active\\n   * @param initiator The address of the user initiating the borrow\\n   */\\n  function updateLoan(\\n    address initiator,\\n    uint256 loanId,\\n    uint256 amountAdded,\\n    uint256 amountTaken,\\n    uint256 borrowIndex\\n  ) external;\\n\\n  /**\\n   * @dev Repay the given loan\\n   *\\n   * Requirements:\\n   *  - The caller must be a holder of the loan\\n   *  - The caller must send in principal + interest\\n   *  - The loan must be in state Active\\n   *\\n   * @param initiator The address of the user initiating the repay\\n   * @param loanId The loan getting burned\\n   * @param bNftAddress The address of bNFT\\n   */\\n  function repayLoan(\\n    address initiator,\\n    uint256 loanId,\\n    address bNftAddress,\\n    uint256 amount,\\n    uint256 borrowIndex\\n  ) external;\\n\\n  /**\\n   * @dev Auction the given loan\\n   *\\n   * Requirements:\\n   *  - The price must be greater than current highest price\\n   *  - The loan must be in state Active or Auction\\n   *\\n   * @param initiator The address of the user initiating the auction\\n   * @param loanId The loan getting auctioned\\n   * @param bidPrice The bid price of this auction\\n   */\\n  function auctionLoan(\\n    address initiator,\\n    uint256 loanId,\\n    address onBehalfOf,\\n    uint256 bidPrice,\\n    uint256 borrowAmount,\\n    uint256 borrowIndex\\n  ) external;\\n\\n  /**\\n   * @dev Redeem the given loan with some params\\n   *\\n   * Requirements:\\n   *  - The caller must be a holder of the loan\\n   *  - The loan must be in state Auction\\n   * @param initiator The address of the user initiating the borrow\\n   */\\n  function redeemLoan(\\n    address initiator,\\n    uint256 loanId,\\n    uint256 amountTaken,\\n    uint256 borrowIndex\\n  ) external;\\n\\n  /**\\n   * @dev Liquidate the given loan\\n   *\\n   * Requirements:\\n   *  - The caller must send in principal + interest\\n   *  - The loan must be in state Active\\n   *\\n   * @param initiator The address of the user initiating the auction\\n   * @param loanId The loan getting burned\\n   * @param bNftAddress The address of bNFT\\n   */\\n  function liquidateLoan(\\n    address initiator,\\n    uint256 loanId,\\n    address bNftAddress,\\n    uint256 borrowAmount,\\n    uint256 borrowIndex\\n  ) external;\\n\\n\\n  /**\\n   * @dev Liquidating buy the given loan\\n   * @param initiator The address of the user initiating the auction\\n   * @param loanId The loan getting burned\\n   * @param bNftAddress The address of bNFT\\n   * @param onBehalfOf The address receiving the loan\\n   * @param bidPrice The bid price of this auction\\n   * @param borrowAmount The borrow amount of this auction\\n   * @param borrowIndex The borrow index of this auction\\n   */\\n  function liquidatingBuyLoan(\\n    address initiator,\\n    uint256 loanId,\\n    address bNftAddress,\\n    address onBehalfOf,\\n    uint256 bidPrice,\\n    uint256 borrowAmount,\\n    uint256 borrowIndex\\n  ) external;\\n\\n  /**\\n   * @dev Add or remove the interceptor from the whitelist\\n   * @param interceptor The address of the interceptor contract\\n   * @param approved add or remove\\n   */\\n  function approveLoanRepaidInterceptor(address interceptor, bool approved) external;\\n\\n  function isLoanRepaidInterceptorApproved(address interceptor) external view returns (bool);\\n\\n  function purgeLoanRepaidInterceptor(\\n    address nftAddress,\\n    uint256[] calldata tokenIds,\\n    address interceptor\\n  ) external;\\n\\n  function addLoanRepaidInterceptor(address nftAsset, uint256 tokenId) external;\\n\\n  function deleteLoanRepaidInterceptor(address nftAsset, uint256 tokenId) external;\\n\\n  function getLoanRepaidInterceptors(address nftAsset, uint256 tokenId) external view returns (address[] memory);\\n\\n  /**\\n   * @dev Add or remove the locker from the whitelist\\n   * @param locker The address of the locker contract\\n   * @param approved add or remove\\n   */\\n  function approveFlashLoanLocker(address locker, bool approved) external;\\n\\n  function isFlashLoanLockerApproved(address locker) external view returns (bool);\\n\\n  /**\\n   * @dev Lock or unlock the flash loan caller\\n   * @param nftAsset The address of the NFT asset\\n   * @param tokenId The id of the NFT token\\n   * @param locked lock or unlock\\n   */\\n  function setFlashLoanLocking(\\n    address nftAsset,\\n    uint256 tokenId,\\n    bool locked\\n  ) external;\\n\\n  function purgeFlashLoanLocking(\\n    address nftAsset,\\n    uint256[] calldata tokenIds,\\n    address locker\\n  ) external;\\n\\n  function borrowerOf(uint256 loanId) external view returns (address);\\n\\n  function getCollateralLoanId(address nftAsset, uint256 nftTokenId) external view returns (uint256);\\n\\n  function getLoan(uint256 loanId) external view returns (DataTypes.LoanData memory loanData);\\n\\n  function getLoanCollateralAndReserve(uint256 loanId)\\n    external\\n    view\\n    returns (\\n      address nftAsset,\\n      uint256 nftTokenId,\\n      address reserveAsset,\\n      uint256 scaledAmount\\n    );\\n\\n  function getLoanReserveBorrowScaledAmount(uint256 loanId) external view returns (address, uint256);\\n\\n  function getLoanReserveBorrowAmount(uint256 loanId) external view returns (address, uint256);\\n\\n  function getLoanHighestBid(uint256 loanId) external view returns (address, uint256);\\n\\n  function getNftCollateralAmount(address nftAsset) external view returns (uint256);\\n\\n  function getUserNftCollateralAmount(address user, address nftAsset) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/logic/GenericLogic.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.8.4;\\n\\nimport {ILendPoolLoan} from \\\"../../interfaces/ILendPoolLoan.sol\\\";\\nimport {IReserveOracleGetter} from \\\"../../interfaces/IReserveOracleGetter.sol\\\";\\nimport {INFTOracleGetter} from \\\"../../interfaces/INFTOracleGetter.sol\\\";\\nimport {WadRayMath} from \\\"../math/WadRayMath.sol\\\";\\nimport {PercentageMath} from \\\"../math/PercentageMath.sol\\\";\\nimport {ReserveConfiguration} from \\\"../configuration/ReserveConfiguration.sol\\\";\\nimport {NftConfiguration} from \\\"../configuration/NftConfiguration.sol\\\";\\nimport {Errors} from \\\"../helpers/Errors.sol\\\";\\nimport {DataTypes} from \\\"../types/DataTypes.sol\\\";\\nimport {ReserveLogic} from \\\"./ReserveLogic.sol\\\";\\n\\n/**\\n * @title GenericLogic library\\n * @author MetaFire\\n * @notice Implements protocol-level logic to calculate and validate the state of a user\\n */\\nlibrary GenericLogic {\\n  using ReserveLogic for DataTypes.ReserveData;\\n  using WadRayMath for uint256;\\n  using PercentageMath for uint256;\\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\\n  using NftConfiguration for DataTypes.NftConfigurationMap;\\n\\n  uint256 public constant HEALTH_FACTOR_LIQUIDATION_THRESHOLD = 1 ether;\\n\\n  struct CalculateLoanDataVars {\\n    uint256 reserveUnitPrice;\\n    uint256 reserveUnit;\\n    uint256 reserveDecimals;\\n    uint256 healthFactor;\\n    uint256 totalCollateralInETH;\\n    uint256 totalCollateralInReserve;\\n    uint256 totalDebtInETH;\\n    uint256 totalDebtInReserve;\\n    uint256 nftLtv;\\n    uint256 nftLiquidationThreshold;\\n    address nftAsset;\\n    uint256 nftTokenId;\\n    uint256 nftUnitPrice;\\n  }\\n\\n  /**\\n   * @dev Calculates the nft loan data.\\n   * this includes the total collateral/borrow balances in Reserve,\\n   * the Loan To Value, the Liquidation Ratio, and the Health factor.\\n   * @param reserveData Data of the reserve\\n   * @param nftData Data of the nft\\n   * @param reserveOracle The price oracle address of reserve\\n   * @param nftOracle The price oracle address of nft\\n   * @return The total collateral and total debt of the loan in Reserve, the ltv, liquidation threshold and the HF\\n   **/\\n  function calculateLoanData(\\n    address reserveAddress,\\n    DataTypes.ReserveData storage reserveData,\\n    address nftAddress,\\n    DataTypes.NftData storage nftData,\\n    address loanAddress,\\n    uint256 loanId,\\n    address reserveOracle,\\n    address nftOracle\\n  )\\n    internal\\n    view\\n    returns (\\n      uint256,\\n      uint256,\\n      uint256\\n    )\\n  {\\n    CalculateLoanDataVars memory vars;\\n\\n    (vars.nftLtv, vars.nftLiquidationThreshold, ) = nftData.configuration.getCollateralParams();\\n\\n    // calculate total borrow balance for the loan\\n    if (loanId != 0) {\\n      (vars.totalDebtInETH, vars.totalDebtInReserve) = calculateNftDebtData(\\n        reserveAddress,\\n        reserveData,\\n        loanAddress,\\n        loanId,\\n        reserveOracle\\n      );\\n    }\\n\\n    // calculate total collateral balance for the nft\\n    (vars.totalCollateralInETH, vars.totalCollateralInReserve) = calculateNftCollateralData(\\n      reserveAddress,\\n      reserveData,\\n      nftAddress,\\n      nftData,\\n      reserveOracle,\\n      nftOracle\\n    );\\n\\n    // calculate health by borrow and collateral\\n    vars.healthFactor = calculateHealthFactorFromBalances(\\n      vars.totalCollateralInReserve,\\n      vars.totalDebtInReserve,\\n      vars.nftLiquidationThreshold\\n    );\\n\\n    return (vars.totalCollateralInReserve, vars.totalDebtInReserve, vars.healthFactor);\\n  }\\n\\n  function calculateNftDebtData(\\n    address reserveAddress,\\n    DataTypes.ReserveData storage reserveData,\\n    address loanAddress,\\n    uint256 loanId,\\n    address reserveOracle\\n  ) internal view returns (uint256, uint256) {\\n    CalculateLoanDataVars memory vars;\\n\\n    // all asset price has converted to ETH based, unit is in WEI (18 decimals)\\n\\n    vars.reserveDecimals = reserveData.configuration.getDecimals();\\n    vars.reserveUnit = 10**vars.reserveDecimals;\\n\\n    vars.reserveUnitPrice = IReserveOracleGetter(reserveOracle).getAssetPrice(reserveAddress);\\n\\n    (, vars.totalDebtInReserve) = ILendPoolLoan(loanAddress).getLoanReserveBorrowAmount(loanId);\\n    vars.totalDebtInETH = (vars.totalDebtInReserve * vars.reserveUnitPrice) / vars.reserveUnit;\\n\\n    return (vars.totalDebtInETH, vars.totalDebtInReserve);\\n  }\\n\\n  function calculateNftCollateralData(\\n    address reserveAddress,\\n    DataTypes.ReserveData storage reserveData,\\n    address nftAddress,\\n    DataTypes.NftData storage nftData,\\n    address reserveOracle,\\n    address nftOracle\\n  ) internal view returns (uint256, uint256) {\\n    reserveData;\\n    nftData;\\n\\n    CalculateLoanDataVars memory vars;\\n\\n    // calculate total collateral balance for the nft\\n    // all asset price has converted to ETH based, unit is in WEI (18 decimals)\\n\\n    vars.nftUnitPrice = INFTOracleGetter(nftOracle).getAssetPrice(nftAddress);\\n    vars.totalCollateralInETH = vars.nftUnitPrice;\\n\\n    if (reserveAddress != address(0)) {\\n      vars.reserveDecimals = reserveData.configuration.getDecimals();\\n      vars.reserveUnit = 10**vars.reserveDecimals;\\n\\n      vars.reserveUnitPrice = IReserveOracleGetter(reserveOracle).getAssetPrice(reserveAddress);\\n\\n      vars.totalCollateralInReserve = (vars.totalCollateralInETH * vars.reserveUnit) / vars.reserveUnitPrice;\\n    }\\n\\n    return (vars.totalCollateralInETH, vars.totalCollateralInReserve);\\n  }\\n\\n  /**\\n   * @dev Calculates the health factor from the corresponding balances\\n   * @param totalCollateral The total collateral\\n   * @param totalDebt The total debt\\n   * @param liquidationThreshold The avg liquidation threshold\\n   * @return The health factor calculated from the balances provided\\n   **/\\n  function calculateHealthFactorFromBalances(\\n    uint256 totalCollateral,\\n    uint256 totalDebt,\\n    uint256 liquidationThreshold\\n  ) internal pure returns (uint256) {\\n    if (totalDebt == 0) return type(uint256).max;\\n\\n    return (totalCollateral.percentMul(liquidationThreshold)).wadDiv(totalDebt);\\n  }\\n\\n  /**\\n   * @dev Calculates the equivalent amount that an user can borrow, depending on the available collateral and the\\n   * average Loan To Value\\n   * @param totalCollateral The total collateral\\n   * @param totalDebt The total borrow balance\\n   * @param ltv The average loan to value\\n   * @return the amount available to borrow for the user\\n   **/\\n\\n  function calculateAvailableBorrows(\\n    uint256 totalCollateral,\\n    uint256 totalDebt,\\n    uint256 ltv\\n  ) internal pure returns (uint256) {\\n    uint256 availableBorrows = totalCollateral.percentMul(ltv);\\n\\n    if (availableBorrows < totalDebt) {\\n      return 0;\\n    }\\n\\n    availableBorrows = availableBorrows - totalDebt;\\n    return availableBorrows;\\n  }\\n\\n  struct CalcLiquidatePriceLocalVars {\\n    uint256 ltv;\\n    uint256 liquidationThreshold;\\n    uint256 liquidationBonus;\\n    uint256 nftPriceInETH;\\n    uint256 nftPriceInReserve;\\n    uint256 reserveDecimals;\\n    uint256 reservePriceInETH;\\n    uint256 thresholdPrice;\\n    uint256 liquidatePrice;\\n    uint256 borrowAmount;\\n  }\\n\\n  function calculateLoanLiquidatePrice(\\n    uint256 loanId,\\n    address reserveAsset,\\n    DataTypes.ReserveData storage reserveData,\\n    address nftAsset,\\n    DataTypes.NftData storage nftData,\\n    address poolLoan,\\n    address reserveOracle,\\n    address nftOracle\\n  )\\n    internal\\n    view\\n    returns (\\n      uint256,\\n      uint256,\\n      uint256\\n    )\\n  {\\n    CalcLiquidatePriceLocalVars memory vars;\\n\\n    /*\\n     * 0                   CR                  LH                  100\\n     * |___________________|___________________|___________________|\\n     *  <       Borrowing with Interest        <\\n     * CR: Callteral Ratio;\\n     * LH: Liquidate Threshold;\\n     * Liquidate Trigger: Borrowing with Interest > thresholdPrice;\\n     * Liquidate Price: (100% - BonusRatio) * NFT Price;\\n     */\\n\\n    vars.reserveDecimals = reserveData.configuration.getDecimals();\\n\\n    (, vars.borrowAmount) = ILendPoolLoan(poolLoan).getLoanReserveBorrowAmount(loanId);\\n\\n    (vars.ltv, vars.liquidationThreshold, vars.liquidationBonus) = nftData.configuration.getCollateralParams();\\n\\n    vars.nftPriceInETH = INFTOracleGetter(nftOracle).getAssetPrice(nftAsset);\\n    vars.reservePriceInETH = IReserveOracleGetter(reserveOracle).getAssetPrice(reserveAsset);\\n\\n    vars.nftPriceInReserve = ((10**vars.reserveDecimals) * vars.nftPriceInETH) / vars.reservePriceInETH;\\n\\n    vars.thresholdPrice = vars.nftPriceInReserve.percentMul(vars.liquidationThreshold);\\n\\n    if (vars.liquidationBonus < PercentageMath.PERCENTAGE_FACTOR) {\\n      vars.liquidatePrice = vars.nftPriceInReserve.percentMul(PercentageMath.PERCENTAGE_FACTOR - vars.liquidationBonus);\\n    }\\n\\n    if (vars.liquidatePrice < vars.borrowAmount) {\\n      vars.liquidatePrice = vars.borrowAmount;\\n    }\\n\\n    return (vars.borrowAmount, vars.thresholdPrice, vars.liquidatePrice);\\n  }\\n  \\n  struct CalcLiquidatingBuyPriceLocalVars {\\n    uint256 ltv;\\n    uint256 liquidationThreshold;\\n    uint256 liquidatingBuyBonus;\\n    uint256 nftPriceInETH;\\n    uint256 nftPriceInReserve;\\n    uint256 reserveDecimals;\\n    uint256 reservePriceInETH;\\n    uint256 thresholdPrice;\\n    uint256 liquidatingBuyPrice;\\n    uint256 borrowAmount;\\n  }\\n\\n  //TODO: finish this function\\n  function calculateLoanLiquidatingBuyPrice(\\n    uint256 loanId,\\n    address reserveAsset,\\n    DataTypes.ReserveData storage reserveData,\\n    address nftAsset,\\n    DataTypes.NftData storage nftData,\\n    address poolLoan,\\n    address reserveOracle,\\n    address nftOracle\\n  )\\n    internal\\n    view\\n    returns (\\n      uint256,\\n      uint256,\\n      uint256\\n    )\\n  {\\n    CalcLiquidatingBuyPriceLocalVars memory vars;\\n\\n    /*\\n     * 0                   CR                  LH                  100\\n     * |___________________|___________________|___________________|\\n     *  <       Borrowing with Interest        <\\n     * CR: Callteral Ratio;\\n     * LH: Liquidate Threshold;\\n     * Liquidate Trigger: Borrowing with Interest > thresholdPrice;\\n     * Liquidate Price: (100% - BonusRatio) * NFT Price;\\n     */\\n\\n    vars.reserveDecimals = reserveData.configuration.getDecimals();\\n\\n    (, vars.borrowAmount) = ILendPoolLoan(poolLoan).getLoanReserveBorrowAmount(loanId);\\n     \\n    (vars.ltv, vars.liquidationThreshold, ) = nftData.configuration.getCollateralParams();\\n    vars.liquidatingBuyBonus = nftData.configuration.getLiquidatingBuyBonus();\\n\\n    vars.nftPriceInETH = INFTOracleGetter(nftOracle).getAssetPrice(nftAsset);\\n    vars.reservePriceInETH = IReserveOracleGetter(reserveOracle).getAssetPrice(reserveAsset);\\n\\n    vars.nftPriceInReserve = ((10**vars.reserveDecimals) * vars.nftPriceInETH) / vars.reservePriceInETH;\\n\\n    vars.thresholdPrice = vars.nftPriceInReserve.percentMul(vars.liquidationThreshold);\\n\\n    if (vars.liquidatingBuyBonus < PercentageMath.PERCENTAGE_FACTOR) {\\n      vars.liquidatingBuyPrice = vars.nftPriceInReserve.percentMul(PercentageMath.PERCENTAGE_FACTOR - vars.liquidatingBuyBonus);\\n    }\\n\\n    if (vars.liquidatingBuyPrice < vars.borrowAmount) {\\n      vars.liquidatingBuyPrice = vars.borrowAmount;\\n    }\\n\\n    return (vars.borrowAmount, vars.thresholdPrice, vars.liquidatingBuyPrice);\\n\\n  }\\n\\n  struct CalcLoanBidFineLocalVars {\\n    uint256 reserveDecimals;\\n    uint256 reservePriceInETH;\\n    uint256 baseBidFineInReserve;\\n    uint256 minBidFinePct;\\n    uint256 minBidFineInReserve;\\n    uint256 bidFineInReserve;\\n    uint256 debtAmount;\\n  }\\n\\n  function calculateLoanBidFine(\\n    address reserveAsset,\\n    DataTypes.ReserveData storage reserveData,\\n    address nftAsset,\\n    DataTypes.NftData storage nftData,\\n    DataTypes.LoanData memory loanData,\\n    address poolLoan,\\n    address reserveOracle\\n  ) internal view returns (uint256, uint256) {\\n    nftAsset;\\n\\n    if (loanData.bidPrice == 0) {\\n      return (0, 0);\\n    }\\n\\n    CalcLoanBidFineLocalVars memory vars;\\n\\n    vars.reserveDecimals = reserveData.configuration.getDecimals();\\n    vars.reservePriceInETH = IReserveOracleGetter(reserveOracle).getAssetPrice(reserveAsset);\\n    vars.baseBidFineInReserve = (1 ether * 10**vars.reserveDecimals) / vars.reservePriceInETH;\\n\\n    vars.minBidFinePct = nftData.configuration.getMinBidFine();\\n    vars.minBidFineInReserve = vars.baseBidFineInReserve.percentMul(vars.minBidFinePct);\\n\\n    (, vars.debtAmount) = ILendPoolLoan(poolLoan).getLoanReserveBorrowAmount(loanData.loanId);\\n\\n    vars.bidFineInReserve = vars.debtAmount.percentMul(nftData.configuration.getRedeemFine());\\n    if (vars.bidFineInReserve < vars.minBidFineInReserve) {\\n      vars.bidFineInReserve = vars.minBidFineInReserve;\\n    }\\n\\n    return (vars.minBidFineInReserve, vars.bidFineInReserve);\\n  }\\n\\n  function calculateLoanAuctionEndTimestamp(\\n    DataTypes.NftData storage nftData,\\n    DataTypes.LoanData memory loanData,\\n    uint256 pauseStartTime,\\n    uint256 pauseDurationTime\\n  ) internal view returns (uint256 auctionEndTimestamp, uint256 redeemEndTimestamp) {\\n    uint256 extraDuration = 0;\\n\\n    if ((pauseDurationTime > 0) && (loanData.bidStartTimestamp <= pauseStartTime)) {\\n      extraDuration = pauseDurationTime;\\n    }\\n\\n    auctionEndTimestamp =\\n      loanData.bidStartTimestamp +\\n      extraDuration +\\n      (nftData.configuration.getAuctionDuration() * 1 hours);\\n\\n    redeemEndTimestamp =\\n      loanData.bidStartTimestamp +\\n      extraDuration +\\n      (nftData.configuration.getRedeemDuration() * 1 hours);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/configuration/NftConfiguration.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.8.4;\\n\\nimport {Errors} from \\\"../helpers/Errors.sol\\\";\\nimport {DataTypes} from \\\"../types/DataTypes.sol\\\";\\n\\n/**\\n * @title NftConfiguration library\\n * @author MetaFire\\n * @notice Implements the bitmap logic to handle the NFT configuration\\n */\\nlibrary NftConfiguration {\\n  uint256 constant LTV_MASK =                   0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000; // prettier-ignore\\n  uint256 constant LIQUIDATION_THRESHOLD_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFF; // prettier-ignore\\n  uint256 constant LIQUIDATION_BONUS_MASK =     0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFFFFFF; // prettier-ignore\\n  uint256 constant ACTIVE_MASK =                0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFF; // prettier-ignore\\n  uint256 constant FROZEN_MASK =                0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFDFFFFFFFFFFFFFF; // prettier-ignore\\n  uint256 constant REDEEM_DURATION_MASK =       0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00FFFFFFFFFFFFFFFF; // prettier-ignore\\n  uint256 constant AUCTION_DURATION_MASK =      0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00FFFFFFFFFFFFFFFFFF; // prettier-ignore\\n  uint256 constant REDEEM_FINE_MASK =           0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFFFFFFFFFFFFFFFFFF; // prettier-ignore\\n  uint256 constant REDEEM_THRESHOLD_MASK =      0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFFFFFFFFFFFFFFFFFFFFFF; // prettier-ignore\\n  uint256 constant MIN_BIDFINE_MASK      =      0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFFFFFFFFFFFFFFFFFFFFFFFFFF; // prettier-ignore\\n  uint256 constant LIQUIDATING_BUY_BONUS_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFFffffFFFFFFFFFFFFFFFFFFFFFFFF; // prettier-ignore\\n \\n  /// @dev For the LTV, the start bit is 0 (up to 15), hence no bitshifting is needed\\n  uint256 constant LIQUIDATION_THRESHOLD_START_BIT_POSITION = 16;\\n  uint256 constant LIQUIDATION_BONUS_START_BIT_POSITION = 32;\\n  uint256 constant IS_ACTIVE_START_BIT_POSITION = 56;\\n  uint256 constant IS_FROZEN_START_BIT_POSITION = 57;\\n  uint256 constant REDEEM_DURATION_START_BIT_POSITION = 64;\\n  uint256 constant AUCTION_DURATION_START_BIT_POSITION = 72;\\n  uint256 constant REDEEM_FINE_START_BIT_POSITION = 80;\\n  uint256 constant REDEEM_THRESHOLD_START_BIT_POSITION = 96;\\n  uint256 constant MIN_BIDFINE_START_BIT_POSITION = 112;\\n  uint256 constant LIQUIDATING_BUY_BONUS_START_BIT_POSITION = 128;\\n\\n  uint256 constant MAX_VALID_LTV = 65535;\\n  uint256 constant MAX_VALID_LIQUIDATION_THRESHOLD = 65535;\\n  uint256 constant MAX_VALID_LIQUIDATION_BONUS = 65535;\\n  uint256 constant MAX_VALID_REDEEM_DURATION = 255;\\n  uint256 constant MAX_VALID_AUCTION_DURATION = 255;\\n  uint256 constant MAX_VALID_REDEEM_FINE = 65535;\\n  uint256 constant MAX_VALID_REDEEM_THRESHOLD = 65535;\\n  uint256 constant MAX_VALID_MIN_BIDFINE = 65535;\\n  uint256 constant MAX_VALID_LIQUIDATING_BUY_BONUS = 65535;\\n\\n  /**\\n   * @dev Sets the Loan to Value of the NFT\\n   * @param self The NFT configuration\\n   * @param ltv the new ltv\\n   **/\\n  function setLtv(DataTypes.NftConfigurationMap memory self, uint256 ltv) internal pure {\\n    require(ltv <= MAX_VALID_LTV, Errors.RC_INVALID_LTV);\\n\\n    self.data = (self.data & LTV_MASK) | ltv;\\n  }\\n\\n  /**\\n   * @dev Gets the Loan to Value of the NFT\\n   * @param self The NFT configuration\\n   * @return The loan to value\\n   **/\\n  function getLtv(DataTypes.NftConfigurationMap storage self) internal view returns (uint256) {\\n    return self.data & ~LTV_MASK;\\n  }\\n\\n  /**\\n   * @dev Sets the liquidation threshold of the NFT\\n   * @param self The NFT configuration\\n   * @param threshold The new liquidation threshold\\n   **/\\n  function setLiquidationThreshold(DataTypes.NftConfigurationMap memory self, uint256 threshold) internal pure {\\n    require(threshold <= MAX_VALID_LIQUIDATION_THRESHOLD, Errors.RC_INVALID_LIQ_THRESHOLD);\\n\\n    self.data = (self.data & LIQUIDATION_THRESHOLD_MASK) | (threshold << LIQUIDATION_THRESHOLD_START_BIT_POSITION);\\n  }\\n\\n  /**\\n   * @dev Gets the liquidation threshold of the NFT\\n   * @param self The NFT configuration\\n   * @return The liquidation threshold\\n   **/\\n  function getLiquidationThreshold(DataTypes.NftConfigurationMap storage self) internal view returns (uint256) {\\n    return (self.data & ~LIQUIDATION_THRESHOLD_MASK) >> LIQUIDATION_THRESHOLD_START_BIT_POSITION;\\n  }\\n\\n  /**\\n   * @dev Sets the liquidation bonus of the NFT\\n   * @param self The NFT configuration\\n   * @param bonus The new liquidation bonus\\n   **/\\n  function setLiquidationBonus(DataTypes.NftConfigurationMap memory self, uint256 bonus) internal pure {\\n    require(bonus <= MAX_VALID_LIQUIDATION_BONUS, Errors.RC_INVALID_LIQ_BONUS);\\n\\n    self.data = (self.data & LIQUIDATION_BONUS_MASK) | (bonus << LIQUIDATION_BONUS_START_BIT_POSITION);\\n  }\\n\\n  /**\\n   * @dev Gets the liquidation bonus of the NFT\\n   * @param self The NFT configuration\\n   * @return The liquidation bonus\\n   **/\\n  function getLiquidationBonus(DataTypes.NftConfigurationMap storage self) internal view returns (uint256) {\\n    return (self.data & ~LIQUIDATION_BONUS_MASK) >> LIQUIDATION_BONUS_START_BIT_POSITION;\\n  }\\n\\n    /**\\n   * @dev Sets the liquidating buy bonus of the NFT\\n   * @param self The NFT configuration\\n   * @param bonus The new liquidating buy bonus\\n   **/\\n  function setLiquidatingBuyBonus(DataTypes.NftConfigurationMap memory self, uint256 bonus) internal pure {\\n    require(bonus <= MAX_VALID_LIQUIDATING_BUY_BONUS, Errors.RC_INVALID_LIQ_BONUS);\\n\\n    self.data = (self.data & LIQUIDATING_BUY_BONUS_MASK) | (bonus << LIQUIDATING_BUY_BONUS_START_BIT_POSITION);\\n  }\\n\\n  /**\\n   * @dev Gets the liquidating buy bonus of the NFT\\n   * @param self The NFT configuration\\n   * @return The liquidating buy bonus\\n   **/\\n  function getLiquidatingBuyBonus(DataTypes.NftConfigurationMap storage self) internal view returns (uint256) {\\n    return (self.data & ~LIQUIDATING_BUY_BONUS_MASK) >> LIQUIDATING_BUY_BONUS_START_BIT_POSITION;\\n  }\\n\\n  /**\\n   * @dev Sets the active state of the NFT\\n   * @param self The NFT configuration\\n   * @param active The active state\\n   **/\\n  function setActive(DataTypes.NftConfigurationMap memory self, bool active) internal pure {\\n    self.data = (self.data & ACTIVE_MASK) | (uint256(active ? 1 : 0) << IS_ACTIVE_START_BIT_POSITION);\\n  }\\n\\n  /**\\n   * @dev Gets the active state of the NFT\\n   * @param self The NFT configuration\\n   * @return The active state\\n   **/\\n  function getActive(DataTypes.NftConfigurationMap storage self) internal view returns (bool) {\\n    return (self.data & ~ACTIVE_MASK) != 0;\\n  }\\n\\n  /**\\n   * @dev Sets the frozen state of the NFT\\n   * @param self The NFT configuration\\n   * @param frozen The frozen state\\n   **/\\n  function setFrozen(DataTypes.NftConfigurationMap memory self, bool frozen) internal pure {\\n    self.data = (self.data & FROZEN_MASK) | (uint256(frozen ? 1 : 0) << IS_FROZEN_START_BIT_POSITION);\\n  }\\n\\n  /**\\n   * @dev Gets the frozen state of the NFT\\n   * @param self The NFT configuration\\n   * @return The frozen state\\n   **/\\n  function getFrozen(DataTypes.NftConfigurationMap storage self) internal view returns (bool) {\\n    return (self.data & ~FROZEN_MASK) != 0;\\n  }\\n\\n  /**\\n   * @dev Sets the redeem duration of the NFT\\n   * @param self The NFT configuration\\n   * @param redeemDuration The redeem duration\\n   **/\\n  function setRedeemDuration(DataTypes.NftConfigurationMap memory self, uint256 redeemDuration) internal pure {\\n    require(redeemDuration <= MAX_VALID_REDEEM_DURATION, Errors.RC_INVALID_REDEEM_DURATION);\\n\\n    self.data = (self.data & REDEEM_DURATION_MASK) | (redeemDuration << REDEEM_DURATION_START_BIT_POSITION);\\n  }\\n\\n  /**\\n   * @dev Gets the redeem duration of the NFT\\n   * @param self The NFT configuration\\n   * @return The redeem duration\\n   **/\\n  function getRedeemDuration(DataTypes.NftConfigurationMap storage self) internal view returns (uint256) {\\n    return (self.data & ~REDEEM_DURATION_MASK) >> REDEEM_DURATION_START_BIT_POSITION;\\n  }\\n\\n  /**\\n   * @dev Sets the auction duration of the NFT\\n   * @param self The NFT configuration\\n   * @param auctionDuration The auction duration\\n   **/\\n  function setAuctionDuration(DataTypes.NftConfigurationMap memory self, uint256 auctionDuration) internal pure {\\n    require(auctionDuration <= MAX_VALID_AUCTION_DURATION, Errors.RC_INVALID_AUCTION_DURATION);\\n\\n    self.data = (self.data & AUCTION_DURATION_MASK) | (auctionDuration << AUCTION_DURATION_START_BIT_POSITION);\\n  }\\n\\n  /**\\n   * @dev Gets the auction duration of the NFT\\n   * @param self The NFT configuration\\n   * @return The auction duration\\n   **/\\n  function getAuctionDuration(DataTypes.NftConfigurationMap storage self) internal view returns (uint256) {\\n    return (self.data & ~AUCTION_DURATION_MASK) >> AUCTION_DURATION_START_BIT_POSITION;\\n  }\\n\\n  /**\\n   * @dev Sets the redeem fine of the NFT\\n   * @param self The NFT configuration\\n   * @param redeemFine The redeem duration\\n   **/\\n  function setRedeemFine(DataTypes.NftConfigurationMap memory self, uint256 redeemFine) internal pure {\\n    require(redeemFine <= MAX_VALID_REDEEM_FINE, Errors.RC_INVALID_REDEEM_FINE);\\n\\n    self.data = (self.data & REDEEM_FINE_MASK) | (redeemFine << REDEEM_FINE_START_BIT_POSITION);\\n  }\\n\\n  /**\\n   * @dev Gets the redeem fine of the NFT\\n   * @param self The NFT configuration\\n   * @return The redeem fine\\n   **/\\n  function getRedeemFine(DataTypes.NftConfigurationMap storage self) internal view returns (uint256) {\\n    return (self.data & ~REDEEM_FINE_MASK) >> REDEEM_FINE_START_BIT_POSITION;\\n  }\\n\\n  /**\\n   * @dev Sets the redeem threshold of the NFT\\n   * @param self The NFT configuration\\n   * @param redeemThreshold The redeem duration\\n   **/\\n  function setRedeemThreshold(DataTypes.NftConfigurationMap memory self, uint256 redeemThreshold) internal pure {\\n    require(redeemThreshold <= MAX_VALID_REDEEM_THRESHOLD, Errors.RC_INVALID_REDEEM_THRESHOLD);\\n\\n    self.data = (self.data & REDEEM_THRESHOLD_MASK) | (redeemThreshold << REDEEM_THRESHOLD_START_BIT_POSITION);\\n  }\\n\\n  /**\\n   * @dev Gets the redeem threshold of the NFT\\n   * @param self The NFT configuration\\n   * @return The redeem threshold\\n   **/\\n  function getRedeemThreshold(DataTypes.NftConfigurationMap storage self) internal view returns (uint256) {\\n    return (self.data & ~REDEEM_THRESHOLD_MASK) >> REDEEM_THRESHOLD_START_BIT_POSITION;\\n  }\\n\\n  /**\\n   * @dev Sets the min & max threshold of the NFT\\n   * @param self The NFT configuration\\n   * @param minBidFine The min bid fine\\n   **/\\n  function setMinBidFine(DataTypes.NftConfigurationMap memory self, uint256 minBidFine) internal pure {\\n    require(minBidFine <= MAX_VALID_MIN_BIDFINE, Errors.RC_INVALID_MIN_BID_FINE);\\n\\n    self.data = (self.data & MIN_BIDFINE_MASK) | (minBidFine << MIN_BIDFINE_START_BIT_POSITION);\\n  }\\n\\n  /**\\n   * @dev Gets the min bid fine of the NFT\\n   * @param self The NFT configuration\\n   * @return The min bid fine\\n   **/\\n  function getMinBidFine(DataTypes.NftConfigurationMap storage self) internal view returns (uint256) {\\n    return ((self.data & ~MIN_BIDFINE_MASK) >> MIN_BIDFINE_START_BIT_POSITION);\\n  }\\n\\n  /**\\n   * @dev Gets the configuration flags of the NFT\\n   * @param self The NFT configuration\\n   * @return The state flags representing active, frozen\\n   **/\\n  function getFlags(DataTypes.NftConfigurationMap storage self) internal view returns (bool, bool) {\\n    uint256 dataLocal = self.data;\\n\\n    return ((dataLocal & ~ACTIVE_MASK) != 0, (dataLocal & ~FROZEN_MASK) != 0);\\n  }\\n\\n  /**\\n   * @dev Gets the configuration flags of the NFT from a memory object\\n   * @param self The NFT configuration\\n   * @return The state flags representing active, frozen\\n   **/\\n  function getFlagsMemory(DataTypes.NftConfigurationMap memory self) internal pure returns (bool, bool) {\\n    return ((self.data & ~ACTIVE_MASK) != 0, (self.data & ~FROZEN_MASK) != 0);\\n  }\\n\\n  /**\\n   * @dev Gets the collateral configuration paramters of the NFT\\n   * @param self The NFT configuration\\n   * @return The state params representing ltv, liquidation threshold, liquidation bonus\\n   **/\\n  function getCollateralParams(DataTypes.NftConfigurationMap storage self)\\n    internal\\n    view\\n    returns (\\n      uint256,\\n      uint256,\\n      uint256\\n    )\\n  {\\n    uint256 dataLocal = self.data;\\n\\n    return (\\n      dataLocal & ~LTV_MASK,\\n      (dataLocal & ~LIQUIDATION_THRESHOLD_MASK) >> LIQUIDATION_THRESHOLD_START_BIT_POSITION,\\n      (dataLocal & ~LIQUIDATION_BONUS_MASK) >> LIQUIDATION_BONUS_START_BIT_POSITION\\n    );\\n  }\\n\\n  /**\\n   * @dev Gets the auction configuration paramters of the NFT\\n   * @param self The NFT configuration\\n   * @return The state params representing redeem duration, auction duration, redeem fine\\n   **/\\n  function getAuctionParams(DataTypes.NftConfigurationMap storage self)\\n    internal\\n    view\\n    returns (\\n      uint256,\\n      uint256,\\n      uint256,\\n      uint256\\n    )\\n  {\\n    uint256 dataLocal = self.data;\\n\\n    return (\\n      (dataLocal & ~REDEEM_DURATION_MASK) >> REDEEM_DURATION_START_BIT_POSITION,\\n      (dataLocal & ~AUCTION_DURATION_MASK) >> AUCTION_DURATION_START_BIT_POSITION,\\n      (dataLocal & ~REDEEM_FINE_MASK) >> REDEEM_FINE_START_BIT_POSITION,\\n      (dataLocal & ~REDEEM_THRESHOLD_MASK) >> REDEEM_THRESHOLD_START_BIT_POSITION\\n    );\\n  }\\n\\n  /**\\n   * @dev Gets the collateral configuration paramters of the NFT from a memory object\\n   * @param self The NFT configuration\\n   * @return The state params representing ltv, liquidation threshold, liquidation bonus\\n   **/\\n  function getCollateralParamsMemory(DataTypes.NftConfigurationMap memory self)\\n    internal\\n    pure\\n    returns (\\n      uint256,\\n      uint256,\\n      uint256\\n    )\\n  {\\n    return (\\n      self.data & ~LTV_MASK,\\n      (self.data & ~LIQUIDATION_THRESHOLD_MASK) >> LIQUIDATION_THRESHOLD_START_BIT_POSITION,\\n      (self.data & ~LIQUIDATION_BONUS_MASK) >> LIQUIDATION_BONUS_START_BIT_POSITION\\n    );\\n  }\\n\\n  /**\\n   * @dev Gets the auction configuration paramters of the NFT from a memory object\\n   * @param self The NFT configuration\\n   * @return The state params representing redeem duration, auction duration, redeem fine\\n   **/\\n  function getAuctionParamsMemory(DataTypes.NftConfigurationMap memory self)\\n    internal\\n    pure\\n    returns (\\n      uint256,\\n      uint256,\\n      uint256,\\n      uint256\\n    )\\n  {\\n    return (\\n      (self.data & ~REDEEM_DURATION_MASK) >> REDEEM_DURATION_START_BIT_POSITION,\\n      (self.data & ~AUCTION_DURATION_MASK) >> AUCTION_DURATION_START_BIT_POSITION,\\n      (self.data & ~REDEEM_FINE_MASK) >> REDEEM_FINE_START_BIT_POSITION,\\n      (self.data & ~REDEEM_THRESHOLD_MASK) >> REDEEM_THRESHOLD_START_BIT_POSITION\\n    );\\n  }\\n\\n  /**\\n   * @dev Gets the min & max bid fine of the NFT\\n   * @param self The NFT configuration\\n   * @return The min & max bid fine\\n   **/\\n  function getMinBidFineMemory(DataTypes.NftConfigurationMap memory self) internal pure returns (uint256) {\\n    return ((self.data & ~MIN_BIDFINE_MASK) >> MIN_BIDFINE_START_BIT_POSITION);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IReserveOracleGetter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.8.4;\\n\\n/************\\n@title IReserveOracleGetter interface\\n@notice Interface for getting Reserve price oracle.*/\\ninterface IReserveOracleGetter {\\n  /* CAUTION: Price uint is ETH based (WEI, 18 decimals) */\\n  /***********\\n    @dev returns the asset price in ETH\\n     */\\n  function getAssetPrice(address asset) external view returns (uint256);\\n\\n  // get twap price depending on _period\\n  function getTwapPrice(address _priceFeedKey, uint256 _interval) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/INFTOracleGetter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.8.4;\\n\\n/************\\n@title INFTOracleGetter interface\\n@notice Interface for getting NFT price oracle.*/\\ninterface INFTOracleGetter {\\n  /* CAUTION: Price uint is ETH based (WEI, 18 decimals) */\\n  /***********\\n    @dev returns the asset price in ETH\\n     */\\n  function getAssetPrice(address asset) external view returns (uint256);\\n\\n  // function getNFTPriceFromLink( address asset) external view returns (uint256);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {\r\n      \"contracts/libraries/logic/ValidationLogic.sol\": {\r\n        \"ValidationLogic\": \"0xc7a95965b13cc19946753ac2d447100dcec5218e\"\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"reserve\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"onBehalfOf\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"period\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"uint16\",\"name\":\"referral\",\"type\":\"uint16\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"reserve\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"period\",\"type\":\"uint8\"}],\"name\":\"Withdraw\",\"type\":\"event\"}]", "ContractName": "SupplyLogic", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}