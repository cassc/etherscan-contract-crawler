{"SourceCode": "{\"BaseWallet.sol\":{\"content\":\"// Copyright (C) 2018  Argent Labs Ltd. \\u003chttps://argent.xyz\\u003e\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see \\u003chttp://www.gnu.org/licenses/\\u003e.\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.6.12;\\n\\nimport \\\"./IModule.sol\\\";\\nimport \\\"./IWallet.sol\\\";\\n\\n/**\\n * @title BaseWallet\\n * @notice Simple modular wallet that authorises modules to call its invoke() method.\\n * @author Julien Niset - \\u003cjulien@argent.xyz\\u003e\\n */\\ncontract BaseWallet is IWallet {\\n\\n    // The implementation of the proxy\\n    address public implementation;\\n    // The owner\\n    address public override owner;\\n    // The authorised modules\\n    mapping (address =\\u003e bool) public override authorised;\\n    // The enabled static calls\\n    mapping (bytes4 =\\u003e address) public override enabled;\\n    // The number of modules\\n    uint public override modules;\\n\\n    event AuthorisedModule(address indexed module, bool value);\\n    event EnabledStaticCall(address indexed module, bytes4 indexed method);\\n    event Invoked(address indexed module, address indexed target, uint indexed value, bytes data);\\n    event Received(uint indexed value, address indexed sender, bytes data);\\n    event OwnerChanged(address owner);\\n\\n    /**\\n     * @notice Throws if the sender is not an authorised module.\\n     */\\n    modifier moduleOnly {\\n        require(authorised[msg.sender], \\\"BW: msg.sender not an authorized module\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @notice Inits the wallet by setting the owner and authorising a list of modules.\\n     * @param _owner The owner.\\n     * @param _modules The modules to authorise.\\n     */\\n    function init(address _owner, address[] calldata _modules) external {\\n        require(owner == address(0) \\u0026\\u0026 modules == 0, \\\"BW: wallet already initialised\\\");\\n        require(_modules.length \\u003e 0, \\\"BW: construction requires at least 1 module\\\");\\n        owner = _owner;\\n        modules = _modules.length;\\n        for (uint256 i = 0; i \\u003c _modules.length; i++) {\\n            require(authorised[_modules[i]] == false, \\\"BW: module is already added\\\");\\n            authorised[_modules[i]] = true;\\n            IModule(_modules[i]).init(address(this));\\n            emit AuthorisedModule(_modules[i], true);\\n        }\\n        if (address(this).balance \\u003e 0) {\\n            emit Received(address(this).balance, address(0), \\\"\\\");\\n        }\\n    }\\n\\n    /**\\n     * @inheritdoc IWallet\\n     */\\n    function authoriseModule(address _module, bool _value) external override moduleOnly {\\n        if (authorised[_module] != _value) {\\n            emit AuthorisedModule(_module, _value);\\n            if (_value == true) {\\n                modules += 1;\\n                authorised[_module] = true;\\n                IModule(_module).init(address(this));\\n            } else {\\n                modules -= 1;\\n                require(modules \\u003e 0, \\\"BW: wallet must have at least one module\\\");\\n                delete authorised[_module];\\n            }\\n        }\\n    }\\n\\n    /**\\n    * @inheritdoc IWallet\\n    */\\n    function enableStaticCall(address _module, bytes4 _method) external override moduleOnly {\\n        require(authorised[_module], \\\"BW: must be an authorised module for static call\\\");\\n        enabled[_method] = _module;\\n        emit EnabledStaticCall(_module, _method);\\n    }\\n\\n    /**\\n     * @inheritdoc IWallet\\n     */\\n    function setOwner(address _newOwner) external override moduleOnly {\\n        require(_newOwner != address(0), \\\"BW: address cannot be null\\\");\\n        owner = _newOwner;\\n        emit OwnerChanged(_newOwner);\\n    }\\n\\n    /**\\n     * @notice Performs a generic transaction.\\n     * @param _target The address for the transaction.\\n     * @param _value The value of the transaction.\\n     * @param _data The data of the transaction.\\n     */\\n    function invoke(address _target, uint _value, bytes calldata _data) external moduleOnly returns (bytes memory _result) {\\n        bool success;\\n        (success, _result) = _target.call{value: _value}(_data);\\n        if (!success) {\\n            // solhint-disable-next-line no-inline-assembly\\n            assembly {\\n                returndatacopy(0, 0, returndatasize())\\n                revert(0, returndatasize())\\n            }\\n        }\\n        emit Invoked(msg.sender, _target, _value, _data);\\n    }\\n\\n    /**\\n     * @notice This method delegates the static call to a target contract if the data corresponds\\n     * to an enabled module, or logs the call otherwise.\\n     */\\n    fallback() external payable {\\n        address module = enabled[msg.sig];\\n        if (module == address(0)) {\\n            emit Received(msg.value, msg.sender, msg.data);\\n        } else {\\n            require(authorised[module], \\\"BW: must be an authorised module for static call\\\");\\n\\n            // solhint-disable-next-line no-inline-assembly\\n            assembly {\\n                calldatacopy(0, 0, calldatasize())\\n                let result := staticcall(gas(), module, 0, calldatasize(), 0, 0)\\n                returndatacopy(0, 0, returndatasize())\\n                switch result\\n                case 0 {revert(0, returndatasize())}\\n                default {return (0, returndatasize())}\\n            }\\n        }\\n    }\\n\\n    receive() external payable {\\n    }\\n}\"},\"IGuardianStorage.sol\":{\"content\":\"// Copyright (C) 2018  Argent Labs Ltd. \\u003chttps://argent.xyz\\u003e\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see \\u003chttp://www.gnu.org/licenses/\\u003e.\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.6.12;\\n\\ninterface IGuardianStorage {\\n\\n    /**\\n     * @notice Lets an authorised module add a guardian to a wallet.\\n     * @param _wallet The target wallet.\\n     * @param _guardian The guardian to add.\\n     */\\n    function addGuardian(address _wallet, address _guardian) external;\\n\\n    /**\\n     * @notice Lets an authorised module revoke a guardian from a wallet.\\n     * @param _wallet The target wallet.\\n     * @param _guardian The guardian to revoke.\\n     */\\n    function revokeGuardian(address _wallet, address _guardian) external;\\n\\n    /**\\n     * @notice Checks if an account is a guardian for a wallet.\\n     * @param _wallet The target wallet.\\n     * @param _guardian The account.\\n     * @return true if the account is a guardian for a wallet.\\n     */\\n    function isGuardian(address _wallet, address _guardian) external view returns (bool);\\n\\n    function isLocked(address _wallet) external view returns (bool);\\n\\n    function getLock(address _wallet) external view returns (uint256);\\n\\n    function getLocker(address _wallet) external view returns (address);\\n\\n    function setLock(address _wallet, uint256 _releaseAfter) external;\\n\\n    function getGuardians(address _wallet) external view returns (address[] memory);\\n\\n    function guardianCount(address _wallet) external view returns (uint256);\\n}\"},\"ILimitStorage.sol\":{\"content\":\"// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see \\u003chttp://www.gnu.org/licenses/\\u003e.\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\n/**\\n * @title ILimitStorage\\n * @notice LimitStorage interface\\n */\\ninterface ILimitStorage {\\n\\n    struct Limit {\\n        // the current limit\\n        uint128 current;\\n        // the pending limit if any\\n        uint128 pending;\\n        // when the pending limit becomes the current limit\\n        uint64 changeAfter;\\n    }\\n\\n    struct DailySpent {\\n        // The amount already spent during the current period\\n        uint128 alreadySpent;\\n        // The end of the current period\\n        uint64 periodEnd;\\n    }\\n\\n    function setLimit(address _wallet, Limit memory _limit) external;\\n\\n    function getLimit(address _wallet) external view returns (Limit memory _limit);\\n\\n    function setDailySpent(address _wallet, DailySpent memory _dailySpent) external;\\n\\n    function getDailySpent(address _wallet) external view returns (DailySpent memory _dailySpent);\\n\\n    function setLimitAndDailySpent(address _wallet, Limit memory _limit, DailySpent memory _dailySpent) external;\\n\\n    function getLimitAndDailySpent(address _wallet) external view returns (Limit memory _limit, DailySpent memory _dailySpent);\\n}\"},\"IModule.sol\":{\"content\":\"// Copyright (C) 2018  Argent Labs Ltd. \\u003chttps://argent.xyz\\u003e\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see \\u003chttp://www.gnu.org/licenses/\\u003e.\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.6.12;\\n\\n/**\\n * @title IModule\\n * @notice Interface for a module.\\n * A module MUST implement the addModule() method to ensure that a wallet with at least one module\\n * can never end up in a \\\"frozen\\\" state.\\n * @author Julien Niset - \\u003cjulien@argent.xyz\\u003e\\n */\\ninterface IModule {\\n    /**\\n     * @notice Inits a module for a wallet by e.g. setting some wallet specific parameters in storage.\\n     * @param _wallet The wallet.\\n     */\\n    function init(address _wallet) external;\\n\\n    /**\\t\\n     * @notice Adds a module to a wallet. Cannot execute when wallet is locked (or under recovery)\\t\\n     * @param _wallet The target wallet.\\t\\n     * @param _module The modules to authorise.\\t\\n     */\\t\\n    function addModule(address _wallet, address _module) external;\\n}\"},\"IModuleRegistry.sol\":{\"content\":\"// Copyright (C) 2020  Argent Labs Ltd. \\u003chttps://argent.xyz\\u003e\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see \\u003chttp://www.gnu.org/licenses/\\u003e.\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.6.12;\\n\\n/**\\n * @title IModuleRegistry\\n * @notice Interface for the registry of authorised modules.\\n */\\ninterface IModuleRegistry {\\n    function registerModule(address _module, bytes32 _name) external;\\n\\n    function deregisterModule(address _module) external;\\n\\n    function registerUpgrader(address _upgrader, bytes32 _name) external;\\n\\n    function deregisterUpgrader(address _upgrader) external;\\n\\n    function recoverToken(address _token) external;\\n\\n    function moduleInfo(address _module) external view returns (bytes32);\\n\\n    function upgraderInfo(address _upgrader) external view returns (bytes32);\\n\\n    function isRegisteredModule(address _module) external view returns (bool);\\n\\n    function isRegisteredModule(address[] calldata _modules) external view returns (bool);\\n\\n    function isRegisteredUpgrader(address _upgrader) external view returns (bool);\\n}\"},\"IVersionManager.sol\":{\"content\":\"// Copyright (C) 2018  Argent Labs Ltd. \\u003chttps://argent.xyz\\u003e\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see \\u003chttp://www.gnu.org/licenses/\\u003e.\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./ILimitStorage.sol\\\";\\n\\n/**\\n * @title IVersionManager\\n * @notice Interface for the VersionManager module.\\n * @author Olivier VDB - \\u003colivier@argent.xyz\\u003e\\n */\\ninterface IVersionManager {\\n    /**\\n     * @notice Returns true if the feature is authorised for the wallet\\n     * @param _wallet The target wallet.\\n     * @param _feature The feature.\\n     */\\n    function isFeatureAuthorised(address _wallet, address _feature) external view returns (bool);\\n\\n    /**\\n     * @notice Lets a feature (caller) invoke a wallet.\\n     * @param _wallet The target wallet.\\n     * @param _to The target address for the transaction.\\n     * @param _value The value of the transaction.\\n     * @param _data The data of the transaction.\\n     */\\n    function checkAuthorisedFeatureAndInvokeWallet(\\n        address _wallet,\\n        address _to,\\n        uint256 _value,\\n        bytes calldata _data\\n    ) external returns (bytes memory _res);\\n\\n    /* ******* Backward Compatibility with old Storages and BaseWallet *************** */\\n\\n    /**\\n     * @notice Sets a new owner for the wallet.\\n     * @param _newOwner The new owner.\\n     */\\n    function setOwner(address _wallet, address _newOwner) external;\\n\\n    /**\\n     * @notice Lets a feature write data to a storage contract.\\n     * @param _wallet The target wallet.\\n     * @param _storage The storage contract.\\n     * @param _data The data of the call\\n     */\\n    function invokeStorage(address _wallet, address _storage, bytes calldata _data) external;\\n\\n    /**\\n     * @notice Upgrade a wallet to a new version.\\n     * @param _wallet the wallet to upgrade\\n     * @param _toVersion the new version\\n     */\\n    function upgradeWallet(address _wallet, uint256 _toVersion) external;\\n \\n}\"},\"IWallet.sol\":{\"content\":\"// Copyright (C) 2018  Argent Labs Ltd. \\u003chttps://argent.xyz\\u003e\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see \\u003chttp://www.gnu.org/licenses/\\u003e.\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity \\u003e=0.5.4 \\u003c0.7.0;\\n\\n/**\\n * @title IWallet\\n * @notice Interface for the BaseWallet\\n */\\ninterface IWallet {\\n    /**\\n     * @notice Returns the wallet owner.\\n     * @return The wallet owner address.\\n     */\\n    function owner() external view returns (address);\\n\\n    /**\\n     * @notice Returns the number of authorised modules.\\n     * @return The number of authorised modules.\\n     */\\n    function modules() external view returns (uint);\\n\\n    /**\\n     * @notice Sets a new owner for the wallet.\\n     * @param _newOwner The new owner.\\n     */\\n    function setOwner(address _newOwner) external;\\n\\n    /**\\n     * @notice Checks if a module is authorised on the wallet.\\n     * @param _module The module address to check.\\n     * @return `true` if the module is authorised, otherwise `false`.\\n     */\\n    function authorised(address _module) external view returns (bool);\\n\\n    /**\\n     * @notice Returns the module responsible for a static call redirection.\\n     * @param _sig The signature of the static call.\\n     * @return the module doing the redirection\\n     */\\n    function enabled(bytes4 _sig) external view returns (address);\\n\\n    /**\\n     * @notice Enables/Disables a module.\\n     * @param _module The target module.\\n     * @param _value Set to `true` to authorise the module.\\n     */\\n    function authoriseModule(address _module, bool _value) external;\\n\\n    /**\\n    * @notice Enables a static method by specifying the target module to which the call must be delegated.\\n    * @param _module The target module.\\n    * @param _method The static method signature.\\n    */\\n    function enableStaticCall(address _module, bytes4 _method) external;\\n}\"},\"Managed.sol\":{\"content\":\"// Copyright (C) 2018  Argent Labs Ltd. \\u003chttps://argent.xyz\\u003e\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see \\u003chttp://www.gnu.org/licenses/\\u003e.\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity \\u003e=0.5.4 \\u003c0.7.0;\\n\\nimport \\\"./Owned.sol\\\";\\n\\n/**\\n * @title Managed\\n * @notice Basic contract that defines a set of managers. Only the owner can add/remove managers.\\n * @author Julien Niset - \\u003cjulien@argent.xyz\\u003e\\n */\\ncontract Managed is Owned {\\n\\n    // The managers\\n    mapping (address =\\u003e bool) public managers;\\n\\n    /**\\n     * @notice Throws if the sender is not a manager.\\n     */\\n    modifier onlyManager {\\n        require(managers[msg.sender] == true, \\\"M: Must be manager\\\");\\n        _;\\n    }\\n\\n    event ManagerAdded(address indexed _manager);\\n    event ManagerRevoked(address indexed _manager);\\n\\n    /**\\n    * @notice Adds a manager.\\n    * @param _manager The address of the manager.\\n    */\\n    function addManager(address _manager) external onlyOwner {\\n        require(_manager != address(0), \\\"M: Address must not be null\\\");\\n        if (managers[_manager] == false) {\\n            managers[_manager] = true;\\n            emit ManagerAdded(_manager);\\n        }\\n    }\\n\\n    /**\\n    * @notice Revokes a manager.\\n    * @param _manager The address of the manager.\\n    */\\n    function revokeManager(address _manager) external onlyOwner {\\n        require(managers[_manager] == true, \\\"M: Target must be an existing manager\\\");\\n        delete managers[_manager];\\n        emit ManagerRevoked(_manager);\\n    }\\n}\"},\"Owned.sol\":{\"content\":\"// Copyright (C) 2018  Argent Labs Ltd. \\u003chttps://argent.xyz\\u003e\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see \\u003chttp://www.gnu.org/licenses/\\u003e.\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity \\u003e=0.5.4 \\u003c0.7.0;\\n\\n/**\\n * @title Owned\\n * @notice Basic contract to define an owner.\\n * @author Julien Niset - \\u003cjulien@argent.xyz\\u003e\\n */\\ncontract Owned {\\n\\n    // The owner\\n    address public owner;\\n\\n    event OwnerChanged(address indexed _newOwner);\\n\\n    /**\\n     * @notice Throws if the sender is not the owner.\\n     */\\n    modifier onlyOwner {\\n        require(msg.sender == owner, \\\"Must be owner\\\");\\n        _;\\n    }\\n\\n    constructor() public {\\n        owner = msg.sender;\\n    }\\n\\n    /**\\n     * @notice Lets the owner transfer ownership of the contract to a new owner.\\n     * @param _newOwner The new owner.\\n     */\\n    function changeOwner(address _newOwner) external onlyOwner {\\n        require(_newOwner != address(0), \\\"Address must not be null\\\");\\n        owner = _newOwner;\\n        emit OwnerChanged(_newOwner);\\n    }\\n}\"},\"Proxy.sol\":{\"content\":\"// Copyright (C) 2018  Argent Labs Ltd. \\u003chttps://argent.xyz\\u003e\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see \\u003chttp://www.gnu.org/licenses/\\u003e.\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.6.12;\\n\\n/**\\n * @title Proxy\\n * @notice Basic proxy that delegates all calls to a fixed implementing contract.\\n * The implementing contract cannot be upgraded.\\n * @author Julien Niset - \\u003cjulien@argent.xyz\\u003e\\n */\\ncontract Proxy {\\n\\n    address implementation;\\n\\n    event Received(uint indexed value, address indexed sender, bytes data);\\n\\n    constructor(address _implementation) public {\\n        implementation = _implementation;\\n    }\\n\\n    fallback() external payable {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            let target := sload(0)\\n            calldatacopy(0, 0, calldatasize())\\n            let result := delegatecall(gas(), target, 0, calldatasize(), 0, 0)\\n            returndatacopy(0, 0, returndatasize())\\n            switch result\\n            case 0 {revert(0, returndatasize())}\\n            default {return (0, returndatasize())}\\n        }\\n    }\\n\\n    receive() external payable {\\n        emit Received(msg.value, msg.sender, msg.data);\\n    }\\n}\"},\"WalletFactory.sol\":{\"content\":\"// Copyright (C) 2018  Argent Labs Ltd. \\u003chttps://argent.xyz\\u003e\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see \\u003chttp://www.gnu.org/licenses/\\u003e.\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.6.12;\\n\\nimport \\\"./Proxy.sol\\\";\\nimport \\\"./BaseWallet.sol\\\";\\nimport \\\"./Owned.sol\\\";\\nimport \\\"./Managed.sol\\\";\\nimport \\\"./IGuardianStorage.sol\\\";\\nimport \\\"./IModuleRegistry.sol\\\";\\nimport \\\"./IVersionManager.sol\\\";\\n\\n/**\\n * @title WalletFactory\\n * @notice The WalletFactory contract creates and assigns wallets to accounts.\\n * @author Julien Niset - \\u003cjulien@argent.xyz\\u003e\\n */\\ncontract WalletFactory is Owned, Managed {\\n\\n    // The address of the module dregistry\\n    address public moduleRegistry;\\n    // The address of the base wallet implementation\\n    address public walletImplementation;\\n    // The address of the GuardianStorage\\n    address public guardianStorage;\\n\\n    // *************** Events *************************** //\\n\\n    event ModuleRegistryChanged(address addr);\\n    event WalletCreated(address indexed wallet, address indexed owner, address indexed guardian);\\n\\n    // *************** Constructor ********************** //\\n\\n    /**\\n     * @notice Default constructor.\\n     */\\n    constructor(address _moduleRegistry, address _walletImplementation, address _guardianStorage) public {\\n        require(_moduleRegistry != address(0), \\\"WF: ModuleRegistry address not defined\\\");\\n        require(_walletImplementation != address(0), \\\"WF: WalletImplementation address not defined\\\");\\n        require(_guardianStorage != address(0), \\\"WF: GuardianStorage address not defined\\\");\\n        moduleRegistry = _moduleRegistry;\\n        walletImplementation = _walletImplementation;\\n        guardianStorage = _guardianStorage;\\n    }\\n\\n    // *************** External Functions ********************* //\\n    /**\\n     * @notice Lets the manager create a wallet for an owner account.\\n     * The wallet is initialised with the version manager module, a version number and a first guardian.\\n     * The wallet is created using the CREATE opcode.\\n     * @param _owner The account address.\\n     * @param _versionManager The version manager module\\n     * @param _guardian The guardian address.\\n     * @param _version The version of the feature bundle.\\n     */\\n    function createWallet(\\n        address _owner,\\n        address _versionManager,\\n        address _guardian,\\n        uint256 _version\\n    )\\n        external\\n        onlyManager\\n    {\\n        validateInputs(_owner, _versionManager, _guardian, _version);\\n        Proxy proxy = new Proxy(walletImplementation);\\n        address payable wallet = address(proxy);\\n        configureWallet(BaseWallet(wallet), _owner, _versionManager, _guardian, _version);\\n    }\\n     \\n    /**\\n     * @notice Lets the manager create a wallet for an owner account at a specific address.\\n     * The wallet is initialised with the version manager module, the version number and a first guardian.\\n     * The wallet is created using the CREATE2 opcode.\\n     * @param _owner The account address.\\n     * @param _versionManager The version manager module\\n     * @param _guardian The guardian address.\\n     * @param _salt The salt.\\n     * @param _version The version of the feature bundle.\\n     */\\n    function createCounterfactualWallet(\\n        address _owner,\\n        address _versionManager,\\n        address _guardian,\\n        bytes32 _salt,\\n        uint256 _version\\n    )\\n        external\\n        onlyManager\\n        returns (address _wallet)\\n    {\\n        validateInputs(_owner, _versionManager, _guardian, _version);\\n        bytes32 newsalt = newSalt(_salt, _owner, _versionManager, _guardian, _version);\\n        Proxy proxy = new Proxy{salt: newsalt}(walletImplementation);\\n        address payable wallet = address(proxy);\\n        configureWallet(BaseWallet(wallet), _owner, _versionManager, _guardian, _version);\\n        return wallet;\\n    }\\n\\n    /**\\n     * @notice Gets the address of a counterfactual wallet with a first default guardian.\\n     * @param _owner The account address.\\n     * @param _versionManager The version manager module\\n     * @param _guardian The guardian address.\\n     * @param _salt The salt.\\n     * @param _version The version of feature bundle.\\n     * @return _wallet The address that the wallet will have when created using CREATE2 and the same input parameters.\\n     */\\n    function getAddressForCounterfactualWallet(\\n        address _owner,\\n        address _versionManager,\\n        address _guardian,\\n        bytes32 _salt,\\n        uint256 _version\\n    )\\n        external\\n        view\\n        returns (address _wallet)\\n    {\\n        validateInputs(_owner, _versionManager, _guardian, _version);\\n        bytes32 newsalt = newSalt(_salt, _owner, _versionManager, _guardian, _version);\\n        bytes memory code = abi.encodePacked(type(Proxy).creationCode, uint256(walletImplementation));\\n        bytes32 hash = keccak256(abi.encodePacked(bytes1(0xff), address(this), newsalt, keccak256(code)));\\n        _wallet = address(uint160(uint256(hash)));\\n    }\\n\\n    /**\\n     * @notice Lets the owner change the address of the module registry contract.\\n     * @param _moduleRegistry The address of the module registry contract.\\n     */\\n    function changeModuleRegistry(address _moduleRegistry) external onlyOwner {\\n        require(_moduleRegistry != address(0), \\\"WF: address cannot be null\\\");\\n        moduleRegistry = _moduleRegistry;\\n        emit ModuleRegistryChanged(_moduleRegistry);\\n    }\\n\\n    /**\\n     * @notice Inits the module for a wallet by doing nothing.\\n     * The method can only be called by the wallet itself.\\n     * @param _wallet The wallet.\\n     */\\n    function init(BaseWallet _wallet) external pure {\\n        //do nothing\\n    }\\n\\n    // *************** Internal Functions ********************* //\\n\\n    /**\\n     * @notice Helper method to configure a wallet for a set of input parameters.\\n     * @param _wallet The target wallet\\n     * @param _owner The account address.\\n     * @param _versionManager The version manager module\\n     * @param _guardian The guardian address.\\n     * @param _version The version of the feature bundle.\\n     */\\n    function configureWallet(\\n        BaseWallet _wallet,\\n        address _owner,\\n        address _versionManager,\\n        address _guardian,\\n        uint256 _version\\n    )\\n        internal\\n    {\\n        // add the factory to modules so it can add a guardian and upgrade the wallet to the required version\\n        address[] memory extendedModules = new address[](2);\\n        extendedModules[0] = _versionManager;\\n        extendedModules[1] = address(this);\\n\\n        // initialise the wallet with the owner and the extended modules\\n        _wallet.init(_owner, extendedModules);\\n\\n        // add guardian\\n        IGuardianStorage(guardianStorage).addGuardian(address(_wallet), _guardian);\\n\\n        // upgrade the wallet\\n        IVersionManager(_versionManager).upgradeWallet(address(_wallet), _version);\\n\\n        // remove the factory from the authorised modules\\n        _wallet.authoriseModule(address(this), false);\\n\\n        // emit event\\n        emit WalletCreated(address(_wallet), _owner, _guardian);\\n    }\\n\\n    /**\\n     * @notice Generates a new salt based on a provided salt, an owner, a list of modules and an optional guardian.\\n     * @param _salt The slat provided.\\n     * @param _owner The owner address.\\n     * @param _versionManager The version manager module\\n     * @param _guardian The guardian address.\\n     * @param _version The version of feature bundle\\n     */\\n    function newSalt(bytes32 _salt, address _owner, address _versionManager, address _guardian, uint256 _version) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(_salt, _owner, _versionManager, _guardian, _version));\\n    }\\n\\n    /**\\n     * @notice Throws if the owner, guardian, version or version manager is invalid.\\n     * @param _owner The owner address.\\n     * @param _versionManager The version manager module\\n     * @param _guardian The guardian address\\n     * @param _version The version of feature bundle\\n     */\\n    function validateInputs(address _owner, address _versionManager, address _guardian, uint256 _version) internal view {\\n        require(_owner != address(0), \\\"WF: owner cannot be null\\\");\\n        require(IModuleRegistry(moduleRegistry).isRegisteredModule(_versionManager), \\\"WF: invalid _versionManager\\\");\\n        require(_guardian != (address(0)), \\\"WF: guardian cannot be null\\\");\\n        require(_version \\u003e 0, \\\"WF: invalid _version\\\");\\n    }\\n}\\n\"}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_moduleRegistry\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_walletImplementation\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_guardianStorage\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_manager\",\"type\":\"address\"}],\"name\":\"ManagerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_manager\",\"type\":\"address\"}],\"name\":\"ManagerRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"ModuleRegistryChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"guardian\",\"type\":\"address\"}],\"name\":\"WalletCreated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_manager\",\"type\":\"address\"}],\"name\":\"addManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_moduleRegistry\",\"type\":\"address\"}],\"name\":\"changeModuleRegistry\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_versionManager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_guardian\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_salt\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_version\",\"type\":\"uint256\"}],\"name\":\"createCounterfactualWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_versionManager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_guardian\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_version\",\"type\":\"uint256\"}],\"name\":\"createWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_versionManager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_guardian\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_salt\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_version\",\"type\":\"uint256\"}],\"name\":\"getAddressForCounterfactualWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"guardianStorage\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract BaseWallet\",\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"managers\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"moduleRegistry\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_manager\",\"type\":\"address\"}],\"name\":\"revokeManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"walletImplementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "WalletFactory", "CompilerVersion": "v0.6.12+commit.27d51765", "OptimizationUsed": "1", "Runs": "999", "ConstructorArguments": "000000000000000000000000c17d432bd8e8850fd7b32b0270f5afac65db010500000000000000000000000029b94b045a0b828d9eb99136a16d97c7ff3d260000000000000000000000000044da3a8051ba88eab0440db3779cab9d679ae76f", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU GPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://3e6230ba2430e25bbb7062a66cec02cd0bf3330e16f132008055dee6ded6c82f"}