{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.7;\r\n\r\nabstract contract DomainAware {\r\n\r\n    // Mapping of ChainID to domain separators. This is a very gas efficient way\r\n    // to not recalculate the domain separator on every call, while still\r\n    // automatically detecting ChainID changes.\r\n    mapping(uint256 => bytes32) private domainSeparators;\r\n\r\n    constructor() {\r\n        _updateDomainSeparator();\r\n    }\r\n\r\n    function domainName() public virtual view returns (string memory);\r\n\r\n    function domainVersion() public virtual view returns (string memory);\r\n\r\n    function generateDomainSeparator() public view returns (bytes32) {\r\n        uint256 chainID = _chainID();\r\n\r\n        // no need for assembly, running very rarely\r\n        bytes32 domainSeparatorHash = keccak256(\r\n            abi.encode(\r\n                keccak256(\r\n                    \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\r\n                ),\r\n                keccak256(bytes(domainName())), // ERC-20 Name\r\n                keccak256(bytes(domainVersion())), // Version\r\n                chainID,\r\n                address(this)\r\n            )\r\n        );\r\n\r\n        return domainSeparatorHash;\r\n    }\r\n\r\n    function domainSeparator() external returns (bytes32) {\r\n        return _domainSeparator();\r\n    }\r\n\r\n    function _updateDomainSeparator() private returns (bytes32) {\r\n        uint256 chainID = _chainID();\r\n\r\n        bytes32 newDomainSeparator = generateDomainSeparator();\r\n\r\n        domainSeparators[chainID] = newDomainSeparator;\r\n\r\n        return newDomainSeparator;\r\n    }\r\n\r\n    // Returns the domain separator, updating it if chainID changes\r\n    function _domainSeparator() private returns (bytes32) {\r\n        bytes32 currentDomainSeparator = domainSeparators[_chainID()];\r\n\r\n        if (currentDomainSeparator != 0x00) {\r\n            return currentDomainSeparator;\r\n        }\r\n\r\n        return _updateDomainSeparator();\r\n    }\r\n\r\n    function _chainID() internal view returns (uint256) {\r\n        uint256 chainID;\r\n        assembly {\r\n            chainID := chainid()\r\n        }\r\n\r\n        return chainID;\r\n    }\r\n}\r\n\r\n/**\r\n * @title IERC1400TokensRecipient\r\n * @dev ERC1400TokensRecipient interface\r\n */\r\ninterface IERC1400TokensRecipient {\r\n\r\n    function canReceive(\r\n        bytes calldata payload,\r\n        bytes32 partition,\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint value,\r\n        bytes calldata data,\r\n        bytes calldata operatorData\r\n    ) external view returns(bool);\r\n\r\n    function tokensReceived(\r\n        bytes calldata payload,\r\n        bytes32 partition,\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint value,\r\n        bytes calldata data,\r\n        bytes calldata operatorData\r\n    ) external;\r\n\r\n}\r\n\r\n/**\r\n * @title IERC1400TokensSender\r\n * @dev ERC1400TokensSender interface\r\n */\r\ninterface IERC1400TokensSender {\r\n\r\n    function canTransfer(\r\n        bytes calldata payload,\r\n        bytes32 partition,\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint value,\r\n        bytes calldata data,\r\n        bytes calldata operatorData\r\n    ) external view returns(bool);\r\n\r\n    function tokensToTransfer(\r\n        bytes calldata payload,\r\n        bytes32 partition,\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint value,\r\n        bytes calldata data,\r\n        bytes calldata operatorData\r\n    ) external;\r\n\r\n}\r\n\r\n/**\r\n * @title IERC1400TokensChecker\r\n * @dev IERC1400TokensChecker interface\r\n */\r\ninterface IERC1400TokensChecker {\r\n\r\n    // function canTransfer(\r\n    //   bytes calldata payload,\r\n    //   address operator,\r\n    //   address from,\r\n    //   address to,\r\n    //   uint256 value,\r\n    //   bytes calldata data,\r\n    //   bytes calldata operatorData\r\n    // ) external view returns (byte, bytes32);\r\n\r\n    function canTransferByPartition(\r\n        bytes calldata payload,\r\n        bytes32 partition,\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256 value,\r\n        bytes calldata data,\r\n        bytes calldata operatorData\r\n    ) external view returns (bytes1, bytes32, bytes32);\r\n\r\n}\r\n\r\n/**\r\n * @title IERC1400TokensValidator\r\n * @dev ERC1400TokensValidator interface\r\n */\r\ninterface IERC1400TokensValidator {\r\n\r\n    /**\r\n     * @dev Verify if a token transfer can be executed or not, on the validator's perspective.\r\n   * @param token Token address.\r\n   * @param payload Payload of the initial transaction.\r\n   * @param partition Name of the partition (left empty for ERC20 transfer).\r\n   * @param operator Address which triggered the balance decrease (through transfer or redemption).\r\n   * @param from Token holder.\r\n   * @param to Token recipient for a transfer and 0x for a redemption.\r\n   * @param value Number of tokens the token holder balance is decreased by.\r\n   * @param data Extra information.\r\n   * @param operatorData Extra information, attached by the operator (if any).\r\n   * @return 'true' if the token transfer can be validated, 'false' if not.\r\n   */\r\n    struct ValidateData {\r\n        address token;\r\n        bytes payload;\r\n        bytes32 partition;\r\n        address operator;\r\n        address from;\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n        bytes operatorData;\r\n    }\r\n\r\n    function canValidate(ValidateData calldata data) external view returns(bool);\r\n\r\n    function tokensToValidate(\r\n        bytes calldata payload,\r\n        bytes32 partition,\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint value,\r\n        bytes calldata data,\r\n        bytes calldata operatorData\r\n    ) external;\r\n\r\n}\r\n\r\n/**\r\n * @title Roles\r\n * @dev Library for managing addresses assigned to a Role.\r\n */\r\nlibrary Roles {\r\n    struct Role {\r\n        mapping (address => bool) bearer;\r\n    }\r\n\r\n    /**\r\n     * @dev Give an account access to this role.\r\n     */\r\n    function add(Role storage role, address account) internal {\r\n        require(!has(role, account), \"Roles: account already has role\");\r\n        role.bearer[account] = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Remove an account's access to this role.\r\n     */\r\n    function remove(Role storage role, address account) internal {\r\n        require(has(role, account), \"Roles: account does not have role\");\r\n        role.bearer[account] = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Check if an account has this role.\r\n     * @return bool\r\n     */\r\n    function has(Role storage role, address account) internal view returns (bool) {\r\n        require(account != address(0), \"Roles: account is the zero address\");\r\n        return role.bearer[account];\r\n    }\r\n}\r\n\r\n/**\r\n * @title MinterRole\r\n * @dev Minters are responsible for minting new tokens.\r\n */\r\ncontract MinterRole {\r\n    using Roles for Roles.Role;\r\n\r\n    event MinterAdded(address indexed account);\r\n    event MinterRemoved(address indexed account);\r\n\r\n    Roles.Role private _minters;\r\n\r\n    constructor() {\r\n        _addMinter(msg.sender);\r\n    }\r\n\r\n    modifier onlyMinter() virtual {\r\n        require(isMinter(msg.sender));\r\n        _;\r\n    }\r\n\r\n    function isMinter(address account) public view returns (bool) {\r\n        return _minters.has(account);\r\n    }\r\n\r\n    function addMinter(address account) external onlyMinter {\r\n        _addMinter(account);\r\n    }\r\n\r\n    function removeMinter(address account) external onlyMinter {\r\n        _removeMinter(account);\r\n    }\r\n\r\n    function renounceMinter() external {\r\n        _removeMinter(msg.sender);\r\n    }\r\n\r\n    function _addMinter(address account) internal {\r\n        _minters.add(account);\r\n        emit MinterAdded(account);\r\n    }\r\n\r\n    function _removeMinter(address account) internal {\r\n        _minters.remove(account);\r\n        emit MinterRemoved(account);\r\n    }\r\n}\r\n\r\ncontract ERC1820Implementer {\r\n    bytes32 constant ERC1820_ACCEPT_MAGIC = keccak256(abi.encodePacked(\"ERC1820_ACCEPT_MAGIC\"));\r\n\r\n    mapping(bytes32 => bool) internal _interfaceHashes;\r\n\r\n    function canImplementInterfaceForAddress(bytes32 interfaceHash, address /*addr*/) // Comments to avoid compilation warnings for unused variables.\r\n    external\r\n    view\r\n    returns(bytes32)\r\n    {\r\n        if(_interfaceHashes[interfaceHash]) {\r\n            return ERC1820_ACCEPT_MAGIC;\r\n        } else {\r\n            return \"\";\r\n        }\r\n    }\r\n\r\n    function _setInterface(string memory interfaceLabel) internal {\r\n        _interfaceHashes[keccak256(abi.encodePacked(interfaceLabel))] = true;\r\n    }\r\n\r\n}\r\n\r\ninterface IERC1820Registry {\r\n    event InterfaceImplementerSet(address indexed account, bytes32 indexed interfaceHash, address indexed implementer);\r\n\r\n    event ManagerChanged(address indexed account, address indexed newManager);\r\n\r\n    /**\r\n     * @dev Sets `newManager` as the manager for `account`. A manager of an\r\n     * account is able to set interface implementers for it.\r\n     *\r\n     * By default, each account is its own manager. Passing a value of `0x0` in\r\n     * `newManager` will reset the manager to this initial state.\r\n     *\r\n     * Emits a {ManagerChanged} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must be the current manager for `account`.\r\n     */\r\n    function setManager(address account, address newManager) external;\r\n\r\n    /**\r\n     * @dev Returns the manager for `account`.\r\n     *\r\n     * See {setManager}.\r\n     */\r\n    function getManager(address account) external view returns (address);\r\n\r\n    /**\r\n     * @dev Sets the `implementer` contract as ``account``'s implementer for\r\n     * `interfaceHash`.\r\n     *\r\n     * `account` being the zero address is an alias for the caller's address.\r\n     * The zero address can also be used in `implementer` to remove an old one.\r\n     *\r\n     * See {interfaceHash} to learn how these are created.\r\n     *\r\n     * Emits an {InterfaceImplementerSet} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must be the current manager for `account`.\r\n     * - `interfaceHash` must not be an {IERC165} interface id (i.e. it must not\r\n     * end in 28 zeroes).\r\n     * - `implementer` must implement {IERC1820Implementer} and return true when\r\n     * queried for support, unless `implementer` is the caller. See\r\n     * {IERC1820Implementer-canImplementInterfaceForAddress}.\r\n     */\r\n    function setInterfaceImplementer(\r\n        address account,\r\n        bytes32 _interfaceHash,\r\n        address implementer\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Returns the implementer of `interfaceHash` for `account`. If no such\r\n     * implementer is registered, returns the zero address.\r\n     *\r\n     * If `interfaceHash` is an {IERC165} interface id (i.e. it ends with 28\r\n     * zeroes), `account` will be queried for support of it.\r\n     *\r\n     * `account` being the zero address is an alias for the caller's address.\r\n     */\r\n    function getInterfaceImplementer(address account, bytes32 _interfaceHash) external view returns (address);\r\n\r\n    /**\r\n     * @dev Returns the interface hash for an `interfaceName`, as defined in the\r\n     * corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-1820#interface-name[section of the EIP].\r\n     */\r\n    function interfaceHash(string calldata interfaceName) external pure returns (bytes32);\r\n\r\n    /**\r\n     * @notice Updates the cache with whether the contract implements an ERC165 interface or not.\r\n     * @param account Address of the contract for which to update the cache.\r\n     * @param interfaceId ERC165 interface for which to update the cache.\r\n     */\r\n    function updateERC165Cache(address account, bytes4 interfaceId) external;\r\n\r\n    /**\r\n     * @notice Checks whether a contract implements an ERC165 interface or not.\r\n     * If the result is not cached a direct lookup on the contract address is performed.\r\n     * If the result is not cached or the cached value is out-of-date, the cache MUST be updated manually by calling\r\n     * {updateERC165Cache} with the contract address.\r\n     * @param account Address of the contract to check.\r\n     * @param interfaceId ERC165 interface to check.\r\n     * @return True if `account` implements `interfaceId`, false otherwise.\r\n     */\r\n    function implementsERC165Interface(address account, bytes4 interfaceId) external view returns (bool);\r\n\r\n    /**\r\n     * @notice Checks whether a contract implements an ERC165 interface or not without using nor updating the cache.\r\n     * @param account Address of the contract to check.\r\n     * @param interfaceId ERC165 interface to check.\r\n     * @return True if `account` implements `interfaceId`, false otherwise.\r\n     */\r\n    function implementsERC165InterfaceNoCache(address account, bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\ncontract ERC1820Client {\r\n    IERC1820Registry constant ERC1820REGISTRY = IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);\r\n\r\n    function setInterfaceImplementation(string memory _interfaceLabel, address _implementation) internal {\r\n        bytes32 interfaceHash = keccak256(abi.encodePacked(_interfaceLabel));\r\n        ERC1820REGISTRY.setInterfaceImplementer(address(this), interfaceHash, _implementation);\r\n    }\r\n\r\n    function interfaceAddr(address addr, string memory _interfaceLabel) internal view returns(address) {\r\n        bytes32 interfaceHash = keccak256(abi.encodePacked(_interfaceLabel));\r\n        return ERC1820REGISTRY.getInterfaceImplementer(addr, interfaceHash);\r\n    }\r\n\r\n\r\n}\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view  returns (address) {\r\n        return msg.sender;\r\n    }\r\n}\r\n\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view  returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the sender is not the owner.\r\n     */\r\n    function _checkOwner() internal view  {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() external  onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public  onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal  {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and making it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        _nonReentrantBefore();\r\n        _;\r\n        _nonReentrantAfter();\r\n    }\r\n\r\n    function _nonReentrantBefore() private {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n    }\r\n\r\n    function _nonReentrantAfter() private {\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address from, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}\r\n\r\n/// @title IERC1643 Document Management (part of the ERC1400 Security Token Standards)\r\n/// @dev See https://github.com/SecurityTokenStandard/EIP-Spec\r\n\r\ninterface IERC1643 {\r\n\r\n    // Document Management\r\n    function getDocument(bytes32 _name) external view returns (string memory, bytes32, uint256);\r\n    function setDocument(bytes32 _name, string memory _uri, bytes32 _documentHash) external;\r\n    function removeDocument(bytes32 _name) external;\r\n    function getAllDocuments() external view returns (bytes32[] memory);\r\n\r\n    // Document Events\r\n    event DocumentRemoved(bytes32 indexed name, string uri, bytes32 documentHash);\r\n    event DocumentUpdated(bytes32 indexed name, string uri, bytes32 documentHash);\r\n\r\n}\r\n\r\n/**\r\n * @title IERC1400 security token standard\r\n * @dev See https://github.com/SecurityTokenStandard/EIP-Spec/blob/master/eip/eip-1400.md\r\n */\r\ninterface IERC1400 is IERC20, IERC1643 {\r\n\r\n    // ******************* Token Information ********************\r\n    function balanceOfByPartition(bytes32 partition, address tokenHolder) external view returns (uint256);\r\n    function partitionsOf(address tokenHolder) external view returns (bytes32[] memory);\r\n\r\n    // *********************** Transfers ************************\r\n    function transferWithData(address to, uint256 value, bytes calldata data) external;\r\n    function transferFromWithData(address from, address to, uint256 value, bytes calldata data) external;\r\n\r\n    // *************** Partition Token Transfers ****************\r\n    function transferByPartition(bytes32 partition, address to, uint256 value, bytes calldata data) external returns (bytes32);\r\n    function operatorTransferByPartition(bytes32 partition, address from, address to, uint256 value, bytes calldata data, bytes calldata operatorData) external returns (bytes32);\r\n    function allowanceByPartition(bytes32 partition, address owner, address spender) external view returns (uint256);\r\n\r\n    // ****************** Controller Operation ******************\r\n    function isControllable() external view returns (bool);\r\n    // function controllerTransfer(address from, address to, uint256 value, bytes calldata data, bytes calldata operatorData) external; // removed because same action can be achieved with \"operatorTransferByPartition\"\r\n    // function controllerRedeem(address tokenHolder, uint256 value, bytes calldata data, bytes calldata operatorData) external; // removed because same action can be achieved with \"operatorRedeemByPartition\"\r\n\r\n    // ****************** Operator Management *******************\r\n    function authorizeOperator(address operator) external;\r\n    function revokeOperator(address operator) external;\r\n    function authorizeOperatorByPartition(bytes32 partition, address operator) external;\r\n    function revokeOperatorByPartition(bytes32 partition, address operator) external;\r\n\r\n    // ****************** Operator Information ******************\r\n    function isOperator(address operator, address tokenHolder) external view returns (bool);\r\n    function isOperatorForPartition(bytes32 partition, address operator, address tokenHolder) external view returns (bool);\r\n\r\n    // ********************* Token Issuance *********************\r\n    function isIssuable() external view returns (bool);\r\n    function issue(address tokenHolder, uint256 value, bytes calldata data) external;\r\n    function issueByPartition(bytes32 partition, address tokenHolder, uint256 value, bytes calldata data) external;\r\n\r\n    // ******************** Token Redemption ********************\r\n    function redeem(uint256 value, bytes calldata data) external;\r\n    function redeemFrom(address tokenHolder, uint256 value, bytes calldata data) external;\r\n    function redeemByPartition(bytes32 partition, uint256 value, bytes calldata data) external;\r\n    function operatorRedeemByPartition(bytes32 partition, address tokenHolder, uint256 value, bytes calldata operatorData) external;\r\n\r\n    event TransferByPartition(\r\n        bytes32 indexed fromPartition,\r\n        address operator,\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 value,\r\n        bytes data,\r\n        bytes operatorData\r\n    );\r\n\r\n    event ChangedPartition(\r\n        bytes32 indexed fromPartition,\r\n        bytes32 indexed toPartition,\r\n        uint256 value\r\n    );\r\n\r\n    // ******************** Operator Events *********************\r\n    event AuthorizedOperator(address indexed operator, address indexed tokenHolder);\r\n    event RevokedOperator(address indexed operator, address indexed tokenHolder);\r\n    event AuthorizedOperatorByPartition(bytes32 indexed partition, address indexed operator, address indexed tokenHolder);\r\n    event RevokedOperatorByPartition(bytes32 indexed partition, address indexed operator, address indexed tokenHolder);\r\n\r\n    // ************** Issuance / Redemption Events **************\r\n    event Issued(address indexed operator, address indexed to, uint256 value, bytes data);\r\n    event Redeemed(address indexed operator, address indexed from, uint256 value, bytes data);\r\n    event IssuedByPartition(bytes32 indexed partition, address indexed operator, address indexed to, uint256 value, bytes data, bytes operatorData);\r\n    event RedeemedByPartition(bytes32 indexed partition, address indexed operator, address indexed from, uint256 value, bytes operatorData);\r\n\r\n}\r\n\r\n/**\r\n * Reason codes - ERC-1066\r\n *\r\n * To improve the token holder experience, canTransfer MUST return a reason byte code\r\n * on success or failure based on the ERC-1066 application-specific status codes specified below.\r\n * An implementation can also return arbitrary data as a bytes32 to provide additional\r\n * information not captured by the reason code.\r\n *\r\n * Code Reason\r\n * 0x50 transfer failure\r\n * 0x51 transfer success\r\n * 0x52 insufficient balance\r\n * 0x53 insufficient allowance\r\n * 0x54 transfers halted (contract paused)\r\n * 0x55 funds locked (lockup period)\r\n * 0x56 invalid sender\r\n * 0x57 invalid receiver\r\n * 0x58 invalid operator (transfer agent)\r\n * 0x59\r\n * 0x5a\r\n * 0x5b\r\n * 0x5a\r\n * 0x5b\r\n * 0x5c\r\n * 0x5d\r\n * 0x5e\r\n * 0x5f token meta or info\r\n *\r\n * These codes are being discussed at: https://ethereum-magicians.org/t/erc-1066-ethereum-status-codes-esc/283/24\r\n */\r\n\r\n\r\n/**\r\n * @title ERC1400\r\n * @dev ERC1400 logic\r\n */\r\ncontract ERC1400 is IERC20, IERC1400, Ownable, ERC1820Client, ERC1820Implementer, MinterRole, DomainAware, ReentrancyGuard {\r\n\r\n    // Token\r\n    string constant internal ERC1400_INTERFACE_NAME = \"ERC1400Token\";\r\n    string constant internal ERC20_INTERFACE_NAME = \"ERC20Token\";\r\n\r\n    // Token extensions\r\n    string constant internal ERC1400_TOKENS_CHECKER = \"ERC1400TokensChecker\";\r\n    string constant internal ERC1400_TOKENS_VALIDATOR = \"ERC1400TokensValidator\";\r\n\r\n    // User extensions\r\n    string constant internal ERC1400_TOKENS_SENDER = \"ERC1400TokensSender\";\r\n    string constant internal ERC1400_TOKENS_RECIPIENT = \"ERC1400TokensRecipient\";\r\n\r\n    /************************************* Token description ****************************************/\r\n    string internal _name;\r\n    string internal _symbol;\r\n    uint256 internal _granularity;\r\n    uint256 internal _totalSupply;\r\n    bool internal _migrated;\r\n    /************************************************************************************************/\r\n\r\n\r\n    /**************************************** Token behaviours **************************************/\r\n    // Indicate whether the token can still be controlled by operators or not anymore.\r\n    bool internal _isControllable;\r\n\r\n    // Indicate whether the token can still be issued by the issuer or not anymore.\r\n    bool internal _isIssuable;\r\n    /************************************************************************************************/\r\n\r\n\r\n    /********************************** ERC20 Token mappings ****************************************/\r\n    // Mapping from tokenHolder to balance.\r\n    mapping(address => uint256) internal _balances;\r\n\r\n    // Mapping from (tokenHolder, spender) to allowed value.\r\n    mapping (address => mapping (address => uint256)) internal _allowed;\r\n    /************************************************************************************************/\r\n\r\n\r\n    /**************************************** Documents *********************************************/\r\n    struct Doc {\r\n        string docURI;\r\n        bytes32 docHash;\r\n        uint256 timestamp;\r\n    }\r\n    // Mapping for documents.\r\n    mapping(bytes32 => Doc) internal _documents;\r\n    mapping(bytes32 => uint256) internal _indexOfDocHashes;\r\n    bytes32[] internal _docHashes;\r\n    /************************************************************************************************/\r\n\r\n\r\n    /*********************************** Partitions  mappings ***************************************/\r\n    // List of partitions.\r\n    bytes32[] internal _totalPartitions;\r\n\r\n    // Mapping from partition to their index.\r\n    mapping (bytes32 => uint256) internal _indexOfTotalPartitions;\r\n\r\n    // Mapping from partition to global balance of corresponding partition.\r\n    mapping (bytes32 => uint256) internal _totalSupplyByPartition;\r\n\r\n    // Mapping from tokenHolder to their partitions.\r\n    mapping (address => bytes32[]) internal _partitionsOf;\r\n\r\n    // Mapping from (tokenHolder, partition) to their index.\r\n    mapping (address => mapping (bytes32 => uint256)) internal _indexOfPartitionsOf;\r\n\r\n    // Mapping from (tokenHolder, partition) to balance of corresponding partition.\r\n    mapping (address => mapping (bytes32 => uint256)) internal _balanceOfByPartition;\r\n\r\n    // List of token default partitions (for ERC20 compatibility).\r\n    bytes32[] internal _defaultPartitions;\r\n    /************************************************************************************************/\r\n\r\n\r\n    /********************************* Global operators mappings ************************************/\r\n    // Mapping from (operator, tokenHolder) to authorized status. [TOKEN-HOLDER-SPECIFIC]\r\n    mapping(address => mapping(address => bool)) internal _authorizedOperator;\r\n\r\n    // Array of controllers. [GLOBAL - NOT TOKEN-HOLDER-SPECIFIC]\r\n    address[] internal _controllers;\r\n\r\n    // Mapping from operator to controller status. [GLOBAL - NOT TOKEN-HOLDER-SPECIFIC]\r\n    mapping(address => bool) internal _isController;\r\n    /************************************************************************************************/\r\n\r\n\r\n    /******************************** Partition operators mappings **********************************/\r\n    // Mapping from (partition, tokenHolder, spender) to allowed value. [TOKEN-HOLDER-SPECIFIC]\r\n    mapping(bytes32 => mapping (address => mapping (address => uint256))) internal _allowedByPartition;\r\n\r\n    // Mapping from (tokenHolder, partition, operator) to 'approved for partition' status. [TOKEN-HOLDER-SPECIFIC]\r\n    mapping (address => mapping (bytes32 => mapping (address => bool))) internal _authorizedOperatorByPartition;\r\n\r\n    // Mapping from partition to controllers for the partition. [NOT TOKEN-HOLDER-SPECIFIC]\r\n    mapping (bytes32 => address[]) internal _controllersByPartition;\r\n\r\n    // Mapping from (partition, operator) to PartitionController status. [NOT TOKEN-HOLDER-SPECIFIC]\r\n    mapping (bytes32 => mapping (address => bool)) internal _isControllerByPartition;\r\n    /************************************************************************************************/\r\n\r\n\r\n    /***************************************** Modifiers ********************************************/\r\n    /**\r\n     * @dev Modifier to verify if token is issuable.\r\n   */\r\n    modifier isIssuableToken() {\r\n        require(_isIssuable, \"55\"); // 0x55 funds locked (lockup period)\r\n        _;\r\n    }\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is not migrated.\r\n   */\r\n    modifier isNotMigratedToken() {\r\n        require(!_migrated, \"54\"); // 0x54  transfers halted (contract paused)\r\n        _;\r\n    }\r\n    /**\r\n     * @dev Modifier to verifiy if sender is a minter.\r\n   */\r\n    modifier onlyMinter() override {\r\n        require(isMinter(msg.sender) || owner() == _msgSender());\r\n        _;\r\n    }\r\n    /************************************************************************************************/\r\n\r\n\r\n    /**************************** Events (additional - not mandatory) *******************************/\r\n    event ApprovalByPartition(bytes32 indexed partition, address indexed owner, address indexed spender, uint256 value);\r\n    /************************************************************************************************/\r\n\r\n\r\n    /**\r\n     * @dev Initialize ERC1400 + register the contract implementation in ERC1820Registry.\r\n   * @param name_ Name of the token.\r\n   * @param symbol_ Symbol of the token.\r\n   * @param granularity_ Granularity of the token.\r\n   * @param defaultPartitions_ Partitions chosen by default, when partition is\r\n   * not specified, like the case ERC20 tranfers.\r\n   */\r\n    constructor(\r\n        string memory name_,\r\n        string memory symbol_,\r\n        uint256 granularity_,\r\n        bytes32[] memory defaultPartitions_\r\n    )\r\n    {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n        _totalSupply = 0;\r\n        require(granularity_ >= 1); // Constructor Blocked - Token granularity can not be lower than 1\r\n        _granularity = granularity_;\r\n\r\n        _defaultPartitions = defaultPartitions_;\r\n\r\n        _isControllable = true;\r\n        _isIssuable = true;\r\n\r\n        // Register contract in ERC1820 registry\r\n        ERC1820Client.setInterfaceImplementation(ERC1400_INTERFACE_NAME, address(this));\r\n        ERC1820Client.setInterfaceImplementation(ERC20_INTERFACE_NAME, address(this));\r\n\r\n        // Indicate token verifies ERC1400 and ERC20 interfaces\r\n        ERC1820Implementer._setInterface(ERC1400_INTERFACE_NAME); // For migration\r\n        ERC1820Implementer._setInterface(ERC20_INTERFACE_NAME); // For migration\r\n    }\r\n\r\n\r\n    /************************************************************************************************/\r\n    /****************************** EXTERNAL FUNCTIONS (ERC20 INTERFACE) ****************************/\r\n    /************************************************************************************************/\r\n\r\n\r\n    /**\r\n     * @dev Get the total number of issued tokens.\r\n   * @return Total supply of tokens currently in circulation.\r\n   */\r\n    function totalSupply() external override view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n    /**\r\n     * @dev Get the balance of the account with address 'tokenHolder'.\r\n   * @param tokenHolder Address for which the balance is returned.\r\n   * @return Amount of token held by 'tokenHolder' in the token contract.\r\n   */\r\n    function balanceOf(address tokenHolder) external override view returns (uint256) {\r\n        return _balances[tokenHolder];\r\n    }\r\n    /**\r\n     * @dev Transfer token for a specified address.\r\n   * @param to The address to transfer to.\r\n   * @param value The value to be transferred.\r\n   * @return A boolean that indicates if the operation was successful.\r\n   */\r\n    function transfer(address to, uint256 value) external override returns (bool) {\r\n        _transferByDefaultPartitions(msg.sender, msg.sender, to, value, \"\");\r\n        return true;\r\n    }\r\n    /**\r\n     * @dev Check the value of tokens that an owner allowed to a spender.\r\n   * @param from address The address which owns the funds.\r\n   * @param spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the value of tokens still available for the spender.\r\n   */\r\n    function allowance(address from, address spender) external override view returns (uint256) {\r\n        return _allowed[from][spender];\r\n    }\r\n    /**\r\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of 'msg.sender'.\r\n   * @param spender The address which will spend the funds.\r\n   * @param value The amount of tokens to be spent.\r\n   * @return A boolean that indicates if the operation was successful.\r\n   */\r\n    function approve(address spender, uint256 value) external override returns (bool) {\r\n        require(spender != address(0), \"56\"); // 0x56   invalid sender\r\n        _allowed[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n    /**\r\n     * @dev Transfer tokens from one address to another.\r\n   * @param from The address which you want to transfer tokens from.\r\n   * @param to The address which you want to transfer to.\r\n   * @param value The amount of tokens to be transferred.\r\n   * @return A boolean that indicates if the operation was successful.\r\n   */\r\n    function transferFrom(address from, address to, uint256 value) external override returns (bool) {\r\n        require( _isOperator(msg.sender, from)\r\n        || (value <= _allowed[from][msg.sender]), \"53\"); // 0x53    insufficient allowance\r\n\r\n        if(_allowed[from][msg.sender] >= value) {\r\n            _allowed[from][msg.sender] = _allowed[from][msg.sender] - value;\r\n        } else {\r\n            _allowed[from][msg.sender] = 0;\r\n        }\r\n\r\n        _transferByDefaultPartitions(msg.sender, from, to, value, \"\");\r\n        return true;\r\n    }\r\n\r\n\r\n    /************************************************************************************************/\r\n    /****************************** EXTERNAL FUNCTIONS (ERC1400 INTERFACE) **************************/\r\n    /************************************************************************************************/\r\n\r\n\r\n    /************************************* Document Management **************************************/\r\n    /**\r\n     * @dev Access a document associated with the token.\r\n   * @param shortName Short name (represented as a bytes32) associated to the document.\r\n   * @return Requested document + document hash + document timestamp.\r\n   */\r\n    function getDocument(bytes32 shortName) external override view returns (string memory, bytes32, uint256) {\r\n        require(bytes(_documents[shortName].docURI).length != 0); // Action Blocked - Empty document\r\n        return (\r\n        _documents[shortName].docURI,\r\n        _documents[shortName].docHash,\r\n        _documents[shortName].timestamp\r\n        );\r\n    }\r\n    /**\r\n     * @dev Associate a document with the token.\r\n   * @param shortName Short name (represented as a bytes32) associated to the document.\r\n   * @param uri Document content.\r\n   * @param documentHash Hash of the document [optional parameter].\r\n   */\r\n    function setDocument(bytes32 shortName, string calldata uri, bytes32 documentHash) external override {\r\n        require(_isController[msg.sender]);\r\n        _documents[shortName] = Doc({\r\n            docURI: uri,\r\n            docHash: documentHash,\r\n            timestamp: block.timestamp\r\n        });\r\n\r\n        if (_indexOfDocHashes[documentHash] == 0) {\r\n            _docHashes.push(documentHash);\r\n            _indexOfDocHashes[documentHash] = _docHashes.length;\r\n        }\r\n\r\n        emit DocumentUpdated(shortName, uri, documentHash);\r\n    }\r\n\r\n    function removeDocument(bytes32 shortName) external override {\r\n        require(_isController[msg.sender], \"Unauthorized\");\r\n        require(bytes(_documents[shortName].docURI).length != 0, \"Document doesnt exist\"); // Action Blocked - Empty document\r\n\r\n        Doc memory data = _documents[shortName];\r\n\r\n        uint256 index1 = _indexOfDocHashes[data.docHash];\r\n        require(index1 > 0, \"Invalid index\"); //Indexing starts at 1, 0 is not allowed\r\n\r\n        // move the last item into the index being vacated\r\n        bytes32 lastValue = _docHashes[_docHashes.length - 1];\r\n        _docHashes[index1 - 1] = lastValue; // adjust for 1-based indexing\r\n        _indexOfDocHashes[lastValue] = index1;\r\n\r\n        //_totalPartitions.length -= 1;\r\n        _docHashes.pop();\r\n        _indexOfDocHashes[data.docHash] = 0;\r\n\r\n        delete _documents[shortName];\r\n\r\n        emit DocumentRemoved(shortName, data.docURI, data.docHash);\r\n    }\r\n\r\n    function getAllDocuments() external override view returns (bytes32[] memory) {\r\n        return _docHashes;\r\n    }\r\n    /************************************************************************************************/\r\n\r\n\r\n    /************************************** Token Information ***************************************/\r\n    /**\r\n     * @dev Get balance of a tokenholder for a specific partition.\r\n   * @param partition Name of the partition.\r\n   * @param tokenHolder Address for which the balance is returned.\r\n   * @return Amount of token of partition 'partition' held by 'tokenHolder' in the token contract.\r\n   */\r\n    function balanceOfByPartition(bytes32 partition, address tokenHolder) external override view returns (uint256) {\r\n        return _balanceOfByPartition[tokenHolder][partition];\r\n    }\r\n    /**\r\n     * @dev Get partitions index of a tokenholder.\r\n   * @param tokenHolder Address for which the partitions index are returned.\r\n   * @return Array of partitions index of 'tokenHolder'.\r\n   */\r\n    function partitionsOf(address tokenHolder) external override view returns (bytes32[] memory) {\r\n        return _partitionsOf[tokenHolder];\r\n    }\r\n    /************************************************************************************************/\r\n\r\n\r\n    /****************************************** Transfers *******************************************/\r\n    /**\r\n     * @dev Transfer the amount of tokens from the address 'msg.sender' to the address 'to'.\r\n   * @param to Token recipient.\r\n   * @param value Number of tokens to transfer.\r\n   * @param data Information attached to the transfer, by the token holder.\r\n   */\r\n    function transferWithData(address to, uint256 value, bytes calldata data) external override {\r\n        _transferByDefaultPartitions(msg.sender, msg.sender, to, value, data);\r\n    }\r\n    /**\r\n     * @dev Transfer the amount of tokens on behalf of the address 'from' to the address 'to'.\r\n   * @param from Token holder (or 'address(0)' to set from to 'msg.sender').\r\n   * @param to Token recipient.\r\n   * @param value Number of tokens to transfer.\r\n   * @param data Information attached to the transfer, and intended for the token holder ('from').\r\n   */\r\n    function transferFromWithData(address from, address to, uint256 value, bytes calldata data) external override virtual {\r\n        require( _isOperator(msg.sender, from)\r\n        || (value <= _allowed[from][msg.sender]), \"53\"); // 0x53    insufficient allowance\r\n\r\n        if(_allowed[from][msg.sender] >= value) {\r\n            _allowed[from][msg.sender] = _allowed[from][msg.sender] - value;\r\n        } else {\r\n            _allowed[from][msg.sender] = 0;\r\n        }\r\n\r\n        _transferByDefaultPartitions(msg.sender, from, to, value, data);\r\n    }\r\n    /************************************************************************************************/\r\n\r\n\r\n    /********************************** Partition Token Transfers ***********************************/\r\n    /**\r\n     * @dev Transfer tokens from a specific partition.\r\n   * @param partition Name of the partition.\r\n   * @param to Token recipient.\r\n   * @param value Number of tokens to transfer.\r\n   * @param data Information attached to the transfer, by the token holder.\r\n   * @return Destination partition.\r\n   */\r\n    function transferByPartition(\r\n        bytes32 partition,\r\n        address to,\r\n        uint256 value,\r\n        bytes calldata data\r\n    )\r\n    external\r\n    override\r\n    nonReentrant\r\n    returns (bytes32)\r\n\r\n    {\r\n        return _transferByPartition(partition, msg.sender, msg.sender, to, value, data, \"\");\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer tokens from a specific partition through an operator.\r\n   * @param partition Name of the partition.\r\n   * @param from Token holder.\r\n   * @param to Token recipient.\r\n   * @param value Number of tokens to transfer.\r\n   * @param data Information attached to the transfer. [CAN CONTAIN THE DESTINATION PARTITION]\r\n   * @param operatorData Information attached to the transfer, by the operator.\r\n   * @return Destination partition.\r\n   */\r\n    function operatorTransferByPartition(\r\n        bytes32 partition,\r\n        address from,\r\n        address to,\r\n        uint256 value,\r\n        bytes calldata data,\r\n        bytes calldata operatorData\r\n    )\r\n    external\r\n    override\r\n    returns (bytes32)\r\n    {\r\n        //We want to check if the msg.sender is an authorized operator for `from`\r\n        //(msg.sender == from OR msg.sender is authorized by from OR msg.sender is a controller if this token is controlable)\r\n        //OR\r\n        //We want to check if msg.sender is an `allowed` operator/spender for `from`\r\n        require(_isOperatorForPartition(partition, msg.sender, from)\r\n        || (value <= _allowedByPartition[partition][from][msg.sender]), \"53\"); // 0x53  insufficient allowance\r\n\r\n        if(_allowedByPartition[partition][from][msg.sender] >= value) {\r\n            _allowedByPartition[partition][from][msg.sender] = _allowedByPartition[partition][from][msg.sender] - value;\r\n        } else {\r\n            _allowedByPartition[partition][from][msg.sender] = 0;\r\n        }\r\n\r\n        return _transferByPartition(partition, msg.sender, from, to, value, data, operatorData);\r\n    }\r\n    /************************************************************************************************/\r\n\r\n\r\n    /************************************* Controller Operation *************************************/\r\n    /**\r\n     * @dev Know if the token can be controlled by operators.\r\n   * If a token returns 'false' for 'isControllable()'' then it MUST always return 'false' in the future.\r\n   * @return bool 'true' if the token can still be controlled by operators, 'false' if it can't anymore.\r\n   */\r\n    function isControllable() external override view returns (bool) {\r\n        return _isControllable;\r\n    }\r\n    /************************************************************************************************/\r\n\r\n\r\n    /************************************* Operator Management **************************************/\r\n    /**\r\n     * @dev Set a third party operator address as an operator of 'msg.sender' to transfer\r\n   * and redeem tokens on its behalf.\r\n   * @param operator Address to set as an operator for 'msg.sender'.\r\n   */\r\n    function authorizeOperator(address operator) external override {\r\n        require(operator != msg.sender);\r\n        _authorizedOperator[operator][msg.sender] = true;\r\n        emit AuthorizedOperator(operator, msg.sender);\r\n    }\r\n    /**\r\n     * @dev Remove the right of the operator address to be an operator for 'msg.sender'\r\n   * and to transfer and redeem tokens on its behalf.\r\n   * @param operator Address to rescind as an operator for 'msg.sender'.\r\n   */\r\n    function revokeOperator(address operator) external override {\r\n        require(operator != msg.sender);\r\n        _authorizedOperator[operator][msg.sender] = false;\r\n        emit RevokedOperator(operator, msg.sender);\r\n    }\r\n    /**\r\n     * @dev Set 'operator' as an operator for 'msg.sender' for a given partition.\r\n   * @param partition Name of the partition.\r\n   * @param operator Address to set as an operator for 'msg.sender'.\r\n   */\r\n    function authorizeOperatorByPartition(bytes32 partition, address operator) external override {\r\n        _authorizedOperatorByPartition[msg.sender][partition][operator] = true;\r\n        emit AuthorizedOperatorByPartition(partition, operator, msg.sender);\r\n    }\r\n    /**\r\n     * @dev Remove the right of the operator address to be an operator on a given\r\n   * partition for 'msg.sender' and to transfer and redeem tokens on its behalf.\r\n   * @param partition Name of the partition.\r\n   * @param operator Address to rescind as an operator on given partition for 'msg.sender'.\r\n   */\r\n    function revokeOperatorByPartition(bytes32 partition, address operator) external override {\r\n        _authorizedOperatorByPartition[msg.sender][partition][operator] = false;\r\n        emit RevokedOperatorByPartition(partition, operator, msg.sender);\r\n    }\r\n    /************************************************************************************************/\r\n\r\n\r\n    /************************************* Operator Information *************************************/\r\n    /**\r\n     * @dev Indicate whether the operator address is an operator of the tokenHolder address.\r\n   * @param operator Address which may be an operator of tokenHolder.\r\n   * @param tokenHolder Address of a token holder which may have the operator address as an operator.\r\n   * @return 'true' if operator is an operator of 'tokenHolder' and 'false' otherwise.\r\n   */\r\n    function isOperator(address operator, address tokenHolder) external override view returns (bool) {\r\n        return _isOperator(operator, tokenHolder);\r\n    }\r\n    /**\r\n     * @dev Indicate whether the operator address is an operator of the tokenHolder\r\n   * address for the given partition.\r\n   * @param partition Name of the partition.\r\n   * @param operator Address which may be an operator of tokenHolder for the given partition.\r\n   * @param tokenHolder Address of a token holder which may have the operator address as an operator for the given partition.\r\n   * @return 'true' if 'operator' is an operator of 'tokenHolder' for partition 'partition' and 'false' otherwise.\r\n   */\r\n    function isOperatorForPartition(bytes32 partition, address operator, address tokenHolder) external override view returns (bool) {\r\n        return _isOperatorForPartition(partition, operator, tokenHolder);\r\n    }\r\n    /************************************************************************************************/\r\n\r\n\r\n    /**************************************** Token Issuance ****************************************/\r\n    /**\r\n     * @dev Know if new tokens can be issued in the future.\r\n   * @return bool 'true' if tokens can still be issued by the issuer, 'false' if they can't anymore.\r\n   */\r\n    function isIssuable() external override view returns (bool) {\r\n        return _isIssuable;\r\n    }\r\n    /**\r\n     * @dev Issue tokens from default partition.\r\n   * @param tokenHolder Address for which we want to issue tokens.\r\n   * @param value Number of tokens issued.\r\n   * @param data Information attached to the issuance, by the issuer.\r\n   */\r\n    function issue(address tokenHolder, uint256 value, bytes calldata data)\r\n    external\r\n    override\r\n    onlyMinter\r\n    nonReentrant\r\n    isIssuableToken\r\n    {\r\n        require(_defaultPartitions.length != 0, \"55\"); // 0x55  funds locked (lockup period)\r\n\r\n        _issueByPartition(_defaultPartitions[0], msg.sender, tokenHolder, value, data);\r\n    }\r\n    /**\r\n     * @dev Issue tokens from a specific partition.\r\n   * @param partition Name of the partition.\r\n   * @param tokenHolder Address for which we want to issue tokens.\r\n   * @param value Number of tokens issued.\r\n   * @param data Information attached to the issuance, by the issuer.\r\n   */\r\n    function issueByPartition(bytes32 partition, address tokenHolder, uint256 value, bytes calldata data)\r\n    external\r\n    override\r\n    onlyMinter\r\n    nonReentrant\r\n    isIssuableToken\r\n    {\r\n        _issueByPartition(partition, msg.sender, tokenHolder, value, data);\r\n    }\r\n    /************************************************************************************************/\r\n\r\n\r\n    /*************************************** Token Redemption ***************************************/\r\n    /**\r\n     * @dev Redeem the amount of tokens from the address 'msg.sender'.\r\n   * @param value Number of tokens to redeem.\r\n   * @param data Information attached to the redemption, by the token holder.\r\n   */\r\n    function redeem(uint256 value, bytes calldata data)\r\n    external\r\n    override\r\n    nonReentrant\r\n    {\r\n        _redeemByDefaultPartitions(msg.sender, msg.sender, value, data);\r\n    }\r\n    /**\r\n     * @dev Redeem the amount of tokens on behalf of the address from.\r\n   * @param from Token holder whose tokens will be redeemed (or address(0) to set from to msg.sender).\r\n   * @param value Number of tokens to redeem.\r\n   * @param data Information attached to the redemption.\r\n   */\r\n    function redeemFrom(address from, uint256 value, bytes calldata data)\r\n    external\r\n    override\r\n    virtual\r\n    nonReentrant\r\n    {\r\n        require(_isOperator(msg.sender, from)\r\n        || (value <= _allowed[from][msg.sender]), \"53\"); // 0x53    insufficient allowance\r\n\r\n        if(_allowed[from][msg.sender] >= value) {\r\n            _allowed[from][msg.sender] = _allowed[from][msg.sender] - value;\r\n        } else {\r\n            _allowed[from][msg.sender] = 0;\r\n        }\r\n\r\n        _redeemByDefaultPartitions(msg.sender, from, value, data);\r\n    }\r\n    /**\r\n     * @dev Redeem tokens of a specific partition.\r\n   * @param partition Name of the partition.\r\n   * @param value Number of tokens redeemed.\r\n   * @param data Information attached to the redemption, by the redeemer.\r\n   */\r\n    function redeemByPartition(bytes32 partition, uint256 value, bytes calldata data)\r\n    external\r\n    override\r\n    nonReentrant\r\n    {\r\n        _redeemByPartition(partition, msg.sender, msg.sender, value, data, \"\");\r\n    }\r\n    /**\r\n     * @dev Redeem tokens of a specific partition.\r\n   * @param partition Name of the partition.\r\n   * @param tokenHolder Address for which we want to redeem tokens.\r\n   * @param value Number of tokens redeemed\r\n   * @param operatorData Information attached to the redemption, by the operator.\r\n   */\r\n    function operatorRedeemByPartition(bytes32 partition, address tokenHolder, uint256 value, bytes calldata operatorData)\r\n    external\r\n    override\r\n    nonReentrant\r\n    nonReentrant\r\n    {\r\n        require(_isOperatorForPartition(partition, msg.sender, tokenHolder) || value <= _allowedByPartition[partition][tokenHolder][msg.sender], \"58\"); // 0x58 invalid operator (transfer agent)\r\n\r\n        if(_allowedByPartition[partition][tokenHolder][msg.sender] >= value) {\r\n            _allowedByPartition[partition][tokenHolder][msg.sender] = _allowedByPartition[partition][tokenHolder][msg.sender] - value;\r\n        } else {\r\n            _allowedByPartition[partition][tokenHolder][msg.sender] = 0;\r\n        }\r\n\r\n        _redeemByPartition(partition, msg.sender, tokenHolder, value, \"\", operatorData);\r\n    }\r\n    /************************************************************************************************/\r\n\r\n\r\n    /************************************************************************************************/\r\n    /************************ EXTERNAL FUNCTIONS (ADDITIONAL - NOT MANDATORY) ***********************/\r\n    /************************************************************************************************/\r\n\r\n\r\n    /************************************ Token description *****************************************/\r\n    /**\r\n     * @dev Get the name of the token, e.g., \"MyToken\".\r\n   * @return Name of the token.\r\n   */\r\n    function name() external view returns(string memory) {\r\n        return _name;\r\n    }\r\n    /**\r\n     * @dev Get the symbol of the token, e.g., \"MYT\".\r\n   * @return Symbol of the token.\r\n   */\r\n    function symbol() external view returns(string memory) {\r\n        return _symbol;\r\n    }\r\n    /**\r\n     * @dev Get the number of decimals of the token.\r\n   * @return The number of decimals of the token. For retrocompatibility, decimals are forced to 18 in ERC1400.\r\n   */\r\n    function decimals() external pure returns(uint8) {\r\n        return uint8(18);\r\n    }\r\n    /**\r\n     * @dev Get the smallest part of the token that\u2019s not divisible.\r\n   * @return The smallest non-divisible part of the token.\r\n   */\r\n    function granularity() external view returns(uint256) {\r\n        return _granularity;\r\n    }\r\n    /**\r\n     * @dev Get list of existing partitions.\r\n   * @return Array of all exisiting partitions.\r\n   */\r\n    function totalPartitions() external view returns (bytes32[] memory) {\r\n        return _totalPartitions;\r\n    }\r\n    /**\r\n     * @dev Get the total number of issued tokens for a given partition.\r\n   * @param partition Name of the partition.\r\n   * @return Total supply of tokens currently in circulation, for a given partition.\r\n   */\r\n    function totalSupplyByPartition(bytes32 partition) external view returns (uint256) {\r\n        return _totalSupplyByPartition[partition];\r\n    }\r\n    /************************************************************************************************/\r\n\r\n\r\n    /**************************************** Token behaviours **************************************/\r\n    /**\r\n     * @dev Definitely renounce the possibility to control tokens on behalf of tokenHolders.\r\n   * Once set to false, '_isControllable' can never be set to 'true' again.\r\n   */\r\n    function renounceControl() external onlyOwner {\r\n        _isControllable = false;\r\n    }\r\n    /**\r\n     * @dev Definitely renounce the possibility to issue new tokens.\r\n   * Once set to false, '_isIssuable' can never be set to 'true' again.\r\n   */\r\n    function renounceIssuance() external onlyOwner {\r\n        _isIssuable = false;\r\n    }\r\n    /************************************************************************************************/\r\n\r\n\r\n    /************************************ Token controllers *****************************************/\r\n    /**\r\n     * @dev Get the list of controllers as defined by the token contract.\r\n   * @return List of addresses of all the controllers.\r\n   */\r\n    function controllers() external view returns (address[] memory) {\r\n        return _controllers;\r\n    }\r\n    /**\r\n     * @dev Get controllers for a given partition.\r\n   * @param partition Name of the partition.\r\n   * @return Array of controllers for partition.\r\n   */\r\n    function controllersByPartition(bytes32 partition) external view returns (address[] memory) {\r\n        return _controllersByPartition[partition];\r\n    }\r\n    /**\r\n     * @dev Set list of token controllers.\r\n   * @param operators Controller addresses.\r\n   */\r\n    function setControllers(address[] calldata operators) external onlyOwner {\r\n        _setControllers(operators);\r\n    }\r\n    /**\r\n     * @dev Set list of token partition controllers.\r\n   * @param partition Name of the partition.\r\n   * @param operators Controller addresses.\r\n   */\r\n    function setPartitionControllers(bytes32 partition, address[] calldata operators) external onlyOwner {\r\n        _setPartitionControllers(partition, operators);\r\n    }\r\n    /************************************************************************************************/\r\n\r\n\r\n    /********************************* Token default partitions *************************************/\r\n    /**\r\n     * @dev Get default partitions to transfer from.\r\n   * Function used for ERC20 retrocompatibility.\r\n   * For example, a security token may return the bytes32(\"unrestricted\").\r\n   * @return Array of default partitions.\r\n   */\r\n    function getDefaultPartitions() external view returns (bytes32[] memory) {\r\n        return _defaultPartitions;\r\n    }\r\n    /**\r\n     * @dev Set default partitions to transfer from.\r\n   * Function used for ERC20 retrocompatibility.\r\n   * @param partitions partitions to use by default when not specified.\r\n   */\r\n    function setDefaultPartitions(bytes32[] calldata partitions) external onlyOwner {\r\n        _defaultPartitions = partitions;\r\n    }\r\n    /************************************************************************************************/\r\n\r\n\r\n    /******************************** Partition Token Allowances ************************************/\r\n    /**\r\n     * @dev Check the value of tokens that an owner allowed to a spender.\r\n   * @param partition Name of the partition.\r\n   * @param ownerAddr address The address which owns the funds.\r\n   * @param spenderAddr address The address which will spend the funds.\r\n   * @return A uint256 specifying the value of tokens still available for the spender.\r\n   */\r\n    function allowanceByPartition(bytes32 partition, address ownerAddr, address spenderAddr) external override view returns (uint256) {\r\n        return _allowedByPartition[partition][ownerAddr][spenderAddr];\r\n    }\r\n    /**\r\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of 'msg.sender'.\r\n   * @param partition Name of the partition.\r\n   * @param spender The address which will spend the funds.\r\n   * @param value The amount of tokens to be spent.\r\n   * @return A boolean that indicates if the operation was successful.\r\n   */\r\n    function approveByPartition(bytes32 partition, address spender, uint256 value) external returns (bool) {\r\n        require(spender != address(0), \"56\"); // 0x56   invalid sender\r\n        _allowedByPartition[partition][msg.sender][spender] = value;\r\n        emit ApprovalByPartition(partition, msg.sender, spender, value);\r\n        return true;\r\n    }\r\n    /************************************************************************************************/\r\n\r\n\r\n    /************************************** Token extension *****************************************/\r\n    /**\r\n     * @dev Set token extension contract address.\r\n   * The extension contract can for example verify \"ERC1400TokensValidator\" or \"ERC1400TokensChecker\" interfaces.\r\n   * If the extension is an \"ERC1400TokensValidator\", it will be called everytime a transfer is executed.\r\n   * @param extension Address of the extension contract.\r\n   * @param interfaceLabel Interface label of extension contract.\r\n   * @param removeOldExtensionRoles If set to 'true', the roles of the old extension(minter, controller) will be removed extension.\r\n   * @param addMinterRoleForExtension If set to 'true', the extension contract will be added as minter.\r\n   * @param addControllerRoleForExtension If set to 'true', the extension contract will be added as controller.\r\n   */\r\n    function setTokenExtension(address extension, string calldata interfaceLabel, bool removeOldExtensionRoles, bool addMinterRoleForExtension, bool addControllerRoleForExtension) external onlyOwner {\r\n        _setTokenExtension(extension, interfaceLabel, removeOldExtensionRoles, addMinterRoleForExtension, addControllerRoleForExtension);\r\n    }\r\n    /************************************************************************************************/\r\n\r\n    /************************************* Token migration ******************************************/\r\n    /**\r\n     * @dev Migrate contract.\r\n   *\r\n   * ===> CAUTION: DEFINITIVE ACTION\r\n   *\r\n   * This function shall be called once a new version of the smart contract has been created.\r\n   * Once this function is called:\r\n   *  - The address of the new smart contract is set in ERC1820 registry\r\n   *  - If the choice is definitive, the current smart contract is turned off and can never be used again\r\n   *\r\n   * @param newContractAddress Address of the new version of the smart contract.\r\n   * @param definitive If set to 'true' the contract is turned off definitely.\r\n   */\r\n    function migrate(address newContractAddress, bool definitive) external onlyOwner {\r\n        _migrate(newContractAddress, definitive);\r\n    }\r\n    /************************************************************************************************/\r\n\r\n\r\n    /************************************************************************************************/\r\n    /************************************* INTERNAL FUNCTIONS ***************************************/\r\n    /************************************************************************************************/\r\n\r\n\r\n    /**************************************** Token Transfers ***************************************/\r\n    /**\r\n     * @dev Perform the transfer of tokens.\r\n   * @param from Token holder.\r\n   * @param to Token recipient.\r\n   * @param value Number of tokens to transfer.\r\n   */\r\n    function _transferWithData(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    )\r\n    internal\r\n    isNotMigratedToken\r\n    {\r\n        require(_isMultiple(value), \"50\"); // 0x50  transfer failure\r\n        require(to != address(0), \"57\"); // 0x57    invalid receiver\r\n        require(_balances[from] >= value, \"52\"); // 0x52    insufficient balance\r\n\r\n        _balances[from] = _balances[from] - value;\r\n        _balances[to] = _balances[to] + value;\r\n\r\n        emit Transfer(from, to, value); // ERC20 retrocompatibility\r\n    }\r\n    /**\r\n     * @dev Transfer tokens from a specific partition.\r\n   * @param fromPartition Partition of the tokens to transfer.\r\n   * @param operator The address performing the transfer.\r\n   * @param from Token holder.\r\n   * @param to Token recipient.\r\n   * @param value Number of tokens to transfer.\r\n   * @param data Information attached to the transfer. [CAN CONTAIN THE DESTINATION PARTITION]\r\n   * @param operatorData Information attached to the transfer, by the operator (if any).\r\n   * @return Destination partition.\r\n   */\r\n    function _transferByPartition(\r\n        bytes32 fromPartition,\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256 value,\r\n        bytes memory data,\r\n        bytes memory operatorData\r\n    )\r\n    internal\r\n    returns (bytes32)\r\n    {\r\n        require(_balanceOfByPartition[from][fromPartition] >= value, \"52\"); // 0x52 insufficient balance\r\n\r\n        bytes32 toPartition = fromPartition;\r\n\r\n        if(operatorData.length != 0 && data.length >= 64) {\r\n            toPartition = _getDestinationPartition(fromPartition, data);\r\n        }\r\n\r\n        _callSenderExtension(fromPartition, operator, from, to, value, data, operatorData);\r\n        _callTokenExtension(fromPartition, operator, from, to, value, data, operatorData);\r\n\r\n        _removeTokenFromPartition(from, fromPartition, value);\r\n        _transferWithData(from, to, value);\r\n        _addTokenToPartition(to, toPartition, value);\r\n\r\n        _callRecipientExtension(toPartition, operator, from, to, value, data, operatorData);\r\n\r\n        emit TransferByPartition(fromPartition, operator, from, to, value, data, operatorData);\r\n\r\n        if(toPartition != fromPartition) {\r\n            emit ChangedPartition(fromPartition, toPartition, value);\r\n        }\r\n\r\n        return toPartition;\r\n    }\r\n    /**\r\n     * @dev Transfer tokens from default partitions.\r\n   * Function used for ERC20 retrocompatibility.\r\n   * @param operator The address performing the transfer.\r\n   * @param from Token holder.\r\n   * @param to Token recipient.\r\n   * @param value Number of tokens to transfer.\r\n   * @param data Information attached to the transfer, and intended for the token holder ('from') [CAN CONTAIN THE DESTINATION PARTITION].\r\n   */\r\n    function _transferByDefaultPartitions(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256 value,\r\n        bytes memory data\r\n    )\r\n    internal\r\n    {\r\n        require(_defaultPartitions.length != 0, \"55\"); // // 0x55   funds locked (lockup period)\r\n\r\n        uint256 _remainingValue = value;\r\n        uint256 _localBalance;\r\n\r\n        for (uint i = 0; i < _defaultPartitions.length; i++) {\r\n            _localBalance = _balanceOfByPartition[from][_defaultPartitions[i]];\r\n            if(_remainingValue <= _localBalance) {\r\n                _transferByPartition(_defaultPartitions[i], operator, from, to, _remainingValue, data, \"\");\r\n                _remainingValue = 0;\r\n                break;\r\n            } else if (_localBalance != 0) {\r\n                _transferByPartition(_defaultPartitions[i], operator, from, to, _localBalance, data, \"\");\r\n                _remainingValue = _remainingValue - _localBalance;\r\n            }\r\n        }\r\n\r\n        require(_remainingValue == 0, \"52\"); // 0x52    insufficient balance\r\n    }\r\n    /**\r\n     * @dev Retrieve the destination partition from the 'data' field.\r\n   * By convention, a partition change is requested ONLY when 'data' starts\r\n   * with the flag: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\r\n   * When the flag is detected, the destination tranche is extracted from the\r\n   * 32 bytes following the flag.\r\n   * @param fromPartition Partition of the tokens to transfer.\r\n   * @param data Information attached to the transfer. [CAN CONTAIN THE DESTINATION PARTITION]\r\n   * @return toPartition Destination partition.\r\n   */\r\n    function _getDestinationPartition(bytes32 fromPartition, bytes memory data) internal pure returns(bytes32 toPartition) {\r\n        bytes32 changePartitionFlag = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\r\n        bytes32 flag;\r\n        assembly {\r\n            flag := mload(add(data, 32))\r\n        }\r\n        if(flag == changePartitionFlag) {\r\n            assembly {\r\n                toPartition := mload(add(data, 64))\r\n            }\r\n        } else {\r\n            toPartition = fromPartition;\r\n        }\r\n    }\r\n    /**\r\n     * @dev Remove a token from a specific partition.\r\n   * @param from Token holder.\r\n   * @param partition Name of the partition.\r\n   * @param value Number of tokens to transfer.\r\n   */\r\n    function _removeTokenFromPartition(address from, bytes32 partition, uint256 value) internal {\r\n        _balanceOfByPartition[from][partition] = _balanceOfByPartition[from][partition]- value;\r\n        _totalSupplyByPartition[partition] = _totalSupplyByPartition[partition] - value;\r\n\r\n        // If the total supply is zero, finds and deletes the partition.\r\n        if(_totalSupplyByPartition[partition] == 0) {\r\n            uint256 index1 = _indexOfTotalPartitions[partition];\r\n            require(index1 > 0, \"50\"); // 0x50  transfer failure\r\n\r\n            // move the last item into the index being vacated\r\n            bytes32 lastValue = _totalPartitions[_totalPartitions.length - 1];\r\n            _totalPartitions[index1 - 1] = lastValue; // adjust for 1-based indexing\r\n            _indexOfTotalPartitions[lastValue] = index1;\r\n\r\n            //_totalPartitions.length -= 1;\r\n            _totalPartitions.pop();\r\n            _indexOfTotalPartitions[partition] = 0;\r\n        }\r\n\r\n        // If the balance of the TokenHolder's partition is zero, finds and deletes the partition.\r\n        if(_balanceOfByPartition[from][partition] == 0) {\r\n            uint256 index2 = _indexOfPartitionsOf[from][partition];\r\n            require(index2 > 0, \"50\"); // 0x50  transfer failure\r\n\r\n            // move the last item into the index being vacated\r\n            bytes32 lastValue = _partitionsOf[from][_partitionsOf[from].length - 1];\r\n            _partitionsOf[from][index2 - 1] = lastValue;  // adjust for 1-based indexing\r\n            _indexOfPartitionsOf[from][lastValue] = index2;\r\n\r\n            //_partitionsOf[from].length -= 1;\r\n            _partitionsOf[from].pop();\r\n            _indexOfPartitionsOf[from][partition] = 0;\r\n        }\r\n    }\r\n    /**\r\n     * @dev Add a token to a specific partition.\r\n   * @param to Token recipient.\r\n   * @param partition Name of the partition.\r\n   * @param value Number of tokens to transfer.\r\n   */\r\n    function _addTokenToPartition(address to, bytes32 partition, uint256 value) internal {\r\n        if(value != 0) {\r\n            if (_indexOfPartitionsOf[to][partition] == 0) {\r\n                _partitionsOf[to].push(partition);\r\n                _indexOfPartitionsOf[to][partition] = _partitionsOf[to].length;\r\n            }\r\n            _balanceOfByPartition[to][partition] = _balanceOfByPartition[to][partition] + value;\r\n\r\n            if (_indexOfTotalPartitions[partition] == 0) {\r\n                _totalPartitions.push(partition);\r\n                _indexOfTotalPartitions[partition] = _totalPartitions.length;\r\n            }\r\n            _totalSupplyByPartition[partition] = _totalSupplyByPartition[partition] + value;\r\n        }\r\n    }\r\n    /**\r\n     * @dev Check if 'value' is multiple of the granularity.\r\n   * @param value The quantity that want's to be checked.\r\n   * @return 'true' if 'value' is a multiple of the granularity.\r\n   */\r\n    function _isMultiple(uint256 value) internal view returns(bool) {\r\n        return(uint256(value / _granularity) * _granularity == value);\r\n    }\r\n    /************************************************************************************************/\r\n\r\n\r\n    /****************************************** Hooks ***********************************************/\r\n    /**\r\n     * @dev Check for 'ERC1400TokensSender' user extension in ERC1820 registry and call it.\r\n   * @param partition Name of the partition (bytes32 to be left empty for transfers where partition is not specified).\r\n   * @param operator Address which triggered the balance decrease (through transfer or redemption).\r\n   * @param from Token holder.\r\n   * @param to Token recipient for a transfer and 0x for a redemption.\r\n   * @param value Number of tokens the token holder balance is decreased by.\r\n   * @param data Extra information.\r\n   * @param operatorData Extra information, attached by the operator (if any).\r\n   */\r\n    function _callSenderExtension(\r\n        bytes32 partition,\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256 value,\r\n        bytes memory data,\r\n        bytes memory operatorData\r\n    )\r\n    internal\r\n    {\r\n        address senderImplementation;\r\n        senderImplementation = interfaceAddr(from, ERC1400_TOKENS_SENDER);\r\n        if (senderImplementation != address(0)) {\r\n            IERC1400TokensSender(senderImplementation).tokensToTransfer(msg.data, partition, operator, from, to, value, data, operatorData);\r\n        }\r\n    }\r\n    /**\r\n     * @dev Check for 'ERC1400TokensValidator' token extension in ERC1820 registry and call it.\r\n   * @param partition Name of the partition (bytes32 to be left empty for transfers where partition is not specified).\r\n   * @param operator Address which triggered the balance decrease (through transfer or redemption).\r\n   * @param from Token holder.\r\n   * @param to Token recipient for a transfer and 0x for a redemption.\r\n   * @param value Number of tokens the token holder balance is decreased by.\r\n   * @param data Extra information.\r\n   * @param operatorData Extra information, attached by the operator (if any).\r\n   */\r\n    function _callTokenExtension(\r\n        bytes32 partition,\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256 value,\r\n        bytes memory data,\r\n        bytes memory operatorData\r\n    )\r\n    internal\r\n    {\r\n        address validatorImplementation;\r\n        validatorImplementation = interfaceAddr(address(this), ERC1400_TOKENS_VALIDATOR);\r\n        if (validatorImplementation != address(0)) {\r\n            IERC1400TokensValidator(validatorImplementation).tokensToValidate(msg.data, partition, operator, from, to, value, data, operatorData);\r\n        }\r\n    }\r\n    /**\r\n     * @dev Check for 'ERC1400TokensRecipient' user extension in ERC1820 registry and call it.\r\n   * @param partition Name of the partition (bytes32 to be left empty for transfers where partition is not specified).\r\n   * @param operator Address which triggered the balance increase (through transfer or issuance).\r\n   * @param from Token holder for a transfer and 0x for an issuance.\r\n   * @param to Token recipient.\r\n   * @param value Number of tokens the recipient balance is increased by.\r\n   * @param data Extra information, intended for the token holder ('from').\r\n   * @param operatorData Extra information attached by the operator (if any).\r\n   */\r\n    function _callRecipientExtension(\r\n        bytes32 partition,\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256 value,\r\n        bytes memory data,\r\n        bytes memory operatorData\r\n    )\r\n    internal\r\n    virtual\r\n    {\r\n        address recipientImplementation;\r\n        recipientImplementation = interfaceAddr(to, ERC1400_TOKENS_RECIPIENT);\r\n\r\n        if (recipientImplementation != address(0)) {\r\n            IERC1400TokensRecipient(recipientImplementation).tokensReceived(msg.data, partition, operator, from, to, value, data, operatorData);\r\n        }\r\n    }\r\n    /************************************************************************************************/\r\n\r\n\r\n    /************************************* Operator Information *************************************/\r\n    /**\r\n     * @dev Indicate whether the operator address is an operator of the tokenHolder address.\r\n   * @param operator Address which may be an operator of 'tokenHolder'.\r\n   * @param tokenHolder Address of a token holder which may have the 'operator' address as an operator.\r\n   * @return 'true' if 'operator' is an operator of 'tokenHolder' and 'false' otherwise.\r\n   */\r\n    function _isOperator(address operator, address tokenHolder) internal view returns (bool) {\r\n        return (operator == tokenHolder\r\n        || _authorizedOperator[operator][tokenHolder]\r\n        || (_isControllable && _isController[operator])\r\n        );\r\n    }\r\n    /**\r\n     * @dev Indicate whether the operator address is an operator of the tokenHolder\r\n   * address for the given partition.\r\n   * @param partition Name of the partition.\r\n   * @param operator Address which may be an operator of tokenHolder for the given partition.\r\n   * @param tokenHolder Address of a token holder which may have the operator address as an operator for the given partition.\r\n   * @return 'true' if 'operator' is an operator of 'tokenHolder' for partition 'partition' and 'false' otherwise.\r\n   */\r\n    function _isOperatorForPartition(bytes32 partition, address operator, address tokenHolder) internal view returns (bool) {\r\n        return (_isOperator(operator, tokenHolder)\r\n        || _authorizedOperatorByPartition[tokenHolder][partition][operator]\r\n        || (_isControllable && _isControllerByPartition[partition][operator])\r\n        );\r\n    }\r\n    /************************************************************************************************/\r\n\r\n\r\n    /**************************************** Token Issuance ****************************************/\r\n    /**\r\n     * @dev Perform the issuance of tokens.\r\n   * @param operator Address which triggered the issuance.\r\n   * @param to Token recipient.\r\n   * @param value Number of tokens issued.\r\n   * @param data Information attached to the issuance, and intended for the recipient (to).\r\n   */\r\n    function _issue(address operator, address to, uint256 value, bytes memory data)\r\n    internal\r\n    isNotMigratedToken\r\n    {\r\n        require(_isMultiple(value), \"50\"); // 0x50  transfer failure\r\n        require(to != address(0), \"57\"); // 0x57    invalid receiver\r\n\r\n        _totalSupply = _totalSupply + value;\r\n        _balances[to] = _balances[to] + value;\r\n\r\n        emit Issued(operator, to, value, data);\r\n        emit Transfer(address(0), to, value); // ERC20 retrocompatibility\r\n    }\r\n    /**\r\n     * @dev Issue tokens from a specific partition.\r\n   * @param toPartition Name of the partition.\r\n   * @param operator The address performing the issuance.\r\n   * @param to Token recipient.\r\n   * @param value Number of tokens to issue.\r\n   * @param data Information attached to the issuance.\r\n   */\r\n    function _issueByPartition(\r\n        bytes32 toPartition,\r\n        address operator,\r\n        address to,\r\n        uint256 value,\r\n        bytes memory data\r\n    )\r\n    internal\r\n    {\r\n        _callTokenExtension(toPartition, operator, address(0), to, value, data, \"\");\r\n\r\n        _issue(operator, to, value, data);\r\n        _addTokenToPartition(to, toPartition, value);\r\n\r\n        _callRecipientExtension(toPartition, operator, address(0), to, value, data, \"\");\r\n\r\n        emit IssuedByPartition(toPartition, operator, to, value, data, \"\");\r\n    }\r\n    /************************************************************************************************/\r\n\r\n\r\n    /*************************************** Token Redemption ***************************************/\r\n    /**\r\n     * @dev Perform the token redemption.\r\n   * @param operator The address performing the redemption.\r\n   * @param from Token holder whose tokens will be redeemed.\r\n   * @param value Number of tokens to redeem.\r\n   * @param data Information attached to the redemption.\r\n   */\r\n    function _redeem(address operator, address from, uint256 value, bytes memory data)\r\n    internal\r\n    isNotMigratedToken\r\n    {\r\n        require(_isMultiple(value), \"50\"); // 0x50  transfer failure\r\n        require(from != address(0), \"56\"); // 0x56  invalid sender\r\n        require(_balances[from] >= value, \"52\"); // 0x52    insufficient balance\r\n\r\n        _balances[from] = _balances[from] - value;\r\n        _totalSupply = _totalSupply - value;\r\n\r\n        emit Redeemed(operator, from, value, data);\r\n        emit Transfer(from, address(0), value);  // ERC20 retrocompatibility\r\n    }\r\n    /**\r\n     * @dev Redeem tokens of a specific partition.\r\n   * @param fromPartition Name of the partition.\r\n   * @param operator The address performing the redemption.\r\n   * @param from Token holder whose tokens will be redeemed.\r\n   * @param value Number of tokens to redeem.\r\n   * @param data Information attached to the redemption.\r\n   * @param operatorData Information attached to the redemption, by the operator (if any).\r\n   */\r\n    function _redeemByPartition(\r\n        bytes32 fromPartition,\r\n        address operator,\r\n        address from,\r\n        uint256 value,\r\n        bytes memory data,\r\n        bytes memory operatorData\r\n    )\r\n    internal\r\n    {\r\n        require(_balanceOfByPartition[from][fromPartition] >= value, \"52\"); // 0x52 insufficient balance\r\n\r\n        _callSenderExtension(fromPartition, operator, from, address(0), value, data, operatorData);\r\n        _callTokenExtension(fromPartition, operator, from, address(0), value, data, operatorData);\r\n\r\n        _removeTokenFromPartition(from, fromPartition, value);\r\n        _redeem(operator, from, value, data);\r\n\r\n        emit RedeemedByPartition(fromPartition, operator, from, value, operatorData);\r\n    }\r\n    /**\r\n     * @dev Redeem tokens from a default partitions.\r\n   * @param operator The address performing the redeem.\r\n   * @param from Token holder.\r\n   * @param value Number of tokens to redeem.\r\n   * @param data Information attached to the redemption.\r\n   */\r\n    function _redeemByDefaultPartitions(\r\n        address operator,\r\n        address from,\r\n        uint256 value,\r\n        bytes memory data\r\n    )\r\n    internal\r\n    {\r\n        require(_defaultPartitions.length != 0, \"55\"); // 0x55  funds locked (lockup period)\r\n\r\n        uint256 _remainingValue = value;\r\n        uint256 _localBalance;\r\n\r\n        for (uint i = 0; i < _defaultPartitions.length; i++) {\r\n            _localBalance = _balanceOfByPartition[from][_defaultPartitions[i]];\r\n            if(_remainingValue <= _localBalance) {\r\n                _redeemByPartition(_defaultPartitions[i], operator, from, _remainingValue, data, \"\");\r\n                _remainingValue = 0;\r\n                break;\r\n            } else {\r\n                _redeemByPartition(_defaultPartitions[i], operator, from, _localBalance, data, \"\");\r\n                _remainingValue = _remainingValue - _localBalance;\r\n            }\r\n        }\r\n\r\n        require(_remainingValue == 0, \"52\"); // 0x52    insufficient balance\r\n    }\r\n    /************************************************************************************************/\r\n\r\n\r\n    /************************************** Transfer Validity ***************************************/\r\n    /**\r\n     * @dev Know the reason on success or failure based on the EIP-1066 application-specific status codes.\r\n   * @param payload Payload of the initial transaction.\r\n   * @param partition Name of the partition.\r\n   * @param operator The address performing the transfer.\r\n   * @param from Token holder.\r\n   * @param to Token recipient.\r\n   * @param value Number of tokens to transfer.\r\n   * @param data Information attached to the transfer. [CAN CONTAIN THE DESTINATION PARTITION]\r\n   * @param operatorData Information attached to the transfer, by the operator (if any).\r\n   * @return ESC (Ethereum Status Code) following the EIP-1066 standard.\r\n   * @return Additional bytes32 parameter that can be used to define\r\n   * application specific reason codes with additional details (for example the\r\n   * transfer restriction rule responsible for making the transfer operation invalid).\r\n   * @return Destination partition.\r\n   */\r\n    function _canTransfer(bytes memory payload, bytes32 partition, address operator, address from, address to, uint256 value, bytes memory data, bytes memory operatorData)\r\n    internal\r\n    view\r\n    returns (bytes1, bytes32, bytes32)\r\n    {\r\n        address checksImplementation = interfaceAddr(address(this), ERC1400_TOKENS_CHECKER);\r\n\r\n        if((checksImplementation != address(0))) {\r\n            return IERC1400TokensChecker(checksImplementation).canTransferByPartition(payload, partition, operator, from, to, value, data, operatorData);\r\n        }\r\n        else {\r\n            return(hex\"00\", \"\", partition);\r\n        }\r\n    }\r\n    /************************************************************************************************/\r\n\r\n\r\n    /************************************************************************************************/\r\n    /************************ INTERNAL FUNCTIONS (ADDITIONAL - NOT MANDATORY) ***********************/\r\n    /************************************************************************************************/\r\n\r\n\r\n    /************************************ Token controllers *****************************************/\r\n    /**\r\n     * @dev Set list of token controllers.\r\n   * @param operators Controller addresses.\r\n   */\r\n    function _setControllers(address[] memory operators) internal {\r\n        for (uint i = 0; i<_controllers.length; i++){\r\n            _isController[_controllers[i]] = false;\r\n        }\r\n        for (uint j = 0; j<operators.length; j++){\r\n            _isController[operators[j]] = true;\r\n        }\r\n        _controllers = operators;\r\n    }\r\n    /**\r\n     * @dev Set list of token partition controllers.\r\n   * @param partition Name of the partition.\r\n   * @param operators Controller addresses.\r\n   */\r\n    function _setPartitionControllers(bytes32 partition, address[] memory operators) internal {\r\n        for (uint i = 0; i<_controllersByPartition[partition].length; i++){\r\n            _isControllerByPartition[partition][_controllersByPartition[partition][i]] = false;\r\n        }\r\n        for (uint j = 0; j<operators.length; j++){\r\n            _isControllerByPartition[partition][operators[j]] = true;\r\n        }\r\n        _controllersByPartition[partition] = operators;\r\n    }\r\n    /************************************************************************************************/\r\n\r\n\r\n    /************************************** Token extension *****************************************/\r\n    /**\r\n     * @dev Set token extension contract address.\r\n   * The extension contract can for example verify \"ERC1400TokensValidator\" or \"ERC1400TokensChecker\" interfaces.\r\n   * If the extension is an \"ERC1400TokensValidator\", it will be called everytime a transfer is executed.\r\n   * @param extension Address of the extension contract.\r\n   * @param interfaceLabel Interface label of extension contract.\r\n   * @param removeOldExtensionRoles If set to 'true', the roles of the old extension(minter, controller) will be removed extension.\r\n   * @param addMinterRoleForExtension If set to 'true', the extension contract will be added as minter.\r\n   * @param addControllerRoleForExtension If set to 'true', the extension contract will be added as controller.\r\n   */\r\n    function _setTokenExtension(address extension, string memory interfaceLabel, bool removeOldExtensionRoles, bool addMinterRoleForExtension, bool addControllerRoleForExtension) internal {\r\n        address oldExtension = interfaceAddr(address(this), interfaceLabel);\r\n\r\n        if (oldExtension != address(0) && removeOldExtensionRoles) {\r\n            if(isMinter(oldExtension)) {\r\n                _removeMinter(oldExtension);\r\n            }\r\n            _isController[oldExtension] = false;\r\n        }\r\n\r\n        ERC1820Client.setInterfaceImplementation(interfaceLabel, extension);\r\n        if(addMinterRoleForExtension && !isMinter(extension)) {\r\n            _addMinter(extension);\r\n        }\r\n        if (addControllerRoleForExtension) {\r\n            _isController[extension] = true;\r\n        }\r\n    }\r\n    /************************************************************************************************/\r\n\r\n\r\n    /************************************* Token migration ******************************************/\r\n    /**\r\n     * @dev Migrate contract.\r\n   *\r\n   * ===> CAUTION: DEFINITIVE ACTION\r\n   *\r\n   * This function shall be called once a new version of the smart contract has been created.\r\n   * Once this function is called:\r\n   *  - The address of the new smart contract is set in ERC1820 registry\r\n   *  - If the choice is definitive, the current smart contract is turned off and can never be used again\r\n   *\r\n   * @param newContractAddress Address of the new version of the smart contract.\r\n   * @param definitive If set to 'true' the contract is turned off definitely.\r\n   */\r\n    function _migrate(address newContractAddress, bool definitive) internal {\r\n        ERC1820Client.setInterfaceImplementation(ERC20_INTERFACE_NAME, newContractAddress);\r\n        ERC1820Client.setInterfaceImplementation(ERC1400_INTERFACE_NAME, newContractAddress);\r\n        if(definitive) {\r\n            _migrated = true;\r\n        }\r\n    }\r\n    /************************************************************************************************/\r\n\r\n    /************************************* Domain Aware ******************************************/\r\n    function domainName() public override view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function domainVersion() public override pure returns (string memory) {\r\n        return \"1\";\r\n    }\r\n    /************************************************************************************************/\r\n}\r\n\r\n/**\r\n * @notice Interface to the extension types\r\n */\r\ninterface IExtensionTypes {\r\n    enum CertificateValidation {\r\n        None,\r\n        NonceBased,\r\n        SaltBased\r\n    }\r\n}\r\n\r\n/**\r\n * @notice Interface to the extension contract\r\n */\r\nabstract contract Extension is IExtensionTypes {\r\n    function registerTokenSetup(\r\n        address token,\r\n        CertificateValidation certificateActivated,\r\n        bool allowlistActivated,\r\n        bool blocklistActivated,\r\n        bool granularityByPartitionActivated,\r\n        bool holdsActivated,\r\n        address[] calldata operators\r\n    ) external virtual;\r\n\r\n    function addCertificateSigner(\r\n        address token,\r\n        address account\r\n    ) external virtual;\r\n}\r\n\r\ncontract BPGT is ERC1400, IExtensionTypes {\r\n\r\n    uint256 public constant ISSUED_TOKENS = 148_705_100 * 10 ** 18;\r\n    uint256 public constant FOR_SALE_TOKENS = 104_093_570 * 10 ** 18;\r\n\r\n    bytes32 public constant BPGT_DEFAULT_PARTITION = keccak256(abi.encodePacked(\"BPGT_DEFAULT_PARTITION\"));\r\n\r\n    bytes32[] private BPGT_DEFAULT_PARTITIONS = [bytes32(BPGT_DEFAULT_PARTITION)];\r\n    uint256 constant private GRANULARITY = 1;\r\n\r\n    /**\r\n     * @dev Initialize ERC1400.\r\n   * @param newOwner Address whom contract ownership shall be transferred to.\r\n   * @param seller Address who will sell tokens.\r\n   */\r\n    constructor(\r\n        address newOwner,\r\n        address seller\r\n    )\r\n    ERC1400(\"Blockchain Property Gate\", \"BPGT\", GRANULARITY, BPGT_DEFAULT_PARTITIONS)\r\n    {\r\n        require(newOwner != address(0), \"BPGT: wrong address\");\r\n        require(seller != address(0), \"BPGT: wrong address\");\r\n\r\n        transferOwnership(newOwner);\r\n\r\n        _issueByPartition(BPGT_DEFAULT_PARTITION, msg.sender, newOwner, ISSUED_TOKENS, \"\");\r\n        _isIssuable = true;\r\n\r\n        _transferByDefaultPartitions(msg.sender, newOwner, seller, FOR_SALE_TOKENS, \"\");\r\n    }\r\n\r\n    /**\r\n     * @dev Initialize extension.\r\n   * @param extension Address of token extension.\r\n   * @param certificateSigner Address of the off-chain service which signs the\r\n   * conditional ownership certificates required for token transfers, issuance,\r\n   * redemption (Cf. CertificateController.sol).\r\n   * @param certificateActivated If set to 'true', the certificate controller\r\n   * is activated at contract creation.\r\n   * @param controllers_ Array of initial controllers.\r\n   */\r\n    function initExtention(\r\n        address extension,\r\n        address certificateSigner,\r\n        CertificateValidation certificateActivated,\r\n        address[] memory controllers_\r\n    ) external onlyOwner\r\n    {\r\n        if(extension != address(0)) {\r\n            Extension(extension).registerTokenSetup(\r\n                address(this), // token\r\n                certificateActivated, // certificateActivated\r\n                true, // allowlistActivated\r\n                true, // blocklistActivated\r\n                true, // granularityByPartitionActivated\r\n                true, // holdsActivated\r\n                controllers_ // token controllers\r\n            );\r\n\r\n            if(certificateSigner != address(0)) {\r\n                Extension(extension).addCertificateSigner(address(this), certificateSigner);\r\n            }\r\n\r\n            _setTokenExtension(extension, ERC1400_TOKENS_VALIDATOR, true, true, true);\r\n        }\r\n        _setControllers(controllers_);\r\n\r\n    }\r\n\r\n\r\n    /************************************** Transfer Validity ***************************************/\r\n    /**\r\n     * @dev Know the reason on success or failure based on the EIP-1066 application-specific status codes.\r\n   * @param partition Name of the partition.\r\n   * @param to Token recipient.\r\n   * @param value Number of tokens to transfer.\r\n   * @param data Information attached to the transfer, by the token holder. [CONTAINS THE CONDITIONAL OWNERSHIP CERTIFICATE]\r\n   * @return ESC (Ethereum Status Code) following the EIP-1066 standard.\r\n   * @return Additional bytes32 parameter that can be used to define\r\n   * application specific reason codes with additional details (for example the\r\n   * transfer restriction rule responsible for making the transfer operation invalid).\r\n   * @return Destination partition.\r\n   */\r\n    function canTransferByPartition(bytes32 partition, address to, uint256 value, bytes calldata data)\r\n    external\r\n    view\r\n    returns (bytes1, bytes32, bytes32)\r\n    {\r\n        return ERC1400._canTransfer(\r\n            _replaceFunctionSelector(this.transferByPartition.selector, msg.data), // 0xf3d490db: 4 first bytes of keccak256(transferByPartition(bytes32,address,uint256,bytes))\r\n            partition,\r\n            msg.sender,\r\n            msg.sender,\r\n            to,\r\n            value,\r\n            data,\r\n            \"\"\r\n        );\r\n    }\r\n    /**\r\n     * @dev Know the reason on success or failure based on the EIP-1066 application-specific status codes.\r\n   * @param partition Name of the partition.\r\n   * @param from Token holder.\r\n   * @param to Token recipient.\r\n   * @param value Number of tokens to transfer.\r\n   * @param data Information attached to the transfer. [CAN CONTAIN THE DESTINATION PARTITION]\r\n   * @param operatorData Information attached to the transfer, by the operator. [CONTAINS THE CONDITIONAL OWNERSHIP CERTIFICATE]\r\n   * @return ESC (Ethereum Status Code) following the EIP-1066 standard.\r\n   * @return Additional bytes32 parameter that can be used to define\r\n   * application specific reason codes with additional details (for example the\r\n   * transfer restriction rule responsible for making the transfer operation invalid).\r\n   * @return Destination partition.\r\n   */\r\n    function canOperatorTransferByPartition(bytes32 partition, address from, address to, uint256 value, bytes calldata data, bytes calldata operatorData)\r\n    external\r\n    view\r\n    returns (bytes1, bytes32, bytes32)\r\n    {\r\n        return ERC1400._canTransfer(\r\n            _replaceFunctionSelector(this.operatorTransferByPartition.selector, msg.data), // 0x8c0dee9c: 4 first bytes of keccak256(operatorTransferByPartition(bytes32,address,address,uint256,bytes,bytes))\r\n            partition,\r\n            msg.sender,\r\n            from,\r\n            to,\r\n            value,\r\n            data,\r\n            operatorData\r\n        );\r\n    }\r\n    /**\r\n     * @dev Replace function selector\r\n   * @param functionSig Replacement function selector.\r\n   * @param payload Payload, where function selector needs to be replaced.\r\n   */\r\n    function _replaceFunctionSelector(bytes4 functionSig, bytes memory payload) internal pure returns(bytes memory) {\r\n        bytes memory updatedPayload = new bytes(payload.length);\r\n        for (uint i = 0; i<4; i++){\r\n            updatedPayload[i] = functionSig[i];\r\n        }\r\n        for (uint j = 4; j<payload.length; j++){\r\n            updatedPayload[j] = payload[j];\r\n        }\r\n        return updatedPayload;\r\n    }\r\n    /************************************************************************************************/\r\n\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"partition\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"ApprovalByPartition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenHolder\",\"type\":\"address\"}],\"name\":\"AuthorizedOperator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"partition\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenHolder\",\"type\":\"address\"}],\"name\":\"AuthorizedOperatorByPartition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"fromPartition\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"toPartition\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"ChangedPartition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"documentHash\",\"type\":\"bytes32\"}],\"name\":\"DocumentRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"documentHash\",\"type\":\"bytes32\"}],\"name\":\"DocumentUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"Issued\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"partition\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"IssuedByPartition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"MinterAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"MinterRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"Redeemed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"partition\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"RedeemedByPartition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenHolder\",\"type\":\"address\"}],\"name\":\"RevokedOperator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"partition\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenHolder\",\"type\":\"address\"}],\"name\":\"RevokedOperatorByPartition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"fromPartition\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"TransferByPartition\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BPGT_DEFAULT_PARTITION\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FOR_SALE_TOKENS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ISSUED_TOKENS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addMinter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"partition\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"ownerAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spenderAddr\",\"type\":\"address\"}],\"name\":\"allowanceByPartition\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"partition\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approveByPartition\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"authorizeOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"partition\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"authorizeOperatorByPartition\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenHolder\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"partition\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"tokenHolder\",\"type\":\"address\"}],\"name\":\"balanceOfByPartition\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"interfaceHash\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"canImplementInterfaceForAddress\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"partition\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"canOperatorTransferByPartition\",\"outputs\":[{\"internalType\":\"bytes1\",\"name\":\"\",\"type\":\"bytes1\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"partition\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"canTransferByPartition\",\"outputs\":[{\"internalType\":\"bytes1\",\"name\":\"\",\"type\":\"bytes1\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"controllers\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"partition\",\"type\":\"bytes32\"}],\"name\":\"controllersByPartition\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"domainName\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"domainSeparator\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"domainVersion\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"generateDomainSeparator\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllDocuments\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDefaultPartitions\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"shortName\",\"type\":\"bytes32\"}],\"name\":\"getDocument\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"granularity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"extension\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"certificateSigner\",\"type\":\"address\"},{\"internalType\":\"enum IExtensionTypes.CertificateValidation\",\"name\":\"certificateActivated\",\"type\":\"uint8\"},{\"internalType\":\"address[]\",\"name\":\"controllers_\",\"type\":\"address[]\"}],\"name\":\"initExtention\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isControllable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isIssuable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isMinter\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenHolder\",\"type\":\"address\"}],\"name\":\"isOperator\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"partition\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenHolder\",\"type\":\"address\"}],\"name\":\"isOperatorForPartition\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenHolder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"issue\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"partition\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"tokenHolder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"issueByPartition\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newContractAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"definitive\",\"type\":\"bool\"}],\"name\":\"migrate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"partition\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"tokenHolder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"operatorRedeemByPartition\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"partition\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"operatorTransferByPartition\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenHolder\",\"type\":\"address\"}],\"name\":\"partitionsOf\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"redeem\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"partition\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"redeemByPartition\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"redeemFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"shortName\",\"type\":\"bytes32\"}],\"name\":\"removeDocument\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"removeMinter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceControl\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceIssuance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceMinter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"revokeOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"partition\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"revokeOperatorByPartition\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"operators\",\"type\":\"address[]\"}],\"name\":\"setControllers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"partitions\",\"type\":\"bytes32[]\"}],\"name\":\"setDefaultPartitions\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"shortName\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"},{\"internalType\":\"bytes32\",\"name\":\"documentHash\",\"type\":\"bytes32\"}],\"name\":\"setDocument\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"partition\",\"type\":\"bytes32\"},{\"internalType\":\"address[]\",\"name\":\"operators\",\"type\":\"address[]\"}],\"name\":\"setPartitionControllers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"extension\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"interfaceLabel\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"removeOldExtensionRoles\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"addMinterRoleForExtension\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"addControllerRoleForExtension\",\"type\":\"bool\"}],\"name\":\"setTokenExtension\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalPartitions\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"partition\",\"type\":\"bytes32\"}],\"name\":\"totalSupplyByPartition\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"partition\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"transferByPartition\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"transferFromWithData\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"transferWithData\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "BPGT", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000009c1258c3cd66a4b35a9e208229f49cca0d28f634000000000000000000000000c7a5768a97f622c974600e5af79205526a906dd4", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://b64184925c1894a61337eb01b89d084f6a88b09623cabf821aa00565857d10bb"}