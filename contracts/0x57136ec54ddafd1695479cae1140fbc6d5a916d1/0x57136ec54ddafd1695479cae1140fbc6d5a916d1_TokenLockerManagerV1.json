{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/ITokenLockerManagerV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface ITokenLockerManagerV1 {\\r\\n  function tokenLockerCount() external view returns (uint40);\\r\\n  function lpLockerCount() external view returns (uint40);\\r\\n  function creationEnabled() external view returns (bool);\\r\\n  function setCreationEnabled(bool value_) external;\\r\\n  function createTokenLocker(\\r\\n    address tokenAddress_,\\r\\n    uint256 amount_,\\r\\n    uint40 unlockTime_\\r\\n  ) external payable;\\r\\n  function createLpLocker(\\r\\n    address tokenAddress_,\\r\\n    uint256 amount_,\\r\\n    uint40 unlockTime_\\r\\n  ) external payable;\\r\\n  function getTokenLockAddress(uint40 id_) external view returns (address);\\r\\n  function getLpLockAddress(uint40 id_) external view returns (address);\\r\\n  function getTokenLockData(uint40 id_) external view returns (\\r\\n    bool isLpToken,\\r\\n    uint40 id,\\r\\n    address contractAddress,\\r\\n    address lockOwner,\\r\\n    address token,\\r\\n    address createdBy,\\r\\n    uint40 createdAt,\\r\\n    uint40 blockTime,\\r\\n    uint40 unlockTime,\\r\\n    uint256 balance,\\r\\n    uint256 totalSupply\\r\\n  );\\r\\n  function getLpLockData(uint40 id_) external view returns (\\r\\n    bool isLpToken,\\r\\n    uint40 id,\\r\\n    address contractAddress,\\r\\n    address lockOwner,\\r\\n    address token,\\r\\n    address createdBy,\\r\\n    uint40 createdAt,\\r\\n    uint40 blockTime,\\r\\n    uint40 unlockTime,\\r\\n    uint256 balance,\\r\\n    uint256 totalSupply\\r\\n  );\\r\\n  function getLpData(uint40 id_) external view returns (\\r\\n    bool hasLpData,\\r\\n    uint40 id,\\r\\n    address token0,\\r\\n    address token1,\\r\\n    uint256 balance0,\\r\\n    uint256 balance1,\\r\\n    uint256 price0,\\r\\n    uint256 price1\\r\\n  );\\r\\n  function getTokenLockersForAddress(address address_) external view returns (uint40[] memory);\\r\\n  function getLpLockersForAddress(address address_) external view returns (uint40[] memory);\\r\\n  function notifyTokenLockerOwnerChange(uint40 id_, address newOwner_, address previousOwner_, address createdBy_) external;\\r\\n  function notifyLpLockerOwnerChange(uint40 id_, address newOwner_, address previousOwner_, address createdBy_) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/library/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts v4.3.2 (utils/Context.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Provides information about the current execution context, including the\\r\\n * sender of the transaction and its data. While these are generally available\\r\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\r\\n * manner, since when dealing with meta-transactions the account sending and\\r\\n * paying for execution may not be the actual sender (as far as an application\\r\\n * is concerned).\\r\\n *\\r\\n * This contract is only required for intermediate, library-like contracts.\\r\\n */\\r\\nabstract contract Context {\\r\\n    function _msgSender() internal view virtual returns (address) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n\\r\\n    function _msgData() internal view virtual returns (bytes calldata) {\\r\\n        return msg.data;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/library/Dex.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity >=0.6.2;\\r\\n\\r\\ninterface IUniswapV2Factory {\\r\\n  event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\r\\n\\r\\n  function feeTo() external view returns (address);\\r\\n  function feeToSetter() external view returns (address);\\r\\n\\r\\n  function getPair(address tokenA, address tokenB) external view returns (address pair);\\r\\n  function allPairs(uint) external view returns (address pair);\\r\\n  function allPairsLength() external view returns (uint);\\r\\n\\r\\n  function createPair(address tokenA, address tokenB) external returns (address pair);\\r\\n\\r\\n  function setFeeTo(address) external;\\r\\n  function setFeeToSetter(address) external;\\r\\n}\\r\\n\\r\\ninterface IUniswapV2Pair {\\r\\n  event Approval(address indexed owner, address indexed spender, uint value);\\r\\n  event Transfer(address indexed from, address indexed to, uint value);\\r\\n\\r\\n  function name() external pure returns (string memory);\\r\\n  function symbol() external pure returns (string memory);\\r\\n  function decimals() external pure returns (uint8);\\r\\n  function totalSupply() external view returns (uint);\\r\\n  function balanceOf(address owner) external view returns (uint);\\r\\n  function allowance(address owner, address spender) external view returns (uint);\\r\\n\\r\\n  function approve(address spender, uint value) external returns (bool);\\r\\n  function transfer(address to, uint value) external returns (bool);\\r\\n  function transferFrom(address from, address to, uint value) external returns (bool);\\r\\n\\r\\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\\r\\n  function PERMIT_TYPEHASH() external pure returns (bytes32);\\r\\n  function nonces(address owner) external view returns (uint);\\r\\n\\r\\n  function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\r\\n\\r\\n  event Mint(address indexed sender, uint amount0, uint amount1);\\r\\n  event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\r\\n  event Swap(\\r\\n    address indexed sender,\\r\\n    uint amount0In,\\r\\n    uint amount1In,\\r\\n    uint amount0Out,\\r\\n    uint amount1Out,\\r\\n    address indexed to\\r\\n  );\\r\\n  event Sync(uint112 reserve0, uint112 reserve1);\\r\\n\\r\\n  function MINIMUM_LIQUIDITY() external pure returns (uint);\\r\\n  function factory() external view returns (address);\\r\\n  function token0() external view returns (address);\\r\\n  function token1() external view returns (address);\\r\\n  function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\r\\n  function price0CumulativeLast() external view returns (uint);\\r\\n  function price1CumulativeLast() external view returns (uint);\\r\\n  function kLast() external view returns (uint);\\r\\n\\r\\n  function mint(address to) external returns (uint liquidity);\\r\\n  function burn(address to) external returns (uint amount0, uint amount1);\\r\\n  function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\r\\n  function skim(address to) external;\\r\\n  function sync() external;\\r\\n\\r\\n  function initialize(address, address) external;\\r\\n}\\r\\n\\r\\ninterface IUniswapV2Router01 {\\r\\n  function factory() external pure returns (address);\\r\\n  function WETH() external pure returns (address);\\r\\n\\r\\n  function addLiquidity(\\r\\n    address tokenA,\\r\\n    address tokenB,\\r\\n    uint amountADesired,\\r\\n    uint amountBDesired,\\r\\n    uint amountAMin,\\r\\n    uint amountBMin,\\r\\n    address to,\\r\\n    uint deadline\\r\\n  ) external returns (uint amountA, uint amountB, uint liquidity);\\r\\n  function addLiquidityETH(\\r\\n    address token,\\r\\n    uint amountTokenDesired,\\r\\n    uint amountTokenMin,\\r\\n    uint amountETHMin,\\r\\n    address to,\\r\\n    uint deadline\\r\\n  ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\r\\n  function removeLiquidity(\\r\\n    address tokenA,\\r\\n    address tokenB,\\r\\n    uint liquidity,\\r\\n    uint amountAMin,\\r\\n    uint amountBMin,\\r\\n    address to,\\r\\n    uint deadline\\r\\n  ) external returns (uint amountA, uint amountB);\\r\\n  function removeLiquidityETH(\\r\\n    address token,\\r\\n    uint liquidity,\\r\\n    uint amountTokenMin,\\r\\n    uint amountETHMin,\\r\\n    address to,\\r\\n    uint deadline\\r\\n  ) external returns (uint amountToken, uint amountETH);\\r\\n  function removeLiquidityWithPermit(\\r\\n    address tokenA,\\r\\n    address tokenB,\\r\\n    uint liquidity,\\r\\n    uint amountAMin,\\r\\n    uint amountBMin,\\r\\n    address to,\\r\\n    uint deadline,\\r\\n    bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n  ) external returns (uint amountA, uint amountB);\\r\\n  function removeLiquidityETHWithPermit(\\r\\n    address token,\\r\\n    uint liquidity,\\r\\n    uint amountTokenMin,\\r\\n    uint amountETHMin,\\r\\n    address to,\\r\\n    uint deadline,\\r\\n    bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n  ) external returns (uint amountToken, uint amountETH);\\r\\n  function swapExactTokensForTokens(\\r\\n    uint amountIn,\\r\\n    uint amountOutMin,\\r\\n    address[] calldata path,\\r\\n    address to,\\r\\n    uint deadline\\r\\n  ) external returns (uint[] memory amounts);\\r\\n  function swapTokensForExactTokens(\\r\\n    uint amountOut,\\r\\n    uint amountInMax,\\r\\n    address[] calldata path,\\r\\n    address to,\\r\\n    uint deadline\\r\\n  ) external returns (uint[] memory amounts);\\r\\n  function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\r\\n    external\\r\\n    payable\\r\\n    returns (uint[] memory amounts);\\r\\n  function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\r\\n    external\\r\\n    returns (uint[] memory amounts);\\r\\n  function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\r\\n    external\\r\\n    returns (uint[] memory amounts);\\r\\n  function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\r\\n    external\\r\\n    payable\\r\\n    returns (uint[] memory amounts);\\r\\n\\r\\n  function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\r\\n  function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\r\\n  function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\r\\n  function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\r\\n  function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\r\\n}\\r\\n\\r\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\r\\n  function removeLiquidityETHSupportingFeeOnTransferTokens(\\r\\n    address token,\\r\\n    uint liquidity,\\r\\n    uint amountTokenMin,\\r\\n    uint amountETHMin,\\r\\n    address to,\\r\\n    uint deadline\\r\\n  ) external returns (uint amountETH);\\r\\n  function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\r\\n    address token,\\r\\n    uint liquidity,\\r\\n    uint amountTokenMin,\\r\\n    uint amountETHMin,\\r\\n    address to,\\r\\n    uint deadline,\\r\\n    bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n  ) external returns (uint amountETH);\\r\\n\\r\\n  function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\r\\n    uint amountIn,\\r\\n    uint amountOutMin,\\r\\n    address[] calldata path,\\r\\n    address to,\\r\\n    uint deadline\\r\\n  ) external;\\r\\n  function swapExactETHForTokensSupportingFeeOnTransferTokens(\\r\\n    uint amountOutMin,\\r\\n    address[] calldata path,\\r\\n    address to,\\r\\n    uint deadline\\r\\n  ) external payable;\\r\\n  function swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n    uint amountIn,\\r\\n    uint amountOutMin,\\r\\n    address[] calldata path,\\r\\n    address to,\\r\\n    uint deadline\\r\\n  ) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/library/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.0.0/contracts/token/ERC20/IERC20.sol\\r\\ninterface IERC20 {\\r\\n  function name() external view returns (string memory);\\r\\n  function symbol() external view returns (string memory);\\r\\n  function totalSupply() external view returns (uint256);\\r\\n  function decimals() external view returns (uint8);\\r\\n  function balanceOf(address account) external view returns (uint256);\\r\\n  function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n  function allowance(address owner, address spender) external view returns (uint256);\\r\\n  function approve(address spender, uint256 amount) external returns (bool);\\r\\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport { Context } from \\\"./library/Context.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title Ownable\\r\\n * \\r\\n * parent for ownable contracts\\r\\n */\\r\\nabstract contract Ownable is Context {\\r\\n  constructor(address owner_) {\\r\\n    _owner_ = owner_;\\r\\n    emit OwnershipTransferred(address(0), _owner());\\r\\n  }\\r\\n\\r\\n  address private _owner_;\\r\\n\\r\\n  event OwnershipTransferred(address indexed oldOwner, address indexed newOwner);\\r\\n\\r\\n  function _owner() internal view returns (address) {\\r\\n    return _owner_;\\r\\n  }\\r\\n\\r\\n  function owner() external view returns (address) {\\r\\n    return _owner();\\r\\n  }\\r\\n\\r\\n  modifier onlyOwner() {\\r\\n    require(_owner() == _msgSender(), \\\"Only the owner can execute this function\\\");\\r\\n    _;\\r\\n  }\\r\\n\\r\\n  function _transferOwnership(address newOwner_) virtual internal onlyOwner {\\r\\n    // keep track of old owner for event\\r\\n    address oldOwner = _owner();\\r\\n\\r\\n    // set the new owner\\r\\n    _owner_ = newOwner_;\\r\\n\\r\\n    // emit event about ownership change\\r\\n    emit OwnershipTransferred(oldOwner, _owner());\\r\\n  }\\r\\n\\r\\n  function transferOwnership(address newOwner_) external onlyOwner {\\r\\n    _transferOwnership(newOwner_);\\r\\n  }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/TokenLockerManagerV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport { ITokenLockerManagerV1 } from \\\"./ITokenLockerManagerV1.sol\\\";\\r\\nimport { Ownable } from \\\"./Ownable.sol\\\";\\r\\nimport { IERC20 } from \\\"./library/IERC20.sol\\\";\\r\\nimport { IUniswapV2Pair } from \\\"./library/Dex.sol\\\";\\r\\nimport { TokenLockerV1 } from \\\"./TokenLockerV1.sol\\\";\\r\\nimport { Util } from \\\"./Util.sol\\\";\\r\\n\\r\\ncontract TokenLockerManagerV1 is ITokenLockerManagerV1, Ownable {\\r\\n  event TokenLockerCreated(\\r\\n    uint40 id,\\r\\n    address indexed token,\\r\\n    address createdBy,\\r\\n    uint256 balance,\\r\\n    uint40 unlockTime\\r\\n  );\\r\\n\\r\\n  event LpLockerCreated(\\r\\n    uint40 id,\\r\\n    address indexed token,\\r\\n    address indexed token0,\\r\\n    address indexed token1,\\r\\n    address createdBy,\\r\\n    uint256 balance,\\r\\n    uint40 unlockTime\\r\\n  );\\r\\n\\r\\n  constructor() Ownable(_msgSender()) {\\r\\n    _creationEnabled = true;\\r\\n    feeWallet = msg.sender;\\r\\n  }\\r\\n\\r\\n  bool private _creationEnabled;\\r\\n\\r\\n  uint40 private _tokenLockerCount;\\r\\n  uint40 private _lpLockerCount;\\r\\n\\r\\n  uint256 public TokenLockerFee = 0.01 ether;\\r\\n  uint256 public LpLockerFee = 0.01 ether;\\r\\n  address public feeWallet;\\r\\n\\r\\n  /** @dev main mapping for lock data */\\r\\n  mapping(uint40 => TokenLockerV1) private _tokenLockers;\\r\\n  mapping(uint40 => TokenLockerV1) private _lpLockers;\\r\\n\\r\\n  /**\\r\\n   * @dev this mapping makes it possible to search for locks,\\r\\n   * at the cost of paying higher gas fees to store the data.\\r\\n   */\\r\\n  mapping(address => uint40[]) private _tokenLockersForAddress;\\r\\n  mapping(address => uint40[]) private _lpLockersForAddress;\\r\\n\\r\\n  modifier allowCreation() {\\r\\n    require(_creationEnabled, \\\"Locker creation is disabled\\\");\\r\\n    _;\\r\\n  }\\r\\n\\r\\n  function tokenLockerCount() external view override returns (uint40) {\\r\\n    return _tokenLockerCount;\\r\\n  }\\r\\n\\r\\n  function lpLockerCount() external view override returns (uint40) {\\r\\n    return _lpLockerCount;\\r\\n  }\\r\\n\\r\\n  function creationEnabled() external view override returns (bool) {\\r\\n    return _creationEnabled;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev allow turning off new lockers from being created, so that we can\\r\\n   * migrate to new versions of the contract & stop people from locking\\r\\n   * with the older versions. this will not prevent extending, depositing,\\r\\n   * or withdrawing from old locks - it only stops new locks from being created.\\r\\n   */\\r\\n  function setCreationEnabled(bool value_) external override onlyOwner {\\r\\n    _creationEnabled = value_;\\r\\n  }\\r\\n\\r\\n  function createTokenLocker(\\r\\n    address tokenAddress_,\\r\\n    uint256 amount_,\\r\\n    uint40 unlockTime_\\r\\n  ) external payable override allowCreation {\\r\\n    \\r\\n    require(msg.value >= TokenLockerFee,\\\"Insufficient Fee\\\");\\r\\n\\r\\n    bool isLp = Util.isLpToken(tokenAddress_);\\r\\n    require(!isLp, \\\"This is not token address.\\\");\\r\\n\\r\\n    uint40 id = _tokenLockerCount++;\\r\\n    _tokenLockers[id] = new TokenLockerV1(address(this), id, _msgSender(), tokenAddress_, unlockTime_+uint40(block.timestamp));\\r\\n    address lockerAddress = address(_tokenLockers[id]);\\r\\n\\r\\n    IERC20 token = IERC20(tokenAddress_);\\r\\n    token.transferFrom(_msgSender(), lockerAddress, amount_);\\r\\n\\r\\n    // add the creator to the token locker mapping, so it's\\r\\n    // able to be searched.\\r\\n    _tokenLockersForAddress[_msgSender()].push(id);\\r\\n\\r\\n    // add the locked token to the token lockers mapping\\r\\n    _tokenLockersForAddress[tokenAddress_].push(id);\\r\\n    // add the locker contract to this mapping as well, so it's\\r\\n    // searchable in the same way as tokens within the locker.\\r\\n    _tokenLockersForAddress[lockerAddress].push(id);\\r\\n\\r\\n    if(msg.value > TokenLockerFee) {\\r\\n      uint remain = msg.value - TokenLockerFee;\\r\\n      payable(msg.sender).transfer(remain);\\r\\n      payable(feeWallet).transfer(TokenLockerFee);\\r\\n    }\\r\\n    else {\\r\\n      payable(feeWallet).transfer(msg.value);\\r\\n    }\\r\\n\\r\\n    emit TokenLockerCreated(\\r\\n      id,\\r\\n      tokenAddress_,\\r\\n      _msgSender(),\\r\\n      token.balanceOf(lockerAddress),\\r\\n      unlockTime_+uint40(block.timestamp)\\r\\n    );\\r\\n  }\\r\\n\\r\\n  function createLpLocker(\\r\\n    address lpAddress_,\\r\\n    uint256 amount_,\\r\\n    uint40 unlockTime_\\r\\n  ) external payable override allowCreation {\\r\\n\\r\\n    require(msg.value >= LpLockerFee,\\\"Insufficient Fee\\\");\\r\\n\\r\\n    bool isLp = Util.isLpToken(lpAddress_);\\r\\n    require(isLp, \\\"This is not lp address.\\\");\\r\\n\\r\\n    uint40 id = _lpLockerCount++;\\r\\n    _lpLockers[id] = new TokenLockerV1(address(this), id, _msgSender(), lpAddress_, unlockTime_+uint40(block.timestamp));\\r\\n    address lockerAddress = address(_lpLockers[id]);\\r\\n\\r\\n    IUniswapV2Pair token = IUniswapV2Pair(lpAddress_);\\r\\n    token.transferFrom(_msgSender(), lockerAddress, amount_);\\r\\n\\r\\n    _lpLockersForAddress[_msgSender()].push(id);\\r\\n    _lpLockersForAddress[lpAddress_].push(id);\\r\\n    _lpLockersForAddress[lockerAddress].push(id);\\r\\n\\r\\n    // get lp data\\r\\n    (bool hasLpData,,address token0Address,address token1Address,,,,) = _lpLockers[id].getLpData();\\r\\n\\r\\n    // if this is an lp token, also add the paired tokens to the mapping\\r\\n    require(hasLpData, \\\"Invalid Liquidity Token Address.\\\");\\r\\n\\r\\n    _lpLockersForAddress[token0Address].push(id);\\r\\n    _lpLockersForAddress[token1Address].push(id);\\r\\n\\r\\n    if(msg.value > LpLockerFee) {\\r\\n      uint remain = msg.value - LpLockerFee;\\r\\n      payable(msg.sender).transfer(remain);\\r\\n      payable(feeWallet).transfer(LpLockerFee);\\r\\n    }\\r\\n    else {\\r\\n      payable(feeWallet).transfer(msg.value);\\r\\n    }\\r\\n\\r\\n    emit LpLockerCreated(\\r\\n      id,\\r\\n      lpAddress_,\\r\\n      token0Address,\\r\\n      token1Address,\\r\\n      _msgSender(),\\r\\n      token.balanceOf(lockerAddress),\\r\\n      unlockTime_+uint40(block.timestamp)\\r\\n    );\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @return the address of a locker contract with the given id\\r\\n   */\\r\\n  function getTokenLockAddress(uint40 id_) external view override returns (address) {\\r\\n    return address(_tokenLockers[id_]);\\r\\n  }\\r\\n  function getLpLockAddress(uint40 id_) external view override returns (address) {\\r\\n    return address(_lpLockers[id_]);\\r\\n  }\\r\\n\\r\\n  function getTokenLockData(uint40 id_) external view override returns (\\r\\n    bool isLpToken,\\r\\n    uint40 id,\\r\\n    address contractAddress,\\r\\n    address lockOwner,\\r\\n    address token,\\r\\n    address createdBy,\\r\\n    uint40 createdAt,\\r\\n    uint40 blockTime,\\r\\n    uint40 unlockTime,\\r\\n    uint256 balance,\\r\\n    uint256 totalSupply\\r\\n  ){\\r\\n    return _tokenLockers[id_].getLockData();\\r\\n  }\\r\\n\\r\\n  function getLpLockData(uint40 id_) external view override returns (\\r\\n    bool isLpToken,\\r\\n    uint40 id,\\r\\n    address contractAddress,\\r\\n    address lockOwner,\\r\\n    address token,\\r\\n    address createdBy,\\r\\n    uint40 createdAt,\\r\\n    uint40 blockTime,\\r\\n    uint40 unlockTime,\\r\\n    uint256 balance,\\r\\n    uint256 totalSupply\\r\\n  ){\\r\\n    return _lpLockers[id_].getLockData();\\r\\n  }\\r\\n\\r\\n  function getLpData(uint40 id_) external view override returns (\\r\\n    bool hasLpData,\\r\\n    uint40 id,\\r\\n    address token0,\\r\\n    address token1,\\r\\n    uint256 balance0,\\r\\n    uint256 balance1,\\r\\n    uint256 price0,\\r\\n    uint256 price1\\r\\n  ) {\\r\\n    return _lpLockers[id_].getLpData();\\r\\n  }\\r\\n\\r\\n  /** @return an array of locker ids matching the given search address */\\r\\n  function getTokenLockersForAddress(address address_) external view override returns (uint40[] memory) {\\r\\n    return _tokenLockersForAddress[address_];\\r\\n  }\\r\\n  function getLpLockersForAddress(address address_) external view override returns (uint40[] memory) {\\r\\n    return _lpLockersForAddress[address_];\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev this gets called from TokenLockerV1.\\r\\n   * it notifies this contract of the owner change so we can modify the search index\\r\\n   */\\r\\n  function notifyTokenLockerOwnerChange(uint40 id_, address newOwner_, address previousOwner_, address createdBy_) external override {\\r\\n    require(\\r\\n      _msgSender() == address(_tokenLockers[id_]),\\r\\n      \\\"Only the locker contract can call this function\\\"\\r\\n    );\\r\\n\\r\\n    // remove the previous owner from the locker address mapping,\\r\\n    // only if it's not the same address as the creator.\\r\\n    if (previousOwner_ != createdBy_) {\\r\\n      for (uint256 i = 0; i < _tokenLockersForAddress[previousOwner_].length; i++) {\\r\\n        // continue searching for id_ in the array until we find a match\\r\\n        if (_tokenLockersForAddress[previousOwner_][i] != id_) continue;\\r\\n        // replace the old item at this index with the last value.\\r\\n        // we don't care about the order.\\r\\n        _tokenLockersForAddress[previousOwner_][i] = _tokenLockersForAddress[\\r\\n          previousOwner_][_tokenLockersForAddress[previousOwner_].length - 1\\r\\n        ];\\r\\n        // remove the last item in the array, since we just moved it\\r\\n        _tokenLockersForAddress[previousOwner_].pop();\\r\\n        // and we're done\\r\\n        break;\\r\\n      }\\r\\n    }\\r\\n\\r\\n    // push the new owner to the lockers address mapping so the new owner is searchable,\\r\\n    // only if they don't already have this id in the lockers address mapping.\\r\\n    bool hasId = false;\\r\\n\\r\\n    // look for the id in the new owners address mapping\\r\\n    for (uint256 i = 0; i < _tokenLockersForAddress[newOwner_].length; i++) {\\r\\n      if (_tokenLockersForAddress[newOwner_][i] == id_) {\\r\\n        hasId = true;\\r\\n        break;\\r\\n      }\\r\\n    }\\r\\n\\r\\n    // only add the id if they didn't already have it\\r\\n    if (!hasId) {\\r\\n      _tokenLockersForAddress[newOwner_].push(id_);\\r\\n    }\\r\\n  }\\r\\n  function notifyLpLockerOwnerChange(uint40 id_, address newOwner_, address previousOwner_, address createdBy_) external override {\\r\\n    require(\\r\\n      _msgSender() == address(_lpLockers[id_]),\\r\\n      \\\"Only the locker contract can call this function\\\"\\r\\n    );\\r\\n\\r\\n    // remove the previous owner from the locker address mapping,\\r\\n    // only if it's not the same address as the creator.\\r\\n    if (previousOwner_ != createdBy_) {\\r\\n      for (uint256 i = 0; i < _lpLockersForAddress[previousOwner_].length; i++) {\\r\\n        // continue searching for id_ in the array until we find a match\\r\\n        if (_lpLockersForAddress[previousOwner_][i] != id_) continue;\\r\\n        // replace the old item at this index with the last value.\\r\\n        // we don't care about the order.\\r\\n        _lpLockersForAddress[previousOwner_][i] = _lpLockersForAddress[\\r\\n          previousOwner_][_lpLockersForAddress[previousOwner_].length - 1\\r\\n        ];\\r\\n        // remove the last item in the array, since we just moved it\\r\\n        _lpLockersForAddress[previousOwner_].pop();\\r\\n        // and we're done\\r\\n        break;\\r\\n      }\\r\\n    }\\r\\n\\r\\n    // push the new owner to the lockers address mapping so the new owner is searchable,\\r\\n    // only if they don't already have this id in the lockers address mapping.\\r\\n    bool hasId = false;\\r\\n\\r\\n    // look for the id in the new owners address mapping\\r\\n    for (uint256 i = 0; i < _lpLockersForAddress[newOwner_].length; i++) {\\r\\n      if (_lpLockersForAddress[newOwner_][i] == id_) {\\r\\n        hasId = true;\\r\\n        break;\\r\\n      }\\r\\n    }\\r\\n\\r\\n    // only add the id if they didn't already have it\\r\\n    if (!hasId) {\\r\\n      _lpLockersForAddress[newOwner_].push(id_);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function setLpLockerFee(uint _amount) external onlyOwner() {\\r\\n    LpLockerFee = _amount;\\r\\n  }\\r\\n\\r\\n  function setTokenLockerFee(uint _amount) external onlyOwner() {\\r\\n    TokenLockerFee = _amount;\\r\\n  }\\r\\n\\r\\n  function setFeeWallet(address _newWallet) external onlyOwner() {\\r\\n    feeWallet = _newWallet;\\r\\n  }\\r\\n\\r\\n  receive() external payable {}\\r\\n\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/TokenLockerV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport { ITokenLockerManagerV1 } from \\\"./ITokenLockerManagerV1.sol\\\";\\r\\nimport { Ownable } from \\\"./Ownable.sol\\\";\\r\\nimport { IUniswapV2Pair } from \\\"./library/Dex.sol\\\";\\r\\nimport { IERC20 } from \\\"./library/IERC20.sol\\\";\\r\\nimport { Util } from \\\"./Util.sol\\\";\\r\\n\\r\\ncontract TokenLockerV1 is Ownable {\\r\\n  event Extended(uint40 newUnlockTime);\\r\\n  event Deposited(uint256 amount);\\r\\n  event Withdrew();\\r\\n\\r\\n  constructor(address manager_, uint40 id_, address owner_, address tokenAddress_, uint40 unlockTime_) Ownable(owner_) {\\r\\n    require(unlockTime_ > 0, \\\"Unlock time must be in the future\\\");\\r\\n\\r\\n    _manager = ITokenLockerManagerV1(manager_);\\r\\n    _id = id_;\\r\\n    _token = IERC20(tokenAddress_);\\r\\n    _createdBy = owner_;\\r\\n    _createdAt = uint40(block.timestamp);\\r\\n    _unlockTime = unlockTime_;\\r\\n    _isLpToken = Util.isLpToken(tokenAddress_);\\r\\n  }\\r\\n\\r\\n  ITokenLockerManagerV1 private _manager;\\r\\n  bool private _isLpToken;\\r\\n  uint40 private _id;\\r\\n  IERC20 private _token;\\r\\n  address private _createdBy;\\r\\n  uint40 private _createdAt;\\r\\n  uint40 private _unlockTime;\\r\\n\\r\\n  bool private _transferLocked;\\r\\n\\r\\n  modifier transferLocked() {\\r\\n    require(!_transferLocked, \\\"Transfering is locked. Wait for the previous transaction to complete\\\");\\r\\n    _transferLocked = true;\\r\\n    _;\\r\\n    _transferLocked = false;\\r\\n  }\\r\\n\\r\\n  function _balance() private view returns (uint256) {\\r\\n    return _token.balanceOf(address(this));\\r\\n  }\\r\\n\\r\\n  function getIsLpToken() external view returns (bool) {\\r\\n    return _isLpToken;\\r\\n  }\\r\\n\\r\\n  function getLockData() external view returns (\\r\\n    bool isLpToken,\\r\\n    uint40 id,\\r\\n    address contractAddress,\\r\\n    address lockOwner,\\r\\n    address token,\\r\\n    address createdBy,\\r\\n    uint40 createdAt,\\r\\n    uint40 blockTime,\\r\\n    uint40 unlockTime,\\r\\n    uint256 balance,\\r\\n    uint256 totalSupply\\r\\n  ){\\r\\n    isLpToken = _isLpToken;\\r\\n    id = _id;\\r\\n    contractAddress = address(this);\\r\\n    lockOwner = _owner();\\r\\n    token = address(_token);\\r\\n    createdBy = _createdBy;\\r\\n    createdAt = _createdAt;\\r\\n    blockTime = uint40(block.timestamp);\\r\\n    unlockTime = _unlockTime;\\r\\n    balance = _balance();\\r\\n    totalSupply = _token.totalSupply();\\r\\n  }\\r\\n\\r\\n  function getLpData() external view returns (\\r\\n    bool hasLpData,\\r\\n    uint40 id,\\r\\n    address token0,\\r\\n    address token1,\\r\\n    uint256 balance0,\\r\\n    uint256 balance1,\\r\\n    uint256 price0,\\r\\n    uint256 price1\\r\\n  ) {\\r\\n    // always return the id\\r\\n    id = _id;\\r\\n\\r\\n    if (!_isLpToken) {\\r\\n      // if this isn't an lp token, don't even bother calling getLpData\\r\\n      hasLpData = false;\\r\\n    } else {\\r\\n      // this is an lp token, so let's get some data\\r\\n      try Util.getLpData(address(_token)) returns (\\r\\n        address token0_,\\r\\n        address token1_,\\r\\n        uint256 balance0_,\\r\\n        uint256 balance1_,\\r\\n        uint256 price0_,\\r\\n        uint256 price1_\\r\\n      ){\\r\\n        hasLpData = true;\\r\\n        token0 = token0_;\\r\\n        token1 = token1_;\\r\\n        balance0 = balance0_;\\r\\n        balance1 = balance1_;\\r\\n        price0 = price0_;\\r\\n        price1 = price1_;\\r\\n      } catch Error(string memory /* reason */) {\\r\\n        hasLpData = false;\\r\\n      } catch (bytes memory /* lowLevelData */) {\\r\\n        hasLpData = false;\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev deposit and extend duration in one call\\r\\n   */\\r\\n  function deposit(uint256 amount_, uint40 newUnlockTime_) external onlyOwner transferLocked {\\r\\n    if (newUnlockTime_ != 0) {\\r\\n      require(\\r\\n        newUnlockTime_ >= _unlockTime && newUnlockTime_ >= uint40(block.timestamp),\\r\\n        \\\"New unlock time must be a future time beyond the previous value\\\"\\r\\n      );\\r\\n      _unlockTime = newUnlockTime_;\\r\\n      emit Extended(_unlockTime);\\r\\n    }\\r\\n\\r\\n    if (amount_ != 0) {\\r\\n      uint256 oldBalance = _balance();\\r\\n      _token.transferFrom(_msgSender(), address(this), amount_);\\r\\n      emit Deposited(_balance() - oldBalance);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev withdraw all of the deposited token\\r\\n   */\\r\\n  function withdraw() external onlyOwner transferLocked {\\r\\n    require(uint40(block.timestamp) >= _unlockTime, \\\"Wait until unlockTime to withdraw \\\");\\r\\n\\r\\n    _token.transfer(_owner(), _balance());\\r\\n\\r\\n    emit Withdrew();\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev recovery function -\\r\\n   * just in case this contract winds up with additional tokens (from dividends, etc).\\r\\n   * attempting to withdraw the locked token will revert.\\r\\n   */\\r\\n  function withdrawToken(address address_) external onlyOwner transferLocked {\\r\\n    require(address_ != address(_token), \\\"Use 'withdraw' to withdraw the primary locked token\\\");\\r\\n\\r\\n    IERC20 theToken = IERC20(address_);\\r\\n    theToken.transfer(_owner(), theToken.balanceOf(address(this)));\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev recovery function -\\r\\n   * just in case this contract winds up with eth in it (from dividends etc)\\r\\n   */\\r\\n  function withdrawEth() external onlyOwner transferLocked {\\r\\n    address payable receiver = payable(_owner());\\r\\n    receiver.transfer(address(this).balance);\\r\\n  }\\r\\n\\r\\n  function _transferOwnership(address newOwner_) override internal onlyOwner {\\r\\n    address previousOwner = _owner();\\r\\n    super._transferOwnership(newOwner_);\\r\\n\\r\\n    // we need to notify the manager contract that we transferred\\r\\n    // ownership, so that the new owner is searchable.\\r\\n    if (_isLpToken)\\r\\n      _manager.notifyLpLockerOwnerChange(_id, newOwner_, previousOwner, _createdBy);\\r\\n    else\\r\\n      _manager.notifyTokenLockerOwnerChange(_id, newOwner_, previousOwner, _createdBy);\\r\\n  }\\r\\n\\r\\n  receive() external payable {\\r\\n    // we need this function to receive eth,\\r\\n    // which might happen from dividend tokens.\\r\\n    // use `withdrawEth` to remove eth from the contract.\\r\\n  }\\r\\n}\"\r\n    },\r\n    \"contracts/Util.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport { IERC20 } from \\\"./library/IERC20.sol\\\";\\r\\nimport { IUniswapV2Pair } from \\\"./library/Dex.sol\\\";\\r\\n\\r\\nlibrary Util {\\r\\n  /**\\r\\n   * @dev retrieves basic information about a token, including sender balance\\r\\n   */\\r\\n  function getTokenData(address address_) external view returns (\\r\\n    string memory name,\\r\\n    string memory symbol,\\r\\n    uint8 decimals,\\r\\n    uint256 totalSupply,\\r\\n    uint256 balance\\r\\n  ){\\r\\n    IERC20 _token = IERC20(address_);\\r\\n\\r\\n    name = _token.name();\\r\\n    symbol = _token.symbol();\\r\\n    decimals = _token.decimals();\\r\\n    totalSupply = _token.totalSupply();\\r\\n    balance = _token.balanceOf(msg.sender);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev this throws an error on false, instead of returning false,\\r\\n   * but can still be used the same way on frontend.\\r\\n   */\\r\\n  function isLpToken(address address_) external view returns (bool) {\\r\\n    IUniswapV2Pair pair = IUniswapV2Pair(address_);\\r\\n\\r\\n    try pair.token0() returns (address tokenAddress_) {\\r\\n      // any address returned successfully should be valid?\\r\\n      // but we might as well check that it's not 0\\r\\n      return tokenAddress_ != address(0);\\r\\n    } catch Error(string memory /* reason */) {\\r\\n      return false;\\r\\n    } catch (bytes memory /* lowLevelData */) {\\r\\n      return false;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev this function will revert the transaction if it's called\\r\\n   * on a token that isn't an LP token. so, it's recommended to be\\r\\n   * sure that it's being called on an LP token, or expect the error.\\r\\n   */\\r\\n  function getLpData(address address_) external view returns (\\r\\n    address token0,\\r\\n    address token1,\\r\\n    uint256 balance0,\\r\\n    uint256 balance1,\\r\\n    uint256 price0,\\r\\n    uint256 price1\\r\\n  ) {\\r\\n    IUniswapV2Pair _pair = IUniswapV2Pair(address_);\\r\\n\\r\\n    token0 = _pair.token0();\\r\\n    token1 = _pair.token1();\\r\\n\\r\\n    balance0 = IERC20(token0).balanceOf(address(_pair));\\r\\n    balance1 = IERC20(token1).balanceOf(address(_pair));\\r\\n\\r\\n    price0 = _pair.price0CumulativeLast();\\r\\n    price1 = _pair.price1CumulativeLast();\\r\\n  }\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {\r\n      \"contracts/Util.sol\": {\r\n        \"Util\": \"0x635822169386f76a8368420988b2e417b695a641\"\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint40\",\"name\":\"id\",\"type\":\"uint40\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"createdBy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint40\",\"name\":\"unlockTime\",\"type\":\"uint40\"}],\"name\":\"LpLockerCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint40\",\"name\":\"id\",\"type\":\"uint40\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"createdBy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint40\",\"name\":\"unlockTime\",\"type\":\"uint40\"}],\"name\":\"TokenLockerCreated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"LpLockerFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TokenLockerFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lpAddress_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"},{\"internalType\":\"uint40\",\"name\":\"unlockTime_\",\"type\":\"uint40\"}],\"name\":\"createLpLocker\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"},{\"internalType\":\"uint40\",\"name\":\"unlockTime_\",\"type\":\"uint40\"}],\"name\":\"createTokenLocker\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"creationEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint40\",\"name\":\"id_\",\"type\":\"uint40\"}],\"name\":\"getLpData\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"hasLpData\",\"type\":\"bool\"},{\"internalType\":\"uint40\",\"name\":\"id\",\"type\":\"uint40\"},{\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"balance0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price1\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint40\",\"name\":\"id_\",\"type\":\"uint40\"}],\"name\":\"getLpLockAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint40\",\"name\":\"id_\",\"type\":\"uint40\"}],\"name\":\"getLpLockData\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isLpToken\",\"type\":\"bool\"},{\"internalType\":\"uint40\",\"name\":\"id\",\"type\":\"uint40\"},{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"lockOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"createdBy\",\"type\":\"address\"},{\"internalType\":\"uint40\",\"name\":\"createdAt\",\"type\":\"uint40\"},{\"internalType\":\"uint40\",\"name\":\"blockTime\",\"type\":\"uint40\"},{\"internalType\":\"uint40\",\"name\":\"unlockTime\",\"type\":\"uint40\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"address_\",\"type\":\"address\"}],\"name\":\"getLpLockersForAddress\",\"outputs\":[{\"internalType\":\"uint40[]\",\"name\":\"\",\"type\":\"uint40[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint40\",\"name\":\"id_\",\"type\":\"uint40\"}],\"name\":\"getTokenLockAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint40\",\"name\":\"id_\",\"type\":\"uint40\"}],\"name\":\"getTokenLockData\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isLpToken\",\"type\":\"bool\"},{\"internalType\":\"uint40\",\"name\":\"id\",\"type\":\"uint40\"},{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"lockOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"createdBy\",\"type\":\"address\"},{\"internalType\":\"uint40\",\"name\":\"createdAt\",\"type\":\"uint40\"},{\"internalType\":\"uint40\",\"name\":\"blockTime\",\"type\":\"uint40\"},{\"internalType\":\"uint40\",\"name\":\"unlockTime\",\"type\":\"uint40\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"address_\",\"type\":\"address\"}],\"name\":\"getTokenLockersForAddress\",\"outputs\":[{\"internalType\":\"uint40[]\",\"name\":\"\",\"type\":\"uint40[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lpLockerCount\",\"outputs\":[{\"internalType\":\"uint40\",\"name\":\"\",\"type\":\"uint40\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint40\",\"name\":\"id_\",\"type\":\"uint40\"},{\"internalType\":\"address\",\"name\":\"newOwner_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"previousOwner_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"createdBy_\",\"type\":\"address\"}],\"name\":\"notifyLpLockerOwnerChange\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint40\",\"name\":\"id_\",\"type\":\"uint40\"},{\"internalType\":\"address\",\"name\":\"newOwner_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"previousOwner_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"createdBy_\",\"type\":\"address\"}],\"name\":\"notifyTokenLockerOwnerChange\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"value_\",\"type\":\"bool\"}],\"name\":\"setCreationEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newWallet\",\"type\":\"address\"}],\"name\":\"setFeeWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"setLpLockerFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"setTokenLockerFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenLockerCount\",\"outputs\":[{\"internalType\":\"uint40\",\"name\":\"\",\"type\":\"uint40\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner_\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "TokenLockerManagerV1", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}