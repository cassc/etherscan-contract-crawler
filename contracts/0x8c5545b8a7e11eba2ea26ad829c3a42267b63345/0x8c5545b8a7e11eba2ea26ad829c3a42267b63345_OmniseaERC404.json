{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/contracts/ERC404/OmniseaERC404.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.7;\\r\\n\\r\\nimport \\\"../interfaces/IOmniseaDropsScheduler.sol\\\";\\r\\nimport \\\"../interfaces/IERC2981Royalties.sol\\\";\\r\\nimport \\\"../interfaces/IOmniseaERC404.sol\\\";\\r\\nimport {CreateParams, Phase} from \\\"../structs/erc404/ERC404Structs.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\r\\nimport \\\"./ERC404.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\r\\n\\r\\ncontract OmniseaERC404 is IOmniseaERC404, ERC404, ReentrancyGuard {\\r\\n    using Strings for uint256;\\r\\n\\r\\n    event BatchMetadataUpdate(uint256 _fromTokenId, uint256 _toTokenId);\\r\\n\\r\\n    IOmniseaDropsScheduler public scheduler;\\r\\n    address internal immutable _revenueManager = address(0x61104fBe07ecc735D8d84422c7f045f8d29DBf15);\\r\\n    uint24 public maxSupply;\\r\\n    string public collectionURI;\\r\\n    address public override dropsManager;\\r\\n    string public tokensURI;\\r\\n    uint256 public override endTime;\\r\\n    uint24 public royaltyAmount;\\r\\n    bool private isInitialized;\\r\\n    bool private isMintedToPlatform;\\r\\n\\r\\n    function initialize(\\r\\n        CreateParams memory params,\\r\\n        address _owner,\\r\\n        address _dropsManager,\\r\\n        address _scheduler\\r\\n    ) external {\\r\\n        require(!isInitialized);\\r\\n        require(bytes(params.tokensURI).length > 0, \\\"!tokensURI\\\");\\r\\n        require(params.maxSupply > 0, \\\"!maxSupply\\\");\\r\\n        _init(params.name, params.symbol, 18, params.maxSupply, _owner);\\r\\n        isInitialized = true;\\r\\n        dropsManager = _dropsManager;\\r\\n        tokensURI = params.tokensURI;\\r\\n        maxSupply = params.maxSupply;\\r\\n        collectionURI = params.uri;\\r\\n        endTime = params.endTime;\\r\\n        royaltyAmount = params.royaltyAmount;\\r\\n        scheduler = IOmniseaDropsScheduler(_scheduler);\\r\\n    }\\r\\n\\r\\n    function contractURI() public view returns (string memory) {\\r\\n        return string(abi.encodePacked(\\\"ipfs://\\\", collectionURI));\\r\\n    }\\r\\n\\r\\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\\r\\n        require(tokenId > 0, \\\"!tokenId\\\");\\r\\n\\r\\n        uint256 effectiveId;\\r\\n        if (tokenId <= maxSupply) {\\r\\n            effectiveId = tokenId;\\r\\n        } else {\\r\\n            effectiveId = ((tokenId - 1) % maxSupply) + 1;\\r\\n        }\\r\\n\\r\\n        return string(abi.encodePacked(\\\"ipfs://\\\", tokensURI, \\\"/\\\", effectiveId.toString(), \\\".json\\\"));\\r\\n    }\\r\\n\\r\\n    function mint(address _minter, uint24 _quantity, bytes32[] memory _merkleProof, uint8 _phaseId) external override nonReentrant returns (uint256) {\\r\\n        require(msg.sender == dropsManager);\\r\\n        require(isAllowed(_minter, _quantity, _merkleProof, _phaseId), \\\"!isAllowed\\\");\\r\\n        scheduler.increasePhaseMintedCount(_minter, _phaseId, _quantity);\\r\\n\\r\\n        for (uint24 i = 0; i < _quantity; i++) {\\r\\n            _mint(_minter);\\r\\n            _mintFractions(_minter);\\r\\n        }\\r\\n\\r\\n        return minted;\\r\\n    }\\r\\n\\r\\n    // @dev Introduces fair initial ERC-404 distribution and prevents underflow on balanceOf subtraction in the after-mint transferFrom\\r\\n    function _mintFractions(address _minter) internal {\\r\\n        balanceOf[_minter] += _getUnit();\\r\\n    }\\r\\n\\r\\n    function mintPrice(uint8 _phaseId) public view override returns (uint256) {\\r\\n        return scheduler.mintPrice(_phaseId);\\r\\n    }\\r\\n\\r\\n    function isAllowed(address _account, uint24 _quantity, bytes32[] memory _merkleProof, uint8 _phaseId) internal view returns (bool) {\\r\\n        require(block.timestamp < endTime);\\r\\n        if (maxSupply > 0) require(maxSupply >= (minted + _quantity));\\r\\n\\r\\n        return scheduler.isAllowed(_account, _quantity, _merkleProof, _phaseId);\\r\\n    }\\r\\n\\r\\n    function setPhase(\\r\\n        uint8 _phaseId,\\r\\n        uint256 _from,\\r\\n        uint256 _to,\\r\\n        bytes32 _merkleRoot,\\r\\n        uint24 _maxPerAddress,\\r\\n        uint256 _price,\\r\\n        address _token,\\r\\n        uint256 _minToken\\r\\n    ) external onlyOwner {\\r\\n        scheduler.setPhase(_phaseId, _from, _to, _merkleRoot, _maxPerAddress, _price, _token, _minToken);\\r\\n    }\\r\\n\\r\\n    function setTokensURI(string memory _uri) external onlyOwner {\\r\\n        require(block.timestamp < endTime);\\r\\n        tokensURI = _uri;\\r\\n        emit BatchMetadataUpdate(1, type(uint256).max);\\r\\n    }\\r\\n\\r\\n    function preMintToTeam(uint256 _quantity) external nonReentrant onlyOwner {\\r\\n        if (maxSupply > 0) {\\r\\n            require(maxSupply >= minted + _quantity);\\r\\n        } else {\\r\\n            require(block.timestamp < endTime);\\r\\n        }\\r\\n\\r\\n        for (uint256 i = 0; i < _quantity; i++) {\\r\\n            _mint(owner);\\r\\n            _mintFractions(owner);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function preMintToPlatform(uint256 _quantity) external {\\r\\n        require(msg.sender == _revenueManager && !isMintedToPlatform && _quantity <= 5);\\r\\n        if (maxSupply > 0) {\\r\\n            require(maxSupply >= minted + _quantity);\\r\\n        } else {\\r\\n            require(block.timestamp < endTime);\\r\\n        }\\r\\n        isMintedToPlatform = true;\\r\\n\\r\\n        for (uint256 i = 0; i < _quantity; i++) {\\r\\n            _mint(_revenueManager);\\r\\n            _mintFractions(_revenueManager);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function royaltyInfo(uint256, uint256 value) external view returns (address _receiver, uint256 _royaltyAmount) {\\r\\n        _receiver = owner;\\r\\n        _royaltyAmount = (value * royaltyAmount) / 10000;\\r\\n    }\\r\\n\\r\\n    function setRoyaltyAmount(uint24 _royaltyAmount) external onlyOwner {\\r\\n        royaltyAmount = _royaltyAmount;\\r\\n    }\\r\\n\\r\\n    function collectionOwner() public view override returns (address) {\\r\\n        return owner;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"src/contracts/interfaces/IOmniseaDropsScheduler.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.7;\\r\\n\\r\\ninterface IOmniseaDropsScheduler {\\r\\n    function isAllowed(address _account, uint24 _quantity, bytes32[] memory _merkleProof, uint8 _phaseId) external view returns (bool);\\r\\n    function setPhase(\\r\\n        uint8 _phaseId,\\r\\n        uint256 _from,\\r\\n        uint256 _to,\\r\\n        bytes32 _merkleRoot,\\r\\n        uint24 _maxPerAddress,\\r\\n        uint256 _price,\\r\\n        address _token,\\r\\n        uint256 _minToken\\r\\n    ) external;\\r\\n    function increasePhaseMintedCount(address _account,uint8 _phaseId, uint24 _quantity) external;\\r\\n    function mintPrice(uint8 _phaseId) external view returns (uint256);\\r\\n}\\r\\n\"\r\n    },\r\n    \"src/contracts/interfaces/IERC2981Royalties.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.7;\\r\\n\\r\\ninterface IERC2981Royalties {\\r\\n    function royaltyInfo(uint256 _tokenId, uint256 _value) external view returns (address _receiver, uint256 _royaltyAmount);\\r\\n}\\r\\n\"\r\n    },\r\n    \"src/contracts/interfaces/IOmniseaERC404.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.5.0;\\n\\nimport {CreateParams} from \\\"../structs/erc404/ERC404Structs.sol\\\";\\nimport \\\"../ERC404/ERC404.sol\\\";\\n\\ninterface IOmniseaERC404 {\\n    function initialize(CreateParams memory params, address _owner, address _manager, address _scheduler) external;\\n    function mint(address _minter, uint24 _quantity, bytes32[] memory _merkleProof, uint8 _phaseId) external returns (uint256);\\n    function mintPrice(uint8 _phaseId) external view returns (uint256);\\n    function collectionOwner() external view returns (address);\\n    function dropsManager() external view returns (address);\\n    function endTime() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"src/contracts/structs/erc404/ERC404Structs.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.7;\\r\\n\\r\\nstruct CreateParams {\\r\\n    string name;\\r\\n    string symbol;\\r\\n    string uri;\\r\\n    string tokensURI;\\r\\n    uint24 maxSupply;\\r\\n    uint24 royaltyAmount;\\r\\n    uint256 endTime;\\r\\n}\\r\\n\\r\\nstruct MintParams {\\r\\n    address to;\\r\\n    address collection;\\r\\n    uint24 quantity;\\r\\n    bytes32[] merkleProof;\\r\\n    uint8 phaseId;\\r\\n}\\r\\n\\r\\nstruct Phase {\\r\\n    uint256 from;\\r\\n    uint256 to;\\r\\n    uint24 maxPerAddress;\\r\\n    uint256 price;\\r\\n    bytes32 merkleRoot;\\r\\n    address token;\\r\\n    uint256 minToken;\\r\\n}\\r\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/contracts/ERC404/ERC404.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\nabstract contract Ownable {\\n    event OwnershipTransferred(address indexed user, address indexed newOwner);\\n\\n    error Unauthorized();\\n    error InvalidOwner();\\n\\n    address public owner;\\n\\n    modifier onlyOwner() virtual {\\n        if (msg.sender != owner) revert Unauthorized();\\n\\n        _;\\n    }\\n\\n    function transferOwnership(address _owner) public virtual onlyOwner {\\n        if (_owner == address(0)) revert InvalidOwner();\\n\\n        owner = _owner;\\n\\n        emit OwnershipTransferred(msg.sender, _owner);\\n    }\\n\\n    function revokeOwnership() public virtual onlyOwner {\\n        owner = address(0);\\n\\n        emit OwnershipTransferred(msg.sender, address(0));\\n    }\\n}\\n\\nabstract contract ERC721Receiver {\\n    function onERC721Received(\\n        address,\\n        address,\\n        uint256,\\n        bytes calldata\\n    ) external virtual returns (bytes4) {\\n        return ERC721Receiver.onERC721Received.selector;\\n    }\\n}\\n\\n/// @notice ERC404\\n///         A gas-efficient, mixed ERC20 / ERC721 implementation\\n///         with native liquidity and fractionalization.\\n///\\n///         This is an experimental standard designed to integrate\\n///         with pre-existing ERC20 / ERC721 support as smoothly as\\n///         possible.\\n///\\n/// @dev    In order to support full functionality of ERC20 and ERC721\\n///         supply assumptions are made that slightly constraint usage.\\n///         Ensure decimals are sufficiently large (standard 18 recommended)\\n///         as ids are effectively encoded in the lowest range of amounts.\\n///\\n///         NFTs are spent on ERC20 functions in a FILO queue, this is by\\n///         design.\\n///\\nabstract contract ERC404 is Ownable {\\n    // Events\\n    event ERC20Transfer(\\n        address indexed from,\\n        address indexed to,\\n        uint256 amount\\n    );\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 amount\\n    );\\n    event Transfer(\\n        address indexed from,\\n        address indexed to,\\n        uint256 indexed id\\n    );\\n    event ERC721Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 indexed id\\n    );\\n    event ApprovalForAll(\\n        address indexed owner,\\n        address indexed operator,\\n        bool approved\\n    );\\n\\n    // Errors\\n    error NotFound();\\n    error AlreadyExists();\\n    error InvalidRecipient();\\n    error InvalidSender();\\n    error UnsafeRecipient();\\n\\n    // Metadata\\n    /// @dev Token name\\n    string public name;\\n\\n    /// @dev Token symbol\\n    string public symbol;\\n\\n    /// @dev Decimals for fractional representation. Immutable after initialization\\n    uint8 public decimals;\\n\\n    /// @dev Total supply in fractionalized representation. Immutable after initialization\\n    uint256 public totalSupply;\\n\\n    /// @dev Current mint counter, monotonically increasing to ensure accurate ownership\\n    uint256 public minted;\\n\\n    // Mappings\\n    /// @dev Balance of user in fractional representation\\n    mapping(address => uint256) public balanceOf;\\n\\n    /// @dev Allowance of user in fractional representation\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    /// @dev Approval in native representaion\\n    mapping(uint256 => address) public getApproved;\\n\\n    /// @dev Approval for all in native representation\\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\\n\\n    /// @dev Owner of id in native representation\\n    mapping(uint256 => address) internal _ownerOf;\\n\\n    /// @dev Array of owned ids in native representation\\n    mapping(address => uint256[]) internal _owned;\\n\\n    /// @dev Tracks indices for the _owned mapping\\n    mapping(uint256 => uint256) internal _ownedIndex;\\n\\n    /// @dev Addresses whitelisted from minting / burning for gas savings (pairs, routers, etc)\\n    mapping(address => bool) public whitelist;\\n\\n    // Constructor\\n    function _init(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals,\\n        uint256 _totalNativeSupply,\\n        address _owner\\n    ) internal {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n        totalSupply = _totalNativeSupply * (10 ** decimals);\\n\\n        if (_owner == address(0)) revert InvalidOwner();\\n\\n        owner = _owner;\\n\\n        emit OwnershipTransferred(address(0), _owner);\\n    }\\n\\n    /// @notice Initialization function to set pairs / etc\\n    ///         saving gas by avoiding mint / burn on unnecessary targets\\n    function setWhitelist(address target, bool state) public onlyOwner {\\n        whitelist[target] = state;\\n    }\\n\\n    /// @notice Function to find owner of a given native token\\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\\n        owner = _ownerOf[id];\\n\\n        if (owner == address(0)) {\\n            revert NotFound();\\n        }\\n    }\\n\\n    /// @notice tokenURI must be implemented by child contract\\n    function tokenURI(uint256 id) public view virtual returns (string memory);\\n\\n    /// @notice Function for token approvals\\n    /// @dev This function assumes id / native if amount less than or equal to current max id\\n    function approve(\\n        address spender,\\n        uint256 amountOrId\\n    ) public virtual returns (bool) {\\n        if (amountOrId <= minted && amountOrId > 0) {\\n            address owner = _ownerOf[amountOrId];\\n\\n            if (msg.sender != owner && !isApprovedForAll[owner][msg.sender]) {\\n                revert Unauthorized();\\n            }\\n\\n            getApproved[amountOrId] = spender;\\n\\n            emit Approval(owner, spender, amountOrId);\\n        } else {\\n            allowance[msg.sender][spender] = amountOrId;\\n\\n            emit Approval(msg.sender, spender, amountOrId);\\n        }\\n\\n        return true;\\n    }\\n\\n    /// @notice Function native approvals\\n    function setApprovalForAll(address operator, bool approved) public virtual {\\n        isApprovedForAll[msg.sender][operator] = approved;\\n\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    /// @notice Function for mixed transfers\\n    /// @dev This function assumes id / native if amount less than or equal to current max id\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amountOrId\\n    ) public virtual {\\n        if (amountOrId <= minted) {\\n            if (from != _ownerOf[amountOrId]) {\\n                revert InvalidSender();\\n            }\\n\\n            if (to == address(0)) {\\n                revert InvalidRecipient();\\n            }\\n\\n            if (\\n                msg.sender != from &&\\n                !isApprovedForAll[from][msg.sender] &&\\n                msg.sender != getApproved[amountOrId]\\n            ) {\\n                revert Unauthorized();\\n            }\\n\\n            balanceOf[from] -= _getUnit();\\n\\n            unchecked {\\n                balanceOf[to] += _getUnit();\\n            }\\n\\n            _ownerOf[amountOrId] = to;\\n            delete getApproved[amountOrId];\\n\\n            // update _owned for sender\\n            uint256 updatedId = _owned[from][_owned[from].length - 1];\\n            _owned[from][_ownedIndex[amountOrId]] = updatedId;\\n            // pop\\n            _owned[from].pop();\\n            // update index for the moved id\\n            _ownedIndex[updatedId] = _ownedIndex[amountOrId];\\n            // push token to to owned\\n            _owned[to].push(amountOrId);\\n            // update index for to owned\\n            _ownedIndex[amountOrId] = _owned[to].length - 1;\\n\\n            emit Transfer(from, to, amountOrId);\\n            emit ERC20Transfer(from, to, _getUnit());\\n        } else {\\n            uint256 allowed = allowance[from][msg.sender];\\n\\n            if (allowed != type(uint256).max)\\n                allowance[from][msg.sender] = allowed - amountOrId;\\n\\n            _transfer(from, to, amountOrId);\\n        }\\n    }\\n\\n    /// @notice Function for fractional transfers\\n    function transfer(\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        return _transfer(msg.sender, to, amount);\\n    }\\n\\n    /// @notice Function for native transfers with contract support\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) public virtual {\\n        transferFrom(from, to, id);\\n\\n        if (\\n            to.code.length != 0 &&\\n            ERC721Receiver(to).onERC721Received(msg.sender, from, id, \\\"\\\") !=\\n            ERC721Receiver.onERC721Received.selector\\n        ) {\\n            revert UnsafeRecipient();\\n        }\\n    }\\n\\n    /// @notice Function for native transfers with contract support and callback data\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        bytes calldata data\\n    ) public virtual {\\n        transferFrom(from, to, id);\\n\\n        if (\\n            to.code.length != 0 &&\\n            ERC721Receiver(to).onERC721Received(msg.sender, from, id, data) !=\\n            ERC721Receiver.onERC721Received.selector\\n        ) {\\n            revert UnsafeRecipient();\\n        }\\n    }\\n\\n    /// @notice Internal function for fractional transfers\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal returns (bool) {\\n        uint256 unit = _getUnit();\\n        uint256 balanceBeforeSender = balanceOf[from];\\n        uint256 balanceBeforeReceiver = balanceOf[to];\\n\\n        balanceOf[from] -= amount;\\n\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        // Skip burn for certain addresses to save gas\\n        if (!whitelist[from]) {\\n            uint256 tokens_to_burn = (balanceBeforeSender / unit) -\\n                (balanceOf[from] / unit);\\n            for (uint256 i = 0; i < tokens_to_burn; i++) {\\n                _burn(from);\\n            }\\n        }\\n\\n        // Skip minting for certain addresses to save gas\\n        if (!whitelist[to]) {\\n            uint256 tokens_to_mint = (balanceOf[to] / unit) -\\n                (balanceBeforeReceiver / unit);\\n            for (uint256 i = 0; i < tokens_to_mint; i++) {\\n                _mint(to);\\n            }\\n        }\\n\\n        emit ERC20Transfer(from, to, amount);\\n        return true;\\n    }\\n\\n    // Internal utility logic\\n    function _getUnit() internal view returns (uint256) {\\n        return 10 ** decimals;\\n    }\\n\\n    function _mint(address to) internal virtual {\\n        if (to == address(0)) {\\n            revert InvalidRecipient();\\n        }\\n\\n        unchecked {\\n            minted++;\\n        }\\n\\n        uint256 id = minted;\\n\\n        if (_ownerOf[id] != address(0)) {\\n            revert AlreadyExists();\\n        }\\n\\n        _ownerOf[id] = to;\\n        _owned[to].push(id);\\n        _ownedIndex[id] = _owned[to].length - 1;\\n\\n        emit Transfer(address(0), to, id);\\n    }\\n\\n    function _burn(address from) internal virtual {\\n        if (from == address(0)) {\\n            revert InvalidSender();\\n        }\\n\\n        uint256 id = _owned[from][_owned[from].length - 1];\\n        _owned[from].pop();\\n        delete _ownedIndex[id];\\n        delete _ownerOf[id];\\n        delete getApproved[id];\\n\\n        emit Transfer(from, address(0), id);\\n    }\\n\\n    function _setNameSymbol(\\n        string memory _name,\\n        string memory _symbol\\n    ) internal {\\n        name = _name;\\n        symbol = _symbol;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"name\":\"AlreadyExists\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidRecipient\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSender\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotFound\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Unauthorized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnsafeRecipient\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_fromTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_toTokenId\",\"type\":\"uint256\"}],\"name\":\"BatchMetadataUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ERC20Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"ERC721Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountOrId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collectionOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collectionURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dropsManager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"endTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"tokensURI\",\"type\":\"string\"},{\"internalType\":\"uint24\",\"name\":\"maxSupply\",\"type\":\"uint24\"},{\"internalType\":\"uint24\",\"name\":\"royaltyAmount\",\"type\":\"uint24\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"}],\"internalType\":\"struct CreateParams\",\"name\":\"params\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_dropsManager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_scheduler\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxSupply\",\"outputs\":[{\"internalType\":\"uint24\",\"name\":\"\",\"type\":\"uint24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_minter\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"_quantity\",\"type\":\"uint24\"},{\"internalType\":\"bytes32[]\",\"name\":\"_merkleProof\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint8\",\"name\":\"_phaseId\",\"type\":\"uint8\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_phaseId\",\"type\":\"uint8\"}],\"name\":\"mintPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minted\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_quantity\",\"type\":\"uint256\"}],\"name\":\"preMintToPlatform\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_quantity\",\"type\":\"uint256\"}],\"name\":\"preMintToTeam\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"revokeOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"royaltyAmount\",\"outputs\":[{\"internalType\":\"uint24\",\"name\":\"\",\"type\":\"uint24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"royaltyInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_royaltyAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"scheduler\",\"outputs\":[{\"internalType\":\"contract IOmniseaDropsScheduler\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_phaseId\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"_from\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_to\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_merkleRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint24\",\"name\":\"_maxPerAddress\",\"type\":\"uint24\"},{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_minToken\",\"type\":\"uint256\"}],\"name\":\"setPhase\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint24\",\"name\":\"_royaltyAmount\",\"type\":\"uint24\"}],\"name\":\"setRoyaltyAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_uri\",\"type\":\"string\"}],\"name\":\"setTokensURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"setWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokensURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountOrId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "OmniseaERC404", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "1", "Runs": "1", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}