{"SourceCode": "# @version 0.3.9\r\n\"\"\"\r\n@title YCRV Zap v3\r\n@license GNU AGPLv3\r\n@author Yearn Finance\r\n@notice Zap into yCRV ecosystem positions in a single transaction\r\n@dev To use safely, supply a reasonable min_out value during your zap.\r\n\"\"\"\r\n\r\nfrom vyper.interfaces import ERC20\r\nfrom vyper.interfaces import ERC20Detailed\r\n\r\ninterface Vault:\r\n    def deposit(amount: uint256, recipient: address = msg.sender) -> uint256: nonpayable\r\n    def withdraw(shares: uint256) -> uint256: nonpayable\r\n    def pricePerShare() -> uint256: view\r\n\r\ninterface IYCRV:\r\n    def burn_to_mint(amount: uint256, recipient: address = msg.sender) -> uint256: nonpayable\r\n    def mint(amount: uint256, recipient: address = msg.sender) -> uint256: nonpayable\r\n\r\ninterface Curve:\r\n    def get_virtual_price() -> uint256: view\r\n    def get_dy(i: int128, j: int128, dx: uint256) -> uint256: view\r\n    def exchange(i: int128, j: int128, _dx: uint256, _min_dy: uint256) -> uint256: nonpayable\r\n    def add_liquidity(amounts: uint256[2], min_mint_amount: uint256) -> uint256: nonpayable\r\n    def remove_liquidity_one_coin(_token_amount: uint256, i: int128, min_amount: uint256) -> uint256: nonpayable\r\n    def remove_liquidity(_burn_amount: uint256, _min_amounts: uint256[2]) -> uint256[2]: nonpayable\r\n    def calc_token_amount(amounts: uint256[2], deposit: bool) -> uint256: view\r\n    def calc_withdraw_one_coin(_burn_amount: uint256, i: int128, _previous: bool = False) -> uint256: view\r\n    def totalSupply() -> uint256: view\r\n    def balances(index: uint256) -> uint256: view\r\n\r\nevent UpdateSweepRecipient:\r\n    sweep_recipient: indexed(address)\r\n\r\nevent UpdateMintBuffer:\r\n    mint_buffer: uint256\r\n\r\nYVECRV: constant(address) =     0xc5bDdf9843308380375a611c18B50Fb9341f502A # YVECRV\r\nCRV: constant(address) =        0xD533a949740bb3306d119CC777fa900bA034cd52 # CRV\r\nYVBOOST: constant(address) =    0x9d409a0A012CFbA9B15F6D4B36Ac57A46966Ab9a # YVBOOST\r\nYCRV: constant(address) =       0xFCc5c47bE19d06BF83eB04298b026F81069ff65b # YCRV\r\nSTYCRV: constant(address) =     0x27B5739e22ad9033bcBf192059122d163b60349D # ST-YCRV\r\nLPYCRV_V1: constant(address) =  0xc97232527B62eFb0D8ed38CF3EA103A6CcA4037e # LP-YCRV Deprecated\r\nLPYCRV_V2: constant(address) =  0x6E9455D109202b426169F0d8f01A3332DAE160f3 # LP-YCRV\r\nPOOL_V1: constant(address) =    0x453D92C7d4263201C69aACfaf589Ed14202d83a4 # OLD POOL\r\nPOOL_V2: constant(address) =    0x99f5aCc8EC2Da2BC0771c32814EFF52b712de1E5 # NEW POOL\r\nCVXCRV: constant(address) =     0x62B9c7356A2Dc64a1969e19C23e4f579F9810Aa7 # CVXCRV\r\nCVXCRVPOOL: constant(address) = 0x9D0464996170c6B9e75eED71c68B99dDEDf279e8 # CVXCRVPOOL\r\nLEGACY_TOKENS: public(immutable(address[2]))\r\nOUTPUT_TOKENS: public(immutable(address[3]))\r\n\r\nsweep_recipient: public(address)\r\nmint_buffer: public(uint256)\r\n\r\n@external\r\n@view\r\ndef name() -> String[32]:\r\n    return \"YCRV Zap v3\"\r\n\r\n@external\r\ndef __init__():\r\n    self.sweep_recipient = 0xFEB4acf3df3cDEA7399794D0869ef76A6EfAff52\r\n    self.mint_buffer = 15\r\n\r\n    assert ERC20(YVECRV).approve(YCRV, max_value(uint256))\r\n    assert ERC20(YCRV).approve(STYCRV, max_value(uint256))\r\n    assert ERC20(YCRV).approve(POOL_V2, max_value(uint256))\r\n    assert ERC20(POOL_V2).approve(LPYCRV_V2, max_value(uint256))\r\n    assert ERC20(CRV).approve(POOL_V2, max_value(uint256))\r\n    assert ERC20(CRV).approve(YCRV, max_value(uint256))\r\n    assert ERC20(CVXCRV).approve(CVXCRVPOOL, max_value(uint256))\r\n\r\n    LEGACY_TOKENS = [YVECRV, YVBOOST]\r\n    OUTPUT_TOKENS = [YCRV, STYCRV, LPYCRV_V2]\r\n\r\n@external\r\ndef zap(_input_token: address, _output_token: address, _amount_in: uint256 = max_value(uint256), _min_out: uint256 = 0, _recipient: address = msg.sender) -> uint256:\r\n    \"\"\"\r\n    @notice \r\n        This function allows users to zap from any legacy tokens, CRV, or any yCRV tokens as input \r\n        into any yCRV token as output.\r\n    @dev \r\n        When zapping between tokens that might incur slippage, it is recommended to supply a _min_out value > 0.\r\n        You can estimate the expected output amount by making an off-chain call to this contract's \r\n        \"calc_expected_out\" helper.\r\n        Discount the result by some extra % to allow buffer, and set as _min_out.\r\n    @param _input_token Can be CRV, yveCRV, yvBOOST, cvxCRV or any yCRV token address that user wishes to migrate from\r\n    @param _output_token The yCRV token address that user wishes to migrate to\r\n    @param _amount_in Amount of input token to migrate, defaults to full balance\r\n    @param _min_out The minimum amount of output token to receive\r\n    @param _recipient The address where the output token should be sent\r\n    @return Amount of output token transferred to the _recipient\r\n    \"\"\"\r\n    assert _amount_in > 0\r\n    assert _input_token != _output_token # dev: input and output token are same\r\n    assert _output_token in OUTPUT_TOKENS  # dev: invalid output token address\r\n\r\n    amount: uint256 = _amount_in\r\n    if amount == max_value(uint256):\r\n        amount = ERC20(_input_token).balanceOf(msg.sender)\r\n\r\n    if _input_token in LEGACY_TOKENS:\r\n        return self._zap_from_legacy(_input_token, _output_token, amount, _min_out, _recipient)\r\n    elif _input_token == CRV or _input_token == CVXCRV:\r\n        assert ERC20(_input_token).transferFrom(msg.sender, self, amount)\r\n        if _input_token == CVXCRV:\r\n            amount = Curve(CVXCRVPOOL).exchange(1, 0, amount, 0)\r\n        amount = self._convert_crv(amount)\r\n    elif _input_token in [LPYCRV_V1, POOL_V1]:\r\n        # If this input token path is chosen, we assume it is a migration. \r\n        # This allows us to hardcode a single route, \r\n        # no need for many permutations to all possible outputs.\r\n        assert _output_token == LPYCRV_V2\r\n        assert ERC20(_input_token).transferFrom(msg.sender, self, amount)\r\n        if _input_token == LPYCRV_V1:\r\n            amount = Vault(LPYCRV_V1).withdraw(amount)\r\n        amounts: uint256[2] = Curve(POOL_V1).remove_liquidity(amount, [0,0])\r\n        amount = Curve(POOL_V2).add_liquidity(amounts, 0)\r\n        amount = Vault(LPYCRV_V2).deposit(amount, _recipient)\r\n        assert amount >= _min_out\r\n        return amount\r\n    else:\r\n        assert _input_token in OUTPUT_TOKENS or _input_token == POOL_V2 # dev: invalid input token address\r\n        assert ERC20(_input_token).transferFrom(msg.sender, self, amount)\r\n\r\n    if _input_token == STYCRV:\r\n        amount = Vault(STYCRV).withdraw(amount)\r\n    elif _input_token in [LPYCRV_V2, POOL_V2]:\r\n        if _input_token == LPYCRV_V2:\r\n            amount = Vault(LPYCRV_V2).withdraw(amount)\r\n        amount = Curve(POOL_V2).remove_liquidity_one_coin(amount, 1, 0)\r\n\r\n    if _output_token == YCRV:\r\n        assert amount >= _min_out # dev: min out\r\n        ERC20(_output_token).transfer(_recipient, amount)\r\n        return amount\r\n    return self._convert_to_output(_output_token, amount, _min_out, _recipient)\r\n\r\n@internal\r\ndef _zap_from_legacy(_input_token: address, _output_token: address, _amount: uint256, _min_out: uint256, _recipient: address) -> uint256:\r\n    # @dev This function handles any inputs that are legacy tokens (yveCRV, yvBOOST)\r\n    amount: uint256 = _amount\r\n    assert ERC20(_input_token).transferFrom(msg.sender, self, amount)\r\n    if _input_token == YVBOOST:\r\n        amount = Vault(YVBOOST).withdraw(amount)\r\n\r\n    # Mint YCRV\r\n    if _output_token == YCRV:\r\n        IYCRV(YCRV).burn_to_mint(amount, _recipient)\r\n        assert amount >= _min_out # dev: min out\r\n        return amount\r\n    IYCRV(YCRV).burn_to_mint(amount)\r\n    return self._convert_to_output(_output_token, amount, _min_out, _recipient)\r\n    \r\n@internal\r\ndef _convert_crv(amount: uint256) -> uint256:\r\n    output_amount: uint256 = Curve(POOL_V2).get_dy(0, 1, amount)\r\n    buffered_amount: uint256 = amount + (amount * self.mint_buffer / 10_000)\r\n    if output_amount > buffered_amount:\r\n        return Curve(POOL_V2).exchange(0, 1, amount, 0)\r\n    else:\r\n        return IYCRV(YCRV).mint(amount)\r\n\r\n@internal\r\ndef _lp(_amounts: uint256[2]) -> uint256:\r\n    return Curve(POOL_V2).add_liquidity(_amounts, 0)\r\n\r\n@internal\r\ndef _convert_to_output(_output_token: address, amount: uint256, _min_out: uint256, _recipient: address) -> uint256:\r\n    # dev: output token and amount values have already been validated\r\n    if _output_token == STYCRV:\r\n        amount_out: uint256 = Vault(STYCRV).deposit(amount, _recipient)\r\n        assert amount_out >= _min_out # dev: min out\r\n        return amount_out\r\n    assert _output_token == LPYCRV_V2\r\n    amount_out: uint256 = Vault(LPYCRV_V2).deposit(self._lp([0, amount]), _recipient)\r\n    assert amount_out >= _min_out # dev: min out\r\n    return amount_out\r\n\r\n@view\r\n@internal\r\ndef _relative_price_from_legacy(_input_token: address, _output_token: address, _amount_in: uint256) -> uint256:\r\n    if _amount_in == 0:\r\n        return 0\r\n\r\n    amount: uint256 = _amount_in\r\n    if _input_token == YVBOOST:\r\n        amount = Vault(YVBOOST).pricePerShare() * amount / 10 ** 18\r\n    \r\n    if _output_token == YCRV:\r\n        return amount\r\n    elif _output_token == STYCRV:\r\n        return amount * 10 ** 18 / Vault(STYCRV).pricePerShare()\r\n    assert _output_token == LPYCRV_V2\r\n    lp_amount: uint256 = amount * 10 ** 18 / Curve(POOL_V2).get_virtual_price()\r\n    return lp_amount * 10 ** 18 / Vault(LPYCRV_V2).pricePerShare()\r\n\r\n@view\r\n@external\r\ndef relative_price(_input_token: address, _output_token: address, _amount_in: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice \r\n        This returns a rough amount of output assuming there's a balanced liquidity pool.\r\n        The return value should not be relied upon for an accurate estimate for actual output amount.\r\n    @dev \r\n        This value should only be used to compare against \"calc_expected_out_from_legacy\" to project price impact.\r\n    @param _input_token The token to migrate from\r\n    @param _output_token The yCRV token to migrate to\r\n    @param _amount_in Amount of input token to migrate, defaults to full balance\r\n    @return Amount of output token transferred to the _recipient\r\n    \"\"\"\r\n    assert _output_token in OUTPUT_TOKENS  # dev: invalid output token address\r\n    if _input_token in LEGACY_TOKENS:\r\n        return self._relative_price_from_legacy(_input_token, _output_token, _amount_in)\r\n    assert  (\r\n        _input_token in [CRV , CVXCRV , LPYCRV_V1 , POOL_V1, POOL_V2]\r\n        or _input_token in OUTPUT_TOKENS\r\n    ) # dev: invalid input token address\r\n\r\n    if _amount_in == 0:\r\n        return 0\r\n    amount: uint256 = _amount_in\r\n    if _input_token == _output_token:\r\n        return _amount_in\r\n    elif _input_token == STYCRV:\r\n        amount = Vault(STYCRV).pricePerShare() * amount / 10 ** 18\r\n    elif _input_token in [LPYCRV_V2, POOL_V2]:\r\n        if _input_token == LPYCRV_V2:\r\n            amount = Vault(LPYCRV_V2).pricePerShare() * amount / 10 ** 18\r\n        amount = Curve(POOL_V2).get_virtual_price() * amount / 10 ** 18\r\n    elif _input_token in [LPYCRV_V1, POOL_V1]:\r\n        assert _output_token == LPYCRV_V2\r\n        if _input_token == LPYCRV_V1:\r\n            amount = Vault(LPYCRV_V1).pricePerShare() * amount / 10 ** 18\r\n        amount = Curve(POOL_V1).get_virtual_price() * amount / 10 ** 18\r\n\r\n    if _output_token == YCRV:\r\n        return amount\r\n    elif _output_token == STYCRV:\r\n        return amount * 10 ** 18 / Vault(STYCRV).pricePerShare()\r\n\r\n    assert _output_token == LPYCRV_V2\r\n    lp_amount: uint256 = amount * 10 ** 18 / Curve(POOL_V2).get_virtual_price()\r\n    return lp_amount * 10 ** 18 / Vault(LPYCRV_V2).pricePerShare()\r\n\r\n@view\r\n@internal\r\ndef _calc_expected_out_from_legacy(_input_token: address, _output_token: address, _amount_in: uint256) -> uint256:\r\n    if _amount_in == 0:\r\n        return 0\r\n    amount: uint256 = _amount_in\r\n    if _input_token == YVBOOST:\r\n        amount = Vault(YVBOOST).pricePerShare() * amount / 10 ** 18\r\n    \r\n    if _output_token == YCRV:\r\n        return amount\r\n    elif _output_token == STYCRV:\r\n        return amount * 10 ** 18 / Vault(STYCRV).pricePerShare()\r\n    assert _output_token == LPYCRV_V2\r\n    lp_amount: uint256 = Curve(POOL_V2).calc_token_amount([0, amount], True)\r\n    return lp_amount * 10 ** 18 / Vault(LPYCRV_V2).pricePerShare()\r\n\r\n@view\r\n@external\r\ndef calc_expected_out(_input_token: address, _output_token: address, _amount_in: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice \r\n        This returns the expected amount of tokens output after conversion.\r\n    @dev\r\n        This calculation accounts for slippage, but not fees.\r\n        Needed to prevent front-running, do not rely on it for precise calculations!\r\n    @param _input_token A valid input token address to migrate from\r\n    @param _output_token The yCRV token address to migrate to\r\n    @param _amount_in Amount of input token to migrate, defaults to full balance\r\n    @return Amount of output token transferred to the _recipient\r\n    \"\"\"\r\n    assert _output_token in OUTPUT_TOKENS  # dev: invalid output token address\r\n    assert _input_token != _output_token\r\n    if _input_token in LEGACY_TOKENS:\r\n        return self._calc_expected_out_from_legacy(_input_token, _output_token, _amount_in)\r\n    amount: uint256 = _amount_in\r\n\r\n    if _input_token == CRV or _input_token == CVXCRV:\r\n        if _input_token == CVXCRV:\r\n            amount = Curve(CVXCRVPOOL).get_dy(1, 0, amount)\r\n        output_amount: uint256 = Curve(POOL_V2).get_dy(0, 1, amount)\r\n        buffered_amount: uint256 = amount + (amount * self.mint_buffer / 10_000)\r\n        if output_amount > buffered_amount: # dev: ensure calculation uses buffer\r\n            amount = output_amount\r\n    elif _input_token in [LPYCRV_V1, POOL_V1]:\r\n        assert _output_token == LPYCRV_V2\r\n        if _input_token == LPYCRV_V1:\r\n            amount = Vault(LPYCRV_V1).pricePerShare() * amount / 10 ** 18\r\n        amounts: uint256[2] = self.assets_amounts_from_lp(POOL_V1, amount)\r\n        amount = Curve(POOL_V2).calc_token_amount(amounts, True) # Deposit\r\n        return amount * 10 ** 18 / Vault(LPYCRV_V2).pricePerShare()\r\n    else:\r\n        assert _input_token in OUTPUT_TOKENS or _input_token == POOL_V2   # dev: invalid input token address\r\n    \r\n    if amount == 0:\r\n        return 0\r\n\r\n    if _input_token == STYCRV:\r\n        amount = Vault(STYCRV).pricePerShare() * amount / 10 ** 18\r\n    elif _input_token in [LPYCRV_V2, POOL_V2]:\r\n        if _input_token == LPYCRV_V2:\r\n            amount = Vault(LPYCRV_V2).pricePerShare() * amount / 10 ** 18\r\n        amount = Curve(POOL_V2).calc_withdraw_one_coin(amount, 1)\r\n\r\n    if _output_token == YCRV:\r\n        return amount\r\n    elif _output_token == STYCRV:\r\n        return amount * 10 ** 18 / Vault(STYCRV).pricePerShare()\r\n    \r\n    assert _output_token == LPYCRV_V2\r\n    lp_amount: uint256 = Curve(POOL_V2).calc_token_amount([0, amount], True)\r\n    return lp_amount * 10 ** 18 / Vault(LPYCRV_V2).pricePerShare()\r\n\r\n@view\r\n@internal\r\ndef assets_amounts_from_lp(pool: address, _lp_amount: uint256) -> uint256[2]:\r\n    supply: uint256 = Curve(pool).totalSupply()\r\n    ratio: uint256 = _lp_amount * 10 ** 18 / supply\r\n    balance0: uint256 = Curve(pool).balances(0) * ratio / 10 ** 18\r\n    balance1: uint256 = Curve(pool).balances(1) * ratio / 10 ** 18\r\n    return [balance0, balance1]\r\n\r\n@external\r\ndef sweep(_token: address, _amount: uint256 = max_value(uint256)):\r\n    assert msg.sender == self.sweep_recipient\r\n    value: uint256 = _amount\r\n    if value == max_value(uint256):\r\n        value = ERC20(_token).balanceOf(self)\r\n    assert ERC20(_token).transfer(self.sweep_recipient, value, default_return_value=True)\r\n\r\n@external\r\ndef set_mint_buffer(_new_buffer: uint256):\r\n    \"\"\"\r\n    @notice \r\n        Allow SWEEP_RECIPIENT to express a preference towards minting over swapping \r\n        to save gas and improve overall locked position\r\n    @param _new_buffer New percentage (expressed in BPS) to nudge zaps towards minting\r\n    \"\"\"\r\n    assert msg.sender == self.sweep_recipient\r\n    assert _new_buffer < 500 # dev: buffer too high\r\n    self.mint_buffer = _new_buffer\r\n    log UpdateMintBuffer(_new_buffer)\r\n\r\n@external\r\ndef set_sweep_recipient(_proposed_sweep_recipient: address):\r\n    assert msg.sender == self.sweep_recipient\r\n    self.sweep_recipient = _proposed_sweep_recipient\r\n    log UpdateSweepRecipient(_proposed_sweep_recipient)", "ABI": "[{\"name\":\"UpdateSweepRecipient\",\"inputs\":[{\"name\":\"sweep_recipient\",\"type\":\"address\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"UpdateMintBuffer\",\"inputs\":[{\"name\":\"mint_buffer\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"name\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"string\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"constructor\",\"inputs\":[],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"zap\",\"inputs\":[{\"name\":\"_input_token\",\"type\":\"address\"},{\"name\":\"_output_token\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"zap\",\"inputs\":[{\"name\":\"_input_token\",\"type\":\"address\"},{\"name\":\"_output_token\",\"type\":\"address\"},{\"name\":\"_amount_in\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"zap\",\"inputs\":[{\"name\":\"_input_token\",\"type\":\"address\"},{\"name\":\"_output_token\",\"type\":\"address\"},{\"name\":\"_amount_in\",\"type\":\"uint256\"},{\"name\":\"_min_out\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"zap\",\"inputs\":[{\"name\":\"_input_token\",\"type\":\"address\"},{\"name\":\"_output_token\",\"type\":\"address\"},{\"name\":\"_amount_in\",\"type\":\"uint256\"},{\"name\":\"_min_out\",\"type\":\"uint256\"},{\"name\":\"_recipient\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"relative_price\",\"inputs\":[{\"name\":\"_input_token\",\"type\":\"address\"},{\"name\":\"_output_token\",\"type\":\"address\"},{\"name\":\"_amount_in\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"calc_expected_out\",\"inputs\":[{\"name\":\"_input_token\",\"type\":\"address\"},{\"name\":\"_output_token\",\"type\":\"address\"},{\"name\":\"_amount_in\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"sweep\",\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"sweep\",\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_mint_buffer\",\"inputs\":[{\"name\":\"_new_buffer\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_sweep_recipient\",\"inputs\":[{\"name\":\"_proposed_sweep_recipient\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"LEGACY_TOKENS\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"OUTPUT_TOKENS\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"sweep_recipient\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"mint_buffer\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]}]", "ContractName": "YCRV Zap v3", "CompilerVersion": "vyper:0.3.9", "OptimizationUsed": "0", "Runs": "0", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}