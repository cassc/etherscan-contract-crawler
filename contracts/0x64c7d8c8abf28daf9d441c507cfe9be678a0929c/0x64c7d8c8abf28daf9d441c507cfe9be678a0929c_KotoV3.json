{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/KotoV3.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n///@title Koto ERC20 Token\\n///@author Izanagi Dev\\n///@notice A stripped down ERC20 tax token that implements automated and continious monetary policy decisions.\\n///@dev Bonds are the ERC20 token in exchange for Ether. Unsold bonds with automatically be burned.\\n/// The bonding schedule is set to attempt to sell all of the tokens held within the contract in 1 day intervals. Taking a snapshot\\n/// of the amount currently held within the contract at the start of the next internal period, using this amount as the capcipty to be sold.\\n\\n/// Socials\\n/// Telegram: https://t.me/KotoPortal\\n\\npragma solidity 0.8.23;\\n\\nimport {PricingLibrary} from \\\"./PricingLibrary.sol\\\";\\nimport {SafeTransferLib} from \\\"lib/solmate/src/utils/SafeTransferLib.sol\\\";\\nimport {FullMath} from \\\"./libraries/FullMath.sol\\\";\\nimport {IERC20Minimal} from \\\"./interfaces/IERC20Minimal.sol\\\";\\nimport {IKotoV3} from \\\"./interfaces/IKotoV3.sol\\\";\\n\\ncontract KotoV3 is IKotoV3 {\\n    // ========================== STORAGE ========================== \\\\\\\\\\n\\n    mapping(address => uint256) private _balances;\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n    mapping(address => bool) private _excluded;\\n    mapping(address => bool) private _amms;\\n    uint256 private _totalSupply;\\n\\n    // ====================== ETH BOND STORAGE ===================== \\\\\\\\\\n\\n    PricingLibrary.Adjustment private adjustment;\\n    PricingLibrary.Data private data;\\n    PricingLibrary.Market private market;\\n    PricingLibrary.Term private term;\\n\\n    // ====================== LP BOND STORAGE ====================== \\\\\\\\\\n\\n    PricingLibrary.Adjustment private lpAdjustment;\\n    PricingLibrary.Data private lpData;\\n    PricingLibrary.Market private lpMarket;\\n    PricingLibrary.Term private lpTerm;\\n\\n    uint256 ethCapacityNext;\\n    uint256 lpCapacityNext;\\n\\n    uint8 private locked;\\n    bool private launched;\\n\\n    // =================== CONSTANTS / IMMUTABLES =================== \\\\\\\\\\n\\n    string private constant NAME = \\\"Koto\\\";\\n    string private constant SYMBOL = \\\"KOTO\\\";\\n    uint8 private constant DECIMALS = 18;\\n    ///@dev flat 5% tax for buys and sells\\n    uint8 private constant FEE = 50;\\n    bool private immutable zeroForOne;\\n    address private constant UNISWAP_V2_ROUTER = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\\n    address private constant UNISWAP_V2_FACTORY = 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f;\\n    address private constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\n    address private constant OWNER = 0x946eF43867225695E29241813A8F41519634B36b;\\n    address private constant BOND_DEPOSITORY = 0xE58B33c813ac4077bd2519dE90FccB189a19FA71;\\n    address private immutable pair;\\n    address private immutable token0;\\n    address private immutable token1;\\n    uint256 private constant INTERVAL = 604800; // 7 days in seconds\\n\\n    // ========================== MODIFIERS ========================== \\\\\\\\\\n\\n    modifier lock() {\\n        if (locked == 2) revert Reentrancy();\\n        locked = 2;\\n        _;\\n        locked = 1;\\n    }\\n\\n    // ========================= CONTRUCTOR ========================= \\\\\\\\\\n\\n    constructor() {\\n        pair = _createUniswapV2Pair(address(this), WETH);\\n        _excluded[OWNER] = true;\\n        _excluded[BOND_DEPOSITORY] = true;\\n        _excluded[address(this)] = true;\\n        _amms[pair] = true;\\n        _mint(OWNER, IERC20Minimal(0xc75c635c1F5e21D23eC8592Cb37503B82A7EF942).totalSupply());\\n        (token0, token1) = _getTokens(pair);\\n        zeroForOne = address(this) == token0 ? true : false;\\n        _allowances[address(this)][UNISWAP_V2_ROUTER] = type(uint256).max;\\n    }\\n\\n    // ==================== EXTERNAL FUNCTIONS ===================== \\\\\\\\\\n\\n    function transfer(address _to, uint256 _value) public returns (bool success) {\\n        if (_to == address(0) || _value == 0) revert InvalidTransfer();\\n        _transfer(msg.sender, _to, _value);\\n        return true;\\n    }\\n\\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\\n        if (_to == address(0) || _value == 0) revert InvalidTransfer();\\n        if (_from != msg.sender) {\\n            if (_allowances[_from][msg.sender] < _value) revert InsufficentAllowance();\\n            _allowances[_from][msg.sender] -= _value;\\n        }\\n        _transfer(_from, _to, _value);\\n        return true;\\n    }\\n\\n    function approve(address _spender, uint256 _value) public returns (bool success) {\\n        address owner = msg.sender;\\n        _allowances[owner][_spender] = _value;\\n        return true;\\n    }\\n\\n    ///@notice exchange ETH for Koto tokens at the current bonding price\\n    ///@dev bonds are set on 1 day intervals with 4 hour deposit intervals and 30 minute tune intervals.\\n    function bond() public payable lock returns (uint256 payout) {\\n        if (block.timestamp > term.conclusion) revert MarketClosed();\\n        if (market.capacity != 0) {\\n            // Cache variables for later use to minimize storage calls\\n            PricingLibrary.Market memory _market = market;\\n            PricingLibrary.Term memory _term = term;\\n            PricingLibrary.Data memory _data = data;\\n            PricingLibrary.Adjustment memory adjustments = adjustment;\\n            uint256 _supply = _totalSupply;\\n            uint48 time = uint48(block.timestamp);\\n\\n            // Can pass in structs here as nothing has been updated yet\\n            (_market, _data, _term, adjustments) = PricingLibrary.decay(data, _market, _term, adjustments);\\n\\n            uint256 price = PricingLibrary.marketPrice(_term.controlVariable, _market.totalDebt, _supply);\\n\\n            payout = (msg.value * 1e18 / price);\\n            if (payout > market.maxPayout) revert MaxPayout();\\n\\n            // Update market variables\\n            _market.capacity -= uint96(payout);\\n            _market.purchased += uint96(msg.value);\\n            _market.sold += uint96(payout);\\n            _market.totalDebt += uint96(payout);\\n\\n            bool success = _bond(msg.sender, payout);\\n            if (!success) revert BondFailed();\\n            emit Bond(msg.sender, payout, price);\\n\\n            //Touches market, data, terms, and adjustments\\n            (_market, _term, _data, adjustments) =\\n                PricingLibrary.tune(time, _market, _term, _data, adjustments, _supply);\\n\\n            // Write changes to storage.\\n            market = _market;\\n            term = _term;\\n            data = _data;\\n            adjustment = adjustments;\\n        } else {\\n            //If bonds are not available refund the eth sent to the contract\\n            SafeTransferLib.safeTransferETH(msg.sender, msg.value);\\n        }\\n    }\\n\\n    function bondLp(uint256 _lpAmount) public lock returns (uint256 payout) {\\n        if (block.timestamp > lpTerm.conclusion) revert MarketClosed();\\n        if (lpMarket.capacity != 0) {\\n            IERC20Minimal(pair).transferFrom(msg.sender, address(BOND_DEPOSITORY), _lpAmount);\\n            // Cache variables for later use to minimize storage calls\\n            PricingLibrary.Market memory _market = lpMarket;\\n            PricingLibrary.Term memory _term = lpTerm;\\n            PricingLibrary.Data memory _data = lpData;\\n            PricingLibrary.Adjustment memory adjustments = lpAdjustment;\\n            uint256 _supply = _totalSupply;\\n            uint48 time = uint48(block.timestamp);\\n\\n            // Can pass in structs here as nothing has been updated yet\\n            (_market, _data, _term, adjustments) = PricingLibrary.decay(lpData, _market, _term, adjustments);\\n\\n            uint256 price = PricingLibrary.marketPrice(_term.controlVariable, _market.totalDebt, _supply);\\n\\n            payout = (_lpAmount * 1e18 / price);\\n            if (payout > lpMarket.maxPayout) revert MaxPayout();\\n\\n            // Update market variables\\n            _market.capacity -= uint96(payout);\\n            _market.purchased += uint96(_lpAmount);\\n            _market.sold += uint96(payout);\\n            _market.totalDebt += uint96(payout);\\n\\n            bool success = _bond(msg.sender, payout);\\n            if (!success) revert BondFailed();\\n            emit Bond(msg.sender, payout, price);\\n\\n            //Touches market, data, terms, and adjustments\\n            (_market, _term, _data, adjustments) =\\n                PricingLibrary.tune(time, _market, _term, _data, adjustments, _supply);\\n\\n            // Write changes to storage.\\n            lpMarket = _market;\\n            lpTerm = _term;\\n            lpData = _data;\\n            lpAdjustment = adjustments;\\n        }\\n    }\\n\\n    ///@notice burn Koto tokens in exchange for a piece of the underlying reserves\\n    ///@param amount The amount of Koto tokens to redeem\\n    ///@return payout The amount of ETH received in exchange for the Koto tokens\\n    function redeem(uint256 amount) external returns (uint256 payout) {\\n        // Underlying reserves per token\\n        uint256 price = FullMath.mulDiv(address(this).balance, 1e18, _totalSupply);\\n        payout = FullMath.mulDiv(price, amount, 1e18);\\n        _burn(msg.sender, amount);\\n        SafeTransferLib.safeTransferETH(msg.sender, payout);\\n        emit Redeem(msg.sender, amount, payout, price);\\n    }\\n\\n    ///@notice burn Koto tokens, without redemption\\n    ///@param amount the amount of Koto to burn\\n    function burn(uint256 amount) external returns (bool success) {\\n        _burn(msg.sender, amount);\\n        success = true;\\n        emit Transfer(msg.sender, address(0), amount);\\n    }\\n\\n    // ==================== EXTERNAL VIEW FUNCTIONS ===================== \\\\\\\\\\n\\n    ///@notice get the tokens name\\n    function name() public pure returns (string memory) {\\n        return NAME;\\n    }\\n\\n    ///@notice get the tokens symbol\\n    function symbol() public pure returns (string memory) {\\n        return SYMBOL;\\n    }\\n\\n    ///@notice get the tokens decimals\\n    function decimals() public pure returns (uint8) {\\n        return DECIMALS;\\n    }\\n\\n    ///@notice get the tokens total supply\\n    function totalSupply() public view returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    ///@notice get the current balance of a user\\n    ///@param _owner the user whos balance you want to check\\n    function balanceOf(address _owner) public view returns (uint256) {\\n        return _balances[_owner];\\n    }\\n\\n    ///@notice get current approved amount for transfer from another party\\n    ///@param owner the current owner of the tokens\\n    ///@param spender the user who has approval (or not) to spend the owners tokens\\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    ///@notice return the Uniswap V2 Pair address\\n    function pool() external view returns (address) {\\n        return pair;\\n    }\\n\\n    ///@notice get the owner of the contract\\n    ///@dev ownership is nontransferable and limited to opening trade, exclusion / inclusion,s and increasing liquidity\\n    function ownership() external pure returns (address) {\\n        return OWNER;\\n    }\\n\\n    ///@notice the current price a bond\\n    function bondPrice() external view returns (uint256) {\\n        return _currentMarketPrice(true);\\n    }\\n\\n    function bondPriceLp() external view returns (uint256) {\\n        return _currentMarketPrice(false);\\n    }\\n\\n    ///@notice return the current redemption price for 1 uint of Koto.\\n    function redemptionPrice() external view returns (uint256) {\\n        return ((address(this).balance * 1e18) / _totalSupply);\\n    }\\n\\n    function marketInfo()\\n        external\\n        view\\n        returns (PricingLibrary.Market memory, PricingLibrary.Term memory, PricingLibrary.Data memory)\\n    {\\n        return (market, term, data);\\n    }\\n\\n    function lpMarketInfo()\\n        external\\n        view\\n        returns (PricingLibrary.Market memory, PricingLibrary.Term memory, PricingLibrary.Data memory)\\n    {\\n        return (lpMarket, lpTerm, lpData);\\n    }\\n\\n    function depository() external pure returns (address) {\\n        return BOND_DEPOSITORY;\\n    }\\n\\n    // ========================= ADMIN FUNCTIONS ========================= \\\\\\\\\\n\\n    ///@notice remove a given address from fees and limits\\n    ///@param user the user to exclude from fees\\n    ///@dev this is a one way street so once a user has been excluded they can not then be removed\\n    function exclude(address user) external {\\n        if (msg.sender != OWNER) revert OnlyOwner();\\n        _excluded[user] = true;\\n        emit UserExcluded(user);\\n    }\\n\\n    ///@notice add a amm pool / pair\\n    ///@param _pool the address of the pool / pair to add\\n    function addAmm(address _pool) external {\\n        if (msg.sender != OWNER) revert OnlyOwner();\\n        _amms[_pool] = true;\\n        emit AmmAdded(_pool);\\n    }\\n\\n    ///@notice seed the initial liquidity from this contract.\\n    function launch() external {\\n        if (msg.sender != OWNER) revert OnlyOwner();\\n        if (launched) revert AlreadyLaunched();\\n        _addInitialLiquidity();\\n        launched = true;\\n        emit Launched(block.timestamp);\\n    }\\n\\n    ///@notice create a new bond market for ETH and LP bonds\\n    ///@param ethBondAmount the amount of koto tokens to be sold for ETH bonds during this period\\n    ///@param lpBondAmount the amount of koto tokens to be sold for LP bonds during this period.\\n    function create(uint256 ethBondAmount, uint256 lpBondAmount) external {\\n        if (msg.sender != OWNER && msg.sender != BOND_DEPOSITORY) revert InvalidSender();\\n        if (term.conclusion > block.timestamp) revert OngoingBonds();\\n\\n        ///@dev clear the current unsold bonds in order to prevent build up of unsold tokens\\n        /// if this is not done over a longer time period it would effect the redemption rate for users.\\n        uint256 currentBalance = _balances[address(this)];\\n        if (currentBalance > 0) {\\n            unchecked {\\n                _balances[address(this)] -= currentBalance;\\n                _totalSupply -= currentBalance;\\n            }\\n            emit Transfer(address(this), address(0), currentBalance);\\n        }\\n        uint256 total = ethBondAmount + lpBondAmount;\\n        transferFrom(msg.sender, address(this), total);\\n        ethCapacityNext = ethBondAmount;\\n        lpCapacityNext = lpBondAmount;\\n        _create();\\n        _createLpMarket();\\n    }\\n\\n    // ========================= INTERNAL FUNCTIONS ========================= \\\\\\\\\\n\\n    ///@notice create the Uniswap V2 Pair\\n    ///@param _token0 token 0 of the pair\\n    ///@param _token1 token 1 of the pair\\n    ///@return _pair the pair address\\n    function _createUniswapV2Pair(address _token0, address _token1) private returns (address _pair) {\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0xc9c6539600000000000000000000000000000000000000000000000000000000)\\n            mstore(add(ptr, 4), and(_token0, 0xffffffffffffffffffffffffffffffffffffffff))\\n            mstore(add(ptr, 36), and(_token1, 0xffffffffffffffffffffffffffffffffffffffff))\\n            let result := call(gas(), UNISWAP_V2_FACTORY, 0, ptr, 68, 0, 32)\\n            if iszero(result) { revert(0, 0) }\\n            _pair := mload(0x00)\\n        }\\n    }\\n\\n    ///@notice add the initial liquidity of the pool.\\n    function _addInitialLiquidity() private {\\n        uint256 tokenAmount = _balances[address(this)];\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0xf305d71900000000000000000000000000000000000000000000000000000000)\\n            mstore(add(ptr, 4), and(address(), 0xffffffffffffffffffffffffffffffffffffffff))\\n            mstore(add(ptr, 36), tokenAmount)\\n            mstore(add(ptr, 68), 0)\\n            mstore(add(ptr, 100), 0)\\n            mstore(add(ptr, 132), BOND_DEPOSITORY)\\n            mstore(add(ptr, 164), timestamp())\\n            let result := call(gas(), UNISWAP_V2_ROUTER, balance(address()), ptr, 196, 0, 0)\\n            if iszero(result) { revert(0, 0) }\\n        }\\n    }\\n\\n    ///@notice create the next bond market information\\n    ///@dev this is done automatically if the previous market conclusion has passed\\n    /// time check must be done elsewhere as the initial conclusion is set to uint48 max,\\n    /// tokens must also already be held within the contract or else the call will revert\\n    function _create() private {\\n        // Set the initial price to the current market price\\n        uint96 targetDebt = uint96(ethCapacityNext);\\n        if (ethCapacityNext > 0) {\\n            uint256 initialPrice = _getPrice();\\n\\n            uint96 capacity = targetDebt;\\n            uint96 maxPayout = uint96(targetDebt * 86400 / INTERVAL);\\n            uint256 controlVariable = initialPrice * _totalSupply / targetDebt;\\n            bool policy = _policy(capacity, initialPrice);\\n            uint48 conclusion = uint48(block.timestamp + INTERVAL);\\n\\n            if (policy) {\\n                market = PricingLibrary.Market(capacity, targetDebt, maxPayout, 0, 0);\\n                term = PricingLibrary.Term(conclusion, controlVariable);\\n                data =\\n                    PricingLibrary.Data(uint48(block.timestamp), uint48(block.timestamp), uint48(INTERVAL), 86400, 1800);\\n                emit CreateMarket(capacity, block.timestamp, conclusion);\\n            } else {\\n                _burn(address(this), capacity);\\n                // Set the markets so that they will be closed for the next interval. Important step to make sure\\n                // that if anyone accidently tries to buy a bond they get refunded their eth.\\n                term.conclusion = uint48(block.timestamp + INTERVAL);\\n                market.capacity = 0;\\n            }\\n        }\\n        ethCapacityNext = 0;\\n    }\\n\\n    ///@notice create the next bond market for LP tokens -> koto\\n    function _createLpMarket() private {\\n        uint96 targetDebt = uint96(lpCapacityNext);\\n        if (targetDebt > 0) {\\n            uint256 initialPrice = _getLpPrice();\\n            uint96 capacity = targetDebt;\\n            uint96 maxPayout = uint96(targetDebt * 86400 / INTERVAL);\\n            uint256 controlVariable = initialPrice * _totalSupply / targetDebt;\\n            bool policy = _policy(capacity, initialPrice);\\n            uint48 conclusion = uint48(block.timestamp + INTERVAL);\\n\\n            if (policy) {\\n                lpMarket = PricingLibrary.Market(capacity, targetDebt, maxPayout, 0, 0);\\n                lpTerm = PricingLibrary.Term(conclusion, controlVariable);\\n                lpData =\\n                    PricingLibrary.Data(uint48(block.timestamp), uint48(block.timestamp), uint48(INTERVAL), 86400, 1800);\\n                emit CreateMarket(capacity, block.timestamp, conclusion);\\n            } else {\\n                _burn(address(this), capacity);\\n                // Set the markets so that they will be closed for the next interval. Important step to make sure\\n                // that if anyone accidently tries to buy a bond they get refunded their eth.\\n                lpTerm.conclusion = uint48(block.timestamp + INTERVAL);\\n                lpMarket.capacity = 0;\\n            }\\n        }\\n        lpCapacityNext = 0;\\n    }\\n\\n    ///@notice determines if to sell the tokens available as bonds or to burn them instead\\n    ///@param capacity the amount of tokens that will be available within the next bonding cycle\\n    ///@param price the starting price of the bonds to sell\\n    ///@return decision the decision reached determining which is more valuable to sell the bonds (true) or to burn them (false)\\n    ///@dev the decision is made optimistically using the initial price as the selling price for the deicison. If selling the tokens all at the starting\\n    /// price does not increase relative reserves more than burning the tokens then they are burned. If they are equivilant burning wins out.\\n    function _policy(uint256 capacity, uint256 price) private view returns (bool decision) {\\n        uint256 supply = _totalSupply;\\n        uint256 burnRelative = (address(this).balance * 1e18) / (supply - capacity);\\n        uint256 bondRelative = ((address(this).balance * 1e18) + ((capacity * price))) / supply;\\n        decision = burnRelative >= bondRelative ? false : true;\\n    }\\n\\n    ///@notice internal transfer function to handle dealing with taxes\\n    function _transfer(address from, address to, uint256 _value) private {\\n        if (_value > _balances[from]) revert InsufficentBalance();\\n        bool fees;\\n        if (_amms[to] || _amms[from]) {\\n            if (_excluded[to] || _excluded[from]) {\\n                fees = false;\\n            } else {\\n                fees = true;\\n            }\\n        }\\n        if (fees) {\\n            uint256 fee = (_value * FEE) / 1000;\\n\\n            unchecked {\\n                _balances[from] -= _value;\\n                _balances[BOND_DEPOSITORY] += fee;\\n            }\\n            _value -= fee;\\n            unchecked {\\n                _balances[to] += _value;\\n            }\\n        } else {\\n            unchecked {\\n                _balances[from] -= _value;\\n                _balances[to] += _value;\\n            }\\n        }\\n        emit Transfer(from, to, _value);\\n    }\\n\\n    ///@notice mint new koto tokens\\n    ///@param to the user who will receive the tokens\\n    ///@param value the amount of tokens to mint\\n    ///@dev this function is used once, during the creation of the contract and is then\\n    /// not callable\\n    function _mint(address to, uint256 value) private {\\n        unchecked {\\n            _balances[to] += value;\\n            _totalSupply += value;\\n        }\\n        emit Transfer(address(0), to, value);\\n    }\\n\\n    ///@notice burn koto tokens\\n    ///@param from the user to burn the tokens from\\n    ///@param value the amount of koto tokens to burn\\n    function _burn(address from, uint256 value) private {\\n        if (_balances[from] < value) revert InsufficentBalance();\\n        unchecked {\\n            _balances[from] -= value;\\n            _totalSupply -= value;\\n        }\\n        emit Transfer(from, address(0), value);\\n    }\\n\\n    ///@notice send the user the correct amount of tokens after the have bought a bond\\n    ///@param to the user to send the tokens to\\n    ///@param value the amount of koto tokens to send\\n    ///@dev bonds are not subject to taxes\\n    function _bond(address to, uint256 value) private returns (bool success) {\\n        if (value > _balances[address(this)]) revert InsufficentBondsAvailable();\\n        unchecked {\\n            _balances[to] += value;\\n            _balances[address(this)] -= value;\\n        }\\n        success = true;\\n        emit Transfer(address(this), to, value);\\n    }\\n\\n    ///@notice calculate the current market price based on the reserves of the Uniswap Pair\\n    ///@dev price is returned as the amount of ETH you would get back for 1 full (1e18) Koto tokens\\n    function _getPrice() private view returns (uint256 price) {\\n        address _pair = pair;\\n        uint112 reserve0;\\n        uint112 reserve1;\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0x0902f1ac00000000000000000000000000000000000000000000000000000000)\\n            let success := staticcall(gas(), _pair, ptr, 4, 0, 0)\\n            if iszero(success) { revert(0, 0) }\\n            returndatacopy(0x00, 0, 32)\\n            returndatacopy(0x20, 0x20, 32)\\n            reserve0 := mload(0x00)\\n            reserve1 := mload(0x20)\\n        }\\n\\n        if (zeroForOne) {\\n            price = FullMath.mulDiv(uint256(reserve1), 1e18, uint256(reserve0));\\n        } else {\\n            price = FullMath.mulDiv(uint256(reserve0), 1e18, uint256(reserve1));\\n        }\\n    }\\n\\n    ///@notice return the current price in koto for 1 LP token\\n    function _getLpPrice() private view returns (uint256 _lpPrice) {\\n        address _pair = pair;\\n        uint112 reserve0;\\n        uint112 reserve1;\\n        uint256 lpTotalSupply;\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0x0902f1ac00000000000000000000000000000000000000000000000000000000)\\n            let success := staticcall(gas(), _pair, ptr, 4, 0, 0)\\n            if iszero(success) { revert(0, 0) }\\n            returndatacopy(0x00, 0, 32)\\n            returndatacopy(0x20, 0x20, 32)\\n            reserve0 := mload(0x00)\\n            reserve1 := mload(0x20)\\n            mstore(add(ptr, 0x20), 0x18160ddd00000000000000000000000000000000000000000000000000000000)\\n            let result := staticcall(gas(), _pair, add(ptr, 0x20), 4, 0, 32)\\n            lpTotalSupply := mload(0x00)\\n        }\\n        ///@dev with uniswap v2 we simply treat the other token total as equal value to simplify the pricing mechanism\\n        if (zeroForOne) {\\n            _lpPrice = FullMath.mulDiv(reserve0 * 2, 1e18, lpTotalSupply);\\n        } else {\\n            _lpPrice = FullMath.mulDiv(reserve1 * 2, 1e18, lpTotalSupply);\\n        }\\n    }\\n\\n    ///@notice return the tokens for a Uniswap V2 Pair\\n    ///@param _pair the address of the pair\\n    ///@return _token0 token 0 of the uniswap pair\\n    ///@return _token1 token 1 of the uniswap pair\\n    function _getTokens(address _pair) private view returns (address _token0, address _token1) {\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0x0dfe168100000000000000000000000000000000000000000000000000000000)\\n            let resultToken0 := staticcall(gas(), _pair, ptr, 4, 0, 32)\\n            mstore(add(ptr, 4), 0xd21220a700000000000000000000000000000000000000000000000000000000)\\n            let resultToken1 := staticcall(gas(), _pair, add(ptr, 4), 4, 32, 32)\\n            if or(iszero(resultToken0), iszero(resultToken1)) { revert(0, 0) }\\n            _token0 := mload(0x00)\\n            _token1 := mload(0x20)\\n        }\\n    }\\n\\n    ///@notice get the current market price of bonds based on decay and other factors\\n    ///@param eth true if you are getting the ETH bond price, false for LP bond price\\n    function _currentMarketPrice(bool eth) private view returns (uint256) {\\n        if (eth) {\\n            return (\\n                FullMath.mulDiv(\\n                    _currentControlVariable(term.controlVariable, adjustment),\\n                    PricingLibrary.debtRatio(market.totalDebt, _totalSupply),\\n                    1e18\\n                )\\n            );\\n        } else {\\n            return (\\n                FullMath.mulDiv(\\n                    _currentControlVariable(lpTerm.controlVariable, lpAdjustment),\\n                    PricingLibrary.debtRatio(lpMarket.totalDebt, _totalSupply),\\n                    1e18\\n                )\\n            );\\n        }\\n    }\\n\\n    function _currentControlVariable(uint256 controlVariable, PricingLibrary.Adjustment memory info)\\n        private\\n        view\\n        returns (uint256)\\n    {\\n        (uint256 decay,,) = PricingLibrary.controlDecay(info);\\n        return controlVariable - decay;\\n    }\\n\\n    receive() external payable {}\\n}\\n\"\r\n    },\r\n    \"src/PricingLibrary.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.23;\\n\\nlibrary PricingLibrary {\\n    // 1 Slot\\n    struct Data {\\n        uint48 lastTune;\\n        uint48 lastDecay; // last timestamp when market was created and debt was decayed\\n        uint48 length; // time from creation to conclusion. used as speed to decay debt.\\n        uint48 depositInterval; // target frequency of deposits\\n        uint48 tuneInterval; // frequency of tuning\\n    }\\n\\n    // 2 Storage slots\\n    struct Market {\\n        uint96 capacity; // capacity remaining\\n        uint96 totalDebt; // total debt from market\\n        uint96 maxPayout; // max tokens in/out\\n        uint96 sold; // Koto out\\n        uint96 purchased; // Eth in\\n    }\\n\\n    // 1 Storage Slot\\n    struct Adjustment {\\n        uint128 change;\\n        uint48 lastAdjustment;\\n        uint48 timeToAdjusted;\\n        bool active;\\n    }\\n\\n    // 2 Storage slots\\n    struct Term {\\n        uint48 conclusion; // timestamp when the current market will end\\n        uint256 controlVariable; // scaling variable for price\\n    }\\n\\n    function decay(Data memory data, Market memory market, Term memory terms, Adjustment memory adjustments)\\n        internal\\n        view\\n        returns (Market memory, Data memory, Term memory, Adjustment memory)\\n    {\\n        uint48 time = uint48(block.timestamp);\\n        market.totalDebt -= debtDecay(data, market);\\n        data.lastDecay = time;\\n\\n        if (adjustments.active) {\\n            (uint128 adjustby, uint48 dt, bool stillActive) = controlDecay(adjustments);\\n            terms.controlVariable -= adjustby;\\n            if (stillActive) {\\n                adjustments.change -= adjustby;\\n                adjustments.timeToAdjusted -= dt;\\n                adjustments.lastAdjustment = time;\\n            } else {\\n                adjustments.active = false;\\n            }\\n        }\\n        return (market, data, terms, adjustments);\\n    }\\n\\n    function controlDecay(Adjustment memory info) internal view returns (uint128, uint48, bool) {\\n        if (!info.active) return (0, 0, false);\\n\\n        uint48 secondsSince = uint48(block.timestamp) - info.lastAdjustment;\\n        bool active = secondsSince < info.timeToAdjusted;\\n        uint128 _decay = active ? (info.change * secondsSince) / info.timeToAdjusted : info.change;\\n        return (_decay, secondsSince, active);\\n    }\\n\\n    function marketPrice(uint256 _controlVariable, uint256 _totalDebt, uint256 _totalSupply)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return ((_controlVariable * debtRatio(_totalDebt, _totalSupply)) / 1e18);\\n    }\\n\\n    function debtRatio(uint256 _totalDebt, uint256 _totalSupply) internal pure returns (uint256) {\\n        return ((_totalDebt * 1e18) / _totalSupply);\\n    }\\n\\n    function debtDecay(Data memory data, Market memory market) internal view returns (uint64) {\\n        uint256 secondsSince = block.timestamp - data.lastDecay;\\n        return uint64((market.totalDebt * secondsSince) / data.length);\\n    }\\n\\n    struct TuneCache {\\n        uint256 remaining;\\n        uint256 price;\\n        uint256 capacity;\\n        uint256 targetDebt;\\n        uint256 ncv;\\n    }\\n\\n    function tune(\\n        uint48 time,\\n        Market memory market,\\n        Term memory term,\\n        Data memory data,\\n        Adjustment memory adjustment,\\n        uint256 _totalSupply\\n    ) internal pure returns (Market memory, Term memory, Data memory, Adjustment memory) {\\n        TuneCache memory cache;\\n        if (time >= data.lastTune + data.tuneInterval) {\\n            cache.remaining = term.conclusion - time;\\n            cache.price = marketPrice(term.controlVariable, market.totalDebt, _totalSupply);\\n            cache.capacity = market.capacity;\\n            market.maxPayout = uint96((cache.capacity * data.depositInterval / cache.remaining));\\n            cache.targetDebt = cache.capacity * data.length / cache.remaining;\\n            cache.ncv = (cache.price * _totalSupply) / cache.targetDebt;\\n\\n            if (cache.ncv < term.controlVariable) {\\n                uint128 change = uint128(term.controlVariable - cache.ncv);\\n                adjustment = Adjustment(change, time, data.tuneInterval, true);\\n            } else {\\n                term.controlVariable = cache.ncv;\\n            }\\n            data.lastTune = time;\\n        }\\n        return (market, term, data, adjustment);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/utils/SafeTransferLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"../tokens/ERC20.sol\\\";\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\\nlibrary SafeTransferLib {\\n    /*//////////////////////////////////////////////////////////////\\n                             ETH OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Transfer the ETH and store if it succeeded or not.\\n            success := call(gas(), to, amount, 0, 0, 0, 0)\\n        }\\n\\n        require(success, \\\"ETH_TRANSFER_FAILED\\\");\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            ERC20 OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferFrom(\\n        ERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), and(from, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \\\"from\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \\\"amount\\\" argument. Masking not required as it's a full 32 byte type.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"TRANSFER_FROM_FAILED\\\");\\n    }\\n\\n    function safeTransfer(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument. Masking not required as it's a full 32 byte type.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"TRANSFER_FAILED\\\");\\n    }\\n\\n    function safeApprove(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument. Masking not required as it's a full 32 byte type.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"APPROVE_FAILED\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libraries/FullMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @title Contains 512-bit math functions\\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\\n/// @dev Handles \\\"phantom overflow\\\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\\nlibrary FullMath {\\n    /// @notice Calculates floor(a\u00d7b\u00f7denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n    /// @param a The multiplicand\\n    /// @param b The multiplier\\n    /// @param denominator The divisor\\n    /// @return result The 256-bit result\\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\\n    function mulDiv(uint256 a, uint256 b, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = a * b\\n            // Compute the product mod 2**256 and mod 2**256 - 1\\n            // then use the Chinese Remainder Theorem to reconstruct\\n            // the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2**256 + prod0\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(a, b, not(0))\\n                prod0 := mul(a, b)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division\\n            if (prod1 == 0) {\\n                require(denominator > 0);\\n                assembly {\\n                    result := div(prod0, denominator)\\n                }\\n                return result;\\n            }\\n\\n            // Make sure the result is less than 2**256.\\n            // Also prevents denominator == 0\\n            require(denominator > prod1);\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0]\\n            // Compute remainder using mulmod\\n            uint256 remainder;\\n            assembly {\\n                remainder := mulmod(a, b, denominator)\\n            }\\n            // Subtract 256 bit number from 512 bit number\\n            assembly {\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator\\n            // Compute largest power of two divisor of denominator.\\n            // Always >= 1.\\n            uint256 twos = (0 - denominator) & denominator;\\n            // Divide denominator by power of two\\n            assembly {\\n                denominator := div(denominator, twos)\\n            }\\n\\n            // Divide [prod1 prod0] by the factors of two\\n            assembly {\\n                prod0 := div(prod0, twos)\\n            }\\n            // Shift in bits from prod1 into prod0. For this we need\\n            // to flip `twos` such that it is 2**256 / twos.\\n            // If twos is zero, then it becomes one\\n            assembly {\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2**256\\n            // Now that denominator is an odd number, it has an inverse\\n            // modulo 2**256 such that denominator * inv = 1 mod 2**256.\\n            // Compute the inverse by starting with a seed that is correct\\n            // correct for four bits. That is, denominator * inv = 1 mod 2**4\\n            uint256 inv = (3 * denominator) ^ 2;\\n            // Now use Newton-Raphson iteration to improve the precision.\\n            // Thanks to Hensel's lifting lemma, this also works in modular\\n            // arithmetic, doubling the correct bits in each step.\\n            inv *= 2 - denominator * inv; // inverse mod 2**8\\n            inv *= 2 - denominator * inv; // inverse mod 2**16\\n            inv *= 2 - denominator * inv; // inverse mod 2**32\\n            inv *= 2 - denominator * inv; // inverse mod 2**64\\n            inv *= 2 - denominator * inv; // inverse mod 2**128\\n            inv *= 2 - denominator * inv; // inverse mod 2**256\\n\\n            // Because the division is now exact we can divide by multiplying\\n            // with the modular inverse of denominator. This will give us the\\n            // correct result modulo 2**256. Since the precoditions guarantee\\n            // that the outcome is less than 2**256, this is the final result.\\n            // We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inv;\\n            return result;\\n        }\\n    }\\n\\n    /// @notice Calculates ceil(a\u00d7b\u00f7denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n    /// @param a The multiplicand\\n    /// @param b The multiplier\\n    /// @param denominator The divisor\\n    /// @return result The 256-bit result\\n    function mulDivRoundingUp(uint256 a, uint256 b, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            result = mulDiv(a, b, denominator);\\n            if (mulmod(a, b, denominator) > 0) {\\n                require(result < type(uint256).max);\\n                result++;\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IERC20Minimal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.23;\\n\\ninterface IERC20Minimal {\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n    function transfer(address, uint256) external returns (bool);\\n    function balanceOf(address) external view returns (uint256);\\n    function totalSupply() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IKotoV3.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.23;\\n\\nimport {PricingLibrary} from \\\"../PricingLibrary.sol\\\";\\n\\ninterface IKotoV3 {\\n    // ==================== EXTERNAL FUNCTIONS ===================== \\\\\\\\\\n\\n    function transfer(address _to, uint256 _value) external returns (bool success);\\n\\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\\n\\n    function approve(address _spender, uint256 _value) external returns (bool success);\\n\\n    ///@notice exchange ETH for Koto tokens at the current bonding price\\n    ///@dev bonds are set on 1 day intervals with 4 hour deposit intervals and 30 minute tune intervals.\\n    function bond() external payable returns (uint256 payout);\\n\\n    function bondLp(uint256 _lpAmount) external returns (uint256 payout);\\n\\n    ///@notice burn Koto tokens in exchange for a piece of the underlying reserves\\n    ///@param amount The amount of Koto tokens to redeem\\n    ///@return payout The amount of ETH received in exchange for the Koto tokens\\n    function redeem(uint256 amount) external returns (uint256 payout);\\n\\n    ///@notice burn Koto tokens, without redemption\\n    ///@param amount the amount of Koto to burn\\n    function burn(uint256 amount) external returns (bool success);\\n\\n    // ==================== EXTERNAL VIEW FUNCTIONS ===================== \\\\\\\\\\n\\n    ///@notice get the tokens name\\n    function name() external pure returns (string memory);\\n\\n    ///@notice get the tokens symbol\\n    function symbol() external pure returns (string memory);\\n\\n    ///@notice get the tokens decimals\\n    function decimals() external pure returns (uint8);\\n\\n    ///@notice get the tokens total supply\\n    function totalSupply() external view returns (uint256);\\n\\n    ///@notice get the current balance of a user\\n    ///@param _owner the user whos balance you want to check\\n    function balanceOf(address _owner) external view returns (uint256);\\n\\n    ///@notice get current approved amount for transfer from another party\\n    ///@param owner the current owner of the tokens\\n    ///@param spender the user who has approval (or not) to spend the owners tokens\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    ///@notice return the Uniswap V2 Pair address\\n    function pool() external view returns (address);\\n\\n    ///@notice get the owner of the contract\\n    ///@dev ownership is nontransferable and limited to opening trade, exclusion / inclusion,s and increasing liquidity\\n    function ownership() external pure returns (address);\\n\\n    ///@notice the current price a bond\\n    function bondPrice() external view returns (uint256);\\n\\n    function bondPriceLp() external view returns (uint256);\\n\\n    ///@notice return the current redemption price for 1 uint of Koto.\\n    function redemptionPrice() external view returns (uint256);\\n\\n    function marketInfo()\\n        external\\n        view\\n        returns (PricingLibrary.Market memory, PricingLibrary.Term memory, PricingLibrary.Data memory);\\n\\n    function lpMarketInfo()\\n        external\\n        view\\n        returns (PricingLibrary.Market memory, PricingLibrary.Term memory, PricingLibrary.Data memory);\\n\\n    function depository() external pure returns (address);\\n\\n    function create(uint256 ethBondAmount, uint256 lpBondAmount) external;\\n\\n    // ========================= EVENTS ========================= \\\\\\\\\\n\\n    event AmmAdded(address poolAdded);\\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\\n    event Bond(address indexed buyer, uint256 amount, uint256 bondPrice);\\n    event CreateMarket(uint256 bonds, uint256 start, uint48 end);\\n    event IncreaseLiquidity(uint256 kotoAdded, uint256 ethAdded);\\n    event Launched(uint256 time);\\n    event LimitsRemoved(uint256 time);\\n    event OpenBondMarket(uint256 openingTime);\\n    event Redeem(address indexed sender, uint256 burned, uint256 payout, uint256 floorPrice);\\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\\n    event UserExcluded(address indexed userToExclude);\\n\\n    // ========================= ERRORS ========================= \\\\\\\\\\n\\n    error AlreadyLaunched();\\n    error BondFailed();\\n    error InsufficentAllowance();\\n    error InsufficentBalance();\\n    error InsufficentBondsAvailable();\\n    error InvalidSender();\\n    error InvalidTransfer();\\n    error LimitsReached();\\n    error MarketClosed();\\n    error MaxPayout();\\n    error OngoingBonds();\\n    error OnlyOwner();\\n    error RedeemFailed();\\n    error Reentrancy();\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/tokens/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\\nabstract contract ERC20 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    uint8 public immutable decimals;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            EIP-2612 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\n\\n    mapping(address => uint256) public nonces;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n\\n        INITIAL_CHAIN_ID = block.chainid;\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        balanceOf[msg.sender] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\n\\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\\n\\n        balanceOf[from] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             EIP-2612 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        require(deadline >= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\n\\n        // Unchecked because the only math done is incrementing\\n        // the owner's nonce which cannot realistically overflow.\\n        unchecked {\\n            address recoveredAddress = ecrecover(\\n                keccak256(\\n                    abi.encodePacked(\\n                        \\\"\\\\x19\\\\x01\\\",\\n                        DOMAIN_SEPARATOR(),\\n                        keccak256(\\n                            abi.encode(\\n                                keccak256(\\n                                    \\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\"\\n                                ),\\n                                owner,\\n                                spender,\\n                                value,\\n                                nonces[owner]++,\\n                                deadline\\n                            )\\n                        )\\n                    )\\n                ),\\n                v,\\n                r,\\n                s\\n            );\\n\\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"INVALID_SIGNER\\\");\\n\\n            allowance[recoveredAddress][spender] = value;\\n        }\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\n    }\\n\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                    keccak256(bytes(name)),\\n                    keccak256(\\\"1\\\"),\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        totalSupply += amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        balanceOf[from] -= amount;\\n\\n        // Cannot underflow because a user's balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply -= amount;\\n        }\\n\\n        emit Transfer(from, address(0), amount);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"solmate/=lib/solmate/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"shanghai\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AlreadyLaunched\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BondFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficentAllowance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficentBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficentBondsAvailable\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSender\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidTransfer\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LimitsReached\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MarketClosed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MaxPayout\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OngoingBonds\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RedeemFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Reentrancy\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"poolAdded\",\"type\":\"address\"}],\"name\":\"AmmAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bondPrice\",\"type\":\"uint256\"}],\"name\":\"Bond\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bonds\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint48\",\"name\":\"end\",\"type\":\"uint48\"}],\"name\":\"CreateMarket\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"kotoAdded\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethAdded\",\"type\":\"uint256\"}],\"name\":\"IncreaseLiquidity\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"Launched\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"LimitsRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"openingTime\",\"type\":\"uint256\"}],\"name\":\"OpenBondMarket\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"burned\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"payout\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"floorPrice\",\"type\":\"uint256\"}],\"name\":\"Redeem\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"userToExclude\",\"type\":\"address\"}],\"name\":\"UserExcluded\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pool\",\"type\":\"address\"}],\"name\":\"addAmm\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bond\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"payout\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_lpAmount\",\"type\":\"uint256\"}],\"name\":\"bondLp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"payout\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bondPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bondPriceLp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ethBondAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lpBondAmount\",\"type\":\"uint256\"}],\"name\":\"create\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depository\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"exclude\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"launch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lpMarketInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"uint96\",\"name\":\"capacity\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"totalDebt\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"maxPayout\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"sold\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"purchased\",\"type\":\"uint96\"}],\"internalType\":\"struct PricingLibrary.Market\",\"name\":\"\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint48\",\"name\":\"conclusion\",\"type\":\"uint48\"},{\"internalType\":\"uint256\",\"name\":\"controlVariable\",\"type\":\"uint256\"}],\"internalType\":\"struct PricingLibrary.Term\",\"name\":\"\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint48\",\"name\":\"lastTune\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"lastDecay\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"length\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"depositInterval\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"tuneInterval\",\"type\":\"uint48\"}],\"internalType\":\"struct PricingLibrary.Data\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"uint96\",\"name\":\"capacity\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"totalDebt\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"maxPayout\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"sold\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"purchased\",\"type\":\"uint96\"}],\"internalType\":\"struct PricingLibrary.Market\",\"name\":\"\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint48\",\"name\":\"conclusion\",\"type\":\"uint48\"},{\"internalType\":\"uint256\",\"name\":\"controlVariable\",\"type\":\"uint256\"}],\"internalType\":\"struct PricingLibrary.Term\",\"name\":\"\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint48\",\"name\":\"lastTune\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"lastDecay\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"length\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"depositInterval\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"tuneInterval\",\"type\":\"uint48\"}],\"internalType\":\"struct PricingLibrary.Data\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ownership\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"redeem\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"payout\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"redemptionPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "KotoV3", "CompilerVersion": "v0.8.23+commit.f704f362", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "shanghai", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://caf4e3b4220f06c011dec8269de8b0005be17a0e02575fba2b57079b228073c0"}