{"SourceCode": "/**\r\n *Submitted for verification at BscScan.com on 2023-10-18\r\n*/\r\n\r\n/*                                                                                                                                                                                      \r\n * ARK Terra Card ETHEREUM\r\n * \r\n * Forked/Edited by: DutchDapps.com \r\n * \r\n * SPDX-License-Identifier: None\r\n */\r\n\r\npragma solidity ^0.8.20;\r\n\r\ninterface IBEP20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function decimals() external view returns (uint8);\r\n    function symbol() external view returns (string memory);\r\n    function name() external view returns (string memory);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address _owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount ) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ninterface IDEXRouter {\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external;\r\n    function getAmountsOut(uint256 amountIn, address[] calldata path) external view returns (uint256[] memory amounts);\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(uint256 amountOutMin, address[] calldata path, address to, uint256 deadline) external payable;\r\n}\r\n\r\ncontract CC_OFFRAMP  {    \r\n    address public constant CEO = 0xB8e0a68f2509b89f08E0D9F3C1a48Fc0d5Cf68B0;\r\n    address public treasury = 0xB8e0a68f2509b89f08E0D9F3C1a48Fc0d5Cf68B0;\r\n    address public fallbackReferrer = 0xB8e0a68f2509b89f08E0D9F3C1a48Fc0d5Cf68B0;\r\n    \r\n    IBEP20 public constant USDT = IBEP20(0xdAC17F958D2ee523a2206206994597C13D831ec7);\r\n    IDEXRouter public constant ROUTER = IDEXRouter(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\r\n    address public constant WBNB = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\r\n    \r\n    mapping(string => Deposit) public deposits;\r\n    mapping(string => CardBuy) public cardBuys;\r\n    mapping(address => address) public referrerOf;\r\n    mapping(address => address[]) public downline;   \r\n    mapping(address => uint256) public totalReferralRewards1;\r\n    mapping(address => uint256) public totalReferralRewards2;\r\n    mapping(address => uint256) public totalReferralRewardsCard1;\r\n    mapping(address => uint256) public totalReferralRewardsCard2;\r\n    mapping(address => uint256) public totalReferrals;\r\n\r\n    event DepositDone(string uid, Deposit details);\r\n    event CardBought(string uid, CardBuy details);\r\n    \r\n    uint256 multiplier = 10**6;\r\n    uint256 minDeposit;\r\n    uint256 maxDeposit = 5000 * multiplier;\r\n    uint256 public affiliateReward = 20;\r\n    uint256 public secondLevelReward = 5;\r\n    uint256 public rewardDivisor = 10000;\r\n\r\n    uint256 public plasticFirstLevel = 25 * multiplier;\r\n    uint256 public plasticSecondLevel = 5 * multiplier;\r\n    uint256 public metalFirstLevel = 40 * multiplier;\r\n    uint256 public metalSecondLevel = 10* multiplier;\r\n    uint256 public customFirstLevel = 65 * multiplier;\r\n    uint256 public customSecondLevel = 15 * multiplier;\r\n    uint256 public customPrice = 400 * multiplier;\r\n    uint256 public metalPrice = 250 * multiplier;\r\n    uint256 public plasticPrice = 150 * multiplier;\r\n\r\n    struct Deposit {\r\n        address user;\r\n        address currency;\r\n        uint256 currencyAmount;\r\n        uint256 depositAmount;\r\n        uint256 timestamp;\r\n        bool isReload;\r\n        bool hasSupport;\r\n        bool hasLegacy;\r\n        address referrer;\r\n        address secondLevelReferrer;\r\n    }\r\n\r\n    struct CardBuy {\r\n        address user;\r\n        address currency;\r\n        uint256 currencyAmount;\r\n        uint256 depositAmount;\r\n        uint256 timestamp;\r\n        bool isMetal;\r\n        bool isCustom;\r\n        bool hasLegacy;\r\n        address referrer;\r\n        address secondLevelReferrer;\r\n    }\r\n\r\n    modifier onlyCEO() {\r\n        require(msg.sender == CEO, \"Only CEO\");\r\n        _;\r\n    }\r\n\r\n\tconstructor() {\r\n        TransferHelper.safeApprove(address(USDT), address(ROUTER), type(uint256).max);\r\n    }\r\n\r\n    receive() external payable {}\r\n\r\n    function checkIfUidIsUsed(string memory uid) internal view returns (bool) {\r\n        if(deposits[uid].timestamp != 0) return true;\r\n        return false;\r\n    }\r\n\r\n    function depositMoneyUSDT(uint256 amount, string memory uid, bool isReload, bool hasSupport, address referrer, bool hasLegacy) external {\r\n        require(!checkIfUidIsUsed(uid),\"Uid already exists\");\r\n        uint256 balanceBefore = USDT.balanceOf(address(this));        \r\n        TransferHelper.safeTransferFrom(address(USDT), msg.sender, address(this), amount);\r\n        Deposit memory deposit = Deposit(msg.sender, address(USDT), amount, 0, block.timestamp, isReload, hasSupport, false, address(0), address(0));\r\n        deposits[uid] = deposit;\r\n        if(referrer == address(0) || referrer == msg.sender) referrer = fallbackReferrer;  \r\n        if(referrerOf[msg.sender] == address(0)) {\r\n            referrerOf[msg.sender] = referrer;\r\n            downline[referrer].push(msg.sender);\r\n        }\r\n        _deposit(balanceBefore, uid, referrerOf[msg.sender], hasLegacy);\r\n    }\r\n\r\n    function depositMoneyBNB(string memory uid, uint256 minOut, bool isReload, bool hasSupport, address referrer, bool hasLegacy) public payable {\r\n        require(!checkIfUidIsUsed(uid),\"Uid already exists\");\r\n        uint256 balanceBefore = USDT.balanceOf(address(this));\r\n        Deposit memory deposit = Deposit(msg.sender, address(0), msg.value, 0, block.timestamp, isReload, hasSupport, false, address(0), address(0));\r\n        deposits[uid] = deposit;\r\n\r\n        address[] memory path = new address[](2);\r\n        path[0] = WBNB;\r\n        path[1] = address(USDT);\r\n        \r\n        ROUTER.swapExactETHForTokensSupportingFeeOnTransferTokens{value: msg.value}(\r\n            minOut,\r\n            path,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n        if(referrer == address(0) || referrer == msg.sender) referrer = fallbackReferrer;  \r\n        if(referrerOf[msg.sender] == address(0)) {\r\n            referrerOf[msg.sender] = referrer;\r\n            downline[referrer].push(msg.sender);\r\n        }\r\n        _deposit(balanceBefore, uid, referrerOf[msg.sender], hasLegacy);\r\n    }\r\n\r\n    function depositMoneyEasy(\r\n        uint256 amount, \r\n        address currency, \r\n        uint256 minOut, \r\n        string memory uid, \r\n        bool isReload, \r\n        bool hasSupport, \r\n        address referrer, \r\n        bool hasLegacy\r\n    ) external {\r\n        require(!checkIfUidIsUsed(uid),\"Uid already exists\");        \r\n        TransferHelper.safeTransferFrom(currency, msg.sender, address(this), amount);\r\n        TransferHelper.safeApprove(currency, address(ROUTER), type(uint256).max);\r\n\r\n        Deposit memory deposit = Deposit(msg.sender, currency, amount, 0, block.timestamp, isReload, hasSupport, false, address(0), address(0));\r\n        deposits[uid] = deposit;\r\n\r\n        address[] memory path = new address[](2);\r\n        path[0] = currency;\r\n        path[1] = address(USDT);\r\n\r\n        uint256 balanceBefore = USDT.balanceOf(address(this));\r\n        ROUTER.swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n            amount,\r\n            minOut,\r\n            path,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n        if(referrer == address(0) || referrer == msg.sender) referrer = fallbackReferrer;  \r\n        if(referrerOf[msg.sender] == address(0)) {\r\n            referrerOf[msg.sender] = referrer;\r\n            downline[referrer].push(msg.sender);\r\n        }\r\n        _deposit(balanceBefore, uid, referrerOf[msg.sender], hasLegacy);\r\n    }\r\n\r\n    function depositMoneyExpert(\r\n        uint256 amount,\r\n        address[] memory path,\r\n        uint256 minOut,\r\n        string memory uid,\r\n        bool isReload,\r\n        bool hasSupport,\r\n        address referrer,\r\n        bool hasLegacy\r\n    ) external {\r\n        require(!checkIfUidIsUsed(uid),\"Uid already exists\");        \r\n        TransferHelper.safeTransferFrom(path[0], msg.sender, address(this), amount);\r\n        require(path[path.length - 1] == address(USDT), \"wrong\");\r\n        TransferHelper.safeApprove(path[0], address(ROUTER), type(uint256).max);\r\n\r\n        Deposit memory deposit = Deposit(msg.sender, path[0], amount, 0, block.timestamp, isReload, hasSupport, false, address(0), address(0));\r\n        deposits[uid] = deposit;\r\n        \r\n        uint256 balanceBefore = USDT.balanceOf(address(this));\r\n        ROUTER.swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n            amount,\r\n            minOut,\r\n            path,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n        if(referrer == address(0) || referrer == msg.sender) referrer = fallbackReferrer;  \r\n        if(referrerOf[msg.sender] == address(0)) {\r\n            referrerOf[msg.sender] = referrer;\r\n            downline[referrer].push(msg.sender);\r\n        }\r\n        _deposit(balanceBefore, uid, referrerOf[msg.sender], hasLegacy);\r\n    }\r\n\r\n    function _deposit(uint256 balanceBefore, string memory uid, address referrer, bool hasLegacy) internal {\r\n        uint256 depositAmount = USDT.balanceOf(address(this)) - balanceBefore;\r\n        require(depositAmount >= minDeposit, \"Min deposit\");\r\n        require(depositAmount <= maxDeposit, \"Max deposit\");\r\n        deposits[uid].depositAmount = depositAmount;        \r\n        deposits[uid].hasLegacy = hasLegacy;\r\n        if(!hasLegacy) {\r\n            uint256 firstLevelAmount = depositAmount * affiliateReward / rewardDivisor;\r\n            uint256 secondLevelAmount = depositAmount * secondLevelReward / rewardDivisor;\r\n                        \r\n            TransferHelper.safeTransfer(address(USDT), referrer, firstLevelAmount);\r\n            if(referrerOf[referrer] == address(0)) referrerOf[referrer] = fallbackReferrer;\r\n            address secondLevelAddress = referrerOf[referrer];\r\n            TransferHelper.safeTransfer(address(USDT), secondLevelAddress, secondLevelAmount);\r\n            totalReferralRewards1[referrer] += firstLevelAmount;\r\n            totalReferralRewards2[secondLevelAddress] += secondLevelAmount;\r\n            totalReferrals[referrer]++;\r\n            totalReferrals[secondLevelAddress]++;\r\n            deposits[uid].referrer = referrer;\r\n            deposits[uid].secondLevelReferrer = secondLevelAddress;\r\n            depositAmount -= firstLevelAmount;\r\n            depositAmount -= secondLevelAmount;\r\n        }\r\n\r\n        TransferHelper.safeTransfer(address(USDT), treasury, depositAmount);\r\n        emit DepositDone(uid, deposits[uid]);\r\n    }\r\n\r\n    function expectedUSDTFromCurrency(uint256 input, address currency) public view returns(uint256) {\r\n        address[] memory path = new address[](2);\r\n        path[0] = currency;\r\n        path[1] = address(USDT);\r\n        uint256 usdtAmount = ROUTER.getAmountsOut(input, path)[path.length - 1];\r\n        return usdtAmount; \r\n    }\r\n\r\n    function expectedUSDTFromPath(uint256 input, address[] memory path) public view returns(uint256) {\r\n        require(path[path.length-1] == address(USDT), \"USDT\");\r\n        uint256 usdtAmount = ROUTER.getAmountsOut(input, path)[path.length - 1];\r\n        return usdtAmount;\r\n    }\r\n\r\n    function rescueAnyToken(IBEP20 tokenToRescue) external onlyCEO {\r\n        uint256 _balance = tokenToRescue.balanceOf(address(this));        \r\n        TransferHelper.safeTransfer(address(tokenToRescue), CEO, _balance);        \r\n    }\r\n\r\n    function rescueBnb() external onlyCEO {\r\n        (bool success,) = address(CEO).call{value: address(this).balance}(\"\");\r\n        if(success) return;\r\n    } \r\n\r\n    function setLimits(uint256 newMinDeposit, uint256 newMaxDeposit) external onlyCEO {\r\n        minDeposit = newMinDeposit * multiplier;\r\n        maxDeposit = newMaxDeposit * multiplier;\r\n    }\r\n    \r\n    function setTreasury(address newTreasury) external onlyCEO {\r\n        treasury = newTreasury;\r\n    }    \r\n\r\n    function setFallbackReferrer(address newFallbackReferrer) external onlyCEO {\r\n        fallbackReferrer = newFallbackReferrer;\r\n    }\r\n\r\n    function setReferrer(address investor, address newReferrer) external onlyCEO {\r\n        referrerOf[investor] = newReferrer;\r\n    }\r\n\r\n    function setReferrers(address oldReferrer, address newReferrer) external onlyCEO {\r\n        for(uint256 i = 0; i<downline[oldReferrer].length;i++){\r\n            referrerOf[downline[oldReferrer][i]] = newReferrer;\r\n        }\r\n    }\r\n\r\n    function setAffiliateReward(uint256 newAffiliateReward, uint256 newSecondLevelReward) external onlyCEO {\r\n        affiliateReward = newAffiliateReward * multiplier;\r\n        secondLevelReward = newSecondLevelReward * multiplier;\r\n    }\r\n\r\n\r\n    function buyCardUSDT(uint256 amount, string memory uid, bool isMetal, bool isCustom, address referrer, bool hasLegacy) external {\r\n        require(!checkIfUidIsUsed(uid),\"Uid already exists\");\r\n        uint256 balanceBefore = USDT.balanceOf(address(this));\r\n        TransferHelper.safeTransferFrom(address(USDT), msg.sender, address(this), amount);\r\n\r\n        CardBuy memory buy = CardBuy(msg.sender, address(USDT), amount, 0, block.timestamp, isMetal, isCustom, false, address(0), address(0));\r\n        cardBuys[uid] = buy;\r\n        if(referrer == address(0) || referrer == msg.sender) referrer = fallbackReferrer;  \r\n        if(referrerOf[msg.sender] == address(0)) {\r\n            referrerOf[msg.sender] = referrer;\r\n            downline[referrer].push(msg.sender);\r\n        }\r\n        _cardBuy(balanceBefore, uid, referrerOf[msg.sender], hasLegacy);\r\n    }\r\n\r\n    function buyCardBNB(string memory uid, uint256 minOut, bool isMetal, bool isCustom, address referrer, bool hasLegacy) public payable {\r\n        require(!checkIfUidIsUsed(uid),\"Uid already exists\");\r\n        uint256 balanceBefore = USDT.balanceOf(address(this));\r\n        CardBuy memory buy = CardBuy(msg.sender, address(0), msg.value, 0, block.timestamp, isMetal, isCustom, false, address(0), address(0));\r\n        cardBuys[uid] = buy;\r\n\r\n        address[] memory path = new address[](2);\r\n        path[0] = WBNB;\r\n        path[1] = address(USDT);\r\n        \r\n        ROUTER.swapExactETHForTokensSupportingFeeOnTransferTokens{value: msg.value}(\r\n            minOut,\r\n            path,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n        if(referrer == address(0) || referrer == msg.sender) referrer = fallbackReferrer;  \r\n        if(referrerOf[msg.sender] == address(0)) {\r\n            referrerOf[msg.sender] = referrer;\r\n            downline[referrer].push(msg.sender);\r\n        }\r\n        _cardBuy(balanceBefore, uid, referrerOf[msg.sender], hasLegacy);\r\n    }\r\n\r\n    function buyCardEasy(\r\n        uint256 amount, \r\n        address currency, \r\n        uint256 minOut, \r\n        string memory uid, \r\n        bool isMetal,\r\n        bool isCustom,\r\n        address referrer,\r\n        bool hasLegacy\r\n    ) external {\r\n        require(!checkIfUidIsUsed(uid),\"Uid already exists\");        \r\n        TransferHelper.safeTransferFrom(currency, msg.sender, address(this), amount); \r\n        TransferHelper.safeApprove(currency, address(ROUTER), type(uint256).max);\r\n\r\n        CardBuy memory buy = CardBuy(msg.sender, currency, amount, 0, block.timestamp, isMetal, isCustom, false, address(0), address(0));\r\n        cardBuys[uid] = buy;\r\n\r\n        address[] memory path = new address[](2);\r\n        path[0] = currency;\r\n        path[1] = address(USDT);\r\n\r\n        uint256 balanceBefore = USDT.balanceOf(address(this));\r\n        ROUTER.swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n            amount,\r\n            minOut,\r\n            path,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n        if(referrer == address(0) || referrer == msg.sender) referrer = fallbackReferrer;  \r\n        if(referrerOf[msg.sender] == address(0)) {\r\n            referrerOf[msg.sender] = referrer;\r\n            downline[referrer].push(msg.sender);\r\n        }\r\n        _cardBuy(balanceBefore, uid, referrerOf[msg.sender], hasLegacy);\r\n    }\r\n\r\n    function buyCardExpert(\r\n        uint256 amount,\r\n        address[] memory path,\r\n        uint256 minOut,\r\n        string memory uid,\r\n        bool isMetal,\r\n        bool isCustom,\r\n        address referrer,\r\n        bool hasLegacy\r\n    ) external {\r\n        require(!checkIfUidIsUsed(uid),\"Uid already exists\");        \r\n        TransferHelper.safeTransferFrom(path[0], msg.sender, address(this), amount);\r\n        require(path[path.length - 1] == address(USDT), \"wrong\");\r\n        TransferHelper.safeApprove(path[0], address(ROUTER), type(uint256).max);\r\n\r\n        CardBuy memory buy = CardBuy(msg.sender, path[0], amount, 0, block.timestamp, isMetal, isCustom, false, address(0), address(0));\r\n        cardBuys[uid] = buy;\r\n        \r\n        uint256 balanceBefore = USDT.balanceOf(address(this));\r\n        ROUTER.swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n            amount,\r\n            minOut,\r\n            path,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n        if(referrer == address(0) || referrer == msg.sender) referrer = fallbackReferrer;  \r\n        if(referrerOf[msg.sender] == address(0)) {\r\n            referrerOf[msg.sender] = referrer;\r\n            downline[referrer].push(msg.sender);\r\n        }\r\n        _cardBuy(balanceBefore, uid, referrerOf[msg.sender], hasLegacy);\r\n    }\r\n\r\n\r\n    function _cardBuy(uint256 balanceBefore, string memory uid, address referrer, bool hasLegacy) internal {\r\n        uint256 depositAmount = USDT.balanceOf(address(this)) - balanceBefore;\r\n        if(cardBuys[uid].isCustom) require(depositAmount >= customPrice, \"Not enough\");\r\n        else if(cardBuys[uid].isMetal) require(depositAmount >= metalPrice, \"Not enough\");\r\n        else require(depositAmount >= plasticPrice, \"Not enough\");\r\n\r\n        cardBuys[uid].depositAmount = depositAmount;        \r\n        cardBuys[uid].hasLegacy = hasLegacy;\r\n\r\n        uint256 firstLevelAmount = cardBuys[uid].isCustom ? customFirstLevel : cardBuys[uid].isMetal ? metalFirstLevel : plasticFirstLevel;\r\n        uint256 secondLevelAmount = cardBuys[uid].isCustom ? customSecondLevel : cardBuys[uid].isMetal ? metalSecondLevel : plasticSecondLevel;\r\n        \r\n        TransferHelper.safeTransfer(address(USDT), referrer, firstLevelAmount);\r\n        if(referrerOf[referrer] == address(0)) referrerOf[referrer] = fallbackReferrer;\r\n        address secondLevelAddress = referrerOf[referrer];\r\n        TransferHelper.safeTransfer(address(USDT), secondLevelAddress, secondLevelAmount);\r\n        totalReferralRewardsCard1[referrer] += firstLevelAmount;\r\n        totalReferralRewardsCard2[secondLevelAddress] += secondLevelAmount;\r\n        totalReferrals[referrer]++;\r\n        totalReferrals[secondLevelAddress]++;\r\n        deposits[uid].referrer = referrer;\r\n        deposits[uid].secondLevelReferrer = secondLevelAddress;\r\n        depositAmount -= firstLevelAmount;\r\n        depositAmount -= secondLevelAmount;\r\n\r\n        TransferHelper.safeTransfer(address(USDT), treasury, depositAmount);        \r\n        emit CardBought(uid, cardBuys[uid]);\r\n    }\r\n}\r\n\r\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\r\nlibrary TransferHelper {\r\n    function safeApprove(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\r\n    }\r\n\r\n    function safeTransfer(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\r\n    }\r\n\r\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\r\n    }\r\n\r\n    function safeTransferETH(address to, uint value) internal {\r\n        (bool success,) = to.call{value:value}(new bytes(0));\r\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"uid\",\"type\":\"string\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"currency\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"currencyAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isMetal\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isCustom\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"hasLegacy\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"secondLevelReferrer\",\"type\":\"address\"}],\"indexed\":false,\"internalType\":\"struct CC_OFFRAMP.CardBuy\",\"name\":\"details\",\"type\":\"tuple\"}],\"name\":\"CardBought\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"uid\",\"type\":\"string\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"currency\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"currencyAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isReload\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"hasSupport\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"hasLegacy\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"secondLevelReferrer\",\"type\":\"address\"}],\"indexed\":false,\"internalType\":\"struct CC_OFFRAMP.Deposit\",\"name\":\"details\",\"type\":\"tuple\"}],\"name\":\"DepositDone\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CEO\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ROUTER\",\"outputs\":[{\"internalType\":\"contract IDEXRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"USDT\",\"outputs\":[{\"internalType\":\"contract IBEP20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WBNB\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"affiliateReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"uid\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"minOut\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isMetal\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isCustom\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"hasLegacy\",\"type\":\"bool\"}],\"name\":\"buyCardBNB\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"currency\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minOut\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"uid\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"isMetal\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isCustom\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"hasLegacy\",\"type\":\"bool\"}],\"name\":\"buyCardEasy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"minOut\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"uid\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"isMetal\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isCustom\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"hasLegacy\",\"type\":\"bool\"}],\"name\":\"buyCardExpert\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"uid\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"isMetal\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isCustom\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"hasLegacy\",\"type\":\"bool\"}],\"name\":\"buyCardUSDT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"cardBuys\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"currency\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"currencyAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isMetal\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isCustom\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"hasLegacy\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"secondLevelReferrer\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"customFirstLevel\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"customPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"customSecondLevel\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"uid\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"minOut\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isReload\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"hasSupport\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"hasLegacy\",\"type\":\"bool\"}],\"name\":\"depositMoneyBNB\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"currency\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minOut\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"uid\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"isReload\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"hasSupport\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"hasLegacy\",\"type\":\"bool\"}],\"name\":\"depositMoneyEasy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"minOut\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"uid\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"isReload\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"hasSupport\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"hasLegacy\",\"type\":\"bool\"}],\"name\":\"depositMoneyExpert\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"uid\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"isReload\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"hasSupport\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"hasLegacy\",\"type\":\"bool\"}],\"name\":\"depositMoneyUSDT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"deposits\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"currency\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"currencyAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isReload\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"hasSupport\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"hasLegacy\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"secondLevelReferrer\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"downline\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"input\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"currency\",\"type\":\"address\"}],\"name\":\"expectedUSDTFromCurrency\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"input\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"}],\"name\":\"expectedUSDTFromPath\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fallbackReferrer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"metalFirstLevel\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"metalPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"metalSecondLevel\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"plasticFirstLevel\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"plasticPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"plasticSecondLevel\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"referrerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IBEP20\",\"name\":\"tokenToRescue\",\"type\":\"address\"}],\"name\":\"rescueAnyToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rescueBnb\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardDivisor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"secondLevelReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newAffiliateReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newSecondLevelReward\",\"type\":\"uint256\"}],\"name\":\"setAffiliateReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newFallbackReferrer\",\"type\":\"address\"}],\"name\":\"setFallbackReferrer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newMinDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newMaxDeposit\",\"type\":\"uint256\"}],\"name\":\"setLimits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"investor\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"newReferrer\",\"type\":\"address\"}],\"name\":\"setReferrer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"oldReferrer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"newReferrer\",\"type\":\"address\"}],\"name\":\"setReferrers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newTreasury\",\"type\":\"address\"}],\"name\":\"setTreasury\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalReferralRewards1\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalReferralRewards2\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalReferralRewardsCard1\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalReferralRewardsCard2\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalReferrals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasury\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "CC_OFFRAMP", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://d4240dbbb7622856b37a564a5f7018eea4c13c3063599d77cb91f38370f22483"}