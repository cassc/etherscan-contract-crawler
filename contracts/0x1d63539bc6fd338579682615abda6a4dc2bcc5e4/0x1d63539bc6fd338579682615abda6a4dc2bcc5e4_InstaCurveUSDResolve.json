{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/protocols/mainnet/crvusd/helpers.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.6;\\nimport \\\"./interfaces.sol\\\";\\nimport { DSMath } from \\\"../../../utils/dsmath.sol\\\";\\n\\ncontract CRVHelpers is DSMath {\\n    address internal constant CRV_USD = 0xf939E0A03FB07F59A73314E73794Be0E57ac1b4E;\\n    /**\\n     * @dev ControllerFactory Interface\\n     */\\n    IControllerFactory internal constant CONTROLLER_FACTORY =\\n        IControllerFactory(0xC9332fdCB1C491Dcc683bAe86Fe3cb70360738BC);\\n\\n    /**\\n     * @dev Get controller address by given collateral asset\\n     */\\n    function getController(address collateral, uint256 i) internal view returns (IController controller) {\\n        controller = IController(CONTROLLER_FACTORY.get_controller(collateral, i));\\n    }\\n\\n    function getMarketConfig(address market, uint256 index) internal view returns (MarketConfig memory config) {\\n        IController controller = getController(market, index);\\n        address AMM = controller.amm();\\n        address monetary = controller.monetary_policy();\\n        config.controller = address(controller);\\n        config.AMM = AMM;\\n        config.monetary = monetary;\\n        config.oraclePrice = controller.amm_price();\\n        config.loanLen = controller.n_loans();\\n        config.totalDebt = controller.total_debt();\\n\\n        address coin0 = I_LLAMMA(AMM).coins(0);\\n        address coin1 = I_LLAMMA(AMM).coins(1);\\n        uint8 decimals0 = IERC20(coin0).decimals();\\n        uint8 decimals1 = IERC20(coin1).decimals();\\n        uint256 amount0 = IERC20(coin0).balanceOf(AMM);\\n        uint256 amount1 = IERC20(coin1).balanceOf(AMM);\\n\\n        Coins memory c = Coins(coin0, coin1, decimals0, decimals1, amount0, amount1);\\n\\n        config.coins = c;\\n        config.borrowable = IERC20(CRV_USD).balanceOf(address(controller));\\n        config.basePrice = I_LLAMMA(AMM).get_base_price();\\n        config.A = I_LLAMMA(AMM).A();\\n        config.minBand = I_LLAMMA(AMM).min_band();\\n        config.maxBand = I_LLAMMA(AMM).max_band();\\n\\n        try IMonetary(monetary).rate(address(controller)) returns (uint256 rate) {\\n            config.fractionPerSecond = rate;\\n        } catch {\\n            config.fractionPerSecond = IMonetary(monetary).rate();\\n        }\\n        config.sigma = IMonetary(monetary).sigma();\\n        config.targetDebtFraction = IMonetary(monetary).target_debt_fraction();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/protocols/mainnet/crvusd/interfaces.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nstruct PositionData {\\n    uint256 supply;\\n    uint256 borrow;\\n    uint256 N;\\n    bool existLoan;\\n    uint256 health;\\n    UserPrices prices;\\n    uint256 loanId;\\n    int256[2] userTickNumber; // calculating for user band range\\n}\\n\\nstruct UserPrices {\\n    uint256 upper;\\n    uint256 lower;\\n}\\n\\nstruct Coins {\\n    address coin0; // borrowToken\\n    address coin1; // collateralToken\\n    uint8 coin0Decimals;\\n    uint8 coin1Decimals;\\n    uint256 coin0Amount;\\n    uint256 coin1Amount;\\n}\\n\\nstruct MarketConfig {\\n    uint256 totalDebt;\\n    uint256 basePrice; // internal oracle price\\n    uint256 oraclePrice; // external oracle price\\n    uint256 A; // amplicitation coefficient\\n    uint256 loanLen;\\n    uint256 fractionPerSecond;\\n    int256 sigma;\\n    uint256 targetDebtFraction;\\n    address controller;\\n    address AMM;\\n    address monetary;\\n    uint256 borrowable;\\n    Coins coins; // factors for total collaterals\\n    int256 minBand;\\n    int256 maxBand;\\n}\\n\\ninterface IControllerFactory {\\n    function get_controller(address collateral, uint256 index) external view returns (address);\\n}\\n\\ninterface IController {\\n    function user_state(address user) external view returns (uint256[4] memory);\\n\\n    function debt(address user) external view returns (uint256);\\n\\n    function total_debt() external view returns (uint256);\\n\\n    function loan_exists(address user) external view returns (bool);\\n\\n    function user_prices(address user) external view returns (uint256[2] memory);\\n\\n    function health(address user, bool full) external view returns (uint256);\\n\\n    function n_loans() external view returns (uint256);\\n\\n    function loan_ix(address user) external view returns (uint256);\\n\\n    function amm() external view returns (address);\\n\\n    function loan_discount() external view returns (uint256);\\n\\n    function liquidation_discount() external view returns (uint256);\\n\\n    function amm_price() external view returns (uint256);\\n\\n    function monetary_policy() external view returns (address);\\n\\n    function max_borrowable(uint256 collateral, uint256 N) external view returns (uint256);\\n\\n    function min_collateral(uint256 debt, uint256 N) external view returns (uint256);\\n\\n    function calculate_debt_n1(\\n        uint256 collateral,\\n        uint256 debt,\\n        uint256 N\\n    ) external view returns (int256);\\n}\\n\\ninterface I_LLAMMA {\\n    function price_oracle() external view returns (uint256);\\n\\n    function A() external view returns (uint256);\\n\\n    function coins(uint256 i) external view returns (address);\\n\\n    function get_base_price() external view returns (uint256);\\n\\n    function read_user_tick_numbers(address user) external view returns (int256[2] memory);\\n\\n    function min_band() external view returns (int256);\\n\\n    function max_band() external view returns (int256);\\n\\n    function p_oracle_up(int256 bandNumber0) external view returns (uint256);\\n\\n    function p_oracle_down(int256 bandNumber1) external view returns (uint256);\\n}\\n\\ninterface IMonetary {\\n    function rate(address controller) external view returns (uint256);\\n\\n    function rate() external view returns (uint256);\\n\\n    function sigma() external view returns (int256);\\n\\n    function target_debt_fraction() external view returns (uint256);\\n\\n    function peg_keepers(uint256 arg0) external view returns (address);\\n}\\n\\ninterface IPegKeeper {\\n    function debt() external view returns (uint256);\\n}\\n\\ninterface IERC20 {\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"contracts/protocols/mainnet/crvusd/main.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.6;\\nimport \\\"./helpers.sol\\\";\\n\\n/**\\n *@title Curve USD Resolver\\n *@dev get user position, user configuration, market configuration.\\n */\\ncontract CurveUSDResolver is CRVHelpers {\\n    /**\\n     *@dev get position of the user for given collateral.\\n     *@notice get position details of the user in a market.\\n     *@param user Address of the user whose position details are needed.\\n     *@param market Address of the market for which the user's position details are needed\\n     *@param index  This is used for getting controller.\\n     *@return positionData position details of the user - balances, collaterals and flags.\\n     *@return marketConfig the market configuration details.\\n     */\\n    function getPosition(\\n        address user,\\n        address market,\\n        uint256 index\\n    ) public view returns (PositionData memory positionData, MarketConfig memory marketConfig) {\\n        IController controller = getController(market, index);\\n        uint256[4] memory res = controller.user_state(user);\\n        address AMM = controller.amm();\\n        positionData.userTickNumber = I_LLAMMA(AMM).read_user_tick_numbers(user);\\n        positionData.borrow = res[2];\\n        positionData.supply = res[0];\\n        positionData.N = res[3];\\n        positionData.existLoan = controller.loan_exists(user);\\n        positionData.health = positionData.existLoan ? controller.health(user, false) : 0;\\n        positionData.loanId = controller.loan_ix(user);\\n        if (positionData.existLoan) {\\n            uint256[2] memory prices = controller.user_prices(user);\\n            UserPrices memory userPrices = UserPrices(prices[0], prices[1]);\\n            positionData.prices = userPrices;\\n        }\\n\\n        marketConfig = getMarketConfig(market, index);\\n    }\\n\\n    /**\\n     *@dev get position of the user for given collateral.\\n     *@notice get position details of the user in a market.\\n     *@param user Address of the user whose position details are needed.\\n     *@param markets Addresses of the market for which the user's position details are needed\\n     *@param indexes  Array of index. It should be matched with markets.\\n     *@return positionData Array of positions details of the user - balances, collaterals and flags.\\n     *@return marketConfig Array of markets configuration details.\\n     */\\n    function getPositionAll(\\n        address user,\\n        address[] memory markets,\\n        uint256[] memory indexes\\n    ) public view returns (PositionData[] memory positionData, MarketConfig[] memory marketConfig) {\\n        require(markets.length == indexes.length);\\n        uint256 length = markets.length;\\n        positionData = new PositionData[](length);\\n        marketConfig = new MarketConfig[](length);\\n        for (uint256 i = 0; i < length; i++) {\\n            (positionData[i], marketConfig[i]) = getPosition(user, markets[i], indexes[i]);\\n        }\\n    }\\n\\n    /**\\n     *@dev get position of the user for all collaterals.\\n     *@notice get position details of the user in a market.\\n     *@param market Address of the market for which the user's position details are needed\\n     *@param index  This is used for getting controller.\\n     *@return marketConfig Detailed market configuration.\\n     */\\n    function getMarketDetails(address market, uint256 index) public view returns (MarketConfig memory marketConfig) {\\n        marketConfig = getMarketConfig(market, index);\\n    }\\n\\n    /**\\n     *@dev get position of the user for all collaterals.\\n     *@notice get position details of the user in a market.\\n     *@param markets Addresses of the market for which the user's position details are needed\\n     *@param indexes  Array of index. It should be matched with markets.\\n     *@return marketConfig Array of detailed market configuration.\\n     */\\n    function getMarketDetailsAll(address[] memory markets, uint256[] memory indexes)\\n        public\\n        view\\n        returns (MarketConfig[] memory marketConfig)\\n    {\\n        require(markets.length == indexes.length);\\n        uint256 length = markets.length;\\n        marketConfig = new MarketConfig[](length);\\n\\n        for (uint256 i = 0; i < length; i++) {\\n            marketConfig[i] = getMarketConfig(markets[i], indexes[i]);\\n        }\\n    }\\n\\n    /**\\n     *@dev get max debt amount with given collateral.\\n     *@param market Addresse of the market\\n     *@param version  Latest controller version\\n     *@return debt Max debt amount.\\n     */\\n    function getMaxDebt(\\n        address market,\\n        uint256 version,\\n        uint256 collateralAmount,\\n        uint256 bandNumber\\n    ) public view returns (uint256 debt) {\\n        IController controller = getController(market, version);\\n        return controller.max_borrowable(collateralAmount, bandNumber);\\n    }\\n\\n    /**\\n     *@dev get min collateral amount with given debt.\\n     *@param market Addresse of the market\\n     *@param version  Latest controller version\\n     *@return collateral Min collateral amount.\\n     */\\n    function getMinCollateral(\\n        address market,\\n        uint256 version,\\n        uint256 debt,\\n        uint256 bandNumber\\n    ) public view returns (uint256 collateral) {\\n        IController controller = getController(market, version);\\n        return controller.min_collateral(debt, bandNumber);\\n    }\\n\\n    /**\\n     *@dev get band range according to given collateral, debt and bandNumber.\\n     *@param market Addresse of the market\\n     *@param version Latest controller version\\n     *@param collateral  collateral amount.\\n     *@param debt  debt amount.\\n     *@return range Band range.\\n     *@return liquidation liquidation price range.\\n     */\\n    function getBandRangeAndLiquidationRange(\\n        address market,\\n        uint256 version,\\n        uint256 collateral,\\n        uint256 debt,\\n        uint256 bandNumber\\n    ) public view returns (int256[2] memory range, uint256[2] memory liquidation) {\\n        IController controller = getController(market, version);\\n        address AMM = controller.amm();\\n        int256 minBand = I_LLAMMA(AMM).min_band();\\n        int256 maxBand = I_LLAMMA(AMM).max_band();\\n        require(int256(bandNumber) >= minBand && int256(bandNumber) <= maxBand, \\\"Invalid band number\\\");\\n\\n        range[0] = controller.calculate_debt_n1(collateral, debt, bandNumber);\\n        range[1] = range[0] + int256(bandNumber) - 1;\\n        liquidation[0] = I_LLAMMA(AMM).p_oracle_up(range[0]);\\n        liquidation[1] = I_LLAMMA(AMM).p_oracle_down(range[1]);\\n    }\\n}\\n\\ncontract InstaCurveUSDResolver is CurveUSDResolver {\\n    string public constant name = \\\"CRVUSD-Resolver-v1.0\\\";\\n}\\n\"\r\n    },\r\n    \"contracts/utils/dsmath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.0;\\n\\ncontract DSMath {\\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        require((z = x + y) >= x, \\\"math-not-safe\\\");\\n    }\\n\\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        z = x - y <= x ? x - y : 0;\\n    }\\n\\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        require(y == 0 || (z = x * y) / y == x, \\\"math-not-safe\\\");\\n    }\\n\\n    function div(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        if (y == 0) return type(uint256).max;\\n        z = x / y;\\n    }\\n\\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\\n        if (y > 3) {\\n            z = y;\\n            uint256 x = y / 2 + 1;\\n            while (x < z) {\\n                z = x;\\n                x = (y / x + x) / 2;\\n            }\\n        } else if (y != 0) {\\n            z = 1;\\n        }\\n    }\\n\\n    uint256 internal constant WAD = 10**18;\\n    uint256 internal constant RAY = 10**27;\\n\\n    function rmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        z = add(mul(x, y), RAY / 2) / RAY;\\n    }\\n\\n    function wmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        z = add(mul(x, y), WAD / 2) / WAD;\\n    }\\n\\n    function rdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        z = add(mul(x, RAY), y / 2) / y;\\n    }\\n\\n    function wdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        z = add(mul(x, WAD), y / 2) / y;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\"\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 800\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"market\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"version\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"debt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bandNumber\",\"type\":\"uint256\"}],\"name\":\"getBandRangeAndLiquidationRange\",\"outputs\":[{\"internalType\":\"int256[2]\",\"name\":\"range\",\"type\":\"int256[2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"liquidation\",\"type\":\"uint256[2]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"market\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getMarketDetails\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"totalDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"basePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"oraclePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"A\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"loanLen\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fractionPerSecond\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"sigma\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"targetDebtFraction\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"controller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"AMM\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"monetary\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"borrowable\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"coin0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"coin1\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"coin0Decimals\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"coin1Decimals\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"coin0Amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"coin1Amount\",\"type\":\"uint256\"}],\"internalType\":\"struct Coins\",\"name\":\"coins\",\"type\":\"tuple\"},{\"internalType\":\"int256\",\"name\":\"minBand\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"maxBand\",\"type\":\"int256\"}],\"internalType\":\"struct MarketConfig\",\"name\":\"marketConfig\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"markets\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"indexes\",\"type\":\"uint256[]\"}],\"name\":\"getMarketDetailsAll\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"totalDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"basePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"oraclePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"A\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"loanLen\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fractionPerSecond\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"sigma\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"targetDebtFraction\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"controller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"AMM\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"monetary\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"borrowable\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"coin0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"coin1\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"coin0Decimals\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"coin1Decimals\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"coin0Amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"coin1Amount\",\"type\":\"uint256\"}],\"internalType\":\"struct Coins\",\"name\":\"coins\",\"type\":\"tuple\"},{\"internalType\":\"int256\",\"name\":\"minBand\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"maxBand\",\"type\":\"int256\"}],\"internalType\":\"struct MarketConfig[]\",\"name\":\"marketConfig\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"market\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"version\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bandNumber\",\"type\":\"uint256\"}],\"name\":\"getMaxDebt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"debt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"market\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"version\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"debt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bandNumber\",\"type\":\"uint256\"}],\"name\":\"getMinCollateral\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"collateral\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"market\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getPosition\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"supply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrow\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"N\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"existLoan\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"health\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"upper\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lower\",\"type\":\"uint256\"}],\"internalType\":\"struct UserPrices\",\"name\":\"prices\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"loanId\",\"type\":\"uint256\"},{\"internalType\":\"int256[2]\",\"name\":\"userTickNumber\",\"type\":\"int256[2]\"}],\"internalType\":\"struct PositionData\",\"name\":\"positionData\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"totalDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"basePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"oraclePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"A\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"loanLen\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fractionPerSecond\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"sigma\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"targetDebtFraction\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"controller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"AMM\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"monetary\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"borrowable\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"coin0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"coin1\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"coin0Decimals\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"coin1Decimals\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"coin0Amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"coin1Amount\",\"type\":\"uint256\"}],\"internalType\":\"struct Coins\",\"name\":\"coins\",\"type\":\"tuple\"},{\"internalType\":\"int256\",\"name\":\"minBand\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"maxBand\",\"type\":\"int256\"}],\"internalType\":\"struct MarketConfig\",\"name\":\"marketConfig\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"markets\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"indexes\",\"type\":\"uint256[]\"}],\"name\":\"getPositionAll\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"supply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrow\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"N\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"existLoan\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"health\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"upper\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lower\",\"type\":\"uint256\"}],\"internalType\":\"struct UserPrices\",\"name\":\"prices\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"loanId\",\"type\":\"uint256\"},{\"internalType\":\"int256[2]\",\"name\":\"userTickNumber\",\"type\":\"int256[2]\"}],\"internalType\":\"struct PositionData[]\",\"name\":\"positionData\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"totalDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"basePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"oraclePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"A\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"loanLen\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fractionPerSecond\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"sigma\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"targetDebtFraction\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"controller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"AMM\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"monetary\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"borrowable\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"coin0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"coin1\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"coin0Decimals\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"coin1Decimals\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"coin0Amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"coin1Amount\",\"type\":\"uint256\"}],\"internalType\":\"struct Coins\",\"name\":\"coins\",\"type\":\"tuple\"},{\"internalType\":\"int256\",\"name\":\"minBand\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"maxBand\",\"type\":\"int256\"}],\"internalType\":\"struct MarketConfig[]\",\"name\":\"marketConfig\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "InstaCurveUSDResolver", "CompilerVersion": "v0.8.6+commit.11564f7e", "OptimizationUsed": "1", "Runs": "800", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}