{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/Wallet/CloneableWallet.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.10;\\n\\nimport \\\"./CoreWallet.sol\\\";\\n\\n\\n/// @title Cloneable Wallet\\n/// @notice This contract represents a complete but non working wallet.  \\n///  It is meant to be deployed and serve as the contract that you clone\\n///  in an EIP 1167 clone setup.\\n/// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1167.md\\n/// @dev Currently, we are seeing approximatley 933 gas overhead for using\\n///  the clone wallet; use `FullWallet` if you think users will overtake\\n///  the transaction threshold over the lifetime of the wallet.\\ncontract CloneableWallet is CoreWallet {\\n\\n    /// @dev An empty constructor that deploys a NON-FUNCTIONAL version\\n    ///  of `CoreWallet`\\n    constructor () public {\\n        initialized = true;\\n    }\\n}\"\r\n    },\r\n    \"/contracts/Wallet/CoreWallet.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.10;\\n\\nimport \\\"../ERC721/ERC721Receivable.sol\\\";\\nimport \\\"../ERC223/ERC223Receiver.sol\\\";\\nimport \\\"../ERC1155/ERC1155TokenReceiver.sol\\\";\\nimport \\\"../ERC1271/ERC1271.sol\\\";\\nimport \\\"../ECDSA.sol\\\";\\n\\n\\n/// @title Core Wallet\\n/// @notice A basic smart contract wallet with cosigner functionality. The notion of \\\"cosigner\\\" is\\n///  the simplest possible multisig solution, a two-of-two signature scheme. It devolves nicely\\n///  to \\\"one-of-one\\\" (i.e. singlesig) by simply having the cosigner set to the same value as\\n///  the main signer.\\n/// \\n///  Most \\\"advanced\\\" functionality (deadman's switch, multiday recovery flows, blacklisting, etc)\\n///  can be implemented externally to this smart contract, either as an additional smart contract\\n///  (which can be tracked as a signer without cosigner, or as a cosigner) or as an off-chain flow\\n///  using a public/private key pair as cosigner. Of course, the basic cosigning functionality could\\n///  also be implemented in this way, but (A) the complexity and gas cost of two-of-two multisig (as\\n///  implemented here) is negligable even if you don't need the cosigner functionality, and\\n///  (B) two-of-two multisig (as implemented here) handles a lot of really common use cases, most\\n///  notably third-party gas payment and off-chain blacklisting and fraud detection.\\ncontract CoreWallet is ERC721Receivable, ERC223Receiver, ERC1271, ERC1155TokenReceiver {\\n\\n    using ECDSA for bytes;\\n\\n    /// @notice We require that presigned transactions use the EIP-191 signing format.\\n    ///  See that EIP for more info: https://github.com/ethereum/EIPs/blob/master/EIPS/eip-191.md\\n    byte public constant EIP191_VERSION_DATA = byte(0);\\n    byte public constant EIP191_PREFIX = byte(0x19);\\n\\n    /// @notice This is the version of the contract.\\n    string public constant VERSION = \\\"1.2.0\\\";\\n\\n    /// @notice This is a sentinel value used to determine when a delegate is set to expose \\n    ///  support for an interface containing more than a single function. See `delegates` and\\n    ///  `setDelegate` for more information.\\n    address public constant COMPOSITE_PLACEHOLDER = address(1);\\n\\n    /// @notice A pre-shifted \\\"1\\\", used to increment the authVersion, so we can \\\"prepend\\\"\\n    ///  the authVersion to an address (for lookups in the authorizations mapping)\\n    ///  by using the '+' operator (which is cheaper than a shift and a mask). See the\\n    ///  comment on the `authorizations` variable for how this is used.\\n    uint256 public constant AUTH_VERSION_INCREMENTOR = (1 << 160);\\n    \\n    /// @notice The pre-shifted authVersion (to get the current authVersion as an integer,\\n    ///  shift this value right by 160 bits). Starts as `1 << 160` (`AUTH_VERSION_INCREMENTOR`)\\n    ///  See the comment on the `authorizations` variable for how this is used.\\n    uint256 public authVersion;\\n\\n    /// @notice A mapping containing all of the addresses that are currently authorized to manage\\n    ///  the assets owned by this wallet.\\n    ///\\n    ///  The keys in this mapping are authorized addresses with a version number prepended,\\n    ///  like so: (authVersion,96)(address,160). The current authVersion MUST BE included\\n    ///  for each look-up; this allows us to effectively clear the entire mapping of its\\n    ///  contents merely by incrementing the authVersion variable. (This is important for\\n    ///  the emergencyRecovery() method.) Inspired by https://ethereum.stackexchange.com/a/42540\\n    ///\\n    ///  The values in this mapping are 256bit words, whose lower 20 bytes constitute \\\"cosigners\\\"\\n    ///  for each address. If an address maps to itself, then that address is said to have no cosigner.\\n    ///\\n    ///  The upper 12 bytes are reserved for future meta-data purposes.  The meta-data could refer\\n    ///  to the key (authorized address) or the value (cosigner) of the mapping.\\n    ///\\n    ///  Addresses that map to a non-zero cosigner in the current authVersion are called\\n    ///  \\\"authorized addresses\\\".\\n    mapping(uint256 => uint256) public authorizations;\\n\\n    /// @notice A per-key nonce value, incremented each time a transaction is processed with that key.\\n    ///  Used for replay prevention. The nonce value in the transaction must exactly equal the current\\n    ///  nonce value in the wallet for that key. (This mirrors the way Ethereum's transaction nonce works.)\\n    mapping(address => uint256) public nonces;\\n\\n    /// @notice A mapping tracking dynamically supported interfaces and their corresponding\\n    ///  implementation contracts. Keys are interface IDs and values are addresses of\\n    ///  contracts that are responsible for implementing the function corresponding to the\\n    ///  interface.\\n    ///  \\n    ///  Delegates are added (or removed) via the `setDelegate` method after the contract is\\n    ///  deployed, allowing support for new interfaces to be dynamically added after deployment.\\n    ///  When a delegate is added, its interface ID is considered \\\"supported\\\" under EIP165. \\n    ///\\n    ///  For cases where an interface composed of more than a single function must be\\n    ///  supported, it is necessary to manually add the composite interface ID with \\n    ///  `setDelegate(interfaceId, COMPOSITE_PLACEHOLDER)`. Interface IDs added with the\\n    ///  COMPOSITE_PLACEHOLDER address are ignored when called and are only used to specify\\n    ///  supported interfaces.\\n    mapping(bytes4 => address) public delegates;\\n\\n    /// @notice A special address that is authorized to call `emergencyRecovery()`. That function\\n    ///  resets ALL authorization for this wallet, and must therefore be treated with utmost security.\\n    ///  Reasonable choices for recoveryAddress include:\\n    ///       - the address of a private key in cold storage\\n    ///       - a physically secured hardware wallet\\n    ///       - a multisig smart contract, possibly with a time-delayed challenge period\\n    ///       - the zero address, if you like performing without a safety net ;-)\\n    address public recoveryAddress;\\n\\n    /// @notice Used to track whether or not this contract instance has been initialized. This\\n    ///  is necessary since it is common for this wallet smart contract to be used as the \\\"library\\n    ///  code\\\" for an clone contract. See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1167.md\\n    ///  for more information about clone contracts.\\n    bool public initialized;\\n    \\n    /// @notice Used to decorate methods that can only be called directly by the recovery address.\\n    modifier onlyRecoveryAddress() {\\n        require(msg.sender == recoveryAddress, \\\"sender must be recovery address\\\");\\n        _;\\n    }\\n\\n    /// @notice Used to decorate the `init` function so this can only be called one time. Necessary\\n    ///  since this contract will often be used as a \\\"clone\\\". (See above.)\\n    modifier onlyOnce() {\\n        require(!initialized, \\\"must not already be initialized\\\");\\n        initialized = true;\\n        _;\\n    }\\n    \\n    /// @notice Used to decorate methods that can only be called indirectly via an `invoke()` method.\\n    ///  In practice, it means that those methods can only be called by a signer/cosigner\\n    ///  pair that is currently authorized. Theoretically, we could factor out the\\n    ///  signer/cosigner verification code and use it explicitly in this modifier, but that\\n    ///  would either result in duplicated code, or additional overhead in the invoke()\\n    ///  calls (due to the stack manipulation for calling into the shared verification function).\\n    ///  Doing it this way makes calling the administration functions more expensive (since they\\n    ///  go through a explicit call() instead of just branching within the contract), but it\\n    ///  makes invoke() more efficient. We assume that invoke() will be used much, much more often\\n    ///  than any of the administration functions.\\n    modifier onlyInvoked() {\\n        require(msg.sender == address(this), \\\"must be called from `invoke()`\\\");\\n        _;\\n    }\\n    \\n    /// @notice Emitted when an authorized address is added, removed, or modified. When an\\n    ///  authorized address is removed (\\\"deauthorized\\\"), cosigner will be address(0) in\\n    ///  this event.\\n    ///  \\n    ///  NOTE: When emergencyRecovery() is called, all existing addresses are deauthorized\\n    ///  WITHOUT Authorized(addr, 0) being emitted. If you are keeping an off-chain mirror of\\n    ///  authorized addresses, you must also watch for EmergencyRecovery events.\\n    /// @dev hash is 0xf5a7f4fb8a92356e8c8c4ae7ac3589908381450500a7e2fd08c95600021ee889\\n    /// @param authorizedAddress the address to authorize or unauthorize\\n    /// @param cosigner the 2-of-2 signatory (optional).\\n    event Authorized(address authorizedAddress, uint256 cosigner);\\n    \\n    /// @notice Emitted when an emergency recovery has been performed. If this event is fired,\\n    ///  ALL previously authorized addresses have been deauthorized and the only authorized\\n    ///  address is the authorizedAddress indicated in this event.\\n    /// @dev hash is 0xe12d0bbeb1d06d7a728031056557140afac35616f594ef4be227b5b172a604b5\\n    /// @param authorizedAddress the new authorized address\\n    /// @param cosigner the cosigning address for `authorizedAddress`\\n    event EmergencyRecovery(address authorizedAddress, uint256 cosigner);\\n\\n    /// @notice Emitted when the recovery address changes. Either (but not both) of the\\n    ///  parameters may be zero.\\n    /// @dev hash is 0x568ab3dedd6121f0385e007e641e74e1f49d0fa69cab2957b0b07c4c7de5abb6\\n    /// @param previousRecoveryAddress the previous recovery address\\n    /// @param newRecoveryAddress the new recovery address\\n    event RecoveryAddressChanged(address previousRecoveryAddress, address newRecoveryAddress);\\n\\n    /// @dev Emitted when this contract receives a non-zero amount ether via the fallback function\\n    ///  (i.e. This event is not fired if the contract receives ether as part of a method invocation)\\n    /// @param from the address which sent you ether\\n    /// @param value the amount of ether sent\\n    event Received(address from, uint value);\\n\\n    /// @notice Emitted whenever a transaction is processed successfully from this wallet. Includes\\n    ///  both simple send ether transactions, as well as other smart contract invocations.\\n    /// @dev hash is 0x101214446435ebbb29893f3348e3aae5ea070b63037a3df346d09d3396a34aee\\n    /// @param hash The hash of the entire operation set. 0 is returned when emitted from `invoke0()`.\\n    /// @param result A bitfield of the results of the operations. A bit of 0 means success, and 1 means failure.\\n    /// @param numOperations A count of the number of operations processed\\n    event InvocationSuccess(\\n        bytes32 hash,\\n        uint256 result,\\n        uint256 numOperations\\n    );\\n\\n    /// @notice Emitted when a delegate is added or removed.\\n    /// @param interfaceId The interface ID as specified by EIP165\\n    /// @param delegate The address of the contract implementing the given function. If this is\\n    ///  COMPOSITE_PLACEHOLDER, we are indicating support for a composite interface.\\n    event DelegateUpdated(bytes4 interfaceId, address delegate);\\n\\n    /// @notice The shared initialization code used to setup the contract state regardless of whether or\\n    ///  not the clone pattern is being used.\\n    /// @param _authorizedAddress the initial authorized address, must not be zero!\\n    /// @param _cosigner the initial cosigning address for `_authorizedAddress`, can be equal to `_authorizedAddress`\\n    /// @param _recoveryAddress the initial recovery address for the wallet, can be address(0)\\n    function init(address _authorizedAddress, uint256 _cosigner, address _recoveryAddress) public onlyOnce {\\n        require(_authorizedAddress != _recoveryAddress, \\\"Do not use the recovery address as an authorized address.\\\");\\n        require(address(_cosigner) != _recoveryAddress, \\\"Do not use the recovery address as a cosigner.\\\");\\n        require(_authorizedAddress != address(0), \\\"Authorized addresses must not be zero.\\\");\\n        require(address(_cosigner) != address(0), \\\"Initial cosigner must not be zero.\\\");\\n        \\n        recoveryAddress = _recoveryAddress;\\n        // set initial authorization value\\n        authVersion = AUTH_VERSION_INCREMENTOR;\\n        // add initial authorized address\\n        authorizations[authVersion + uint256(_authorizedAddress)] = _cosigner;\\n        \\n        emit Authorized(_authorizedAddress, _cosigner);\\n    }\\n\\n    function bytesToAddresses(bytes memory bys) private pure returns (address[] memory addresses) {\\n            addresses = new address[](bys.length/20);\\n            for (uint i=0; i < bys.length; i+=20) {\\n                address addr;\\n                uint end = i+20;\\n                assembly {\\n                  addr := mload(add(bys,end))\\n                }\\n                addresses[i/20] = addr;\\n            }\\n        }\\n\\n    function init2(bytes memory _authorizedAddresses, uint256 _cosigner, address _recoveryAddress) public onlyOnce {\\n        address[] memory addresses = bytesToAddresses(_authorizedAddresses);\\n        for (uint i=0; i < addresses.length; i++) {\\n            address _authorizedAddress = addresses[i];\\n            require(_authorizedAddress != _recoveryAddress, \\\"Do not use the recovery address as an authorized address.\\\");\\n            require(address(_cosigner) != _recoveryAddress, \\\"Do not use the recovery address as a cosigner.\\\");\\n            require(_authorizedAddress != address(0), \\\"Authorized addresses must not be zero.\\\");\\n            require(address(_cosigner) != address(0), \\\"Initial cosigner must not be zero.\\\");\\n\\n            recoveryAddress = _recoveryAddress;\\n            // set initial authorization value\\n            authVersion = AUTH_VERSION_INCREMENTOR;\\n            // add initial authorized address\\n            authorizations[authVersion + uint256(_authorizedAddress)] = _cosigner;\\n\\n            emit Authorized(_authorizedAddress, _cosigner);\\n        }\\n    }\\n\\n    /// @notice The fallback function, invoked whenever we receive a transaction that doesn't call any of our\\n    ///  named functions. In particular, this method is called when we are the target of a simple send\\n    ///  transaction, when someone calls a method we have dynamically added a delegate for, or when someone\\n    ///  tries to call a function we don't implement, either statically or dynamically.\\n    ///\\n    ///  A correct invocation of this method occurs in two cases:\\n    ///  - someone transfers ETH to this wallet (`msg.data.length` is  0)\\n    ///  - someone calls a delegated function (`msg.data.length` is greater than 0 and\\n    ///    `delegates[msg.sig]` is set) \\n    ///  In all other cases, this function will revert.\\n    ///\\n    ///  NOTE: Some smart contracts send 0 eth as part of a more complex operation\\n    ///  (-cough- CryptoKitties -cough-); ideally, we'd `require(msg.value > 0)` here when\\n    ///  `msg.data.length == 0`, but to work with those kinds of smart contracts, we accept zero sends\\n    ///  and just skip logging in that case.\\n    function() external payable {\\n        if (msg.value > 0) {\\n            emit Received(msg.sender, msg.value);\\n        }\\n        if (msg.data.length > 0) {\\n            address delegate = delegates[msg.sig]; \\n            require(delegate > COMPOSITE_PLACEHOLDER, \\\"Invalid transaction\\\");\\n\\n            // We have found a delegate contract that is responsible for the method signature of\\n            // this call. Now, pass along the calldata of this CALL to the delegate contract.  \\n            assembly {\\n                calldatacopy(0, 0, calldatasize())\\n                let result := staticcall(gas, delegate, 0, calldatasize(), 0, 0)\\n                returndatacopy(0, 0, returndatasize())\\n\\n                // If the delegate reverts, we revert. If the delegate does not revert, we return the data\\n                // returned by the delegate to the original caller.\\n                switch result \\n                case 0 {\\n                    revert(0, returndatasize())\\n                } \\n                default {\\n                    return(0, returndatasize())\\n                }\\n            } \\n        }    \\n    }\\n\\n    /// @notice Adds or removes dynamic support for an interface. Can be used in 3 ways:\\n    ///   - Add a contract \\\"delegate\\\" that implements a single function\\n    ///   - Remove delegate for a function\\n    ///   - Specify that an interface ID is \\\"supported\\\", without adding a delegate. This is\\n    ///     used for composite interfaces when the interface ID is not a single method ID.\\n    /// @dev Must be called through `invoke`\\n    /// @param _interfaceId The ID of the interface we are adding support for\\n    /// @param _delegate Either:\\n    ///    - the address of a contract that implements the function specified by `_interfaceId`\\n    ///      for adding an implementation for a single function\\n    ///    - 0 for removing an existing delegate\\n    ///    - COMPOSITE_PLACEHOLDER for specifying support for a composite interface\\n    function setDelegate(bytes4 _interfaceId, address _delegate) external onlyInvoked {\\n        delegates[_interfaceId] = _delegate;\\n        emit DelegateUpdated(_interfaceId, _delegate);\\n    }\\n    \\n    /// @notice Configures an authorizable address. Can be used in four ways:\\n    ///   - Add a new signer/cosigner pair (cosigner must be non-zero)\\n    ///   - Set or change the cosigner for an existing signer (if authorizedAddress != cosigner)\\n    ///   - Remove the cosigning requirement for a signer (if authorizedAddress == cosigner)\\n    ///   - Remove a signer (if cosigner == address(0))\\n    /// @dev Must be called through `invoke()`\\n    /// @param _authorizedAddress the address to configure authorization\\n    /// @param _cosigner the corresponding cosigning address\\n    function setAuthorized(address _authorizedAddress, uint256 _cosigner) external onlyInvoked {\\n        // TODO: Allowing a signer to remove itself is actually pretty terrible; it could result in the user\\n        //  removing their only available authorized key. Unfortunately, due to how the invocation forwarding\\n        //  works, we don't actually _know_ which signer was used to call this method, so there's no easy way\\n        //  to prevent this.\\n        \\n        // TODO: Allowing the backup key to be set as an authorized address bypasses the recovery mechanisms.\\n        //  Dapper can prevent this with offchain logic and the cosigner, but it would be nice to have \\n        //  this enforced by the smart contract logic itself.\\n        \\n        require(_authorizedAddress != address(0), \\\"Authorized addresses must not be zero.\\\");\\n        require(_authorizedAddress != recoveryAddress, \\\"Do not use the recovery address as an authorized address.\\\");\\n        require(address(_cosigner) == address(0) || address(_cosigner) != recoveryAddress, \\\"Do not use the recovery address as a cosigner.\\\");\\n \\n        authorizations[authVersion + uint256(_authorizedAddress)] = _cosigner;\\n        emit Authorized(_authorizedAddress, _cosigner);\\n    }\\n    \\n    /// @notice Performs an emergency recovery operation, removing all existing authorizations and setting\\n    ///  a sole new authorized address with optional cosigner. THIS IS A SCORCHED EARTH SOLUTION, and great\\n    ///  care should be taken to ensure that this method is never called unless it is a last resort. See the\\n    ///  comments above about the proper kinds of addresses to use as the recoveryAddress to ensure this method\\n    ///  is not trivially abused.\\n    /// @param _authorizedAddress the new and sole authorized address\\n    /// @param _cosigner the corresponding cosigner address, can be equal to _authorizedAddress\\n    function emergencyRecovery(address _authorizedAddress, uint256 _cosigner) external onlyRecoveryAddress {\\n        require(_authorizedAddress != address(0), \\\"Authorized addresses must not be zero.\\\");\\n        require(_authorizedAddress != recoveryAddress, \\\"Do not use the recovery address as an authorized address.\\\");\\n        require(address(_cosigner) != address(0), \\\"The cosigner must not be zero.\\\");\\n\\n        // Incrementing the authVersion number effectively erases the authorizations mapping. See the comments\\n        // on the authorizations variable (above) for more information.\\n        authVersion += AUTH_VERSION_INCREMENTOR;\\n\\n        // Store the new signer/cosigner pair as the only remaining authorized address\\n        authorizations[authVersion + uint256(_authorizedAddress)] = _cosigner;\\n        emit EmergencyRecovery(_authorizedAddress, _cosigner);\\n    }\\n\\n    function emergencyRecovery2(address _authorizedAddress, uint256 _cosigner, address _recoveryAddress) external onlyRecoveryAddress {\\n            require(_authorizedAddress != address(0), \\\"Authorized addresses must not be zero.\\\");\\n            require(_authorizedAddress != _recoveryAddress, \\\"Do not use the recovery address as an authorized address.\\\");\\n            require(address(_cosigner) != address(0), \\\"The cosigner must not be zero.\\\");\\n\\n            // Incrementing the authVersion number effectively erases the authorizations mapping. See the comments\\n            // on the authorizations variable (above) for more information.\\n            authVersion += AUTH_VERSION_INCREMENTOR;\\n\\n            // Store the new signer/cosigner pair as the only remaining authorized address\\n            authorizations[authVersion + uint256(_authorizedAddress)] = _cosigner;\\n\\n            // set new recovery address\\n            address previous = recoveryAddress;\\n            recoveryAddress = _recoveryAddress;\\n\\n            emit RecoveryAddressChanged(previous, recoveryAddress);\\n            emit EmergencyRecovery(_authorizedAddress, _cosigner);\\n     }\\n\\n    /// @notice Sets the recovery address, which can be zero (indicating that no recovery is possible)\\n    ///  Can be updated by any authorized address. This address should be set with GREAT CARE. See the\\n    ///  comments above about the proper kinds of addresses to use as the recoveryAddress to ensure this\\n    ///  mechanism is not trivially abused.\\n    /// @dev Must be called through `invoke()`\\n    /// @param _recoveryAddress the new recovery address\\n    function setRecoveryAddress(address _recoveryAddress) external onlyInvoked {\\n        require(\\n            address(authorizations[authVersion + uint256(_recoveryAddress)]) == address(0),\\n            \\\"Do not use an authorized address as the recovery address.\\\"\\n        );\\n \\n        address previous = recoveryAddress;\\n        recoveryAddress = _recoveryAddress;\\n\\n        emit RecoveryAddressChanged(previous, recoveryAddress);\\n    }\\n\\n    /// @notice Allows ANY caller to recover gas by way of deleting old authorization keys after\\n    ///  a recovery operation. Anyone can call this method to delete the old unused storage and\\n    ///  get themselves a bit of gas refund in the bargin.\\n    /// @dev keys must be known to caller or else nothing is refunded\\n    /// @param _version the version of the mapping which you want to delete (unshifted)\\n    /// @param _keys the authorization keys to delete \\n    function recoverGas(uint256 _version, address[] calldata _keys) external {\\n        // TODO: should this be 0xffffffffffffffffffffffff ?\\n        require(_version > 0 && _version < 0xffffffff, \\\"Invalid version number.\\\");\\n        \\n        uint256 shiftedVersion = _version << 160;\\n\\n        require(shiftedVersion < authVersion, \\\"You can only recover gas from expired authVersions.\\\");\\n\\n        for (uint256 i = 0; i < _keys.length; ++i) {\\n            delete(authorizations[shiftedVersion + uint256(_keys[i])]);\\n        }\\n    }\\n\\n    /// @notice Should return whether the signature provided is valid for the provided data\\n    ///  See https://github.com/ethereum/EIPs/issues/1271\\n    /// @dev This function meets the following conditions as per the EIP:\\n    ///  MUST return the bytes4 magic value `0x1626ba7e` when function passes.\\n    ///  MUST NOT modify state (using `STATICCALL` for solc < 0.5, `view` modifier for solc > 0.5)\\n    ///  MUST allow external calls\\n    /// @param hash A 32 byte hash of the signed data.  The actual hash that is hashed however is the\\n    ///  the following tightly packed arguments: `0x19,0x0,wallet_address,hash`\\n    /// @param _signature Signature byte array associated with `_data`\\n    /// @return Magic value `0x1626ba7e` upon success, 0 otherwise.\\n    function isValidSignature(bytes32 hash, bytes calldata _signature) external view returns (bytes4) {\\n        \\n        // We 'hash the hash' for the following reasons:\\n        // 1. `hash` is not the hash of an Ethereum transaction\\n        // 2. signature must target this wallet to avoid replaying the signature for another wallet\\n        // with the same key\\n        // 3. Gnosis does something similar: \\n        // https://github.com/gnosis/safe-contracts/blob/102e632d051650b7c4b0a822123f449beaf95aed/contracts/GnosisSafe.sol\\n        bytes32 operationHash = keccak256(\\n            abi.encodePacked(\\n            EIP191_PREFIX,\\n            EIP191_VERSION_DATA,\\n            this,\\n            hash));\\n\\n        bytes32[2] memory r;\\n        bytes32[2] memory s;\\n        uint8[2] memory v;\\n        address signer;\\n        address cosigner;\\n\\n        // extract 1 or 2 signatures depending on length\\n        if (_signature.length == 65) {\\n            (r[0], s[0], v[0]) = _signature.extractSignature(0);\\n            signer = ecrecover(operationHash, v[0], r[0], s[0]);\\n            cosigner = signer;\\n        } else if (_signature.length == 130) {\\n            (r[0], s[0], v[0]) = _signature.extractSignature(0);\\n            (r[1], s[1], v[1]) = _signature.extractSignature(65);\\n            signer = ecrecover(operationHash, v[0], r[0], s[0]);\\n            cosigner = ecrecover(operationHash, v[1], r[1], s[1]);\\n        } else {\\n            return 0;\\n        }\\n            \\n        // check for valid signature\\n        if (signer == address(0)) {\\n            return 0;\\n        }\\n\\n        // check for valid signature\\n        if (cosigner == address(0)) {\\n            return 0;\\n        }\\n\\n        // check to see if this is an authorized key\\n        if (address(authorizations[authVersion + uint256(signer)]) != cosigner) {\\n            return 0;\\n        }\\n\\n        return ERC1271_VALIDSIGNATURE;\\n    }\\n\\n    /// @notice Query if this contract implements an interface. This function takes into account\\n    ///  interfaces we implement dynamically through delegates. For interfaces that are just a\\n    ///  single method, using `setDelegate` will result in that method's ID returning true from \\n    ///  `supportsInterface`. For composite interfaces that are composed of multiple functions, it is\\n    ///  necessary to add the interface ID manually with `setDelegate(interfaceID,\\n    ///  COMPOSITE_PLACEHOLDER)`\\n    ///  IN ADDITION to adding each function of the interface as usual.\\n    /// @param interfaceID The interface identifier, as specified in ERC-165\\n    /// @dev Interface identification is specified in ERC-165. This function\\n    ///  uses less than 30,000 gas.\\n    /// @return `true` if the contract implements `interfaceID` and\\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\\n    function supportsInterface(bytes4 interfaceID) external view returns (bool) {\\n        // First check if the ID matches one of the interfaces we support statically.\\n        if (\\n            interfaceID == this.supportsInterface.selector || // ERC165\\n            interfaceID == ERC721_RECEIVED_FINAL || // ERC721 Final\\n            interfaceID == ERC721_RECEIVED_DRAFT || // ERC721 Draft\\n            interfaceID == ERC223_ID || // ERC223\\n            interfaceID == ERC1155_TOKEN_RECIEVER || // ERC1155 Token Reciever\\n            interfaceID == ERC1271_VALIDSIGNATURE // ERC1271\\n        ) {\\n            return true;\\n        }\\n        // If we don't support the interface statically, check whether we have added\\n        // dynamic support for it.\\n        return uint256(delegates[interfaceID]) > 0;\\n    }\\n\\n    /// @notice A version of `invoke()` that has no explicit signatures, and uses msg.sender\\n    ///  as both the signer and cosigner. Will only succeed if `msg.sender` is an authorized\\n    ///  signer for this wallet, with no cosigner, saving transaction size and gas in that case.\\n    /// @param data The data containing the transactions to be invoked; see internalInvoke for details.\\n    function invoke0(bytes calldata data) external {\\n        // The nonce doesn't need to be incremented for transactions that don't include explicit signatures;\\n        // the built-in nonce of the native ethereum transaction will protect against replay attacks, and we\\n        // can save the gas that would be spent updating the nonce variable\\n\\n        // The operation should be approved if the signer address has no cosigner (i.e. signer == cosigner)\\n        require(address(authorizations[authVersion + uint256(msg.sender)]) == msg.sender, \\\"Invalid authorization.\\\");\\n\\n        internalInvoke(0, data);\\n    }\\n\\n    /// @notice A version of `invoke()` that has one explicit signature which is used to derive the authorized\\n    ///  address. Uses `msg.sender` as the cosigner.\\n    /// @param v the v value for the signature; see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-155.md\\n    /// @param r the r value for the signature\\n    /// @param s the s value for the signature\\n    /// @param nonce the nonce value for the signature\\n    /// @param authorizedAddress the address of the authorization key; this is used here so that cosigner signatures are interchangeable\\n    ///  between this function and `invoke2()`\\n    /// @param data The data containing the transactions to be invoked; see internalInvoke for details.\\n    function invoke1CosignerSends(uint8 v, bytes32 r, bytes32 s, uint256 nonce, address authorizedAddress, bytes calldata data) external {\\n        // check signature version\\n        require(v == 27 || v == 28, \\\"Invalid signature version.\\\");\\n\\n        // calculate hash\\n        bytes32 operationHash = keccak256(\\n            abi.encodePacked(\\n            EIP191_PREFIX,\\n            EIP191_VERSION_DATA,\\n            this,\\n            nonce,\\n            authorizedAddress,\\n            data));\\n \\n        // recover signer\\n        address signer = ecrecover(operationHash, v, r, s);\\n\\n        // check for valid signature\\n        require(signer != address(0), \\\"Invalid signature.\\\");\\n\\n        // check nonce\\n        require(nonce > nonces[signer], \\\"must use valid nonce for signer\\\");\\n\\n        // check signer\\n        require(signer == authorizedAddress, \\\"authorized addresses must be equal\\\");\\n\\n        // Get cosigner\\n        address requiredCosigner = address(authorizations[authVersion + uint256(signer)]);\\n        \\n        // The operation should be approved if the signer address has no cosigner (i.e. signer == cosigner) or\\n        // if the actual cosigner matches the required cosigner.\\n        require(requiredCosigner == signer || requiredCosigner == msg.sender, \\\"Invalid authorization.\\\");\\n\\n        // increment nonce to prevent replay attacks\\n        nonces[signer] = nonce;\\n\\n        // call internal function\\n        internalInvoke(operationHash, data);\\n    }\\n\\n    /// @notice A version of `invoke()` that has one explicit signature which is used to derive the cosigning\\n    ///  address. Uses `msg.sender` as the authorized address.\\n    /// @param v the v value for the signature; see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-155.md\\n    /// @param r the r value for the signature\\n    /// @param s the s value for the signature\\n    /// @param data The data containing the transactions to be invoked; see internalInvoke for details.\\n    function invoke1SignerSends(uint8 v, bytes32 r, bytes32 s, bytes calldata data) external {\\n        // check signature version\\n        // `ecrecover` will in fact return 0 if given invalid\\n        // so perhaps this check is redundant\\n        require(v == 27 || v == 28, \\\"Invalid signature version.\\\");\\n        \\n        uint256 nonce = nonces[msg.sender];\\n\\n        // calculate hash\\n        bytes32 operationHash = keccak256(\\n            abi.encodePacked(\\n            EIP191_PREFIX,\\n            EIP191_VERSION_DATA,\\n            this,\\n            nonce,\\n            msg.sender,\\n            data));\\n \\n        // recover cosigner\\n        address cosigner = ecrecover(operationHash, v, r, s);\\n        \\n        // check for valid signature\\n        require(cosigner != address(0), \\\"Invalid signature.\\\");\\n\\n        // Get required cosigner\\n        address requiredCosigner = address(authorizations[authVersion + uint256(msg.sender)]);\\n        \\n        // The operation should be approved if the signer address has no cosigner (i.e. signer == cosigner) or\\n        // if the actual cosigner matches the required cosigner.\\n        require(requiredCosigner == cosigner || requiredCosigner == msg.sender, \\\"Invalid authorization.\\\");\\n\\n        // increment nonce to prevent replay attacks\\n        nonces[msg.sender] = nonce + 1;\\n \\n        internalInvoke(operationHash, data);\\n    }\\n\\n    /// @notice A version of `invoke()` that has two explicit signatures, the first is used to derive the authorized\\n    ///  address, the second to derive the cosigner. The value of `msg.sender` is ignored.\\n    /// @param v the v values for the signatures\\n    /// @param r the r values for the signatures\\n    /// @param s the s values for the signatures\\n    /// @param nonce the nonce value for the signature\\n    /// @param authorizedAddress the address of the signer; forces the signature to be unique and tied to the signers nonce \\n    /// @param data The data containing the transactions to be invoked; see internalInvoke for details.\\n    function invoke2(uint8[2] calldata v, bytes32[2] calldata r, bytes32[2] calldata s, uint256 nonce, address authorizedAddress, bytes calldata data) external {\\n        // check signature versions\\n        // `ecrecover` will infact return 0 if given invalid\\n        // so perhaps these checks are redundant\\n        require(v[0] == 27 || v[0] == 28, \\\"invalid signature version v[0]\\\");\\n        require(v[1] == 27 || v[1] == 28, \\\"invalid signature version v[1]\\\");\\n \\n        bytes32 operationHash = keccak256(\\n            abi.encodePacked(\\n            EIP191_PREFIX,\\n            EIP191_VERSION_DATA,\\n            this,\\n            nonce,\\n            authorizedAddress,\\n            data));\\n \\n        // recover signer and cosigner\\n        address signer = ecrecover(operationHash, v[0], r[0], s[0]);\\n        address cosigner = ecrecover(operationHash, v[1], r[1], s[1]);\\n\\n        // check for valid signatures\\n        require(signer != address(0), \\\"Invalid signature for signer.\\\");\\n        require(cosigner != address(0), \\\"Invalid signature for cosigner.\\\");\\n\\n        // check signer address\\n        require(signer == authorizedAddress, \\\"authorized addresses must be equal\\\");\\n\\n        // check nonces\\n        require(nonce > nonces[signer], \\\"must use valid nonce for signer\\\");\\n\\n        // Get Mapping\\n        address requiredCosigner = address(authorizations[authVersion + uint256(signer)]);\\n        \\n        // The operation should be approved if the signer address has no cosigner (i.e. signer == cosigner) or\\n        // if the actual cosigner matches the required cosigner.\\n        require(requiredCosigner == signer || requiredCosigner == cosigner, \\\"Invalid authorization.\\\");\\n\\n        // increment nonce to prevent replay attacks\\n        nonces[signer] = nonce;\\n\\n        internalInvoke(operationHash, data);\\n    }\\n\\n    /// @dev Internal invoke call, \\n    /// @param operationHash The hash of the operation\\n    /// @param data The data to send to the `call()` operation\\n    ///  The data is prefixed with a global 1 byte revert flag\\n    ///  If revert is 1, then any revert from a `call()` operation is rethrown.\\n    ///  Otherwise, the error is recorded in the `result` field of the `InvocationSuccess` event.\\n    ///  Immediately following the revert byte (no padding), the data format is then is a series\\n    ///  of 1 or more tightly packed tuples:\\n    ///  `<target(20),amount(32),datalength(32),data>`\\n    ///  If `datalength == 0`, the data field must be omitted\\n    function internalInvoke(bytes32 operationHash, bytes memory data) internal {\\n        // keep track of the number of operations processed\\n        uint256 numOps;\\n        // keep track of the result of each operation as a bit\\n        uint256 result;\\n\\n        // We need to store a reference to this string as a variable so we can use it as an argument to\\n        // the revert call from assembly.\\n        string memory invalidLengthMessage = \\\"Data field too short\\\";\\n        string memory callFailed = \\\"Call failed\\\";\\n\\n        // At an absolute minimum, the data field must be at least 85 bytes\\n        // <revert(1), to_address(20), value(32), data_length(32)>\\n        require(data.length >= 85, invalidLengthMessage);\\n\\n        // Forward the call onto its actual target. Note that the target address can be `self` here, which is\\n        // actually the required flow for modifying the configuration of the authorized keys and recovery address.\\n        //\\n        // The assembly code below loads data directly from memory, so the enclosing function must be marked `internal`\\n        assembly {\\n            // A cursor pointing to the revert flag, starts after the length field of the data object\\n            let memPtr := add(data, 32)\\n\\n            // The revert flag is the leftmost byte from memPtr\\n            let revertFlag := byte(0, mload(memPtr))\\n\\n            // A pointer to the end of the data object\\n            let endPtr := add(memPtr, mload(data))\\n\\n            // Now, memPtr is a cursor pointing to the beginning of the current sub-operation\\n            memPtr := add(memPtr, 1)\\n\\n            // Loop through data, parsing out the various sub-operations\\n            for { } lt(memPtr, endPtr) { } {\\n                // Load the length of the call data of the current operation\\n                // 52 = to(20) + value(32)\\n                let len := mload(add(memPtr, 52))\\n                \\n                // Compute a pointer to the end of the current operation\\n                // 84 = to(20) + value(32) + size(32)\\n                let opEnd := add(len, add(memPtr, 84))\\n\\n                // Bail if the current operation's data overruns the end of the enclosing data buffer\\n                // NOTE: Comment out this bit of code and uncomment the next section if you want\\n                // the solidity-coverage tool to work.\\n                // See https://github.com/sc-forks/solidity-coverage/issues/287\\n                if gt(opEnd, endPtr) {\\n                    // The computed end of this operation goes past the end of the data buffer. Not good!\\n                    revert(add(invalidLengthMessage, 32), mload(invalidLengthMessage))\\n                }\\n                // NOTE: Code that is compatible with solidity-coverage\\n                // switch gt(opEnd, endPtr)\\n                // case 1 {\\n                //     revert(add(invalidLengthMessage, 32), mload(invalidLengthMessage))\\n                // }\\n\\n                // This line of code packs in a lot of functionality!\\n                //  - load the target address from memPtr, the address is only 20-bytes but mload always grabs 32-bytes,\\n                //    so we have to shr by 12 bytes.\\n                //  - load the value field, stored at memPtr+20\\n                //  - pass a pointer to the call data, stored at memPtr+84\\n                //  - use the previously loaded len field as the size of the call data\\n                //  - make the call (passing all remaining gas to the child call)\\n                //  - check the result (0 == reverted)\\n                if eq(0, call(gas, shr(96, mload(memPtr)), mload(add(memPtr, 20)), add(memPtr, 84), len, 0, 0)) {\\n                    switch revertFlag\\n                    case 1 {\\n                        revert(add(callFailed, 32), mload(callFailed))\\n                    }\\n                    default {\\n                        // mark this operation as failed\\n                        // create the appropriate bit, 'or' with previous\\n                        result := or(result, exp(2, numOps))\\n                    }\\n                }\\n\\n                // increment our counter\\n                numOps := add(numOps, 1)\\n             \\n                // Update mem pointer to point to the next sub-operation\\n                memPtr := opEnd\\n            }\\n        }\\n\\n        // emit single event upon success\\n        emit InvocationSuccess(operationHash, result, numOps);\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/ERC721/ERC721ReceiverFinal.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.10;\\n\\n\\n/// @title ERC721ReceiverFinal\\n/// @notice Interface for any contract that wants to support safeTransfers from\\n///  ERC721 asset contracts.\\n///  @dev Note: this is the final interface as defined at http://erc721.org\\ncontract ERC721ReceiverFinal {\\n\\n    /// @dev Magic value to be returned upon successful reception of an NFT\\n    ///  Equals to `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`,\\n    ///  which can be also obtained as `ERC721ReceiverFinal(0).onERC721Received.selector`\\n    /// @dev see https://github.com/OpenZeppelin/openzeppelin-solidity/blob/v1.12.0/contracts/token/ERC721/ERC721Receiver.sol\\n    bytes4 internal constant ERC721_RECEIVED_FINAL = 0x150b7a02;\\n\\n    /// @notice Handle the receipt of an NFT\\n    /// @dev The ERC721 smart contract calls this function on the recipient\\n    /// after a `safetransfer`. This function MAY throw to revert and reject the\\n    /// transfer. Return of other than the magic value MUST result in the\\n    /// transaction being reverted.\\n    /// Note: the contract address is always the message sender.\\n    /// @param _operator The address which called `safeTransferFrom` function\\n    /// @param _from The address which previously owned the token\\n    /// @param _tokenId The NFT identifier which is being transferred\\n    /// @param _data Additional data with no specified format\\n    /// @return `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`\\n    function onERC721Received(\\n        address _operator,\\n        address _from,\\n        uint256 _tokenId,\\n        bytes memory _data\\n    )\\n    public\\n        returns (bytes4);\\n}\"\r\n    },\r\n    \"/contracts/ERC721/ERC721ReceiverDraft.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.10;\\n\\n\\n/// @title ERC721ReceiverDraft\\n/// @dev Interface for any contract that wants to support safeTransfers from\\n///  ERC721 asset contracts.\\n/// @dev Note: this is the interface defined from \\n///  https://github.com/ethereum/EIPs/commit/2bddd126def7c046e1e62408dc2b51bdd9e57f0f\\n///  to https://github.com/ethereum/EIPs/commit/27788131d5975daacbab607076f2ee04624f9dbb \\n///  and is not the final interface.\\n///  Due to the extended period of time this revision was specified in the draft,\\n///  we are supporting both this and the newer (final) interface in order to be \\n///  compatible with any ERC721 implementations that may have used this interface.\\ncontract ERC721ReceiverDraft {\\n\\n    /// @dev Magic value to be returned upon successful reception of an NFT\\n    ///  Equals to `bytes4(keccak256(\\\"onERC721Received(address,uint256,bytes)\\\"))`,\\n    ///  which can be also obtained as `ERC721ReceiverDraft(0).onERC721Received.selector`\\n    /// @dev see https://github.com/ethereum/EIPs/commit/2bddd126def7c046e1e62408dc2b51bdd9e57f0f\\n    bytes4 internal constant ERC721_RECEIVED_DRAFT = 0xf0b9e5ba;\\n\\n    /// @notice Handle the receipt of an NFT\\n    /// @dev The ERC721 smart contract calls this function on the recipient\\n    ///  after a `transfer`. This function MAY throw to revert and reject the\\n    ///  transfer. This function MUST use 50,000 gas or less. Return of other\\n    ///  than the magic value MUST result in the transaction being reverted.\\n    ///  Note: the contract address is always the message sender.\\n    /// @param _from The sending address \\n    /// @param _tokenId The NFT identifier which is being transfered\\n    /// @param data Additional data with no specified format\\n    /// @return `bytes4(keccak256(\\\"onERC721Received(address,uint256,bytes)\\\"))`\\n    ///  unless throwing\\n    function onERC721Received(address _from, uint256 _tokenId, bytes calldata data) external returns(bytes4);\\n}\"\r\n    },\r\n    \"/contracts/ERC721/ERC721Receivable.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.10;\\n\\nimport \\\"./ERC721ReceiverDraft.sol\\\";\\nimport \\\"./ERC721ReceiverFinal.sol\\\";\\n\\n/// @title ERC721Receivable handles the reception of ERC721 tokens\\n///  See ERC721 specification\\n/// @author Christopher Scott\\n/// @dev These functions are public, and could be called by anyone, even in the case\\n///  where no NFTs have been transferred. Since it's not a reliable source of\\n///  truth about ERC721 tokens being transferred, we save the gas and don't\\n///  bother emitting a (potentially spurious) event as found in \\n///  https://github.com/OpenZeppelin/openzeppelin-solidity/blob/5471fc808a17342d738853d7bf3e9e5ef3108074/contracts/mocks/ERC721ReceiverMock.sol\\ncontract ERC721Receivable is ERC721ReceiverDraft, ERC721ReceiverFinal {\\n\\n    /// @notice Handle the receipt of an NFT\\n    /// @dev The ERC721 smart contract calls this function on the recipient\\n    ///  after a `transfer`. This function MAY throw to revert and reject the\\n    ///  transfer. This function MUST use 50,000 gas or less. Return of other\\n    ///  than the magic value MUST result in the transaction being reverted.\\n    ///  Note: the contract address is always the message sender.\\n    /// @param _from The sending address \\n    /// @param _tokenId The NFT identifier which is being transfered\\n    /// @param data Additional data with no specified format\\n    /// @return `bytes4(keccak256(\\\"onERC721Received(address,uint256,bytes)\\\"))`\\n    ///  unless throwing\\n    function onERC721Received(address _from, uint256 _tokenId, bytes calldata data) external returns(bytes4) {\\n        _from;\\n        _tokenId;\\n        data;\\n\\n        // emit ERC721Received(_operator, _from, _tokenId, _data, gasleft());\\n\\n        return ERC721_RECEIVED_DRAFT;\\n    }\\n\\n    /// @notice Handle the receipt of an NFT\\n    /// @dev The ERC721 smart contract calls this function on the recipient\\n    /// after a `safetransfer`. This function MAY throw to revert and reject the\\n    /// transfer. Return of other than the magic value MUST result in the\\n    /// transaction being reverted.\\n    /// Note: the contract address is always the message sender.\\n    /// @param _operator The address which called `safeTransferFrom` function\\n    /// @param _from The address which previously owned the token\\n    /// @param _tokenId The NFT identifier which is being transferred\\n    /// @param _data Additional data with no specified format\\n    /// @return `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`\\n    function onERC721Received(\\n        address _operator,\\n        address _from,\\n        uint256 _tokenId,\\n        bytes memory _data\\n    )\\n        public\\n        returns(bytes4)\\n    {\\n        _operator;\\n        _from;\\n        _tokenId;\\n        _data;\\n\\n        // emit ERC721Received(_operator, _from, _tokenId, _data, gasleft());\\n\\n        return ERC721_RECEIVED_FINAL;\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"/contracts/ERC223/ERC223Receiver.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.10;\\n\\n\\n/// @title ERC223Receiver ensures we are ERC223 compatible\\n/// @author Christopher Scott\\ncontract ERC223Receiver {\\n    \\n    bytes4 public constant ERC223_ID = 0xc0ee0b8a;\\n\\n    struct TKN {\\n        address sender;\\n        uint value;\\n        bytes data;\\n        bytes4 sig;\\n    }\\n    \\n    /// @notice tokenFallback is called from an ERC223 compatible contract\\n    /// @param _from the address from which the token was sent\\n    /// @param _value the amount of tokens sent\\n    /// @param _data the data sent with the transaction\\n    function tokenFallback(address _from, uint _value, bytes memory _data) public pure {\\n        _from;\\n        _value;\\n        _data;\\n    //   TKN memory tkn;\\n    //   tkn.sender = _from;\\n    //   tkn.value = _value;\\n    //   tkn.data = _data;\\n    //   uint32 u = uint32(_data[3]) + (uint32(_data[2]) << 8) + (uint32(_data[1]) << 16) + (uint32(_data[0]) << 24);\\n    //   tkn.sig = bytes4(u);\\n      \\n      /* tkn variable is analogue of msg variable of Ether transaction\\n      *  tkn.sender is person who initiated this token transaction   (analogue of msg.sender)\\n      *  tkn.value the number of tokens that were sent   (analogue of msg.value)\\n      *  tkn.data is data of token transaction   (analogue of msg.data)\\n      *  tkn.sig is 4 bytes signature of function\\n      *  if data of token transaction is a function execution\\n      */\\n\\n    }\\n}\"\r\n    },\r\n    \"/contracts/ERC1271/ERC1271.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.10;\\n\\ncontract ERC1271 {\\n\\n    /// @dev bytes4(keccak256(\\\"isValidSignature(bytes32,bytes)\\\")\\n    bytes4 internal constant ERC1271_VALIDSIGNATURE = 0x1626ba7e;\\n\\n    /// @dev Should return whether the signature provided is valid for the provided data\\n    /// @param hash 32-byte hash of the data that is signed\\n    /// @param _signature Signature byte array associated with _data\\n    ///  MUST return the bytes4 magic value 0x1626ba7e when function passes.\\n    ///  MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for solc > 0.5)\\n    ///  MUST allow external calls\\n    function isValidSignature(\\n        bytes32 hash, \\n        bytes calldata _signature)\\n        external\\n        view \\n        returns (bytes4);\\n}\"\r\n    },\r\n    \"/contracts/ERC1155/ERC1155TokenReceiver.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.10;\\n\\ncontract ERC1155TokenReceiver {\\n    /// @dev `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\")) ^\\n    /// bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\n    bytes4 internal constant ERC1155_TOKEN_RECIEVER = 0x4e2312e0;\\n\\n    /**\\n        @notice Handle the receipt of a single ERC1155 token type.\\n        @dev An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeTransferFrom` after the balance has been updated.        \\n        This function MUST return `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))` (i.e. 0xf23a6e61) if it accepts the transfer.\\n        This function MUST revert if it rejects the transfer.\\n        Return of any other value than the prescribed keccak256 generated value MUST result in the transaction being reverted by the caller.\\n        @param _operator  The address which initiated the transfer (i.e. msg.sender)\\n        @param _from      The address which previously owned the token\\n        @param _id        The ID of the token being transferred\\n        @param _value     The amount of tokens being transferred\\n        @param _data      Additional data with no specified format\\n        @return           `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\n    */\\n    function onERC1155Received(\\n        address _operator,\\n        address _from,\\n        uint256 _id,\\n        uint256 _value,\\n        bytes calldata _data\\n    ) external pure returns (bytes4) {\\n        _operator;\\n        _from;\\n        _id;\\n        _value;\\n        _data;\\n\\n        return 0xf23a6e61;\\n    }\\n\\n    /**\\n        @notice Handle the receipt of multiple ERC1155 token types.\\n        @dev An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeBatchTransferFrom` after the balances have been updated.        \\n        This function MUST return `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))` (i.e. 0xbc197c81) if it accepts the transfer(s).\\n        This function MUST revert if it rejects the transfer(s).\\n        Return of any other value than the prescribed keccak256 generated value MUST result in the transaction being reverted by the caller.\\n        @param _operator  The address which initiated the batch transfer (i.e. msg.sender)\\n        @param _from      The address which previously owned the token\\n        @param _ids       An array containing ids of each token being transferred (order and length must match _values array)\\n        @param _values    An array containing amounts of each token being transferred (order and length must match _ids array)\\n        @param _data      Additional data with no specified format\\n        @return           `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\n    */\\n    function onERC1155BatchReceived(\\n        address _operator,\\n        address _from,\\n        uint256[] calldata _ids,\\n        uint256[] calldata _values,\\n        bytes calldata _data\\n    ) external pure returns (bytes4) {\\n        _operator;\\n        _from;\\n        _ids;\\n        _values;\\n        _data;\\n\\n        return 0xbc197c81;\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/ECDSA.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.10;\\n\\n\\n/// @title ECDSA is a library that contains useful methods for working with ECDSA signatures\\nlibrary ECDSA {\\n\\n    /// @notice Extracts the r, s, and v components from the `sigData` field starting from the `offset`\\n    /// @dev Note: does not do any bounds checking on the arguments!\\n    /// @param sigData the signature data; could be 1 or more packed signatures.\\n    /// @param offset the offset in sigData from which to start unpacking the signature components.\\n    function extractSignature(bytes memory sigData, uint256 offset) internal pure returns  (bytes32 r, bytes32 s, uint8 v) {\\n        // Divide the signature in r, s and v variables\\n        // ecrecover takes the signature parameters, and the only way to get them\\n        // currently is to use assembly.\\n        // solium-disable-next-line security/no-inline-assembly\\n        assembly {\\n             let dataPointer := add(sigData, offset)\\n             r := mload(add(dataPointer, 0x20))\\n             s := mload(add(dataPointer, 0x40))\\n             v := byte(0, mload(add(dataPointer, 0x60)))\\n        }\\n    \\n        return (r, s, v);\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"evmVersion\": \"petersburg\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"constant\":true,\"inputs\":[{\"name\":\"interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ERC223_ID\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"},{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_authorizedAddresses\",\"type\":\"bytes\"},{\"name\":\"_cosigner\",\"type\":\"uint256\"},{\"name\":\"_recoveryAddress\",\"type\":\"address\"}],\"name\":\"init2\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initialized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"hash\",\"type\":\"bytes32\"},{\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"isValidSignature\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"EIP191_VERSION_DATA\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes1\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"authorizations\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"v\",\"type\":\"uint8[2]\"},{\"name\":\"r\",\"type\":\"bytes32[2]\"},{\"name\":\"s\",\"type\":\"bytes32[2]\"},{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"authorizedAddress\",\"type\":\"address\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"invoke2\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_authorizedAddress\",\"type\":\"address\"},{\"name\":\"_cosigner\",\"type\":\"uint256\"},{\"name\":\"_recoveryAddress\",\"type\":\"address\"}],\"name\":\"init\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_recoveryAddress\",\"type\":\"address\"}],\"name\":\"setRecoveryAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"invoke1SignerSends\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"recoveryAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_authorizedAddress\",\"type\":\"address\"},{\"name\":\"_cosigner\",\"type\":\"uint256\"}],\"name\":\"emergencyRecovery\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"AUTH_VERSION_INCREMENTOR\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_interfaceId\",\"type\":\"bytes4\"},{\"name\":\"_delegate\",\"type\":\"address\"}],\"name\":\"setDelegate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"authVersion\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_authorizedAddress\",\"type\":\"address\"},{\"name\":\"_cosigner\",\"type\":\"uint256\"},{\"name\":\"_recoveryAddress\",\"type\":\"address\"}],\"name\":\"emergencyRecovery2\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"COMPOSITE_PLACEHOLDER\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"},{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"authorizedAddress\",\"type\":\"address\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"invoke1CosignerSends\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes4\"}],\"name\":\"delegates\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"invoke0\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"},{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_ids\",\"type\":\"uint256[]\"},{\"name\":\"_values\",\"type\":\"uint256[]\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"onERC1155BatchReceived\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_authorizedAddress\",\"type\":\"address\"},{\"name\":\"_cosigner\",\"type\":\"uint256\"}],\"name\":\"setAuthorized\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"tokenFallback\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"EIP191_PREFIX\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes1\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_version\",\"type\":\"uint256\"},{\"name\":\"_keys\",\"type\":\"address[]\"}],\"name\":\"recoverGas\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"},{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_id\",\"type\":\"uint256\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"onERC1155Received\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"VERSION\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"authorizedAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"cosigner\",\"type\":\"uint256\"}],\"name\":\"Authorized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"authorizedAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"cosigner\",\"type\":\"uint256\"}],\"name\":\"EmergencyRecovery\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"previousRecoveryAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newRecoveryAddress\",\"type\":\"address\"}],\"name\":\"RecoveryAddressChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Received\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"hash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"result\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"numOperations\",\"type\":\"uint256\"}],\"name\":\"InvocationSuccess\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"interfaceId\",\"type\":\"bytes4\"},{\"indexed\":false,\"name\":\"delegate\",\"type\":\"address\"}],\"name\":\"DelegateUpdated\",\"type\":\"event\"}]", "ContractName": "CloneableWallet", "CompilerVersion": "v0.5.10+commit.5a6ea5b1", "OptimizationUsed": "1", "Runs": "1000", "ConstructorArguments": "", "EVMVersion": "petersburg", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}