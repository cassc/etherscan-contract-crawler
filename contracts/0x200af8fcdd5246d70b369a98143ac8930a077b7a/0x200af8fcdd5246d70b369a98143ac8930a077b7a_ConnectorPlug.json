{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/interfaces/IPlug.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity 0.8.13;\\n\\n/**\\n * @title IPlug\\n * @notice Interface for a plug contract that executes the message received from a source chain.\\n */\\ninterface IPlug {\\n    /**\\n     * @dev this should be only executable by socket\\n     * @notice executes the message received from source chain\\n     * @notice It is expected to have original sender checks in the destination plugs using payload\\n     * @param srcChainSlug_ chain slug of source\\n     * @param payload_ the data which is needed by plug at inbound call on remote\\n     */\\n    function inbound(\\n        uint32 srcChainSlug_,\\n        bytes calldata payload_\\n    ) external payable;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ISocket.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity 0.8.13;\\n\\n/**\\n * @title ISocket\\n * @notice An interface for a cross-chain communication contract\\n * @dev This interface provides methods for transmitting and executing messages between chains,\\n * connecting a plug to a remote chain and setting up switchboards for the message transmission\\n * This interface also emits events for important operations such as message transmission, execution status,\\n * and plug connection\\n */\\ninterface ISocket {\\n    /**\\n     * @notice A struct containing fees required for message transmission and execution\\n     * @param transmissionFees fees needed for transmission\\n     * @param switchboardFees fees needed by switchboard\\n     * @param executionFee fees needed for execution\\n     */\\n    struct Fees {\\n        uint128 transmissionFees;\\n        uint128 executionFee;\\n        uint128 switchboardFees;\\n    }\\n\\n    /**\\n     * @title MessageDetails\\n     * @dev This struct defines the details of a message to be executed in a Decapacitor contract.\\n     */\\n    struct MessageDetails {\\n        // A unique identifier for the message.\\n        bytes32 msgId;\\n        // The fee to be paid for executing the message.\\n        uint256 executionFee;\\n        // The maximum amount of gas that can be used to execute the message.\\n        uint256 minMsgGasLimit;\\n        // The extra params which provides msg value and additional info needed for message exec\\n        bytes32 executionParams;\\n        // The payload data to be executed in the message.\\n        bytes payload;\\n    }\\n\\n    /**\\n     * @title ExecutionDetails\\n     * @dev This struct defines the execution details\\n     */\\n    struct ExecutionDetails {\\n        // packet id\\n        bytes32 packetId;\\n        // proposal count\\n        uint256 proposalCount;\\n        // gas limit needed to execute inbound\\n        uint256 executionGasLimit;\\n        // proof data required by the Decapacitor contract to verify the message's authenticity\\n        bytes decapacitorProof;\\n        // signature of executor\\n        bytes signature;\\n    }\\n\\n    /**\\n     * @notice emits the message details when a new message arrives at outbound\\n     * @param localChainSlug local chain slug\\n     * @param localPlug local plug address\\n     * @param dstChainSlug remote chain slug\\n     * @param dstPlug remote plug address\\n     * @param msgId message id packed with remoteChainSlug and nonce\\n     * @param minMsgGasLimit gas limit needed to execute the inbound at remote\\n     * @param payload the data which will be used by inbound at remote\\n     */\\n    event MessageOutbound(\\n        uint32 localChainSlug,\\n        address localPlug,\\n        uint32 dstChainSlug,\\n        address dstPlug,\\n        bytes32 msgId,\\n        uint256 minMsgGasLimit,\\n        bytes32 executionParams,\\n        bytes32 transmissionParams,\\n        bytes payload,\\n        Fees fees\\n    );\\n\\n    /**\\n     * @notice emits the status of message after inbound call\\n     * @param msgId msg id which is executed\\n     */\\n    event ExecutionSuccess(bytes32 msgId);\\n\\n    /**\\n     * @notice emits the config set by a plug for a remoteChainSlug\\n     * @param plug address of plug on current chain\\n     * @param siblingChainSlug sibling chain slug\\n     * @param siblingPlug address of plug on sibling chain\\n     * @param inboundSwitchboard inbound switchboard (select from registered options)\\n     * @param outboundSwitchboard outbound switchboard (select from registered options)\\n     * @param capacitor capacitor selected based on outbound switchboard\\n     * @param decapacitor decapacitor selected based on inbound switchboard\\n     */\\n    event PlugConnected(\\n        address plug,\\n        uint32 siblingChainSlug,\\n        address siblingPlug,\\n        address inboundSwitchboard,\\n        address outboundSwitchboard,\\n        address capacitor,\\n        address decapacitor\\n    );\\n\\n    /**\\n     * @notice registers a message\\n     * @dev Packs the message and includes it in a packet with capacitor\\n     * @param remoteChainSlug_ the remote chain slug\\n     * @param minMsgGasLimit_ the gas limit needed to execute the payload on remote\\n     * @param payload_ the data which is needed by plug at inbound call on remote\\n     */\\n    function outbound(\\n        uint32 remoteChainSlug_,\\n        uint256 minMsgGasLimit_,\\n        bytes32 executionParams_,\\n        bytes32 transmissionParams_,\\n        bytes calldata payload_\\n    ) external payable returns (bytes32 msgId);\\n\\n    /**\\n     * @notice executes a message\\n     * @param executionDetails_ the packet details, proof and signature needed for message execution\\n     * @param messageDetails_ the message details\\n     */\\n    function execute(\\n        ISocket.ExecutionDetails calldata executionDetails_,\\n        ISocket.MessageDetails calldata messageDetails_\\n    ) external payable;\\n\\n    /**\\n     * @notice sets the config specific to the plug\\n     * @param siblingChainSlug_ the sibling chain slug\\n     * @param siblingPlug_ address of plug present at sibling chain to call inbound\\n     * @param inboundSwitchboard_ the address of switchboard to use for receiving messages\\n     * @param outboundSwitchboard_ the address of switchboard to use for sending messages\\n     */\\n    function connect(\\n        uint32 siblingChainSlug_,\\n        address siblingPlug_,\\n        address inboundSwitchboard_,\\n        address outboundSwitchboard_\\n    ) external;\\n\\n    /**\\n     * @notice Retrieves the minimum fees required for a message with a specified gas limit and destination chain.\\n     * @param minMsgGasLimit_ The gas limit of the message.\\n     * @param remoteChainSlug_ The slug of the destination chain for the message.\\n     * @param plug_ The address of the plug through which the message is sent.\\n     * @return totalFees The minimum fees required for the specified message.\\n     */\\n    function getMinFees(\\n        uint256 minMsgGasLimit_,\\n        uint256 payloadSize_,\\n        bytes32 executionParams_,\\n        bytes32 transmissionParams_,\\n        uint32 remoteChainSlug_,\\n        address plug_\\n    ) external view returns (uint256 totalFees);\\n\\n    /**\\n     * @notice returns chain slug\\n     * @return chainSlug current chain slug\\n     */\\n    function chainSlug() external view returns (uint32 chainSlug);\\n\\n    /**\\n     * @notice returns the config for given `plugAddress_` and `siblingChainSlug_`\\n     * @param siblingChainSlug_ the sibling chain slug\\n     * @param plugAddress_ address of plug present at current chain\\n     */\\n    function getPlugConfig(\\n        address plugAddress_,\\n        uint32 siblingChainSlug_\\n    )\\n        external\\n        view\\n        returns (\\n            address siblingPlug,\\n            address inboundSwitchboard__,\\n            address outboundSwitchboard__,\\n            address capacitor__,\\n            address decapacitor__\\n        );\\n}\\n\"\r\n    },\r\n    \"contracts/superbridge/ConnectorPlug.sol\": {\r\n      \"content\": \"pragma solidity 0.8.13;\\n\\nimport \\\"lib/openzeppelin-contracts/contracts/access/Ownable2Step.sol\\\";\\nimport {ISocket} from \\\"../interfaces/ISocket.sol\\\";\\nimport {IPlug} from \\\"../interfaces/IPlug.sol\\\";\\nimport {RescueFundsLib} from \\\"./RescueFundsLib.sol\\\";\\n\\ninterface IHub {\\n    function receiveInbound(bytes memory payload_) external;\\n}\\n\\ninterface IConnector {\\n    function outbound(\\n        uint256 msgGasLimit_,\\n        bytes memory payload_\\n    ) external payable;\\n\\n    function siblingChainSlug() external view returns (uint32);\\n\\n    function getMinFees(\\n        uint256 msgGasLimit_\\n    ) external view returns (uint256 totalFees);\\n}\\n\\ncontract ConnectorPlug is IConnector, IPlug, Ownable2Step {\\n    IHub public immutable hub__;\\n    ISocket public immutable socket__;\\n    uint32 public immutable siblingChainSlug;\\n\\n    error NotHub();\\n    error NotSocket();\\n\\n    event ConnectorPlugDisconnected();\\n\\n    constructor(address hub_, address socket_, uint32 siblingChainSlug_) {\\n        hub__ = IHub(hub_);\\n        socket__ = ISocket(socket_);\\n        siblingChainSlug = siblingChainSlug_;\\n    }\\n\\n    function outbound(\\n        uint256 msgGasLimit_,\\n        bytes memory payload_\\n    ) external payable override {\\n        if (msg.sender != address(hub__)) revert NotHub();\\n\\n        socket__.outbound{value: msg.value}(\\n            siblingChainSlug,\\n            msgGasLimit_,\\n            bytes32(0),\\n            bytes32(0),\\n            payload_\\n        );\\n    }\\n\\n    function inbound(\\n        uint32 /* siblingChainSlug_ */, // cannot be connected for any other slug, immutable variable\\n        bytes calldata payload_\\n    ) external payable override {\\n        if (msg.sender != address(socket__)) revert NotSocket();\\n        hub__.receiveInbound(payload_);\\n    }\\n\\n    function getMinFees(\\n        uint256 msgGasLimit_\\n    ) external view override returns (uint256 totalFees) {\\n        return\\n            socket__.getMinFees(\\n                msgGasLimit_,\\n                64,\\n                bytes32(0),\\n                bytes32(0),\\n                siblingChainSlug,\\n                address(this)\\n            );\\n    }\\n\\n    function connect(\\n        address siblingPlug_,\\n        address switchboard_\\n    ) external onlyOwner {\\n        socket__.connect(\\n            siblingChainSlug,\\n            siblingPlug_,\\n            switchboard_,\\n            switchboard_\\n        );\\n    }\\n\\n    function disconnect() external onlyOwner {\\n        (\\n            ,\\n            address inboundSwitchboard,\\n            address outboundSwitchboard,\\n            ,\\n\\n        ) = socket__.getPlugConfig(address(this), siblingChainSlug);\\n\\n        socket__.connect(\\n            siblingChainSlug,\\n            address(0),\\n            inboundSwitchboard,\\n            outboundSwitchboard\\n        );\\n\\n        emit ConnectorPlugDisconnected();\\n    }\\n\\n    /**\\n     * @notice Rescues funds from the contract if they are locked by mistake.\\n     * @param token_ The address of the token contract.\\n     * @param rescueTo_ The address where rescued tokens need to be sent.\\n     * @param amount_ The amount of tokens to be rescued.\\n     */\\n    function rescueFunds(\\n        address token_,\\n        address rescueTo_,\\n        uint256 amount_\\n    ) external onlyOwner {\\n        RescueFundsLib.rescueFunds(token_, rescueTo_, amount_);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/superbridge/Controller.sol\": {\r\n      \"content\": \"pragma solidity 0.8.13;\\n\\nimport \\\"lib/solmate/src/utils/SafeTransferLib.sol\\\";\\nimport \\\"lib/openzeppelin-contracts/contracts/access/Ownable2Step.sol\\\";\\nimport {IExchangeRate} from \\\"./ExchangeRate.sol\\\";\\nimport {Gauge} from \\\"./Gauge.sol\\\";\\nimport {IConnector, IHub} from \\\"./ConnectorPlug.sol\\\";\\nimport {IMintableERC20} from \\\"./MintableToken.sol\\\";\\nimport {RescueFundsLib} from \\\"./RescueFundsLib.sol\\\";\\n\\ncontract Controller is IHub, Gauge, Ownable2Step {\\n    using SafeTransferLib for IMintableERC20;\\n    IMintableERC20 public immutable token__;\\n    IExchangeRate public exchangeRate__;\\n\\n    struct UpdateLimitParams {\\n        bool isMint;\\n        address connector;\\n        uint256 maxLimit;\\n        uint256 ratePerSecond;\\n    }\\n\\n    // connectorPoolId => totalLockedAmount\\n    mapping(uint256 => uint256) public poolLockedAmounts;\\n\\n    // connector => connectorPoolId\\n    mapping(address => uint256) public connectorPoolIds;\\n\\n    // connector => mintLimitParams\\n    mapping(address => LimitParams) _mintLimitParams;\\n\\n    // connector => burnLimitParams\\n    mapping(address => LimitParams) _burnLimitParams;\\n\\n    // connector => receiver => amount\\n    mapping(address => mapping(address => uint256)) public pendingMints;\\n\\n    // connector => amount\\n    mapping(address => uint256) public connectorPendingMints;\\n\\n    uint256 public totalMinted;\\n\\n    error ConnectorUnavailable();\\n    error InvalidPoolId();\\n    error ZeroAmount();\\n    event ExchangeRateUpdated(address exchangeRate);\\n    event ConnectorPoolIdUpdated(address connector, uint256 poolId);\\n    event LimitParamsUpdated(UpdateLimitParams[] updates);\\n    event TokensWithdrawn(\\n        address connector,\\n        address withdrawer,\\n        address receiver,\\n        uint256 burnAmount\\n    );\\n    event PendingTokensMinted(\\n        address connector,\\n        address receiver,\\n        uint256 mintAmount,\\n        uint256 pendingAmount\\n    );\\n    event TokensPending(\\n        address connecter,\\n        address receiver,\\n        uint256 pendingAmount,\\n        uint256 totalPendingAmount\\n    );\\n    event TokensMinted(address connecter, address receiver, uint256 mintAmount);\\n\\n    constructor(address token_, address exchangeRate_) {\\n        token__ = IMintableERC20(token_);\\n        exchangeRate__ = IExchangeRate(exchangeRate_);\\n    }\\n\\n    function updateExchangeRate(address exchangeRate_) external onlyOwner {\\n        exchangeRate__ = IExchangeRate(exchangeRate_);\\n        emit ExchangeRateUpdated(exchangeRate_);\\n    }\\n\\n    function updateConnectorPoolId(\\n        address[] calldata connectors,\\n        uint256[] calldata poolIds\\n    ) external onlyOwner {\\n        uint256 length = connectors.length;\\n        for (uint256 i; i < length; i++) {\\n            if (poolIds[i] == 0) revert InvalidPoolId();\\n            connectorPoolIds[connectors[i]] = poolIds[i];\\n            emit ConnectorPoolIdUpdated(connectors[i], poolIds[i]);\\n        }\\n    }\\n\\n    function updateLimitParams(\\n        UpdateLimitParams[] calldata updates_\\n    ) external onlyOwner {\\n        for (uint256 i; i < updates_.length; i++) {\\n            if (updates_[i].isMint) {\\n                _consumePartLimit(0, _mintLimitParams[updates_[i].connector]); // to keep current limit in sync\\n                _mintLimitParams[updates_[i].connector].maxLimit = updates_[i]\\n                    .maxLimit;\\n                _mintLimitParams[updates_[i].connector]\\n                    .ratePerSecond = updates_[i].ratePerSecond;\\n            } else {\\n                _consumePartLimit(0, _burnLimitParams[updates_[i].connector]); // to keep current limit in sync\\n                _burnLimitParams[updates_[i].connector].maxLimit = updates_[i]\\n                    .maxLimit;\\n                _burnLimitParams[updates_[i].connector]\\n                    .ratePerSecond = updates_[i].ratePerSecond;\\n            }\\n        }\\n\\n        emit LimitParamsUpdated(updates_);\\n    }\\n\\n    // do we throttle burn amount or unlock amount? burn for now\\n    function withdrawFromAppChain(\\n        address receiver_,\\n        uint256 burnAmount_,\\n        uint256 msgGasLimit_,\\n        address connector_\\n    ) external payable {\\n        if (burnAmount_ == 0) revert ZeroAmount();\\n\\n        if (_burnLimitParams[connector_].maxLimit == 0)\\n            revert ConnectorUnavailable();\\n\\n        _consumeFullLimit(burnAmount_, _burnLimitParams[connector_]); // reverts on limit hit\\n\\n        totalMinted -= burnAmount_;\\n        token__.burn(msg.sender, burnAmount_);\\n\\n        uint256 connectorPoolId = connectorPoolIds[connector_];\\n        if (connectorPoolId == 0) revert InvalidPoolId();\\n        uint256 unlockAmount = exchangeRate__.getUnlockAmount(\\n            burnAmount_,\\n            poolLockedAmounts[connectorPoolId]\\n        );\\n        poolLockedAmounts[connectorPoolId] -= unlockAmount; // underflow revert expected\\n\\n        IConnector(connector_).outbound{value: msg.value}(\\n            msgGasLimit_,\\n            abi.encode(receiver_, unlockAmount)\\n        );\\n\\n        emit TokensWithdrawn(connector_, msg.sender, receiver_, burnAmount_);\\n    }\\n\\n    function mintPendingFor(address receiver_, address connector_) external {\\n        if (_mintLimitParams[connector_].maxLimit == 0)\\n            revert ConnectorUnavailable();\\n\\n        uint256 pendingMint = pendingMints[connector_][receiver_];\\n        (uint256 consumedAmount, uint256 pendingAmount) = _consumePartLimit(\\n            pendingMint,\\n            _mintLimitParams[connector_]\\n        );\\n\\n        pendingMints[connector_][receiver_] = pendingAmount;\\n        connectorPendingMints[connector_] -= consumedAmount;\\n        totalMinted += consumedAmount;\\n\\n        token__.mint(receiver_, consumedAmount);\\n\\n        emit PendingTokensMinted(\\n            connector_,\\n            receiver_,\\n            consumedAmount,\\n            pendingAmount\\n        );\\n    }\\n\\n    // receive inbound assuming connector called\\n    function receiveInbound(bytes memory payload_) external override {\\n        if (_mintLimitParams[msg.sender].maxLimit == 0)\\n            revert ConnectorUnavailable();\\n\\n        (address receiver, uint256 lockAmount) = abi.decode(\\n            payload_,\\n            (address, uint256)\\n        );\\n        uint256 connectorPoolId = connectorPoolIds[msg.sender];\\n        if (connectorPoolId == 0) revert InvalidPoolId();\\n        poolLockedAmounts[connectorPoolId] += lockAmount;\\n\\n        uint256 mintAmount = exchangeRate__.getMintAmount(\\n            lockAmount,\\n            poolLockedAmounts[connectorPoolId]\\n        );\\n        (uint256 consumedAmount, uint256 pendingAmount) = _consumePartLimit(\\n            mintAmount,\\n            _mintLimitParams[msg.sender]\\n        );\\n\\n        if (pendingAmount > 0) {\\n            // add instead of overwrite to handle case where already pending amount is left\\n            pendingMints[msg.sender][receiver] += pendingAmount;\\n            connectorPendingMints[msg.sender] += pendingAmount;\\n            emit TokensPending(\\n                msg.sender,\\n                receiver,\\n                pendingAmount,\\n                pendingMints[msg.sender][receiver]\\n            );\\n        }\\n\\n        totalMinted += consumedAmount;\\n        token__.mint(receiver, consumedAmount);\\n\\n        emit TokensMinted(msg.sender, receiver, consumedAmount);\\n    }\\n\\n    function getMinFees(\\n        address connector_,\\n        uint256 msgGasLimit_\\n    ) external view returns (uint256 totalFees) {\\n        return IConnector(connector_).getMinFees(msgGasLimit_);\\n    }\\n\\n    function getCurrentMintLimit(\\n        address connector_\\n    ) external view returns (uint256) {\\n        return _getCurrentLimit(_mintLimitParams[connector_]);\\n    }\\n\\n    function getCurrentBurnLimit(\\n        address connector_\\n    ) external view returns (uint256) {\\n        return _getCurrentLimit(_burnLimitParams[connector_]);\\n    }\\n\\n    function getMintLimitParams(\\n        address connector_\\n    ) external view returns (LimitParams memory) {\\n        return _mintLimitParams[connector_];\\n    }\\n\\n    function getBurnLimitParams(\\n        address connector_\\n    ) external view returns (LimitParams memory) {\\n        return _burnLimitParams[connector_];\\n    }\\n\\n    /**\\n     * @notice Rescues funds from the contract if they are locked by mistake.\\n     * @param token_ The address of the token contract.\\n     * @param rescueTo_ The address where rescued tokens need to be sent.\\n     * @param amount_ The amount of tokens to be rescued.\\n     */\\n    function rescueFunds(\\n        address token_,\\n        address rescueTo_,\\n        uint256 amount_\\n    ) external onlyOwner {\\n        RescueFundsLib.rescueFunds(token_, rescueTo_, amount_);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/superbridge/ExchangeRate.sol\": {\r\n      \"content\": \"pragma solidity 0.8.13;\\n\\nimport \\\"lib/openzeppelin-contracts/contracts/access/Ownable2Step.sol\\\";\\nimport {RescueFundsLib} from \\\"./RescueFundsLib.sol\\\";\\n\\ninterface IExchangeRate {\\n    // not marked pure, may involve state interactions in future\\n    function getMintAmount(\\n        uint256 lockAmount,\\n        uint256 totalLockedAmount\\n    ) external returns (uint256 mintAmount);\\n\\n    // not marked pure, may involve state interactions in future\\n    function getUnlockAmount(\\n        uint256 burnAmount,\\n        uint256 totalLockedAmount\\n    ) external returns (uint256 unlockAmount);\\n}\\n\\ncontract ExchangeRate is IExchangeRate, Ownable2Step {\\n    // chainId input needed? what else? slippage?\\n    function getMintAmount(\\n        uint256 lockAmount,\\n        uint256 /* totalLockedAmount */\\n    ) external pure returns (uint256 mintAmount) {\\n        return lockAmount;\\n    }\\n\\n    function getUnlockAmount(\\n        uint256 burnAmount,\\n        uint256 /* totalLockedAmount */\\n    ) external pure returns (uint256 unlockAmount) {\\n        return burnAmount;\\n    }\\n\\n    /**\\n     * @notice Rescues funds from the contract if they are locked by mistake.\\n     * @param token_ The address of the token contract.\\n     * @param rescueTo_ The address where rescued tokens need to be sent.\\n     * @param amount_ The amount of tokens to be rescued.\\n     */\\n    function rescueFunds(\\n        address token_,\\n        address rescueTo_,\\n        uint256 amount_\\n    ) external onlyOwner {\\n        RescueFundsLib.rescueFunds(token_, rescueTo_, amount_);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/superbridge/Gauge.sol\": {\r\n      \"content\": \"pragma solidity 0.8.13;\\n\\nabstract contract Gauge {\\n    struct LimitParams {\\n        uint256 lastUpdateTimestamp;\\n        uint256 ratePerSecond;\\n        uint256 maxLimit;\\n        uint256 lastUpdateLimit;\\n    }\\n\\n    error AmountOutsideLimit();\\n\\n    function _getCurrentLimit(\\n        LimitParams storage _params\\n    ) internal view returns (uint256 _limit) {\\n        uint256 timeElapsed = block.timestamp - _params.lastUpdateTimestamp;\\n        uint256 limitIncrease = timeElapsed * _params.ratePerSecond;\\n\\n        if (limitIncrease + _params.lastUpdateLimit > _params.maxLimit) {\\n            _limit = _params.maxLimit;\\n        } else {\\n            _limit = limitIncrease + _params.lastUpdateLimit;\\n        }\\n    }\\n\\n    function _consumePartLimit(\\n        uint256 amount_,\\n        LimitParams storage _params\\n    ) internal returns (uint256 consumedAmount, uint256 pendingAmount) {\\n        uint256 currentLimit = _getCurrentLimit(_params);\\n        _params.lastUpdateTimestamp = block.timestamp;\\n        if (currentLimit >= amount_) {\\n            _params.lastUpdateLimit = currentLimit - amount_;\\n            consumedAmount = amount_;\\n            pendingAmount = 0;\\n        } else {\\n            _params.lastUpdateLimit = 0;\\n            consumedAmount = currentLimit;\\n            pendingAmount = amount_ - currentLimit;\\n        }\\n    }\\n\\n    function _consumeFullLimit(\\n        uint256 amount_,\\n        LimitParams storage _params\\n    ) internal {\\n        uint256 currentLimit = _getCurrentLimit(_params);\\n        if (currentLimit >= amount_) {\\n            _params.lastUpdateTimestamp = block.timestamp;\\n            _params.lastUpdateLimit = currentLimit - amount_;\\n        } else {\\n            revert AmountOutsideLimit();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/superbridge/MintableToken.sol\": {\r\n      \"content\": \"pragma solidity 0.8.13;\\n\\nimport \\\"lib/solmate/src/tokens/ERC20.sol\\\";\\n\\nabstract contract IMintableERC20 is ERC20 {\\n    function mint(address receiver_, uint256 amount_) external virtual;\\n\\n    function burn(address burner_, uint256 amount_) external virtual;\\n}\\n\\n// this is a mock token used in tests, other projects' token to be used here\\ncontract MintableToken is IMintableERC20 {\\n    constructor(\\n        string memory name_,\\n        string memory symbol_,\\n        uint8 decimals_\\n    ) ERC20(name_, symbol_, decimals_) {}\\n\\n    function mint(address receiver_, uint256 amount_) external override {\\n        _mint(receiver_, amount_);\\n    }\\n\\n    function burn(address burner_, uint256 amount_) external override {\\n        _burn(burner_, amount_);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/superbridge/NonMintableToken.sol\": {\r\n      \"content\": \"pragma solidity 0.8.13;\\n\\nimport \\\"lib/solmate/src/tokens/ERC20.sol\\\";\\n\\ncontract NonMintableToken is ERC20 {\\n    // this is a mock token used in tests, other projects' token to be used here\\n    constructor(\\n        string memory name_,\\n        string memory symbol_,\\n        uint8 decimals_,\\n        uint256 totalSupply_\\n    ) ERC20(name_, symbol_, decimals_) {\\n        _mint(msg.sender, totalSupply_);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/superbridge/RescueFundsLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity 0.8.13;\\n\\nimport \\\"lib/solmate/src/utils/SafeTransferLib.sol\\\";\\n\\nerror ZeroAddress();\\n\\n/**\\n * @title RescueFundsLib\\n * @dev A library that provides a function to rescue funds from a contract.\\n */\\n\\nlibrary RescueFundsLib {\\n    /**\\n     * @dev The address used to identify ETH.\\n     */\\n    address public constant ETH_ADDRESS =\\n        address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\\n\\n    /**\\n     * @dev thrown when the given token address don't have any code\\n     */\\n    error InvalidTokenAddress();\\n\\n    /**\\n     * @dev Rescues funds from a contract.\\n     * @param token_ The address of the token contract.\\n     * @param rescueTo_ The address of the user.\\n     * @param amount_ The amount of tokens to be rescued.\\n     */\\n    function rescueFunds(\\n        address token_,\\n        address rescueTo_,\\n        uint256 amount_\\n    ) internal {\\n        if (rescueTo_ == address(0)) revert ZeroAddress();\\n\\n        if (token_ == ETH_ADDRESS) {\\n            SafeTransferLib.safeTransferETH(rescueTo_, amount_);\\n        } else {\\n            if (token_.code.length == 0) revert InvalidTokenAddress();\\n            SafeTransferLib.safeTransfer(ERC20(token_), rescueTo_, amount_);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/superbridge/Vault.sol\": {\r\n      \"content\": \"pragma solidity 0.8.13;\\n\\nimport \\\"lib/solmate/src/utils/SafeTransferLib.sol\\\";\\nimport \\\"lib/openzeppelin-contracts/contracts/access/Ownable2Step.sol\\\";\\nimport {Gauge} from \\\"./Gauge.sol\\\";\\nimport {IConnector, IHub} from \\\"./ConnectorPlug.sol\\\";\\nimport {RescueFundsLib} from \\\"./RescueFundsLib.sol\\\";\\n\\n// @todo: separate our connecter plugs\\ncontract Vault is Gauge, IHub, Ownable2Step {\\n    using SafeTransferLib for ERC20;\\n    ERC20 public immutable token__;\\n\\n    struct UpdateLimitParams {\\n        bool isLock;\\n        address connector;\\n        uint256 maxLimit;\\n        uint256 ratePerSecond;\\n    }\\n\\n    // connector => receiver => pendingUnlock\\n    mapping(address => mapping(address => uint256)) public pendingUnlocks;\\n\\n    // connector => amount\\n    mapping(address => uint256) public connectorPendingUnlocks;\\n\\n    // connector => lockLimitParams\\n    mapping(address => LimitParams) _lockLimitParams;\\n\\n    // connector => unlockLimitParams\\n    mapping(address => LimitParams) _unlockLimitParams;\\n\\n    error ConnectorUnavailable();\\n    error ZeroAmount();\\n\\n    event LimitParamsUpdated(UpdateLimitParams[] updates);\\n    event TokensDeposited(\\n        address connector,\\n        address depositor,\\n        address receiver,\\n        uint256 depositAmount\\n    );\\n    event PendingTokensTransferred(\\n        address connector,\\n        address receiver,\\n        uint256 unlockedAmount,\\n        uint256 pendingAmount\\n    );\\n    event TokensPending(\\n        address connector,\\n        address receiver,\\n        uint256 pendingAmount,\\n        uint256 totalPendingAmount\\n    );\\n    event TokensUnlocked(\\n        address connector,\\n        address receiver,\\n        uint256 unlockedAmount\\n    );\\n\\n    constructor(address token_) {\\n        token__ = ERC20(token_);\\n    }\\n\\n    function updateLimitParams(\\n        UpdateLimitParams[] calldata updates_\\n    ) external onlyOwner {\\n        for (uint256 i; i < updates_.length; i++) {\\n            if (updates_[i].isLock) {\\n                _consumePartLimit(0, _lockLimitParams[updates_[i].connector]); // to keep current limit in sync\\n                _lockLimitParams[updates_[i].connector].maxLimit = updates_[i]\\n                    .maxLimit;\\n                _lockLimitParams[updates_[i].connector]\\n                    .ratePerSecond = updates_[i].ratePerSecond;\\n            } else {\\n                _consumePartLimit(0, _unlockLimitParams[updates_[i].connector]); // to keep current limit in sync\\n                _unlockLimitParams[updates_[i].connector].maxLimit = updates_[i]\\n                    .maxLimit;\\n                _unlockLimitParams[updates_[i].connector]\\n                    .ratePerSecond = updates_[i].ratePerSecond;\\n            }\\n        }\\n\\n        emit LimitParamsUpdated(updates_);\\n    }\\n\\n    function depositToAppChain(\\n        address receiver_,\\n        uint256 amount_,\\n        uint256 msgGasLimit_,\\n        address connector_\\n    ) external payable {\\n        if (amount_ == 0) revert ZeroAmount();\\n\\n        if (_lockLimitParams[connector_].maxLimit == 0)\\n            revert ConnectorUnavailable();\\n\\n        _consumeFullLimit(amount_, _lockLimitParams[connector_]); // reverts on limit hit\\n\\n        token__.safeTransferFrom(msg.sender, address(this), amount_);\\n\\n        IConnector(connector_).outbound{value: msg.value}(\\n            msgGasLimit_,\\n            abi.encode(receiver_, amount_)\\n        );\\n\\n        emit TokensDeposited(connector_, msg.sender, receiver_, amount_);\\n    }\\n\\n    function unlockPendingFor(address receiver_, address connector_) external {\\n        if (_unlockLimitParams[connector_].maxLimit == 0)\\n            revert ConnectorUnavailable();\\n\\n        uint256 pendingUnlock = pendingUnlocks[connector_][receiver_];\\n        (uint256 consumedAmount, uint256 pendingAmount) = _consumePartLimit(\\n            pendingUnlock,\\n            _unlockLimitParams[connector_]\\n        );\\n\\n        pendingUnlocks[connector_][receiver_] = pendingAmount;\\n        connectorPendingUnlocks[connector_] -= consumedAmount;\\n\\n        token__.safeTransfer(receiver_, consumedAmount);\\n\\n        emit PendingTokensTransferred(\\n            connector_,\\n            receiver_,\\n            consumedAmount,\\n            pendingAmount\\n        );\\n    }\\n\\n    // receive inbound assuming connector called\\n    function receiveInbound(bytes memory payload_) external override {\\n        if (_unlockLimitParams[msg.sender].maxLimit == 0)\\n            revert ConnectorUnavailable();\\n\\n        (address receiver, uint256 unlockAmount) = abi.decode(\\n            payload_,\\n            (address, uint256)\\n        );\\n\\n        (uint256 consumedAmount, uint256 pendingAmount) = _consumePartLimit(\\n            unlockAmount,\\n            _unlockLimitParams[msg.sender]\\n        );\\n\\n        if (pendingAmount > 0) {\\n            // add instead of overwrite to handle case where already pending amount is left\\n            pendingUnlocks[msg.sender][receiver] += pendingAmount;\\n            connectorPendingUnlocks[msg.sender] += pendingAmount;\\n            emit TokensPending(\\n                msg.sender,\\n                receiver,\\n                pendingAmount,\\n                pendingUnlocks[msg.sender][receiver]\\n            );\\n        }\\n        token__.safeTransfer(receiver, consumedAmount);\\n\\n        emit TokensUnlocked(msg.sender, receiver, consumedAmount);\\n    }\\n\\n    function getMinFees(\\n        address connector_,\\n        uint256 msgGasLimit_\\n    ) external view returns (uint256 totalFees) {\\n        return IConnector(connector_).getMinFees(msgGasLimit_);\\n    }\\n\\n    function getCurrentLockLimit(\\n        address connector_\\n    ) external view returns (uint256) {\\n        return _getCurrentLimit(_lockLimitParams[connector_]);\\n    }\\n\\n    function getCurrentUnlockLimit(\\n        address connector_\\n    ) external view returns (uint256) {\\n        return _getCurrentLimit(_unlockLimitParams[connector_]);\\n    }\\n\\n    function getLockLimitParams(\\n        address connector_\\n    ) external view returns (LimitParams memory) {\\n        return _lockLimitParams[connector_];\\n    }\\n\\n    function getUnlockLimitParams(\\n        address connector_\\n    ) external view returns (LimitParams memory) {\\n        return _unlockLimitParams[connector_];\\n    }\\n\\n    /**\\n     * @notice Rescues funds from the contract if they are locked by mistake.\\n     * @param token_ The address of the token contract.\\n     * @param rescueTo_ The address where rescued tokens need to be sent.\\n     * @param amount_ The amount of tokens to be rescued.\\n     */\\n    function rescueFunds(\\n        address token_,\\n        address rescueTo_,\\n        uint256 amount_\\n    ) external onlyOwner {\\n        RescueFundsLib.rescueFunds(token_, rescueTo_, amount_);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/access/Ownable2Step.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable2Step.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Ownable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership} and {acceptOwnership}.\\n *\\n * This module is used through inheritance. It will make available all functions\\n * from parent (Ownable).\\n */\\nabstract contract Ownable2Step is Ownable {\\n    address private _pendingOwner;\\n\\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Returns the address of the pending owner.\\n     */\\n    function pendingOwner() public view virtual returns (address) {\\n        return _pendingOwner;\\n    }\\n\\n    /**\\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\\n        _pendingOwner = newOwner;\\n        emit OwnershipTransferStarted(owner(), newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual override {\\n        delete _pendingOwner;\\n        super._transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev The new owner accepts the ownership transfer.\\n     */\\n    function acceptOwnership() public virtual {\\n        address sender = _msgSender();\\n        require(pendingOwner() == sender, \\\"Ownable2Step: caller is not the new owner\\\");\\n        _transferOwnership(sender);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/tokens/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\\nabstract contract ERC20 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    uint8 public immutable decimals;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            EIP-2612 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\n\\n    mapping(address => uint256) public nonces;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n\\n        INITIAL_CHAIN_ID = block.chainid;\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        balanceOf[msg.sender] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\n\\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\\n\\n        balanceOf[from] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             EIP-2612 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        require(deadline >= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\n\\n        // Unchecked because the only math done is incrementing\\n        // the owner's nonce which cannot realistically overflow.\\n        unchecked {\\n            address recoveredAddress = ecrecover(\\n                keccak256(\\n                    abi.encodePacked(\\n                        \\\"\\\\x19\\\\x01\\\",\\n                        DOMAIN_SEPARATOR(),\\n                        keccak256(\\n                            abi.encode(\\n                                keccak256(\\n                                    \\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\"\\n                                ),\\n                                owner,\\n                                spender,\\n                                value,\\n                                nonces[owner]++,\\n                                deadline\\n                            )\\n                        )\\n                    )\\n                ),\\n                v,\\n                r,\\n                s\\n            );\\n\\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"INVALID_SIGNER\\\");\\n\\n            allowance[recoveredAddress][spender] = value;\\n        }\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\n    }\\n\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                    keccak256(bytes(name)),\\n                    keccak256(\\\"1\\\"),\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        totalSupply += amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        balanceOf[from] -= amount;\\n\\n        // Cannot underflow because a user's balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply -= amount;\\n        }\\n\\n        emit Transfer(from, address(0), amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/utils/SafeTransferLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"../tokens/ERC20.sol\\\";\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\\nlibrary SafeTransferLib {\\n    /*//////////////////////////////////////////////////////////////\\n                             ETH OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Transfer the ETH and store if it succeeded or not.\\n            success := call(gas(), to, amount, 0, 0, 0, 0)\\n        }\\n\\n        require(success, \\\"ETH_TRANSFER_FAILED\\\");\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            ERC20 OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferFrom(\\n        ERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), and(from, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \\\"from\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \\\"amount\\\" argument. Masking not required as it's a full 32 byte type.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"TRANSFER_FROM_FAILED\\\");\\n    }\\n\\n    function safeTransfer(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument. Masking not required as it's a full 32 byte type.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"TRANSFER_FAILED\\\");\\n    }\\n\\n    function safeApprove(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument. Masking not required as it's a full 32 byte type.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"APPROVE_FAILED\\\");\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 999999\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"hub_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"socket_\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"siblingChainSlug_\",\"type\":\"uint32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"InvalidTokenAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotHub\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotSocket\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroAddress\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"ConnectorPlugDisconnected\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"siblingPlug_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"switchboard_\",\"type\":\"address\"}],\"name\":\"connect\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disconnect\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"msgGasLimit_\",\"type\":\"uint256\"}],\"name\":\"getMinFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalFees\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hub__\",\"outputs\":[{\"internalType\":\"contract IHub\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"},{\"internalType\":\"bytes\",\"name\":\"payload_\",\"type\":\"bytes\"}],\"name\":\"inbound\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"msgGasLimit_\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"payload_\",\"type\":\"bytes\"}],\"name\":\"outbound\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rescueTo_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"}],\"name\":\"rescueFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"siblingChainSlug\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"socket__\",\"outputs\":[{\"internalType\":\"contract ISocket\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "ConnectorPlug", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "999999", "ConstructorArguments": "0000000000000000000000006d303cee7959f814042d31e0624fb88ec6fbcc1d000000000000000000000000943ac2775928318653e91d350574436a1b9b16f900000000000000000000000000000000000000000000000000000000000003bd", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}