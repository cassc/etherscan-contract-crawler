{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Metadata is IERC721 {\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@rmrk-team/evm-contracts/contracts/RMRK/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\npragma solidity ^0.8.21;\\n\\nimport \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\nimport \\\"../library/RMRKErrors.sol\\\";\\n\\n/**\\n * @title Ownable\\n * @author RMRK team\\n * @notice A minimal ownable smart contractf or owner and contributors.\\n * @dev This smart contract is based on \\\"openzeppelin's access/Ownable.sol\\\".\\n */\\ncontract Ownable is Context {\\n    address private _owner;\\n    mapping(address => uint256) private _contributors;\\n\\n    /**\\n     * @notice Used to anounce the transfer of ownership.\\n     * @param previousOwner Address of the account that transferred their ownership role\\n     * @param newOwner Address of the account receiving the ownership role\\n     */\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    /**\\n     * @notice Event that signifies that an address was granted contributor role or that the permission has been\\n     *  revoked.\\n     * @dev This can only be triggered by a current owner, so there is no need to include that information in the event.\\n     * @param contributor Address of the account that had contributor role status updated\\n     * @param isContributor A boolean value signifying whether the role has been granted (`true`) or revoked (`false`)\\n     */\\n    event ContributorUpdate(address indexed contributor, bool isContributor);\\n\\n    /**\\n     * @dev Reverts if called by any account other than the owner or an approved contributor.\\n     */\\n    modifier onlyOwnerOrContributor() {\\n        _onlyOwnerOrContributor();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Reverts if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _onlyOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Initializes the contract by setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @notice Returns the address of the current owner.\\n     * @return Address of the current owner\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @notice Leaves the contract without owner. Functions using the `onlyOwner` modifier will be disabled.\\n     * @dev Can only be called by the current owner.\\n     * @dev Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is\\n     *  only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @notice Transfers ownership of the contract to a new owner.\\n     * @dev Can only be called by the current owner.\\n     * @param newOwner Address of the new owner's account\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        if (newOwner == address(0)) revert RMRKNewOwnerIsZeroAddress();\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @notice Transfers ownership of the contract to a new owner.\\n     * @dev Internal function without access restriction.\\n     * @dev Emits ***OwnershipTransferred*** event.\\n     * @param newOwner Address of the new owner's account\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n\\n    /**\\n     * @notice Adds or removes a contributor to the smart contract.\\n     * @dev Can only be called by the owner.\\n     * @dev Emits ***ContributorUpdate*** event.\\n     * @param contributor Address of the contributor's account\\n     * @param grantRole A boolean value signifying whether the contributor role is being granted (`true`) or revoked\\n     *  (`false`)\\n     */\\n    function manageContributor(\\n        address contributor,\\n        bool grantRole\\n    ) external onlyOwner {\\n        if (contributor == address(0)) revert RMRKNewContributorIsZeroAddress();\\n        grantRole\\n            ? _contributors[contributor] = 1\\n            : _contributors[contributor] = 0;\\n        emit ContributorUpdate(contributor, grantRole);\\n    }\\n\\n    /**\\n     * @notice Used to check if the address is one of the contributors.\\n     * @param contributor Address of the contributor whose status we are checking\\n     * @return Boolean value indicating whether the address is a contributor or not\\n     */\\n    function isContributor(address contributor) public view returns (bool) {\\n        return _contributors[contributor] == 1;\\n    }\\n\\n    /**\\n     * @notice Used to verify that the caller is either the owner or a contributor.\\n     * @dev If the caller is not the owner or a contributor, the execution will be reverted.\\n     */\\n    function _onlyOwnerOrContributor() private view {\\n        if (owner() != _msgSender() && !isContributor(_msgSender()))\\n            revert RMRKNotOwnerOrContributor();\\n    }\\n\\n    /**\\n     * @notice Used to verify that the caller is the owner.\\n     * @dev If the caller is not the owner, the execution will be reverted.\\n     */\\n    function _onlyOwner() private view {\\n        if (owner() != _msgSender()) revert RMRKNotOwner();\\n    }\\n}\\n\"\r\n    },\r\n    \"@rmrk-team/evm-contracts/contracts/RMRK/library/RMRKErrors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\npragma solidity ^0.8.21;\\n\\n/// @title RMRKErrors\\n/// @author RMRK team\\n/// @notice A collection of errors used in the RMRK suite\\n/// @dev Errors are kept in a centralised file in order to provide a central point of reference and to avoid error\\n///  naming collisions due to inheritance\\n\\n/// Attempting to grant the token to 0x0 address\\nerror ERC721AddressZeroIsNotaValidOwner();\\n/// Attempting to grant approval to the current owner of the token\\nerror ERC721ApprovalToCurrentOwner();\\n/// Attempting to grant approval when not being owner or approved for all should not be permitted\\nerror ERC721ApproveCallerIsNotOwnerNorApprovedForAll();\\n/// Attempting to get approvals for a token owned by 0x0 (considered non-existent)\\nerror ERC721ApprovedQueryForNonexistentToken();\\n/// Attempting to grant approval to self\\nerror ERC721ApproveToCaller();\\n/// Attempting to use an invalid token ID\\nerror ERC721InvalidTokenId();\\n/// Attempting to mint to 0x0 address\\nerror ERC721MintToTheZeroAddress();\\n/// Attempting to manage a token without being its owner or approved by the owner\\nerror ERC721NotApprovedOrOwner();\\n/// Attempting to mint an already minted token\\nerror ERC721TokenAlreadyMinted();\\n/// Attempting to transfer the token from an address that is not the owner\\nerror ERC721TransferFromIncorrectOwner();\\n/// Attempting to safe transfer to an address that is unable to receive the token\\nerror ERC721TransferToNonReceiverImplementer();\\n/// Attempting to transfer the token to a 0x0 address\\nerror ERC721TransferToTheZeroAddress();\\n/// Attempting to grant approval of assets to their current owner\\nerror RMRKApprovalForAssetsToCurrentOwner();\\n/// Attempting to grant approval of assets without being the caller or approved for all\\nerror RMRKApproveForAssetsCallerIsNotOwnerNorApprovedForAll();\\n/// Attempting to incorrectly configue a Catalog item\\nerror RMRKBadConfig();\\n/// Attempting to set the priorities with an array of length that doesn't match the length of active assets array\\nerror RMRKBadPriorityListLength();\\n/// Attempting to add an asset entry with `Part`s, without setting the `Catalog` address\\nerror RMRKCatalogRequiredForParts();\\n/// Attempting to transfer a soulbound (non-transferrable) token\\nerror RMRKCannotTransferSoulbound();\\n/// Attempting to accept a child that has already been accepted\\nerror RMRKChildAlreadyExists();\\n/// Attempting to interact with a child, using index that is higher than the number of children\\nerror RMRKChildIndexOutOfRange();\\n/// Attempting to find the index of a child token on a parent which does not own it.\\nerror RMRKChildNotFoundInParent();\\n/// Attempting to pass collaborator address array and collaborator permission array of different lengths\\nerror RMRKCollaboratorArraysNotEqualLength();\\n/// Attempting to register a collection that is already registered\\nerror RMRKCollectionAlreadyRegistered();\\n/// Attempting to manage or interact with colleciton that is not registered\\nerror RMRKCollectionNotRegistered();\\n/// Attempting to equip a `Part` with a child not approved by the Catalog\\nerror RMRKEquippableEquipNotAllowedByCatalog();\\n/// Attempting to pass an epired ECDSA deadline\\nerror RMRKExpiredDeadline();\\n/// Attempting to use ID 0, which is not supported\\n/// @dev The ID 0 in RMRK suite is reserved for empty values. Guarding against its use ensures the expected operation\\nerror RMRKIdZeroForbidden();\\n/// Attempting to interact with an asset, using index greater than number of assets\\nerror RMRKIndexOutOfRange();\\n/// Attempting to reclaim a child that can't be reclaimed\\nerror RMRKInvalidChildReclaim();\\n/// Attempting to use and invalid ECDSA signature\\nerror RMRKInvalidSignature();\\n/// Attempting to interact with an end-user account when the contract account is expected\\nerror RMRKIsNotContract();\\n/// Attempting to interact with a contract that had its operation locked\\nerror RMRKLocked();\\n/// Attempting to add a pending child after the number of pending children has reached the limit (default limit is 128)\\nerror RMRKMaxPendingChildrenReached();\\n/// Attempting to add a pending asset after the number of pending assets has reached the limit (default limit is\\n///  128)\\nerror RMRKMaxPendingAssetsReached();\\n/// Attempting to burn a total number of recursive children higher than maximum set\\n/// @param childContract Address of the collection smart contract in which the maximum number of recursive burns was reached\\n/// @param childId ID of the child token at which the maximum number of recursive burns was reached\\nerror RMRKMaxRecursiveBurnsReached(address childContract, uint256 childId);\\n/// Attempting to mint a number of tokens that would cause the total supply to be greater than maximum supply\\nerror RMRKMintOverMax();\\n/// Attempting to mint a nested token to a smart contract that doesn't support nesting\\nerror RMRKMintToNonRMRKNestableImplementer();\\n/// Attempting to mint zero tokens\\nerror RMRKMintZero();\\n/// Attempting to pass complementary arrays of different lengths\\nerror RMRKMismachedArrayLength();\\n/// Attempting to transfer a child before it is unequipped\\nerror RMRKMustUnequipFirst();\\n/// Attempting to nest a child over the nestable limit (current limit is 100 levels of nesting)\\nerror RMRKNestableTooDeep();\\n/// Attempting to nest the token to own descendant, which would create a loop and leave the looped tokens in limbo\\nerror RMRKNestableTransferToDescendant();\\n/// Attempting to nest the token to a smart contract that doesn't support nesting\\nerror RMRKNestableTransferToNonRMRKNestableImplementer();\\n/// Attempting to nest the token into itself\\nerror RMRKNestableTransferToSelf();\\n/// Attempting to interact with an asset that can not be found\\nerror RMRKNoAssetMatchingId();\\n/// Attempting to manage an asset without owning it or having been granted permission by the owner to do so\\nerror RMRKNotApprovedForAssetsOrOwner();\\n/// Attempting to interact with a token without being its owner or having been granted permission by the\\n///  owner to do so\\n/// @dev When a token is nested, only the direct owner (NFT parent) can mange it. In that case, approved addresses are\\n///  not allowed to manage it, in order to ensure the expected behaviour\\nerror RMRKNotApprovedOrDirectOwner();\\n/// Attempting to manage a collection without being the collection's collaborator\\nerror RMRKNotCollectionCollaborator();\\n/// Attemting to manage a collection without being the collection's issuer\\nerror RMRKNotCollectionIssuer();\\n/// Attempting to manage a collection without being the collection's issuer or collaborator\\nerror RMRKNotCollectionIssuerOrCollaborator();\\n/// Attempting to compose an asset wihtout having an associated Catalog\\nerror RMRKNotComposableAsset();\\n/// Attempting to unequip an item that isn't equipped\\nerror RMRKNotEquipped();\\n/// Attempting to interact with a management function without being the smart contract's owner\\nerror RMRKNotOwner();\\n/// Attempting to interact with a function without being the owner or contributor of the collection\\nerror RMRKNotOwnerOrContributor();\\n/// Attempting to manage a collection without being the specific address\\nerror RMRKNotSpecificAddress();\\n/// Attempting to manage a token without being its owner\\nerror RMRKNotTokenOwner();\\n/// Attempting to transfer the ownership to the 0x0 address\\nerror RMRKNewOwnerIsZeroAddress();\\n/// Attempting to assign a 0x0 address as a contributor\\nerror RMRKNewContributorIsZeroAddress();\\n/// Attemtping to use `Ownable` interface without implementing it\\nerror RMRKOwnableNotImplemented();\\n/// Attempting an operation requiring the token being nested, while it is not\\nerror RMRKParentIsNotNFT();\\n/// Attempting to add a `Part` with an ID that is already used\\nerror RMRKPartAlreadyExists();\\n/// Attempting to use a `Part` that doesn't exist\\nerror RMRKPartDoesNotExist();\\n/// Attempting to use a `Part` that is `Fixed` when `Slot` kind of `Part` should be used\\nerror RMRKPartIsNotSlot();\\n/// Attempting to interact with a pending child using an index greater than the size of pending array\\nerror RMRKPendingChildIndexOutOfRange();\\n/// Attempting to add an asset using an ID that has already been used\\nerror RMRKAssetAlreadyExists();\\n/// Attempting to equip an item into a slot that already has an item equipped\\nerror RMRKSlotAlreadyUsed();\\n/// Attempting to equip an item into a `Slot` that the target asset does not implement\\nerror RMRKTargetAssetCannotReceiveSlot();\\n/// Attempting to equip a child into a `Slot` and parent that the child's collection doesn't support\\nerror RMRKTokenCannotBeEquippedWithAssetIntoSlot();\\n/// Attempting to compose a NFT of a token without active assets\\nerror RMRKTokenDoesNotHaveAsset();\\n/// Attempting to determine the asset with the top priority on a token without assets\\nerror RMRKTokenHasNoAssets();\\n/// Attempting to accept or transfer a child which does not match the one at the specified index\\nerror RMRKUnexpectedChildId();\\n/// Attempting to reject all pending assets but more assets than expected are pending\\nerror RMRKUnexpectedNumberOfAssets();\\n/// Attempting to reject all pending children but children assets than expected are pending\\nerror RMRKUnexpectedNumberOfChildren();\\n/// Attempting to accept or reject an asset which does not match the one at the specified index\\nerror RMRKUnexpectedAssetId();\\n/// Attempting an operation expecting a parent to the token which is not the actual one\\nerror RMRKUnexpectedParent();\\n/// Attempting not to pass an empty array of equippable addresses when adding or setting the equippable addresses\\nerror RMRKZeroLengthIdsPassed();\\n/// Attempting to set the royalties to a value higher than 100% (10000 in basis points)\\nerror RMRKRoyaltiesTooHigh();\\n/// Attempting to do a bulk operation on a token that is not owned by the caller\\nerror RMRKCanOnlyDoBulkOperationsOnOwnedTokens();\\n/// Attempting to do a bulk operation with multiple tokens at a time\\nerror RMRKCanOnlyDoBulkOperationsWithOneTokenAtATime();\\n/// Attempting to pay with native token with a value different than expected\\nerror RMRKWrongValueSent();\\n\"\r\n    },\r\n    \"contracts/interfaces/IRMRKDeployer.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: Apache 2.0\\n\\npragma solidity ^0.8.21;\\n\\n/**\\n * @title RMRK Deployer Interface\\n * @notice This is interface is for an intermediary contract whose only purpose is to deploy Wrapped Collections.\\n * @dev This contract does not have any validation, it is kept the minimal possible to avoid breaking the size limit.\\n */\\ninterface IRMRKDeployer {\\n    /**\\n     * @notice Deploys a new collection.\\n     * @param name Name of the token collection\\n     * @param symbol Symbol of the token collection\\n     * @param collectionMetadata CID of the collection metadata\\n     * @param maxSupply The maximum supply of tokens\\n     * @param royaltyRecipient Recipient of resale royalties\\n     * @param royaltyPercentageBps The percentage to be paid from the sale of the token expressed in basis points\\n     * @param initialAssetsMetadata Array with metadata of the initial assets which will be added into every minted token\\n     */\\n    function deployCollection(\\n        string memory name,\\n        string memory symbol,\\n        string memory collectionMetadata,\\n        uint256 maxSupply,\\n        address collectionOwner,\\n        address royaltyRecipient,\\n        uint16 royaltyPercentageBps,\\n        string[] memory initialAssetsMetadata\\n    ) external returns (address newCollection);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IRMRKMintaurRegistry.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: Apache 2.0\\n\\npragma solidity ^0.8.21;\\n\\n/**\\n * @title RMRK Mint'aur Registry Interface\\n * @notice\\n */\\ninterface IRMRKMintaurRegistry {\\n    function mint(\\n        address collection,\\n        address to,\\n        uint256 numToMint\\n    ) external payable;\\n\\n    function storeNewCollection(\\n        address collection,\\n        uint256 mintPrice,\\n        uint256 mintFee,\\n        address beneficiary,\\n        uint256 cutOffDate\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IRMRKRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.21;\\n\\ninterface IRMRKRegistry {\\n    enum LegoCombination {\\n        None,\\n        MultiAsset,\\n        Nestable,\\n        NestableMultiAsset,\\n        Equippable,\\n        ERC721,\\n        ERC1155,\\n        Custom\\n    }\\n\\n    enum MintingType {\\n        None,\\n        RMRKPreMint,\\n        RMRKLazyMintNativeToken,\\n        RMRKLazyMintERC20,\\n        Custom\\n    }\\n\\n    struct CollectionConfig {\\n        bool usesOwnable;\\n        bool usesAccessControl;\\n        bool usesRMRKContributor;\\n        bool usesRMRKMintingUtils;\\n        bool usesRMRKLockable;\\n        bool hasStandardAssetManagement; // has addAssetEntry, addEquippableAssetEntry, addAssetToToken, etc\\n        bool hasStandardMinting; // has mint(address to, uint256 numToMint)\\n        bool hasStandardNestMinting; // has nestMint(address to, uint256 numToMint, uint256 destinationId)\\n        bool autoAcceptsFirstAsset;\\n        uint8 customLegoCombination;\\n        uint8 customMintingType;\\n        bytes32 adminRole; // Only for AccessControl users\\n    }\\n\\n    struct Collection {\\n        address collection;\\n        address verificationSponsor;\\n        uint256 verificationFeeBalance;\\n        LegoCombination legoCombination;\\n        MintingType mintingType;\\n        bool isSoulbound;\\n        bool visible;\\n        bool verified;\\n        CollectionConfig config;\\n    }\\n\\n    event CollectionAdded(\\n        address deployer,\\n        string name,\\n        string symbol,\\n        uint256 maxSupply,\\n        string collectionMetadata,\\n        LegoCombination legoCombination,\\n        MintingType mintingType,\\n        bool isSoulbound,\\n        CollectionConfig config\\n    );\\n\\n    function addCollection(\\n        address collection,\\n        address deployer,\\n        uint256 maxSupply,\\n        LegoCombination legoCombination,\\n        MintingType mintingType,\\n        bool isSoulbound,\\n        CollectionConfig memory config,\\n        string memory collectionMetadata\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/RMRKMintaur.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: Apache 2.0\\n\\npragma solidity ^0.8.21;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\\\";\\nimport \\\"@rmrk-team/evm-contracts/contracts/RMRK/access/Ownable.sol\\\";\\nimport \\\"./interfaces/IRMRKDeployer.sol\\\";\\nimport \\\"./interfaces/IRMRKMintaurRegistry.sol\\\";\\nimport \\\"./interfaces/IRMRKRegistry.sol\\\";\\n\\nerror FailedToSend();\\nerror FeeTooLow();\\nerror InvalidCutOffDate();\\nerror WrongValueSent();\\n\\n/**\\n * @title RMRK Mint'aur\\n * @notice This contract is used to create new RMRK collections\\n */\\ncontract RMRKMintaur is Ownable {\\n    /**\\n     * @notice Emitted when a collection is created.\\n     * @param collection The address of the new collection\\n     * @param deployer The address of the deployer\\n     */\\n    event CollectionDeployed(\\n        address indexed collection,\\n        address indexed deployer,\\n        uint256 maxSupply,\\n        uint256 mintPrice,\\n        uint256 cutOffDate,\\n        string collectionMetadata\\n    );\\n\\n    uint8 CUSTOM_MINTING_TYPE_FROM_MINTAUR = 3;\\n    IRMRKRegistry.CollectionConfig private _defaultCollectionConfig;\\n\\n    address private _platformBeneficiary;\\n    IRMRKDeployer private _deployer;\\n    IRMRKRegistry private _registry;\\n    IRMRKMintaurRegistry private _mintaurRegistry;\\n\\n    uint256 private _assetPinningPrice;\\n    uint256 private _minimumMintingFee;\\n    uint256 private _mintingFeePercentageBPS;\\n\\n    /**\\n     * @notice Initializes the contract.\\n     * @dev The basis points (bPt) are integer representation of percentage up to the second decimal space. Meaning that\\n     *  1 bPt equals 0.01% and 500 bPt equal 5%.\\n     * @param beneficiary The address of the beneficiary\\n     * @param deployer The address of the deployer contract\\n     * @param registry The address of the registry contract\\n     * @param assetPinningPrice The individial pinning price per asset\\n     * @param minimumMintingFee The minimum price per minted token\\n     * @param mintingFeePercentageBPS The minting fee percentage in basis points\\n     */\\n    constructor(\\n        address beneficiary,\\n        address deployer,\\n        address registry,\\n        uint256 assetPinningPrice,\\n        uint256 minimumMintingFee,\\n        uint256 mintingFeePercentageBPS\\n    ) {\\n        _platformBeneficiary = beneficiary;\\n        _deployer = IRMRKDeployer(deployer);\\n        _registry = IRMRKRegistry(registry);\\n        _assetPinningPrice = assetPinningPrice;\\n        _minimumMintingFee = minimumMintingFee;\\n        _mintingFeePercentageBPS = mintingFeePercentageBPS;\\n\\n        _defaultCollectionConfig = IRMRKRegistry.CollectionConfig(\\n            true,\\n            false,\\n            true,\\n            true,\\n            false,\\n            true,\\n            false,\\n            false,\\n            false,\\n            0,\\n            CUSTOM_MINTING_TYPE_FROM_MINTAUR,\\n            0x0\\n        );\\n    }\\n\\n    // -------------- GETTERS --------------\\n\\n    /**\\n     * @notice Returns the address of the platform beneficiary.\\n     * @return beneficiary The address of the platform beneficiary\\n     */\\n    function getBeneficiary() public view returns (address) {\\n        return _platformBeneficiary;\\n    }\\n\\n    /**\\n     * @notice Returns the address of the deployer contract.\\n     * @return deployer The address of the deployer contract\\n     */\\n    function getDeployer() public view returns (address) {\\n        return address(_deployer);\\n    }\\n\\n    /**\\n     * @notice Returns the address of the registry contract.\\n     * @return registry The address of the registry contract\\n     */\\n    function getRegistry() public view returns (address) {\\n        return address(_registry);\\n    }\\n\\n    /**\\n     * @notice Returns the address of the mintaur registry contract.\\n     * @return mintaurRegistry The address of the mintaur registry contract\\n     */\\n    function getMintaurRegistry() public view returns (address) {\\n        return address(_mintaurRegistry);\\n    }\\n\\n    /**\\n     * @notice Returns the individual pinning price per asset.\\n     * @return assetPinningPrice The individual pinning price per asset\\n     */\\n    function getAssetPinningPrice() public view returns (uint256) {\\n        return _assetPinningPrice;\\n    }\\n\\n    /**\\n     * @notice Returns the minimum fee per minted token.\\n     * @return minimumMintingFee The minimum fee per minted token\\n     */\\n    function getMinimumMintingFee() public view returns (uint256) {\\n        return _minimumMintingFee;\\n    }\\n\\n    /**\\n     * @notice Returns the minting fee percentage in basis points.\\n     * @return mintingFeePercentageBPS The minting fee percentage in basis points\\n     */\\n    function getMintingFeePercentageBPS() public view returns (uint256) {\\n        return _mintingFeePercentageBPS;\\n    }\\n\\n    // -------------- ADMIN SETTERS --------------\\n\\n    /**\\n     * @notice Sets the address of the beneficiary.\\n     * @param beneficiary The address of the beneficiary\\n     */\\n    function setBeneficiary(address beneficiary) public onlyOwner {\\n        _platformBeneficiary = beneficiary;\\n    }\\n\\n    /**\\n     * @notice Sets the address of the deployer contract.\\n     * @param deployer The address of the deployer contract\\n     */\\n    function setDeployer(address deployer) public onlyOwnerOrContributor {\\n        _deployer = IRMRKDeployer(deployer);\\n    }\\n\\n    /**\\n     * @notice Sets the address of the registry contract.\\n     * @param registry The address of the registry contract\\n     */\\n    function setRegistry(address registry) public onlyOwnerOrContributor {\\n        _registry = IRMRKRegistry(registry);\\n    }\\n\\n    /**\\n     * @notice Sets the address of the mintaur registry contract.\\n     * @param mintaurRegistry The address of the mintaur registry contract\\n     */\\n    function setMintaurRegistry(\\n        address mintaurRegistry\\n    ) public onlyOwnerOrContributor {\\n        _mintaurRegistry = IRMRKMintaurRegistry(mintaurRegistry);\\n    }\\n\\n    /**\\n     * @notice Sets the individual pinning price per asset.\\n     * @param assetPinningPrice The individual pinning price per asset\\n     */\\n    function setAssetPinningPrice(\\n        uint256 assetPinningPrice\\n    ) public onlyOwnerOrContributor {\\n        _assetPinningPrice = assetPinningPrice;\\n    }\\n\\n    /**\\n     * @notice Sets the minimum fee per minted token\\n     * @param minimumMintingFee The minimum fee per minted token\\n     */\\n    function setMinimumMintingFee(\\n        uint256 minimumMintingFee\\n    ) public onlyOwnerOrContributor {\\n        _minimumMintingFee = minimumMintingFee;\\n    }\\n\\n    /**\\n     * @notice Sets the minting fee percentage in basis points.\\n     * @param mintingFeePercentageBPS The minting fee percentage in basis points\\n     */\\n    function setMintingFeePercentageBPS(\\n        uint256 mintingFeePercentageBPS\\n    ) public onlyOwnerOrContributor {\\n        _mintingFeePercentageBPS = mintingFeePercentageBPS;\\n    }\\n\\n    // -------------- Deploying --------------\\n\\n    /**\\n     * @notice Deploys a new collection.\\n     * @param name Name of the token collection\\n     * @param symbol Symbol of the token collection\\n     * @param collectionMetadata CID of the collection metadata\\n     * @param maxSupply The maximum supply of tokens\\n     * @param royaltyRecipient Recipient of resale royalties\\n     * @param royaltyPercentageBps The percentage to be paid from the sale of the token expressed in basis points\\n     * @param initialAssetsMetadata Array with metadata of the initial assets which will be added into every minte\\n     */\\n    function deployCollection(\\n        string memory name,\\n        string memory symbol,\\n        string memory collectionMetadata,\\n        uint256 maxSupply,\\n        uint256 mintPrice,\\n        address beneficiary,\\n        address royaltyRecipient,\\n        uint16 royaltyPercentageBps,\\n        uint256 cutOffDate,\\n        string[] memory initialAssetsMetadata\\n    ) external payable {\\n        if (mintPrice < _minimumMintingFee) revert FeeTooLow();\\n        if (cutOffDate < block.timestamp) revert InvalidCutOffDate();\\n        _chargeAssetPinning(initialAssetsMetadata.length);\\n\\n        address newCollection = _deployer.deployCollection(\\n            name,\\n            symbol,\\n            collectionMetadata,\\n            maxSupply,\\n            msg.sender,\\n            royaltyRecipient,\\n            royaltyPercentageBps,\\n            initialAssetsMetadata\\n        );\\n        _addCollectionToRegistry(newCollection, collectionMetadata, maxSupply);\\n        _mintaurRegistry.storeNewCollection(\\n            newCollection,\\n            mintPrice,\\n            getMintFeeEstimate(mintPrice),\\n            beneficiary,\\n            cutOffDate\\n        );\\n\\n        emit CollectionDeployed(\\n            newCollection,\\n            msg.sender,\\n            maxSupply,\\n            mintPrice,\\n            cutOffDate,\\n            collectionMetadata\\n        );\\n    }\\n\\n    function mint(\\n        address collection,\\n        address to,\\n        uint256 numToMint\\n    ) external payable {\\n        // Extra checks (e.g. allow lists) in the future can be added here\\n        _mintaurRegistry.mint{value: msg.value}(\\n            collection,\\n            to,\\n            numToMint\\n        );\\n    }\\n\\n    function getMintFeeEstimate(\\n        uint256 mintPrice\\n    ) public view returns (uint256) {\\n        uint256 fee = (mintPrice * _mintingFeePercentageBPS) / 10000;\\n        if (fee < _minimumMintingFee) fee = _minimumMintingFee;\\n        return fee;\\n    }\\n\\n    function _addCollectionToRegistry(\\n        address collection,\\n        string memory collectionMetadata,\\n        uint256 maxSupply\\n    ) private {\\n        _registry.addCollection(\\n            collection,\\n            _msgSender(),\\n            maxSupply,\\n            IRMRKRegistry.LegoCombination.Equippable,\\n            IRMRKRegistry.MintingType.Custom,\\n            false,\\n            _defaultCollectionConfig,\\n            collectionMetadata\\n        );\\n    }\\n\\n    function _chargeAssetPinning(uint256 numAssets) private {\\n        uint256 price = _assetPinningPrice * numAssets;\\n        if (msg.value != price) revert WrongValueSent();\\n\\n        (bool sent, ) = _platformBeneficiary.call{\\n            value: msg.value\\n        }(\\\"\\\");\\n        if (!sent) revert FailedToSend();\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"london\",\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"deployer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"registry\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"assetPinningPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minimumMintingFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mintingFeePercentageBPS\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"FailedToSend\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FeeTooLow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidCutOffDate\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RMRKNewContributorIsZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RMRKNewOwnerIsZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RMRKNotOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RMRKNotOwnerOrContributor\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WrongValueSent\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"deployer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxSupply\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mintPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cutOffDate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"collectionMetadata\",\"type\":\"string\"}],\"name\":\"CollectionDeployed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"contributor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isContributor\",\"type\":\"bool\"}],\"name\":\"ContributorUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"collectionMetadata\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"maxSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mintPrice\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"royaltyRecipient\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"royaltyPercentageBps\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"cutOffDate\",\"type\":\"uint256\"},{\"internalType\":\"string[]\",\"name\":\"initialAssetsMetadata\",\"type\":\"string[]\"}],\"name\":\"deployCollection\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAssetPinningPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBeneficiary\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDeployer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMinimumMintingFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"mintPrice\",\"type\":\"uint256\"}],\"name\":\"getMintFeeEstimate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMintaurRegistry\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMintingFeePercentageBPS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRegistry\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contributor\",\"type\":\"address\"}],\"name\":\"isContributor\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contributor\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"grantRole\",\"type\":\"bool\"}],\"name\":\"manageContributor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"numToMint\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"assetPinningPrice\",\"type\":\"uint256\"}],\"name\":\"setAssetPinningPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"}],\"name\":\"setBeneficiary\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"deployer\",\"type\":\"address\"}],\"name\":\"setDeployer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"minimumMintingFee\",\"type\":\"uint256\"}],\"name\":\"setMinimumMintingFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"mintaurRegistry\",\"type\":\"address\"}],\"name\":\"setMintaurRegistry\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"mintingFeePercentageBPS\",\"type\":\"uint256\"}],\"name\":\"setMintingFeePercentageBPS\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"registry\",\"type\":\"address\"}],\"name\":\"setRegistry\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "RMRKMintaur", "CompilerVersion": "v0.8.21+commit.d9974bed", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000ca03d97879031ab5edf81921ef5ad3383b3cc7600000000000000000000000003222bb296b583c52313e66816c0ddf5f98bbd563000000000000000000000000a9c01de4f9c1e550e869e550d3b08498ba1d38f3000000000000000000000000000000000000000000000000002386f26fc1000000000000000000000000000000000000000000000000000000038d7ea4c68000000000000000000000000000000000000000000000000000000000000000012c", "EVMVersion": "london", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}