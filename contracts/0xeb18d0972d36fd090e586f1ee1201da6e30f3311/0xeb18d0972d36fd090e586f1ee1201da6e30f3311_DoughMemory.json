{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/registry/index.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.7.0;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\n/**\\r\\n * @title DoughIndex\\r\\n * @dev Main Contract For DeFi Smart Accounts. This is also a factory contract, Which deploys new Smart Account.\\r\\n * Also Registry for DeFi Smart Accounts.\\r\\n */\\r\\n\\r\\ninterface AccountInterface {\\r\\n    function version() external view returns (uint);\\r\\n    function enable(address authority) external;\\r\\n    function cast(address[] calldata _targets, bytes[] calldata _datas, address _origin) external payable returns (bytes32[] memory responses);\\r\\n}\\r\\n\\r\\ninterface ListInterface {\\r\\n    function init(address _account) external;\\r\\n}\\r\\n\\r\\ncontract AddressIndex {\\r\\n\\r\\n    event LogNewMaster(address indexed master);\\r\\n    event LogUpdateMaster(address indexed master);\\r\\n    event LogNewCheck(uint indexed accountVersion, address indexed check);\\r\\n    event LogNewAccount(address indexed _newAccount, address indexed _connectors, address indexed _check);\\r\\n\\r\\n    // New Master Address.\\r\\n    address private newMaster;\\r\\n    // Master Address.\\r\\n    address public master;\\r\\n    // List Registry Address.\\r\\n    address public list;\\r\\n\\r\\n    // Connectors Modules(Account Module Version => Connectors Registry Module Address).\\r\\n    mapping (uint => address) public connectors;\\r\\n    // Check Modules(Account Module Version => Check Module Address).\\r\\n    mapping (uint => address) public check;\\r\\n    // Account Modules(Account Module Version => Account Module Address).\\r\\n    mapping (uint => address) public account;\\r\\n    // Version Count of Account Modules.\\r\\n    uint public versionCount;\\r\\n\\r\\n    /**\\r\\n    * @dev Throws if the sender not is Master Address.\\r\\n    */\\r\\n    modifier isMaster() {\\r\\n        require(msg.sender == master, \\\"not-master\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Change the Master Address.\\r\\n     * @param _newMaster New Master Address.\\r\\n     */\\r\\n    function changeMaster(address _newMaster) external isMaster {\\r\\n        require(_newMaster != master, \\\"already-a-master\\\");\\r\\n        require(_newMaster != address(0), \\\"not-valid-address\\\");\\r\\n        require(newMaster != _newMaster, \\\"already-a-new-master\\\");\\r\\n        newMaster = _newMaster;\\r\\n        emit LogNewMaster(_newMaster);\\r\\n    }\\r\\n\\r\\n    function updateMaster() external {\\r\\n        require(newMaster != address(0), \\\"not-valid-address\\\");\\r\\n        require(msg.sender == newMaster, \\\"not-master\\\");\\r\\n        master = newMaster;\\r\\n        newMaster = address(0);\\r\\n        emit LogUpdateMaster(master);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Change the Check Address of a specific Account Module version.\\r\\n     * @param accountVersion Account Module version.\\r\\n     * @param _newCheck The New Check Address.\\r\\n     */\\r\\n    function changeCheck(uint accountVersion, address _newCheck) external isMaster {\\r\\n        require(_newCheck != check[accountVersion], \\\"already-a-check\\\");\\r\\n        check[accountVersion] = _newCheck;\\r\\n        emit LogNewCheck(accountVersion, _newCheck);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Add New Account Module.\\r\\n     * @param _newAccount The New Account Module Address.\\r\\n     * @param _connectors Connectors Registry Module Address.\\r\\n     * @param _check Check Module Address.\\r\\n     */\\r\\n    function addNewAccount(address _newAccount, address _connectors, address _check) external isMaster {\\r\\n        require(_newAccount != address(0), \\\"not-valid-address\\\");\\r\\n        versionCount++;\\r\\n        require(AccountInterface(_newAccount).version() == versionCount, \\\"not-valid-version\\\");\\r\\n        account[versionCount] = _newAccount;\\r\\n        if (_connectors != address(0)) connectors[versionCount] = _connectors;\\r\\n        if (_check != address(0)) check[versionCount] = _check;\\r\\n        emit LogNewAccount(_newAccount, _connectors, _check);\\r\\n    }\\r\\n\\r\\n}\\r\\n\\r\\ncontract CloneFactory is AddressIndex {\\r\\n    /**\\r\\n     * @dev Clone a new Account Module.\\r\\n     * @param version Account Module version to clone.\\r\\n     */\\r\\n    function createClone(uint version) internal returns (address result) {\\r\\n        bytes20 targetBytes = bytes20(account[version]);\\r\\n        // solium-disable-next-line security/no-inline-assembly\\r\\n        assembly {\\r\\n            let clone := mload(0x40)\\r\\n            mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\r\\n            mstore(add(clone, 0x14), targetBytes)\\r\\n            mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\\r\\n            result := create(0, clone, 0x37)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Check if Account Module is a clone.\\r\\n     * @param version Account Module version.\\r\\n     * @param query Account Module Address.\\r\\n     */\\r\\n    function isClone(uint version, address query) external view returns (bool result) {\\r\\n        bytes20 targetBytes = bytes20(account[version]);\\r\\n        // solium-disable-next-line security/no-inline-assembly\\r\\n        assembly {\\r\\n            let clone := mload(0x40)\\r\\n            mstore(clone, 0x363d3d373d3d3d363d7300000000000000000000000000000000000000000000)\\r\\n            mstore(add(clone, 0xa), targetBytes)\\r\\n            mstore(add(clone, 0x1e), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\\r\\n\\r\\n            let other := add(clone, 0x40)\\r\\n            extcodecopy(query, other, 0, 0x2d)\\r\\n            result := and(\\r\\n                eq(mload(clone), mload(other)),\\r\\n                eq(mload(add(clone, 0xd)), mload(add(other, 0xd)))\\r\\n            )\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract DoughIndex is CloneFactory {\\r\\n\\r\\n    event LogAccountCreated(address sender, address indexed owner, address indexed account, address indexed origin);\\r\\n\\r\\n    /**\\r\\n     * @dev Create a new DeFi Smart Account for a user and run cast function in the new Smart Account.\\r\\n     * @param _owner Owner of the Smart Account.\\r\\n     * @param accountVersion Account Module version.\\r\\n     * @param _targets Array of Target to run cast function.\\r\\n     * @param _datas Array of Data(callData) to run cast function.\\r\\n     * @param _origin Where Smart Account is created.\\r\\n     */\\r\\n    function buildWithCast(\\r\\n        address _owner,\\r\\n        uint accountVersion,\\r\\n        address[] calldata _targets,\\r\\n        bytes[] calldata _datas,\\r\\n        address _origin\\r\\n    ) external payable returns (address _account) {\\r\\n        _account = build(_owner, accountVersion, _origin);\\r\\n        if (_targets.length > 0) AccountInterface(_account).cast{value: msg.value}(_targets, _datas, _origin);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Create a new DeFi Smart Account for a user.\\r\\n     * @param _owner Owner of the Smart Account.\\r\\n     * @param accountVersion Account Module version.\\r\\n     * @param _origin Where Smart Account is created.\\r\\n     */\\r\\n    function build(\\r\\n        address _owner,\\r\\n        uint accountVersion,\\r\\n        address _origin\\r\\n    ) public returns (address _account) {\\r\\n        require(accountVersion != 0 && accountVersion <= versionCount, \\\"not-valid-account\\\");\\r\\n        _account = createClone(accountVersion);\\r\\n        ListInterface(list).init(_account);\\r\\n        AccountInterface(_account).enable(_owner);\\r\\n        emit LogAccountCreated(msg.sender, _owner, _account, _origin);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Setup Initial things for DoughIndex, after its been deployed and can be only run once.\\r\\n     * @param _master The Master Address.\\r\\n     * @param _list The List Address.\\r\\n     * @param _account The Account Module Address.\\r\\n     * @param _connectors The Connectors Registry Module Address.\\r\\n     */\\r\\n    function setBasics(\\r\\n        address _master,\\r\\n        address _list,\\r\\n        address _account,\\r\\n        address _connectors\\r\\n    ) external {\\r\\n        require(\\r\\n            master == address(0) &&\\r\\n            list == address(0) &&\\r\\n            account[1] == address(0) &&\\r\\n            connectors[1] == address(0) &&\\r\\n            versionCount == 0,\\r\\n            \\\"already-defined\\\"\\r\\n        );\\r\\n        master = _master;\\r\\n        list = _list;\\r\\n        versionCount++;\\r\\n        account[versionCount] = _account;\\r\\n        connectors[versionCount] = _connectors;\\r\\n    }\\r\\n\\r\\n}\"\r\n    },\r\n    \"contracts/registry/list.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\n/**\\r\\n * @title DoughList\\r\\n * @dev Registry For DeFi Smart Account Authorised user.\\r\\n */\\r\\n\\r\\ninterface AccountInterface {\\r\\n    function isAuth(address _user) external view returns (bool);\\r\\n}\\r\\n\\r\\n\\r\\ncontract DSMath {\\r\\n\\r\\n    function add(uint64 x, uint64 y) internal pure returns (uint64 z) {\\r\\n        require((z = x + y) >= x, \\\"ds-math-add-overflow\\\");\\r\\n    }\\r\\n\\r\\n    function sub(uint64 x, uint64 y) internal pure returns (uint64 z) {\\r\\n        require((z = x - y) <= x, \\\"ds-math-sub-underflow\\\");\\r\\n    }\\r\\n\\r\\n}\\r\\n\\r\\n\\r\\ncontract Variables is DSMath {\\r\\n\\r\\n    // DoughIndex Address.\\r\\n    address public immutable doughIndex;\\r\\n\\r\\n    constructor (address _doughIndex) {\\r\\n        doughIndex = _doughIndex;\\r\\n    }\\r\\n\\r\\n    // Smart Account Count.\\r\\n    uint64 public accounts;\\r\\n    // Smart Account ID (Smart Account Address => Account ID).\\r\\n    mapping (address => uint64) public accountID;\\r\\n    // Smart Account Address (Smart Account ID => Smart Account Address).\\r\\n    mapping (uint64 => address) public accountAddr;\\r\\n\\r\\n    // User Link (User Address => UserLink(Account ID of First and Last And Count of Smart Accounts)).\\r\\n    mapping (address => UserLink) public userLink;\\r\\n    // Linked List of Users (User Address => Smart Account ID => UserList(Previous and next Account ID)).\\r\\n    mapping (address => mapping(uint64 => UserList)) public userList;\\r\\n\\r\\n    struct UserLink {\\r\\n        uint64 first;\\r\\n        uint64 last;\\r\\n        uint64 count;\\r\\n    }\\r\\n    struct UserList {\\r\\n        uint64 prev;\\r\\n        uint64 next;\\r\\n    }\\r\\n\\r\\n    // Account Link (Smart Account ID => AccountLink).\\r\\n    mapping (uint64 => AccountLink) public accountLink; // account => account linked list connection\\r\\n    // Linked List of Accounts (Smart Account ID => Account Address => AccountList).\\r\\n    mapping (uint64 => mapping (address => AccountList)) public accountList; // account => user address => list\\r\\n\\r\\n    struct AccountLink {\\r\\n        address first;\\r\\n        address last;\\r\\n        uint64 count;\\r\\n    }\\r\\n    struct AccountList {\\r\\n        address prev;\\r\\n        address next;\\r\\n    }\\r\\n\\r\\n}\\r\\n\\r\\ncontract Configure is Variables {\\r\\n\\r\\n    constructor (address _doughIndex) Variables(_doughIndex) {\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Add Account to User Linked List.\\r\\n     * @param _owner Account Owner.\\r\\n     * @param _account Smart Account Address.\\r\\n    */\\r\\n    function addAccount(address _owner, uint64 _account) internal {\\r\\n        if (userLink[_owner].last != 0) {\\r\\n            userList[_owner][_account].prev = userLink[_owner].last;\\r\\n            userList[_owner][userLink[_owner].last].next = _account;\\r\\n        }\\r\\n        if (userLink[_owner].first == 0) userLink[_owner].first = _account;\\r\\n        userLink[_owner].last = _account;\\r\\n        userLink[_owner].count = add(userLink[_owner].count, 1);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Remove Account from User Linked List.\\r\\n     * @param _owner Account Owner/User.\\r\\n     * @param _account Smart Account Address.\\r\\n    */\\r\\n    function removeAccount(address _owner, uint64 _account) internal {\\r\\n        uint64 _prev = userList[_owner][_account].prev;\\r\\n        uint64 _next = userList[_owner][_account].next;\\r\\n        if (_prev != 0) userList[_owner][_prev].next = _next;\\r\\n        if (_next != 0) userList[_owner][_next].prev = _prev;\\r\\n        if (_prev == 0) userLink[_owner].first = _next;\\r\\n        if (_next == 0) userLink[_owner].last = _prev;\\r\\n        userLink[_owner].count = sub(userLink[_owner].count, 1);\\r\\n        delete userList[_owner][_account];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Add Owner to Account Linked List.\\r\\n     * @param _owner Account Owner.\\r\\n     * @param _account Smart Account Address.\\r\\n    */\\r\\n    function addUser(address _owner, uint64 _account) internal {\\r\\n        if (accountLink[_account].last != address(0)) {\\r\\n            accountList[_account][_owner].prev = accountLink[_account].last;\\r\\n            accountList[_account][accountLink[_account].last].next = _owner;\\r\\n        }\\r\\n        if (accountLink[_account].first == address(0)) accountLink[_account].first = _owner;\\r\\n        accountLink[_account].last = _owner;\\r\\n        accountLink[_account].count = add(accountLink[_account].count, 1);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Remove Owner from Account Linked List.\\r\\n     * @param _owner Account Owner.\\r\\n     * @param _account Smart Account Address.\\r\\n    */\\r\\n    function removeUser(address _owner, uint64 _account) internal {\\r\\n        address _prev = accountList[_account][_owner].prev;\\r\\n        address _next = accountList[_account][_owner].next;\\r\\n        if (_prev != address(0)) accountList[_account][_prev].next = _next;\\r\\n        if (_next != address(0)) accountList[_account][_next].prev = _prev;\\r\\n        if (_prev == address(0)) accountLink[_account].first = _next;\\r\\n        if (_next == address(0)) accountLink[_account].last = _prev;\\r\\n        accountLink[_account].count = sub(accountLink[_account].count, 1);\\r\\n        delete accountList[_account][_owner];\\r\\n    }\\r\\n\\r\\n}\\r\\n\\r\\ncontract DoughList is Configure {\\r\\n    constructor (address _doughIndex) public Configure(_doughIndex) {}\\r\\n\\r\\n\\r\\n    /**\\r\\n     * @dev Enable Auth for Smart Account.\\r\\n     * @param _owner Owner Address.\\r\\n    */\\r\\n    function addAuth(address _owner) external {\\r\\n        require(accountID[msg.sender] != 0, \\\"not-account\\\");\\r\\n        require(AccountInterface(msg.sender).isAuth(_owner), \\\"not-owner\\\");\\r\\n        addAccount(_owner, accountID[msg.sender]);\\r\\n        addUser(_owner, accountID[msg.sender]);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Disable Auth for Smart Account.\\r\\n     * @param _owner Owner Address.\\r\\n    */\\r\\n    function removeAuth(address _owner) external {\\r\\n        require(accountID[msg.sender] != 0, \\\"not-account\\\");\\r\\n        require(!AccountInterface(msg.sender).isAuth(_owner), \\\"already-owner\\\");\\r\\n        removeAccount(_owner, accountID[msg.sender]);\\r\\n        removeUser(_owner, accountID[msg.sender]);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Setup Initial configuration of Smart Account.\\r\\n     * @param _account Smart Account Address.\\r\\n    */\\r\\n    function init(address  _account) external {\\r\\n        require(msg.sender == doughIndex, \\\"not-index\\\");\\r\\n        accounts++;\\r\\n        accountID[_account] = accounts;\\r\\n        accountAddr[accounts] = _account;\\r\\n    }\\r\\n\\r\\n}\"\r\n    },\r\n    \"contracts/v1/account.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.7.0;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\n/**\\r\\n * @title DoughAccount.\\r\\n * @dev DeFi Smart Account Wallet.\\r\\n */\\r\\n\\r\\ninterface IndexInterface {\\r\\n    function connectors(uint version) external view returns (address);\\r\\n    function check(uint version) external view returns (address);\\r\\n    function list() external view returns (address);\\r\\n}\\r\\n\\r\\ninterface ConnectorsInterface {\\r\\n    function isConnector(address[] calldata logicAddr) external view returns (bool);\\r\\n    function isStaticConnector(address[] calldata logicAddr) external view returns (bool);\\r\\n}\\r\\n\\r\\ninterface CheckInterface {\\r\\n    function isOk() external view returns (bool);\\r\\n}\\r\\n\\r\\ninterface ListInterface {\\r\\n    function addAuth(address user) external;\\r\\n    function removeAuth(address user) external;\\r\\n}\\r\\n\\r\\n\\r\\ncontract Record {\\r\\n\\r\\n    event LogEnable(address indexed user);\\r\\n    event LogDisable(address indexed user);\\r\\n    event LogSwitchShield(bool _shield);\\r\\n\\r\\n    // DoughIndex Address.\\r\\n    address public immutable doughIndex;\\r\\n    // The Account Module Version.\\r\\n    uint public constant version = 1;\\r\\n    // Auth Module(Address of Auth => bool).\\r\\n    mapping (address => bool) private auth;\\r\\n    // Is shield true/false.\\r\\n    bool public shield;\\r\\n\\r\\n    constructor (address _doughIndex) {\\r\\n        doughIndex = _doughIndex;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Check for Auth if enabled.\\r\\n     * @param user address/user/owner.\\r\\n     */\\r\\n    function isAuth(address user) public view returns (bool) {\\r\\n        return auth[user];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Change Shield State.\\r\\n    */\\r\\n    function switchShield(bool _shield) external {\\r\\n        require(auth[msg.sender], \\\"not-self\\\");\\r\\n        require(shield != _shield, \\\"shield is set\\\");\\r\\n        shield = _shield;\\r\\n        emit LogSwitchShield(shield);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Enable New User.\\r\\n     * @param user Owner of the Smart Account.\\r\\n    */\\r\\n    function enable(address user) public {\\r\\n        require(msg.sender == address(this) || msg.sender == doughIndex, \\\"not-self-index\\\");\\r\\n        require(user != address(0), \\\"not-valid\\\");\\r\\n        require(!auth[user], \\\"already-enabled\\\");\\r\\n        auth[user] = true;\\r\\n        ListInterface(IndexInterface(doughIndex).list()).addAuth(user);\\r\\n        emit LogEnable(user);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Disable User.\\r\\n     * @param user Owner of the Smart Account.\\r\\n    */\\r\\n    function disable(address user) public {\\r\\n        require(msg.sender == address(this), \\\"not-self\\\");\\r\\n        require(user != address(0), \\\"not-valid\\\");\\r\\n        require(auth[user], \\\"already-disabled\\\");\\r\\n        delete auth[user];\\r\\n        ListInterface(IndexInterface(doughIndex).list()).removeAuth(user);\\r\\n        emit LogDisable(user);\\r\\n    }\\r\\n\\r\\n}\\r\\n\\r\\ncontract DoughAccount is Record {\\r\\n\\r\\n    constructor (address _doughIndex) public Record(_doughIndex) {\\r\\n    }\\r\\n\\r\\n    event LogCast(address indexed origin, address indexed sender, uint value);\\r\\n\\r\\n    receive() external payable {}\\r\\n\\r\\n     /**\\r\\n     * @dev Delegate the calls to Connector And this function is ran by cast().\\r\\n     * @param _target Target to of Connector.\\r\\n     * @param _data CallData of function in Connector.\\r\\n    */\\r\\n    function spell(address _target, bytes memory _data) internal {\\r\\n        require(_target != address(0), \\\"target-invalid\\\");\\r\\n        assembly {\\r\\n            let succeeded := delegatecall(gas(), _target, add(_data, 0x20), mload(_data), 0, 0)\\r\\n\\r\\n            switch iszero(succeeded)\\r\\n                case 1 {\\r\\n                    // throw if delegatecall failed\\r\\n                    let size := returndatasize()\\r\\n                    returndatacopy(0x00, 0x00, size)\\r\\n                    revert(0x00, size)\\r\\n                }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev This is the main function, Where all the different functions are called\\r\\n     * from Smart Account.\\r\\n     * @param _targets Array of Target(s) to of Connector.\\r\\n     * @param _datas Array of Calldata(S) of function.\\r\\n    */\\r\\n    function cast(\\r\\n        address[] calldata _targets,\\r\\n        bytes[] calldata _datas,\\r\\n        address _origin\\r\\n    )\\r\\n    external\\r\\n    payable\\r\\n    {\\r\\n        require(isAuth(msg.sender) || msg.sender == doughIndex, \\\"permission-denied\\\");\\r\\n        require(_targets.length == _datas.length , \\\"array-length-invalid\\\");\\r\\n        IndexInterface indexContract = IndexInterface(doughIndex);\\r\\n        bool isShield = shield;\\r\\n        if (!isShield) {\\r\\n            require(ConnectorsInterface(indexContract.connectors(version)).isConnector(_targets), \\\"not-connector\\\");\\r\\n        } else {\\r\\n            require(ConnectorsInterface(indexContract.connectors(version)).isStaticConnector(_targets), \\\"not-static-connector\\\");\\r\\n        }\\r\\n        for (uint i = 0; i < _targets.length; i++) {\\r\\n            spell(_targets[i], _datas[i]);\\r\\n        }\\r\\n        address _check = indexContract.check(version);\\r\\n        if (_check != address(0) && !isShield) require(CheckInterface(_check).isOk(), \\\"not-ok\\\");\\r\\n        emit LogCast(_origin, msg.sender, msg.value);\\r\\n    }\\r\\n\\r\\n}\"\r\n    },\r\n    \"contracts/v1/connectors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\n/**\\r\\n * @title DoughConnectors\\r\\n * @dev Registry for Connectors.\\r\\n */\\r\\n\\r\\n\\r\\ninterface IndexInterface {\\r\\n    function master() external view returns (address);\\r\\n}\\r\\n\\r\\ninterface ConnectorInterface {\\r\\n    function connectorID() external view returns(uint _type, uint _id);\\r\\n    function name() external view returns (string memory);\\r\\n}\\r\\n\\r\\n\\r\\ncontract DSMath {\\r\\n\\r\\n    function add(uint x, uint y) internal pure returns (uint z) {\\r\\n        require((z = x + y) >= x, \\\"ds-math-add-overflow\\\");\\r\\n    }\\r\\n\\r\\n    function sub(uint x, uint y) internal pure returns (uint z) {\\r\\n        require((z = x - y) <= x, \\\"ds-math-sub-underflow\\\");\\r\\n    }\\r\\n\\r\\n}\\r\\n\\r\\ncontract Controllers is DSMath {\\r\\n\\r\\n    event LogAddController(address indexed addr);\\r\\n    event LogRemoveController(address indexed addr);\\r\\n\\r\\n    // DoughIndex Address.\\r\\n    address public immutable doughIndex;\\r\\n\\r\\n    constructor (address _doughIndex) {\\r\\n        doughIndex = _doughIndex;\\r\\n    }\\r\\n\\r\\n    // Enabled Chief(Address of Chief => bool).\\r\\n    mapping(address => bool) public chief;\\r\\n    // Enabled Connectors(Connector Address => bool).\\r\\n    mapping(address => bool) public connectors;\\r\\n    // Enabled Static Connectors(Connector Address => bool).\\r\\n    mapping(address => bool) public staticConnectors;\\r\\n\\r\\n    /**\\r\\n    * @dev Throws if the sender not is Master Address from DoughIndex\\r\\n    * or Enabled Chief.\\r\\n    */\\r\\n    modifier isChief {\\r\\n        require(chief[msg.sender] || msg.sender == IndexInterface(doughIndex).master(), \\\"not-an-chief\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Enable a Chief.\\r\\n     * @param _userAddress Chief Address.\\r\\n    */\\r\\n    function enableChief(address _userAddress) external isChief {\\r\\n        chief[_userAddress] = true;\\r\\n        emit LogAddController(_userAddress);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Disables a Chief.\\r\\n     * @param _userAddress Chief Address.\\r\\n    */\\r\\n    function disableChief(address _userAddress) external isChief {\\r\\n        delete chief[_userAddress];\\r\\n        emit LogRemoveController(_userAddress);\\r\\n    }\\r\\n\\r\\n}\\r\\n\\r\\n\\r\\ncontract Listings is Controllers {\\r\\n\\r\\n    constructor (address _doughIndex) Controllers(_doughIndex) {\\r\\n    }\\r\\n\\r\\n    // Connectors Array.\\r\\n    address[] public connectorArray;\\r\\n    // Count of Connector's Enabled.\\r\\n    uint public connectorCount;\\r\\n\\r\\n    /**\\r\\n     * @dev Add Connector to Connector's array.\\r\\n     * @param _connector Connector Address.\\r\\n    **/\\r\\n    function addToArr(address _connector) internal {\\r\\n        require(_connector != address(0), \\\"Not-valid-connector\\\");\\r\\n        (, uint _id) = ConnectorInterface(_connector).connectorID();\\r\\n        require(_id == (connectorArray.length+1),\\\"ConnectorID-doesnt-match\\\");\\r\\n        ConnectorInterface(_connector).name(); // Checking if connector has function name()\\r\\n        connectorArray.push(_connector);\\r\\n    }\\r\\n\\r\\n    // Static Connectors Array.\\r\\n    address[] public staticConnectorArray;\\r\\n\\r\\n    /**\\r\\n     * @dev Add Connector to Static Connector's array.\\r\\n     * @param _connector Static Connector Address.\\r\\n    **/\\r\\n    function addToArrStatic(address _connector) internal {\\r\\n        require(_connector != address(0), \\\"Not-valid-connector\\\");\\r\\n        (, uint _id) = ConnectorInterface(_connector).connectorID();\\r\\n        require(_id == (staticConnectorArray.length+1),\\\"ConnectorID-doesnt-match\\\");\\r\\n        ConnectorInterface(_connector).name(); // Checking if connector has function name()\\r\\n        staticConnectorArray.push(_connector);\\r\\n    }\\r\\n\\r\\n}\\r\\n\\r\\n\\r\\ncontract DoughConnectors is Listings {\\r\\n\\r\\n    constructor (address _doughIndex) public Listings(_doughIndex) {\\r\\n    }\\r\\n\\r\\n    event LogEnable(address indexed connector);\\r\\n    event LogDisable(address indexed connector);\\r\\n    event LogEnableStatic(address indexed connector);\\r\\n\\r\\n    /**\\r\\n     * @dev Enable Connector.\\r\\n     * @param _connector Connector Address.\\r\\n    */\\r\\n    function enable(address _connector) external isChief {\\r\\n        require(!connectors[_connector], \\\"already-enabled\\\");\\r\\n        addToArr(_connector);\\r\\n        connectors[_connector] = true;\\r\\n        connectorCount++;\\r\\n        emit LogEnable(_connector);\\r\\n    }\\r\\n    /**\\r\\n     * @dev Disable Connector.\\r\\n     * @param _connector Connector Address.\\r\\n    */\\r\\n    function disable(address _connector) external isChief {\\r\\n        require(connectors[_connector], \\\"already-disabled\\\");\\r\\n        delete connectors[_connector];\\r\\n        connectorCount--;\\r\\n        emit LogDisable(_connector);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Enable Static Connector.\\r\\n     * @param _connector Static Connector Address.\\r\\n    */\\r\\n    function enableStatic(address _connector) external isChief {\\r\\n        require(!staticConnectors[_connector], \\\"already-enabled\\\");\\r\\n        addToArrStatic(_connector);\\r\\n        staticConnectors[_connector] = true;\\r\\n        emit LogEnableStatic(_connector);\\r\\n    }\\r\\n\\r\\n     /**\\r\\n     * @dev Check if Connector addresses are enabled.\\r\\n     * @param _connectors Array of Connector Addresses.\\r\\n    */\\r\\n    function isConnector(address[] calldata _connectors) external view returns (bool isOk) {\\r\\n        isOk = true;\\r\\n        for (uint i = 0; i < _connectors.length; i++) {\\r\\n            if (!connectors[_connectors[i]]) {\\r\\n                isOk = false;\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Check if Connector addresses are static enabled.\\r\\n     * @param _connectors Array of Connector Addresses.\\r\\n    */\\r\\n    function isStaticConnector(address[] calldata _connectors) external view returns (bool isOk) {\\r\\n        isOk = true;\\r\\n        for (uint i = 0; i < _connectors.length; i++) {\\r\\n            if (!staticConnectors[_connectors[i]]) {\\r\\n                isOk = false;\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev get Connector's Array length.\\r\\n    */\\r\\n    function connectorLength() external view returns (uint) {\\r\\n        return connectorArray.length;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev get Static Connector's Array length.\\r\\n    */\\r\\n    function staticConnectorLength() external view returns (uint) {\\r\\n        return staticConnectorArray.length;\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/v1/connectors/auth.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\n/**\\r\\n * @title ConnectAuth.\\r\\n * @dev Connector For Adding Auth.\\r\\n */\\r\\n\\r\\ninterface AccountInterface {\\r\\n    function enable(address user) external;\\r\\n    function disable(address user) external;\\r\\n}\\r\\n\\r\\ninterface EventInterface {\\r\\n    function emitEvent(uint _connectorType, uint _connectorID, bytes32 _eventCode, bytes calldata _eventData) external;\\r\\n}\\r\\n\\r\\n\\r\\ncontract Basics {\\r\\n\\r\\n    /**\\r\\n     * @dev DoughEvent Address.\\r\\n     */\\r\\n    address public immutable doughEventAddress;\\r\\n    constructor (address _doughEventAddress) {\\r\\n        doughEventAddress = _doughEventAddress;\\r\\n    }\\r\\n\\r\\n     /**\\r\\n     * @dev Connector ID and Type.\\r\\n     */\\r\\n    function connectorID() public pure returns(uint _type, uint _id) {\\r\\n        (_type, _id) = (1, 1);\\r\\n    }\\r\\n\\r\\n}\\r\\n\\r\\n\\r\\ncontract Auth is Basics {\\r\\n\\r\\n    constructor (address _doughEventAddress) Basics(_doughEventAddress) {}\\r\\n\\r\\n    event LogAddAuth(address indexed _msgSender, address indexed _auth);\\r\\n    event LogRemoveAuth(address indexed _msgSender, address indexed _auth);\\r\\n\\r\\n    /**\\r\\n     * @dev Add New Owner\\r\\n     * @param user User Address.\\r\\n     */\\r\\n    function addModule(address user) public payable {\\r\\n        AccountInterface(address(this)).enable(user);\\r\\n\\r\\n        emit LogAddAuth(msg.sender, user);\\r\\n\\r\\n        bytes32 _eventCode = keccak256(\\\"LogAddAuth(address,address)\\\");\\r\\n        bytes memory _eventParam = abi.encode(msg.sender, user);\\r\\n        (uint _type, uint _id) = connectorID();\\r\\n        EventInterface(doughEventAddress).emitEvent(_type, _id, _eventCode, _eventParam);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Remove New Owner\\r\\n     * @param user User Address.\\r\\n     */\\r\\n    function removeModule(address user) public payable {\\r\\n        AccountInterface(address(this)).disable(user);\\r\\n\\r\\n        emit LogRemoveAuth(msg.sender, user);\\r\\n\\r\\n        bytes32 _eventCode = keccak256(\\\"LogRemoveAuth(address,address)\\\");\\r\\n        bytes memory _eventParam = abi.encode(msg.sender, user);\\r\\n        (uint _type, uint _id) = connectorID();\\r\\n        EventInterface(doughEventAddress).emitEvent(_type, _id, _eventCode, _eventParam);\\r\\n    }\\r\\n\\r\\n}\\r\\n\\r\\n\\r\\ncontract ConnectAuth is Auth {\\r\\n\\r\\n    constructor (address _doughEventAddress) public Auth(_doughEventAddress) {}\\r\\n    string constant public name = \\\"Auth-v1\\\";\\r\\n}\"\r\n    },\r\n    \"contracts/v1/connectors/basic.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\n/**\\r\\n * @title ConnectBasic.\\r\\n * @dev Connector to deposit/withdraw assets.\\r\\n */\\r\\n\\r\\ninterface ERC20Interface {\\r\\n    function allowance(address, address) external view returns (uint);\\r\\n    function balanceOf(address) external view returns (uint);\\r\\n    function approve(address, uint) external;\\r\\n    function transfer(address, uint) external returns (bool);\\r\\n    function transferFrom(address, address, uint) external returns (bool);\\r\\n}\\r\\n\\r\\ninterface AccountInterface {\\r\\n    function isAuth(address _user) external view returns (bool);\\r\\n}\\r\\n\\r\\ninterface MemoryInterface {\\r\\n    function getUint(uint _id) external returns (uint _num);\\r\\n    function setUint(uint _id, uint _val) external;\\r\\n}\\r\\n\\r\\ninterface EventInterface {\\r\\n    function emitEvent(uint _connectorType, uint _connectorID, bytes32 _eventCode, bytes calldata _eventData) external;\\r\\n}\\r\\n\\r\\ncontract Memory {\\r\\n\\r\\n     /**\\r\\n     * @dev DoughMemory Address.\\r\\n     */\\r\\n    address public immutable doughMemoryAddress;\\r\\n\\r\\n    constructor (address _doughMemoryAddress) {\\r\\n        doughMemoryAddress = _doughMemoryAddress;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Get Stored Uint Value From DoughMemory.\\r\\n     * @param getId Storage ID.\\r\\n     * @param val if any value.\\r\\n     */\\r\\n    function getUint(uint getId, uint val) internal returns (uint returnVal) {\\r\\n        returnVal = getId == 0 ? val : MemoryInterface(doughMemoryAddress).getUint(getId);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Store Uint Value In DoughMemory.\\r\\n     * @param setId Storage ID.\\r\\n     * @param val Value To store.\\r\\n     */\\r\\n    function setUint(uint setId, uint val) internal {\\r\\n        if (setId != 0) MemoryInterface(doughMemoryAddress).setUint(setId, val);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Connector ID and Type.\\r\\n     */\\r\\n    function connectorID() public pure returns(uint _type, uint _id) {\\r\\n        (_type, _id) = (1, 2);\\r\\n    }\\r\\n\\r\\n}\\r\\n\\r\\ncontract BasicResolver is Memory {\\r\\n\\r\\n    event LogDeposit(address indexed erc20, uint256 tokenAmt, uint256 getId, uint256 setId);\\r\\n    event LogWithdraw(address indexed erc20, uint256 tokenAmt, address indexed to, uint256 getId, uint256 setId);\\r\\n\\r\\n      /**\\r\\n     * @dev DoughEvent Address.\\r\\n     */\\r\\n    address public immutable doughEventAddress;\\r\\n    \\r\\n    constructor (address _doughEventAddress, address _doughMemoryAddress) Memory(_doughMemoryAddress) {\\r\\n        doughEventAddress = _doughEventAddress;\\r\\n    }\\r\\n    /**\\r\\n     * @dev ETH Address.\\r\\n     */\\r\\n    function getEthAddr() public pure returns (address) {\\r\\n        return 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Deposit Assets To Smart Account.\\r\\n     * @param erc20 Token Address.\\r\\n     * @param tokenAmt Token Amount.\\r\\n     * @param getId Get Storage ID.\\r\\n     * @param setId Set Storage ID.\\r\\n     */\\r\\n    function deposit(address erc20, uint tokenAmt, uint getId, uint setId) public payable {\\r\\n        uint amt = getUint(getId, tokenAmt);\\r\\n        if (erc20 != getEthAddr()) {\\r\\n            ERC20Interface token = ERC20Interface(erc20);\\r\\n            amt = amt == uint(-1) ? token.balanceOf(msg.sender) : amt;\\r\\n            token.transferFrom(msg.sender, address(this), amt);\\r\\n        } else {\\r\\n            require(msg.value == amt || amt == uint(-1), \\\"invalid-ether-amount\\\");\\r\\n            amt = msg.value;\\r\\n        }\\r\\n        setUint(setId, amt);\\r\\n\\r\\n        emit LogDeposit(erc20, amt, getId, setId);\\r\\n\\r\\n        bytes32 _eventCode = keccak256(\\\"LogDeposit(address,uint256,uint256,uint256)\\\");\\r\\n        bytes memory _eventParam = abi.encode(erc20, amt, getId, setId);\\r\\n        (uint _type, uint _id) = connectorID();\\r\\n        EventInterface(doughEventAddress).emitEvent(_type, _id, _eventCode, _eventParam);\\r\\n    }\\r\\n\\r\\n   /**\\r\\n     * @dev Withdraw Assets To Smart Account.\\r\\n     * @param erc20 Token Address.\\r\\n     * @param tokenAmt Token Amount.\\r\\n     * @param to Withdraw token address.\\r\\n     * @param getId Get Storage ID.\\r\\n     * @param setId Set Storage ID.\\r\\n     */\\r\\n    function withdraw(\\r\\n        address erc20,\\r\\n        uint tokenAmt,\\r\\n        address payable to,\\r\\n        uint getId,\\r\\n        uint setId\\r\\n    ) public payable {\\r\\n        require(AccountInterface(address(this)).isAuth(to), \\\"invalid-to-address\\\");\\r\\n        uint amt = getUint(getId, tokenAmt);\\r\\n        if (erc20 == getEthAddr()) {\\r\\n            amt = amt == uint(-1) ? address(this).balance : amt;\\r\\n            to.transfer(amt);\\r\\n        } else {\\r\\n            ERC20Interface token = ERC20Interface(erc20);\\r\\n            amt = amt == uint(-1) ? token.balanceOf(address(this)) : amt;\\r\\n            token.transfer(to, amt);\\r\\n        }\\r\\n        setUint(setId, amt);\\r\\n\\r\\n        emit LogWithdraw(erc20, amt, to, getId, setId);\\r\\n\\r\\n        bytes32 _eventCode = keccak256(\\\"LogWithdraw(address,uint256,address,uint256,uint256)\\\");\\r\\n        bytes memory _eventParam = abi.encode(erc20, amt, to, getId, setId);\\r\\n        (uint _type, uint _id) = connectorID();\\r\\n        EventInterface(doughEventAddress).emitEvent(_type, _id, _eventCode, _eventParam);\\r\\n    }\\r\\n\\r\\n}\\r\\n\\r\\n\\r\\ncontract ConnectBasic is BasicResolver {\\r\\n\\r\\n    constructor (address _doughEventAddress, address _doughMemoryAddress) public BasicResolver(_doughEventAddress, _doughMemoryAddress) {}\\r\\n    string public constant name = \\\"Basic-v1\\\";\\r\\n}\"\r\n    },\r\n    \"contracts/v1/event.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\ninterface ListInterface {\\r\\n    function accountID(address) external view returns (uint64);\\r\\n}\\r\\n\\r\\n\\r\\ncontract DoughEvent {\\r\\n\\r\\n    address public immutable doughList;\\r\\n\\r\\n    constructor (address _doughList) public {\\r\\n        doughList = _doughList;\\r\\n    }\\r\\n\\r\\n    event LogEvent(uint64 connectorType, uint64 indexed connectorID, uint64 indexed accountID, bytes32 indexed eventCode, bytes eventData);\\r\\n\\r\\n    function emitEvent(uint _connectorType, uint _connectorID, bytes32 _eventCode, bytes calldata _eventData) external {\\r\\n        uint64 _ID = ListInterface(doughList).accountID(msg.sender);\\r\\n        require(_ID != 0, \\\"not-SA\\\");\\r\\n        emit LogEvent(uint64(_connectorType), uint64(_connectorID), _ID, _eventCode, _eventData);\\r\\n    }\\r\\n\\r\\n}\"\r\n    },\r\n    \"contracts/v1/memory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\n/**\\r\\n * @title DoughMemory.\\r\\n * @dev Store Data For Cast Function.\\r\\n */\\r\\n\\r\\ncontract DoughMemory {\\r\\n\\r\\n    // Memory Bytes (Smart Account Address => Storage ID => Bytes).\\r\\n    mapping (address => mapping (uint => bytes32)) internal mbytes; // Use it to store execute data and delete in the same transaction\\r\\n    // Memory Uint (Smart Account Address => Storage ID => Uint).\\r\\n    mapping (address => mapping (uint => uint)) internal muint; // Use it to store execute data and delete in the same transaction\\r\\n    // Memory Address (Smart Account Address => Storage ID => Address).\\r\\n    mapping (address => mapping (uint => address)) internal maddr; // Use it to store execute data and delete in the same transaction\\r\\n\\r\\n    /**\\r\\n     * @dev Store Bytes.\\r\\n     * @param _id Storage ID.\\r\\n     * @param _byte bytes data to store.\\r\\n    */\\r\\n    function setBytes(uint _id, bytes32 _byte) public {\\r\\n        mbytes[msg.sender][_id] = _byte;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Get Stored Bytes.\\r\\n     * @param _id Storage ID.\\r\\n    */\\r\\n    function getBytes(uint _id) public returns (bytes32 _byte) {\\r\\n        _byte = mbytes[msg.sender][_id];\\r\\n        delete mbytes[msg.sender][_id];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Store Uint.\\r\\n     * @param _id Storage ID.\\r\\n     * @param _num uint data to store.\\r\\n    */\\r\\n    function setUint(uint _id, uint _num) public {\\r\\n        muint[msg.sender][_id] = _num;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Get Stored Uint.\\r\\n     * @param _id Storage ID.\\r\\n    */\\r\\n    function getUint(uint _id) public returns (uint _num) {\\r\\n        _num = muint[msg.sender][_id];\\r\\n        delete muint[msg.sender][_id];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Store Address.\\r\\n     * @param _id Storage ID.\\r\\n     * @param _addr Address data to store.\\r\\n    */\\r\\n    function setAddr(uint _id, address _addr) public {\\r\\n        maddr[msg.sender][_id] = _addr;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Get Stored Address.\\r\\n     * @param _id Storage ID.\\r\\n    */\\r\\n    function getAddr(uint _id) public returns (address _addr) {\\r\\n        _addr = maddr[msg.sender][_id];\\r\\n        delete maddr[msg.sender][_id];\\r\\n    }\\r\\n\\r\\n}\"\r\n    },\r\n    \"contracts/v1/test/check.test.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\ncontract Change {\\r\\n    bool public status;\\r\\n\\r\\n    function change(bool _status) public {\\r\\n        status = _status;\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract DoughCheck is Change {\\r\\n    function isOk() external view returns (bool ok) {\\r\\n        return status;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/v1/test/connector.registry.test.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\n/**\\r\\n * @title DoughConnectors\\r\\n * @dev Registry for Connectors.\\r\\n */\\r\\n\\r\\ninterface IndexInterface {\\r\\n    function master() external view returns (address);\\r\\n}\\r\\n\\r\\ninterface ConnectorInterface {\\r\\n    function connectorID() external view returns (uint256 _type, uint256 _id);\\r\\n\\r\\n    function name() external view returns (string memory);\\r\\n}\\r\\n\\r\\ncontract DSMath {\\r\\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\\r\\n        require((z = x + y) >= x, \\\"ds-math-add-overflow\\\");\\r\\n    }\\r\\n\\r\\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\\r\\n        require((z = x - y) <= x, \\\"ds-math-sub-underflow\\\");\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract Controllers is DSMath {\\r\\n    event LogAddController(address indexed addr);\\r\\n    event LogRemoveController(address indexed addr);\\r\\n\\r\\n    // DoughIndex Address.\\r\\n    address public immutable doughIndex;\\r\\n\\r\\n    constructor(address _doughIndex) {\\r\\n        doughIndex = _doughIndex;\\r\\n    }\\r\\n\\r\\n    // Enabled Chief(Address of Chief => bool).\\r\\n    mapping(address => bool) public chief;\\r\\n    // Enabled Connectors(Connector Address => bool).\\r\\n    mapping(address => bool) public connectors;\\r\\n    // Enabled Static Connectors(Connector Address => bool).\\r\\n    mapping(address => bool) public staticConnectors;\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if the sender not is Master Address from DoughIndex\\r\\n     * or Enabled Chief.\\r\\n     */\\r\\n    modifier isChief() {\\r\\n        require(\\r\\n            chief[msg.sender] ||\\r\\n                msg.sender == IndexInterface(doughIndex).master(),\\r\\n            \\\"not-an-chief\\\"\\r\\n        );\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Enable a Chief.\\r\\n     * @param _userAddress Chief Address.\\r\\n     */\\r\\n    function enableChief(address _userAddress) external isChief {\\r\\n        chief[_userAddress] = true;\\r\\n        emit LogAddController(_userAddress);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Disables a Chief.\\r\\n     * @param _userAddress Chief Address.\\r\\n     */\\r\\n    function disableChief(address _userAddress) external isChief {\\r\\n        delete chief[_userAddress];\\r\\n        emit LogRemoveController(_userAddress);\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract Listings is Controllers {\\r\\n    constructor(address _doughIndex) Controllers(_doughIndex) {}\\r\\n\\r\\n    // Connectors Array.\\r\\n    address[] public connectorArray;\\r\\n    // Count of Connector's Enabled.\\r\\n    uint256 public connectorCount;\\r\\n\\r\\n    /**\\r\\n     * @dev Add Connector to Connector's array.\\r\\n     * @param _connector Connector Address.\\r\\n     **/\\r\\n    function addToArr(address _connector) internal {\\r\\n        require(_connector != address(0), \\\"Not-valid-connector\\\");\\r\\n        (, uint256 _id) = ConnectorInterface(_connector).connectorID();\\r\\n        require(_id == (connectorArray.length + 1), \\\"ConnectorID-doesnt-match\\\");\\r\\n        ConnectorInterface(_connector).name(); // Checking if connector has function name()\\r\\n        connectorArray.push(_connector);\\r\\n    }\\r\\n\\r\\n    // Static Connectors Array.\\r\\n    address[] public staticConnectorArray;\\r\\n\\r\\n    /**\\r\\n     * @dev Add Connector to Static Connector's array.\\r\\n     * @param _connector Static Connector Address.\\r\\n     **/\\r\\n    function addToArrStatic(address _connector) internal {\\r\\n        require(_connector != address(0), \\\"Not-valid-connector\\\");\\r\\n        (, uint256 _id) = ConnectorInterface(_connector).connectorID();\\r\\n        require(\\r\\n            _id == (staticConnectorArray.length + 1),\\r\\n            \\\"ConnectorID-doesnt-match\\\"\\r\\n        );\\r\\n        ConnectorInterface(_connector).name(); // Checking if connector has function name()\\r\\n        staticConnectorArray.push(_connector);\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract DoughConnectorsTest is Listings {\\r\\n    constructor(address _doughIndex) public Listings(_doughIndex) {}\\r\\n\\r\\n    event LogEnable(address indexed connector);\\r\\n    event LogDisable(address indexed connector);\\r\\n    event LogEnableStatic(address indexed connector);\\r\\n\\r\\n    /**\\r\\n     * @dev Enable Connector.\\r\\n     * @param _connector Connector Address.\\r\\n     */\\r\\n    function enable(address _connector) external isChief {\\r\\n        require(!connectors[_connector], \\\"already-enabled\\\");\\r\\n        addToArr(_connector);\\r\\n        connectors[_connector] = true;\\r\\n        connectorCount++;\\r\\n        emit LogEnable(_connector);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Disable Connector.\\r\\n     * @param _connector Connector Address.\\r\\n     */\\r\\n    function disable(address _connector) external isChief {\\r\\n        require(connectors[_connector], \\\"already-disabled\\\");\\r\\n        delete connectors[_connector];\\r\\n        connectorCount--;\\r\\n        emit LogDisable(_connector);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Enable Static Connector.\\r\\n     * @param _connector Static Connector Address.\\r\\n     */\\r\\n    function enableStatic(address _connector) external isChief {\\r\\n        require(!staticConnectors[_connector], \\\"already-enabled\\\");\\r\\n        addToArrStatic(_connector);\\r\\n        staticConnectors[_connector] = true;\\r\\n        emit LogEnableStatic(_connector);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Check if Connector addresses are enabled.\\r\\n     * @param _connectors Array of Connector Addresses.\\r\\n     */\\r\\n    function isConnector(address[] calldata _connectors)\\r\\n        external\\r\\n        view\\r\\n        returns (bool isOk)\\r\\n    {\\r\\n        isOk = true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Check if Connector addresses are static enabled.\\r\\n     * @param _connectors Array of Connector Addresses.\\r\\n     */\\r\\n    function isStaticConnector(address[] calldata _connectors)\\r\\n        external\\r\\n        view\\r\\n        returns (bool isOk)\\r\\n    {\\r\\n        isOk = true;\\r\\n        for (uint256 i = 0; i < _connectors.length; i++) {\\r\\n            if (!staticConnectors[_connectors[i]]) {\\r\\n                isOk = false;\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev get Connector's Array length.\\r\\n     */\\r\\n    function connectorLength() external view returns (uint256) {\\r\\n        return connectorArray.length;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev get Static Connector's Array length.\\r\\n     */\\r\\n    function staticConnectorLength() external view returns (uint256) {\\r\\n        return staticConnectorArray.length;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/v1/test/DoughAccountV3.test.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.7.0;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\n/**\\r\\n * @title Test DoughAccount.\\r\\n * @dev DeFi Smart Account Wallet.\\r\\n */\\r\\n\\r\\ncontract Record {\\r\\n    uint256 public constant version = 3;\\r\\n}\\r\\n\\r\\ncontract DoughAccountV3 is Record {\\r\\n    receive() external payable {}\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/v1/test/DoughAccountV4.test.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.7.0;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\n/**\\r\\n * @title Test DoughAccount.\\r\\n * @dev DeFi Smart Account Wallet.\\r\\n */\\r\\n\\r\\ncontract Record {\\r\\n    uint256 public constant version = 4;\\r\\n}\\r\\n\\r\\ncontract DoughAccountV4 is Record {\\r\\n    receive() external payable {}\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/v1/test/staticConnector.test.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\n/**\\r\\n * @title Staic connector.\\r\\n * @dev Connector For Testing Static connectors.\\r\\n */\\r\\n\\r\\ncontract StaticTest {\\r\\n    /**\\r\\n     * @dev Connector ID and Type.\\r\\n     */\\r\\n    function connectorID() public pure returns (uint256 _type, uint256 _id) {\\r\\n        (_type, _id) = (1, 4);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/v2/accounts/default/implementation_default.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.7.0;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\nimport { Variables } from \\\"../variables.sol\\\";\\r\\n\\r\\ninterface IndexInterface {\\r\\n    function list() external view returns (address);\\r\\n}\\r\\n\\r\\ninterface ListInterface {\\r\\n    function addAuth(address user) external;\\r\\n\\r\\n    function removeAuth(address user) external;\\r\\n}\\r\\n\\r\\ncontract Constants is Variables {\\r\\n    uint256 public constant implementationVersion = 1;\\r\\n    // DoughIndex Address.\\r\\n    address public immutable doughIndex;\\r\\n    // The Account Module Version.\\r\\n    uint256 public constant version = 2;\\r\\n\\r\\n    constructor(address _doughIndex) {\\r\\n        doughIndex = _doughIndex;\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract Record is Constants {\\r\\n    constructor(address _doughIndex) Constants(_doughIndex) {}\\r\\n\\r\\n    event LogEnableUser(address indexed user);\\r\\n    event LogDisableUser(address indexed user);\\r\\n    event LogBetaMode(bool indexed beta);\\r\\n\\r\\n    /**\\r\\n     * @dev Check for Auth if enabled.\\r\\n     * @param user address/user/owner.\\r\\n     */\\r\\n    function isAuth(address user) public view returns (bool) {\\r\\n        return _auth[user];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Check if Beta mode is enabled or not\\r\\n     */\\r\\n    function isBeta() public view returns (bool) {\\r\\n        return _beta;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Enable New User.\\r\\n     * @param user Owner address\\r\\n     */\\r\\n    function enable(address user) public {\\r\\n        require(\\r\\n            msg.sender == address(this) || msg.sender == doughIndex,\\r\\n            \\\"not-self-index\\\"\\r\\n        );\\r\\n        require(user != address(0), \\\"not-valid\\\");\\r\\n        require(!_auth[user], \\\"already-enabled\\\");\\r\\n        _auth[user] = true;\\r\\n        ListInterface(IndexInterface(doughIndex).list()).addAuth(user);\\r\\n        emit LogEnableUser(user);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Disable User.\\r\\n     * @param user Owner address\\r\\n     */\\r\\n    function disable(address user) public {\\r\\n        require(msg.sender == address(this), \\\"not-self\\\");\\r\\n        require(user != address(0), \\\"not-valid\\\");\\r\\n        require(_auth[user], \\\"already-disabled\\\");\\r\\n        delete _auth[user];\\r\\n        ListInterface(IndexInterface(doughIndex).list()).removeAuth(user);\\r\\n        emit LogDisableUser(user);\\r\\n    }\\r\\n\\r\\n    function toggleBeta() public {\\r\\n        require(msg.sender == address(this), \\\"not-self\\\");\\r\\n        _beta = !_beta;\\r\\n        emit LogBetaMode(_beta);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev ERC721 token receiver\\r\\n     */\\r\\n    function onERC721Received(\\r\\n        address,\\r\\n        address,\\r\\n        uint256,\\r\\n        bytes calldata\\r\\n    ) external returns (bytes4) {\\r\\n        return 0x150b7a02; // bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev ERC1155 token receiver\\r\\n     */\\r\\n    function onERC1155Received(\\r\\n        address,\\r\\n        address,\\r\\n        uint256,\\r\\n        uint256,\\r\\n        bytes memory\\r\\n    ) external returns (bytes4) {\\r\\n        return 0xf23a6e61; // bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev ERC1155 token receiver\\r\\n     */\\r\\n    function onERC1155BatchReceived(\\r\\n        address,\\r\\n        address,\\r\\n        uint256[] calldata,\\r\\n        uint256[] calldata,\\r\\n        bytes calldata\\r\\n    ) external returns (bytes4) {\\r\\n        return 0xbc197c81; // bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract DoughDefaultImplementation is Record {\\r\\n    constructor(address _doughIndex) public Record(_doughIndex) {}\\r\\n\\r\\n    receive() external payable {}\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/v2/accounts/variables.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\ncontract Variables {\\r\\n    // Auth Module(Address of Auth => bool).\\r\\n    mapping (address => bool) internal _auth;\\r\\n    // enable beta mode to access all the beta features.\\r\\n    bool internal _beta;\\r\\n}\"\r\n    },\r\n    \"contracts/v2/accounts/test/ImplementationBetaTest.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.7.0;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\nimport {Variables} from \\\"../variables.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title DoughAccountV2.\\r\\n * @dev DeFi Smart Account Wallet.\\r\\n */\\r\\n\\r\\ninterface ConnectorsInterface {\\r\\n    function isConnectors(string[] calldata connectorNames)\\r\\n        external\\r\\n        view\\r\\n        returns (bool, address[] memory);\\r\\n}\\r\\n\\r\\ncontract Constants is Variables {\\r\\n    // DoughIndex Address.\\r\\n    address internal immutable doughIndex;\\r\\n    // Connectors Address.\\r\\n    address public immutable connectorsM1;\\r\\n\\r\\n    constructor(address _doughIndex, address _connectors) {\\r\\n        connectorsM1 = _connectors;\\r\\n        doughIndex = _doughIndex;\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract DoughImplementationBetaTest is Constants {\\r\\n    constructor(address _doughIndex, address _connectors)\\r\\n        Constants(_doughIndex, _connectors)\\r\\n    {}\\r\\n\\r\\n    function decodeEvent(bytes memory response)\\r\\n        internal\\r\\n        pure\\r\\n        returns (string memory _eventCode, bytes memory _eventParams)\\r\\n    {\\r\\n        if (response.length > 0) {\\r\\n            (_eventCode, _eventParams) = abi.decode(response, (string, bytes));\\r\\n        }\\r\\n    }\\r\\n\\r\\n    event LogCast(\\r\\n        address indexed origin,\\r\\n        address indexed sender,\\r\\n        uint256 value,\\r\\n        string[] targetsNames,\\r\\n        address[] targets,\\r\\n        string[] eventNames,\\r\\n        bytes[] eventParams\\r\\n    );\\r\\n\\r\\n    receive() external payable {}\\r\\n\\r\\n    /**\\r\\n     * @dev Delegate the calls to Connector.\\r\\n     * @param _target Connector address\\r\\n     * @param _data CallData of function.\\r\\n     */\\r\\n    function spell(address _target, bytes memory _data)\\r\\n        internal\\r\\n        returns (bytes memory response)\\r\\n    {\\r\\n        require(_target != address(0), \\\"target-invalid\\\");\\r\\n        assembly {\\r\\n            let succeeded := delegatecall(\\r\\n                gas(),\\r\\n                _target,\\r\\n                add(_data, 0x20),\\r\\n                mload(_data),\\r\\n                0,\\r\\n                0\\r\\n            )\\r\\n            let size := returndatasize()\\r\\n\\r\\n            response := mload(0x40)\\r\\n            mstore(\\r\\n                0x40,\\r\\n                add(response, and(add(add(size, 0x20), 0x1f), not(0x1f)))\\r\\n            )\\r\\n            mstore(response, size)\\r\\n            returndatacopy(add(response, 0x20), 0, size)\\r\\n\\r\\n            switch iszero(succeeded)\\r\\n            case 1 {\\r\\n                // throw if delegatecall failed\\r\\n                returndatacopy(0x00, 0x00, size)\\r\\n                revert(0x00, size)\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev This is the main function, Where all the different functions are called\\r\\n     * from Smart Account.\\r\\n     * @param _targetNames Array of Connector address.\\r\\n     * @param _datas Array of Calldata.\\r\\n     */\\r\\n    function castBeta(\\r\\n        string[] calldata _targetNames,\\r\\n        bytes[] calldata _datas,\\r\\n        address _origin\\r\\n    )\\r\\n        external\\r\\n        payable\\r\\n        returns (\\r\\n            bytes32 // Dummy return to fix doughIndex buildWithCast function\\r\\n        )\\r\\n    {\\r\\n        require(_beta, \\\"Beta-does-not-enabled\\\");\\r\\n        uint256 _length = _targetNames.length;\\r\\n        require(\\r\\n            _auth[msg.sender] || msg.sender == doughIndex,\\r\\n            \\\"1: permission-denied\\\"\\r\\n        );\\r\\n        require(_length != 0, \\\"1: length-invalid\\\");\\r\\n        require(_length == _datas.length, \\\"1: array-length-invalid\\\");\\r\\n\\r\\n        string[] memory eventNames = new string[](_length);\\r\\n        bytes[] memory eventParams = new bytes[](_length);\\r\\n\\r\\n        (bool isOk, address[] memory _targets) = ConnectorsInterface(\\r\\n            connectorsM1\\r\\n        ).isConnectors(_targetNames);\\r\\n\\r\\n        require(isOk, \\\"1: not-connector\\\");\\r\\n\\r\\n        for (uint256 i = 0; i < _length; i++) {\\r\\n            bytes memory response = spell(_targets[i], _datas[i]);\\r\\n            (eventNames[i], eventParams[i]) = decodeEvent(response);\\r\\n        }\\r\\n\\r\\n        emit LogCast(\\r\\n            _origin,\\r\\n            msg.sender,\\r\\n            msg.value,\\r\\n            _targetNames,\\r\\n            _targets,\\r\\n            eventNames,\\r\\n            eventParams\\r\\n        );\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/v2/accounts/module1/Implementation_m1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.7.0;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\nimport { Variables } from \\\"../variables.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title DoughAccountV2.\\r\\n * @dev DeFi Smart Account Wallet.\\r\\n */\\r\\n\\r\\ninterface ConnectorsInterface {\\r\\n    function isConnectors(string[] calldata connectorNames) external view returns (bool, address[] memory);\\r\\n}\\r\\n\\r\\ncontract Constants is Variables {\\r\\n    // DoughIndex Address.\\r\\n    address internal immutable doughIndex;\\r\\n    // Connectors Address.\\r\\n    address public immutable connectorsM1;\\r\\n\\r\\n    constructor(address _doughIndex, address _connectors) {\\r\\n        connectorsM1 = _connectors;\\r\\n        doughIndex = _doughIndex;\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract DoughImplementationM1 is Constants {\\r\\n\\r\\n    constructor(address _doughIndex, address _connectors) Constants(_doughIndex, _connectors) {}\\r\\n\\r\\n    function decodeEvent(bytes memory response) internal pure returns (string memory _eventCode, bytes memory _eventParams) {\\r\\n        if (response.length > 0) {\\r\\n            (_eventCode, _eventParams) = abi.decode(response, (string, bytes));\\r\\n        }\\r\\n    }\\r\\n\\r\\n    event LogCast(\\r\\n        address indexed origin,\\r\\n        address indexed sender,\\r\\n        uint256 value,\\r\\n        string[] targetsNames,\\r\\n        address[] targets,\\r\\n        string[] eventNames,\\r\\n        bytes[] eventParams\\r\\n    );\\r\\n\\r\\n    receive() external payable {}\\r\\n\\r\\n     /**\\r\\n     * @dev Delegate the calls to Connector.\\r\\n     * @param _target Connector address\\r\\n     * @param _data CallData of function.\\r\\n    */\\r\\n    function spell(address _target, bytes memory _data) internal returns (bytes memory response) {\\r\\n        require(_target != address(0), \\\"target-invalid\\\");\\r\\n        assembly {\\r\\n            let succeeded := delegatecall(gas(), _target, add(_data, 0x20), mload(_data), 0, 0)\\r\\n            let size := returndatasize()\\r\\n            \\r\\n            response := mload(0x40)\\r\\n            mstore(0x40, add(response, and(add(add(size, 0x20), 0x1f), not(0x1f))))\\r\\n            mstore(response, size)\\r\\n            returndatacopy(add(response, 0x20), 0, size)\\r\\n\\r\\n            switch iszero(succeeded)\\r\\n                case 1 {\\r\\n                    // throw if delegatecall failed\\r\\n                    returndatacopy(0x00, 0x00, size)\\r\\n                    revert(0x00, size)\\r\\n                }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev This is the main function, Where all the different functions are called\\r\\n     * from Smart Account.\\r\\n     * @param _targetNames Array of Connector address.\\r\\n     * @param _datas Array of Calldata.\\r\\n    */\\r\\n    function cast(\\r\\n        string[] calldata _targetNames,\\r\\n        bytes[] calldata _datas,\\r\\n        address _origin\\r\\n    )\\r\\n    external\\r\\n    payable \\r\\n    returns (bytes32) // Dummy return to fix doughIndex buildWithCast function\\r\\n    {   \\r\\n        uint256 _length = _targetNames.length;\\r\\n        require(_auth[msg.sender] || msg.sender == doughIndex, \\\"1: permission-denied\\\");\\r\\n        require(_length != 0, \\\"1: length-invalid\\\");\\r\\n        require(_length == _datas.length , \\\"1: array-length-invalid\\\");\\r\\n\\r\\n        string[] memory eventNames = new string[](_length);\\r\\n        bytes[] memory eventParams = new bytes[](_length);\\r\\n\\r\\n        (bool isOk, address[] memory _targets) = ConnectorsInterface(connectorsM1).isConnectors(_targetNames);\\r\\n\\r\\n        require(isOk, \\\"1: not-connector\\\");\\r\\n\\r\\n        for (uint i = 0; i < _length; i++) {\\r\\n            bytes memory response = spell(_targets[i], _datas[i]);\\r\\n            (eventNames[i], eventParams[i]) = decodeEvent(response);\\r\\n        }\\r\\n\\r\\n        emit LogCast(\\r\\n            _origin,\\r\\n            msg.sender,\\r\\n            msg.value,\\r\\n            _targetNames,\\r\\n            _targets,\\r\\n            eventNames,\\r\\n            eventParams\\r\\n        );\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/v2/accounts/test/ERC1155.token.test.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\\\";\\r\\n\\r\\n/**\\r\\n * ERC1155 Token contract\\r\\n * For testing purpose.\\r\\n */\\r\\n\\r\\ncontract TokenTest is ERC1155 {\\r\\n    constructor() public ERC1155(\\\"https://token.example/api/item/{id}.json\\\") {}\\r\\n\\r\\n    uint256 public constant _token1 = 0;\\r\\n    uint256 public constant _token2 = 1;\\r\\n\\r\\n    event LogTransferERC1155(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 tokenId,\\r\\n        uint256 amount\\r\\n    );\\r\\n    event LogTransferBatchERC1155(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256[] tokenIds,\\r\\n        uint256[] amounts\\r\\n    );\\r\\n\\r\\n    function transfer1155(\\r\\n        address _to,\\r\\n        uint256 id,\\r\\n        uint256 amount\\r\\n    ) public {\\r\\n        _mint(msg.sender, id, amount, \\\"\\\");\\r\\n        safeTransferFrom(msg.sender, _to, id, amount, \\\"\\\");\\r\\n\\r\\n        emit LogTransferERC1155(msg.sender, _to, id, amount);\\r\\n    }\\r\\n\\r\\n    function transferBatch1155(\\r\\n        address _to,\\r\\n        uint256[] memory ids,\\r\\n        uint256[] memory amounts\\r\\n    ) public {\\r\\n        _mintBatch(msg.sender, ids, amounts, \\\"\\\");\\r\\n        safeBatchTransferFrom(msg.sender, _to, ids, amounts, \\\"\\\");\\r\\n\\r\\n        emit LogTransferBatchERC1155(msg.sender, _to, ids, amounts);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"./IERC1155.sol\\\";\\nimport \\\"./IERC1155MetadataURI.sol\\\";\\nimport \\\"./IERC1155Receiver.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\nimport \\\"../../introspection/ERC165.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\n\\n/**\\n *\\n * @dev Implementation of the basic standard multi-token.\\n * See https://eips.ethereum.org/EIPS/eip-1155\\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\\n *\\n * _Available since v3.1._\\n */\\ncontract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    // Mapping from token ID to account balances\\n    mapping (uint256 => mapping(address => uint256)) private _balances;\\n\\n    // Mapping from account to operator approvals\\n    mapping (address => mapping(address => bool)) private _operatorApprovals;\\n\\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\\n    string private _uri;\\n\\n    /*\\n     *     bytes4(keccak256('balanceOf(address,uint256)')) == 0x00fdd58e\\n     *     bytes4(keccak256('balanceOfBatch(address[],uint256[])')) == 0x4e1273f4\\n     *     bytes4(keccak256('setApprovalForAll(address,bool)')) == 0xa22cb465\\n     *     bytes4(keccak256('isApprovedForAll(address,address)')) == 0xe985e9c5\\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,uint256,bytes)')) == 0xf242432a\\n     *     bytes4(keccak256('safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)')) == 0x2eb2c2d6\\n     *\\n     *     => 0x00fdd58e ^ 0x4e1273f4 ^ 0xa22cb465 ^\\n     *        0xe985e9c5 ^ 0xf242432a ^ 0x2eb2c2d6 == 0xd9b67a26\\n     */\\n    bytes4 private constant _INTERFACE_ID_ERC1155 = 0xd9b67a26;\\n\\n    /*\\n     *     bytes4(keccak256('uri(uint256)')) == 0x0e89341c\\n     */\\n    bytes4 private constant _INTERFACE_ID_ERC1155_METADATA_URI = 0x0e89341c;\\n\\n    /**\\n     * @dev See {_setURI}.\\n     */\\n    constructor (string memory uri_) public {\\n        _setURI(uri_);\\n\\n        // register the supported interfaces to conform to ERC1155 via ERC165\\n        _registerInterface(_INTERFACE_ID_ERC1155);\\n\\n        // register the supported interfaces to conform to ERC1155MetadataURI via ERC165\\n        _registerInterface(_INTERFACE_ID_ERC1155_METADATA_URI);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155MetadataURI-uri}.\\n     *\\n     * This implementation returns the same URI for *all* token types. It relies\\n     * on the token type ID substitution mechanism\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\\n     *\\n     * Clients calling this function must replace the `\\\\{id\\\\}` substring with the\\n     * actual token type ID.\\n     */\\n    function uri(uint256) external view virtual override returns (string memory) {\\n        return _uri;\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\\n        require(account != address(0), \\\"ERC1155: balance query for the zero address\\\");\\n        return _balances[id][account];\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-balanceOfBatch}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(\\n        address[] memory accounts,\\n        uint256[] memory ids\\n    )\\n        public\\n        view\\n        virtual\\n        override\\n        returns (uint256[] memory)\\n    {\\n        require(accounts.length == ids.length, \\\"ERC1155: accounts and ids length mismatch\\\");\\n\\n        uint256[] memory batchBalances = new uint256[](accounts.length);\\n\\n        for (uint256 i = 0; i < accounts.length; ++i) {\\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\\n        }\\n\\n        return batchBalances;\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\n        require(_msgSender() != operator, \\\"ERC1155: setting approval status for self\\\");\\n\\n        _operatorApprovals[_msgSender()][operator] = approved;\\n        emit ApprovalForAll(_msgSender(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\\n        return _operatorApprovals[account][operator];\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    )\\n        public\\n        virtual\\n        override\\n    {\\n        require(to != address(0), \\\"ERC1155: transfer to the zero address\\\");\\n        require(\\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\\n            \\\"ERC1155: caller is not owner nor approved\\\"\\n        );\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);\\n\\n        _balances[id][from] = _balances[id][from].sub(amount, \\\"ERC1155: insufficient balance for transfer\\\");\\n        _balances[id][to] = _balances[id][to].add(amount);\\n\\n        emit TransferSingle(operator, from, to, id, amount);\\n\\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-safeBatchTransferFrom}.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    )\\n        public\\n        virtual\\n        override\\n    {\\n        require(ids.length == amounts.length, \\\"ERC1155: ids and amounts length mismatch\\\");\\n        require(to != address(0), \\\"ERC1155: transfer to the zero address\\\");\\n        require(\\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\\n            \\\"ERC1155: transfer caller is not owner nor approved\\\"\\n        );\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\\n\\n        for (uint256 i = 0; i < ids.length; ++i) {\\n            uint256 id = ids[i];\\n            uint256 amount = amounts[i];\\n\\n            _balances[id][from] = _balances[id][from].sub(\\n                amount,\\n                \\\"ERC1155: insufficient balance for transfer\\\"\\n            );\\n            _balances[id][to] = _balances[id][to].add(amount);\\n        }\\n\\n        emit TransferBatch(operator, from, to, ids, amounts);\\n\\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\\n    }\\n\\n    /**\\n     * @dev Sets a new URI for all token types, by relying on the token type ID\\n     * substitution mechanism\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\\n     *\\n     * By this mechanism, any occurrence of the `\\\\{id\\\\}` substring in either the\\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\\n     * clients with the token type ID.\\n     *\\n     * For example, the `https://token-cdn-domain/\\\\{id\\\\}.json` URI would be\\n     * interpreted by clients as\\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\\n     * for token type ID 0x4cce0.\\n     *\\n     * See {uri}.\\n     *\\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\\n     * this function emits no events.\\n     */\\n    function _setURI(string memory newuri) internal virtual {\\n        _uri = newuri;\\n    }\\n\\n    /**\\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `account`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - If `account` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function _mint(address account, uint256 id, uint256 amount, bytes memory data) internal virtual {\\n        require(account != address(0), \\\"ERC1155: mint to the zero address\\\");\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, address(0), account, _asSingletonArray(id), _asSingletonArray(amount), data);\\n\\n        _balances[id][account] = _balances[id][account].add(amount);\\n        emit TransferSingle(operator, address(0), account, id, amount);\\n\\n        _doSafeTransferAcceptanceCheck(operator, address(0), account, id, amount, data);\\n    }\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function _mintBatch(address to, uint256[] memory ids, uint256[] memory amounts, bytes memory data) internal virtual {\\n        require(to != address(0), \\\"ERC1155: mint to the zero address\\\");\\n        require(ids.length == amounts.length, \\\"ERC1155: ids and amounts length mismatch\\\");\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\\n\\n        for (uint i = 0; i < ids.length; i++) {\\n            _balances[ids[i]][to] = amounts[i].add(_balances[ids[i]][to]);\\n        }\\n\\n        emit TransferBatch(operator, address(0), to, ids, amounts);\\n\\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens of token type `id` from `account`\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens of token type `id`.\\n     */\\n    function _burn(address account, uint256 id, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC1155: burn from the zero address\\\");\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, account, address(0), _asSingletonArray(id), _asSingletonArray(amount), \\\"\\\");\\n\\n        _balances[id][account] = _balances[id][account].sub(\\n            amount,\\n            \\\"ERC1155: burn amount exceeds balance\\\"\\n        );\\n\\n        emit TransferSingle(operator, account, address(0), id, amount);\\n    }\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     */\\n    function _burnBatch(address account, uint256[] memory ids, uint256[] memory amounts) internal virtual {\\n        require(account != address(0), \\\"ERC1155: burn from the zero address\\\");\\n        require(ids.length == amounts.length, \\\"ERC1155: ids and amounts length mismatch\\\");\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, account, address(0), ids, amounts, \\\"\\\");\\n\\n        for (uint i = 0; i < ids.length; i++) {\\n            _balances[ids[i]][account] = _balances[ids[i]][account].sub(\\n                amounts[i],\\n                \\\"ERC1155: burn amount exceeds balance\\\"\\n            );\\n        }\\n\\n        emit TransferBatch(operator, account, address(0), ids, amounts);\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any token transfer. This includes minting\\n     * and burning, as well as batched variants.\\n     *\\n     * The same hook is called on both single and batched variants. For single\\n     * transfers, the length of the `id` and `amount` arrays will be 1.\\n     *\\n     * Calling conditions (for each `id` and `amount` pair):\\n     *\\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * of token type `id` will be  transferred to `to`.\\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\\n     * for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\\n     * will be burned.\\n     * - `from` and `to` are never both zero.\\n     * - `ids` and `amounts` have the same, non-zero length.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    )\\n        internal\\n        virtual\\n    { }\\n\\n    function _doSafeTransferAcceptanceCheck(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    )\\n        private\\n    {\\n        if (to.isContract()) {\\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\\n                if (response != IERC1155Receiver(to).onERC1155Received.selector) {\\n                    revert(\\\"ERC1155: ERC1155Receiver rejected tokens\\\");\\n                }\\n            } catch Error(string memory reason) {\\n                revert(reason);\\n            } catch {\\n                revert(\\\"ERC1155: transfer to non ERC1155Receiver implementer\\\");\\n            }\\n        }\\n    }\\n\\n    function _doSafeBatchTransferAcceptanceCheck(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    )\\n        private\\n    {\\n        if (to.isContract()) {\\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (bytes4 response) {\\n                if (response != IERC1155Receiver(to).onERC1155BatchReceived.selector) {\\n                    revert(\\\"ERC1155: ERC1155Receiver rejected tokens\\\");\\n                }\\n            } catch Error(string memory reason) {\\n                revert(reason);\\n            } catch {\\n                revert(\\\"ERC1155: transfer to non ERC1155Receiver implementer\\\");\\n            }\\n        }\\n    }\\n\\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\\n        uint256[] memory array = new uint256[](1);\\n        array[0] = element;\\n\\n        return array;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2 <0.8.0;\\n\\nimport \\\"../../introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155 is IERC165 {\\n    /**\\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\\n     */\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n    /**\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n     * transfers.\\n     */\\n    event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values);\\n\\n    /**\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\n     * `approved`.\\n     */\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\n     *\\n     * If an {URI} event was emitted for `id`, the standard\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\n     * returned by {IERC1155MetadataURI-uri}.\\n     */\\n    event URI(string value, uint256 indexed id);\\n\\n    /**\\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids) external view returns (uint256[] memory);\\n\\n    /**\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `operator` cannot be the caller.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function safeBatchTransferFrom(address from, address to, uint256[] calldata ids, uint256[] calldata amounts, bytes calldata data) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/IERC1155MetadataURI.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2 <0.8.0;\\n\\nimport \\\"./IERC1155.sol\\\";\\n\\n/**\\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155MetadataURI is IERC1155 {\\n    /**\\n     * @dev Returns the URI for token type `id`.\\n     *\\n     * If the `\\\\{id\\\\}` substring is present in the URI, it must be replaced by\\n     * clients with the actual token type ID.\\n     */\\n    function uri(uint256 id) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../../introspection/IERC165.sol\\\";\\n\\n/**\\n * _Available since v3.1._\\n */\\ninterface IERC1155Receiver is IERC165 {\\n\\n    /**\\n        @dev Handles the receipt of a single ERC1155 token type. This function is\\n        called at the end of a `safeTransferFrom` after the balance has been updated.\\n        To accept the transfer, this must return\\n        `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\n        (i.e. 0xf23a6e61, or its own function selector).\\n        @param operator The address which initiated the transfer (i.e. msg.sender)\\n        @param from The address which previously owned the token\\n        @param id The ID of the token being transferred\\n        @param value The amount of tokens being transferred\\n        @param data Additional data with no specified format\\n        @return `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))` if transfer is allowed\\n    */\\n    function onERC1155Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        uint256 value,\\n        bytes calldata data\\n    )\\n        external\\n        returns(bytes4);\\n\\n    /**\\n        @dev Handles the receipt of a multiple ERC1155 token types. This function\\n        is called at the end of a `safeBatchTransferFrom` after the balances have\\n        been updated. To accept the transfer(s), this must return\\n        `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\n        (i.e. 0xbc197c81, or its own function selector).\\n        @param operator The address which initiated the batch transfer (i.e. msg.sender)\\n        @param from The address which previously owned the token\\n        @param ids An array containing ids of each token being transferred (order and length must match values array)\\n        @param values An array containing amounts of each token being transferred (order and length must match ids array)\\n        @param data Additional data with no specified format\\n        @return `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))` if transfer is allowed\\n    */\\n    function onERC1155BatchReceived(\\n        address operator,\\n        address from,\\n        uint256[] calldata ids,\\n        uint256[] calldata values,\\n        bytes calldata data\\n    )\\n        external\\n        returns(bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts may inherit from this and call {_registerInterface} to declare\\n * their support of an interface.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /*\\n     * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7\\n     */\\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\\n\\n    /**\\n     * @dev Mapping of interface ids to whether or not it's supported.\\n     */\\n    mapping(bytes4 => bool) private _supportedInterfaces;\\n\\n    constructor () internal {\\n        // Derived contracts need only register support for their own interfaces,\\n        // we register support for ERC165 itself here\\n        _registerInterface(_INTERFACE_ID_ERC165);\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     *\\n     * Time complexity O(1), guaranteed to always use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return _supportedInterfaces[interfaceId];\\n    }\\n\\n    /**\\n     * @dev Registers the contract as an implementer of the interface defined by\\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\\n     * registering its interface id is not required.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     *\\n     * Requirements:\\n     *\\n     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\\n     */\\n    function _registerInterface(bytes4 interfaceId) internal virtual {\\n        require(interfaceId != 0xffffffff, \\\"ERC165: invalid interface id\\\");\\n        _supportedInterfaces[interfaceId] = true;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2 <0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n// solhint-disable-next-line compiler-version\\npragma solidity >=0.4.24 <0.8.0;\\n\\nimport \\\"../utils/Address.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {UpgradeableProxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n */\\nabstract contract Initializable {\\n\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        require(_initializing || _isConstructor() || !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n\\n    /// @dev Returns true if and only if the function is running in the constructor\\n    function _isConstructor() private view returns (bool) {\\n        return !Address.isContract(address(this));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/v2/timelock/timelock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.7.0;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\nimport {TimelockController} from \\\"@openzeppelin/contracts/access/TimelockController.sol\\\";\\r\\nimport { Initializable } from \\\"@openzeppelin/contracts/proxy/Initializable.sol\\\";\\r\\n\\r\\ninterface IndexInterface {\\r\\n    function master() external view returns (address);\\r\\n    function changeMaster(address) external;\\r\\n    function updateMaster() external;\\r\\n}\\r\\n\\r\\ncontract DoughTimelockContract is Initializable, TimelockController {\\r\\n\\r\\n    IndexInterface constant public doughIndex = IndexInterface(0x2971AdFa57b20E5a416aE5a708A8655A9c74f723);\\r\\n    address constant public governanceTimelock = 0xC7Cb1dE2721BFC0E0DA1b9D526bCdC54eF1C0eFC;\\r\\n\\r\\n    constructor (address[] memory masterSig) public TimelockController(10 days, masterSig, masterSig){\\r\\n    }\\r\\n\\r\\n    function initialize() external initializer {\\r\\n        doughIndex.updateMaster();\\r\\n        doughIndex.changeMaster(governanceTimelock);\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/access/TimelockController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.9 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./../math/SafeMath.sol\\\";\\nimport \\\"./AccessControl.sol\\\";\\n\\n/**\\n * @dev Contract module which acts as a timelocked controller. When set as the\\n * owner of an `Ownable` smart contract, it enforces a timelock on all\\n * `onlyOwner` maintenance operations. This gives time for users of the\\n * controlled contract to exit before a potentially dangerous maintenance\\n * operation is applied.\\n *\\n * By default, this contract is self administered, meaning administration tasks\\n * have to go through the timelock process. The proposer (resp executor) role\\n * is in charge of proposing (resp executing) operations. A common use case is\\n * to position this {TimelockController} as the owner of a smart contract, with\\n * a multisig or a DAO as the sole proposer.\\n *\\n * _Available since v3.3._\\n */\\ncontract TimelockController is AccessControl {\\n\\n    bytes32 public constant TIMELOCK_ADMIN_ROLE = keccak256(\\\"TIMELOCK_ADMIN_ROLE\\\");\\n    bytes32 public constant PROPOSER_ROLE = keccak256(\\\"PROPOSER_ROLE\\\");\\n    bytes32 public constant EXECUTOR_ROLE = keccak256(\\\"EXECUTOR_ROLE\\\");\\n    uint256 internal constant _DONE_TIMESTAMP = uint256(1);\\n\\n    mapping(bytes32 => uint256) private _timestamps;\\n    uint256 private _minDelay;\\n\\n    /**\\n     * @dev Emitted when a call is scheduled as part of operation `id`.\\n     */\\n    event CallScheduled(bytes32 indexed id, uint256 indexed index, address target, uint256 value, bytes data, bytes32 predecessor, uint256 delay);\\n\\n    /**\\n     * @dev Emitted when a call is performed as part of operation `id`.\\n     */\\n    event CallExecuted(bytes32 indexed id, uint256 indexed index, address target, uint256 value, bytes data);\\n\\n    /**\\n     * @dev Emitted when operation `id` is cancelled.\\n     */\\n    event Cancelled(bytes32 indexed id);\\n\\n    /**\\n     * @dev Emitted when the minimum delay for future operations is modified.\\n     */\\n    event MinDelayChange(uint256 oldDuration, uint256 newDuration);\\n\\n    /**\\n     * @dev Initializes the contract with a given `minDelay`.\\n     */\\n    constructor(uint256 minDelay, address[] memory proposers, address[] memory executors) public {\\n        _setRoleAdmin(TIMELOCK_ADMIN_ROLE, TIMELOCK_ADMIN_ROLE);\\n        _setRoleAdmin(PROPOSER_ROLE, TIMELOCK_ADMIN_ROLE);\\n        _setRoleAdmin(EXECUTOR_ROLE, TIMELOCK_ADMIN_ROLE);\\n\\n        // deployer + self administration\\n        _setupRole(TIMELOCK_ADMIN_ROLE, _msgSender());\\n        _setupRole(TIMELOCK_ADMIN_ROLE, address(this));\\n\\n        // register proposers\\n        for (uint256 i = 0; i < proposers.length; ++i) {\\n            _setupRole(PROPOSER_ROLE, proposers[i]);\\n        }\\n\\n        // register executors\\n        for (uint256 i = 0; i < executors.length; ++i) {\\n            _setupRole(EXECUTOR_ROLE, executors[i]);\\n        }\\n\\n        _minDelay = minDelay;\\n        emit MinDelayChange(0, minDelay);\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only by a certain role. In\\n     * addition to checking the sender's role, `address(0)` 's role is also\\n     * considered. Granting a role to `address(0)` is equivalent to enabling\\n     * this role for everyone.\\n     */\\n    modifier onlyRole(bytes32 role) {\\n        require(hasRole(role, _msgSender()) || hasRole(role, address(0)), \\\"TimelockController: sender requires permission\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Contract might receive/hold ETH as part of the maintenance process.\\n     */\\n    receive() external payable {}\\n\\n    /**\\n     * @dev Returns whether an id correspond to a registered operation. This\\n     * includes both Pending, Ready and Done operations.\\n     */\\n    function isOperation(bytes32 id) public view virtual returns (bool pending) {\\n        return getTimestamp(id) > 0;\\n    }\\n\\n    /**\\n     * @dev Returns whether an operation is pending or not.\\n     */\\n    function isOperationPending(bytes32 id) public view virtual returns (bool pending) {\\n        return getTimestamp(id) > _DONE_TIMESTAMP;\\n    }\\n\\n    /**\\n     * @dev Returns whether an operation is ready or not.\\n     */\\n    function isOperationReady(bytes32 id) public view virtual returns (bool ready) {\\n        uint256 timestamp = getTimestamp(id);\\n        // solhint-disable-next-line not-rely-on-time\\n        return timestamp > _DONE_TIMESTAMP && timestamp <= block.timestamp;\\n    }\\n\\n    /**\\n     * @dev Returns whether an operation is done or not.\\n     */\\n    function isOperationDone(bytes32 id) public view virtual returns (bool done) {\\n        return getTimestamp(id) == _DONE_TIMESTAMP;\\n    }\\n\\n    /**\\n     * @dev Returns the timestamp at with an operation becomes ready (0 for\\n     * unset operations, 1 for done operations).\\n     */\\n    function getTimestamp(bytes32 id) public view virtual returns (uint256 timestamp) {\\n        return _timestamps[id];\\n    }\\n\\n    /**\\n     * @dev Returns the minimum delay for an operation to become valid.\\n     *\\n     * This value can be changed by executing an operation that calls `updateDelay`.\\n     */\\n    function getMinDelay() public view virtual returns (uint256 duration) {\\n        return _minDelay;\\n    }\\n\\n    /**\\n     * @dev Returns the identifier of an operation containing a single\\n     * transaction.\\n     */\\n    function hashOperation(address target, uint256 value, bytes calldata data, bytes32 predecessor, bytes32 salt) public pure virtual returns (bytes32 hash) {\\n        return keccak256(abi.encode(target, value, data, predecessor, salt));\\n    }\\n\\n    /**\\n     * @dev Returns the identifier of an operation containing a batch of\\n     * transactions.\\n     */\\n    function hashOperationBatch(address[] calldata targets, uint256[] calldata values, bytes[] calldata datas, bytes32 predecessor, bytes32 salt) public pure virtual returns (bytes32 hash) {\\n        return keccak256(abi.encode(targets, values, datas, predecessor, salt));\\n    }\\n\\n    /**\\n     * @dev Schedule an operation containing a single transaction.\\n     *\\n     * Emits a {CallScheduled} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have the 'proposer' role.\\n     */\\n    function schedule(address target, uint256 value, bytes calldata data, bytes32 predecessor, bytes32 salt, uint256 delay) public virtual onlyRole(PROPOSER_ROLE) {\\n        bytes32 id = hashOperation(target, value, data, predecessor, salt);\\n        _schedule(id, delay);\\n        emit CallScheduled(id, 0, target, value, data, predecessor, delay);\\n    }\\n\\n    /**\\n     * @dev Schedule an operation containing a batch of transactions.\\n     *\\n     * Emits one {CallScheduled} event per transaction in the batch.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have the 'proposer' role.\\n     */\\n    function scheduleBatch(address[] calldata targets, uint256[] calldata values, bytes[] calldata datas, bytes32 predecessor, bytes32 salt, uint256 delay) public virtual onlyRole(PROPOSER_ROLE) {\\n        require(targets.length == values.length, \\\"TimelockController: length mismatch\\\");\\n        require(targets.length == datas.length, \\\"TimelockController: length mismatch\\\");\\n\\n        bytes32 id = hashOperationBatch(targets, values, datas, predecessor, salt);\\n        _schedule(id, delay);\\n        for (uint256 i = 0; i < targets.length; ++i) {\\n            emit CallScheduled(id, i, targets[i], values[i], datas[i], predecessor, delay);\\n        }\\n    }\\n\\n    /**\\n     * @dev Schedule an operation that is to becomes valid after a given delay.\\n     */\\n    function _schedule(bytes32 id, uint256 delay) private {\\n        require(!isOperation(id), \\\"TimelockController: operation already scheduled\\\");\\n        require(delay >= getMinDelay(), \\\"TimelockController: insufficient delay\\\");\\n        // solhint-disable-next-line not-rely-on-time\\n        _timestamps[id] = SafeMath.add(block.timestamp, delay);\\n    }\\n\\n    /**\\n     * @dev Cancel an operation.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have the 'proposer' role.\\n     */\\n    function cancel(bytes32 id) public virtual onlyRole(PROPOSER_ROLE) {\\n        require(isOperationPending(id), \\\"TimelockController: operation cannot be cancelled\\\");\\n        delete _timestamps[id];\\n\\n        emit Cancelled(id);\\n    }\\n\\n    /**\\n     * @dev Execute an (ready) operation containing a single transaction.\\n     *\\n     * Emits a {CallExecuted} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have the 'executor' role.\\n     */\\n    function execute(address target, uint256 value, bytes calldata data, bytes32 predecessor, bytes32 salt) public payable virtual onlyRole(EXECUTOR_ROLE) {\\n        bytes32 id = hashOperation(target, value, data, predecessor, salt);\\n        _beforeCall(id, predecessor);\\n        _call(id, 0, target, value, data);\\n        _afterCall(id);\\n    }\\n\\n    /**\\n     * @dev Execute an (ready) operation containing a batch of transactions.\\n     *\\n     * Emits one {CallExecuted} event per transaction in the batch.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have the 'executor' role.\\n     */\\n    function executeBatch(address[] calldata targets, uint256[] calldata values, bytes[] calldata datas, bytes32 predecessor, bytes32 salt) public payable virtual onlyRole(EXECUTOR_ROLE) {\\n        require(targets.length == values.length, \\\"TimelockController: length mismatch\\\");\\n        require(targets.length == datas.length, \\\"TimelockController: length mismatch\\\");\\n\\n        bytes32 id = hashOperationBatch(targets, values, datas, predecessor, salt);\\n        _beforeCall(id, predecessor);\\n        for (uint256 i = 0; i < targets.length; ++i) {\\n            _call(id, i, targets[i], values[i], datas[i]);\\n        }\\n        _afterCall(id);\\n    }\\n\\n    /**\\n     * @dev Checks before execution of an operation's calls.\\n     */\\n    function _beforeCall(bytes32 id, bytes32 predecessor) private view {\\n        require(isOperationReady(id), \\\"TimelockController: operation is not ready\\\");\\n        require(predecessor == bytes32(0) || isOperationDone(predecessor), \\\"TimelockController: missing dependency\\\");\\n    }\\n\\n    /**\\n     * @dev Checks after execution of an operation's calls.\\n     */\\n    function _afterCall(bytes32 id) private {\\n        require(isOperationReady(id), \\\"TimelockController: operation is not ready\\\");\\n        _timestamps[id] = _DONE_TIMESTAMP;\\n    }\\n\\n    /**\\n     * @dev Execute an operation's call.\\n     *\\n     * Emits a {CallExecuted} event.\\n     */\\n    function _call(bytes32 id, uint256 index, address target, uint256 value, bytes calldata data) private {\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success,) = target.call{value: value}(data);\\n        require(success, \\\"TimelockController: underlying transaction reverted\\\");\\n\\n        emit CallExecuted(id, index, target, value, data);\\n    }\\n\\n    /**\\n     * @dev Changes the minimum timelock duration for future operations.\\n     *\\n     * Emits a {MinDelayChange} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be the timelock itself. This can only be achieved by scheduling and later executing\\n     * an operation where the timelock is the target and the data is the ABI-encoded call to this function.\\n     */\\n    function updateDelay(uint256 newDelay) external virtual {\\n        require(msg.sender == address(this), \\\"TimelockController: caller must be timelock\\\");\\n        emit MinDelayChange(_minDelay, newDelay);\\n        _minDelay = newDelay;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/AccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../utils/EnumerableSet.sol\\\";\\nimport \\\"../utils/Address.sol\\\";\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module that allows children to implement role-based access\\n * control mechanisms.\\n *\\n * Roles are referred to by their `bytes32` identifier. These should be exposed\\n * in the external API and be unique. The best way to achieve this is by\\n * using `public constant` hash digests:\\n *\\n * ```\\n * bytes32 public constant MY_ROLE = keccak256(\\\"MY_ROLE\\\");\\n * ```\\n *\\n * Roles can be used to represent a set of permissions. To restrict access to a\\n * function call, use {hasRole}:\\n *\\n * ```\\n * function foo() public {\\n *     require(hasRole(MY_ROLE, msg.sender));\\n *     ...\\n * }\\n * ```\\n *\\n * Roles can be granted and revoked dynamically via the {grantRole} and\\n * {revokeRole} functions. Each role has an associated admin role, and only\\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\\n *\\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\\n * that only accounts with this role will be able to grant or revoke other\\n * roles. More complex role relationships can be created by using\\n * {_setRoleAdmin}.\\n *\\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\\n * grant and revoke this role. Extra precautions should be taken to secure\\n * accounts that have been granted it.\\n */\\nabstract contract AccessControl is Context {\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n    using Address for address;\\n\\n    struct RoleData {\\n        EnumerableSet.AddressSet members;\\n        bytes32 adminRole;\\n    }\\n\\n    mapping (bytes32 => RoleData) private _roles;\\n\\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) public view returns (bool) {\\n        return _roles[role].members.contains(account);\\n    }\\n\\n    /**\\n     * @dev Returns the number of accounts that have `role`. Can be used\\n     * together with {getRoleMember} to enumerate all bearers of a role.\\n     */\\n    function getRoleMemberCount(bytes32 role) public view returns (uint256) {\\n        return _roles[role].members.length();\\n    }\\n\\n    /**\\n     * @dev Returns one of the accounts that have `role`. `index` must be a\\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\\n     *\\n     * Role bearers are not sorted in any particular way, and their ordering may\\n     * change at any point.\\n     *\\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\\n     * you perform all queries on the same block. See the following\\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\\n     * for more information.\\n     */\\n    function getRoleMember(bytes32 role, uint256 index) public view returns (address) {\\n        return _roles[role].members.at(index);\\n    }\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) public view returns (bytes32) {\\n        return _roles[role].adminRole;\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) public virtual {\\n        require(hasRole(_roles[role].adminRole, _msgSender()), \\\"AccessControl: sender must be an admin to grant\\\");\\n\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) public virtual {\\n        require(hasRole(_roles[role].adminRole, _msgSender()), \\\"AccessControl: sender must be an admin to revoke\\\");\\n\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) public virtual {\\n        require(account == _msgSender(), \\\"AccessControl: can only renounce roles for self\\\");\\n\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event. Note that unlike {grantRole}, this function doesn't perform any\\n     * checks on the calling account.\\n     *\\n     * [WARNING]\\n     * ====\\n     * This function should only be called from the constructor when setting\\n     * up the initial roles for the system.\\n     *\\n     * Using this function in any other way is effectively circumventing the admin\\n     * system imposed by {AccessControl}.\\n     * ====\\n     */\\n    function _setupRole(bytes32 role, address account) internal virtual {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Sets `adminRole` as ``role``'s admin role.\\n     *\\n     * Emits a {RoleAdminChanged} event.\\n     */\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\n        emit RoleAdminChanged(role, _roles[role].adminRole, adminRole);\\n        _roles[role].adminRole = adminRole;\\n    }\\n\\n    function _grantRole(bytes32 role, address account) private {\\n        if (_roles[role].members.add(account)) {\\n            emit RoleGranted(role, account, _msgSender());\\n        }\\n    }\\n\\n    function _revokeRole(bytes32 role, address account) private {\\n        if (_roles[role].members.remove(account)) {\\n            emit RoleRevoked(role, account, _msgSender());\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping (bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\\n\\n            bytes32 lastvalue = set._values[lastIndex];\\n\\n            // Move the last value to the index where the value to delete is\\n            set._values[toDeleteIndex] = lastvalue;\\n            // Update the index for the moved value\\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        require(set._values.length > index, \\\"EnumerableSet: index out of bounds\\\");\\n        return set._values[index];\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/ERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../../utils/Context.sol\\\";\\nimport \\\"./IERC721.sol\\\";\\nimport \\\"./IERC721Metadata.sol\\\";\\nimport \\\"./IERC721Enumerable.sol\\\";\\nimport \\\"./IERC721Receiver.sol\\\";\\nimport \\\"../../introspection/ERC165.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\nimport \\\"../../utils/EnumerableSet.sol\\\";\\nimport \\\"../../utils/EnumerableMap.sol\\\";\\nimport \\\"../../utils/Strings.sol\\\";\\n\\n/**\\n * @title ERC721 Non-Fungible Token Standard basic implementation\\n * @dev see https://eips.ethereum.org/EIPS/eip-721\\n */\\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata, IERC721Enumerable {\\n    using SafeMath for uint256;\\n    using Address for address;\\n    using EnumerableSet for EnumerableSet.UintSet;\\n    using EnumerableMap for EnumerableMap.UintToAddressMap;\\n    using Strings for uint256;\\n\\n    // Equals to `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`\\n    // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\\n    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\\n\\n    // Mapping from holder address to their (enumerable) set of owned tokens\\n    mapping (address => EnumerableSet.UintSet) private _holderTokens;\\n\\n    // Enumerable mapping from token ids to their owners\\n    EnumerableMap.UintToAddressMap private _tokenOwners;\\n\\n    // Mapping from token ID to approved address\\n    mapping (uint256 => address) private _tokenApprovals;\\n\\n    // Mapping from owner to operator approvals\\n    mapping (address => mapping (address => bool)) private _operatorApprovals;\\n\\n    // Token name\\n    string private _name;\\n\\n    // Token symbol\\n    string private _symbol;\\n\\n    // Optional mapping for token URIs\\n    mapping (uint256 => string) private _tokenURIs;\\n\\n    // Base URI\\n    string private _baseURI;\\n\\n    /*\\n     *     bytes4(keccak256('balanceOf(address)')) == 0x70a08231\\n     *     bytes4(keccak256('ownerOf(uint256)')) == 0x6352211e\\n     *     bytes4(keccak256('approve(address,uint256)')) == 0x095ea7b3\\n     *     bytes4(keccak256('getApproved(uint256)')) == 0x081812fc\\n     *     bytes4(keccak256('setApprovalForAll(address,bool)')) == 0xa22cb465\\n     *     bytes4(keccak256('isApprovedForAll(address,address)')) == 0xe985e9c5\\n     *     bytes4(keccak256('transferFrom(address,address,uint256)')) == 0x23b872dd\\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256)')) == 0x42842e0e\\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)')) == 0xb88d4fde\\n     *\\n     *     => 0x70a08231 ^ 0x6352211e ^ 0x095ea7b3 ^ 0x081812fc ^\\n     *        0xa22cb465 ^ 0xe985e9c5 ^ 0x23b872dd ^ 0x42842e0e ^ 0xb88d4fde == 0x80ac58cd\\n     */\\n    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\\n\\n    /*\\n     *     bytes4(keccak256('name()')) == 0x06fdde03\\n     *     bytes4(keccak256('symbol()')) == 0x95d89b41\\n     *     bytes4(keccak256('tokenURI(uint256)')) == 0xc87b56dd\\n     *\\n     *     => 0x06fdde03 ^ 0x95d89b41 ^ 0xc87b56dd == 0x5b5e139f\\n     */\\n    bytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\\n\\n    /*\\n     *     bytes4(keccak256('totalSupply()')) == 0x18160ddd\\n     *     bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) == 0x2f745c59\\n     *     bytes4(keccak256('tokenByIndex(uint256)')) == 0x4f6ccce7\\n     *\\n     *     => 0x18160ddd ^ 0x2f745c59 ^ 0x4f6ccce7 == 0x780e9d63\\n     */\\n    bytes4 private constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;\\n\\n    /**\\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\\n     */\\n    constructor (string memory name_, string memory symbol_) public {\\n        _name = name_;\\n        _symbol = symbol_;\\n\\n        // register the supported interfaces to conform to ERC721 via ERC165\\n        _registerInterface(_INTERFACE_ID_ERC721);\\n        _registerInterface(_INTERFACE_ID_ERC721_METADATA);\\n        _registerInterface(_INTERFACE_ID_ERC721_ENUMERABLE);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-balanceOf}.\\n     */\\n    function balanceOf(address owner) public view virtual override returns (uint256) {\\n        require(owner != address(0), \\\"ERC721: balance query for the zero address\\\");\\n        return _holderTokens[owner].length();\\n    }\\n\\n    /**\\n     * @dev See {IERC721-ownerOf}.\\n     */\\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\\n        return _tokenOwners.get(tokenId, \\\"ERC721: owner query for nonexistent token\\\");\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-name}.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-symbol}.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-tokenURI}.\\n     */\\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\\n        require(_exists(tokenId), \\\"ERC721Metadata: URI query for nonexistent token\\\");\\n\\n        string memory _tokenURI = _tokenURIs[tokenId];\\n        string memory base = baseURI();\\n\\n        // If there is no base URI, return the token URI.\\n        if (bytes(base).length == 0) {\\n            return _tokenURI;\\n        }\\n        // If both are set, concatenate the baseURI and tokenURI (via abi.encodePacked).\\n        if (bytes(_tokenURI).length > 0) {\\n            return string(abi.encodePacked(base, _tokenURI));\\n        }\\n        // If there is a baseURI but no tokenURI, concatenate the tokenID to the baseURI.\\n        return string(abi.encodePacked(base, tokenId.toString()));\\n    }\\n\\n    /**\\n    * @dev Returns the base URI set via {_setBaseURI}. This will be\\n    * automatically added as a prefix in {tokenURI} to each token's URI, or\\n    * to the token ID if no specific URI is set for that token ID.\\n    */\\n    function baseURI() public view virtual returns (string memory) {\\n        return _baseURI;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\\n     */\\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\\n        return _holderTokens[owner].at(index);\\n    }\\n\\n    /**\\n     * @dev See {IERC721Enumerable-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        // _tokenOwners are indexed by tokenIds, so .length() returns the number of tokenIds\\n        return _tokenOwners.length();\\n    }\\n\\n    /**\\n     * @dev See {IERC721Enumerable-tokenByIndex}.\\n     */\\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\\n        (uint256 tokenId, ) = _tokenOwners.at(index);\\n        return tokenId;\\n    }\\n\\n    /**\\n     * @dev See {IERC721-approve}.\\n     */\\n    function approve(address to, uint256 tokenId) public virtual override {\\n        address owner = ERC721.ownerOf(tokenId);\\n        require(to != owner, \\\"ERC721: approval to current owner\\\");\\n\\n        require(_msgSender() == owner || ERC721.isApprovedForAll(owner, _msgSender()),\\n            \\\"ERC721: approve caller is not owner nor approved for all\\\"\\n        );\\n\\n        _approve(to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-getApproved}.\\n     */\\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\\n        require(_exists(tokenId), \\\"ERC721: approved query for nonexistent token\\\");\\n\\n        return _tokenApprovals[tokenId];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\n        require(operator != _msgSender(), \\\"ERC721: approve to caller\\\");\\n\\n        _operatorApprovals[_msgSender()][operator] = approved;\\n        emit ApprovalForAll(_msgSender(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\\n        return _operatorApprovals[owner][operator];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-transferFrom}.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\\n        //solhint-disable-next-line max-line-length\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: transfer caller is not owner nor approved\\\");\\n\\n        _transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\\n        safeTransferFrom(from, to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public virtual override {\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: transfer caller is not owner nor approved\\\");\\n        _safeTransfer(from, to, tokenId, _data);\\n    }\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\\n     *\\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory _data) internal virtual {\\n        _transfer(from, to, tokenId);\\n        require(_checkOnERC721Received(from, to, tokenId, _data), \\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n    }\\n\\n    /**\\n     * @dev Returns whether `tokenId` exists.\\n     *\\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\\n     *\\n     * Tokens start existing when they are minted (`_mint`),\\n     * and stop existing when they are burned (`_burn`).\\n     */\\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\\n        return _tokenOwners.contains(tokenId);\\n    }\\n\\n    /**\\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\\n        require(_exists(tokenId), \\\"ERC721: operator query for nonexistent token\\\");\\n        address owner = ERC721.ownerOf(tokenId);\\n        return (spender == owner || getApproved(tokenId) == spender || ERC721.isApprovedForAll(owner, spender));\\n    }\\n\\n    /**\\n     * @dev Safely mints `tokenId` and transfers it to `to`.\\n     *\\n     * Requirements:\\n     d*\\n     * - `tokenId` must not exist.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeMint(address to, uint256 tokenId) internal virtual {\\n        _safeMint(to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\\n     */\\n    function _safeMint(address to, uint256 tokenId, bytes memory _data) internal virtual {\\n        _mint(to, tokenId);\\n        require(_checkOnERC721Received(address(0), to, tokenId, _data), \\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n    }\\n\\n    /**\\n     * @dev Mints `tokenId` and transfers it to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - `to` cannot be the zero address.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _mint(address to, uint256 tokenId) internal virtual {\\n        require(to != address(0), \\\"ERC721: mint to the zero address\\\");\\n        require(!_exists(tokenId), \\\"ERC721: token already minted\\\");\\n\\n        _beforeTokenTransfer(address(0), to, tokenId);\\n\\n        _holderTokens[to].add(tokenId);\\n\\n        _tokenOwners.set(tokenId, to);\\n\\n        emit Transfer(address(0), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Destroys `tokenId`.\\n     * The approval is cleared when the token is burned.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _burn(uint256 tokenId) internal virtual {\\n        address owner = ERC721.ownerOf(tokenId); // internal owner\\n\\n        _beforeTokenTransfer(owner, address(0), tokenId);\\n\\n        // Clear approvals\\n        _approve(address(0), tokenId);\\n\\n        // Clear metadata (if any)\\n        if (bytes(_tokenURIs[tokenId]).length != 0) {\\n            delete _tokenURIs[tokenId];\\n        }\\n\\n        _holderTokens[owner].remove(tokenId);\\n\\n        _tokenOwners.remove(tokenId);\\n\\n        emit Transfer(owner, address(0), tokenId);\\n    }\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\\n        require(ERC721.ownerOf(tokenId) == from, \\\"ERC721: transfer of token that is not own\\\"); // internal owner\\n        require(to != address(0), \\\"ERC721: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, tokenId);\\n\\n        // Clear approvals from the previous owner\\n        _approve(address(0), tokenId);\\n\\n        _holderTokens[from].remove(tokenId);\\n        _holderTokens[to].add(tokenId);\\n\\n        _tokenOwners.set(tokenId, to);\\n\\n        emit Transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Sets `_tokenURI` as the tokenURI of `tokenId`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {\\n        require(_exists(tokenId), \\\"ERC721Metadata: URI set of nonexistent token\\\");\\n        _tokenURIs[tokenId] = _tokenURI;\\n    }\\n\\n    /**\\n     * @dev Internal function to set the base URI for all token IDs. It is\\n     * automatically added as a prefix to the value returned in {tokenURI},\\n     * or to the token ID if {tokenURI} is empty.\\n     */\\n    function _setBaseURI(string memory baseURI_) internal virtual {\\n        _baseURI = baseURI_;\\n    }\\n\\n    /**\\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\\n     * The call is not executed if the target address is not a contract.\\n     *\\n     * @param from address representing the previous owner of the given token ID\\n     * @param to target address that will receive the tokens\\n     * @param tokenId uint256 ID of the token to be transferred\\n     * @param _data bytes optional data to send along with the call\\n     * @return bool whether the call correctly returned the expected magic value\\n     */\\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\\n        private returns (bool)\\n    {\\n        if (!to.isContract()) {\\n            return true;\\n        }\\n        bytes memory returndata = to.functionCall(abi.encodeWithSelector(\\n            IERC721Receiver(to).onERC721Received.selector,\\n            _msgSender(),\\n            from,\\n            tokenId,\\n            _data\\n        ), \\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n        bytes4 retval = abi.decode(returndata, (bytes4));\\n        return (retval == _ERC721_RECEIVED);\\n    }\\n\\n    /**\\n     * @dev Approve `to` to operate on `tokenId`\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function _approve(address to, uint256 tokenId) internal virtual {\\n        _tokenApprovals[tokenId] = to;\\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId); // internal owner\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any token transfer. This includes minting\\n     * and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` will be minted for `to`.\\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual { }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2 <0.8.0;\\n\\nimport \\\"../../introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n      * @dev Safely transfers `tokenId` token from `from` to `to`.\\n      *\\n      * Requirements:\\n      *\\n      * - `from` cannot be the zero address.\\n      * - `to` cannot be the zero address.\\n      * - `tokenId` token must exist and be owned by `from`.\\n      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n      *\\n      * Emits a {Transfer} event.\\n      */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2 <0.8.0;\\n\\nimport \\\"./IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Metadata is IERC721 {\\n\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721Enumerable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2 <0.8.0;\\n\\nimport \\\"./IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Enumerable is IERC721 {\\n\\n    /**\\n     * @dev Returns the total amount of tokens stored by the contract.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\\n     */\\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\\n\\n    /**\\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\\n     * Use along with {totalSupply} to enumerate all tokens.\\n     */\\n    function tokenByIndex(uint256 index) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\\n     */\\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/EnumerableMap.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Library for managing an enumerable variant of Solidity's\\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\\n * type.\\n *\\n * Maps have the following properties:\\n *\\n * - Entries are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\\n *\\n *     // Declare a set state variable\\n *     EnumerableMap.UintToAddressMap private myMap;\\n * }\\n * ```\\n *\\n * As of v3.0.0, only maps of type `uint256 -> address` (`UintToAddressMap`) are\\n * supported.\\n */\\nlibrary EnumerableMap {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Map type with\\n    // bytes32 keys and values.\\n    // The Map implementation uses private functions, and user-facing\\n    // implementations (such as Uint256ToAddressMap) are just wrappers around\\n    // the underlying Map.\\n    // This means that we can only create new EnumerableMaps for types that fit\\n    // in bytes32.\\n\\n    struct MapEntry {\\n        bytes32 _key;\\n        bytes32 _value;\\n    }\\n\\n    struct Map {\\n        // Storage of map keys and values\\n        MapEntry[] _entries;\\n\\n        // Position of the entry defined by a key in the `entries` array, plus 1\\n        // because index 0 means a key is not in the map.\\n        mapping (bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n    function _set(Map storage map, bytes32 key, bytes32 value) private returns (bool) {\\n        // We read and store the key's index to prevent multiple reads from the same storage slot\\n        uint256 keyIndex = map._indexes[key];\\n\\n        if (keyIndex == 0) { // Equivalent to !contains(map, key)\\n            map._entries.push(MapEntry({ _key: key, _value: value }));\\n            // The entry is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            map._indexes[key] = map._entries.length;\\n            return true;\\n        } else {\\n            map._entries[keyIndex - 1]._value = value;\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a key-value pair from a map. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n    function _remove(Map storage map, bytes32 key) private returns (bool) {\\n        // We read and store the key's index to prevent multiple reads from the same storage slot\\n        uint256 keyIndex = map._indexes[key];\\n\\n        if (keyIndex != 0) { // Equivalent to contains(map, key)\\n            // To delete a key-value pair from the _entries array in O(1), we swap the entry to delete with the last one\\n            // in the array, and then remove the last entry (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = keyIndex - 1;\\n            uint256 lastIndex = map._entries.length - 1;\\n\\n            // When the entry to delete is the last one, the swap operation is unnecessary. However, since this occurs\\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\\n\\n            MapEntry storage lastEntry = map._entries[lastIndex];\\n\\n            // Move the last entry to the index where the entry to delete is\\n            map._entries[toDeleteIndex] = lastEntry;\\n            // Update the index for the moved entry\\n            map._indexes[lastEntry._key] = toDeleteIndex + 1; // All indexes are 1-based\\n\\n            // Delete the slot where the moved entry was stored\\n            map._entries.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete map._indexes[key];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the key is in the map. O(1).\\n     */\\n    function _contains(Map storage map, bytes32 key) private view returns (bool) {\\n        return map._indexes[key] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of key-value pairs in the map. O(1).\\n     */\\n    function _length(Map storage map) private view returns (uint256) {\\n        return map._entries.length;\\n    }\\n\\n   /**\\n    * @dev Returns the key-value pair stored at position `index` in the map. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of entries inside the\\n    * array, and it may change when more entries are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function _at(Map storage map, uint256 index) private view returns (bytes32, bytes32) {\\n        require(map._entries.length > index, \\\"EnumerableMap: index out of bounds\\\");\\n\\n        MapEntry storage entry = map._entries[index];\\n        return (entry._key, entry._value);\\n    }\\n\\n    /**\\n     * @dev Tries to returns the value associated with `key`.  O(1).\\n     * Does not revert if `key` is not in the map.\\n     */\\n    function _tryGet(Map storage map, bytes32 key) private view returns (bool, bytes32) {\\n        uint256 keyIndex = map._indexes[key];\\n        if (keyIndex == 0) return (false, 0); // Equivalent to contains(map, key)\\n        return (true, map._entries[keyIndex - 1]._value); // All indexes are 1-based\\n    }\\n\\n    /**\\n     * @dev Returns the value associated with `key`.  O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n    function _get(Map storage map, bytes32 key) private view returns (bytes32) {\\n        uint256 keyIndex = map._indexes[key];\\n        require(keyIndex != 0, \\\"EnumerableMap: nonexistent key\\\"); // Equivalent to contains(map, key)\\n        return map._entries[keyIndex - 1]._value; // All indexes are 1-based\\n    }\\n\\n    /**\\n     * @dev Same as {_get}, with a custom error message when `key` is not in the map.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {_tryGet}.\\n     */\\n    function _get(Map storage map, bytes32 key, string memory errorMessage) private view returns (bytes32) {\\n        uint256 keyIndex = map._indexes[key];\\n        require(keyIndex != 0, errorMessage); // Equivalent to contains(map, key)\\n        return map._entries[keyIndex - 1]._value; // All indexes are 1-based\\n    }\\n\\n    // UintToAddressMap\\n\\n    struct UintToAddressMap {\\n        Map _inner;\\n    }\\n\\n    /**\\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n    function set(UintToAddressMap storage map, uint256 key, address value) internal returns (bool) {\\n        return _set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n    function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\\n        return _remove(map._inner, bytes32(key));\\n    }\\n\\n    /**\\n     * @dev Returns true if the key is in the map. O(1).\\n     */\\n    function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\\n        return _contains(map._inner, bytes32(key));\\n    }\\n\\n    /**\\n     * @dev Returns the number of elements in the map. O(1).\\n     */\\n    function length(UintToAddressMap storage map) internal view returns (uint256) {\\n        return _length(map._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the element stored at position `index` in the set. O(1).\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\\n        (bytes32 key, bytes32 value) = _at(map._inner, index);\\n        return (uint256(key), address(uint160(uint256(value))));\\n    }\\n\\n    /**\\n     * @dev Tries to returns the value associated with `key`.  O(1).\\n     * Does not revert if `key` is not in the map.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {\\n        (bool success, bytes32 value) = _tryGet(map._inner, bytes32(key));\\n        return (success, address(uint160(uint256(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the value associated with `key`.  O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n    function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\\n        return address(uint160(uint256(_get(map._inner, bytes32(key)))));\\n    }\\n\\n    /**\\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryGet}.\\n     */\\n    function get(UintToAddressMap storage map, uint256 key, string memory errorMessage) internal view returns (address) {\\n        return address(uint160(uint256(_get(map._inner, bytes32(key), errorMessage))));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        uint256 index = digits - 1;\\n        temp = value;\\n        while (temp != 0) {\\n            buffer[index--] = bytes1(uint8(48 + temp % 10));\\n            temp /= 10;\\n        }\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/v2/accounts/test/NFT.test.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/token/ERC721/ERC721.sol\\\";\\r\\n\\r\\n/**\\r\\n * ERC721 Token contract\\r\\n * For testing purpose.\\r\\n */\\r\\n\\r\\ncontract NFTTest is ERC721 {\\r\\n    constructor() public ERC721(\\\"NFTTest\\\", \\\"NFT\\\") {}\\r\\n\\r\\n    uint256 public _tokenIds;\\r\\n\\r\\n    event LogTransferERC721(address from, address to, uint256 tokenId);\\r\\n\\r\\n    function transferNFT(address _to) public {\\r\\n        _tokenIds++;\\r\\n\\r\\n        uint256 newItemId = _tokenIds;\\r\\n        _mint(msg.sender, newItemId);\\r\\n        safeTransferFrom(msg.sender, _to, newItemId);\\r\\n\\r\\n        emit LogTransferERC721(msg.sender, _to, newItemId);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/v2/timelock/chiefTimelock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.7.0;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\nimport { TimelockController } from \\\"@openzeppelin/contracts/access/TimelockController.sol\\\";\\r\\n\\r\\ninterface IndexInterface {\\r\\n    function master() external view returns (address);\\r\\n    function changeMaster(address) external;\\r\\n    function updateMaster() external;\\r\\n}\\r\\n\\r\\ncontract DoughChiefTimelockContract is TimelockController {\\r\\n\\r\\n    constructor (address[] memory chiefMultiSig) public TimelockController(2 days, chiefMultiSig, chiefMultiSig) {\\r\\n        require(chiefMultiSig.length == 1, \\\"chiefMultiSig length != 1\\\");\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/UpgradeableProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"./Proxy.sol\\\";\\nimport \\\"../utils/Address.sol\\\";\\n\\n/**\\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\\n * implementation address that can be changed. This address is stored in storage in the location specified by\\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\\n * implementation behind the proxy.\\n *\\n * Upgradeability is only provided internally through {_upgradeTo}. For an externally upgradeable proxy see\\n * {TransparentUpgradeableProxy}.\\n */\\ncontract UpgradeableProxy is Proxy {\\n    /**\\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\\n     *\\n     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\\n     * function call, and allows initializating the storage of the proxy like a Solidity constructor.\\n     */\\n    constructor(address _logic, bytes memory _data) public payable {\\n        assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\\\"eip1967.proxy.implementation\\\")) - 1));\\n        _setImplementation(_logic);\\n        if(_data.length > 0) {\\n            Address.functionDelegateCall(_logic, _data);\\n        }\\n    }\\n\\n    /**\\n     * @dev Emitted when the implementation is upgraded.\\n     */\\n    event Upgraded(address indexed implementation);\\n\\n    /**\\n     * @dev Storage slot with the address of the current implementation.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.implementation\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 private constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    /**\\n     * @dev Returns the current implementation address.\\n     */\\n    function _implementation() internal view virtual override returns (address impl) {\\n        bytes32 slot = _IMPLEMENTATION_SLOT;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            impl := sload(slot)\\n        }\\n    }\\n\\n    /**\\n     * @dev Upgrades the proxy to a new implementation.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeTo(address newImplementation) internal virtual {\\n        _setImplementation(newImplementation);\\n        emit Upgraded(newImplementation);\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 implementation slot.\\n     */\\n    function _setImplementation(address newImplementation) private {\\n        require(Address.isContract(newImplementation), \\\"UpgradeableProxy: new implementation is not a contract\\\");\\n\\n        bytes32 slot = _IMPLEMENTATION_SLOT;\\n\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            sstore(slot, newImplementation)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/Proxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\\n * be specified by overriding the virtual {_implementation} function.\\n *\\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\\n * different contract through the {_delegate} function.\\n *\\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\\n */\\nabstract contract Proxy {\\n    /**\\n     * @dev Delegates the current call to `implementation`.\\n     *\\n     * This function does not return to its internall call site, it will return directly to the external caller.\\n     */\\n    function _delegate(address implementation) internal virtual {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            // Copy msg.data. We take full control of memory in this inline assembly\\n            // block because it will not return to Solidity code. We overwrite the\\n            // Solidity scratch pad at memory position 0.\\n            calldatacopy(0, 0, calldatasize())\\n\\n            // Call the implementation.\\n            // out and outsize are 0 because we don't know the size yet.\\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\\n\\n            // Copy the returned data.\\n            returndatacopy(0, 0, returndatasize())\\n\\n            switch result\\n            // delegatecall returns 0 on error.\\n            case 0 { revert(0, returndatasize()) }\\n            default { return(0, returndatasize()) }\\n        }\\n    }\\n\\n    /**\\n     * @dev This is a virtual function that should be overriden so it returns the address to which the fallback function\\n     * and {_fallback} should delegate.\\n     */\\n    function _implementation() internal view virtual returns (address);\\n\\n    /**\\n     * @dev Delegates the current call to the address returned by `_implementation()`.\\n     *\\n     * This function does not return to its internall call site, it will return directly to the external caller.\\n     */\\n    function _fallback() internal virtual {\\n        _beforeFallback();\\n        _delegate(_implementation());\\n    }\\n\\n    /**\\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\\n     * function in the contract matches the call data.\\n     */\\n    fallback () external payable virtual {\\n        _fallback();\\n    }\\n\\n    /**\\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\\n     * is empty.\\n     */\\n    receive () external payable virtual {\\n        _fallback();\\n    }\\n\\n    /**\\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\\n     * call, or as part of the Solidity `fallback` or `receive` functions.\\n     *\\n     * If overriden should call `super._beforeFallback()`.\\n     */\\n    function _beforeFallback() internal virtual {\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/TransparentUpgradeableProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"./UpgradeableProxy.sol\\\";\\n\\n/**\\n * @dev This contract implements a proxy that is upgradeable by an admin.\\n *\\n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector\\n * clashing], which can potentially be used in an attack, this contract uses the\\n * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two\\n * things that go hand in hand:\\n *\\n * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if\\n * that call matches one of the admin functions exposed by the proxy itself.\\n * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the\\n * implementation. If the admin tries to call a function on the implementation it will fail with an error that says\\n * \\\"admin cannot fallback to proxy target\\\".\\n *\\n * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing\\n * the admin, so it's best if it's a dedicated account that is not used for anything else. This will avoid headaches due\\n * to sudden errors when trying to call a function from the proxy implementation.\\n *\\n * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,\\n * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy.\\n */\\ncontract TransparentUpgradeableProxy is UpgradeableProxy {\\n    /**\\n     * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and\\n     * optionally initialized with `_data` as explained in {UpgradeableProxy-constructor}.\\n     */\\n    constructor(address _logic, address admin_, bytes memory _data) public payable UpgradeableProxy(_logic, _data) {\\n        assert(_ADMIN_SLOT == bytes32(uint256(keccak256(\\\"eip1967.proxy.admin\\\")) - 1));\\n        _setAdmin(admin_);\\n    }\\n\\n    /**\\n     * @dev Emitted when the admin account has changed.\\n     */\\n    event AdminChanged(address previousAdmin, address newAdmin);\\n\\n    /**\\n     * @dev Storage slot with the admin of the contract.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.admin\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 private constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n    /**\\n     * @dev Modifier used internally that will delegate the call to the implementation unless the sender is the admin.\\n     */\\n    modifier ifAdmin() {\\n        if (msg.sender == _admin()) {\\n            _;\\n        } else {\\n            _fallback();\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the current admin.\\n     *\\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyAdmin}.\\n     *\\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\\n     */\\n    function admin() external ifAdmin returns (address admin_) {\\n        admin_ = _admin();\\n    }\\n\\n    /**\\n     * @dev Returns the current implementation.\\n     *\\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}.\\n     *\\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\\n     */\\n    function implementation() external ifAdmin returns (address implementation_) {\\n        implementation_ = _implementation();\\n    }\\n\\n    /**\\n     * @dev Changes the admin of the proxy.\\n     *\\n     * Emits an {AdminChanged} event.\\n     *\\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-changeProxyAdmin}.\\n     */\\n    function changeAdmin(address newAdmin) external virtual ifAdmin {\\n        require(newAdmin != address(0), \\\"TransparentUpgradeableProxy: new admin is the zero address\\\");\\n        emit AdminChanged(_admin(), newAdmin);\\n        _setAdmin(newAdmin);\\n    }\\n\\n    /**\\n     * @dev Upgrade the implementation of the proxy.\\n     *\\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgrade}.\\n     */\\n    function upgradeTo(address newImplementation) external virtual ifAdmin {\\n        _upgradeTo(newImplementation);\\n    }\\n\\n    /**\\n     * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified\\n     * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the\\n     * proxied contract.\\n     *\\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgradeAndCall}.\\n     */\\n    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable virtual ifAdmin {\\n        _upgradeTo(newImplementation);\\n        Address.functionDelegateCall(newImplementation, data);\\n    }\\n\\n    /**\\n     * @dev Returns the current admin.\\n     */\\n    function _admin() internal view virtual returns (address adm) {\\n        bytes32 slot = _ADMIN_SLOT;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            adm := sload(slot)\\n        }\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 admin slot.\\n     */\\n    function _setAdmin(address newAdmin) private {\\n        bytes32 slot = _ADMIN_SLOT;\\n\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            sstore(slot, newAdmin)\\n        }\\n    }\\n\\n    /**\\n     * @dev Makes sure the admin cannot access the fallback function. See {Proxy-_beforeFallback}.\\n     */\\n    function _beforeFallback() internal virtual override {\\n        require(msg.sender != _admin(), \\\"TransparentUpgradeableProxy: admin cannot fallback to proxy target\\\");\\n        super._beforeFallback();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/v2/proxy/connectorsProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/proxy/TransparentUpgradeableProxy.sol\\\";\\r\\n\\r\\ncontract DoughConnectorsV2Proxy is TransparentUpgradeableProxy {\\r\\n    constructor(address _logic, address admin_, bytes memory _data) public TransparentUpgradeableProxy(_logic, admin_, _data) {}\\r\\n}\"\r\n    },\r\n    \"contracts/v2/accounts/test/implementation_default.v2.test.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\ninterface IndexInterface {\\r\\n    function list() external view returns (address);\\r\\n}\\r\\n\\r\\ninterface CheckInterface {\\r\\n    function isOk() external view returns (bool);\\r\\n}\\r\\n\\r\\ninterface ListInterface {\\r\\n    function addAuth(address user) external;\\r\\n\\r\\n    function removeAuth(address user) external;\\r\\n}\\r\\n\\r\\ncontract CommonSetup {\\r\\n    uint256 public constant implementationVersion = 2;\\r\\n    // DoughIndex Address.\\r\\n    address public constant doughIndex =\\r\\n        0x2971AdFa57b20E5a416aE5a708A8655A9c74f723;\\r\\n    // The Account Module Version.\\r\\n    uint256 public constant version = 2;\\r\\n    // Auth Module(Address of Auth => bool).\\r\\n    mapping(address => bool) internal auth;\\r\\n    // Is shield true/false.\\r\\n    bool public shield;\\r\\n    // Auth Module(Address of Auth => bool).\\r\\n    mapping(address => bool) internal checkMapping;\\r\\n}\\r\\n\\r\\ncontract Record is CommonSetup {\\r\\n    event LogReceiveEther(uint256 amt);\\r\\n    event LogEnableUser(address indexed user);\\r\\n    event LogDisableUser(address indexed user);\\r\\n    event LogSwitchShield(bool _shield);\\r\\n    event LogCheckMapping(address user, bool check);\\r\\n\\r\\n    /**\\r\\n     * @dev Check for Auth if enabled.\\r\\n     * @param user address/user/owner.\\r\\n     */\\r\\n    function isAuth(address user) public view returns (bool) {\\r\\n        return auth[user];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Change Shield State.\\r\\n     */\\r\\n    function switchShield(bool _shield) external {\\r\\n        require(auth[msg.sender], \\\"not-self\\\");\\r\\n        require(shield != _shield, \\\"shield is set\\\");\\r\\n        shield = _shield;\\r\\n        emit LogSwitchShield(shield);\\r\\n    }\\r\\n\\r\\n    function editCheckMapping(address user, bool _bool) public {\\r\\n        require(msg.sender == address(this), \\\"not-self-index\\\");\\r\\n        require(user != address(0), \\\"not-valid\\\");\\r\\n        checkMapping[user] = _bool;\\r\\n        emit LogCheckMapping(user, _bool);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Enable New User.\\r\\n     * @param user Owner of the Smart Account.\\r\\n     */\\r\\n    function enable(address user) public {\\r\\n        require(\\r\\n            msg.sender == address(this) ||\\r\\n                msg.sender == doughIndex ||\\r\\n                isAuth(msg.sender),\\r\\n            \\\"not-self-index\\\"\\r\\n        );\\r\\n        require(user != address(0), \\\"not-valid\\\");\\r\\n        require(!auth[user], \\\"already-enabled\\\");\\r\\n        auth[user] = true;\\r\\n        ListInterface(IndexInterface(doughIndex).list()).addAuth(user);\\r\\n        emit LogEnableUser(user);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Disable User.\\r\\n     * @param user Owner of the Smart Account.\\r\\n     */\\r\\n    function disable(address user) public {\\r\\n        require(msg.sender == address(this) || isAuth(msg.sender), \\\"not-self\\\");\\r\\n        require(user != address(0), \\\"not-valid\\\");\\r\\n        require(auth[user], \\\"already-disabled\\\");\\r\\n        delete auth[user];\\r\\n        ListInterface(IndexInterface(doughIndex).list()).removeAuth(user);\\r\\n        emit LogDisableUser(user);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Test function to check receival of ether to contract.\\r\\n     */\\r\\n    function receiveEther() public payable {\\r\\n        emit LogReceiveEther(msg.value);\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract DoughDefaultImplementationV2 is Record {\\r\\n    receive() external payable {}\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/v2/accounts/test/Implementation_m2.test.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.7.0;\\r\\npragma experimental ABIEncoderV2;\\r\\nimport \\\"hardhat/console.sol\\\";\\r\\n\\r\\n\\r\\n/**\\r\\n * @title DoughAccountV2 Mapping 2.\\r\\n * @dev DeFi Smart Account Wallet.\\r\\n */\\r\\n\\r\\ninterface DefaultImplementation {\\r\\n    function version() external view returns(uint);\\r\\n    function isAuth(address) external view returns(bool);\\r\\n}\\r\\n\\r\\ninterface IndexInterface {\\r\\n    function connectors(uint version) external view returns (address);\\r\\n    function check(uint version) external view returns (address);\\r\\n}\\r\\n\\r\\ninterface ConnectorsInterface {\\r\\n    function isConnectors(string[] calldata connectorNames) external view returns (bool, address[] memory);\\r\\n}\\r\\n\\r\\ninterface CheckInterface {\\r\\n    function isOk() external view returns (bool);\\r\\n}\\r\\n\\r\\ncontract DoughImplementationM2 {\\r\\n    address internal immutable doughIndex;\\r\\n    // Connnectors Address.\\r\\n    address public immutable connectorsM2;\\r\\n\\r\\n    constructor(address _doughIndex, address _connectors) {\\r\\n        connectorsM2 = _connectors;\\r\\n        doughIndex = _doughIndex;\\r\\n    }\\r\\n    \\r\\n    function decodeEvent(bytes memory response) internal pure returns (string memory _eventCode, bytes memory _eventParams) {\\r\\n        (_eventCode, _eventParams) = abi.decode(response, (string, bytes));\\r\\n    }\\r\\n\\r\\n    event LogCast(\\r\\n        address indexed origin,\\r\\n        address indexed sender,\\r\\n        uint value,\\r\\n        string[] targetsNames,\\r\\n        address[] targets,\\r\\n        string[] eventNames,\\r\\n        bytes[] eventParams\\r\\n    );\\r\\n\\r\\n    receive() external payable {}\\r\\n\\r\\n     /**\\r\\n     * @dev Delegate the calls to Connector And this function is ran by cast().\\r\\n     * @param _target Target to of Connector.\\r\\n     * @param _data CallData of function in Connector.\\r\\n    */\\r\\n    function spell(address _target, bytes memory _data) internal returns (bytes memory response) {\\r\\n        require(_target != address(0), \\\"target-invalid\\\");\\r\\n        assembly {\\r\\n            let succeeded := delegatecall(gas(), _target, add(_data, 0x20), mload(_data), 0, 0)\\r\\n            let size := returndatasize()\\r\\n            \\r\\n            response := mload(0x40)\\r\\n            mstore(0x40, add(response, and(add(add(size, 0x20), 0x1f), not(0x1f))))\\r\\n            mstore(response, size)\\r\\n            returndatacopy(add(response, 0x20), 0, size)\\r\\n\\r\\n            switch iszero(succeeded)\\r\\n                case 1 {\\r\\n                    // throw if delegatecall failed\\r\\n                    returndatacopy(0x00, 0x00, size)\\r\\n                    revert(0x00, size)\\r\\n                }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev This is the main function, Where all the different functions are called\\r\\n     * from Smart Account.\\r\\n     * @param _targetNames Array of Target(s) to of Connector.\\r\\n     * @param _datas Array of Calldata(S) of function.\\r\\n    */\\r\\n    function castWithFlashloan(\\r\\n        string[] calldata _targetNames,\\r\\n        bytes[] calldata _datas,\\r\\n        address _origin\\r\\n    )\\r\\n    external\\r\\n    payable \\r\\n    returns (bytes32) // Dummy return to fix doughIndex buildWithCast function\\r\\n    {   \\r\\n\\r\\n        DefaultImplementation defaultImplementation = DefaultImplementation(address(this));\\r\\n        uint256 _length = _targetNames.length;\\r\\n\\r\\n        require(defaultImplementation.isAuth(msg.sender) || msg.sender == address(doughIndex), \\\"DoughImplementationM1: permission-denied\\\");\\r\\n        require(_length == _datas.length , \\\"DoughImplementationM1: array-length-invalid\\\");\\r\\n\\r\\n        string[] memory eventNames = new string[](_length);\\r\\n        bytes[] memory eventParams = new bytes[](_length);\\r\\n\\r\\n        (bool isOk, address[] memory _targets) = ConnectorsInterface(connectorsM2).isConnectors(_targetNames);\\r\\n        require(isOk, \\\"1: not-connector\\\");\\r\\n        \\r\\n        for (uint i = 0; i < _targets.length; i++) {\\r\\n            bytes memory response = spell(_targets[i], _datas[i]);\\r\\n            (eventNames[i], eventParams[i]) = decodeEvent(response);\\r\\n        }\\r\\n        \\r\\n        emit LogCast(\\r\\n            _origin,\\r\\n            msg.sender,\\r\\n            msg.value,\\r\\n            _targetNames,\\r\\n            _targets,\\r\\n            eventNames,\\r\\n            eventParams\\r\\n        );\\r\\n    }\\r\\n\\r\\n}\"\r\n    },\r\n    \"hardhat/console.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >= 0.4.22 <0.9.0;\\n\\nlibrary console {\\n\\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\\n\\n\\tfunction _sendLogPayload(bytes memory payload) private view {\\n\\t\\tuint256 payloadLength = payload.length;\\n\\t\\taddress consoleAddress = CONSOLE_ADDRESS;\\n\\t\\tassembly {\\n\\t\\t\\tlet payloadStart := add(payload, 32)\\n\\t\\t\\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\\n\\t\\t}\\n\\t}\\n\\n\\tfunction log() internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log()\\\"));\\n\\t}\\n\\n\\tfunction logInt(int p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(int)\\\", p0));\\n\\t}\\n\\n\\tfunction logUint(uint p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint)\\\", p0));\\n\\t}\\n\\n\\tfunction logString(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction logBool(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction logAddress(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes(bytes memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes1(bytes1 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes1)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes2(bytes2 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes2)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes3(bytes3 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes3)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes4(bytes4 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes4)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes5(bytes5 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes5)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes6(bytes6 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes6)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes7(bytes7 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes7)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes8(bytes8 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes8)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes9(bytes9 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes9)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes10(bytes10 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes10)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes11(bytes11 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes11)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes12(bytes12 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes12)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes13(bytes13 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes13)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes14(bytes14 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes14)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes15(bytes15 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes15)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes16(bytes16 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes16)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes17(bytes17 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes17)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes18(bytes18 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes18)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes19(bytes19 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes19)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes20(bytes20 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes20)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes21(bytes21 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes21)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes22(bytes22 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes22)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes23(bytes23 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes23)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes24(bytes24 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes24)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes25(bytes25 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes25)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes26(bytes26 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes26)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes27(bytes27 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes27)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes28(bytes28 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes28)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes29(bytes29 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes29)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes30(bytes30 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes30)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes31(bytes31 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes31)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes32(bytes32 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes32)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint)\\\", p0));\\n\\t}\\n\\n\\tfunction log(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction log(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction log(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n}\\n\"\r\n    },\r\n    \"contracts/v2/accounts/test/Implmentation_account.test.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.7.0;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\n/**\\r\\n * Test ImplementationM0\\r\\n * Defi Smart Account\\r\\n * Not a complete or correct contract.\\r\\n */\\r\\ninterface IndexInterface {\\r\\n    function list() external view returns (address);\\r\\n}\\r\\n\\r\\ninterface ListInterface {\\r\\n    function addAuth(address user) external;\\r\\n}\\r\\n\\r\\ncontract CommonSetup {\\r\\n    // Auth Module(Address of Auth => bool).\\r\\n    mapping(address => bool) internal auth;\\r\\n}\\r\\n\\r\\ncontract Record is CommonSetup {\\r\\n    address public immutable doughIndex;\\r\\n\\r\\n    constructor(address _doughIndex) {\\r\\n        doughIndex = _doughIndex;\\r\\n    }\\r\\n\\r\\n    event LogEnableUser(address indexed user);\\r\\n    event LogPayEther(uint256 amt);\\r\\n\\r\\n    /**\\r\\n     * @dev Test function to check transfer of ether, should not be used.\\r\\n     * @param _account account module address.\\r\\n     */\\r\\n    function handlePayment(address payable _account) public payable {\\r\\n        _account.transfer(msg.value);\\r\\n        emit LogPayEther(msg.value);\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract DoughImplementationM0Test is Record {\\r\\n    constructor(address _doughIndex) Record(_doughIndex) {}\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/v2/connectors/test/auth.test.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.7.0;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\n/**\\r\\n * @title ConnectAuth.\\r\\n * @dev Connector For Adding Authorities.\\r\\n */\\r\\n\\r\\ninterface AccountInterface {\\r\\n    function enable(address) external;\\r\\n    function disable(address) external;\\r\\n}\\r\\n\\r\\ninterface ListInterface {\\r\\n    struct UserLink {\\r\\n        uint64 first;\\r\\n        uint64 last;\\r\\n        uint64 count;\\r\\n    }\\r\\n\\r\\n    struct UserList {\\r\\n        uint64 prev;\\r\\n        uint64 next;\\r\\n    }\\r\\n\\r\\n    struct AccountLink {\\r\\n        address first;\\r\\n        address last;\\r\\n        uint64 count;\\r\\n    }\\r\\n\\r\\n    struct AccountList {\\r\\n        address prev;\\r\\n        address next;\\r\\n    }\\r\\n\\r\\n    function accounts() external view returns (uint);\\r\\n    function accountID(address) external view returns (uint64);\\r\\n    function accountAddr(uint64) external view returns (address);\\r\\n    function userLink(address) external view returns (UserLink memory);\\r\\n    function userList(address, uint64) external view returns (UserList memory);\\r\\n    function accountLink(uint64) external view returns (AccountLink memory);\\r\\n    function accountList(uint64, address) external view returns (AccountList memory);\\r\\n}\\r\\n\\r\\n\\r\\ncontract Basics {\\r\\n    /**\\r\\n     * @dev Return Address.\\r\\n    */\\r\\n    address public immutable doughList;\\r\\n\\r\\n    constructor(address _doughList) {\\r\\n        doughList = _doughList;\\r\\n    }\\r\\n\\r\\n}\\r\\n\\r\\ncontract Helpers is Basics {\\r\\n    constructor(address _doughList) Basics(_doughList) {}\\r\\n\\r\\n    function checkAuthCount() internal view returns (uint count) {\\r\\n        ListInterface listContract = ListInterface(doughList);\\r\\n        uint64 accountId = listContract.accountID(address(this));\\r\\n        count = listContract.accountLink(accountId).count;\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract Auth is Helpers {\\r\\n    constructor(address _doughList) Helpers(_doughList) {}\\r\\n\\r\\n    event LogAddAuth(address indexed _msgSender, address indexed _authority);\\r\\n    event LogRemoveAuth(address indexed _msgSender, address indexed _authority);\\r\\n\\r\\n    /**\\r\\n     * @dev Add New authority\\r\\n     * @param authority authority Address.\\r\\n     */\\r\\n    function add(address authority) external payable returns (string memory _eventName, bytes memory _eventParam) {\\r\\n        AccountInterface(address(this)).enable(authority);\\r\\n\\r\\n        emit LogAddAuth(msg.sender, authority);\\r\\n\\r\\n        // _eventCode = keccak256(\\\"LogAddAuth(address,address)\\\");\\r\\n        _eventName = \\\"LogAddAuth(address,address)\\\";\\r\\n        _eventParam = abi.encode(msg.sender, authority);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Remove authority\\r\\n     * @param authority authority Address.\\r\\n     */\\r\\n    function remove(address authority) external payable returns (string memory _eventName, bytes memory _eventParam)  {\\r\\n        require(checkAuthCount() > 1, \\\"Removing-all-authorities\\\");\\r\\n        AccountInterface(address(this)).disable(authority);\\r\\n\\r\\n        emit LogRemoveAuth(msg.sender, authority);\\r\\n\\r\\n        // _eventCode = keccak256(\\\"LogRemoveAuth(address,address)\\\");\\r\\n        _eventName = \\\"LogRemoveAuth(address,address)\\\";\\r\\n        _eventParam = abi.encode(msg.sender, authority);\\r\\n    }\\r\\n\\r\\n}\\r\\n\\r\\n\\r\\ncontract ConnectV2Auth is Auth {\\r\\n    constructor(address _doughList) Auth(_doughList) {}\\r\\n    string public constant name = \\\"Auth-v1\\\";\\r\\n}\"\r\n    },\r\n    \"contracts/v2/connectors/test/betamode.test.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\n/**\\r\\n * @dev betamode connect\\r\\n */\\r\\n\\r\\ninterface AccountInterface {\\r\\n    function enable(address) external;\\r\\n    function disable(address) external;\\r\\n    function isAuth(address) external view returns (bool);\\r\\n    function isBeta() external view returns (bool);\\r\\n    function toggleBeta() external;\\r\\n}\\r\\n\\r\\ncontract Events {\\r\\n    event LogEnableBeta();\\r\\n    event LogDisableBeta();\\r\\n}\\r\\n\\r\\nabstract contract Resolver is Events {\\r\\n    /**\\r\\n     * @dev Enable beta mode\\r\\n     * @notice enabling beta mode gives early access to new/risky features\\r\\n     */\\r\\n    function enable() external payable returns (string memory _eventName, bytes memory _eventParam) {\\r\\n        AccountInterface _dsa = AccountInterface(address(this));\\r\\n        require(!_dsa.isBeta(), \\\"beta-already-enabled\\\");\\r\\n        _dsa.toggleBeta();\\r\\n\\r\\n        _eventName = \\\"LogEnableBeta()\\\";\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Disable beta mode\\r\\n     * @notice disabling beta mode removes early access to new/risky features\\r\\n     */\\r\\n    function disable() external payable returns (string memory _eventName, bytes memory _eventParam) {\\r\\n         AccountInterface _dsa = AccountInterface(address(this));\\r\\n        require(_dsa.isBeta(), \\\"beta-already-disabled\\\");\\r\\n        _dsa.toggleBeta();\\r\\n\\r\\n        _eventName = \\\"LogDisableBeta()\\\";\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract ConnectV2Beta is Resolver {\\r\\n    string public constant name = \\\"Beta-v1\\\";\\r\\n}\"\r\n    },\r\n    \"contracts/v2/connectors/test/compound.test.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\ninterface CTokenInterface {\\r\\n    function mint(uint mintAmount) external returns (uint);\\r\\n    function redeem(uint redeemTokens) external returns (uint);\\r\\n    function borrow(uint borrowAmount) external returns (uint);\\r\\n    function repayBorrow(uint repayAmount) external returns (uint);\\r\\n    function repayBorrowBehalf(address borrower, uint repayAmount) external returns (uint); // For ERC20\\r\\n    function liquidateBorrow(address borrower, uint repayAmount, address cTokenCollateral) external returns (uint);\\r\\n\\r\\n    function borrowBalanceCurrent(address account) external returns (uint);\\r\\n    function redeemUnderlying(uint redeemAmount) external returns (uint);\\r\\n    function exchangeRateCurrent() external returns (uint);\\r\\n\\r\\n    function balanceOf(address owner) external view returns (uint256 balance);\\r\\n}\\r\\n\\r\\ninterface CETHInterface {\\r\\n    function mint() external payable;\\r\\n    function repayBorrow() external payable;\\r\\n    function repayBorrowBehalf(address borrower) external payable;\\r\\n    function liquidateBorrow(address borrower, address cTokenCollateral) external payable;\\r\\n}\\r\\n\\r\\ninterface TokenInterface {\\r\\n    function allowance(address, address) external view returns (uint);\\r\\n    function balanceOf(address) external view returns (uint);\\r\\n    function approve(address, uint) external;\\r\\n    function transfer(address, uint) external returns (bool);\\r\\n    function transferFrom(address, address, uint) external returns (bool);\\r\\n}\\r\\n\\r\\ninterface ComptrollerInterface {\\r\\n    function enterMarkets(address[] calldata cTokens) external returns (uint[] memory);\\r\\n    function exitMarket(address cTokenAddress) external returns (uint);\\r\\n    function getAssetsIn(address account) external view returns (address[] memory);\\r\\n    function getAccountLiquidity(address account) external view returns (uint, uint, uint);\\r\\n    function claimComp(address) external;\\r\\n}\\r\\n\\r\\ninterface DoughMapping {\\r\\n    function cTokenMapping(address) external view returns (address);\\r\\n}\\r\\n\\r\\ninterface MemoryInterface {\\r\\n    function getUint(uint _id) external returns (uint _num);\\r\\n    function setUint(uint _id, uint _val) external;\\r\\n}\\r\\n\\r\\ncontract DSMath {\\r\\n\\r\\n    function add(uint x, uint y) internal pure returns (uint z) {\\r\\n        require((z = x + y) >= x, \\\"math-not-safe\\\");\\r\\n    }\\r\\n\\r\\n    function mul(uint x, uint y) internal pure returns (uint z) {\\r\\n        require(y == 0 || (z = x * y) / y == x, \\\"math-not-safe\\\");\\r\\n    }\\r\\n\\r\\n    uint constant WAD = 10 ** 18;\\r\\n\\r\\n    function wmul(uint x, uint y) internal pure returns (uint z) {\\r\\n        z = add(mul(x, y), WAD / 2) / WAD;\\r\\n    }\\r\\n\\r\\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\\r\\n        z = add(mul(x, WAD), y / 2) / y;\\r\\n    }\\r\\n\\r\\n    function sub(uint x, uint y) internal pure returns (uint z) {\\r\\n        require((z = x - y) <= x, \\\"ds-math-sub-underflow\\\");\\r\\n    }\\r\\n\\r\\n}\\r\\n\\r\\n\\r\\ncontract Helpers is DSMath {\\r\\n    /**\\r\\n     * @dev Return ethereum address\\r\\n     */\\r\\n    function getAddressETH() internal pure returns (address) {\\r\\n        return 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE; // ETH Address\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Return Memory Variable Address\\r\\n     */\\r\\n    function getMemoryAddr() internal pure returns (address) {\\r\\n        return 0x8a5419CfC711B2343c17a6ABf4B2bAFaBb06957F; // DoughMemory Address\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Get Uint value from DoughMemory Contract.\\r\\n    */\\r\\n    function getUint(uint getId, uint val) internal returns (uint returnVal) {\\r\\n        returnVal = getId == 0 ? val : MemoryInterface(getMemoryAddr()).getUint(getId);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Set Uint value in DoughMemory Contract.\\r\\n    */\\r\\n    function setUint(uint setId, uint val) internal {\\r\\n        if (setId != 0) MemoryInterface(getMemoryAddr()).setUint(setId, val);\\r\\n    }\\r\\n}\\r\\n\\r\\n\\r\\ncontract CompoundHelpers is Helpers {\\r\\n    /**\\r\\n     * @dev Return Compound Comptroller Address\\r\\n     */\\r\\n    function getComptrollerAddress() internal pure returns (address) {\\r\\n        return 0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Return COMP Token Address.\\r\\n     */\\r\\n    function getCompTokenAddress() internal pure returns (address) {\\r\\n        return 0xc00e94Cb662C3520282E6f5717214004A7f26888;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Return DoughDApp Mapping Addresses\\r\\n     */\\r\\n    function getMappingAddr() internal pure returns (address) {\\r\\n        return 0xe81F70Cc7C0D46e12d70efc60607F16bbD617E88; // DoughMapping Address\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev enter compound market\\r\\n     */\\r\\n    function enterMarket(address cToken) internal {\\r\\n        ComptrollerInterface troller = ComptrollerInterface(getComptrollerAddress());\\r\\n        address[] memory markets = troller.getAssetsIn(address(this));\\r\\n        bool isEntered = false;\\r\\n        for (uint i = 0; i < markets.length; i++) {\\r\\n            if (markets[i] == cToken) {\\r\\n                isEntered = true;\\r\\n            }\\r\\n        }\\r\\n        if (!isEntered) {\\r\\n            address[] memory toEnter = new address[](1);\\r\\n            toEnter[0] = cToken;\\r\\n            troller.enterMarkets(toEnter);\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\\r\\n\\r\\ncontract BasicResolver is CompoundHelpers {\\r\\n    event LogDeposit(address indexed token, address cToken, uint256 tokenAmt, uint256 getId, uint256 setId);\\r\\n    event LogWithdraw(address indexed token, address cToken, uint256 tokenAmt, uint256 getId, uint256 setId);\\r\\n    event LogBorrow(address indexed token, address cToken, uint256 tokenAmt, uint256 getId, uint256 setId);\\r\\n    event LogPayback(address indexed token, address cToken, uint256 tokenAmt, uint256 getId, uint256 setId);\\r\\n\\r\\n    /**\\r\\n     * @dev Deposit ETH/ERC20_Token.\\r\\n     * @param token token address to deposit.(For ETH: 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)\\r\\n     * @param amt token amount to deposit.\\r\\n     * @param getId Get token amount at this ID from `DoughMemory` Contract.\\r\\n     * @param setId Set token amount at this ID in `DoughMemory` Contract.\\r\\n    */\\r\\n    function deposit(\\r\\n        address token,\\r\\n        uint amt,\\r\\n        uint getId,\\r\\n        uint setId\\r\\n    ) external payable returns (string memory _eventName, bytes memory _eventParam) {\\r\\n        uint _amt = getUint(getId, amt);\\r\\n        address cToken = DoughMapping(getMappingAddr()).cTokenMapping(token);\\r\\n        enterMarket(cToken);\\r\\n        if (token == getAddressETH()) {\\r\\n            _amt = _amt == uint(-1) ? address(this).balance : _amt;\\r\\n            CETHInterface(cToken).mint{value: _amt}();\\r\\n        } else {\\r\\n            TokenInterface tokenContract = TokenInterface(token);\\r\\n            _amt = _amt == uint(-1) ? tokenContract.balanceOf(address(this)) : _amt;\\r\\n            tokenContract.approve(cToken, _amt);\\r\\n            require(CTokenInterface(cToken).mint(_amt) == 0, \\\"deposit-failed\\\");\\r\\n        }\\r\\n        setUint(setId, _amt);\\r\\n\\r\\n        emit LogDeposit(token, cToken, _amt, getId, setId);\\r\\n\\r\\n        _eventName = \\\"LogDeposit(address,address,uint256,uint256,uint256)\\\";\\r\\n        _eventParam = abi.encode(token, cToken, _amt, getId, setId);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Withdraw ETH/ERC20_Token.\\r\\n     * @param token token address to withdraw.(For ETH: 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)\\r\\n     * @param amt token amount to withdraw.\\r\\n     * @param getId Get token amount at this ID from `DoughMemory` Contract.\\r\\n     * @param setId Set token amount at this ID in `DoughMemory` Contract.\\r\\n    */\\r\\n    function withdraw(\\r\\n        address token,\\r\\n        uint amt,\\r\\n        uint getId,\\r\\n        uint setId\\r\\n    ) external payable returns (string memory _eventName, bytes memory _eventParam) {\\r\\n        uint _amt = getUint(getId, amt);\\r\\n        address cToken = DoughMapping(getMappingAddr()).cTokenMapping(token);\\r\\n        CTokenInterface cTokenContract = CTokenInterface(cToken);\\r\\n        if (_amt == uint(-1)) {\\r\\n            TokenInterface tokenContract = TokenInterface(token);\\r\\n            uint initialBal = token == getAddressETH() ? address(this).balance : tokenContract.balanceOf(address(this));\\r\\n            require(cTokenContract.redeem(cTokenContract.balanceOf(address(this))) == 0, \\\"full-withdraw-failed\\\");\\r\\n            uint finalBal = token == getAddressETH() ? address(this).balance : tokenContract.balanceOf(address(this));\\r\\n            _amt = finalBal - initialBal;\\r\\n        } else {\\r\\n            require(cTokenContract.redeemUnderlying(_amt) == 0, \\\"withdraw-failed\\\");\\r\\n        }\\r\\n        setUint(setId, _amt);\\r\\n\\r\\n        emit LogWithdraw(token, cToken, _amt, getId, setId);\\r\\n\\r\\n        _eventName = \\\"LogWithdraw(address,address,uint256,uint256,uint256)\\\";\\r\\n        _eventParam = abi.encode(token, cToken, _amt, getId, setId);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Borrow ETH/ERC20_Token.\\r\\n     * @param token token address to borrow.(For ETH: 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)\\r\\n     * @param amt token amount to borrow.\\r\\n     * @param getId Get token amount at this ID from `DoughMemory` Contract.\\r\\n     * @param setId Set token amount at this ID in `DoughMemory` Contract.\\r\\n    */\\r\\n    function borrow(\\r\\n        address token,\\r\\n        uint amt,\\r\\n        uint getId,\\r\\n        uint setId\\r\\n    ) external payable returns (string memory _eventName, bytes memory _eventParam) {\\r\\n        uint _amt = getUint(getId, amt);\\r\\n        address cToken = DoughMapping(getMappingAddr()).cTokenMapping(token);\\r\\n        enterMarket(cToken);\\r\\n        require(CTokenInterface(cToken).borrow(_amt) == 0, \\\"borrow-failed\\\");\\r\\n        setUint(setId, _amt);\\r\\n\\r\\n        emit LogBorrow(token, cToken, _amt, getId, setId);\\r\\n\\r\\n        _eventName = \\\"LogBorrow(address,address,uint256,uint256,uint256)\\\";\\r\\n        _eventParam = abi.encode(token, cToken, _amt, getId, setId);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Payback borrowed ETH/ERC20_Token.\\r\\n     * @param token token address to payback.(For ETH: 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)\\r\\n     * @param amt token amount to payback.\\r\\n     * @param getId Get token amount at this ID from `DoughMemory` Contract.\\r\\n     * @param setId Set token amount at this ID in `DoughMemory` Contract.\\r\\n    */\\r\\n    function payback(\\r\\n        address token,\\r\\n        uint amt,\\r\\n        uint getId,\\r\\n        uint setId\\r\\n    ) external payable returns (string memory _eventName, bytes memory _eventParam) {\\r\\n        uint _amt = getUint(getId, amt);\\r\\n        address cToken = DoughMapping(getMappingAddr()).cTokenMapping(token);\\r\\n        CTokenInterface cTokenContract = CTokenInterface(cToken);\\r\\n        _amt = _amt == uint(-1) ? cTokenContract.borrowBalanceCurrent(address(this)) : _amt;\\r\\n\\r\\n        if (token == getAddressETH()) {\\r\\n            require(address(this).balance >= _amt, \\\"not-enough-eth\\\");\\r\\n            CETHInterface(cToken).repayBorrow{value: _amt}();\\r\\n        } else {\\r\\n            TokenInterface tokenContract = TokenInterface(token);\\r\\n            require(tokenContract.balanceOf(address(this)) >= _amt, \\\"not-enough-token\\\");\\r\\n            tokenContract.approve(cToken, _amt);\\r\\n            require(cTokenContract.repayBorrow(_amt) == 0, \\\"repay-failed.\\\");\\r\\n        }\\r\\n        setUint(setId, _amt);\\r\\n\\r\\n        emit LogPayback(token, cToken, _amt, getId, setId);\\r\\n\\r\\n        _eventName = \\\"LogPayback(address,address,uint256,uint256,uint256)\\\";\\r\\n        _eventParam = abi.encode(token, cToken, _amt, getId, setId);\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract ConnectCompound is BasicResolver {\\r\\n    string public name = \\\"Compound-v1\\\";\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/v2/connectors/test/connector.registry.test.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.7.0;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\n/**\\r\\n * @title DoughConnectorsV2\\r\\n * @dev Registry for Connectors.\\r\\n */\\r\\n\\r\\ninterface IndexInterface {\\r\\n    function master() external view returns (address);\\r\\n}\\r\\n\\r\\ninterface ConnectorInterface {\\r\\n    function name() external view returns (string memory);\\r\\n}\\r\\n\\r\\ncontract Controllers {\\r\\n    event LogController(address indexed addr, bool indexed isChief);\\r\\n\\r\\n    // DoughIndex Address.\\r\\n    address public immutable doughIndex;\\r\\n\\r\\n    constructor(address _doughIndex) {\\r\\n        doughIndex = _doughIndex;\\r\\n    }\\r\\n\\r\\n    // Enabled Chief(Address of Chief => bool).\\r\\n    mapping(address => bool) public chief;\\r\\n    // Enabled Connectors(Connector name => address).\\r\\n    mapping(string => address) public connectors;\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if the sender not is Master Address from DoughIndex\\r\\n     * or Enabled Chief.\\r\\n     */\\r\\n    modifier isChief() {\\r\\n        require(\\r\\n            chief[msg.sender] ||\\r\\n                msg.sender == IndexInterface(doughIndex).master(),\\r\\n            \\\"not-an-chief\\\"\\r\\n        );\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Toggle a Chief. Enable if disable & vice versa\\r\\n     * @param _chiefAddress Chief Address.\\r\\n     */\\r\\n    function toggleChief(address _chiefAddress) external {\\r\\n        require(\\r\\n            msg.sender == IndexInterface(doughIndex).master(),\\r\\n            \\\"toggleChief: not-master\\\"\\r\\n        );\\r\\n        chief[_chiefAddress] = !chief[_chiefAddress];\\r\\n        emit LogController(_chiefAddress, chief[_chiefAddress]);\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract DoughConnectorsV2Test is Controllers {\\r\\n    event LogConnectorAdded(\\r\\n        bytes32 indexed connectorNameHash,\\r\\n        string connectorName,\\r\\n        address indexed connector\\r\\n    );\\r\\n    event LogConnectorUpdated(\\r\\n        bytes32 indexed connectorNameHash,\\r\\n        string connectorName,\\r\\n        address indexed oldConnector,\\r\\n        address indexed newConnector\\r\\n    );\\r\\n    event LogConnectorRemoved(\\r\\n        bytes32 indexed connectorNameHash,\\r\\n        string connectorName,\\r\\n        address indexed connector\\r\\n    );\\r\\n\\r\\n    constructor(address _doughIndex) public Controllers(_doughIndex) {}\\r\\n\\r\\n    /**\\r\\n     * @dev Add Connectors\\r\\n     * @param _connectorNames Array of Connector Names.\\r\\n     * @param _connectors Array of Connector Address.\\r\\n     */\\r\\n    function addConnectors(\\r\\n        string[] calldata _connectorNames,\\r\\n        address[] calldata _connectors\\r\\n    ) external isChief {\\r\\n        require(\\r\\n            _connectorNames.length == _connectors.length,\\r\\n            \\\"addConnectors: not same length\\\"\\r\\n        );\\r\\n        for (uint256 i = 0; i < _connectors.length; i++) {\\r\\n            require(\\r\\n                connectors[_connectorNames[i]] == address(0),\\r\\n                \\\"addConnectors: _connectorName added already\\\"\\r\\n            );\\r\\n            require(\\r\\n                _connectors[i] != address(0),\\r\\n                \\\"addConnectors: _connectors address not vaild\\\"\\r\\n            );\\r\\n            ConnectorInterface(_connectors[i]).name(); // Checking if connector has function name()\\r\\n            connectors[_connectorNames[i]] = _connectors[i];\\r\\n            emit LogConnectorAdded(\\r\\n                keccak256(abi.encodePacked(_connectorNames[i])),\\r\\n                _connectorNames[i],\\r\\n                _connectors[i]\\r\\n            );\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Update Connectors\\r\\n     * @param _connectorNames Array of Connector Names.\\r\\n     * @param _connectors Array of Connector Address.\\r\\n     */\\r\\n    function updateConnectors(\\r\\n        string[] calldata _connectorNames,\\r\\n        address[] calldata _connectors\\r\\n    ) external isChief {\\r\\n        require(\\r\\n            _connectorNames.length == _connectors.length,\\r\\n            \\\"updateConnectors: not same length\\\"\\r\\n        );\\r\\n        for (uint256 i = 0; i < _connectors.length; i++) {\\r\\n            require(\\r\\n                connectors[_connectorNames[i]] != address(0),\\r\\n                \\\"updateConnectors: _connectorName not added to update\\\"\\r\\n            );\\r\\n            require(\\r\\n                _connectors[i] != address(0),\\r\\n                \\\"updateConnectors: _connector address is not vaild\\\"\\r\\n            );\\r\\n            ConnectorInterface(_connectors[i]).name(); // Checking if connector has function name()\\r\\n            emit LogConnectorUpdated(\\r\\n                keccak256(abi.encodePacked(_connectorNames[i])),\\r\\n                _connectorNames[i],\\r\\n                connectors[_connectorNames[i]],\\r\\n                _connectors[i]\\r\\n            );\\r\\n            connectors[_connectorNames[i]] = _connectors[i];\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Remove Connectors\\r\\n     * @param _connectorNames Array of Connector Names.\\r\\n     */\\r\\n    function removeConnectors(string[] calldata _connectorNames)\\r\\n        external\\r\\n        isChief\\r\\n    {\\r\\n        for (uint256 i = 0; i < _connectorNames.length; i++) {\\r\\n            require(\\r\\n                connectors[_connectorNames[i]] != address(0),\\r\\n                \\\"removeConnectors: _connectorName not added to update\\\"\\r\\n            );\\r\\n            emit LogConnectorRemoved(\\r\\n                keccak256(abi.encodePacked(_connectorNames[i])),\\r\\n                _connectorNames[i],\\r\\n                connectors[_connectorNames[i]]\\r\\n            );\\r\\n            delete connectors[_connectorNames[i]];\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Check if Connector addresses are enabled.\\r\\n     * @param _connectors Array of Connector Names.\\r\\n     */\\r\\n    function isConnectors(string[] calldata _connectorNames)\\r\\n        external\\r\\n        view\\r\\n        returns (bool isOk, address[] memory _connectors)\\r\\n    {\\r\\n        isOk = true;\\r\\n        uint256 len = _connectorNames.length;\\r\\n        _connectors = new address[](len);\\r\\n        for (uint256 i = 0; i < _connectors.length; i++) {\\r\\n            _connectors[i] = connectors[_connectorNames[i]];\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/v2/connectors/test/emitEvent.test.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\ncontract ConnectV2EmitEvent {\\r\\n\\r\\n    event LogEmitEvent(address indexed dsaAddress, address indexed _sender);\\r\\n\\r\\n    function emitEvent() public payable returns (string memory _eventName, bytes memory _eventParam) {\\r\\n        emit LogEmitEvent(address(this), msg.sender);\\r\\n\\r\\n        _eventName = \\\"LogEmitEvent(address,address)\\\";\\r\\n        _eventParam = abi.encode(address(this), msg.sender);\\r\\n    }\\r\\n\\r\\n    string constant public name = \\\"EmitEvent-v1\\\";\\r\\n}\"\r\n    },\r\n    \"contracts/v2/proxy/accountProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\ninterface AccountImplementations {\\r\\n    function getImplementation(bytes4 _sig) external view returns (address);\\r\\n}\\r\\n\\r\\n/**\\r\\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\\r\\n * instruction `delegatecall`.\\r\\n */\\r\\ncontract DoughAccountV2 {\\r\\n\\r\\n    AccountImplementations public immutable implementations;\\r\\n\\r\\n    constructor(address _implementations) {\\r\\n        implementations = AccountImplementations(_implementations);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Delegates the current call to `implementation`.\\r\\n     * \\r\\n     * This function does not return to its internall call site, it will return directly to the external caller.\\r\\n     */\\r\\n    function _delegate(address implementation) internal {\\r\\n        // solhint-disable-next-line no-inline-assembly\\r\\n        assembly {\\r\\n            // Copy msg.data. We take full control of memory in this inline assembly\\r\\n            // block because it will not return to Solidity code. We overwrite the\\r\\n            // Solidity scratch pad at memory position 0.\\r\\n            calldatacopy(0, 0, calldatasize())\\r\\n\\r\\n            // Call the implementation.\\r\\n            // out and outsize are 0 because we don't know the size yet.\\r\\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\\r\\n\\r\\n            // Copy the returned data.\\r\\n            returndatacopy(0, 0, returndatasize())\\r\\n\\r\\n            switch result\\r\\n            // delegatecall returns 0 on error.\\r\\n            case 0 { revert(0, returndatasize()) }\\r\\n            default { return(0, returndatasize()) }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Delegates the current call to the address returned by Implementations registry.\\r\\n     * \\r\\n     * This function does not return to its internall call site, it will return directly to the external caller.\\r\\n     */\\r\\n    function _fallback(bytes4 _sig) internal {\\r\\n        address _implementation = implementations.getImplementation(_sig);\\r\\n        require(_implementation != address(0), \\\"DoughAccountV2: Not able to find _implementation\\\");\\r\\n        _delegate(_implementation);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Fallback function that delegates calls to the address returned by Implementations registry.\\r\\n     */\\r\\n    fallback () external payable {\\r\\n        _fallback(msg.sig);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Fallback function that delegates calls to the address returned by Implementations registry.\\r\\n     */\\r\\n    receive () external payable {\\r\\n        if (msg.sig != 0x00000000) {\\r\\n            _fallback(msg.sig);\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/v2/proxy/dummyConnectorsImpl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\ncontract DoughConnectorsV2Impl  {\\r\\n\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/v2/registry/connectors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.7.0;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\n/**\\r\\n * @title DoughConnectorsV2\\r\\n * @dev Registry for Connectors.\\r\\n */\\r\\n\\r\\ninterface IndexInterface {\\r\\n    function master() external view returns (address);\\r\\n}\\r\\n\\r\\ninterface ConnectorInterface {\\r\\n    function name() external view returns (string memory);\\r\\n}\\r\\n\\r\\ncontract Controllers {\\r\\n\\r\\n    event LogController(address indexed addr, bool indexed isChief);\\r\\n\\r\\n    // DoughIndex Address.\\r\\n    address public immutable doughIndex;\\r\\n\\r\\n    constructor(address _doughIndex) {\\r\\n        doughIndex = _doughIndex;\\r\\n    }\\r\\n\\r\\n    // Enabled Chief(Address of Chief => bool).\\r\\n    mapping(address => bool) public chief;\\r\\n    // Enabled Connectors(Connector name => address).\\r\\n    mapping(string => address) public connectors;\\r\\n\\r\\n    /**\\r\\n    * @dev Throws if the sender not is Master Address from DoughIndex\\r\\n    * or Enabled Chief.\\r\\n    */\\r\\n    modifier isChief {\\r\\n        require(chief[msg.sender] || msg.sender == IndexInterface(doughIndex).master(), \\\"not-an-chief\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Toggle a Chief. Enable if disable & vice versa\\r\\n     * @param _chiefAddress Chief Address.\\r\\n    */\\r\\n    function toggleChief(address _chiefAddress) external {\\r\\n        require(msg.sender == IndexInterface(doughIndex).master(), \\\"toggleChief: not-master\\\");\\r\\n        chief[_chiefAddress] = !chief[_chiefAddress];\\r\\n        emit LogController(_chiefAddress, chief[_chiefAddress]);\\r\\n    }\\r\\n}\\r\\n\\r\\n\\r\\ncontract DoughConnectorsV2 is Controllers {\\r\\n    event LogConnectorAdded(\\r\\n        bytes32 indexed connectorNameHash,\\r\\n        string connectorName,\\r\\n        address indexed connector\\r\\n    );\\r\\n    event LogConnectorUpdated(\\r\\n        bytes32 indexed connectorNameHash,\\r\\n        string connectorName,\\r\\n        address indexed oldConnector,\\r\\n        address indexed newConnector\\r\\n    );\\r\\n    event LogConnectorRemoved(\\r\\n        bytes32 indexed connectorNameHash,\\r\\n        string connectorName,\\r\\n        address indexed connector\\r\\n    );\\r\\n\\r\\n    constructor(address _doughIndex) public Controllers(_doughIndex) {}\\r\\n\\r\\n    /**\\r\\n     * @dev Add Connectors\\r\\n     * @param _connectorNames Array of Connector Names.\\r\\n     * @param _connectors Array of Connector Address.\\r\\n    */\\r\\n    function addConnectors(string[] calldata _connectorNames, address[] calldata _connectors) external isChief {\\r\\n        require(_connectorNames.length == _connectors.length, \\\"addConnectors: not same length\\\");\\r\\n        for (uint i = 0; i < _connectors.length; i++) {\\r\\n            require(connectors[_connectorNames[i]] == address(0), \\\"addConnectors: _connectorName added already\\\");\\r\\n            require(_connectors[i] != address(0), \\\"addConnectors: _connectors address not vaild\\\");\\r\\n            ConnectorInterface(_connectors[i]).name(); // Checking if connector has function name()\\r\\n            connectors[_connectorNames[i]] = _connectors[i];\\r\\n            emit LogConnectorAdded(keccak256(abi.encodePacked(_connectorNames[i])), _connectorNames[i], _connectors[i]);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Update Connectors\\r\\n     * @param _connectorNames Array of Connector Names.\\r\\n     * @param _connectors Array of Connector Address.\\r\\n    */\\r\\n    function updateConnectors(string[] calldata _connectorNames, address[] calldata _connectors) external isChief {\\r\\n        require(_connectorNames.length == _connectors.length, \\\"updateConnectors: not same length\\\");\\r\\n        for (uint i = 0; i < _connectors.length; i++) {\\r\\n            require(connectors[_connectorNames[i]] != address(0), \\\"updateConnectors: _connectorName not added to update\\\");\\r\\n            require(_connectors[i] != address(0), \\\"updateConnectors: _connector address is not vaild\\\");\\r\\n            ConnectorInterface(_connectors[i]).name(); // Checking if connector has function name()\\r\\n            emit LogConnectorUpdated(keccak256(abi.encodePacked(_connectorNames[i])), _connectorNames[i], connectors[_connectorNames[i]], _connectors[i]);\\r\\n            connectors[_connectorNames[i]] = _connectors[i];\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Remove Connectors\\r\\n     * @param _connectorNames Array of Connector Names.\\r\\n    */\\r\\n    function removeConnectors(string[] calldata _connectorNames) external isChief {\\r\\n        for (uint i = 0; i < _connectorNames.length; i++) {\\r\\n            require(connectors[_connectorNames[i]] != address(0), \\\"removeConnectors: _connectorName not added to update\\\");\\r\\n            emit LogConnectorRemoved(keccak256(abi.encodePacked(_connectorNames[i])), _connectorNames[i], connectors[_connectorNames[i]]);\\r\\n            delete connectors[_connectorNames[i]];\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Check if Connector addresses are enabled.\\r\\n     * @param _connectors Array of Connector Names.\\r\\n    */\\r\\n    function isConnectors(string[] calldata _connectorNames) external view returns (bool isOk, address[] memory _connectors) {\\r\\n        isOk = true;\\r\\n        uint len = _connectorNames.length;\\r\\n        _connectors = new address[](len);\\r\\n        for (uint i = 0; i < _connectors.length; i++) {\\r\\n            _connectors[i] = connectors[_connectorNames[i]];\\r\\n            if (_connectors[i] == address(0)) {\\r\\n                isOk = false;\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/v2/registry/implementations.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\ninterface IndexInterface {\\r\\n    function master() external view returns (address);\\r\\n}\\r\\n\\r\\ncontract Setup {\\r\\n    address public defaultImplementation;\\r\\n\\r\\n    mapping (bytes4 => address) internal sigImplementations;\\r\\n\\r\\n    mapping (address => bytes4[]) internal implementationSigs;\\r\\n}\\r\\n\\r\\ncontract Implementations is Setup {\\r\\n    event LogSetDefaultImplementation(address indexed oldImplementation, address indexed newImplementation);\\r\\n    event LogAddImplementation(address indexed implementation, bytes4[] sigs);\\r\\n    event LogRemoveImplementation(address indexed implementation, bytes4[] sigs);\\r\\n\\r\\n    IndexInterface immutable public doughIndex;\\r\\n\\r\\n    constructor(address _doughIndex) {\\r\\n        doughIndex = IndexInterface(_doughIndex);\\r\\n    }\\r\\n\\r\\n    modifier isMaster() {\\r\\n        require(msg.sender == doughIndex.master(), \\\"Implementations: not-master\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function setDefaultImplementation(address _defaultImplementation) external isMaster {\\r\\n        require(_defaultImplementation != address(0), \\\"Implementations: _defaultImplementation address not valid\\\");\\r\\n        require(_defaultImplementation != defaultImplementation, \\\"Implementations: _defaultImplementation cannot be same\\\");\\r\\n        emit LogSetDefaultImplementation(defaultImplementation, _defaultImplementation);\\r\\n        defaultImplementation = _defaultImplementation;\\r\\n    }\\r\\n\\r\\n    function addImplementation(address _implementation, bytes4[] calldata _sigs) external isMaster {\\r\\n        require(_implementation != address(0), \\\"Implementations: _implementation not valid.\\\");\\r\\n        require(implementationSigs[_implementation].length == 0, \\\"Implementations: _implementation already added.\\\");\\r\\n        for (uint i = 0; i < _sigs.length; i++) {\\r\\n            bytes4 _sig = _sigs[i];\\r\\n            require(sigImplementations[_sig] == address(0), \\\"Implementations: _sig already added\\\");\\r\\n            sigImplementations[_sig] = _implementation;\\r\\n        }\\r\\n        implementationSigs[_implementation] = _sigs;\\r\\n        emit LogAddImplementation(_implementation, _sigs);\\r\\n    }\\r\\n\\r\\n    function removeImplementation(address _implementation) external isMaster {\\r\\n        require(_implementation != address(0), \\\"Implementations: _implementation not valid.\\\");\\r\\n        require(implementationSigs[_implementation].length != 0, \\\"Implementations: _implementation not found.\\\");\\r\\n        bytes4[] memory sigs = implementationSigs[_implementation];\\r\\n        for (uint i = 0; i < sigs.length; i++) {\\r\\n            bytes4 sig = sigs[i];\\r\\n            delete sigImplementations[sig];\\r\\n        }\\r\\n        delete implementationSigs[_implementation];\\r\\n        emit LogRemoveImplementation(_implementation, sigs);\\r\\n\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract DoughImplementations is Implementations {\\r\\n    constructor(address _doughIndex) public Implementations(_doughIndex) {}\\r\\n\\r\\n    function getImplementation(bytes4 _sig) external view returns (address) {\\r\\n        address _implementation = sigImplementations[_sig];\\r\\n        return _implementation == address(0) ? defaultImplementation : _implementation;\\r\\n    }\\r\\n\\r\\n    function getImplementationSigs(address _impl) external view returns (bytes4[] memory) {\\r\\n        return implementationSigs[_impl];\\r\\n    }\\r\\n\\r\\n    function getSigImplementation(bytes4 _sig) external view returns (address) {\\r\\n        return sigImplementations[_sig];\\r\\n    }\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"getAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"getBytes\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"_byte\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"getUint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_num\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setAddr\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_byte\",\"type\":\"bytes32\"}],\"name\":\"setBytes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_num\",\"type\":\"uint256\"}],\"name\":\"setUint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "DoughMemory", "CompilerVersion": "v0.7.0+commit.9e61f92b", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://01eb38114c99ed31688a2ec7adfc7669362566e50298b03fbe223cbed51e571e"}