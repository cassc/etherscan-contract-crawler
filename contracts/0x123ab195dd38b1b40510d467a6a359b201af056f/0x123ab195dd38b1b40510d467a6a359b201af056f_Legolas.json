{"SourceCode": "pragma solidity ^0.4.13;\r\n\r\ncontract EIP20Interface {\r\n    /* This is a slight change to the ERC20 base standard.\r\n    function totalSupply() constant returns (uint256 supply);\r\n    is replaced with:\r\n    uint256 public totalSupply;\r\n    This automatically creates a getter function for the totalSupply.\r\n    This is moved to the base contract since public getter functions are not\r\n    currently recognised as an implementation of the matching abstract\r\n    function by the compiler.\r\n    */\r\n    /// total amount of tokens\r\n    uint256 public totalSupply;\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) public view returns (uint256 balance);\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n\r\n    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of tokens to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) public returns (bool success);\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining);\r\n\r\n    // solhint-disable-next-line no-simple-event-func-name\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\ncontract Ownable {\r\n    address public owner;\r\n    address public newOwner;\r\n\r\n    event OwnershipTransferred(address indexed _from, address indexed _to);\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function Ownable() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /// @notice Transfer ownership from `owner` to `newOwner`\r\n    /// @param _newOwner The new contract owner\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n        if (_newOwner != address(0)) {\r\n            newOwner = _newOwner;\r\n        }\r\n    }\r\n\r\n    /// @notice accept ownership of the contract\r\n    function acceptOwnership() public {\r\n        require(msg.sender == newOwner);\r\n        OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n}\r\n\r\ncontract LegolasBase is Ownable {\r\n\r\n    mapping (address => uint256) public balances;\r\n\r\n    // Initial amount received from the pre-sale (doesn't include bonus)\r\n    mapping (address => uint256) public initialAllocations;\r\n    // Initial amount received from the pre-sale (includes bonus)\r\n    mapping (address => uint256) public allocations;\r\n    // False if part of the allocated amount is spent\r\n    mapping (uint256 => mapping(address => bool)) public eligibleForBonus;\r\n    // unspent allocated amount by period\r\n    mapping (uint256 => uint256) public unspentAmounts;\r\n    // List of founders addresses\r\n    mapping (address => bool) public founders;\r\n    // List of advisors addresses\r\n    mapping (address => bool) public advisors;\r\n\r\n    // Release dates for adviors: one twelfth released each month.\r\n    uint256[12] public ADVISORS_LOCK_DATES = [1521072000, 1523750400, 1526342400,\r\n                                       1529020800, 1531612800, 1534291200,\r\n                                       1536969600, 1539561600, 1542240000,\r\n                                       1544832000, 1547510400, 1550188800];\r\n    // Release dates for founders: After one year, one twelfth released each month.\r\n    uint256[12] public FOUNDERS_LOCK_DATES = [1552608000, 1555286400, 1557878400,\r\n                                       1560556800, 1563148800, 1565827200,\r\n                                       1568505600, 1571097600, 1573776000,\r\n                                       1576368000, 1579046400, 1581724800];\r\n\r\n    // Bonus dates: each 6 months during 2 years\r\n    uint256[4] public BONUS_DATES = [1534291200, 1550188800, 1565827200, 1581724800];\r\n\r\n    /// @param _address The address from which the locked amount will be retrieved\r\n    /// @return The amount locked for _address.\r\n    function getLockedAmount(address _address) internal view returns (uint256 lockedAmount) {\r\n        // Only founders and advisors have locks\r\n        if (!advisors[_address] && !founders[_address]) return 0;\r\n        // Determine release dates\r\n        uint256[12] memory lockDates = advisors[_address] ? ADVISORS_LOCK_DATES : FOUNDERS_LOCK_DATES;\r\n        // Determine how many twelfths are locked\r\n        for (uint8 i = 11; i >= 0; i--) {\r\n            if (now >= lockDates[i]) {\r\n                return (allocations[_address] / 12) * (11 - i);\r\n            }\r\n        }\r\n        return allocations[_address];\r\n    }\r\n\r\n    function updateBonusEligibity(address _from) internal {\r\n        if (now < BONUS_DATES[3] &&\r\n            initialAllocations[_from] > 0 &&\r\n            balances[_from] < allocations[_from]) {\r\n            for (uint8 i = 0; i < 4; i++) {\r\n                if (now < BONUS_DATES[i] && eligibleForBonus[BONUS_DATES[i]][_from]) {\r\n                    unspentAmounts[BONUS_DATES[i]] -= initialAllocations[_from];\r\n                    eligibleForBonus[BONUS_DATES[i]][_from] = false;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ncontract EIP20 is EIP20Interface, LegolasBase {\r\n\r\n    uint256 constant private MAX_UINT256 = 2**256 - 1;\r\n    mapping (address => mapping (address => uint256)) public allowed;\r\n\r\n\r\n    /*\r\n    NOTE:\r\n    The following variables are OPTIONAL vanities. One does not have to include them.\r\n    They allow one to customise the token contract & in no way influences the core functionality.\r\n    Some wallets/interfaces might not even bother to look at this information.\r\n    */\r\n    string public name;                   //fancy name: eg Simon Bucks\r\n    uint8 public decimals;                //How many decimals to show.\r\n    string public symbol;                 //An identifier: eg SBX\r\n\r\n    function EIP20(\r\n        uint256 _initialAmount,\r\n        string _tokenName,\r\n        uint8 _decimalUnits,\r\n        string _tokenSymbol\r\n    ) public {\r\n        balances[msg.sender] = _initialAmount;               // Give the creator all initial tokens\r\n        totalSupply = _initialAmount;                        // Update total supply\r\n        name = _tokenName;                                   // Set the name for display purposes\r\n        decimals = _decimalUnits;                            // Amount of decimals for display purposes\r\n        symbol = _tokenSymbol;                               // Set the symbol for display purposes\r\n    }\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool success) {\r\n        require(balances[msg.sender] >= _value);\r\n        // Check locked amount\r\n        require(balances[msg.sender] - _value >= getLockedAmount(msg.sender));\r\n        balances[msg.sender] -= _value;\r\n        balances[_to] += _value;\r\n\r\n        // Bonus lost if balance is lower than the original allocation\r\n        updateBonusEligibity(msg.sender);\r\n\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n        uint256 allowance = allowed[_from][msg.sender];\r\n        require(balances[_from] >= _value && allowance >= _value);\r\n\r\n        // Check locked amount\r\n        require(balances[_from] - _value >= getLockedAmount(_from));\r\n\r\n        balances[_to] += _value;\r\n        balances[_from] -= _value;\r\n        if (allowance < MAX_UINT256) {\r\n            allowed[_from][msg.sender] -= _value;\r\n        }\r\n\r\n        // Bonus lost if balance is lower than the original allocation\r\n        updateBonusEligibity(_from);\r\n\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function balanceOf(address _owner) public view returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) public returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n}\r\n\r\ncontract Legolas is EIP20 {\r\n\r\n    // Standard ERC20 information\r\n    string  constant NAME = \"LGO Token\";\r\n    string  constant SYMBOL = \"LGO\";\r\n    uint8   constant DECIMALS = 8;\r\n    uint256 constant UNIT = 10**uint256(DECIMALS);\r\n\r\n    uint256 constant onePercent = 181415052000000;\r\n\r\n    // 5% for advisors\r\n    uint256 constant ADVISORS_AMOUNT =   5 * onePercent;\r\n    // 15% for founders\r\n    uint256 constant FOUNDERS_AMOUNT =  15 * onePercent;\r\n    // 60% sold in pre-sale\r\n    uint256 constant HOLDERS_AMOUNT  =  60 * onePercent;\r\n    // 20% reserve\r\n    uint256 constant RESERVE_AMOUNT  =  20 * onePercent;\r\n    // ADVISORS_AMOUNT + FOUNDERS_AMOUNT + HOLDERS_AMOUNT +RESERVE_AMOUNT\r\n    uint256 constant INITIAL_AMOUNT  = 100 * onePercent;\r\n    // 20% for holder bonus\r\n    uint256 constant BONUS_AMOUNT    =  20 * onePercent;\r\n    // amount already allocated to advisors\r\n    uint256 public advisorsAllocatedAmount = 0;\r\n    // amount already allocated to funders\r\n    uint256 public foundersAllocatedAmount = 0;\r\n    // amount already allocated to holders\r\n    uint256 public holdersAllocatedAmount = 0;\r\n    // list of all initial holders\r\n    address[] initialHolders;\r\n    // not distributed because the defaut value is false\r\n    mapping (uint256 => mapping(address => bool)) bonusNotDistributed;\r\n\r\n    event Allocate(address _address, uint256 _value);\r\n\r\n    function Legolas() EIP20( // EIP20 constructor\r\n        INITIAL_AMOUNT + BONUS_AMOUNT,\r\n        NAME,\r\n        DECIMALS,\r\n        SYMBOL\r\n    ) public {}\r\n\r\n    /// @param _address The address of the recipient\r\n    /// @param _amount Amount of the allocation\r\n    /// @param _type Type of the recipient. 0 for advisor, 1 for founders.\r\n    /// @return Whether the allocation was successful or not\r\n    function allocate(address _address, uint256 _amount, uint8 _type) public onlyOwner returns (bool success) {\r\n        // one allocations by address\r\n        require(allocations[_address] == 0);\r\n\r\n        if (_type == 0) { // advisor\r\n            // check allocated amount\r\n            require(advisorsAllocatedAmount + _amount <= ADVISORS_AMOUNT);\r\n            // increase allocated amount\r\n            advisorsAllocatedAmount += _amount;\r\n            // mark address as advisor\r\n            advisors[_address] = true;\r\n        } else if (_type == 1) { // founder\r\n            // check allocated amount\r\n            require(foundersAllocatedAmount + _amount <= FOUNDERS_AMOUNT);\r\n            // increase allocated amount\r\n            foundersAllocatedAmount += _amount;\r\n            // mark address as founder\r\n            founders[_address] = true;\r\n        } else {\r\n            // check allocated amount\r\n            require(holdersAllocatedAmount + _amount <= HOLDERS_AMOUNT + RESERVE_AMOUNT);\r\n            // increase allocated amount\r\n            holdersAllocatedAmount += _amount;\r\n        }\r\n        // set allocation\r\n        allocations[_address] = _amount;\r\n        initialAllocations[_address] = _amount;\r\n\r\n        // increase balance\r\n        balances[_address] += _amount;\r\n\r\n        // update variables for bonus distribution\r\n        for (uint8 i = 0; i < 4; i++) {\r\n            // increase unspent amount\r\n            unspentAmounts[BONUS_DATES[i]] += _amount;\r\n            // initialize bonus eligibility\r\n            eligibleForBonus[BONUS_DATES[i]][_address] = true;\r\n            bonusNotDistributed[BONUS_DATES[i]][_address] = true;\r\n        }\r\n\r\n        // add to initial holders list\r\n        initialHolders.push(_address);\r\n\r\n        Allocate(_address, _amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @param _address Holder address.\r\n    /// @param _bonusDate Date of the bonus to distribute.\r\n    /// @return Whether the bonus distribution was successful or not\r\n    function claimBonus(address _address, uint256 _bonusDate) public returns (bool success) {\r\n        /// bonus date must be past\r\n        require(_bonusDate <= now);\r\n        /// disrtibute bonus only once\r\n        require(bonusNotDistributed[_bonusDate][_address]);\r\n        /// disrtibute bonus only if eligible\r\n        require(eligibleForBonus[_bonusDate][_address]);\r\n\r\n        // calculate the bonus for one holded LGO\r\n        uint256 bonusByLgo = (BONUS_AMOUNT / 4) / unspentAmounts[_bonusDate];\r\n\r\n        // distribute the bonus\r\n        uint256 holderBonus = initialAllocations[_address] * bonusByLgo;\r\n        balances[_address] += holderBonus;\r\n        allocations[_address] += holderBonus;\r\n\r\n        // set bonus as distributed\r\n        bonusNotDistributed[_bonusDate][_address] = false;\r\n        return true;\r\n    }\r\n}", "ABI": "[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"advisors\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"_bonusDate\",\"type\":\"uint256\"}],\"name\":\"claimBonus\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"BONUS_DATES\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"eligibleForBonus\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"allocations\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"holdersAllocatedAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"advisorsAllocatedAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"foundersAllocatedAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_type\",\"type\":\"uint8\"}],\"name\":\"allocate\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"initialAllocations\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"FOUNDERS_LOCK_DATES\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"founders\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ADVISORS_LOCK_DATES\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"unspentAmounts\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_address\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Allocate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]", "ContractName": "Legolas", "CompilerVersion": "v0.4.13+commit.fb4cb1a", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://994d4bd6d6864869281179d49a52ee3c4ba7840553f259acbe3dcf191d0b62b7"}