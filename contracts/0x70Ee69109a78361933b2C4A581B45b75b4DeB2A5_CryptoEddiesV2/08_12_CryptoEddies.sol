// SPDX-License-Identifier: MIT

/*
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX  CRYPTO EDDIES  XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX   by @eddietree  XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXNWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXNWWWx'....................................:0WWWNXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXNNNo.                                    ,ONNNXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXNWWNd'..;looooooooooooooooooooooooooooooooooooc,..;OWWWNXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXNNWNl   ,xOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOo.  .kWNNNXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXNWWNd,',:llldkOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOxollc;'';OWWWNXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXWMMN:   ;kOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOd.  .xMMMNXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXWMMN:   ,kOOOOOOOOOOO0000000KKKKKKKKKKKKKKKKK00000000Kx.  .xMMMNXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXWMMN:   ;kOOOOOOOOOOOKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKk'  .xMMMNXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXWMMN:   ;kOOOOOOO000KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKk'  .xMMMNXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXWMMN:   ;kOOOOOO0KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKk'  .xMMMNXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXWMMN:   ;kOOOOOO0KKKKKKKOl;;ckKKKKKKKKKKKKKKKKkc;;lOXXk'  .xMMMNXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXWMMN:   ;kOOOOOO0KKKKKKKk'  .oKKKKKKKKKKKKKKKXo.  .xXXk'  .xMMMNXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXNNNXxllc.   ;kOOOOOO0KKKKKKK0occc::::cxKKKKKKKkc:::cccoOKKk'  .xMMMNXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXNWMMX;       ;kOOOOOO0KKKKKKKKKKXO,    cKKKKKKKl   'OXXXKKKk'  .xMMMNXXXXXXXXXXXXXXXX
XXXXXXXXXXXXNNNKxoolc:::::::okOOOOOO0KKKKKKK0occc:::::xKKKKKKKxc:::cccoOKXk'  .xMMMNXXXXXXXXXXXXXXXX
XXXXXXXXXXXNWMM0'  .oKKKKKKK0OOOOOOO0KKKKKKXk'  .oKKKKKKKKKKKKKKXKo.  .xKXk'  .xMMMNXXXXXXXXXXXXXXXX
XXXXXXXXXXXNWMM0'  .oKKKKKKKK000OOOO0KKKKKKKOl;;:kKKKKKKKKK0000KKKkc;;lOKKOl;;:lddd0NNNXXXXXXXXXXXXX
XXXXXXXXXXXNWMM0'  .oKKKKKKKKKKK0OOO0KKKKKKKKKKKKKKKKKKKKK0kkkOKKKKKKKKKKKKKKKO,   oWMMNXXXXXXXXXXXX
XXXXXXXXXXXXNWWKo;;:coooooookKKKK0000KKKKKKKKKKK0xooookKKKxc::d0KKOdood0KKKKKKO,   oWMMNXXXXXXXXXXXX
XXXXXXXXXXXXXXXNWWMX;       :0KKKKKKKKKKKKKKKKKXO,    cKKKc   ;0KXo.  .xKKKKKXO,   oWMMNXXXXXXXXXXXX
XXXXXXXXXXXXXXXXNWWXo,,,,,,,coodkKKKKKKKKKKKKKKK0c''',codo:''':oddc,'':kXKKKKXO,   oWMMNXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXNWWWWWWNl   ;0KKKKKKKKKKKKKKKKKKKO;   :0K0l.  ,kKKKKKKKKKKO,   oWMMNXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXNWWWWWWNx,'':dddkKKKKKKKKKKKKKKKX0l..'oKKKd'..:OXKKKKK0kddo:'',xWWWNXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXNNNNd.  ,OXKKKKKKKKKKKKKKKK000KKKKK0000KKKKKKKk,  .dNNNNXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXNXK000o'..;dxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxo;..,kWWWNXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXNWMWo...;k0Ol.                                    'xXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXKK0l...c0KKd'............................     ...,OWWWNXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXNWWNl...:kOO0KKX0OOOOOOOOOOOOOOOOOOOOOOOOOOOOOc.  .xKKXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXX0c...cKKK0OOO0KKKKKKKKKKKKKKKKKKKKKKKKK0OOOl.  '0MMWNXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXNWWXc..'cxkk0KKKo...:OKKKKKKKOkkO0KKKK0kkO0KKKo'...   '0MMWNXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXWMMX;   lKKKKKKKl.  ,x000KKKKOkkk0KKKKOkkk0KKKl       ,ONNNXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXWMMX;   cKKKKKKK0xxxl'..;kXKKK000KKKKKK000KKKKl   .oxxo,'.:OWWWNXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXWMMX;  .c000KKKKKKKKo.  .xKKKKKKKKKKKKKKKKKKKKl   'kXXx.  .kMMWNXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXNNX0kkkc'''oKKKKKKKo.  .xKK0dlloxkkkkkkkk0KKKl   'kXXx.  .kMMWNXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXWMMNc   :0KKKKKKo.  .xKKOl:::oxxxxxxxxOKKKl   'kKKd.  .kMMWNXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXNNNX0xxxc,,,,,,,;loox0KKOl:::oxxxxxxxxOKKKl    ',,:oxxkKNNNXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXNMMWl       'kXKKKKKOl;::oxxxxxxxxOKKKl       '0MMWNXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXNNNN0ddd;   'OXXkc,,;;:::oxxxxxxxxOKKKl   .lddkKNNNXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXNMMMd   'OXXd.   ':::oxxxxxxxxOKKKl   ,KMMWNXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXNMMMd   'OKXx.  .lOOO0KKK0o,,,oKKKl   ,KMMWNXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXNMMMd   'OKKd.  .kMMMMMMMNc   :0XKl   ,KMMWXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXNWWWx'..:OXXk;..;OWWWWWWWNo...lKKKd'..cKWWNXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/

pragma solidity ^0.8.4;

import "erc721a/contracts/ERC721A.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/Strings.sol";
import "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol";
import 'base64-sol/base64.sol';

import "./EddieRenderer.sol";
import "./CryptoDeddies.sol";

/// @title CryptoEddies
/// @author Eddie Lee
/// @notice CryptoEddies is an 100% on-chain experimental NFT character project.
contract CryptoEddies is EddieRenderer, ERC721A, Ownable {
    
    uint256 public constant MAX_TOKEN_SUPPLY = 3500;

    // 3 pricing tiers
    uint256 public tier0_price = 0.01 ether;
    uint256 public tier1_price = 0.015 ether;
    uint256 public tier2_price = 0.02 ether;
    uint256 public tier0_supply = 2000;
    uint256 public tier1_supply = 1000;

    uint256 public maxMintsPerPersonPublic = 150;
    uint256 public maxMintsPerPersonWhitelist = 1;
    uint public constant MAX_HP = 5;

    CryptoDeddies public contractGhost;

    enum MintStatus {
        CLOSED, // 0
        WHITELIST, // 1
        PUBLIC // 2
    }

    MintStatus public mintStatus = MintStatus.CLOSED;
    bool public revealed = false;

    mapping(uint256 => uint256) public seeds; // seeds for image + stats
    mapping(uint256 => uint) public hp; // health power

    // events
    event EddieDied(uint256 indexed tokenId); // emitted when an HP goes to zero
    event EddieRerolled(uint256 indexed tokenId); // emitted when an Eddie gets re-rolled
    event EddieSacrificed(uint256 indexed tokenId); // emitted when an Eddie gets sacrificed

    constructor() ERC721A("CryptoEddies", "EDDIE") {
    }

    modifier verifySupply(uint256 numEddiesToMint) {
        //require(tx.origin == msg.sender,  "No bots");
        require(numEddiesToMint > 0, "Mint at least 1");
        require(_totalMinted() + numEddiesToMint <= MAX_TOKEN_SUPPLY, "Exceeds max supply");

        _;
    }

    modifier verifyTokenId(uint256 tokenId) {
        require(tokenId >= _startTokenId() && tokenId <= _totalMinted(), "Out of bounds");
        _;
    }

    function _mintEddies(address to, uint256 numEddiesToMint) private verifySupply(numEddiesToMint) {
        uint256 startTokenId = _startTokenId() + _totalMinted();
         for(uint256 tokenId = startTokenId; tokenId < startTokenId+numEddiesToMint; tokenId++) {
            _saveSeed(tokenId);
            hp[tokenId] = MAX_HP;
         }

         _safeMint(to, numEddiesToMint);
    }

    function reserveEddies(address to, uint256 numEddiesToMint) external onlyOwner {
        _mintEddies(to, numEddiesToMint);
    }

    function reserveEddiesToManyFolk(address[] calldata addresses, uint256 numEddiesToMint) external {
        uint256 num = addresses.length;
        for (uint256 i = 0; i < num; ++i) {
            address to = addresses[i];
            _mintEddies(to, numEddiesToMint);
        }
    }

    /// @notice Mints CryptoEddies into your wallet! payableAmount is the total amount of ETH to mint all numEddiesToMint (costPerCryptoEddie * numEddiesToMint)
    /// @param numEddiesToMint The number of CryptoEddies you want to mint
    function mintEddies(uint256 numEddiesToMint) external payable {
        require(mintStatus == MintStatus.PUBLIC, "Public mint closed");
        require(msg.value >= _getPrice(numEddiesToMint), "Incorrect ether" );
        require(_numberMinted(msg.sender) + numEddiesToMint <= maxMintsPerPersonPublic, "Exceeds max mints");

        _mintEddies(msg.sender, numEddiesToMint);
    }

    function _rerollEddie(uint256 tokenId) verifyTokenId(tokenId) private {
        require(revealed == true, "Not revealed");
        require(hp[tokenId] > 0, "No HP");
        require(msg.sender == ownerOf(tokenId), "Not yours");

        _saveSeed(tokenId);   
        _takeDamageHP(tokenId, msg.sender);

        emit EddieRerolled(tokenId);
    }

    /// @notice Rerolls the visuals and stats of one CryptoEddie, deals -1 HP damage!
    /// @param tokenId The token ID for the CryptoEddie to reroll
    function rerollEddie(uint256 tokenId) external {
        _rerollEddie(tokenId);
    }

    function rerollEddieMany(uint256[] calldata tokenIds) external {
        uint256 num = tokenIds.length;
        for (uint256 i = 0; i < num; ++i) {
            uint256 tokenId = tokenIds[i];
            _rerollEddie(tokenId);
        }
    }

    function _saveSeed(uint256 tokenId) private {
        seeds[tokenId] = uint256(keccak256(abi.encodePacked(blockhash(block.number - 1), tokenId, msg.sender)));
    }

    // @notice Destroys your CryptoEddie, spawning a ghost
    /// @param tokenId The token ID for the CryptoEddie
    function burnSacrifice(uint256 tokenId) external {
        require(msg.sender == ownerOf(tokenId), "Not yours");
        _burn(tokenId);

        // if not already dead, force kill and spawn ghost
        if (hp[tokenId] > 0) {
            hp[tokenId] = 0;
            emit EddieDied(tokenId);

            if (address(contractGhost) != address(0)) {
                contractGhost.spawnGhost(msg.sender, tokenId, seeds[tokenId]);
            }
        }

        emit EddieSacrificed(tokenId);
    }

    function _startTokenId() override internal pure virtual returns (uint256) {
        return 1;
    }

    // taken from 'ERC721AQueryable.sol'
    function tokensOfOwner(address owner) external view returns (uint256[] memory) {
        unchecked {
            uint256 tokenIdsIdx;
            address currOwnershipAddr;
            uint256 tokenIdsLength = balanceOf(owner);
            uint256[] memory tokenIds = new uint256[](tokenIdsLength);
            TokenOwnership memory ownership;
            for (uint256 i = _startTokenId(); tokenIdsIdx != tokenIdsLength; ++i) {
                ownership = _ownershipAt(i);
                if (ownership.burned) {
                    continue;
                }
                if (ownership.addr != address(0)) {
                    currOwnershipAddr = ownership.addr;
                }
                if (currOwnershipAddr == owner) {
                    tokenIds[tokenIdsIdx++] = i;
                }
            }
            return tokenIds;
        }
    }

    function _getPrice(uint256 numPayable) private view returns (uint256) {
        uint256 numMintedAlready = _totalMinted();

        return numPayable 
            * (numMintedAlready < tier0_supply ? 
                tier0_price 
                : ( (numMintedAlready < (tier0_supply+tier1_supply)) ? tier1_price : tier2_price));
    }

    function setPricing(uint256[] calldata pricingData) external onlyOwner {
        tier0_supply = pricingData[0];
        tier0_price = pricingData[1];

        tier1_supply = pricingData[2];
        tier1_price = pricingData[3];

        tier2_price = pricingData[4];

        require(tier0_supply + tier1_supply <= MAX_TOKEN_SUPPLY);
    }

    function setPublicMintStatus(uint256 _status) external onlyOwner {
        mintStatus = MintStatus(_status);
    }

    function setMaxMints(uint256 _maxMintsPublic, uint256 _maxMintsWhitelist) external onlyOwner {
        maxMintsPerPersonPublic = _maxMintsPublic;
        maxMintsPerPersonWhitelist = _maxMintsWhitelist;
    }

    function setContractGhost(address newAddress) external onlyOwner {
        contractGhost = CryptoDeddies(newAddress);
    }

    function setRevealed(bool _revealed) external onlyOwner {
        revealed = _revealed;
    }

    // props to @cygaar_dev
    error SteveAokiNotAllowed();
    address public constant STEVE_AOKI_ADDRESS = 0xe4bBCbFf51e61D0D95FcC5016609aC8354B177C4;

    function _beforeTokenTransfers(address from, address to, uint256 startTokenId, uint256 quantity) internal override {
        if (to == STEVE_AOKI_ADDRESS) { // sorry Mr. Aoki
            revert SteveAokiNotAllowed();
        }

        if (from == address(0) || to == address(0))  // bypass for minting and burning
            return;

        for (uint256 tokenId = startTokenId; tokenId < startTokenId + quantity; ++tokenId) {
            //require(hp[tokenId] > 0, "No more HP"); // soulbound?

            // transfers reduces HP
            _takeDamageHP(tokenId, from);
        }
    }

    function _takeDamageHP(uint256 tokenId, address mintGhostTo) private verifyTokenId(tokenId){
        if (hp[tokenId] == 0) // to make sure it doesn't wrap around
            return;

        hp[tokenId] -= 1;

        if (hp[tokenId] == 0) {
            emit EddieDied(tokenId);

            if (address(contractGhost) != address(0)) {
                contractGhost.spawnGhost(mintGhostTo, tokenId, seeds[tokenId]);
            }
        }
    }

    function rewardHP(uint256 tokenId, uint hpRewarded) external onlyOwner verifyTokenId(tokenId) {
        require(hp[tokenId] > 0, "Already dead");
        hp[tokenId] += hpRewarded;

        if (hp[tokenId] > MAX_HP) 
            hp[tokenId] = MAX_HP;
    }

    function rewardManyHP(uint256[] calldata tokenIds, uint hpRewarded) external {
        uint256 num = tokenIds.length;
        for (uint256 i = 0; i < num; ++i) {
            uint256 tokenId = tokenIds[i];

            if (hp[tokenId] > 0 ) { // not dead
                hp[tokenId] += hpRewarded;

                if (hp[tokenId] > MAX_HP) 
                    hp[tokenId] = MAX_HP;
            }
        }
    }

    /// @notice Retrieves the HP
    /// @param tokenId The token ID for the CryptoEddie
    /// @return hp the amount of HP for the CryptoEddie
    function getHP(uint256 tokenId) external view verifyTokenId(tokenId) returns(uint){
        return hp[tokenId];
    }

    function numberMinted(address addr) external view returns(uint256){
        return _numberMinted(addr);
    }

    ///////////////////////////
    // -- MERKLE NERD STUFF --
    ///////////////////////////
    bytes32 public merkleRoot = 0x0;

    function setMerkleRoot(bytes32 _merkleRoot) external onlyOwner {
        merkleRoot = _merkleRoot;
    }

    function _verifyMerkle(bytes32[] calldata _proof, bytes32 _leaf) private view returns (bool) {
        return MerkleProof.verify(_proof, merkleRoot, _leaf);
    }

    function verifyMerkle(bytes32[] calldata _proof, bytes32 _leaf) external view returns (bool) {
        return _verifyMerkle(_proof, _leaf);
    }

    function verifyMerkleAddress(bytes32[] calldata _proof, address from) external view returns (bool) {
        bytes32 leaf = keccak256(abi.encodePacked(from));
        return _verifyMerkle(_proof, leaf);
    }

    function mintEddiesMerkle(bytes32[] calldata _merkleProof, uint256 numEddiesToMint) external payable {
        require(mintStatus == MintStatus.WHITELIST || mintStatus == MintStatus.PUBLIC, "Merkle mint closed");
        
        uint256 numMintedAlready = _numberMinted(msg.sender);
        require(numMintedAlready + numEddiesToMint <= maxMintsPerPersonPublic, "Exceeds max mints");

        // calculate how much you need to pay beyond whitelisted amount
        uint256 numToMintFromWhitelist = 0;
        if (numMintedAlready < maxMintsPerPersonWhitelist) {
            numToMintFromWhitelist = (maxMintsPerPersonWhitelist - numMintedAlready);
        }

        // num to actually buy
        uint256 numToMintPayable = numEddiesToMint - numToMintFromWhitelist;
        require(msg.value >= _getPrice(numToMintPayable), "Incorrect ether sent" );
    
        // verify merkle        
        bytes32 leaf = keccak256(abi.encodePacked(msg.sender));
        require(_verifyMerkle(_merkleProof, leaf), "Invalid proof");

        _mintEddies(msg.sender, numEddiesToMint);
    }

    ///////////////////////////
    // -- TOKEN URI --
    ///////////////////////////
    function _tokenURI(uint256 tokenId) private view returns (string memory) {
        string[6] memory lookup = [  '0', '1', '2', '3', '4', '5'];
        uint256 seed = seeds[tokenId];
        string memory image = _getSVG(seed);

        string memory json = Base64.encode(
            bytes(string(
                abi.encodePacked(
                    '{"name": ', '"CryptoEddie #', Strings.toString(tokenId),'",',
                    '"description": "CryptoEddies is an 100% on-chain experimental NFT character project with unique functionality, inspired by retro Japanese RPGs.",',
                    '"attributes":[',
                        _getTraitsMetadata(seed),
                        _getStatsMetadata(seed),
                        '{"trait_type":"HP", "value":',lookup[hp[tokenId]],', "max_value":',lookup[MAX_HP],'}'
                    '],',
                    '"image": "data:image/svg+xml;base64,', Base64.encode(bytes(image)), '"}' 
                )
            ))
        );

        return string(abi.encodePacked('data:application/json;base64,', json));
    }

    function _tokenUnrevealedURI(uint256 tokenId) private view returns (string memory) {
        uint256 seed = seeds[tokenId];
        string memory image = _getUnrevealedSVG(seed);

        string memory json = Base64.encode(
            bytes(string(
                abi.encodePacked(
                    '{"name": ', '"CryptoEddie #', Strings.toString(tokenId),'",',
                    '"description": "CryptoEddies is an 100% on-chain experimental character art project, chillin on the Ethereum blockchain.",',
                    '"attributes":[{"trait_type":"Unrevealed", "value":"True"}],',
                    '"image": "data:image/svg+xml;base64,', Base64.encode(bytes(image)), '"}' 
                )
            ))
        );

        return string(abi.encodePacked('data:application/json;base64,', json));
    }

    function tokenURI(uint256 tokenId) override(ERC721A) public view verifyTokenId(tokenId) returns (string memory) {
        if (revealed) 
            return _tokenURI(tokenId);
        else
            return _tokenUnrevealedURI(tokenId);
    }

    function _randStat(uint256 seed, uint256 div, uint256 min, uint256 max) private pure returns (uint256) {
        return min + (seed/div) % (max-min);
    }

    function _getStatsMetadata(uint256 seed) private pure returns (string memory) {
        string[11] memory lookup = [ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '10' ];

        string memory metadata = string(abi.encodePacked(
          '{"trait_type":"Determination", "display_type": "number", "value":', lookup[_randStat(seed, 2, 2, 10)], '},',
          '{"trait_type":"Love", "display_type": "number", "value":', lookup[_randStat(seed, 3, 2, 10)], '},',
          '{"trait_type":"Cringe", "display_type": "number", "value":', lookup[_randStat(seed, 4, 2, 10)], '},',
          '{"trait_type":"Bonk", "display_type": "number", "value":', lookup[_randStat(seed, 5, 2, 10)], '},',
          '{"trait_type":"Magic Defense", "display_type": "number", "value":', lookup[_randStat(seed, 6, 2, 10)], '},'
        ));

        return metadata;
    }

    function withdraw() external onlyOwner {
        uint balance = address(this).balance;
        payable(msg.sender).transfer(balance);
    }
}