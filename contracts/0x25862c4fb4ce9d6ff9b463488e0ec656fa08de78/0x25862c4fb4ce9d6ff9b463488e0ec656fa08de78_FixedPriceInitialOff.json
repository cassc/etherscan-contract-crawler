{"SourceCode": "{\"Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\\n\"},\"FixedPriceInitialOffering.sol\":{\"content\":\"/*\\n* SPDX-License-Identifier: UNLICENSED\\n* Copyright \u00a9 2021 Blocksquare d.o.o.\\n*/\\n\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\n\\n\\ninterface FixedPriceInitialOfferingHelpers {\\n    function mint(address[] memory accounts, uint256[] memory amounts) external returns (bool);\\n\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    function transfer(address sender, uint256 amount) external returns (bool);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function canEditProperty(address wallet, address property) external view returns (bool);\\n\\n    function contractBurn(address user, uint256 amount) external returns (bool);\\n\\n    function cap() external view returns (uint256);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function hasSystemAdminRights(address sender) external view returns (bool);\\n\\n    function isCPAdminOfProperty(address admin, address property) external view returns (bool);\\n\\n    function getUserBytesFromWallet(address wallet) external view returns (bytes32);\\n}\\n\\n/// @title Fixed Price Initial Offering\\ncontract FixedPriceInitialOffering is Ownable {\\n    using SafeMath for uint256;\\n\\n    struct Offering {\\n        uint256 presaleStart;\\n        uint256 presaleEnd;\\n        uint256 saleStart;\\n        uint256 saleEnd;\\n        uint256 price;\\n        uint256 amountCollected;\\n        uint256 presaleCollected;\\n        uint256 presaleMaxInvestment;\\n        uint256 presaleMinInvestment;\\n        uint256 maxInvestment;\\n        uint256 minInvestment;\\n        uint256 softCap;\\n        address investmentToken;\\n        address collector;\\n        address feeCollector;\\n        uint256 fee;\\n        bool investmentCollected;\\n    }\\n\\n    struct NewOffering {\\n        uint256 presaleStart;\\n        uint256 presaleEnd;\\n        uint256 saleEnd;\\n        uint256 price;\\n        uint256 presaleMaxInvestment;\\n        uint256 presaleMinInvestment;\\n        uint256 maxInvestment;\\n        uint256 minInvestment;\\n        uint256 softCap;\\n        address investmentToken;\\n        address collector;\\n        address feeCollector;\\n        uint256 fee;\\n    }\\n\\n    mapping(address =\\u003e mapping(address =\\u003e mapping(uint16 =\\u003e uint256))) private _userInvestment;\\n    mapping(address =\\u003e mapping(bytes32 =\\u003e mapping(uint16 =\\u003e uint256))) private _userTotalInvestment;\\n    mapping(address =\\u003e mapping(address =\\u003e mapping(uint16 =\\u003e uint256))) private _userTokens;\\n    mapping(address =\\u003e mapping(address =\\u003e mapping(uint16 =\\u003e uint256))) private _userTokensPresale;\\n    mapping(address =\\u003e Offering) private _offerings;\\n    mapping(address =\\u003e uint16) private _numOfSuccessfulOfferings;\\n\\n    address private _dataProxy;\\n    address private _users;\\n\\n    modifier onlyCPOrAdmin(address admin, address property) {\\n        require(FixedPriceInitialOfferingHelpers(_dataProxy).canEditProperty(admin, property), \\\"Initial investment: You need to be able to edit property\\\");\\n        _;\\n    }\\n\\n    event Invested(address indexed property, address indexed wallet, address investmentToken, uint256 amountInvested, uint256 amountReceived);\\n    event InitialOffer(address indexed property, uint256 pricePerToken, uint256 presaleMaxInvestment, uint256 presaleMinInvestment, uint256 maxInvestment, uint256 minInvestment, uint256 softCap, uint256 presaleStart, uint256 presaleEnd, uint256 saleStart, uint256 saleEnd, address investmentCurrency, address collector, address feeCollector, uint256 fee);\\n    event ClaimInvestment(address indexed property, uint256 amount, uint256 feeAmount);\\n    event ReturnedInvestment(address indexed proeprty, address wallet, uint256 amount);\\n    event ReturnedPresaleInvestment(address indexed proeprty, address wallet, uint256 amount);\\n    event InitialOfferingCanceled(address indexed property);\\n\\n    constructor(address dataProxy, address users) public {\\n        _dataProxy = dataProxy;\\n        _users = users;\\n    }\\n\\n    function changeDataProxy(address dataProxy) public onlyOwner {\\n        _dataProxy = dataProxy;\\n    }\\n\\n    function changeUsers(address users) public onlyOwner {\\n        _users = users;\\n    }\\n\\n    /// @notice create or update offering information\\n    /// @param newOffering Offering information (price and fee support up to 2 decimals for 5% fee enter 500)\\n    function modifyOfferingInfo(address property, NewOffering memory newOffering) public onlyCPOrAdmin(_msgSender(), property) {\\n        require(newOffering.softCap.mul(10 ** 9).div(newOffering.price).div(10 ** 7) \\u003c= hardCap(property).sub(currentSupply(property)), \\\"InitialInvestment: Soft cap set too high\\\");\\n        require(newOffering.presaleStart \\u003e= block.timestamp, \\\"InitialInvestment: Investment must start in the future\\\");\\n        require(newOffering.presaleStart \\u003c= newOffering.presaleEnd \\u0026\\u0026 (newOffering.presaleEnd + 3 days) \\u003c= newOffering.saleEnd, \\\"InitialInvestment: Start time must be before end time\\\");\\n        Offering memory offering = _offerings[property];\\n        require(offering.presaleStart == 0 || offering.presaleStart \\u003e block.timestamp || offering.saleEnd \\u003c block.timestamp || offering.investmentCollected, \\\"Initial investment: Offering already set and it started\\\");\\n        require((offering.amountCollected == 0 \\u0026\\u0026 offering.presaleCollected == 0) || offering.investmentCollected, \\\"InitialInvestment: You need to collect investments first\\\");\\n        offering = Offering(newOffering.presaleStart, newOffering.presaleEnd, newOffering.presaleEnd + 3 days, newOffering.saleEnd, newOffering.price, 0, 0, newOffering.presaleMaxInvestment, newOffering.presaleMinInvestment, newOffering.maxInvestment, newOffering.minInvestment, newOffering.softCap, newOffering.investmentToken, newOffering.collector, newOffering.feeCollector, newOffering.fee, false);\\n        _offerings[property] = offering;\\n        emit InitialOffer(property, offering.price, offering.presaleMaxInvestment, offering.presaleMinInvestment, offering.maxInvestment, offering.minInvestment, offering.softCap, offering.presaleStart, offering.presaleEnd, offering.presaleStart + 3 days, offering.saleEnd, offering.investmentToken, offering.collector, offering.feeCollector, offering.fee);\\n    }\\n\\n    /// @notice invest ERC-20 token (DAI for example) to receive property token\\n    /// @param property Property contract address\\n    /// @param amount Amount of specified token to invest\\n    function invest(address property, uint256 amount) public {\\n        Offering memory offering = _offerings[property];\\n        bytes32 user = FixedPriceInitialOfferingHelpers(_users).getUserBytesFromWallet(_msgSender());\\n        require(offering.saleStart \\u003c= block.timestamp \\u0026\\u0026 offering.saleEnd \\u003e= block.timestamp, \\\"InitialInvestment: Offering is not active\\\");\\n        require(amount \\u003e= offering.minInvestment, \\\"InitialInvestment: You need to invest more\\\");\\n        require(_userTotalInvestment[property][user][_numOfSuccessfulOfferings[property]].add(amount) \\u003c= offering.maxInvestment, \\\"InitialInvestment: You need to invest less\\\");\\n        uint256 cap = FixedPriceInitialOfferingHelpers(property).cap();\\n        uint256 mintAmount = amount.mul(10 ** 9).div(offering.price).div(10 ** 7);\\n        uint256 currentSupply = FixedPriceInitialOfferingHelpers(property).totalSupply();\\n\\n        require(currentSupply.add(mintAmount) \\u003c= cap, \\\"InitialInvestment: Too many tokens would be minted\\\");\\n        _offerings[property].amountCollected = offering.amountCollected.add(amount);\\n\\n        require(FixedPriceInitialOfferingHelpers(offering.investmentToken).transferFrom(_msgSender(), address(this), amount));\\n\\n        uint256[] memory mAmount = new uint256[](1);\\n        mAmount[0] = mintAmount;\\n        address[] memory receiver = new address[](1);\\n        receiver[0] = _msgSender();\\n        require(FixedPriceInitialOfferingHelpers(property).mint(receiver, mAmount));\\n        _userInvestment[property][_msgSender()][_numOfSuccessfulOfferings[property]] = _userInvestment[property][_msgSender()][_numOfSuccessfulOfferings[property]].add(amount);\\n        _userTokens[property][_msgSender()][_numOfSuccessfulOfferings[property]] = _userTokens[property][_msgSender()][_numOfSuccessfulOfferings[property]].add(mintAmount);\\n        _userTotalInvestment[property][user][_numOfSuccessfulOfferings[property]] = _userTotalInvestment[property][user][_numOfSuccessfulOfferings[property]].add(amount);\\n        emit Invested(property, _msgSender(), offering.investmentToken, amount, mintAmount);\\n    }\\n\\n    /// @notice collect investment (only if soft cap was reached and the offering closed)\\n    /// @param property Property contract address\\n    function collectInvestments(address property) public {\\n        Offering storage offering = _offerings[property];\\n        require(offering.softCap \\u003c= offering.amountCollected.add(offering.presaleCollected), \\\"InitialInvestment: Soft cap not reached\\\");\\n        require(offering.saleEnd \\u003c block.timestamp || currentSupply(property) == hardCap(property), \\\"InitialInvestment: You need to wait for initial investment to finish\\\");\\n        uint256 collected = offering.amountCollected;\\n        offering.amountCollected = 0;\\n        offering.investmentCollected = true;\\n        uint256 fee = collected.mul(offering.fee).div(10000);\\n        collected = collected.sub(fee);\\n        _numOfSuccessfulOfferings[property] = _numOfSuccessfulOfferings[property] + 1;\\n        require(FixedPriceInitialOfferingHelpers(_offerings[property].investmentToken).transfer(offering.collector, collected));\\n        if (fee \\u003e 0) {\\n            require(FixedPriceInitialOfferingHelpers(_offerings[property].investmentToken).transfer(offering.feeCollector, fee));\\n        }\\n        emit ClaimInvestment(property, collected, fee);\\n    }\\n\\n    /// @notice mint property tokens for presale (done offchain)\\n    /// @param property Property contract address\\n    /// @param wallets Array of wallets to which tokens should be minted\\n    /// @param amounts Array of amounts of how much tokens should be minted\\n    function mintPresale(address property, address[] memory wallets, uint256[] memory amounts) public {\\n        require(FixedPriceInitialOfferingHelpers(_dataProxy).isCPAdminOfProperty(_msgSender(), property), \\\"InitialInvestment: You need to be admin\\\");\\n        Offering storage offering = _offerings[property];\\n        require(offering.presaleStart \\u003c= block.timestamp \\u0026\\u0026 block.timestamp \\u003c= offering.saleEnd, \\\"InitialInvestment: Can only mint during sale\\\");\\n        require(FixedPriceInitialOfferingHelpers(property).mint(wallets, amounts));\\n        for (uint256 i = 0; i \\u003c wallets.length; i++) {\\n            address wallet = wallets[i];\\n            _userTokensPresale[property][wallet][_numOfSuccessfulOfferings[property]] = _userTokensPresale[property][wallet][_numOfSuccessfulOfferings[property]].add(amounts[i]);\\n            uint256 investment = amounts[i].mul(offering.price).div(100);\\n            _offerings[property].presaleCollected = offering.presaleCollected.add(investment);\\n        }\\n    }\\n\\n    /// @notice burn presale minted tokens in case soft cap was not reached\\n    /// @param property Property contract address\\n    /// @param wallets Array of wallets for which to burn the property tokens\\n    function returnPresaleInvestment(address property, address[] memory wallets) public onlyCPOrAdmin(msg.sender, property) {\\n        Offering storage offering = _offerings[property];\\n        require(offering.saleEnd \\u003c= block.timestamp \\u0026\\u0026 offering.softCap \\u003e offering.amountCollected.add(offering.presaleCollected), \\\"InitialInvestment: Soft cap must not be reached\\\");\\n        for (uint i = 0; i \\u003c wallets.length; i++) {\\n            address wallet = wallets[i];\\n            uint256 userBalance = _userTokensPresale[property][wallet][_numOfSuccessfulOfferings[property]];\\n            uint256 userInvestment = userBalance.mul(offering.price).div(100);\\n            _userTokensPresale[property][wallet][_numOfSuccessfulOfferings[property]] = 0;\\n\\n            require(FixedPriceInitialOfferingHelpers(property).contractBurn(wallet, userBalance));\\n\\n            _offerings[property].presaleCollected = _offerings[property].presaleCollected.sub(userInvestment);\\n            emit ReturnedPresaleInvestment(property, wallet, userInvestment);\\n        }\\n    }\\n\\n    function _returnInvestment(address property, address wallet) private {\\n        bytes32 user = FixedPriceInitialOfferingHelpers(_users).getUserBytesFromWallet(wallet);\\n        uint256 userBalance = _userTokens[property][wallet][_numOfSuccessfulOfferings[property]];\\n        uint256 userInvestment = _userInvestment[property][wallet][_numOfSuccessfulOfferings[property]];\\n        _userInvestment[property][wallet][_numOfSuccessfulOfferings[property]] = 0;\\n        _userTokens[property][wallet][_numOfSuccessfulOfferings[property]] = 0;\\n        _userTotalInvestment[property][user][_numOfSuccessfulOfferings[property]] = _userTotalInvestment[property][user][_numOfSuccessfulOfferings[property]].sub(userInvestment);\\n\\n        require(FixedPriceInitialOfferingHelpers(property).contractBurn(wallet, userBalance));\\n        require(FixedPriceInitialOfferingHelpers(_offerings[property].investmentToken).transfer(wallet, userInvestment));\\n\\n        _offerings[property].amountCollected = _offerings[property].amountCollected.sub(userInvestment);\\n        emit ReturnedInvestment(property, wallet, userInvestment);\\n    }\\n\\n    /// @notice return investment in case soft cap was not reached\\n    /// @param property Property contract address\\n    /// @param wallets Array of wallets for which to return the investment\\n    function returnInvestment(address property, address[] memory wallets) public onlyCPOrAdmin(msg.sender, property) {\\n        Offering storage offering = _offerings[property];\\n        require(offering.saleEnd \\u003c= block.timestamp \\u0026\\u0026 offering.softCap \\u003e offering.amountCollected.add(offering.presaleCollected), \\\"InitialInvestment: Soft cap must not be reached\\\");\\n        for (uint i = 0; i \\u003c wallets.length; i++) {\\n            address wallet = wallets[i];\\n            _returnInvestment(property, wallet);\\n        }\\n    }\\n\\n\\n    /// @notice get back investment and burn property token\\n    /// @param property Property contract address\\n    function getInvestmentBack(address property) public {\\n        Offering storage offering = _offerings[property];\\n        require(offering.saleEnd \\u003c block.timestamp \\u0026\\u0026 offering.softCap \\u003e offering.amountCollected.add(offering.presaleCollected), \\\"InitialInvestment: Soft cap must not be reached\\\");\\n        _returnInvestment(property, _msgSender());\\n    }\\n\\n    /// @notice cancel current initial investment for property\\n    /// @param property Property contract address\\n    function cancelOffering(address property) public {\\n        require(FixedPriceInitialOfferingHelpers(_dataProxy).hasSystemAdminRights(msg.sender), \\\"InitialInvestment: You need to have system admin rights\\\");\\n        _offerings[property].presaleStart = block.timestamp;\\n        _offerings[property].presaleEnd = block.timestamp;\\n        _offerings[property].saleStart = block.timestamp;\\n        _offerings[property].saleEnd = block.timestamp;\\n        emit InitialOfferingCanceled(property);\\n    }\\n\\n    /// @notice transfer DAI from this contract to another wallet in case something goes wrong\\n    /// @param property Property contract address\\n    /// @param wallet Wallet address\\n    function recoverDAI(address property, address wallet) public {\\n        require(FixedPriceInitialOfferingHelpers(_dataProxy).hasSystemAdminRights(msg.sender), \\\"InitialInvestment: You need to have system admin rights\\\");\\n        Offering storage offering = _offerings[property];\\n        require(offering.saleEnd \\u003c= block.timestamp \\u0026\\u0026 offering.softCap \\u003e offering.amountCollected.add(offering.presaleCollected), \\\"InitialInvestment: Soft cap must not be reached\\\");\\n        require(FixedPriceInitialOfferingHelpers(_offerings[property].investmentToken).transfer(wallet, offering.amountCollected));\\n        _offerings[property].amountCollected = 0;\\n        _offerings[property].presaleCollected = 0;\\n        _numOfSuccessfulOfferings[property] = _numOfSuccessfulOfferings[property] + 1;\\n    }\\n\\n    /// @notice retrieves total supply of property token\\n    /// @param property Property contract address\\n    function currentSupply(address property) public view returns (uint256) {\\n        return FixedPriceInitialOfferingHelpers(property).totalSupply();\\n    }\\n\\n    /// @notice retrieves cap of property token\\n    /// @param property Property contract address\\n    function hardCap(address property) public view returns (uint256) {\\n        return FixedPriceInitialOfferingHelpers(property).cap();\\n    }\\n\\n    /// @notice retrieves initial offering information for property\\n    /// @param property Property contract address\\n    function offeringInfo(address property) public view returns (Offering memory) {\\n        return _offerings[property];\\n    }\\n\\n    /// @notice retrieves current offering token invested in sale (returns zero if investment was collected) for wallet\\n    /// @param property Property contract address\\n    /// @param wallet Investor wallet\\n    function currentInvestmentByWallet(address property, address wallet) public view returns (uint256) {\\n        return _userInvestment[property][wallet][_numOfSuccessfulOfferings[property]];\\n    }\\n\\n    /// @notice retrieves current total offering token invested in sale by user (returns zero if investment was collected)\\n    /// @param property Property contract address\\n    /// @param wallet Investor wallet\\n    function currentInvestmentByUser(address property, address wallet) public view returns (uint256) {\\n        bytes32 user = FixedPriceInitialOfferingHelpers(_users).getUserBytesFromWallet(wallet);\\n        return _userTotalInvestment[property][user][_numOfSuccessfulOfferings[property]];\\n    }\\n\\n    /// @notice retrieves current offering token invested in presale (returns zero if investment was collected)\\n    /// @param property Property contract address\\n    /// @param wallet Investor wallet\\n    function currentUserPresaleInvestment(address property, address wallet) public view returns (uint256) {\\n        return _userTokensPresale[property][wallet][_numOfSuccessfulOfferings[property]].mul(_offerings[property].price).div(100);\\n    }\\n}\\n\\n\"},\"Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\\"./Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\ncontract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () internal {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\\n\"},\"SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it\\u0027s recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b \\u003c= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b \\u003e 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\\n\"}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dataProxy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"users\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"property\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"feeAmount\",\"type\":\"uint256\"}],\"name\":\"ClaimInvestment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"property\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pricePerToken\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"presaleMaxInvestment\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"presaleMinInvestment\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxInvestment\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minInvestment\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"softCap\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"presaleStart\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"presaleEnd\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"saleStart\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"saleEnd\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"investmentCurrency\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"collector\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"feeCollector\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"InitialOffer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"property\",\"type\":\"address\"}],\"name\":\"InitialOfferingCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"property\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"investmentToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountInvested\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountReceived\",\"type\":\"uint256\"}],\"name\":\"Invested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"proeprty\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ReturnedInvestment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"proeprty\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ReturnedPresaleInvestment\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"property\",\"type\":\"address\"}],\"name\":\"cancelOffering\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dataProxy\",\"type\":\"address\"}],\"name\":\"changeDataProxy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"users\",\"type\":\"address\"}],\"name\":\"changeUsers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"property\",\"type\":\"address\"}],\"name\":\"collectInvestments\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"property\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"currentInvestmentByUser\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"property\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"currentInvestmentByWallet\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"property\",\"type\":\"address\"}],\"name\":\"currentSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"property\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"currentUserPresaleInvestment\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"property\",\"type\":\"address\"}],\"name\":\"getInvestmentBack\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"property\",\"type\":\"address\"}],\"name\":\"hardCap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"property\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"invest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"property\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"wallets\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"mintPresale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"property\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"presaleStart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"presaleEnd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"saleEnd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"presaleMaxInvestment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"presaleMinInvestment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxInvestment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minInvestment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"softCap\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"investmentToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"collector\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"feeCollector\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"internalType\":\"struct FixedPriceInitialOffering.NewOffering\",\"name\":\"newOffering\",\"type\":\"tuple\"}],\"name\":\"modifyOfferingInfo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"property\",\"type\":\"address\"}],\"name\":\"offeringInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"presaleStart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"presaleEnd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"saleStart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"saleEnd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountCollected\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"presaleCollected\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"presaleMaxInvestment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"presaleMinInvestment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxInvestment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minInvestment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"softCap\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"investmentToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"collector\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"feeCollector\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"investmentCollected\",\"type\":\"bool\"}],\"internalType\":\"struct FixedPriceInitialOffering.Offering\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"property\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"recoverDAI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"property\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"wallets\",\"type\":\"address[]\"}],\"name\":\"returnInvestment\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"property\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"wallets\",\"type\":\"address[]\"}],\"name\":\"returnPresaleInvestment\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "FixedPriceInitialOffering", "CompilerVersion": "v0.6.12+commit.27d51765", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000008c2a858fe7b2bf155247c7f528c6ca7b186197b500000000000000000000000013344d0cb96b17df81c4171ce47e14ff6c1975f7", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://8d3b192464f063698685395204ebd4fb425f5005036ccbe7a9334501f67a25d0"}