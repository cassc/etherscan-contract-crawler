{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@chainlink/contracts/src/v0.8/ConfirmedOwner.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ConfirmedOwnerWithProposal.sol\\\";\\n\\n/**\\n * @title The ConfirmedOwner contract\\n * @notice A contract with helpers for basic contract ownership.\\n */\\ncontract ConfirmedOwner is ConfirmedOwnerWithProposal {\\n  constructor(address newOwner) ConfirmedOwnerWithProposal(newOwner, address(0)) {}\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.8/ConfirmedOwnerWithProposal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./interfaces/OwnableInterface.sol\\\";\\n\\n/**\\n * @title The ConfirmedOwner contract\\n * @notice A contract with helpers for basic contract ownership.\\n */\\ncontract ConfirmedOwnerWithProposal is OwnableInterface {\\n  address private s_owner;\\n  address private s_pendingOwner;\\n\\n  event OwnershipTransferRequested(address indexed from, address indexed to);\\n  event OwnershipTransferred(address indexed from, address indexed to);\\n\\n  constructor(address newOwner, address pendingOwner) {\\n    require(newOwner != address(0), \\\"Cannot set owner to zero\\\");\\n\\n    s_owner = newOwner;\\n    if (pendingOwner != address(0)) {\\n      _transferOwnership(pendingOwner);\\n    }\\n  }\\n\\n  /**\\n   * @notice Allows an owner to begin transferring ownership to a new address,\\n   * pending.\\n   */\\n  function transferOwnership(address to) public override onlyOwner {\\n    _transferOwnership(to);\\n  }\\n\\n  /**\\n   * @notice Allows an ownership transfer to be completed by the recipient.\\n   */\\n  function acceptOwnership() external override {\\n    require(msg.sender == s_pendingOwner, \\\"Must be proposed owner\\\");\\n\\n    address oldOwner = s_owner;\\n    s_owner = msg.sender;\\n    s_pendingOwner = address(0);\\n\\n    emit OwnershipTransferred(oldOwner, msg.sender);\\n  }\\n\\n  /**\\n   * @notice Get the current owner\\n   */\\n  function owner() public view override returns (address) {\\n    return s_owner;\\n  }\\n\\n  /**\\n   * @notice validate, transfer ownership, and emit relevant events\\n   */\\n  function _transferOwnership(address to) private {\\n    require(to != msg.sender, \\\"Cannot transfer to self\\\");\\n\\n    s_pendingOwner = to;\\n\\n    emit OwnershipTransferRequested(s_owner, to);\\n  }\\n\\n  /**\\n   * @notice validate access\\n   */\\n  function _validateOwnership() internal view {\\n    require(msg.sender == s_owner, \\\"Only callable by owner\\\");\\n  }\\n\\n  /**\\n   * @notice Reverts if called by anyone other than the contract owner.\\n   */\\n  modifier onlyOwner() {\\n    _validateOwnership();\\n    _;\\n  }\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface LinkTokenInterface {\\n  function allowance(address owner, address spender) external view returns (uint256 remaining);\\n\\n  function approve(address spender, uint256 value) external returns (bool success);\\n\\n  function balanceOf(address owner) external view returns (uint256 balance);\\n\\n  function decimals() external view returns (uint8 decimalPlaces);\\n\\n  function decreaseApproval(address spender, uint256 addedValue) external returns (bool success);\\n\\n  function increaseApproval(address spender, uint256 subtractedValue) external;\\n\\n  function name() external view returns (string memory tokenName);\\n\\n  function symbol() external view returns (string memory tokenSymbol);\\n\\n  function totalSupply() external view returns (uint256 totalTokensIssued);\\n\\n  function transfer(address to, uint256 value) external returns (bool success);\\n\\n  function transferAndCall(\\n    address to,\\n    uint256 value,\\n    bytes calldata data\\n  ) external returns (bool success);\\n\\n  function transferFrom(\\n    address from,\\n    address to,\\n    uint256 value\\n  ) external returns (bool success);\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.8/interfaces/OwnableInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface OwnableInterface {\\n  function owner() external returns (address);\\n\\n  function transferOwnership(address recipient) external;\\n\\n  function acceptOwnership() external;\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.8/interfaces/VRFV2WrapperInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface VRFV2WrapperInterface {\\n  /**\\n   * @return the request ID of the most recent VRF V2 request made by this wrapper. This should only\\n   * be relied option within the same transaction that the request was made.\\n   */\\n  function lastRequestId() external view returns (uint256);\\n\\n  /**\\n   * @notice Calculates the price of a VRF request with the given callbackGasLimit at the current\\n   * @notice block.\\n   *\\n   * @dev This function relies on the transaction gas price which is not automatically set during\\n   * @dev simulation. To estimate the price at a specific gas price, use the estimatePrice function.\\n   *\\n   * @param _callbackGasLimit is the gas limit used to estimate the price.\\n   */\\n  function calculateRequestPrice(uint32 _callbackGasLimit) external view returns (uint256);\\n\\n  /**\\n   * @notice Estimates the price of a VRF request with a specific gas limit and gas price.\\n   *\\n   * @dev This is a convenience function that can be called in simulation to better understand\\n   * @dev pricing.\\n   *\\n   * @param _callbackGasLimit is the gas limit used to estimate the price.\\n   * @param _requestGasPriceWei is the gas price in wei used for the estimation.\\n   */\\n  function estimateRequestPrice(uint32 _callbackGasLimit, uint256 _requestGasPriceWei) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.8/VRFV2WrapperConsumerBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./interfaces/LinkTokenInterface.sol\\\";\\nimport \\\"./interfaces/VRFV2WrapperInterface.sol\\\";\\n\\n/** *******************************************************************************\\n * @notice Interface for contracts using VRF randomness through the VRF V2 wrapper\\n * ********************************************************************************\\n * @dev PURPOSE\\n *\\n * @dev Create VRF V2 requests without the need for subscription management. Rather than creating\\n * @dev and funding a VRF V2 subscription, a user can use this wrapper to create one off requests,\\n * @dev paying up front rather than at fulfillment.\\n *\\n * @dev Since the price is determined using the gas price of the request transaction rather than\\n * @dev the fulfillment transaction, the wrapper charges an additional premium on callback gas\\n * @dev usage, in addition to some extra overhead costs associated with the VRFV2Wrapper contract.\\n * *****************************************************************************\\n * @dev USAGE\\n *\\n * @dev Calling contracts must inherit from VRFV2WrapperConsumerBase. The consumer must be funded\\n * @dev with enough LINK to make the request, otherwise requests will revert. To request randomness,\\n * @dev call the 'requestRandomness' function with the desired VRF parameters. This function handles\\n * @dev paying for the request based on the current pricing.\\n *\\n * @dev Consumers must implement the fullfillRandomWords function, which will be called during\\n * @dev fulfillment with the randomness result.\\n */\\nabstract contract VRFV2WrapperConsumerBase {\\n  LinkTokenInterface internal immutable LINK;\\n  VRFV2WrapperInterface internal immutable VRF_V2_WRAPPER;\\n\\n  /**\\n   * @param _link is the address of LinkToken\\n   * @param _vrfV2Wrapper is the address of the VRFV2Wrapper contract\\n   */\\n  constructor(address _link, address _vrfV2Wrapper) {\\n    LINK = LinkTokenInterface(_link);\\n    VRF_V2_WRAPPER = VRFV2WrapperInterface(_vrfV2Wrapper);\\n  }\\n\\n  /**\\n   * @dev Requests randomness from the VRF V2 wrapper.\\n   *\\n   * @param _callbackGasLimit is the gas limit that should be used when calling the consumer's\\n   *        fulfillRandomWords function.\\n   * @param _requestConfirmations is the number of confirmations to wait before fulfilling the\\n   *        request. A higher number of confirmations increases security by reducing the likelihood\\n   *        that a chain re-org changes a published randomness outcome.\\n   * @param _numWords is the number of random words to request.\\n   *\\n   * @return requestId is the VRF V2 request ID of the newly created randomness request.\\n   */\\n  function requestRandomness(\\n    uint32 _callbackGasLimit,\\n    uint16 _requestConfirmations,\\n    uint32 _numWords\\n  ) internal returns (uint256 requestId) {\\n    LINK.transferAndCall(\\n      address(VRF_V2_WRAPPER),\\n      VRF_V2_WRAPPER.calculateRequestPrice(_callbackGasLimit),\\n      abi.encode(_callbackGasLimit, _requestConfirmations, _numWords)\\n    );\\n    return VRF_V2_WRAPPER.lastRequestId();\\n  }\\n\\n  /**\\n   * @notice fulfillRandomWords handles the VRF V2 wrapper response. The consuming contract must\\n   * @notice implement it.\\n   *\\n   * @param _requestId is the VRF V2 request ID.\\n   * @param _randomWords is the randomness result.\\n   */\\n  function fulfillRandomWords(uint256 _requestId, uint256[] memory _randomWords) internal virtual;\\n\\n  function rawFulfillRandomWords(uint256 _requestId, uint256[] memory _randomWords) external {\\n    require(msg.sender == address(VRF_V2_WRAPPER), \\\"only VRF V2 wrapper can fulfill\\\");\\n    fulfillRandomWords(_requestId, _randomWords);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/FraudVRF.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.7;\\n/*\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28c0\u28c0\u28c0\u28c0\u28c0\u2840\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\\n\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2809\u281b\u28a6\u2840\u2809\u2819\u28a6\u2840\u2800\u2800\u28c0\u28e0\u28e4\u28c4\u28c0\u2800\u2800\u2800\u2800\\n\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28c0\u2864\u2824\u2834\u2836\u2824\u2824\u28bd\u28e6\u2840\u2800\u28b9\u2874\u281a\u2801\u2800\u2880\u28c0\u28c8\u28f3\u28c4\u2800\u2800\\n\u2800\u2800\u2800\u2800\u2800\u28a0\u281e\u28c1\u2864\u2834\u2836\u2836\u28e6\u2844\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2836\u283f\u282d\u2824\u28c4\u28c8\u2819\u2833\u2800\\n\u2800\u2800\u2800\u2800\u28a0\u287f\u280b\u2800\u2800\u2880\u2874\u280b\u2801\u2800\u28c0\u2856\u281b\u28b3\u2834\u2836\u2844\u2800\u2800\u2800\u2800\u2800\u2808\u2819\u28a6\u2800\\n\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2874\u280b\u28e0\u2834\u281a\u2809\u2809\u28e7\u28c4\u28f7\u2840\u2880\u28ff\u2840\u2808\u2819\u283b\u284d\u2819\u2832\u28ae\u28e7\\n\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u285e\u28e0\u281e\u2801\u2800\u2800\u2800\u28f0\u2803\u2800\u28f8\u2809\u2809\u2800\u2819\u28a6\u2840\u2800\u2838\u2844\u2800\u2808\u281f\\n\u2800\u2800\u2800\u2800\u2800\u2800\u28b8\u281f\u2801\u2800\u2800\u2800\u2800\u28a0\u280f\u2809\u2889\u2847\u2800\u2800\u2800\u2800\u2800\u2809\u2833\u28c4\u28b7\u2800\u2800\u2800\\n\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u287e\u2824\u2824\u28bc\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2818\u28bf\u2800\u2800\u2800\\n\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28a0\u2847\u2800\u2800\u28ff\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2808\u2800\u2800\u2800\\n\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28b8\u2809\u2809\u2809\u28c7\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\\n\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28b8\u28c0\u28c0\u28c0\u28fb\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\\n\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28c0\u28c0\u2864\u2824\u2824\u28ff\u2809\u2809\u2809\u2818\u28e7\u2824\u28a4\u28c4\u28c0\u2840\u2800\u2800\u2800\u2800\u2800\u2800\u2800\\n\u2800\u2800\u2880\u2864\u2816\u280b\u2809\u2800\u2800\u2800\u2800\u2800\u2819\u2832\u2824\u2824\u2834\u281a\u2801\u2800\u2800\u2800\u2809\u2809\u2813\u2826\u28c4\u2800\u2800\u2800\\n\u2880\u285e\u2809\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2808\u2819\u28c4\u2800\\n\u2818\u2812\u2812\u2812\u2812\u2812\u2812\u2812\u2812\u2812\u2812\u2812\u2812\u2812\u2812\u2812\u2812\u2812\u2812\u2812\u2812\u2812\u2812\u2812\u2812\u2812\u2812\u2812\u281a\u2800\\n\\n _____ ____      _   _   _ ______     ______  _____ \\n |  ___|  _ \\\\    / \\\\ | | | |  _ \\\\ \\\\   / /  _ \\\\|  ___|\\n | |_  | |_) |  / _ \\\\| | | | | | \\\\ \\\\ / /| |_) | |_   \\n |  _| |  _ <  / ___ \\\\ |_| | |_| |\\\\ V / |  _ <|  _|  \\n |_|   |_| \\\\_\\\\/_/   \\\\_\\\\___/|____/  \\\\_/  |_| \\\\_\\\\_|    \\n\\n   Twitter: https://twitter.com/fraudeth_gg\\n   Telegram: http://t.me/fraudportal\\n   Website: https://fraudeth.gg\\n   Docs: https://docs.fraudeth.gg\\n*/                                                   \\nimport \\\"@chainlink/contracts/src/v0.8/ConfirmedOwner.sol\\\";\\nimport \\\"@chainlink/contracts/src/v0.8/VRFV2WrapperConsumerBase.sol\\\";\\nimport \\\"./IFraudToken.sol\\\";\\nimport \\\"./IBribeToken.sol\\\";\\nimport \\\"./ITaxHaven.sol\\\";\\n\\n\\n\\ncontract FraudVRF is\\n    VRFV2WrapperConsumerBase,\\n    ConfirmedOwner\\n{\\n    IFraudToken public fraud;\\n    IBribeToken public bribe;\\n    ITaxHaven public taxHaven;\\n\\n    event RequestSent(uint256 requestId, uint32 numWords);\\n    event RequestFulfilled(\\n        uint256 requestId,\\n        uint256[] randomWords,\\n        uint256 payment\\n    );\\n\\n    struct RequestStatus {\\n        uint256 paid; // amount paid in link\\n        bool fulfilled; // whether the request has been successfully fulfilled\\n        uint256[] randomWords;\\n        address user;\\n        uint256 vault;\\n        uint256 reward;\\n    }\\n\\n    mapping(uint256 => RequestStatus)\\n        public s_requests; /* requestId --> requestStatus */\\n\\n    // past requests Id.\\n    uint256[] public requestIds;\\n    uint256 public lastRequestId;\\n\\n    // Depends on the number of requested values that you want sent to the\\n    // fulfillRandomWords() function. Test and adjust\\n    // this limit based on the network that you select, the size of the request,\\n    // and the processing of the callback request in the fulfillRandomWords()\\n    // function.\\n    uint32 callbackGasLimit;\\n\\n    // The default is 3, but you can set this higher.\\n    uint16 requestConfirmations = 3;\\n\\n    // For this example, retrieve 2 random values in one request.\\n    // Cannot exceed VRFV2Wrapper.getConfig().maxNumWords.\\n    uint32 numWords = 2;\\n\\n    // Address LINK \\n    address linkAddress = 0x514910771AF9Ca656af840dff83E8264EcF986CA;\\n\\n    // address WRAPPER \\n    address wrapperAddress = 0x5A861794B927983406fCE1D062e00b9368d97Df6;\\n\\n    mapping(address => bool) public mainAdmins;\\n    mapping(address => bool) public admins;\\n\\n    constructor(address _taxHaven, address _link, address _wraper, address _fraud, address _bribe)\\n        ConfirmedOwner(_taxHaven)\\n        VRFV2WrapperConsumerBase(_link, _wraper)\\n    {\\n        mainAdmins[msg.sender] = true;\\n        callbackGasLimit = 100000;\\n        taxHaven = ITaxHaven(_taxHaven);\\n        fraud = IFraudToken(_fraud);\\n        bribe = IBribeToken(_bribe);\\n    }\\n\\n    function requestRandomWords(uint256 vault, uint256 reward, address user)\\n        external\\n        onlyOwner\\n        returns (uint256 requestId)\\n    {\\n        requestId = requestRandomness(\\n            callbackGasLimit,\\n            requestConfirmations,\\n            numWords\\n        );\\n        s_requests[requestId] = RequestStatus({\\n            paid: VRF_V2_WRAPPER.calculateRequestPrice(callbackGasLimit),\\n            randomWords: new uint256[](0),\\n            fulfilled: false,\\n            user: user,\\n            vault: vault,\\n            reward: reward\\n        });\\n        requestIds.push(requestId);\\n        lastRequestId = requestId;\\n        emit RequestSent(requestId, numWords);\\n        return requestId;\\n    }\\n\\n    function fulfillRandomWords(\\n        uint256 _requestId,\\n        uint256[] memory _randomWords\\n    ) internal override {\\n        require(s_requests[_requestId].paid > 0, \\\"request not found\\\");\\n        s_requests[_requestId].fulfilled = true;\\n        s_requests[_requestId].randomWords = _randomWords;\\n        uint256 vault = s_requests[_requestId].vault;\\n        uint256 reward = s_requests[_requestId].reward;\\n        uint256 randNum = _randomWords[0] % 100;\\n        uint256 randNum2 = _randomWords[1] % 100;\\n        address user = s_requests[_requestId].user;\\n\\n        if(vault == 0){\\n            // In Panama\\n            taxHaven.withdrawPanamaVrf(user, randNum);\\n\\n        } else if(vault == 1){\\n            // In Venezuela\\n            taxHaven.withdrawVenezuelaVrf(user, randNum, randNum2);\\n        } else {\\n            // In ClaimBribe reward is reward\\n            taxHaven.claimBribeVrf(user, reward, randNum);\\n        }\\n        emit RequestFulfilled(\\n            _requestId,\\n            _randomWords,\\n            s_requests[_requestId].paid\\n        );\\n    }\\n\\n    function getRequestStatus(\\n        uint256 _requestId\\n    )\\n        external\\n        view\\n        returns (uint256 paid, bool fulfilled, uint256[] memory randomWords)\\n    {\\n        require(s_requests[_requestId].paid > 0, \\\"request not found\\\");\\n        RequestStatus memory request = s_requests[_requestId];\\n        return (request.paid, request.fulfilled, request.randomWords);\\n    }\\n\\n    /**\\n     * Allow withdraw of Link tokens from the contract\\n     */\\n    function withdrawLink() public onlyAdmins {\\n        LinkTokenInterface link = LinkTokenInterface(linkAddress);\\n        require(\\n            link.transfer(msg.sender, link.balanceOf(address(this))),\\n            \\\"Unable to transfer\\\"\\n        );\\n    }\\n\\n    function setCallbackGasLimit(uint32 _callbackGasLimit) public onlyAdmins {\\n        callbackGasLimit = _callbackGasLimit;\\n    }\\n\\n    function setAdmins(address _admin, bool _isAdmin) public onlyMainAdmins {\\n        admins[_admin] = _isAdmin;\\n    }\\n\\n    modifier onlyMainAdmins() {\\n        require(mainAdmins[msg.sender], \\\"Not a main admin\\\");\\n        _;\\n    }\\n\\n    modifier onlyAdmins(){\\n        require(mainAdmins[msg.sender] || admins[msg.sender], \\\"Not an admin\\\");\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/IBribeToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IBribeToken {\\n    function mint(address to, uint256 amount) external;\\n    function balanceOf(address who) external view returns (uint256);\\n    function burn(address to, uint256 amount) external;\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n    function transfer(address to, uint256 value) external returns (bool);\\n} \"\r\n    },\r\n    \"contracts/IFraudToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IFraudToken {\\n    function mint(address to, uint256 amount) external;\\n    function totalSupply() external view returns (uint256);\\n    function transferUnderlying(address to, uint256 value) external returns (bool);\\n    function fragmentToFraud(uint256 value) external view returns (uint256);\\n    function fraudToFragment(uint256 fraud) external view returns (uint256);\\n    function balanceOfUnderlying(address who) external view returns (uint256);\\n    function balanceOf(address who) external view returns (uint256);\\n    function approve(address spender, uint256 value) external returns (bool);\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n    function getCurrentEpoch() external view returns (uint256);\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function burn(address from, uint256 amount) external;\\n    function rebase(\\n        uint256 epoch,\\n        uint256 indexDelta,\\n        bool positive\\n    ) external returns (uint256);\\n}\\n\\n\\n\"\r\n    },\r\n    \"contracts/ITaxHaven.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface ITaxHaven {\\n    function withdrawPanamaVrf(address _user, uint256 _randNum) external;\\n    function withdrawVenezuelaVrf(address _user, uint256 _randNum, uint256 randNum2) external;\\n    function claimBribeVrf(address _user, uint256 _reward, uint256 _randNum) external;\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_taxHaven\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_link\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_wraper\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_fraud\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_bribe\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"requestId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"randomWords\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"payment\",\"type\":\"uint256\"}],\"name\":\"RequestFulfilled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"requestId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"numWords\",\"type\":\"uint32\"}],\"name\":\"RequestSent\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"admins\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bribe\",\"outputs\":[{\"internalType\":\"contract IBribeToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fraud\",\"outputs\":[{\"internalType\":\"contract IFraudToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_requestId\",\"type\":\"uint256\"}],\"name\":\"getRequestStatus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"paid\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"fulfilled\",\"type\":\"bool\"},{\"internalType\":\"uint256[]\",\"name\":\"randomWords\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastRequestId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"mainAdmins\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_requestId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"_randomWords\",\"type\":\"uint256[]\"}],\"name\":\"rawFulfillRandomWords\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"requestIds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"vault\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"requestRandomWords\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"requestId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"s_requests\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"paid\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"fulfilled\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"vault\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_isAdmin\",\"type\":\"bool\"}],\"name\":\"setAdmins\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_callbackGasLimit\",\"type\":\"uint32\"}],\"name\":\"setCallbackGasLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"taxHaven\",\"outputs\":[{\"internalType\":\"contract ITaxHaven\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawLink\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "FraudVRF", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000fe491d331e1cbb38438c2ecc0d29539c72a8c716000000000000000000000000514910771af9ca656af840dff83e8264ecf986ca0000000000000000000000005a861794b927983406fce1d062e00b9368d97df60000000000000000000000001a0120eab44157ba10d767e0f4a38a0a6452bcf900000000000000000000000085acb547000531d96fd64f6d87ee4df0965e5925", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}