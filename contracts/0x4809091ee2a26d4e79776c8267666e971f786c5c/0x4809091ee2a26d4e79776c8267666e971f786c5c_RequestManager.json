{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"RequestManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nimport \\\"OpenZeppelin/openzeppelin-contracts@4.8.0/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"OpenZeppelin/openzeppelin-contracts@4.8.0/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"OpenZeppelin/openzeppelin-contracts@4.8.0/contracts/utils/math/Math.sol\\\";\\nimport \\\"OpenZeppelin/openzeppelin-contracts@4.8.0/contracts/access/Ownable.sol\\\";\\nimport \\\"OpenZeppelin/openzeppelin-contracts@4.8.0/contracts/security/Pausable.sol\\\";\\n\\nimport \\\"./BeamerUtils.sol\\\";\\nimport \\\"./RestrictedCalls.sol\\\";\\nimport \\\"./LpWhitelist.sol\\\";\\n\\n/// The request manager.\\n///\\n/// This contract is responsible for keeping track of transfer requests,\\n/// implementing the rules of the challenge game and holding deposited\\n/// tokens until they are withdrawn.\\n/// The information passed by L1 resolution will be stored with the respective requests.\\n///\\n/// It is the only contract that agents need to interact with on the source chain.\\n/// .. note::\\n///\\n///   The functions resolveRequest and invalidateFill can only be called by\\n///   the :sol:contract:`Resolver` contract, via a chain-dependent messenger contract.\\ncontract RequestManager is Ownable, LpWhitelist, RestrictedCalls, Pausable {\\n    using Math for uint256;\\n    using SafeERC20 for IERC20;\\n\\n    // Structs\\n    // TODO: check if we can use a smaller type for `targetChainId`, so that the\\n    // fields can be packed into one storage slot\\n    struct Request {\\n        address sender;\\n        address sourceTokenAddress;\\n        uint256 targetChainId;\\n        uint256 amount;\\n        uint32 validUntil;\\n        uint256 lpFee;\\n        uint256 protocolFee;\\n        uint32 activeClaims;\\n        uint96 withdrawClaimId;\\n        address filler;\\n        bytes32 fillId;\\n        mapping(bytes32 fillId => bool invalid) invalidFillIds;\\n    }\\n\\n    struct Claim {\\n        bytes32 requestId;\\n        address claimer;\\n        uint96 claimerStake;\\n        mapping(address challenger => uint96 stake) challengersStakes;\\n        address lastChallenger;\\n        uint96 challengerStakeTotal;\\n        uint256 withdrawnAmount;\\n        uint256 termination;\\n        bytes32 fillId;\\n    }\\n\\n    struct Token {\\n        uint256 transferLimit;\\n        uint256 ethInToken;\\n        uint256 collectedProtocolFees;\\n    }\\n\\n    struct Chain {\\n        uint256 finalityPeriod;\\n        uint256 transferCost;\\n        uint256 targetWeightPPM;\\n    }\\n\\n    // Events\\n\\n    /// Emitted when a new request has been created.\\n    ///\\n    /// .. seealso:: :sol:func:`createRequest`\\n    event RequestCreated(\\n        bytes32 indexed requestId,\\n        uint256 targetChainId,\\n        address sourceTokenAddress,\\n        address targetTokenAddress,\\n        address indexed sourceAddress,\\n        address targetAddress,\\n        uint256 amount,\\n        uint96 nonce,\\n        uint32 validUntil,\\n        uint256 lpFee,\\n        uint256 protocolFee\\n    );\\n\\n    /// Emitted when the token deposit for request ``requestId`` has been\\n    /// transferred to the ``receiver``.\\n    ///\\n    /// This can happen in two cases:\\n    ///\\n    ///  * the request expired and the request submitter called :sol:func:`withdrawExpiredRequest`\\n    ///  * a claim related to the request has been resolved successfully in favor of the claimer\\n    ///\\n    /// .. seealso:: :sol:func:`withdraw` :sol:func:`withdrawExpiredRequest`\\n    event DepositWithdrawn(bytes32 requestId, address receiver);\\n\\n    /// Emitted when a claim or a counter-claim (challenge) has been made.\\n    ///\\n    /// .. seealso:: :sol:func:`claimRequest` :sol:func:`challengeClaim`\\n    event ClaimMade(\\n        bytes32 indexed requestId,\\n        uint96 claimId,\\n        address claimer,\\n        uint96 claimerStake,\\n        address lastChallenger,\\n        uint96 challengerStakeTotal,\\n        uint256 termination,\\n        bytes32 fillId\\n    );\\n\\n    /// Emitted when staked native tokens tied to a claim have been withdrawn.\\n    ///\\n    /// This can only happen when the claim has been resolved and the caller\\n    /// of :sol:func:`withdraw` is allowed to withdraw their stake.\\n    ///\\n    /// .. seealso:: :sol:func:`withdraw`\\n    event ClaimStakeWithdrawn(\\n        uint96 claimId,\\n        bytes32 indexed requestId,\\n        address stakeRecipient\\n    );\\n\\n    /// Emitted when fees are updated.\\n    ///\\n    /// .. seealso:: :sol:func:`updateFees`\\n    event FeesUpdated(uint32 minFeePPM, uint32 lpFeePPM, uint32 protocolFeePPM);\\n\\n    /// Emitted when token object of a token address is updated.\\n    ///\\n    /// .. seealso:: :sol:func:`updateToken`\\n    event TokenUpdated(\\n        address indexed tokenAddress,\\n        uint256 transferLimit,\\n        uint256 ethInToken\\n    );\\n\\n    /// Emitted when chain object of a chain id is updated.\\n    ///\\n    /// .. seealso:: :sol:func:`updateChain`\\n    event ChainUpdated(\\n        uint256 indexed chainId,\\n        uint256 finalityPeriod,\\n        uint256 transferCost,\\n        uint256 targetWeightPPM\\n    );\\n\\n    /// Emitted when a request has been resolved via L1 resolution.\\n    ///\\n    /// .. seealso:: :sol:func:`resolveRequest`\\n    event RequestResolved(bytes32 requestId, address filler, bytes32 fillId);\\n\\n    /// Emitted when an invalidated fill has been resolved.\\n    ///\\n    /// .. seealso:: :sol:func:`invalidateFill`\\n    event FillInvalidatedResolved(bytes32 requestId, bytes32 fillId);\\n\\n    // Constants\\n\\n    /// The minimum amount of source chain's native token that the claimer needs to\\n    /// provide when making a claim, as well in each round of the challenge game.\\n    uint96 public immutable claimStake;\\n\\n    /// The additional time given to claim a request. This value is added to the\\n    /// validity period of a request.\\n    uint256 public immutable claimRequestExtension;\\n\\n    /// The period for which the claim is valid.\\n    uint256 public immutable claimPeriod;\\n\\n    /// The period by which the termination time of a claim is extended after each\\n    /// round of the challenge game. This period should allow enough time for the\\n    /// other parties to counter-challenge.\\n    ///\\n    /// .. note::\\n    ///\\n    ///    The claim's termination time is extended only if it is less than the\\n    ///    extension time.\\n    ///\\n    /// Note that in the first challenge round, i.e. the round initiated by the first\\n    /// challenger, the termination time is extended additionally by the finality\\n    /// period of the target chain. This is done to allow for L1 resolution.\\n    uint256 public immutable challengePeriodExtension;\\n\\n    /// PPM to determine the minLpFee profit for liquidity providers.\\n    uint32 public minFeePPM;\\n\\n    /// PPM from transfer amount to determine the LP's fee\\n    uint32 public lpFeePPM;\\n\\n    /// PPM from transfer amount to determine the protocol's fee\\n    uint32 public protocolFeePPM;\\n\\n    /// The minimum validity period of a request.\\n    uint256 public constant MIN_VALIDITY_PERIOD = 30 minutes;\\n\\n    /// The maximum validity period of a request.\\n    uint256 public constant MAX_VALIDITY_PERIOD = 48 hours;\\n\\n    /// withdrawClaimId is set to this value when an expired request gets withdrawn by the sender\\n    uint96 public constant CLAIM_ID_WITHDRAWN_EXPIRED = type(uint96).max;\\n\\n    // Variables\\n\\n    /// A counter used to generate request and claim IDs.\\n    /// The variable holds the most recently used nonce and must\\n    /// be incremented to get the next nonce\\n    uint96 public currentNonce;\\n\\n    /// Maps target rollup chain IDs to chain information.\\n    mapping(uint256 chainId => Chain) public chains;\\n\\n    /// Maps request IDs to requests.\\n    mapping(bytes32 requestId => Request) public requests;\\n\\n    /// Maps claim IDs to claims.\\n    mapping(uint96 claimId => Claim) public claims;\\n\\n    /// Maps ERC20 token address to tokens\\n    mapping(address tokenAddress => Token) public tokens;\\n\\n    /// Compute the minimum liquidity provider fee that needs to be paid for a token transfer.\\n    function minLpFee(\\n        uint256 targetChainId,\\n        address tokenAddress\\n    ) public view returns (uint256) {\\n        Token storage token = tokens[tokenAddress];\\n        Chain storage sourceChain = chains[block.chainid];\\n        Chain storage targetChain = chains[targetChainId];\\n\\n        // The shift by 30 decimals comes from a multiplication of two PPM divisions (1e6 each)\\n        // and the 18 decimals division for ether\\n        return\\n            (((1_000_000 - sourceChain.targetWeightPPM) *\\n                sourceChain.transferCost +\\n                targetChain.targetWeightPPM *\\n                targetChain.transferCost) *\\n                (minFeePPM + 1_000_000) *\\n                token.ethInToken) / 10 ** 30;\\n    }\\n\\n    /// Compute the liquidity provider fee that needs to be paid for a given transfer amount.\\n    function lpFee(\\n        uint256 targetChainId,\\n        address tokenAddress,\\n        uint256 amount\\n    ) public view returns (uint256) {\\n        uint256 minFee = minLpFee(targetChainId, tokenAddress);\\n        return Math.max(minFee, (amount * lpFeePPM) / 1_000_000);\\n    }\\n\\n    /// Compute the protocol fee that needs to be paid for a given transfer amount.\\n    function protocolFee(uint256 amount) public view returns (uint256) {\\n        return (amount * protocolFeePPM) / 1_000_000;\\n    }\\n\\n    /// Compute the total fee that needs to be paid for a given transfer amount.\\n    /// The total fee is the sum of the liquidity provider fee and the protocol fee.\\n    function totalFee(\\n        uint256 targetChainId,\\n        address tokenAddress,\\n        uint256 amount\\n    ) public view returns (uint256) {\\n        return lpFee(targetChainId, tokenAddress, amount) + protocolFee(amount);\\n    }\\n\\n    /// Return the transferable amount excluding fees.\\n    ///\\n    /// It takes the given amount and calculates the actual transferable amount without fees\\n    /// based on the token address and its current fees.\\n    ///\\n    /// @param targetChainId ID of the target chain.\\n    /// @param tokenAddress Address of the token contract on the source chain.\\n    /// @param amount Amount of tokens to transfer including fees.\\n    /// @return transferable amount excluding fees.\\n    function transferableAmount(\\n        uint256 targetChainId,\\n        address tokenAddress,\\n        uint256 amount\\n    ) public view returns (uint256) {\\n        uint256 minFee = minLpFee(targetChainId, tokenAddress);\\n        require(amount > minFee, \\\"Amount not high enough to cover the fees\\\");\\n        // FIXME: There is a possible rounding error which leads to off by one unit\\n        // currently the error happens in \\\"our\\\" favor so that the dust stays in the wallet.\\n        // Can probably be fixed by rounding on the token.decimals() + 1 th digit\\n        uint256 transferableAmount = (amount * 1_000_000) /\\n            (1_000_000 + lpFeePPM + protocolFeePPM);\\n\\n        if ((transferableAmount * lpFeePPM) / 1_000_000 >= minFee) {\\n            return transferableAmount;\\n        }\\n\\n        return ((amount - minFee) * 1_000_000) / (1_000_000 + protocolFeePPM);\\n    }\\n\\n    // Modifiers\\n\\n    /// Check whether a given request ID is valid.\\n    modifier validRequestId(bytes32 requestId) {\\n        require(\\n            requests[requestId].sender != address(0),\\n            \\\"requestId not valid\\\"\\n        );\\n        _;\\n    }\\n\\n    /// Check whether a given claim ID is valid.\\n    modifier validClaimId(uint96 claimId) {\\n        require(claims[claimId].claimer != address(0), \\\"claimId not valid\\\");\\n        _;\\n    }\\n\\n    /// Constructor.\\n    ///\\n    /// @param _claimStake Claim stake amount.\\n    /// @param _claimRequestExtension Extension to claim a request after validity period ends.\\n    /// @param _claimPeriod Claim period, in seconds.\\n    /// @param _challengePeriodExtension Challenge period extension, in seconds.\\n    constructor(\\n        uint96 _claimStake,\\n        uint256 _claimRequestExtension,\\n        uint256 _claimPeriod,\\n        uint256 _challengePeriodExtension\\n    ) {\\n        claimStake = _claimStake;\\n        claimRequestExtension = _claimRequestExtension;\\n        claimPeriod = _claimPeriod;\\n        challengePeriodExtension = _challengePeriodExtension;\\n    }\\n\\n    /// Create a new transfer request.\\n    ///\\n    /// @param targetChainId ID of the target chain.\\n    /// @param sourceTokenAddress Address of the token contract on the source chain.\\n    /// @param targetTokenAddress Address of the token contract on the target chain.\\n    /// @param targetAddress Recipient address on the target chain.\\n    /// @param amount Amount of tokens to transfer. Does not include fees.\\n    /// @param validityPeriod The number of seconds the request is to be considered valid.\\n    ///                       Once its validity period has elapsed, the request cannot be claimed\\n    ///                       anymore and will eventually expire, allowing the request submitter\\n    ///                       to withdraw the deposited tokens if there are no active claims.\\n    /// @return ID of the newly created request.\\n    function createRequest(\\n        uint256 targetChainId,\\n        address sourceTokenAddress,\\n        address targetTokenAddress,\\n        address targetAddress,\\n        uint256 amount,\\n        uint256 validityPeriod\\n    ) external whenNotPaused returns (bytes32) {\\n        require(\\n            chains[targetChainId].finalityPeriod != 0,\\n            \\\"Target rollup not supported\\\"\\n        );\\n        require(\\n            validityPeriod >= MIN_VALIDITY_PERIOD,\\n            \\\"Validity period too short\\\"\\n        );\\n        require(\\n            validityPeriod <= MAX_VALIDITY_PERIOD,\\n            \\\"Validity period too long\\\"\\n        );\\n        require(\\n            amount <= tokens[sourceTokenAddress].transferLimit,\\n            \\\"Amount exceeds transfer limit\\\"\\n        );\\n\\n        uint256 lpFeeTokenAmount = lpFee(\\n            targetChainId,\\n            sourceTokenAddress,\\n            amount\\n        );\\n        uint256 protocolFeeTokenAmount = protocolFee(amount);\\n\\n        require(\\n            IERC20(sourceTokenAddress).allowance(msg.sender, address(this)) >=\\n                amount + lpFeeTokenAmount + protocolFeeTokenAmount,\\n            \\\"Insufficient allowance\\\"\\n        );\\n\\n        uint96 nonce = currentNonce + 1;\\n        currentNonce = nonce;\\n\\n        bytes32 requestId = BeamerUtils.createRequestId(\\n            block.chainid,\\n            targetChainId,\\n            targetTokenAddress,\\n            targetAddress,\\n            amount,\\n            nonce\\n        );\\n\\n        Request storage newRequest = requests[requestId];\\n        newRequest.sender = msg.sender;\\n        newRequest.sourceTokenAddress = sourceTokenAddress;\\n        newRequest.targetChainId = targetChainId;\\n        newRequest.amount = amount;\\n        newRequest.validUntil = uint32(block.timestamp + validityPeriod);\\n        newRequest.lpFee = lpFeeTokenAmount;\\n        newRequest.protocolFee = protocolFeeTokenAmount;\\n\\n        emit RequestCreated(\\n            requestId,\\n            targetChainId,\\n            sourceTokenAddress,\\n            targetTokenAddress,\\n            msg.sender,\\n            targetAddress,\\n            amount,\\n            nonce,\\n            uint32(block.timestamp + validityPeriod),\\n            lpFeeTokenAmount,\\n            protocolFeeTokenAmount\\n        );\\n\\n        IERC20(sourceTokenAddress).safeTransferFrom(\\n            msg.sender,\\n            address(this),\\n            amount + lpFeeTokenAmount + protocolFeeTokenAmount\\n        );\\n\\n        return requestId;\\n    }\\n\\n    /// Withdraw funds deposited with an expired request.\\n    ///\\n    /// No claims must be active for the request.\\n    ///\\n    /// @param requestId ID of the expired request.\\n    function withdrawExpiredRequest(\\n        bytes32 requestId\\n    ) external validRequestId(requestId) {\\n        Request storage request = requests[requestId];\\n\\n        require(request.withdrawClaimId == 0, \\\"Deposit already withdrawn\\\");\\n        require(\\n            block.timestamp >= request.validUntil,\\n            \\\"Request not expired yet\\\"\\n        );\\n        require(request.activeClaims == 0, \\\"Active claims running\\\");\\n\\n        request.withdrawClaimId = CLAIM_ID_WITHDRAWN_EXPIRED;\\n\\n        emit DepositWithdrawn(requestId, request.sender);\\n\\n        IERC20 token = IERC20(request.sourceTokenAddress);\\n        token.safeTransfer(\\n            request.sender,\\n            request.amount + request.lpFee + request.protocolFee\\n        );\\n    }\\n\\n    /// Claim that a request was filled by the caller.\\n    ///\\n    /// The request must still be valid at call time.\\n    /// The caller must provide the ``claimStake`` amount of source rollup's native\\n    /// token.\\n    ///\\n    /// @param requestId ID of the request.\\n    /// @param fillId The fill ID.\\n    /// @return The claim ID.\\n    function claimRequest(\\n        bytes32 requestId,\\n        bytes32 fillId\\n    )\\n        external\\n        payable\\n        validRequestId(requestId)\\n        onlyAllowed(msg.sender)\\n        returns (uint96)\\n    {\\n        return claimRequest(msg.sender, requestId, fillId);\\n    }\\n\\n    /// Claim that a request was filled.\\n    ///\\n    /// The request must still be valid at call time.\\n    /// The caller must provide the ``claimStake`` amount of source rollup's native\\n    /// token.\\n    /// Only the claimer may get the stake back later.\\n    ///\\n    /// @param claimer Address of the claimer.\\n    /// @param requestId ID of the request.\\n    /// @param fillId The fill ID.\\n    /// @return The claim ID.\\n    function claimRequest(\\n        address claimer,\\n        bytes32 requestId,\\n        bytes32 fillId\\n    )\\n        public\\n        payable\\n        validRequestId(requestId)\\n        onlyAllowed(claimer)\\n        returns (uint96)\\n    {\\n        Request storage request = requests[requestId];\\n\\n        require(\\n            block.timestamp < request.validUntil + claimRequestExtension,\\n            \\\"Request cannot be claimed anymore\\\"\\n        );\\n        require(request.withdrawClaimId == 0, \\\"Deposit already withdrawn\\\");\\n        require(msg.value == claimStake, \\\"Invalid stake amount\\\");\\n        require(claimer != address(0), \\\"Claimer can't be zero address\\\");\\n        require(fillId != bytes32(0), \\\"FillId must not be 0x0\\\");\\n\\n        request.activeClaims += 1;\\n\\n        uint96 nonce = currentNonce + 1;\\n        currentNonce = nonce;\\n        uint256 termination = block.timestamp + claimPeriod;\\n\\n        Claim storage claim = claims[nonce];\\n        claim.requestId = requestId;\\n        claim.claimer = claimer;\\n        claim.claimerStake = uint96(msg.value);\\n        claim.termination = termination;\\n        claim.fillId = fillId;\\n\\n        emit ClaimMade(\\n            requestId,\\n            nonce,\\n            claimer,\\n            uint96(msg.value),\\n            address(0),\\n            0,\\n            termination,\\n            fillId\\n        );\\n\\n        return nonce;\\n    }\\n\\n    /// Challenge an existing claim.\\n    ///\\n    /// The claim must still be valid at call time.\\n    /// This function implements one round of the challenge game.\\n    /// The original claimer is allowed to call this function only\\n    /// after someone else made a challenge, i.e. every second round.\\n    /// However, once the original claimer counter-challenges, anyone\\n    /// can join the game and make another challenge.\\n    ///\\n    /// The caller must provide enough native tokens as their stake.\\n    /// For the original claimer, the minimum stake is\\n    /// ``challengerStakeTotal - claimerStake + claimStake``.\\n    ///\\n    /// For challengers, the minimum stake is\\n    /// ``claimerStake - challengerStakeTotal + 1``.\\n    ///\\n    /// An example (time flows downwards, claimStake = 10)::\\n    ///\\n    ///   claimRequest() by Max [stakes 10]\\n    ///   challengeClaim() by Alice [stakes 11]\\n    ///   challengeClaim() by Max [stakes 11]\\n    ///   challengeClaim() by Bob [stakes 16]\\n    ///\\n    /// In this example, if Max didn't want to lose the challenge game to\\n    /// Alice and Bob, he would have to challenge with a stake of at least 16.\\n    ///\\n    /// @param claimId The claim ID.\\n    function challengeClaim(\\n        uint96 claimId\\n    ) external payable validClaimId(claimId) {\\n        Claim storage claim = claims[claimId];\\n        bytes32 requestId = claim.requestId;\\n        uint256 termination = claim.termination;\\n        require(block.timestamp < termination, \\\"Claim expired\\\");\\n        require(\\n            requests[requestId].filler == address(0),\\n            \\\"Request already resolved\\\"\\n        );\\n        require(\\n            !requests[requestId].invalidFillIds[claim.fillId],\\n            \\\"Fill already invalidated\\\"\\n        );\\n\\n        uint256 periodExtension = challengePeriodExtension;\\n        address claimer = claim.claimer;\\n        uint96 claimerStake = claim.claimerStake;\\n        uint96 challengerStakeTotal = claim.challengerStakeTotal;\\n\\n        if (claimerStake > challengerStakeTotal) {\\n            if (challengerStakeTotal == 0) {\\n                periodExtension += chains[requests[requestId].targetChainId]\\n                    .finalityPeriod;\\n            }\\n            require(msg.sender != claimer, \\\"Cannot challenge own claim\\\");\\n            require(\\n                msg.value >= claimerStake - challengerStakeTotal + 1,\\n                \\\"Not enough stake provided\\\"\\n            );\\n        } else {\\n            require(msg.sender == claimer, \\\"Not eligible to outbid\\\");\\n            require(\\n                msg.value >= challengerStakeTotal - claimerStake + claimStake,\\n                \\\"Not enough stake provided\\\"\\n            );\\n        }\\n\\n        if (msg.sender == claimer) {\\n            claimerStake += uint96(msg.value);\\n            claim.claimerStake = claimerStake;\\n        } else {\\n            claim.lastChallenger = msg.sender;\\n            claim.challengersStakes[msg.sender] += uint96(msg.value);\\n            challengerStakeTotal += uint96(msg.value);\\n            claim.challengerStakeTotal = challengerStakeTotal;\\n        }\\n\\n        if (block.timestamp + periodExtension > termination) {\\n            termination = block.timestamp + periodExtension;\\n            claim.termination = termination;\\n        }\\n\\n        emit ClaimMade(\\n            requestId,\\n            claimId,\\n            claimer,\\n            claimerStake,\\n            claim.lastChallenger,\\n            challengerStakeTotal,\\n            termination,\\n            claim.fillId\\n        );\\n    }\\n\\n    /// Withdraw the deposit that the request submitter left with the contract,\\n    /// as well as the staked native tokens associated with the claim.\\n    ///\\n    /// In case the caller of this function is a challenger that won the game,\\n    /// they will only get their staked native tokens plus the reward in the form\\n    /// of full (sole challenger) or partial (multiple challengers) amount\\n    /// of native tokens staked by the dishonest claimer.\\n    ///\\n    /// @param claimId The claim ID.\\n    /// @return The claim stakes receiver.\\n    function withdraw(\\n        uint96 claimId\\n    ) external validClaimId(claimId) returns (address) {\\n        return withdraw(msg.sender, claimId);\\n    }\\n\\n    /// Withdraw the deposit that the request submitter left with the contract,\\n    /// as well as the staked native tokens associated with the claim.\\n    ///\\n    /// This function is called on behalf of a participant. Only a participant\\n    /// may receive the funds if he is the winner of the challenge or the claim is valid.\\n    ///\\n    /// In case the caller of this function is a challenger that won the game,\\n    /// they will only get their staked native tokens plus the reward in the form\\n    /// of full (sole challenger) or partial (multiple challengers) amount\\n    /// of native tokens staked by the dishonest claimer.\\n    ///\\n    /// @param claimId The claim ID.\\n    /// @param participant The participant.\\n    /// @return The claim stakes receiver.\\n    function withdraw(\\n        address participant,\\n        uint96 claimId\\n    ) public validClaimId(claimId) returns (address) {\\n        Claim storage claim = claims[claimId];\\n        address claimer = claim.claimer;\\n        bytes32 requestId = claim.requestId;\\n        Request storage request = requests[requestId];\\n\\n        (address stakeRecipient, uint256 ethToTransfer) = resolveClaim(\\n            participant,\\n            claimId\\n        );\\n\\n        if (claim.challengersStakes[stakeRecipient] > 0) {\\n            //Re-entrancy protection\\n            claim.challengersStakes[stakeRecipient] = 0;\\n        }\\n\\n        uint256 withdrawnAmount = claim.withdrawnAmount;\\n\\n        // First time withdraw is called, remove it from active claims\\n        if (withdrawnAmount == 0) {\\n            request.activeClaims -= 1;\\n        }\\n        withdrawnAmount += ethToTransfer;\\n        claim.withdrawnAmount = withdrawnAmount;\\n\\n        require(\\n            withdrawnAmount <= claim.claimerStake + claim.challengerStakeTotal,\\n            \\\"Amount to withdraw too large\\\"\\n        );\\n\\n        (bool sent, ) = stakeRecipient.call{value: ethToTransfer}(\\\"\\\");\\n        require(sent, \\\"Failed to send Ether\\\");\\n\\n        emit ClaimStakeWithdrawn(claimId, requestId, stakeRecipient);\\n\\n        if (request.withdrawClaimId == 0 && stakeRecipient == claimer) {\\n            withdrawDeposit(request, claimId);\\n        }\\n\\n        return stakeRecipient;\\n    }\\n\\n    function resolveClaim(\\n        address participant,\\n        uint96 claimId\\n    ) private view returns (address, uint256) {\\n        Claim storage claim = claims[claimId];\\n        Request storage request = requests[claim.requestId];\\n        uint96 withdrawClaimId = request.withdrawClaimId;\\n        address claimer = claim.claimer;\\n        uint96 claimerStake = claim.claimerStake;\\n        uint96 challengerStakeTotal = claim.challengerStakeTotal;\\n        require(\\n            claim.withdrawnAmount < claimerStake + challengerStakeTotal,\\n            \\\"Claim already withdrawn\\\"\\n        );\\n\\n        bool claimValid = false;\\n\\n        // The claim is resolved with the following priority:\\n        // 1) The l1 resolved filler is the claimer and l1 resolved fillId matches, claim is valid\\n        // 2) FillId is true in request's invalidFillIds, claim is invalid\\n        // 3) The withdrawer's claim matches exactly this claim (same claimer address, same fillId)\\n        // 4) Claim properties, claim terminated and claimer has the highest stake\\n        if (request.filler != address(0)) {\\n            // Claim resolution via 1)\\n            claimValid =\\n                request.filler == claimer &&\\n                request.fillId == claim.fillId;\\n        } else if (request.invalidFillIds[claim.fillId]) {\\n            // Claim resolution via 2)\\n            claimValid = false;\\n        } else if (withdrawClaimId != 0) {\\n            // Claim resolution via 3)\\n            claimValid =\\n                claimer == claims[withdrawClaimId].claimer &&\\n                claim.fillId == claims[withdrawClaimId].fillId;\\n        } else {\\n            // Claim resolution via 4)\\n            require(\\n                block.timestamp >= claim.termination,\\n                \\\"Claim period not finished\\\"\\n            );\\n            claimValid = claimerStake > challengerStakeTotal;\\n        }\\n\\n        // Calculate withdraw scheme for claim stakes\\n        uint96 ethToTransfer;\\n        address stakeRecipient;\\n\\n        if (claimValid) {\\n            // If claim is valid, all stakes go to the claimer\\n            stakeRecipient = claimer;\\n            ethToTransfer = claimerStake + challengerStakeTotal;\\n        } else if (challengerStakeTotal > 0) {\\n            // If claim is invalid, partial withdrawal by the participant\\n            stakeRecipient = participant;\\n            ethToTransfer = 2 * claim.challengersStakes[stakeRecipient];\\n            require(ethToTransfer > 0, \\\"Challenger has nothing to withdraw\\\");\\n        } else {\\n            // The unlikely event is possible that a false claim has no challenger\\n            // If it is known that the claim is false then the claimer stake goes to the platform\\n            stakeRecipient = owner();\\n            ethToTransfer = claimerStake;\\n        }\\n\\n        // If the challenger wins and is the last challenger, he gets either\\n        // twice his stake plus the excess stake (if the claimer was winning), or\\n        // twice his stake minus the difference between the claimer and challenger stakes (if the claimer was losing)\\n        if (stakeRecipient == claim.lastChallenger) {\\n            if (claimerStake > challengerStakeTotal) {\\n                ethToTransfer += (claimerStake - challengerStakeTotal);\\n            } else {\\n                ethToTransfer -= (challengerStakeTotal - claimerStake);\\n            }\\n        }\\n\\n        return (stakeRecipient, ethToTransfer);\\n    }\\n\\n    function withdrawDeposit(Request storage request, uint96 claimId) private {\\n        Claim storage claim = claims[claimId];\\n        address claimer = claim.claimer;\\n        emit DepositWithdrawn(claim.requestId, claimer);\\n\\n        request.withdrawClaimId = claimId;\\n\\n        tokens[request.sourceTokenAddress].collectedProtocolFees += request\\n            .protocolFee;\\n\\n        IERC20 token = IERC20(request.sourceTokenAddress);\\n        token.safeTransfer(claimer, request.amount + request.lpFee);\\n    }\\n\\n    /// Returns whether a request's deposit was withdrawn or not\\n    ///\\n    /// This can be true in two cases:\\n    /// 1. The deposit was withdrawn after the request was claimed and filled.\\n    /// 2. The submitter withdrew the deposit after the request's expiry.\\n    /// .. seealso:: :sol:func:`withdraw`\\n    /// .. seealso:: :sol:func:`withdrawExpiredRequest`\\n    ///\\n    /// @param requestId The request ID\\n    /// @return Whether the deposit corresponding to the given request ID was withdrawn\\n    function isWithdrawn(\\n        bytes32 requestId\\n    ) public view validRequestId(requestId) returns (bool) {\\n        return requests[requestId].withdrawClaimId != 0;\\n    }\\n\\n    /// Withdraw protocol fees collected by the contract.\\n    ///\\n    /// Protocol fees are paid in token transferred.\\n    ///\\n    /// .. note:: This function can only be called by the contract owner.\\n    ///\\n    /// @param tokenAddress The address of the token contract.\\n    /// @param recipient The address the fees should be sent to.\\n    function withdrawProtocolFees(\\n        address tokenAddress,\\n        address recipient\\n    ) external onlyOwner {\\n        uint256 amount = tokens[tokenAddress].collectedProtocolFees;\\n        require(amount > 0, \\\"Protocol fee is zero\\\");\\n        tokens[tokenAddress].collectedProtocolFees = 0;\\n\\n        IERC20 token = IERC20(tokenAddress);\\n        token.safeTransfer(recipient, amount);\\n    }\\n\\n    /// Update fees\\n    ///\\n    /// .. note:: This function can only be called by the contract owner.\\n    ///\\n    /// @param _minFeePPM Margin which is going to be applied to the minLpFee\\n    /// @param _lpFeePPM LP percentage fee applied on transfer amount denominated in parts per million\\n    /// @param _protocolFeePPM Protocol fee applied on transfer amount denominated in parts per million\\n    function updateFees(\\n        uint32 _minFeePPM,\\n        uint32 _lpFeePPM,\\n        uint32 _protocolFeePPM\\n    ) external onlyOwner {\\n        require(_lpFeePPM <= 999_999, \\\"Maximum PPM of 999999 exceeded\\\");\\n        require(_protocolFeePPM <= 999_999, \\\"Maximum PPM of 999999 exceeded\\\");\\n\\n        minFeePPM = _minFeePPM;\\n        lpFeePPM = _lpFeePPM;\\n        protocolFeePPM = _protocolFeePPM;\\n\\n        emit FeesUpdated(_minFeePPM, _lpFeePPM, _protocolFeePPM);\\n    }\\n\\n    function updateToken(\\n        address tokenAddress,\\n        uint256 transferLimit,\\n        uint256 ethInToken\\n    ) external onlyOwner {\\n        Token storage token = tokens[tokenAddress];\\n        token.transferLimit = transferLimit;\\n        token.ethInToken = ethInToken;\\n\\n        emit TokenUpdated(tokenAddress, transferLimit, ethInToken);\\n    }\\n\\n    /// Update chain information for a given chain ID.\\n    ///\\n    /// .. note:: This function can only be called by the contract owner.\\n    ///\\n    /// @param chainId The chain ID of the chain.\\n    /// @param finalityPeriod The finality period of the chain in seconds.\\n    /// @param transferCost The transfer cost (fill, claim, withdraw) on the chain in WEI.\\n    /// @param targetWeightPPM The share of the target chain costs (fill) in parts per million.\\n    function updateChain(\\n        uint256 chainId,\\n        uint256 finalityPeriod,\\n        uint256 transferCost,\\n        uint256 targetWeightPPM\\n    ) external onlyOwner {\\n        require(targetWeightPPM <= 999_999, \\\"Maximum PPM of 999999 exceeded\\\");\\n\\n        Chain storage chain = chains[chainId];\\n        chain.finalityPeriod = finalityPeriod;\\n        chain.transferCost = transferCost;\\n        chain.targetWeightPPM = targetWeightPPM;\\n\\n        emit ChainUpdated(\\n            chainId,\\n            finalityPeriod,\\n            transferCost,\\n            targetWeightPPM\\n        );\\n    }\\n\\n    /// Returns whether a fill is invalidated or not\\n    ///\\n    /// Calling invalidateFill() will set this boolean to true,\\n    /// marking that the ``fillId`` for the corresponding ``requestId`` was\\n    /// invalidated.\\n    /// Calling resolveRequest will validate it again, setting request.invalidatedFills[fillId]\\n    /// to false.\\n    /// .. seealso:: :sol:func:`invalidateFill`\\n    /// .. seealso:: :sol:func:`resolveRequest`\\n    ///\\n    /// @param requestId The request ID\\n    /// @param fillId The fill ID\\n    /// @return Whether the fill ID is invalid for the given request ID\\n    function isInvalidFill(\\n        bytes32 requestId,\\n        bytes32 fillId\\n    ) public view returns (bool) {\\n        return requests[requestId].invalidFillIds[fillId];\\n    }\\n\\n    /// Mark the request identified by ``requestId`` as filled by ``filler``.\\n    ///\\n    /// .. note::\\n    ///\\n    ///     This function is a restricted call function. Only callable by the added caller.\\n    ///\\n    /// @param requestId The request ID.\\n    /// @param fillId The fill ID.\\n    /// @param resolutionChainId The resolution (L1) chain ID.\\n    /// @param filler The address that filled the request.\\n    function resolveRequest(\\n        bytes32 requestId,\\n        bytes32 fillId,\\n        uint256 resolutionChainId,\\n        address filler\\n    ) external restricted(resolutionChainId) {\\n        Request storage request = requests[requestId];\\n        request.filler = filler;\\n        request.fillId = fillId;\\n\\n        request.invalidFillIds[fillId] = false;\\n\\n        emit RequestResolved(requestId, filler, fillId);\\n    }\\n\\n    /// Mark the fill identified by ``requestId`` and ``fillId`` as invalid.\\n    ///\\n    /// .. note::\\n    ///\\n    ///     This function is a restricted call function. Only callable by the added caller.\\n    ///\\n    /// @param requestId The request ID.\\n    /// @param fillId The fill ID.\\n    /// @param resolutionChainId The resolution (L1) chain ID.\\n    function invalidateFill(\\n        bytes32 requestId,\\n        bytes32 fillId,\\n        uint256 resolutionChainId\\n    ) external restricted(resolutionChainId) {\\n        Request storage request = requests[requestId];\\n        require(\\n            request.filler == address(0),\\n            \\\"Cannot invalidate resolved fills\\\"\\n        );\\n        require(\\n            request.invalidFillIds[fillId] == false,\\n            \\\"Fill already invalidated\\\"\\n        );\\n\\n        request.invalidFillIds[fillId] = true;\\n\\n        emit FillInvalidatedResolved(requestId, fillId);\\n    }\\n\\n    /// Pauses the contract.\\n    ///\\n    /// Once the contract is paused, it cannot be used to create new\\n    /// requests anymore. Withdrawing deposited funds and claim stakes\\n    /// still works, though.\\n    ///\\n    /// .. note:: This function can only be called when the contract is not paused.\\n    /// .. note:: This function can only be called by the contract owner.\\n    function pause() external onlyOwner {\\n        _pause();\\n    }\\n\\n    /// Unpauses the contract.\\n    ///\\n    /// Once the contract is unpaused, it can be used normally.\\n    ///\\n    /// .. note:: This function can only be called when the contract is paused.\\n    /// .. note:: This function can only be called by the contract owner.\\n    function unpause() external onlyOwner {\\n        _unpause();\\n    }\\n}\\n\"\r\n    },\r\n    \".cache/OpenZeppelin/v4.8.0/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"LpWhitelist.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nimport \\\"OpenZeppelin/openzeppelin-contracts@4.8.0/contracts/access/Ownable.sol\\\";\\n\\n/// Liquidity Provider Whitelist.\\n///\\n/// This contract describes the concept of a whitelist for allowed Lps. RequestManager and FillManager\\n/// inherit from this contract.\\ncontract LpWhitelist is Ownable {\\n    /// Emitted when a liquidity provider has been added to the set of allowed\\n    /// liquidity providers.\\n    ///\\n    /// .. seealso:: :sol:func:`addAllowedLp`\\n    event LpAdded(address lp);\\n\\n    /// Emitted when a liquidity provider has been removed from the set of allowed\\n    /// liquidity providers.\\n    ///\\n    /// .. seealso:: :sol:func:`removeAllowedLp`\\n    event LpRemoved(address lp);\\n\\n    /// The mapping containing addresses allowed to provide liquidity.\\n    mapping(address lp => bool allowed) public allowedLps;\\n\\n    /// Modifier to check whether the passed address is an allowed LP\\n    modifier onlyAllowed(address addressToCheck) {\\n        require(allowedLps[addressToCheck], \\\"Not allowed\\\");\\n        _;\\n    }\\n\\n    /// Add a liquidity provider to the set of allowed liquidity providers.\\n    ///\\n    /// .. note:: This function can only be called by the contract owner.\\n    ///\\n    /// @param newLp The liquidity provider.\\n    function addAllowedLp(address newLp) public onlyOwner {\\n        allowedLps[newLp] = true;\\n\\n        emit LpAdded(newLp);\\n    }\\n\\n    /// Remove a liquidity provider from the set of allowed liquidity providers.\\n    ///\\n    /// .. note:: This function can only be called by the contract owner.\\n    ///\\n    /// @param oldLp The liquidity provider.\\n    function removeAllowedLp(address oldLp) public onlyOwner {\\n        delete allowedLps[oldLp];\\n\\n        emit LpRemoved(oldLp);\\n    }\\n}\\n\"\r\n    },\r\n    \".cache/OpenZeppelin/v4.8.0/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \".cache/OpenZeppelin/v4.8.0/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \".cache/OpenZeppelin/v4.8.0/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../extensions/draft-IERC20Permit.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    function safePermit(\\n        IERC20Permit token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \".cache/OpenZeppelin/v4.8.0/token/ERC20/extensions/draft-IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \".cache/OpenZeppelin/v4.8.0/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \".cache/OpenZeppelin/v4.8.0/security/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor() {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        _requireNotPaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        _requirePaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is paused.\\n     */\\n    function _requireNotPaused() internal view virtual {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is not paused.\\n     */\\n    function _requirePaused() internal view virtual {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\"\r\n    },\r\n    \".cache/OpenZeppelin/v4.8.0/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1);\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator,\\n        Rounding rounding\\n    ) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10**64) {\\n                value /= 10**64;\\n                result += 64;\\n            }\\n            if (value >= 10**32) {\\n                value /= 10**32;\\n                result += 32;\\n            }\\n            if (value >= 10**16) {\\n                value /= 10**16;\\n                result += 16;\\n            }\\n            if (value >= 10**8) {\\n                value /= 10**8;\\n                result += 8;\\n            }\\n            if (value >= 10**4) {\\n                value /= 10**4;\\n                result += 4;\\n            }\\n            if (value >= 10**2) {\\n                value /= 10**2;\\n                result += 2;\\n            }\\n            if (value >= 10**1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"BeamerUtils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nlibrary BeamerUtils {\\n    function createRequestId(\\n        uint256 sourceChainId,\\n        uint256 targetChainId,\\n        address targetTokenAddress,\\n        address targetReceiverAddress,\\n        uint256 amount,\\n        uint96 nonce\\n    ) internal pure returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encodePacked(\\n                    sourceChainId,\\n                    targetChainId,\\n                    targetTokenAddress,\\n                    targetReceiverAddress,\\n                    amount,\\n                    nonce\\n                )\\n            );\\n    }\\n}\\n\"\r\n    },\r\n    \"RestrictedCalls.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nimport \\\"OpenZeppelin/openzeppelin-contracts@4.8.0/contracts/access/Ownable.sol\\\";\\nimport \\\"../interfaces/IMessenger.sol\\\";\\n\\n/// A helper contract that provides a way to restrict callers of restricted functions\\n/// to a single address. This allows for a trusted call chain,\\n/// as described in :ref:`contracts' architecture <contracts-architecture>`.\\ncontract RestrictedCalls is Ownable {\\n    /// Maps caller chain IDs to tuples [caller, messenger].\\n    ///\\n    /// For same-chain calls, the messenger address is 0x0.\\n    mapping(uint256 callerChainId => address[2]) public callers;\\n\\n    function _addCaller(\\n        uint256 callerChainId,\\n        address caller,\\n        address messenger\\n    ) internal {\\n        require(caller != address(0), \\\"RestrictedCalls: caller cannot be 0\\\");\\n        require(\\n            callers[callerChainId][0] == address(0),\\n            \\\"RestrictedCalls: caller already exists\\\"\\n        );\\n        callers[callerChainId] = [caller, messenger];\\n    }\\n\\n    /// Allow calls from an address on the same chain.\\n    ///\\n    /// @param caller The caller.\\n    function addCaller(address caller) external onlyOwner {\\n        _addCaller(block.chainid, caller, address(0));\\n    }\\n\\n    /// Allow calls from an address on another chain.\\n    ///\\n    /// @param callerChainId The caller's chain ID.\\n    /// @param caller The caller.\\n    /// @param messenger The messenger.\\n    function addCaller(\\n        uint256 callerChainId,\\n        address caller,\\n        address messenger\\n    ) external onlyOwner {\\n        _addCaller(callerChainId, caller, messenger);\\n    }\\n\\n    /// Mark the function as restricted.\\n    ///\\n    /// Calls to the restricted function can only come from an address that\\n    /// was previously added by a call to :sol:func:`addCaller`.\\n    ///\\n    /// Example usage::\\n    ///\\n    ///     restricted(block.chainid)   // expecting calls from the same chain\\n    ///     restricted(otherChainId)    // expecting calls from another chain\\n    ///\\n    modifier restricted(uint256 callerChainId) {\\n        address caller = callers[callerChainId][0];\\n\\n        if (callerChainId == block.chainid) {\\n            require(msg.sender == caller, \\\"RestrictedCalls: call disallowed\\\");\\n        } else {\\n            address messenger = callers[callerChainId][1];\\n            require(\\n                messenger != address(0),\\n                \\\"RestrictedCalls: messenger not set\\\"\\n            );\\n            require(\\n                IMessenger(messenger).callAllowed(caller, msg.sender),\\n                \\\"RestrictedCalls: call disallowed\\\"\\n            );\\n        }\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \".cache/Interfaces/local/IMessenger.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.12;\\n\\n/// The messenger interface.\\n///\\n/// Implementations of this interface are expected to transport\\n/// messages across the L1 <-> L2 boundary. For instance,\\n/// if an implementation is deployed on L1, the :sol:func:`sendMessage`\\n/// would send a message to a L2 chain, as determined by the implementation.\\n/// In order to do this, a messenger implementation may use a native\\n/// messenger contract. In such cases, :sol:func:`nativeMessenger` must\\n/// return the address of the native messenger contract.\\ninterface IMessenger {\\n    /// Send a message across the L1 <-> L2 boundary.\\n    ///\\n    /// @param target The message recipient.\\n    /// @param message The message.\\n    function sendMessage(address target, bytes calldata message) external;\\n\\n    /// Return whether the call is allowed or not.\\n    ///\\n    /// @param caller The caller.\\n    /// @param courier The contract that is trying to deliver the message.\\n    function callAllowed(address caller, address courier)\\n        external\\n        view\\n        returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"remappings\": [\r\n      \"OpenZeppelin/openzeppelin-contracts@4.8.0/contracts=.cache/OpenZeppelin/v4.8.0\",\r\n      \"interfaces=.cache/Interfaces/local\"\r\n    ],\r\n    \"evmVersion\": \"london\"\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint96\",\"name\":\"_claimStake\",\"type\":\"uint96\"},{\"internalType\":\"uint256\",\"name\":\"_claimRequestExtension\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_claimPeriod\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_challengePeriodExtension\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"finalityPeriod\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"transferCost\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"targetWeightPPM\",\"type\":\"uint256\"}],\"name\":\"ChainUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint96\",\"name\":\"claimId\",\"type\":\"uint96\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"claimer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint96\",\"name\":\"claimerStake\",\"type\":\"uint96\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"lastChallenger\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint96\",\"name\":\"challengerStakeTotal\",\"type\":\"uint96\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"termination\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"fillId\",\"type\":\"bytes32\"}],\"name\":\"ClaimMade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint96\",\"name\":\"claimId\",\"type\":\"uint96\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"stakeRecipient\",\"type\":\"address\"}],\"name\":\"ClaimStakeWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"DepositWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"minFeePPM\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"lpFeePPM\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"protocolFeePPM\",\"type\":\"uint32\"}],\"name\":\"FeesUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"fillId\",\"type\":\"bytes32\"}],\"name\":\"FillInvalidatedResolved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"lp\",\"type\":\"address\"}],\"name\":\"LpAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"lp\",\"type\":\"address\"}],\"name\":\"LpRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"targetChainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sourceTokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"targetTokenAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sourceAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"targetAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint96\",\"name\":\"nonce\",\"type\":\"uint96\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"validUntil\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lpFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"protocolFee\",\"type\":\"uint256\"}],\"name\":\"RequestCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"filler\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"fillId\",\"type\":\"bytes32\"}],\"name\":\"RequestResolved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"transferLimit\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethInToken\",\"type\":\"uint256\"}],\"name\":\"TokenUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CLAIM_ID_WITHDRAWN_EXPIRED\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"\",\"type\":\"uint96\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_VALIDITY_PERIOD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_VALIDITY_PERIOD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newLp\",\"type\":\"address\"}],\"name\":\"addAllowedLp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"callerChainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"messenger\",\"type\":\"address\"}],\"name\":\"addCaller\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"addCaller\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lp\",\"type\":\"address\"}],\"name\":\"allowedLps\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"allowed\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"callerChainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"callers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"}],\"name\":\"chains\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"finalityPeriod\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"transferCost\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"targetWeightPPM\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint96\",\"name\":\"claimId\",\"type\":\"uint96\"}],\"name\":\"challengeClaim\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"challengePeriodExtension\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"claimer\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"fillId\",\"type\":\"bytes32\"}],\"name\":\"claimRequest\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"\",\"type\":\"uint96\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"fillId\",\"type\":\"bytes32\"}],\"name\":\"claimRequest\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"\",\"type\":\"uint96\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimRequestExtension\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimStake\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"\",\"type\":\"uint96\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint96\",\"name\":\"claimId\",\"type\":\"uint96\"}],\"name\":\"claims\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"claimer\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"claimerStake\",\"type\":\"uint96\"},{\"internalType\":\"address\",\"name\":\"lastChallenger\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"challengerStakeTotal\",\"type\":\"uint96\"},{\"internalType\":\"uint256\",\"name\":\"withdrawnAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"termination\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"fillId\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"targetChainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"sourceTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"targetTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"targetAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"validityPeriod\",\"type\":\"uint256\"}],\"name\":\"createRequest\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentNonce\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"\",\"type\":\"uint96\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"fillId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"resolutionChainId\",\"type\":\"uint256\"}],\"name\":\"invalidateFill\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"fillId\",\"type\":\"bytes32\"}],\"name\":\"isInvalidFill\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"}],\"name\":\"isWithdrawn\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"targetChainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"lpFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lpFeePPM\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minFeePPM\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"targetChainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"minLpFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"protocolFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"protocolFeePPM\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"oldLp\",\"type\":\"address\"}],\"name\":\"removeAllowedLp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"}],\"name\":\"requests\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"sourceTokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"targetChainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"validUntil\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"lpFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"protocolFee\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"activeClaims\",\"type\":\"uint32\"},{\"internalType\":\"uint96\",\"name\":\"withdrawClaimId\",\"type\":\"uint96\"},{\"internalType\":\"address\",\"name\":\"filler\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"fillId\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"fillId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"resolutionChainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"filler\",\"type\":\"address\"}],\"name\":\"resolveRequest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"tokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"transferLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ethInToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collectedProtocolFees\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"targetChainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"totalFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"targetChainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferableAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"finalityPeriod\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"transferCost\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"targetWeightPPM\",\"type\":\"uint256\"}],\"name\":\"updateChain\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_minFeePPM\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_lpFeePPM\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_protocolFeePPM\",\"type\":\"uint32\"}],\"name\":\"updateFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"transferLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ethInToken\",\"type\":\"uint256\"}],\"name\":\"updateToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"participant\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"claimId\",\"type\":\"uint96\"}],\"name\":\"withdraw\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint96\",\"name\":\"claimId\",\"type\":\"uint96\"}],\"name\":\"withdraw\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"}],\"name\":\"withdrawExpiredRequest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"withdrawProtocolFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "RequestManager", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000000000000000000000000000002386f26fc10000000000000000000000000000000000000000000000000000000000000001518000000000000000000000000000000000000000000000000000000000000151800000000000000000000000000000000000000000000000000000000000015180", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}