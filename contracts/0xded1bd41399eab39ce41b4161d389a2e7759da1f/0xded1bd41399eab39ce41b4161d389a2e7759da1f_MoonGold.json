{"SourceCode": "{\"ERC20Interface.sol\":{\"content\":\"pragma solidity ^0.5.10;\\r\\n\\r\\ncontract ERC20Interface {\\r\\n    function totalSupply() \\r\\n\\t\\tpublic \\r\\n\\t\\tview \\r\\n\\t\\treturns (uint256);\\r\\n\\r\\n    function balanceOf(address tokenOwner) \\r\\n\\t\\tpublic \\r\\n\\t\\tview \\r\\n\\t\\treturns (uint256 balance);\\r\\n    \\r\\n\\tfunction allowance\\r\\n\\t\\t(address tokenOwner, address spender) \\r\\n\\t\\tpublic \\r\\n\\t\\tview \\r\\n\\t\\treturns (uint256 remaining);\\r\\n\\r\\n    function transfer(address to, uint256 tokens) \\t\\t\\t\\tpublic \\r\\n\\t\\treturns (bool success);\\r\\n    \\r\\n\\tfunction approve(address spender, uint256 tokens) \\t\\tpublic \\r\\n\\t\\treturns (bool success);\\r\\n\\r\\n    function transferFrom \\r\\n\\t\\t(address from, address to, uint256 tokens) \\t\\t\\t\\tpublic \\r\\n\\t\\treturns (bool success);\\r\\n\\r\\n\\r\\n    event Transfer(address indexed from, address indexed to, uint256 tokens);\\r\\n    event Approval(address indexed tokenOwner, address indexed spender, uint256 tokens);\\r\\n}\"},\"MoonGold.sol\":{\"content\":\"pragma solidity ^0.5.10;\\r\\n\\r\\nimport \\\"./ERC20Interface.sol\\\";\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\n\\r\\n\\r\\ncontract MoonGold {\\r\\n\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    /*=================================\\r\\n    =            MODIFIERS            =\\r\\n    =================================*/\\r\\n    // only people with tokens\\r\\n    modifier onlybelievers () {\\r\\n        require(myTokens() \\u003e 0, \\\"Not Believer\\\");\\r\\n        _;\\r\\n    }\\r\\n    \\r\\n    // only people with profits\\r\\n    modifier onlyhodler() {\\r\\n        require(myDividends(true) \\u003e 0, \\\"Not Holder\\\");\\r\\n        _;\\r\\n    }\\r\\n    \\r\\n    \\r\\n    \\r\\n    /*==============================\\r\\n    =            EVENTS            =\\r\\n    ==============================*/\\r\\n    event onTokenPurchase(\\r\\n        address indexed customerAddress,\\r\\n        uint256 incomingMoonday,\\r\\n        uint256 tokensMinted,\\r\\n        address indexed referredBy\\r\\n    );\\r\\n    \\r\\n    event onTokenSell(\\r\\n        address indexed customerAddress,\\r\\n        uint256 tokensBurned,\\r\\n        uint256 moondayEarned\\r\\n    );\\r\\n    \\r\\n    event onReinvestment(\\r\\n        address indexed customerAddress,\\r\\n        uint256 moondayReinvested,\\r\\n        uint256 tokensMinted\\r\\n    );\\r\\n    \\r\\n    event onWithdraw(\\r\\n        address indexed customerAddress,\\r\\n        uint256 moondayWithdrawn\\r\\n    );\\r\\n    \\r\\n    // ERC20\\r\\n    event Transfer(\\r\\n        address indexed from,\\r\\n        address indexed to,\\r\\n        uint256 tokens\\r\\n    );\\r\\n    \\r\\n    \\r\\n    /*=====================================\\r\\n    =            CONFIGURABLES            =\\r\\n    =====================================*/\\r\\n    string public name = \\\"Moon Gold\\\";\\r\\n    string public symbol = \\\"MOONGold\\\";\\r\\n    uint256 constant public decimals = 18;\\r\\n    uint256 constant internal dividendFee_ = 6;\\r\\n    uint256 constant internal MANAGER_FEE = 3;\\r\\n    uint256 constant internal PARTNER_FEE = 1;\\r\\n\\tuint256 constant internal DEV_FEE = 1;\\r\\n    uint256 constant internal CAPITAL_FEE = 10;\\r\\n\\r\\n    uint256 constant internal tokenPriceInitial_ = 0.0000001 ether;\\r\\n    uint256 constant internal tokenPriceIncremental_ = 0.00000001 ether;\\r\\n    uint256 constant internal magnitude = 2**64;\\r\\n    \\r\\n    // proof of stake (defaults at 1 token)\\r\\n    uint256 public stakingRequirement = 1 ether;\\r\\n    \\r\\n    \\r\\n    ERC20Interface MoondayToken;\\r\\n    \\r\\n   /*================================\\r\\n    =            DATASETS            =\\r\\n    ================================*/\\r\\n    // amount of shares for each address (scaled number)\\r\\n    mapping(address =\\u003e uint256) internal tokenBalanceLedger_;\\r\\n    mapping(address =\\u003e uint256) internal referralBalance_;\\r\\n    mapping(address =\\u003e int256) internal payoutsTo_;\\r\\n\\r\\n    uint256 internal tokenSupply_ = 0;\\r\\n    uint256 internal profitPerShare_;\\r\\n\\r\\n\\r\\n    address payable public managerAddress;\\r\\n    address payable public devAddress;\\r\\n\\taddress payable public partnerAddress;\\r\\n    address payable public partnerAddress2;\\r\\n    address payable public moondayCapitalAddress;\\r\\n    \\r\\n\\r\\n    /*=======================================\\r\\n    =            PUBLIC FUNCTIONS            =\\r\\n    =======================================*/\\r\\n    /*\\r\\n    * -- APPLICATION ENTRY POINTS --  \\r\\n    */\\r\\n    constructor(\\r\\n        address payable _managerAddress, \\r\\n        address payable _partnerAddress, \\r\\n        address payable _partnerAddress2, \\r\\n        address payable _devAddress,\\r\\n        address payable _moondayCapitalAddress,\\r\\n        address _MoondayToken\\r\\n        ) public {\\r\\n        managerAddress = _managerAddress;\\r\\n        partnerAddress = _partnerAddress;\\r\\n        partnerAddress2 = _partnerAddress2;\\r\\n\\t\\tdevAddress = _devAddress;\\r\\n        moondayCapitalAddress = _moondayCapitalAddress;\\r\\n        MoondayToken = ERC20Interface(_MoondayToken);\\r\\n    }\\r\\n    \\r\\n     \\r\\n    /**\\r\\n     * Converts all incoming Moonday to MoonGold for the caller, and passes down the referral address (if any)\\r\\n     */\\r\\n    function buy(uint256 _amount, address _referredBy)\\r\\n        public\\r\\n        returns(uint256)\\r\\n    {\\r\\n        uint256 received = _amount.mul(99).div(100);\\r\\n\\r\\n\\t\\tMoondayToken.transferFrom(msg.sender, address(this), _amount);\\r\\n        purchaseTokens(received, _referredBy);\\r\\n    }\\r\\n    \\r\\n    \\r\\n    /**\\r\\n     * Converts all of caller\\u0027s dividends to tokens.\\r\\n     */\\r\\n    function reinvest()\\r\\n        onlyhodler()\\r\\n        public\\r\\n    {\\r\\n        // fetch dividends\\r\\n        uint256 _dividends = myDividends(false); // retrieve ref. bonus later in the code\\r\\n        \\r\\n        // pay out the dividends virtually\\r\\n        address _customerAddress = msg.sender;\\r\\n        payoutsTo_[_customerAddress] +=  (int256) (_dividends * magnitude);\\r\\n        \\r\\n        // retrieve ref. bonus\\r\\n        _dividends += referralBalance_[_customerAddress];\\r\\n        referralBalance_[_customerAddress] = 0;\\r\\n        \\r\\n        // dispatch a buy order with the virtualized \\\"withdrawn dividends\\\"\\r\\n        uint256 _tokens = purchaseTokens(_dividends, address(0));\\r\\n        \\r\\n        // fire event\\r\\n        emit onReinvestment(_customerAddress, _dividends, _tokens);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * Alias of sell() and withdraw().\\r\\n     */\\r\\n    function exit()\\r\\n        public\\r\\n    {\\r\\n        // get token count for caller \\u0026 sell them all\\r\\n        address _customerAddress = msg.sender;\\r\\n        uint256 _tokens = tokenBalanceLedger_[_customerAddress];\\r\\n        if(_tokens \\u003e 0) sell(_tokens);\\r\\n        \\r\\n        withdraw();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Withdraws all of the callers earnings.\\r\\n     */\\r\\n    function withdraw()\\r\\n        onlyhodler()\\r\\n        public\\r\\n    {\\r\\n        // setup data\\r\\n        address _customerAddress = msg.sender;\\r\\n        uint256 _dividends = myDividends(false); // get ref. bonus later in the code\\r\\n        \\r\\n        // update dividend tracker\\r\\n        payoutsTo_[_customerAddress] +=  (int256) (_dividends * magnitude);\\r\\n        \\r\\n        // add ref. bonus\\r\\n        _dividends += referralBalance_[_customerAddress];\\r\\n        referralBalance_[_customerAddress] = 0;\\r\\n        \\r\\n        // delivery service\\r\\n\\r\\n        MoondayToken.transfer(_customerAddress, _dividends);\\r\\n        \\r\\n        // fire event\\r\\n        emit onWithdraw(_customerAddress, _dividends);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * Liquifies tokens to Moonday.\\r\\n     */\\r\\n    function sell(uint256 _amountOfTokens)\\r\\n        onlybelievers ()\\r\\n        public\\r\\n    {\\r\\n      \\r\\n        address _customerAddress = msg.sender;\\r\\n       \\r\\n        require(_amountOfTokens \\u003c= tokenBalanceLedger_[_customerAddress], \\\"Invalid amount to sell\\\");\\r\\n        uint256 _tokens = _amountOfTokens;\\r\\n        uint256 _moonday = tokensToMoonday_(_tokens);\\r\\n        uint256 _dividends = _moonday.mul(dividendFee_).div(100);\\r\\n        uint256 _taxedMoonday = _moonday.sub(_dividends);\\r\\n        \\r\\n        // burn the sold tokens\\r\\n        tokenSupply_ = tokenSupply_.sub(_tokens);\\r\\n        tokenBalanceLedger_[_customerAddress] = tokenBalanceLedger_[_customerAddress].sub(_tokens);\\r\\n        \\r\\n        // update dividends tracker\\r\\n        int256 _updatedPayouts = (int256) (profitPerShare_ * _tokens + (_taxedMoonday * magnitude));\\r\\n        payoutsTo_[_customerAddress] -= _updatedPayouts;       \\r\\n        \\r\\n        // dividing by zero is a bad idea\\r\\n        if (tokenSupply_ \\u003e 0) {\\r\\n            // update the amount of dividends per token\\r\\n            profitPerShare_ = profitPerShare_.add((_dividends * magnitude) / tokenSupply_);\\r\\n        }\\r\\n        \\r\\n        // fire event\\r\\n        emit onTokenSell(_customerAddress, _tokens, _taxedMoonday);\\r\\n    }\\r\\n    \\r\\n    \\r\\n    /**\\r\\n     * Transfer tokens from the caller to a new holder.\\r\\n     * Remember, there\\u0027s a 6% fee here as well.\\r\\n     */\\r\\n    function transfer(address _toAddress, uint256 _amountOfTokens)\\r\\n        onlybelievers ()\\r\\n        public\\r\\n        returns(bool)\\r\\n    {\\r\\n        // setup\\r\\n        address _customerAddress = msg.sender;\\r\\n        \\r\\n        // make sure we have the requested tokens\\r\\n     \\r\\n        require(_amountOfTokens \\u003c= tokenBalanceLedger_[_customerAddress], \\\"Invalid Balance\\\");\\r\\n        \\r\\n        // withdraw all outstanding dividends first\\r\\n        if(myDividends(true) \\u003e 0) withdraw();\\r\\n        \\r\\n        // liquify 6% of the tokens that are transfered\\r\\n        // these are dispersed to shareholders\\r\\n        uint256 _tokenFee = _amountOfTokens.mul(dividendFee_).div(100);\\r\\n        uint256 _taxedTokens = _amountOfTokens.sub(_tokenFee);\\r\\n        uint256 _dividends = tokensToMoonday_(_tokenFee);\\r\\n  \\r\\n        // burn the fee tokens\\r\\n        tokenSupply_ = tokenSupply_.sub(_tokenFee);\\r\\n\\r\\n        // exchange tokens\\r\\n        tokenBalanceLedger_[_customerAddress] = tokenBalanceLedger_[_customerAddress].sub(_amountOfTokens);\\r\\n        tokenBalanceLedger_[_toAddress] = tokenBalanceLedger_[_toAddress].add(_taxedTokens);\\r\\n        \\r\\n        // update dividend trackers\\r\\n        payoutsTo_[_customerAddress] -= (int256) (profitPerShare_ * _amountOfTokens);\\r\\n        payoutsTo_[_toAddress] += (int256) (profitPerShare_ * _taxedTokens);\\r\\n        \\r\\n        // disperse dividends among holders\\r\\n        profitPerShare_ = profitPerShare_.add((_dividends * magnitude) / tokenSupply_);\\r\\n        \\r\\n        // fire event\\r\\n        emit Transfer(_customerAddress, _toAddress, _taxedTokens);\\r\\n        \\r\\n        // ERC20\\r\\n        return true;\\r\\n       \\r\\n    }\\r\\n    \\r\\n    \\r\\n    /*----------  HELPERS AND CALCULATORS  ----------*/\\r\\n    /**\\r\\n     * Method to view the current Moonday stored in the contract\\r\\n     * Example: totalMoondayBalance()\\r\\n     */\\r\\n    function totalMoondayBalance()\\r\\n        public\\r\\n        view\\r\\n        returns(uint256)\\r\\n    {\\r\\n        return MoondayToken.balanceOf(address(this));\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * Retrieve the total token supply.\\r\\n     */\\r\\n    function totalSupply()\\r\\n        public\\r\\n        view\\r\\n        returns(uint256)\\r\\n    {\\r\\n        return tokenSupply_;\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * Retrieve the tokens owned by the caller.\\r\\n     */\\r\\n    function myTokens()\\r\\n        public\\r\\n        view\\r\\n        returns(uint256)\\r\\n    {\\r\\n        address _customerAddress = msg.sender;\\r\\n        return balanceOf(_customerAddress);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * Retrieve the dividends owned by the caller.\\r\\n       */ \\r\\n    function myDividends(bool _includeReferralBonus)\\r\\n        public \\r\\n        view \\r\\n        returns(uint256)\\r\\n    {\\r\\n        address _customerAddress = msg.sender;\\r\\n        return _includeReferralBonus ? dividendsOf(_customerAddress) + referralBalance_[_customerAddress] : dividendsOf(_customerAddress) ;\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * Retrieve the token balance of any single address.\\r\\n     */\\r\\n    function balanceOf(address _customerAddress)\\r\\n        view\\r\\n        public\\r\\n        returns(uint256)\\r\\n    {\\r\\n        return tokenBalanceLedger_[_customerAddress];\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * Retrieve the dividend balance of any single address.\\r\\n     */\\r\\n    function dividendsOf(address _customerAddress)\\r\\n        view\\r\\n        public\\r\\n        returns(uint256)\\r\\n    {\\r\\n        return (uint256) ((int256)(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude;\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * Return the buy price of 1 individual token.\\r\\n     */\\r\\n    function sellPrice() \\r\\n        public \\r\\n        view \\r\\n        returns(uint256)\\r\\n    {\\r\\n       \\r\\n        if(tokenSupply_ == 0){\\r\\n            return tokenPriceInitial_ - tokenPriceIncremental_;\\r\\n        } else {\\r\\n            uint256 _moonday = tokensToMoonday_(1e18);\\r\\n            uint256 _dividends = _moonday.mul(dividendFee_).div(100);\\r\\n            uint256 _taxedMoonday = _moonday.sub(_dividends);\\r\\n            return _taxedMoonday;\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * Return the sell price of 1 individual token.\\r\\n     */\\r\\n    function buyPrice() \\r\\n        public \\r\\n        view \\r\\n        returns(uint256)\\r\\n    {\\r\\n        \\r\\n        if(tokenSupply_ == 0){\\r\\n            return tokenPriceInitial_ + tokenPriceIncremental_;\\r\\n        } else {\\r\\n            uint256 _moonday = tokensToMoonday_(1e18);\\r\\n            uint256 _dividends = _moonday.mul(dividendFee_).div(100);\\r\\n            uint256 _taxedMoonday = _moonday.add(_dividends);\\r\\n            return _taxedMoonday;\\r\\n        }\\r\\n    }\\r\\n    \\r\\n   \\r\\n    function calculateTokensReceived(uint256 _moondayToSpend) \\r\\n        public \\r\\n        view \\r\\n        returns(uint256)\\r\\n    {\\r\\n        uint256 _dividends = _moondayToSpend.mul(dividendFee_).div(100);\\r\\n        uint256 _taxedMoonday = _moondayToSpend.sub(_dividends);\\r\\n        uint256 _amountOfTokens = moondayToTokens_(_taxedMoonday);\\r\\n        \\r\\n        return _amountOfTokens;\\r\\n    }\\r\\n    \\r\\n   \\r\\n    function calculateMoondayReceived(uint256 _tokensToSell) \\r\\n        public \\r\\n        view \\r\\n        returns(uint256)\\r\\n    {\\r\\n        require(_tokensToSell \\u003c= tokenSupply_, \\\"Invalid amount to sell\\\");\\r\\n        uint256 _moonday = tokensToMoonday_(_tokensToSell);\\r\\n        uint256 _dividends = _moonday.mul(dividendFee_).div(100);\\r\\n        uint256 _taxedMoonday = _moonday.sub(_dividends);\\r\\n        return _taxedMoonday;\\r\\n    }\\r\\n    \\r\\n    \\r\\n    /*==========================================\\r\\n    =            INTERNAL FUNCTIONS            =\\r\\n    ==========================================*/\\r\\n    function purchaseTokens(uint256 _incomingMoonday, address _referredBy)\\r\\n        internal\\r\\n        returns(uint256)\\r\\n    {\\r\\n        // data setup\\r\\n        address _customerAddress = msg.sender;\\r\\n        uint256 _undividedDividends = _incomingMoonday.mul(dividendFee_).div(100);\\r\\n        \\r\\n        uint256 _referralBonus = _undividedDividends.div(3);\\r\\n\\r\\n        uint256 totalBonus = _referralBonus\\r\\n            .add(_undividedDividends.mul(MANAGER_FEE).div(100))\\r\\n            .add(_undividedDividends.mul(PARTNER_FEE).div(100))\\r\\n            .add(_undividedDividends.mul(PARTNER_FEE).div(100))\\r\\n            .add(_undividedDividends.mul(DEV_FEE).div(100))\\r\\n            .add(_undividedDividends.mul(CAPITAL_FEE).div(100));\\r\\n\\r\\n        MoondayToken.transfer(managerAddress, _undividedDividends.mul(MANAGER_FEE).div(100));\\r\\n\\t\\tMoondayToken.transfer(partnerAddress, _undividedDividends.mul(PARTNER_FEE).div(100));\\r\\n        MoondayToken.transfer(partnerAddress2, _undividedDividends.mul(PARTNER_FEE).div(100));\\r\\n\\t\\tMoondayToken.transfer(devAddress, _undividedDividends.mul(DEV_FEE).div(100));\\r\\n\\t\\tMoondayToken.transfer(moondayCapitalAddress, _undividedDividends.mul(CAPITAL_FEE).div(100));\\r\\n\\r\\n        uint256 _dividends = _undividedDividends.sub(totalBonus);\\r\\n        uint256 _taxedMoonday = _incomingMoonday.sub(_undividedDividends);\\r\\n        uint256 _amountOfTokens = moondayToTokens_(_taxedMoonday);\\r\\n        uint256 _fee = _dividends * magnitude;\\r\\n \\r\\n      \\r\\n        require(_amountOfTokens \\u003e 0 \\u0026\\u0026 (_amountOfTokens.add(tokenSupply_) \\u003e tokenSupply_), \\\"Invalid amount\\\");\\r\\n        \\r\\n        // is the user referred by a link?\\r\\n        if(\\r\\n            // is this a referred purchase?\\r\\n            _referredBy != address(0) \\u0026\\u0026\\r\\n\\r\\n            // no cheating!\\r\\n            _referredBy != _customerAddress \\u0026\\u0026\\r\\n            \\r\\n        \\r\\n            tokenBalanceLedger_[_referredBy] \\u003e= stakingRequirement\\r\\n        ){\\r\\n            // wealth redistribution\\r\\n            referralBalance_[_referredBy] = referralBalance_[_referredBy].add(_referralBonus); \\r\\n        } else {\\r\\n            // no ref purchase\\r\\n            // add the referral bonus back to the global dividends cake\\r\\n            _dividends = _dividends.add(_referralBonus); \\r\\n            _fee = _dividends * magnitude;\\r\\n        }\\r\\n        \\r\\n        // we can\\u0027t give people infinite Moonday\\r\\n        if(tokenSupply_ \\u003e 0){\\r\\n            \\r\\n            // add tokens to the pool\\r\\n            tokenSupply_ = tokenSupply_.add(_amountOfTokens); \\r\\n \\r\\n            // take the amount of dividends gained through this transaction, and allocates them evenly to each shareholder\\r\\n            profitPerShare_ += (_dividends * magnitude / (tokenSupply_));\\r\\n            \\r\\n            // calculate the amount of tokens the customer receives over his purchase \\r\\n            _fee = _fee - (_fee-(_amountOfTokens * (_dividends * magnitude / (tokenSupply_))));\\r\\n        \\r\\n        } else {\\r\\n            // add tokens to the pool\\r\\n            tokenSupply_ = _amountOfTokens;\\r\\n        }\\r\\n        \\r\\n        // update circulating supply \\u0026 the ledger address for the customer\\r\\n        tokenBalanceLedger_[_customerAddress] = tokenBalanceLedger_[_customerAddress].add(_amountOfTokens);\\r\\n        \\r\\n        \\r\\n        int256 _updatedPayouts = (int256) ((profitPerShare_ * _amountOfTokens) - _fee);\\r\\n        payoutsTo_[_customerAddress] += _updatedPayouts;\\r\\n        \\r\\n        // fire event\\r\\n        emit onTokenPurchase(_customerAddress, _incomingMoonday, _amountOfTokens, _referredBy);\\r\\n        \\r\\n        return _amountOfTokens;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Calculate Token price based on an amount of incoming Moonday\\r\\n     * It\\u0027s an algorithm, hopefully we gave you the whitepaper with it in scientific notation;\\r\\n     * Some conversions occurred to prevent decimal errors or underflows / overflows in solidity code.\\r\\n     */\\r\\n    function moondayToTokens_(uint256 _moonday)\\r\\n        internal\\r\\n        view\\r\\n        returns(uint256)\\r\\n    {\\r\\n        uint256 _tokenPriceInitial = tokenPriceInitial_ * 1e18;\\r\\n        uint256 _tokensReceived = \\r\\n         (\\r\\n            (\\r\\n                // underflow attempts BTFO\\r\\n                (sqrt\\r\\n                    (\\r\\n                        (_tokenPriceInitial**2)\\r\\n                        +\\r\\n                        (2*(tokenPriceIncremental_ * 1e18)*(_moonday * 1e18))\\r\\n                        +\\r\\n                        (((tokenPriceIncremental_)**2)*(tokenSupply_**2))\\r\\n                        +\\r\\n                        (2*(tokenPriceIncremental_)*_tokenPriceInitial*tokenSupply_)\\r\\n                    )\\r\\n                ).sub(_tokenPriceInitial)\\r\\n            )/(tokenPriceIncremental_)\\r\\n        )-(tokenSupply_)\\r\\n        ;\\r\\n  \\r\\n        return _tokensReceived;\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * Calculate token sell value.\\r\\n          */\\r\\n     function tokensToMoonday_(uint256 _tokens)\\r\\n        internal\\r\\n        view\\r\\n        returns(uint256)\\r\\n    {\\r\\n\\r\\n        uint256 tokens_ = (_tokens + 1e18);\\r\\n        uint256 _tokenSupply = (tokenSupply_ + 1e18);\\r\\n        uint256 _moondayReceived =\\r\\n        (\\r\\n            // underflow attempts BTFO\\r\\n            (\\r\\n                (\\r\\n                    (\\r\\n                        tokenPriceInitial_ +(tokenPriceIncremental_ * (_tokenSupply/1e18))\\r\\n                    )-tokenPriceIncremental_\\r\\n                )*(tokens_ - 1e18)\\r\\n            ).sub((tokenPriceIncremental_*((tokens_**2-tokens_)/1e18))/2)\\r\\n        /1e18);\\r\\n        return _moondayReceived;\\r\\n    }\\r\\n    \\r\\n    \\r\\n    function sqrt(uint x) internal pure returns (uint y) {\\r\\n        uint z = (x + 1) / 2;\\r\\n        y = x;\\r\\n        while (z \\u003c y) {\\r\\n            y = z;\\r\\n            z = (x / z + z) / 2;\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"},\"SafeMath.sol\":{\"content\":\"pragma solidity ^0.5.10;\\r\\n\\r\\nlibrary SafeMath {\\r\\n\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        require(b \\u003c= a, \\\"SafeMath: subtraction overflow\\\");\\r\\n        uint256 c = a - b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        require(b \\u003e 0, \\\"SafeMath: division by zero\\\");\\r\\n        uint256 c = a / b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n}\"}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_managerAddress\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_partnerAddress\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_partnerAddress2\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_devAddress\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_moondayCapitalAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_MoondayToken\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"moondayReinvested\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensMinted\",\"type\":\"uint256\"}],\"name\":\"onReinvestment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"incomingMoonday\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensMinted\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referredBy\",\"type\":\"address\"}],\"name\":\"onTokenPurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensBurned\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"moondayEarned\",\"type\":\"uint256\"}],\"name\":\"onTokenSell\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"moondayWithdrawn\",\"type\":\"uint256\"}],\"name\":\"onWithdraw\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_referredBy\",\"type\":\"address\"}],\"name\":\"buy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"buyPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokensToSell\",\"type\":\"uint256\"}],\"name\":\"calculateMoondayReceived\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_moondayToSpend\",\"type\":\"uint256\"}],\"name\":\"calculateTokensReceived\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"devAddress\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"dividendsOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"exit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"managerAddress\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"moondayCapitalAddress\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_includeReferralBonus\",\"type\":\"bool\"}],\"name\":\"myDividends\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"myTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"partnerAddress\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"partnerAddress2\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"reinvest\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amountOfTokens\",\"type\":\"uint256\"}],\"name\":\"sell\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sellPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stakingRequirement\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalMoondayBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_toAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amountOfTokens\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "MoonGold", "CompilerVersion": "v0.5.16+commit.9c3226ce", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "0000000000000000000000002ffb230b7ce4758e25f10f03dbce1278ce4441b500000000000000000000000093a4ed59486409c9a41114b0621fe5e7525247eb00000000000000000000000020f9b4cf601dc667c62a73c3ff8bafeaee4c54d00000000000000000000000004efd33509c894a4d628a940cdce10abb4e2e1b94000000000000000000000000beedb437a796dfebf77d16b96f9cdd35918ed8c10000000000000000000000001ad606adde97c0c28bd6ac85554176bc55783c01", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://34f7518abeb5fd3b40aa4be698724eec780aef636ad008685cf3558da41d9904"}