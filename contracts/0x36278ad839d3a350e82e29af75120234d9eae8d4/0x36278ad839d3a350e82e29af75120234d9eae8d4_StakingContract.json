{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Context} from \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * The initial owner is set to the address provided by the deployer. This can\\n * later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    /**\\n     * @dev The caller account is not authorized to perform an operation.\\n     */\\n    error OwnableUnauthorizedAccount(address account);\\n\\n    /**\\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\\n     */\\n    error OwnableInvalidOwner(address owner);\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\\n     */\\n    constructor(address initialOwner) {\\n        if (initialOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(initialOwner);\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        if (owner() != _msgSender()) {\\n            revert OwnableUnauthorizedAccount(_msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        if (newOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the value of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the value of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\n     * allowance mechanism. `value` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC165} from \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\\n     *   a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or\\n     *   {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\\n     *   a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the address zero.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Context.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/StakingContract.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity 0.8.23;\\n\\n//import \\\"hardhat/console.sol\\\";\\nimport \\\"./interfaces/INFTContract.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\ncontract StakingContract is Ownable {\\n\\n    event Staked(uint256[] ids, address owner);\\n    event Unstaked(uint256[] ids, address owner);\\n    event Halved(uint256 newRewardsPerBlock, address operator);\\n    event Claimed(address owner, uint256 amount);\\n\\n    uint256 constant startingRewardPerBlock = 50 * 10 ** 18;\\n    uint256 constant halvingInterval = 2100000;\\n    uint256 constant thresholdHR = 21000;\\n\\n    INFTContract immutable nftProvider;\\n    IERC20 immutable token;\\n    address operator;\\n\\n    mapping(uint256 => uint256) totalRewardPerHRatBlock;\\n\\n    mapping(uint256 => address) public owners;\\n    mapping(uint256 => uint256) startBlock;\\n    mapping(uint256 => uint256) hrs;\\n\\n    mapping(address => uint256) public userHR;\\n    mapping(address => uint256) public claimed;\\n    mapping(address => uint256) rewardAcc;\\n    mapping(address => uint256) lastUpdateBlock;\\n\\n    uint256 public currentActiveHR;\\n    uint256 public currentRewardsPerBlock;\\n    uint256 public nextHalvingTS;\\n\\n    mapping(address => int256) public nftAmounts;\\n\\n    int256 public nftStaked;\\n    uint256 public uniqStakers;\\n    uint256 public totalClaimed;\\n\\n    uint256 lastChangedRewardBlock;\\n    uint256 totalMintedintedBeforeHalving;\\n\\n    uint256 currentRewardsPerBHR;\\n    uint256 lastProcessedBlock;\\n    uint256 tokenBalance;\\n\\n    constructor(\\n        address _initialOwner,\\n        address _nftProvider,\\n        address _token\\n    ) Ownable(_initialOwner) {\\n        token = IERC20(_token);\\n        nftProvider = INFTContract(_nftProvider);\\n        tokenBalance = token.balanceOf(address(this));\\n    }\\n\\n    function getEarnedByVMM(uint256 id) public view returns (uint256) {\\n        return hrs[id] * (_currentTotalPerHR() - totalRewardPerHRatBlock[startBlock[id]]);\\n    }\\n\\n    function getAvailableForClaim(address user) public view returns (uint256) {\\n        return getTotalReward(user) - getClaimed(user);\\n    }\\n\\n    function getClaimed(address user) public view returns (uint256) {\\n        return claimed[user];\\n    }\\n\\n    function getTotalReward(address user) public view returns (uint256) {\\n        return rewardAcc[user] + userHR[user] * (_currentTotalPerHR() - totalRewardPerHRatBlock[lastUpdateBlock[user]]);\\n    }\\n\\n    function getAverageRewardPerBlock(address user) public view returns (uint256){\\n        uint256 bn = block.number;\\n        uint256 delta = bn - lastProcessedBlock;\\n        uint256 balance = token.balanceOf(address(this));\\n        uint256 feeIncome = balance - tokenBalance;\\n        return (userHR[user] * currentRewardsPerBHR) + (userHR[user] * feeIncome) / (delta * currentActiveHR);\\n    }\\n\\n    function getMinted() public view returns (uint256){\\n        return totalMintedintedBeforeHalving + (block.number - lastChangedRewardBlock) * currentRewardsPerBlock;\\n    }\\n\\n    function getRemainingBlockReward() public view returns (uint256){\\n        return 2 * startingRewardPerBlock * halvingInterval - getMinted();\\n    }\\n\\n    function claim() public {\\n        address user = msg.sender;\\n        _updateRewards();\\n        _updateUser(user, 0);\\n        uint256 amount = rewardAcc[user] - claimed[user];\\n        claimed[user] += amount;\\n        totalClaimed += amount;\\n        tokenBalance -= amount;\\n        token.transfer(user, amount);\\n        emit Claimed(user, amount);\\n    }\\n\\n    function stake(uint256[] memory ids) public {\\n        address receiver = nftProvider.ownerOf(ids[0]);\\n        require(\\n            receiver == msg.sender || operator == msg.sender,\\n            \\\"E01: Only owner or operator allowed to stake\\\"\\n        );\\n        uint8 len = uint8(ids.length);\\n        uint256 totalHR;\\n        uint256 bn = block.number;\\n\\n        _updateRewards();\\n        _updateUser(receiver, int8(len));\\n\\n        for (uint8 i = 0; i < len; ++i) {\\n            uint256 id = ids[i];\\n            address nftOwner = nftProvider.ownerOf(id);\\n            require(\\n                nftOwner == receiver,\\n                \\\"E02: All VMMs staked within one request should have same owner\\\"\\n            );\\n            require(startBlock[id] == 0, \\\"E03: VMM already staked\\\");\\n            owners[id] = nftOwner;\\n            uint256 hr = nftProvider.nftHashrate(id);\\n            totalHR += hr;\\n            hrs[id] = hr;\\n            startBlock[id] = bn;\\n        }\\n\\n        userHR[receiver] += totalHR;\\n        uint256 newHR = currentActiveHR + totalHR;\\n        if ((currentRewardsPerBlock == 0) && (newHR >= thresholdHR)) {\\n            currentRewardsPerBlock = startingRewardPerBlock;\\n            nextHalvingTS = bn + halvingInterval;\\n            lastChangedRewardBlock = bn;\\n        }\\n        currentActiveHR = newHR;\\n        currentRewardsPerBHR = currentRewardsPerBlock / newHR;\\n\\n        emit Staked(ids, receiver);\\n    }\\n\\n    function unstake(uint256[] memory ids) public {\\n        address staker = owners[ids[0]];\\n        require(\\n            staker == msg.sender || operator == msg.sender,\\n            \\\"E04: Only owner or operator allowed to unstake\\\"\\n        );\\n        uint8 len = uint8(ids.length);\\n        uint256 totalHR;\\n\\n        _updateRewards();\\n        _updateUser(staker, - int8(len));\\n\\n        for (uint8 i = 0; i < len; ++i) {\\n            uint256 id = ids[i];\\n            require(startBlock[id] != 0, \\\"E05: VMM is not staked\\\");\\n            require(owners[id] == staker, \\\"E06: All VMMs unstaked within one request should have same owner\\\");\\n            totalHR += hrs[id];\\n            startBlock[id] = 0;\\n            hrs[id] = 0;\\n            owners[id] = address(0);\\n        }\\n\\n        userHR[staker] -= totalHR;\\n        uint256 updatedActiveHR = currentActiveHR - totalHR;\\n        require(updatedActiveHR > 0, \\\"E07: Last VMM could not be unstaked\\\");\\n        currentActiveHR = updatedActiveHR;\\n        currentRewardsPerBHR = currentRewardsPerBlock / updatedActiveHR;\\n\\n        emit Unstaked(ids, staker);\\n    }\\n\\n    function restakeOnSell(uint256 id, address newOwner) public {\\n        require(startBlock[id] != 0, \\\"E08: VMM is not staked\\\");\\n        require(\\n            operator == msg.sender,\\n            \\\"E09: Only operator allowed to restake\\\"\\n        );\\n\\n        _updateRewards();\\n        address nftOwner = owners[id];\\n        uint256 bn = block.number;\\n        uint256 hr = hrs[id];\\n\\n        _updateUser(newOwner, 1);\\n        _updateUser(nftOwner, - 1);\\n\\n        startBlock[id] = bn;\\n\\n        userHR[nftOwner] -= hr;\\n        userHR[newOwner] += hr;\\n\\n        owners[id] = newOwner;\\n\\n        uint256[] memory t = new uint256[](1);\\n        t[0] = id;\\n        emit Unstaked(t, nftOwner);\\n        emit Staked(t, newOwner);\\n    }\\n\\n    function halve() public {\\n        if ((block.number > nextHalvingTS) && (currentRewardsPerBlock != 0)) {\\n            _updateRewards();\\n            totalMintedintedBeforeHalving += (block.number - lastChangedRewardBlock) * currentRewardsPerBlock;\\n            lastChangedRewardBlock = block.number;\\n            nextHalvingTS = block.number + halvingInterval;\\n            currentRewardsPerBlock = currentRewardsPerBlock / 2;\\n            currentRewardsPerBHR = currentRewardsPerBlock / currentActiveHR;\\n            emit Halved(currentRewardsPerBlock, msg.sender);\\n        }\\n    }\\n\\n    function setOperator(address _operator) public {\\n        _checkOwner();\\n        operator = _operator;\\n    }\\n\\n    function _currentTotalPerHR() private view returns (uint256) {\\n        return\\n            totalRewardPerHRatBlock[lastProcessedBlock] +\\n            ((block.number - lastProcessedBlock) * currentRewardsPerBHR) +\\n            ((token.balanceOf(address(this)) - tokenBalance) / currentActiveHR);\\n    }\\n\\n    function _updateRewards() private {\\n        unchecked {\\n            uint256 bn = block.number;\\n            uint256 delta = bn - lastProcessedBlock;\\n            uint256 balance = token.balanceOf(address(this));\\n            uint256 feeIncome = balance - tokenBalance;\\n            uint256 _currentActiveHR = currentActiveHR;\\n            uint256 feePerHR;\\n        // solhint-disable-next-line no-inline-assembly\\n            assembly {\\n            // black Solidity magic :)\\n                feePerHR := div(feeIncome, _currentActiveHR)\\n            }\\n            uint256 totalReward = totalRewardPerHRatBlock[lastProcessedBlock] +\\n                delta *\\n                currentRewardsPerBHR +\\n                        feePerHR;\\n            totalRewardPerHRatBlock[bn] = totalReward;\\n            lastProcessedBlock = bn;\\n            tokenBalance = balance;\\n        }\\n    }\\n\\n    function _updateUser(address user, int8 amount) private {\\n\\n        uint256 bn = block.number;\\n        rewardAcc[user] +=\\n            userHR[user] *\\n            (totalRewardPerHRatBlock[bn] -\\n                totalRewardPerHRatBlock[lastUpdateBlock[user]]);\\n        lastUpdateBlock[user] = bn;\\n        if (amount != 0) {\\n            nftStaked += amount;\\n            int256 oldAmount = nftAmounts[user];\\n            int256 newAmount = oldAmount + amount;\\n            if (oldAmount == 0) {\\n                ++uniqStakers;\\n            } else if (newAmount == 0) {\\n                --uniqStakers;\\n            }\\n            nftAmounts[user] = newAmount;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/INFTContract.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity 0.8.23;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\n\\ninterface INFTContract is IERC721 {\\n    function nftHashrate(uint256 _tokenId) external view returns (uint16);\\n}\\n\"\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_initialOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_nftProvider\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnableInvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnableUnauthorizedAccount\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Claimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newRewardsPerBlock\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"Halved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"Staked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"Unstaked\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"claimed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentActiveHR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentRewardsPerBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getAvailableForClaim\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getAverageRewardPerBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getClaimed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getEarnedByVMM\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMinted\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRemainingBlockReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getTotalReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"halve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextHalvingTS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nftAmounts\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nftStaked\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"owners\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"restakeOnSell\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"setOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalClaimed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniqStakers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"name\":\"unstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userHR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "StakingContract", "CompilerVersion": "v0.8.23+commit.f704f362", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000053112316dbb765c20344ac32cd950d69cedd6dab00000000000000000000000038bff7b69e3aca319bd96a399beabb7c10abf6cb0000000000000000000000005bdc0bc6d2ccce56213a300587a84edeb3481448", "EVMVersion": "paris", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}