{"SourceCode": "//SPDX-License-Identifier: MIT\r\npragma solidity 0.8.14;\r\n\r\ninterface IERC20 {\r\n\r\n    function totalSupply() external view returns (uint256);\r\n    \r\n    function symbol() external view returns(string memory);\r\n    \r\n    function name() external view returns(string memory);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n    \r\n    /**\r\n     * @dev Returns the number of decimal places\r\n     */\r\n    function decimals() external view returns (uint8);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract Ownable {\r\n\r\n    address private owner;\r\n    \r\n    // event for EVM logging\r\n    event OwnerSet(address indexed oldOwner, address indexed newOwner);\r\n    \r\n    // modifier to check if caller is owner\r\n    modifier onlyOwner() {\r\n        // If the first argument of 'require' evaluates to 'false', execution terminates and all\r\n        // changes to the state and to Ether balances are reverted.\r\n        // This used to consume all gas in old EVM versions, but not anymore.\r\n        // It is often a good idea to use 'require' to check if functions are called correctly.\r\n        // As a second argument, you can also provide an explanation about what went wrong.\r\n        require(msg.sender == owner, \"Caller is not owner\");\r\n        _;\r\n    }\r\n    \r\n    /**\r\n     * @dev Set contract deployer as owner\r\n     */\r\n    constructor() {\r\n        owner = msg.sender; // 'msg.sender' is sender of current call, contract deployer for a constructor\r\n        emit OwnerSet(address(0), owner);\r\n    }\r\n\r\n    /**\r\n     * @dev Change owner\r\n     * @param newOwner address of new owner\r\n     */\r\n    function changeOwner(address newOwner) public onlyOwner {\r\n        emit OwnerSet(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n    /**\r\n     * @dev Return owner address \r\n     * @return address of owner\r\n     */\r\n    function getOwner() external view returns (address) {\r\n        return owner;\r\n    }\r\n}\r\n\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor () {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\n\r\ninterface IOracle {\r\n    function lastAnswer() external view returns (int256);\r\n}\r\n\r\ncontract MARS is Ownable, ReentrancyGuard {\r\n\r\n    // Eclipse Token\r\n    address public eclipse;\r\n\r\n    // Listing Data\r\n    struct ListedToken {\r\n        uint256 listedIndex;\r\n        uint256 amount;\r\n        uint256 lastContribute;\r\n        bool isNFT;\r\n        bool isNSFW;\r\n    }\r\n\r\n    // token => listing data\r\n    mapping (address => ListedToken) public listedTokens;\r\n\r\n    // array of listed tokens\r\n    address[] public listed;\r\n\r\n    // Applicants\r\n    struct Applicant {\r\n        uint index;\r\n        uint feeCharged;\r\n        address user;\r\n        address ref;\r\n    }\r\n    address[] public applicants;\r\n    mapping ( address => Applicant ) public applicationInfo;\r\n\r\n    // Referral Structure\r\n    struct Ref {\r\n        uint256 cut;\r\n        uint256 totalEarned;\r\n        address[] tokenReferrals;\r\n    }\r\n\r\n    // Referrer Structure\r\n    mapping ( address => Ref ) public refInfo;\r\n\r\n    // address => is authorized\r\n    mapping ( address => bool ) public authorized;\r\n    modifier onlyAuthorized() {\r\n        require(authorized[msg.sender] || msg.sender == this.getOwner(), 'Only Authorized');\r\n        _;\r\n    }\r\n\r\n    // Decay Rate\r\n    uint256 public decay_per_second = 165343916000;\r\n    uint256 private constant DENOM = 10**18;\r\n\r\n    // Listing Fees\r\n    uint256 public listingFee;\r\n\r\n    // Recipient\r\n    address public eclipseRecipient;\r\n    address public listingRecipient;\r\n\r\n    // Default Referrer Fee\r\n    uint256 public default_referral_fee = 10;\r\n\r\n    // Chainlink Oracle Address\r\n    address public oracle;\r\n\r\n    // decimals of oracle\r\n    uint8 public oracle_decimals;\r\n\r\n    // Events\r\n    event Applied(address indexed user, address ref, uint256 listingFee);\r\n    event FundedEclipse(address token, address funder, uint256 amount);\r\n\r\n    constructor(address eclipse_, uint listingFee_) {\r\n        eclipse = eclipse_;\r\n        listingFee = listingFee_;\r\n    }\r\n\r\n    function getLatestPrice() public view returns (uint256) {\r\n        int256 answer = IOracle(oracle).lastAnswer();\r\n        if (answer <= 0) {\r\n            return 0;\r\n        }\r\n        return uint256(answer);\r\n    }\r\n\r\n    function setOracle(address oracle_) external onlyOwner {\r\n        require(\r\n            oracle_ != address(0),\r\n            'Zero Addr'\r\n        );\r\n        oracle = oracle_;\r\n    }\r\n\r\n    function setOracleDecimals(uint8 newDecimals) external onlyOwner {\r\n        oracle_decimals = newDecimals;\r\n    }\r\n\r\n    function setListingFee(uint newFee) external onlyOwner {\r\n        listingFee = newFee;\r\n    }\r\n\r\n    function setDefaultReferralFee(uint newDefault) external onlyOwner {\r\n        require(\r\n            newDefault > 0 && newDefault < 50,\r\n            'Fee Out Of Bounds'\r\n        );\r\n        default_referral_fee = newDefault;\r\n    }\r\n\r\n    function upgrade(address oldToken, address newToken) external onlyOwner {\r\n        require(\r\n            isListed(oldToken),\r\n            'Token Not Listed'\r\n        );\r\n        listedTokens[newToken] = listedTokens[oldToken];\r\n    }\r\n\r\n    function awardPoints(address token, uint256 numPoints) external onlyOwner {\r\n        require(\r\n            isListed(token),\r\n            'Token Not Listed'\r\n        );\r\n\r\n        // add new points to amount\r\n        unchecked {\r\n            listedTokens[token].amount += numPoints;\r\n        }\r\n\r\n        // reset last contribution timestamp\r\n        listedTokens[token].lastContribute = block.timestamp;\r\n    }\r\n\r\n    function setEclipse(address eclipse_) external onlyOwner {\r\n        require(\r\n            eclipse_ != address(0),\r\n            'Zero Addr'\r\n        );\r\n        eclipse = eclipse_;\r\n    }\r\n\r\n    function setAuthorized(address account, bool isAuth) external onlyOwner {\r\n        authorized[account] = isAuth;\r\n    }\r\n\r\n    function delistToken(address token) external onlyOwner {\r\n        require(isListed(token),\r\n            'Not Listed'\r\n        );\r\n        listed[listedTokens[token].listedIndex] = listed[listed.length-1];\r\n        listedTokens[listed[listed.length-1]].listedIndex = listedTokens[token].listedIndex;\r\n        listed.pop();\r\n        delete listedTokens[token];\r\n    }\r\n\r\n    function setDecayPerSecond(uint newDecay) external onlyOwner {\r\n        decay_per_second = newDecay;\r\n    }\r\n\r\n    function setEclipseRecipient(address newRecipient) external onlyOwner {\r\n        require(\r\n            newRecipient != address(0),\r\n            'Zero Addr'\r\n        );\r\n        eclipseRecipient = newRecipient;\r\n    }\r\n\r\n    function setListingRecipient(address newRecipient) external onlyOwner {\r\n        require(\r\n            newRecipient != address(0),\r\n            'Zero Addr'\r\n        );\r\n        listingRecipient = newRecipient;\r\n    }\r\n\r\n    function withdrawTokens(address token) external onlyOwner {\r\n        IERC20(token).transfer(msg.sender, IERC20(token).balanceOf(address(this)));\r\n    }\r\n\r\n    function setReferralCut(address ref, uint cut) external onlyOwner {\r\n        require(\r\n            cut > 0,\r\n            'Must Have Cut'\r\n        );\r\n        require(\r\n            cut < 100,\r\n            'Cut Cannot Be 100%'\r\n        );\r\n        require(\r\n            ref != address(0),\r\n            'Zero Addr'\r\n        );\r\n        refInfo[ref].cut = cut;\r\n    }\r\n\r\n    function removeReferrerCut(address ref) external onlyOwner {\r\n        require(\r\n            ref != address(0),\r\n            'Zero Addr'\r\n        );\r\n        delete refInfo[ref].cut;\r\n    }\r\n\r\n    function listTokenWithoutApplication(address token, bool isNFT) external onlyOwner {\r\n        require(\r\n            token != address(0),\r\n            'Zero Addr'\r\n        );\r\n        require(\r\n            !isListed(token),\r\n            'Already Listed'\r\n        );\r\n        require(\r\n            !isApplicant(token),\r\n            'Token Already Applied'\r\n        );\r\n        \r\n        // listed data\r\n        listedTokens[token].listedIndex = listed.length;\r\n        listedTokens[token].isNFT = isNFT;\r\n        listed.push(token);\r\n    }\r\n\r\n    function listToken(address token, bool isNFT, bool isNSFW) external onlyAuthorized nonReentrant {\r\n        require(\r\n            token != address(0),\r\n            'Zero Addr'\r\n        );\r\n        require(\r\n            !isListed(token),\r\n            'Already Listed'\r\n        );\r\n        require(\r\n            isApplicant(token),\r\n            'Token Did Not Apply'\r\n        );\r\n        \r\n        // listed data\r\n        listedTokens[token].listedIndex = listed.length;\r\n        listedTokens[token].isNFT = isNFT;\r\n        listedTokens[token].isNSFW = isNSFW;\r\n        listed.push(token);\r\n\r\n        // application fee\r\n        uint fee = applicationInfo[token].feeCharged;\r\n\r\n        // referrer\r\n        address ref = applicationInfo[token].ref;\r\n\r\n        // remove applicant\r\n        _removeApplicant(token);\r\n        \r\n        // forward fee\r\n        if (fee > 0) {\r\n            if (ref != address(0)) {\r\n\r\n                // split fee\r\n                uint refCut = getReferralFee(fee, ref);\r\n                uint rest = fee - refCut;\r\n\r\n                // send fee to listing recipient\r\n                (bool s,) = payable(listingRecipient).call{value: rest}(\"\");\r\n                require(s, 'BNB TRANSFER FAIL');\r\n\r\n                // send fee to referrer\r\n                (s,) = payable(ref).call{value: refCut}(\"\");\r\n                require(s, 'BNB TRANSFER FAIL');\r\n\r\n                // track how many fees were received by referrer\r\n                unchecked {\r\n                    refInfo[ref].totalEarned += refCut;\r\n                }\r\n\r\n                // add to referrers list\r\n                refInfo[ref].tokenReferrals.push(token);\r\n\r\n            } else {\r\n\r\n                // no referrer, send entire fee to listing recipient\r\n                (bool s,) = payable(listingRecipient).call{value: fee}(\"\");\r\n                require(s, 'BNB TRANSFER FAIL');\r\n\r\n            }\r\n        }\r\n    }\r\n\r\n    function rejectApplication(address token) external onlyAuthorized nonReentrant {\r\n        require(\r\n            token != address(0),\r\n            'Zero Addr'\r\n        );\r\n        require(\r\n            isApplicant(token),\r\n            'Not Applicant'\r\n        );\r\n\r\n        // fetch data\r\n        uint refund = applicationInfo[token].feeCharged;\r\n        address user = applicationInfo[token].user;\r\n\r\n        // remove applicant\r\n        _removeApplicant(token);\r\n\r\n        // refund user\r\n        (bool s,) = payable(user).call{value: refund}(\"\");\r\n        require(s, 'BNB TRANSFER FAIL');\r\n    }\r\n\r\n    function setNSFW(address token, bool isNSFW) external onlyAuthorized {\r\n        require(\r\n            token != address(0),\r\n            'Zero Addr'\r\n        );\r\n        require(\r\n            isListed(token),\r\n            'Token Not Listed'\r\n        );\r\n        listedTokens[token].isNSFW = isNSFW;\r\n    }\r\n\r\n    function getUSDValue(uint256 value) external view returns (uint256) {\r\n        uint256 lastPrice = getLatestPrice();\r\n        if (lastPrice == 0) {\r\n            return 0;\r\n        }\r\n        return ( value * lastPrice ) / 10**oracle_decimals;\r\n    }\r\n\r\n    function getValueForListing() external view returns (uint256) {\r\n        uint256 lastPrice = getLatestPrice();\r\n        if (lastPrice == 0) {\r\n            return 0;\r\n        }\r\n        uint256 num = listingFee / 10**oracle_decimals;\r\n        uint256 denom = lastPrice * 10**(18 - oracle_decimals);\r\n        return ( 10**18 * num ) / denom;\r\n    }\r\n\r\n    function Apply(address ref, address token) external payable {\r\n        require(\r\n            token != address(0),\r\n            'Non Token'\r\n        );\r\n        require(\r\n            !isApplicant(token),\r\n            'Already Applied'\r\n        );\r\n\r\n        // fetch and validate latest price\r\n        uint256 lastPrice = getLatestPrice();\r\n        require(\r\n            lastPrice > 0,\r\n            'Invalid Oracle Response'\r\n        );\r\n\r\n        // convert price to USD\r\n        uint256 usdValue = ( msg.value * lastPrice ) / 10**oracle_decimals;\r\n        require(\r\n            usdValue >= listingFee,\r\n            'Invalid Fee'\r\n        );\r\n\r\n        // We allow no referrer\r\n        if (ref != address(0)) {\r\n            applicationInfo[token].ref = ref;\r\n        }\r\n\r\n        applicationInfo[token].index = applicants.length;\r\n        applicationInfo[token].feeCharged = msg.value;\r\n        applicationInfo[token].user = msg.sender;\r\n        applicants.push(token);\r\n\r\n        emit Applied(msg.sender, ref, msg.value);\r\n    }\r\n\r\n    function addToEclipse(address token, uint256 amount) external nonReentrant {\r\n        require(\r\n            IERC20(eclipse).allowance(msg.sender, address(this)) >= amount,\r\n            'Insufficient Allowance'\r\n        );\r\n        require(\r\n            IERC20(eclipse).balanceOf(msg.sender) >= amount,\r\n            'Insufficient Balance'\r\n        );\r\n\r\n        // transfer tokens from sender to eclipse recipient\r\n        IERC20(eclipse).transferFrom(msg.sender, eclipseRecipient, amount);\r\n\r\n        // decay balance if applicable\r\n        if (timeSince(token) > 0) {\r\n            listedTokens[token].amount = getPoints(token);\r\n        }\r\n\r\n        // add new donation to amount\r\n        unchecked {\r\n            listedTokens[token].amount += amount;\r\n        }\r\n        listedTokens[token].lastContribute = block.timestamp;\r\n\r\n        emit FundedEclipse(token, msg.sender, amount);\r\n    }\r\n\r\n    function _removeApplicant(address applicant) internal {\r\n        applicants[applicationInfo[applicant].index] = applicants[applicants.length-1];\r\n        applicationInfo[applicants[applicants.length-1]].index = applicationInfo[applicant].index;\r\n        applicants.pop();\r\n        delete applicationInfo[applicant];\r\n    }\r\n\r\n    function getReferralFee(uint256 amount, address ref) public view returns (uint256 refFee) {\r\n        uint256 refCut = refInfo[ref].cut == 0 ? default_referral_fee : refInfo[ref].cut;\r\n        return ( amount * refCut ) / 100;\r\n    }\r\n\r\n    function getPoints(address token) public view returns (uint256) {\r\n        if (listedTokens[token].amount == 0 || listedTokens[token].lastContribute == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint prev = listedTokens[token].amount;\r\n        uint timeSince_ = timeSince(token);\r\n\r\n        uint decay = prev * timeSince_ * decay_per_second / DENOM;\r\n\r\n        return decay >= prev ? 0 : prev - decay;\r\n    }\r\n\r\n    function timeSince(address token) public view returns (uint256) {\r\n        if (listedTokens[token].lastContribute == 0) {\r\n            return 0;\r\n        }\r\n\r\n        return block.timestamp > listedTokens[token].lastContribute ? block.timestamp - listedTokens[token].lastContribute : 0;\r\n    }\r\n\r\n    function getListedTokens() public view returns (address[] memory) {\r\n        return listed;\r\n    }\r\n\r\n    function getListedTokensAndPoints() public view returns (address[] memory, uint256[] memory) {\r\n        uint len = listed.length;\r\n        uint256[] memory points = new uint256[](len);\r\n        for (uint i = 0; i < len;) {\r\n            points[i] = getPoints(listed[i]);\r\n            unchecked { ++i; }\r\n        }\r\n        return (listed, points);\r\n    }\r\n\r\n    function getListedTokensAndPointsAndTypeFlag() public view returns (\r\n        address[] memory,\r\n        uint256[] memory,\r\n        bool[] memory isNFTList,\r\n        bool[] memory isNSFWList\r\n    ) {\r\n\r\n        uint len = listed.length;\r\n        uint256[] memory points = new uint256[](len);\r\n        isNFTList = new bool[](len);\r\n        isNSFWList = new bool[](len);\r\n        for (uint i = 0; i < len;) {\r\n            points[i] = getPoints(listed[i]);\r\n            isNFTList[i] = listedTokens[listed[i]].isNFT;\r\n            isNSFWList[i] = listedTokens[listed[i]].isNSFW;\r\n            unchecked { ++i; }\r\n        }\r\n        return (listed, points, isNFTList, isNSFWList);\r\n    }\r\n\r\n    function getPaginatedListedTokensAndPointsAndTypeFlag(\r\n        uint256 startIndex,\r\n        uint256 endIndex\r\n    ) public view returns (\r\n        address[] memory,\r\n        uint256[] memory,\r\n        bool[] memory isNFTList,\r\n        bool[] memory isNSFWList\r\n    ) {\r\n\r\n        address[] memory listeds = new address[](endIndex - startIndex);\r\n        uint256[] memory points = new uint256[](endIndex - startIndex);\r\n        isNFTList = new bool[](endIndex - startIndex);\r\n        isNSFWList = new bool[](endIndex - startIndex);\r\n        uint count = 0;\r\n        for (uint i = startIndex; i < endIndex;) {\r\n            listeds[count] = listed[i];\r\n            points[count] = getPoints(listed[i]);\r\n            isNFTList[count] = listedTokens[listed[i]].isNFT;\r\n            isNSFWList[count] = listedTokens[listed[i]].isNSFW;\r\n            unchecked { ++i; ++count; }\r\n        }\r\n        return (listeds, points, isNFTList, isNSFWList);\r\n    }\r\n\r\n    function isListed(address token) public view returns (bool) {\r\n        if (listed.length <= listedTokens[token].listedIndex) {\r\n            return false;\r\n        }\r\n        return listed[listedTokens[token].listedIndex] == token;\r\n    }\r\n\r\n    function isApplicant(address token) public view returns (bool) {\r\n        if (applicants.length <= applicationInfo[token].index) {\r\n            return false;\r\n        }\r\n        return applicants[applicationInfo[token].index] == token;\r\n    }\r\n\r\n    function isReferrer(address ref) public view returns (bool) {\r\n        if (ref == address(0)) {\r\n            return false;\r\n        }\r\n        return refInfo[ref].cut > 0;\r\n    }\r\n\r\n    function getTotalEarned(address ref) external view returns (uint256) {\r\n        return refInfo[ref].totalEarned;\r\n    }\r\n\r\n    function viewAllTokensReferred(address ref) external view returns (address[] memory) {\r\n        return refInfo[ref].tokenReferrals;\r\n    }\r\n\r\n    function getNumberOfTokensReferred(address ref) external view returns (uint256) {\r\n        return refInfo[ref].tokenReferrals.length;\r\n    }\r\n\r\n    receive() external payable {}\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"eclipse_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"listingFee_\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"ref\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"listingFee\",\"type\":\"uint256\"}],\"name\":\"Applied\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"funder\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"FundedEclipse\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerSet\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ref\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"Apply\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"addToEclipse\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"applicants\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"applicationInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feeCharged\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"ref\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"authorized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"numPoints\",\"type\":\"uint256\"}],\"name\":\"awardPoints\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decay_per_second\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"default_referral_fee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"delistToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"eclipse\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"eclipseRecipient\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLatestPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getListedTokens\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getListedTokensAndPoints\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getListedTokensAndPointsAndTypeFlag\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"bool[]\",\"name\":\"isNFTList\",\"type\":\"bool[]\"},{\"internalType\":\"bool[]\",\"name\":\"isNSFWList\",\"type\":\"bool[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ref\",\"type\":\"address\"}],\"name\":\"getNumberOfTokensReferred\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"startIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endIndex\",\"type\":\"uint256\"}],\"name\":\"getPaginatedListedTokensAndPointsAndTypeFlag\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"bool[]\",\"name\":\"isNFTList\",\"type\":\"bool[]\"},{\"internalType\":\"bool[]\",\"name\":\"isNSFWList\",\"type\":\"bool[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getPoints\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"ref\",\"type\":\"address\"}],\"name\":\"getReferralFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"refFee\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ref\",\"type\":\"address\"}],\"name\":\"getTotalEarned\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"getUSDValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getValueForListing\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"isApplicant\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"isListed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ref\",\"type\":\"address\"}],\"name\":\"isReferrer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isNFT\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isNSFW\",\"type\":\"bool\"}],\"name\":\"listToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isNFT\",\"type\":\"bool\"}],\"name\":\"listTokenWithoutApplication\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"listed\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"listedTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"listedIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastContribute\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isNFT\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isNSFW\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"listingFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"listingRecipient\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oracle\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oracle_decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"refInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"cut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalEarned\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"rejectApplication\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ref\",\"type\":\"address\"}],\"name\":\"removeReferrerCut\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isAuth\",\"type\":\"bool\"}],\"name\":\"setAuthorized\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newDecay\",\"type\":\"uint256\"}],\"name\":\"setDecayPerSecond\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newDefault\",\"type\":\"uint256\"}],\"name\":\"setDefaultReferralFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"eclipse_\",\"type\":\"address\"}],\"name\":\"setEclipse\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newRecipient\",\"type\":\"address\"}],\"name\":\"setEclipseRecipient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newFee\",\"type\":\"uint256\"}],\"name\":\"setListingFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newRecipient\",\"type\":\"address\"}],\"name\":\"setListingRecipient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isNSFW\",\"type\":\"bool\"}],\"name\":\"setNSFW\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"oracle_\",\"type\":\"address\"}],\"name\":\"setOracle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"newDecimals\",\"type\":\"uint8\"}],\"name\":\"setOracleDecimals\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ref\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"cut\",\"type\":\"uint256\"}],\"name\":\"setReferralCut\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"timeSince\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"oldToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"newToken\",\"type\":\"address\"}],\"name\":\"upgrade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ref\",\"type\":\"address\"}],\"name\":\"viewAllTokensReferred\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"withdrawTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "MARS", "CompilerVersion": "v0.8.14+commit.80d49f37", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000002a21474660a6d6c9ae4b0300c576c78f54f20fd00000000000000000000000000000000000000000000003635c9adc5dea00000", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://b6c9113b5dc5f3566bd710c6c3f107c29108b10e84b45de847d55a8003fb1783"}