{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/Dependencies/CheckContract.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.17;\\r\\n\\r\\n\\r\\ncontract CheckContract {\\r\\n    /**\\r\\n     * Check that the account is an already deployed non-destroyed contract.\\r\\n     * See: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol#L12\\r\\n     */\\r\\n    function checkContract(address _account) internal view {\\r\\n        require(_account != address(0), \\\"Account cannot be zero address\\\");\\r\\n\\r\\n        uint256 size;\\r\\n        // solhint-disable-next-line no-inline-assembly\\r\\n        assembly { size := extcodesize(_account) }\\r\\n        require(size > 0, \\\"Account code size cannot be zero\\\");\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/Dependencies/IERC2612.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.17;\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC2612 standard as defined in the EIP.\\r\\n *\\r\\n * Adds the {permit} method, which can be used to change one's\\r\\n * {IERC20-allowance} without having to send a transaction, by signing a\\r\\n * message. This allows users to spend tokens without having to hold Ether.\\r\\n *\\r\\n * See https://eips.ethereum.org/EIPS/eip-2612.\\r\\n * \\r\\n * Code adapted from https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2237/\\r\\n */\\r\\ninterface IERC2612 {\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over `owner`'s tokens,\\r\\n     * given `owner`'s signed approval.\\r\\n     *\\r\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\r\\n     * ordering also apply here.\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `owner` cannot be the zero address.\\r\\n     * - `spender` cannot be the zero address.\\r\\n     * - `deadline` must be a timestamp in the future.\\r\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\r\\n     * over the EIP712-formatted function arguments.\\r\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\r\\n     *\\r\\n     * For more information on the signature format, see the\\r\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\r\\n     * section].\\r\\n     */\\r\\n    function permit(address owner, address spender, uint256 amount, \\r\\n                    uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\\r\\n    \\r\\n    /**\\r\\n     * @dev Returns the current ERC2612 nonce for `owner`. This value must be\\r\\n     * included whenever a signature is generated for {permit}.\\r\\n     *\\r\\n     * Every successful call to {permit} increases `owner`'s nonce by one. This\\r\\n     * prevents a signature from being used multiple times.\\r\\n     *\\r\\n     * `owner` can limit the time a Permit is valid for by setting `deadline` to \\r\\n     * a value in the near future. The deadline argument can be set to uint(-1) to \\r\\n     * create Permits that effectively never expire.\\r\\n     */\\r\\n    function nonces(address owner) external view returns (uint256);\\r\\n    \\r\\n    function version() external view returns (string memory);\\r\\n    function permitTypeHash() external view returns (bytes32);\\r\\n    function domainSeparator() external view returns (bytes32);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/Dependencies/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.17;\\r\\n\\r\\n/**\\r\\n * Based on OpenZeppelin's Ownable contract:\\r\\n * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol\\r\\n *\\r\\n * @dev Contract module which provides a basic access control mechanism, where\\r\\n * there is an account (an owner) that can be granted exclusive access to\\r\\n * specific functions.\\r\\n *\\r\\n * This module is used through inheritance. It will make available the modifier\\r\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\r\\n * the owner.\\r\\n */\\r\\ncontract Ownable {\\r\\n    address private _owner;\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    /**\\r\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\r\\n     */\\r\\n    constructor () {\\r\\n        _owner = msg.sender;\\r\\n        emit OwnershipTransferred(address(0), msg.sender);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the address of the current owner.\\r\\n     */\\r\\n    function owner() public view returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if called by any account other than the owner.\\r\\n     */\\r\\n    modifier onlyOwner() {\\r\\n        require(isOwner(), \\\"Ownable: caller is not the owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns true if the caller is the current owner.\\r\\n     */\\r\\n    function isOwner() public view returns (bool) {\\r\\n        return msg.sender == _owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Leaves the contract without owner. It will not be possible to call\\r\\n     * `onlyOwner` functions anymore.\\r\\n     *\\r\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\r\\n     * thereby removing any functionality that is only available to the owner.\\r\\n     *\\r\\n     * NOTE: This function is not safe, as it doesn\u2019t check owner is calling it.\\r\\n     * Make sure you check it before calling it.\\r\\n     */\\r\\n    function _renounceOwnership() internal {\\r\\n        emit OwnershipTransferred(_owner, address(0));\\r\\n        _owner = address(0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     * Can only be called by the current owner.\\r\\n     */\\r\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\r\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\r\\n        _transferOwnership(newOwner);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     * Internal function without access restriction.\\r\\n     */\\r\\n    function _transferOwnership(address newOwner) internal virtual {\\r\\n        address oldOwner = _owner;\\r\\n        _owner = newOwner;\\r\\n        emit OwnershipTransferred(oldOwner, newOwner);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/GasPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.17;\\r\\n\\r\\nimport \\\"./Interfaces/IGasPool.sol\\\";\\r\\nimport \\\"./Interfaces/ITHUSDToken.sol\\\";\\r\\nimport \\\"./Dependencies/Ownable.sol\\\";\\r\\nimport \\\"./Dependencies/CheckContract.sol\\\";\\r\\n\\r\\n\\r\\n/**\\r\\n * The purpose of this contract is to hold THUSD tokens for gas compensation:\\r\\n * https://github.com/liquity/dev#gas-compensation\\r\\n * When a borrower opens a trove, an additional 50 THUSD debt is issued,\\r\\n * and 50 THUSD is minted and sent to this contract.\\r\\n * When a borrower closes their active trove, this gas compensation is refunded:\\r\\n * 50 THUSD is burned from the this contract's balance, and the corresponding\\r\\n * 50 THUSD debt on the trove is cancelled.\\r\\n * See this issue for more context: https://github.com/liquity/dev/issues/186\\r\\n */\\r\\ncontract GasPool is Ownable, CheckContract, IGasPool {\\r\\n    \\r\\n    address public troveManagerAddress;\\r\\n    ITHUSDToken public thusdToken;\\r\\n    \\r\\n    function setAddresses(\\r\\n        address _troveManagerAddress,\\r\\n        address _thusdTokenAddress\\r\\n    )\\r\\n        external\\r\\n        onlyOwner\\r\\n    {\\r\\n        checkContract(_troveManagerAddress);\\r\\n        checkContract(_thusdTokenAddress);\\r\\n\\r\\n        troveManagerAddress = _troveManagerAddress;\\r\\n        thusdToken = ITHUSDToken(_thusdTokenAddress);\\r\\n\\r\\n        emit TroveManagerAddressChanged(_troveManagerAddress);\\r\\n        emit THUSDTokenAddressChanged(_thusdTokenAddress);\\r\\n\\r\\n        _renounceOwnership();\\r\\n    }\\r\\n\\r\\n    function sendTHUSD(address _account, uint256 _amount) override external {\\r\\n        require(msg.sender == troveManagerAddress, \\\"GasPool: Caller is not the TroveManager\\\");\\r\\n        require(thusdToken.transfer(_account, _amount), \\\"GasPool: sending thUSD failed\\\");\\r\\n    }\\r\\n\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/Interfaces/IGasPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.17;\\r\\n\\r\\n\\r\\ninterface IGasPool {\\r\\n    // --- Events ---\\r\\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\\r\\n    event THUSDTokenAddressChanged(address _thusdTokenAddress);\\r\\n\\r\\n    // --- Functions ---\\r\\n    function sendTHUSD(address _account, uint256 _amount) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/Interfaces/ITHUSDToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.17;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\r\\nimport \\\"../Dependencies/IERC2612.sol\\\";\\r\\n\\r\\ninterface ITHUSDToken is IERC20Metadata, IERC2612 {\\r\\n\\r\\n    // --- Events ---\\r\\n\\r\\n    event TroveManagerAddressAdded(address _troveManagerAddress);\\r\\n    event StabilityPoolAddressAdded(address _newStabilityPoolAddress);\\r\\n    event BorrowerOperationsAddressAdded(address _newBorrowerOperationsAddress);\\r\\n\\r\\n    event THUSDTokenBalanceUpdated(address _user, uint256 _amount);\\r\\n\\r\\n    // --- Functions ---\\r\\n    function mintList(address contractAddress) external view returns (bool);\\r\\n    function burnList(address contractAddress) external view returns (bool);\\r\\n\\r\\n    function mint(address _account, uint256 _amount) external;\\r\\n\\r\\n    function burn(address _account, uint256 _amount) external;\\r\\n\\r\\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\\r\\n\\r\\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 100\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_thusdTokenAddress\",\"type\":\"address\"}],\"name\":\"THUSDTokenAddressChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_newTroveManagerAddress\",\"type\":\"address\"}],\"name\":\"TroveManagerAddressChanged\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"sendTHUSD\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_troveManagerAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_thusdTokenAddress\",\"type\":\"address\"}],\"name\":\"setAddresses\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"thusdToken\",\"outputs\":[{\"internalType\":\"contract ITHUSDToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"troveManagerAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "GasPool", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "100", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}