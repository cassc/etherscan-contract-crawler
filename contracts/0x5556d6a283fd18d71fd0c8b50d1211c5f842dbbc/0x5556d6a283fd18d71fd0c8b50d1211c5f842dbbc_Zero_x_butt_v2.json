{"SourceCode": "pragma solidity 0.5 .11;\r\n\r\n// 'ButtCoin' contract, version 2.0\r\n// Website: http://www.0xbutt.com/\r\n//\r\n// Symbol      : 0xBUTT\r\n// Name        : ButtCoin v2.0 \r\n// Total supply: 33,554,431.99999981\r\n// Decimals    : 8\r\n//\r\n// ----------------------------------------------------------------------------\r\n\r\n// ============================================================================\r\n// Safe maths\r\n// ============================================================================\r\n \r\n library SafeMath {\r\n   function add(uint256 a, uint256 b) internal pure returns(uint256) {\r\n     uint256 c = a + b;\r\n     require(c >= a, \"SafeMath: addition overflow\");\r\n     return c;\r\n   }\r\n\r\n   function sub(uint256 a, uint256 b) internal pure returns(uint256) {\r\n     return sub(a, b, \"SafeMath: subtraction overflow\");\r\n   }\r\n\r\n   function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns(uint256) {\r\n     require(b <= a, errorMessage);\r\n     uint256 c = a - b;\r\n     return c;\r\n   }\r\n\r\n   function mul(uint256 a, uint256 b) internal pure returns(uint256) {\r\n     if (a == 0) {\r\n       return 0;\r\n     }\r\n     uint256 c = a * b;\r\n     require(c / a == b, \"SafeMath: multiplication overflow\");\r\n     return c;\r\n   }\r\n\r\n   function div(uint256 a, uint256 b) internal pure returns(uint256) {\r\n     return div(a, b, \"SafeMath: division by zero\");\r\n   }\r\n\r\n   function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns(uint256) {\r\n     require(b > 0, errorMessage);\r\n     uint256 c = a / b;\r\n     return c;\r\n   }\r\n\r\n   function mod(uint256 a, uint256 b) internal pure returns(uint256) {\r\n     return mod(a, b, \"SafeMath: modulo by zero\");\r\n   }\r\n\r\n   function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns(uint256) {\r\n     require(b != 0, errorMessage);\r\n     return a % b;\r\n   }\r\n }\r\n\r\n// ============================================================================\r\n// ERC Token Standard Interface\r\n// ============================================================================\r\n \r\n contract ERC20Interface {\r\n\r\n   function addToBlacklist(address addToBlacklist) public;\r\n   function addToRootAccounts(address addToRoot) public;\r\n   function addToWhitelist(address addToWhitelist) public;\r\n   function allowance(address tokenOwner, address spender) public view returns(uint remaining);\r\n   function approve(address spender, uint tokens) public returns(bool success);\r\n   function approveAndCall(address spender, uint tokens, bytes memory data) public returns(bool success);\r\n   function balanceOf(address tokenOwner) public view returns(uint balance);\r\n   function checkMintSolution(uint256 nonce, bytes32 challenge_digest, bytes32 challenge_number, uint testTarget) public view returns(bool success);\r\n   function confirmBlacklist(address confirmBlacklist) public returns(bool);\r\n   function confirmWhitelist(address tokenAddress) public returns(bool);\r\n   function currentSupply() public view returns(uint);\r\n   function decreaseAllowance(address spender, uint256 subtractedValue) public returns(bool);\r\n   function getChallengeNumber() public view returns(bytes32);\r\n   function getMiningDifficulty() public view returns(uint);\r\n   function getMiningReward() public view returns(uint);\r\n   function getMiningTarget() public view returns(uint);\r\n   function getMintDigest(uint256 nonce, bytes32 challenge_digest, bytes32 challenge_number) public view returns(bytes32);\r\n   function getBlockAmount (address minerAddress) public returns(uint);\r\n   function getBlockAmount (uint blockNumber) public returns(uint);\r\n   function getBlockMiner(uint blockNumber) public returns(address);\r\n   function increaseAllowance(address spender, uint256 addedValue) public returns(bool);\r\n   function mint(uint256 nonce, bytes32 challenge_digest) public returns(bool success);\r\n   function multiTransfer(address[] memory receivers, uint256[] memory amounts) public;\r\n   function removeFromBlacklist(address removeFromBlacklist) public;\r\n   function removeFromRootAccounts(address removeFromRoot) public;\r\n   function removeFromWhitelist(address removeFromWhitelist) public;\r\n   function rootTransfer(address from, address to, uint tokens) public returns(bool success);\r\n   function setDifficulty(uint difficulty) public returns(bool success);\r\n   function switchApproveAndCallLock() public;\r\n   function switchApproveLock() public;\r\n   function switchMintLock() public;\r\n   function switchRootTransferLock() public;\r\n   function switchTransferFromLock() public;\r\n   function switchTransferLock() public;\r\n   function totalSupply() public view returns(uint);\r\n   function transfer(address to, uint tokens) public returns(bool success);\r\n   function transferFrom(address from, address to, uint tokens) public returns(bool success);\r\n\r\n   event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n   event Transfer(address indexed from, address indexed to, uint tokens);\r\n   \r\n }\r\n\r\n// ============================================================================\r\n// Contract function to receive approval and execute function in one call\r\n// ============================================================================\r\n \r\n contract ApproveAndCallFallBack {\r\n   function receiveApproval(address from, uint256 tokens, address token, bytes memory data) public;\r\n }\r\n\r\n// ============================================================================\r\n// Owned contract\r\n// ============================================================================\r\n \r\n contract Owned {\r\n\r\n   address public owner;\r\n   address public newOwner;\r\n\r\n   event OwnershipTransferred(address indexed _from, address indexed _to);\r\n\r\n   constructor() public {\r\n     owner = msg.sender;\r\n   }\r\n\r\n   modifier onlyOwner {\r\n     require(msg.sender == owner);\r\n     _;\r\n   }\r\n\r\n   function transferOwnership(address _newOwner) public onlyOwner {\r\n     newOwner = _newOwner;\r\n   }\r\n\r\n   function acceptOwnership() public {\r\n     require(msg.sender == newOwner);\r\n     emit OwnershipTransferred(owner, newOwner);\r\n     owner = newOwner;\r\n     newOwner = address(0);\r\n   }\r\n\r\n }\r\n\r\n// ============================================================================\r\n// All booleans are false as a default. False means unlocked.\r\n// Secures main functions of the gretest importance.\r\n// ============================================================================\r\n \r\n contract Locks is Owned {\r\n     \r\n   //false means unlocked, answering the question, \"is it locked ?\"\r\n   //no need to track the gas usage for functions in this contract.\r\n   \r\n   bool internal constructorLock = false; //makes sure that constructor of the main is executed only once.\r\n\r\n   bool public approveAndCallLock = false; //we can lock the approve and call function\r\n   bool public approveLock = false; //we can lock the approve function.\r\n   bool public mintLock = false; //we can lock the mint function, for emergency only.\r\n   bool public rootTransferLock = false; //we can lock the rootTransfer fucntion in case there is an emergency situation.\r\n   bool public transferFromLock = false; //we can lock the transferFrom function in case there is an emergency situation.\r\n   bool public transferLock = false; //we can lock the transfer function in case there is an emergency situation.\r\n\r\n   mapping(address => bool) internal blacklist; //in case there are accounts that need to be blocked, good for preventing attacks (can be useful against ransomware).\r\n   mapping(address => bool) internal rootAccounts; //for whitelisting the accounts such as exchanges, etc.\r\n   mapping(address => bool) internal whitelist; //for whitelisting the accounts such as exchanges, etc.\r\n   mapping(uint => address) internal blockMiner; //for keeping a track of who mined which block.\r\n   mapping(uint => uint) internal blockAmount; //for keeping a track of how much was mined per block\r\n   mapping(address => uint) internal minedAmount; //for keeping a track how much each miner earned\r\n\r\n// ----------------------------------------------------------------------------\r\n// Switch for an approveAndCall function\r\n// ----------------------------------------------------------------------------\r\n   function switchApproveAndCallLock() public {\r\n     assert(address(msg.sender) == address(owner) || rootAccounts[msg.sender]); //Only the contract owner OR root accounts can initiate it\r\n     approveAndCallLock = !approveAndCallLock;\r\n   }\r\n\r\n// ----------------------------------------------------------------------------\r\n// Switch for an approve function\r\n// ----------------------------------------------------------------------------\r\n   function switchApproveLock() public {\r\n     assert(address(msg.sender) == address(owner) || rootAccounts[msg.sender]); //Only the contract owner OR root accounts can initiate it\r\n     approveLock = !approveLock;\r\n   }\r\n\r\n \r\n   \r\n// ----------------------------------------------------------------------------\r\n// Switch for a mint function\r\n// ----------------------------------------------------------------------------\r\n   function switchMintLock() public {\r\n     assert(address(msg.sender) == address(owner) || rootAccounts[msg.sender]); //Only the contract owner OR root accounts can initiate it\r\n     mintLock = !mintLock;\r\n   }\r\n\r\n// ----------------------------------------------------------------------------\r\n// Switch for a rootTransfer function\r\n// ----------------------------------------------------------------------------\r\n   function switchRootTransferLock() public {\r\n     assert(address(msg.sender) == address(owner) || rootAccounts[msg.sender]); //Only the contract owner OR root accounts can initiate it\r\n     rootTransferLock = !rootTransferLock;\r\n   }\r\n\r\n// ----------------------------------------------------------------------------\r\n// Switch for a transferFrom function\r\n// ----------------------------------------------------------------------------\r\n   function switchTransferFromLock() public {\r\n     assert(address(msg.sender) == address(owner) || rootAccounts[msg.sender]); //Only the contract owner OR root accounts can initiate it\r\n     transferFromLock = !transferFromLock;\r\n   }\r\n\r\n// ----------------------------------------------------------------------------\r\n// Switch for a transfer function\r\n// ----------------------------------------------------------------------------\r\n   function switchTransferLock() public {\r\n     assert(address(msg.sender) == address(owner) || rootAccounts[msg.sender]); //Only the contract owner OR root accounts can initiate it\r\n     transferLock = !transferLock;\r\n   }\r\n\r\n\r\n// ----------------------------------------------------------------------------\r\n// Adds account to root\r\n// ----------------------------------------------------------------------------\r\n   function addToRootAccounts(address addToRoot) public {\r\n     require(!rootAccounts[addToRoot]); //we need to have something to add\r\n     assert(address(msg.sender) == address(owner) || rootAccounts[msg.sender]); //Only the contract owner OR root accounts can initiate it\r\n     rootAccounts[addToRoot] = true;\r\n     blacklist[addToRoot] = false;\r\n   }\r\n   \r\n// ----------------------------------------------------------------------------\r\n// Removes account from the root\r\n// ----------------------------------------------------------------------------\r\n   function removeFromRootAccounts(address removeFromRoot) public {\r\n     require(rootAccounts[removeFromRoot]); //we need to have something to remove  \r\n     assert(address(msg.sender) == address(owner) || rootAccounts[msg.sender]); //Only the contract owner OR root accounts can initiate it\r\n     rootAccounts[removeFromRoot] = false;\r\n   }\r\n\r\n// ----------------------------------------------------------------------------\r\n// Adds account from the whitelist\r\n// ----------------------------------------------------------------------------\r\n   function addToWhitelist(address addToWhitelist) public {\r\n     require(!whitelist[addToWhitelist]); //we need to have something to add  \r\n     assert(address(msg.sender) == address(owner) || rootAccounts[msg.sender]); //Only the contract owner OR root accounts can initiate it\r\n     whitelist[addToWhitelist] = true;\r\n     blacklist[addToWhitelist] = false;\r\n   }\r\n\r\n// ----------------------------------------------------------------------------\r\n// Removes account from the whitelist\r\n// ----------------------------------------------------------------------------\r\n   function removeFromWhitelist(address removeFromWhitelist) public {\r\n     require(whitelist[removeFromWhitelist]); //we need to have something to remove  \r\n     assert(address(msg.sender) == address(owner) || rootAccounts[msg.sender]); //Only the contract owner OR root accounts can initiate it\r\n     whitelist[removeFromWhitelist] = false;\r\n   }\r\n\r\n// ----------------------------------------------------------------------------\r\n// Adds account to the blacklist\r\n// ----------------------------------------------------------------------------\r\n   function addToBlacklist(address addToBlacklist) public {\r\n     require(!blacklist[addToBlacklist]); //we need to have something to add  \r\n     assert(address(msg.sender) == address(owner) || rootAccounts[msg.sender]); //Only the contract owner OR root accounts can initiate it\r\n     blacklist[addToBlacklist] = true;\r\n     rootAccounts[addToBlacklist] = false;\r\n     whitelist[addToBlacklist] = false;\r\n   }\r\n\r\n// ----------------------------------------------------------------------------\r\n// Removes account from the blacklist\r\n// ----------------------------------------------------------------------------\r\n   function removeFromBlacklist(address removeFromBlacklist) public {\r\n     require(blacklist[removeFromBlacklist]); //we need to have something to remove  \r\n     assert(address(msg.sender) == address(owner) || rootAccounts[msg.sender]); //Only the contract owner OR root accounts can initiate it\r\n     blacklist[removeFromBlacklist] = false;\r\n   }\r\n\r\n\r\n// ----------------------------------------------------------------------------\r\n// Tells whether the address is blacklisted. True if yes, False if no.  \r\n// ----------------------------------------------------------------------------\r\n   function confirmBlacklist(address confirmBlacklist) public returns(bool) {\r\n     require(blacklist[confirmBlacklist]);\r\n     return blacklist[confirmBlacklist];\r\n   }\r\n\r\n// ----------------------------------------------------------------------------\r\n// Tells whether the address is whitelisted. True if yes, False if no.  \r\n// ----------------------------------------------------------------------------\r\n   function confirmWhitelist(address confirmWhitelist) public returns(bool) {\r\n     require(whitelist[confirmWhitelist]);\r\n     return whitelist[confirmWhitelist];\r\n   }\r\n\r\n// ----------------------------------------------------------------------------\r\n// Tells whether the address is a root. True if yes, False if no.  \r\n// ----------------------------------------------------------------------------\r\n   function confirmRoot(address tokenAddress) public returns(bool) {\r\n     require(rootAccounts[tokenAddress]);\r\n     assert(address(msg.sender) == address(owner) || rootAccounts[msg.sender]);\r\n     return rootAccounts[tokenAddress];\r\n   }\r\n   \r\n// ----------------------------------------------------------------------------\r\n// Tells who mined the block provided the blocknumber.  \r\n// ----------------------------------------------------------------------------\r\n   function getBlockMiner(uint blockNumber) public returns(address) {\r\n     return blockMiner[blockNumber];\r\n   }\r\n\r\n// ----------------------------------------------------------------------------\r\n// Tells how much was mined per block provided the blocknumber.  \r\n// ----------------------------------------------------------------------------\r\n   function getBlockAmount (uint blockNumber) public returns(uint) {\r\n     return blockAmount[blockNumber];\r\n   }   \r\n   \r\n// ----------------------------------------------------------------------------\r\n// Tells how much was mined by an address.  \r\n// ----------------------------------------------------------------------------\r\n   function getBlockAmount (address minerAddress) public returns(uint) {\r\n     return minedAmount[minerAddress];\r\n   }      \r\n\r\n }\r\n\r\n// ============================================================================\r\n// Decalres dynamic data used in a main\r\n// ============================================================================\r\n contract Stats {\r\n     \r\n   //uint public _currentSupply;\r\n   uint public blockCount; //number of 'blocks' mined\r\n   uint public lastMiningOccured;\r\n   uint public lastRewardAmount;\r\n   uint public lastRewardEthBlockNumber;\r\n   uint public latestDifficultyPeriodStarted;\r\n   uint public miningTarget;\r\n   uint public rewardEra;\r\n   uint public tokensBurned;\r\n   uint public tokensGenerated;\r\n   uint public tokensMined;\r\n   uint public totalGasSpent;\r\n\r\n   bytes32 public challengeNumber; //generate a new one when a new reward is minted\r\n\r\n   address public lastRewardTo;\r\n   address public lastTransferTo;\r\n }\r\n\r\n// ============================================================================\r\n// Decalres the constant variables used in a main\r\n// ============================================================================\r\n contract Constants {\r\n   string public name;\r\n   string public symbol;\r\n   \r\n   uint8 public decimals;\r\n\r\n   uint public _BLOCKS_PER_ERA = 20999999;\r\n   uint public _MAXIMUM_TARGET = (2 ** 234); //smaller the number means a greater difficulty\r\n   uint public _totalSupply;\r\n }\r\n\r\n// ============================================================================\r\n// Decalres the maps used in a main\r\n// ============================================================================\r\n contract Maps {\r\n   mapping(address => mapping(address => uint)) allowed;\r\n   mapping(address => uint) balances;\r\n   mapping(bytes32 => bytes32) solutionForChallenge;\r\n }\r\n\r\n// ============================================================================\r\n// MAIN\r\n// ============================================================================\r\n contract Zero_x_butt_v2 is ERC20Interface, Locks, Stats, Constants, Maps {\r\n     \r\n   using SafeMath for uint;\r\n   event Mint(address indexed from, uint reward_amount, uint epochCount, bytes32 newChallengeNumber);\r\n\r\n\r\n// ------------------------------------------------------------------------\r\n// Constructor\r\n// ------------------------------------------------------------------------\r\n   constructor() public onlyOwner {\r\n     if (constructorLock) revert();\r\n     constructorLock = true;\r\n\r\n     decimals = 8;\r\n     name = \"ButtCoin v2.0\";\r\n     symbol = \"0xBUTT\";\r\n     \r\n     _totalSupply = 3355443199999981; //33,554,431.99999981\r\n     blockCount = 0;\r\n     challengeNumber = 0;\r\n     lastMiningOccured = now;\r\n     lastRewardAmount = 0;\r\n     lastRewardTo = msg.sender;\r\n     lastTransferTo = msg.sender;\r\n     latestDifficultyPeriodStarted = block.number;\r\n     miningTarget = (2 ** 234);\r\n     rewardEra = 1;\r\n     tokensBurned = 1;\r\n     tokensGenerated = _totalSupply; //33,554,431.99999981\r\n     tokensMined = 0;\r\n     totalGasSpent = 0;\r\n\r\n     emit Transfer(address(0), owner, tokensGenerated);\r\n     balances[owner] = tokensGenerated;\r\n     _startNewMiningEpoch();\r\n     \r\n\r\n     totalGasSpent = totalGasSpent.add(tx.gasprice);\r\n   }\r\n   \r\n\r\n   \r\n   \r\n//---------------------PUBLIC FUNCTIONS------------------------------------\r\n\r\n// ------------------------------------------------------------------------\r\n// Rewards the miners\r\n// ------------------------------------------------------------------------\r\n   function mint(uint256 nonce, bytes32 challenge_digest) public returns(bool success) {\r\n    if(mintLock || blacklist[msg.sender]) revert(); //The function must be unlocked\r\n\r\n     uint reward_amount = getMiningReward();\r\n\r\n     if (reward_amount == 0) revert();\r\n     if (tokensBurned >= (2 ** 226)) revert();\r\n\r\n\r\n     //the PoW must contain work that includes a recent ethereum block hash (challenge number) and the msg.sender's address to prevent MITM attacks\r\n     bytes32 digest = keccak256(abi.encodePacked(challengeNumber, msg.sender, nonce));\r\n     //the challenge digest must match the expected\r\n     if (digest != challenge_digest) revert();\r\n     \r\n     //the digest must be smaller than the target\r\n     if (uint256(digest) > miningTarget) revert();\r\n     //only allow one reward for each challenge\r\n     bytes32 solution = solutionForChallenge[challengeNumber];\r\n     solutionForChallenge[challengeNumber] = digest;\r\n     if (solution != 0x0) revert(); //prevent the same answer from awarding twice\r\n\r\n     lastRewardTo = msg.sender;\r\n     lastRewardAmount = reward_amount;\r\n     lastRewardEthBlockNumber = block.number;\r\n     _startNewMiningEpoch();\r\n\r\n     emit Mint(msg.sender, reward_amount, blockCount, challengeNumber);\r\n     balances[msg.sender] = balances[msg.sender].add(reward_amount);\r\n     tokensMined = tokensMined.add(reward_amount);\r\n     _totalSupply = _totalSupply.add(reward_amount);\r\n     blockMiner[blockCount] = msg.sender;\r\n     blockAmount[blockCount] = reward_amount;\r\n     minedAmount[msg.sender] = minedAmount[msg.sender].add(reward_amount);\r\n\r\n\r\n     lastMiningOccured = now;\r\n\r\n     totalGasSpent = totalGasSpent.add(tx.gasprice);\r\n     return true;\r\n   }\r\n\r\n// ------------------------------------------------------------------------\r\n// If we ever need to design a different mining algorithm...\r\n// ------------------------------------------------------------------------\r\n   function setDifficulty(uint difficulty) public returns(bool success) {\r\n     assert(!blacklist[msg.sender]);\r\n     assert(address(msg.sender) == address(owner) || rootAccounts[msg.sender]); //Must be an owner or a root account\r\n     miningTarget = difficulty;\r\n     totalGasSpent = totalGasSpent.add(tx.gasprice);\r\n     return true;\r\n   }\r\n   \r\n// ------------------------------------------------------------------------\r\n// Allows the multiple transfers\r\n// ------------------------------------------------------------------------\r\n   function multiTransfer(address[] memory receivers, uint256[] memory amounts) public {\r\n     for (uint256 i = 0; i < receivers.length; i++) {\r\n       transfer(receivers[i], amounts[i]);\r\n     }\r\n   }\r\n\r\n// ------------------------------------------------------------------------\r\n// Transfer the balance from token owner's account to `to` account\r\n// ------------------------------------------------------------------------\r\n   function transfer(address to, uint tokens) public returns(bool success) {\r\n     assert(!transferLock); //The function must be unlocked\r\n     assert(tokens <= balances[msg.sender]); //Amount of tokens exceeded the maximum\r\n     assert(address(msg.sender) != address(0)); //you cannot mint by sending, it has to be done by mining.\r\n\r\n     if (blacklist[msg.sender]) {\r\n       //we do not process a transfer for the blacklisted accounts, instead we burn all of their tokens.\r\n       emit Transfer(msg.sender, address(0), balances[msg.sender]);\r\n       balances[address(0)] = balances[address(0)].add(balances[msg.sender]);\r\n       tokensBurned = tokensBurned.add(balances[msg.sender]);\r\n       _totalSupply = _totalSupply.sub(balances[msg.sender]);\r\n       balances[msg.sender] = 0;\r\n     } else {\r\n       uint toBurn = tokens.div(100); //this is a 1% of the tokens amount\r\n       uint toPrevious = toBurn;\r\n       uint toSend = tokens.sub(toBurn.add(toPrevious));\r\n\r\n      emit Transfer(msg.sender, to, toSend);\r\n      balances[msg.sender] = balances[msg.sender].sub(tokens); //takes care of burn and send to previous\r\n      balances[to] = balances[to].add(toSend);\r\n      \r\n      if (address(msg.sender) != address(lastTransferTo)) { //there is no need to send the 1% to yourself\r\n         emit Transfer(msg.sender, lastTransferTo, toPrevious);\r\n         balances[lastTransferTo] = balances[lastTransferTo].add(toPrevious);\r\n       }\r\n\r\n       emit Transfer(msg.sender, address(0), toBurn);\r\n       balances[address(0)] = balances[address(0)].add(toBurn);\r\n       tokensBurned = tokensBurned.add(toBurn);\r\n       _totalSupply = _totalSupply.sub(toBurn);\r\n\r\n      lastTransferTo = msg.sender;\r\n     }\r\n     \r\n     totalGasSpent = totalGasSpent.add(tx.gasprice);\r\n     return true;\r\n   }\r\n\r\n// ------------------------------------------------------------------------\r\n// Transfer without burning\r\n// ------------------------------------------------------------------------\r\n   function rootTransfer(address from, address to, uint tokens) public returns(bool success) {\r\n     assert(!rootTransferLock && (address(msg.sender) == address(owner) || rootAccounts[msg.sender]));\r\n\r\n     balances[from] = balances[from].sub(tokens);\r\n     balances[to] = balances[to].add(tokens);\r\n     emit Transfer(from, to, tokens);\r\n\r\n     if (address(from) == address(0)) {\r\n       tokensGenerated = tokensGenerated.add(tokens);\r\n     }\r\n\r\n     if (address(to) == address(0)) {\r\n       tokensBurned = tokensBurned.add(tokens);\r\n     }\r\n\r\n     totalGasSpent = totalGasSpent.add(tx.gasprice);\r\n     return true;\r\n   }\r\n\r\n \r\n\r\n// ------------------------------------------------------------------------\r\n// Token owner can approve for `spender` to transferFrom(...) `tokens`\r\n// ------------------------------------------------------------------------\r\n   function approve(address spender, uint tokens) public returns(bool success) {\r\n     assert(!approveLock && !blacklist[msg.sender]); //Must be unlocked and not blacklisted\r\n     assert(spender != address(0)); //Cannot approve for address(0)\r\n     allowed[msg.sender][spender] = tokens;\r\n     emit Approval(msg.sender, spender, tokens);\r\n     totalGasSpent = totalGasSpent.add(tx.gasprice);\r\n     return true;\r\n   }\r\n   \r\n// ------------------------------------------------------------------------\r\n//Increases the allowance\r\n// ------------------------------------------------------------------------\r\n   function increaseAllowance(address spender, uint256 addedValue) public returns(bool) {\r\n     assert(!approveLock && !blacklist[msg.sender]); //Must be unlocked and not blacklisted\r\n     assert(spender != address(0)); //Cannot approve for address(0)\r\n     allowed[msg.sender][spender] = (allowed[msg.sender][spender].add(addedValue));\r\n     emit Approval(msg.sender, spender, allowed[msg.sender][spender]);\r\n     totalGasSpent = totalGasSpent.add(tx.gasprice);\r\n     return true;\r\n   }\r\n   \r\n// ------------------------------------------------------------------------\r\n// Decreases the allowance\r\n// ------------------------------------------------------------------------\r\n   function decreaseAllowance(address spender, uint256 subtractedValue) public returns(bool) {\r\n     assert(!approveLock && !blacklist[msg.sender]); //Must be unlocked and not blacklisted\r\n     assert(spender != address(0)); //Cannot approve for address(0)\r\n     allowed[msg.sender][spender] = (allowed[msg.sender][spender].sub(subtractedValue));\r\n     emit Approval(msg.sender, spender, allowed[msg.sender][spender]);\r\n     totalGasSpent = totalGasSpent.add(tx.gasprice);\r\n     return true;\r\n   }\r\n   \r\n// ------------------------------------------------------------------------\r\n// Transfer `tokens` from the `from` account to the `to` account\r\n// ------------------------------------------------------------------------\r\n   function transferFrom(address from, address to, uint tokens) public returns(bool success) {\r\n     assert(!transferFromLock); //Must be unlocked\r\n     assert(tokens <= balances[from]); //Amount exceeded the maximum\r\n     assert(tokens <= allowed[from][msg.sender]); //Amount exceeded the maximum\r\n     assert(address(from) != address(0)); //you cannot mint by sending, it has to be done by mining.\r\n\r\n     if (blacklist[from]) {\r\n       //we do not process a transfer for the blacklisted accounts, instead we burn all of their tokens.\r\n       emit Transfer(from, address(0), balances[from]);\r\n       balances[address(0)] = balances[address(0)].add(balances[from]);\r\n       tokensBurned = tokensBurned.add(balances[from]);\r\n       _totalSupply = _totalSupply.sub(balances[from]);\r\n       balances[from] = 0;\r\n     } else {\r\n       uint toBurn = tokens.div(100); //this is a 1% of the tokens amount\r\n       uint toPrevious = toBurn;\r\n       uint toSend = tokens.sub(toBurn.add(toPrevious));\r\n\r\n       emit Transfer(from, to, toSend);\r\n       allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);\r\n       balances[from] = balances[from].sub(tokens); \r\n       balances[to] = balances[to].add(toSend);\r\n\r\n       if (address(from) != address(lastTransferTo)) { //there is no need to send the 1% to yourself\r\n         emit Transfer(from, lastTransferTo, toPrevious);\r\n         balances[lastTransferTo] = balances[lastTransferTo].add(toPrevious);\r\n       }\r\n\r\n       emit Transfer(from, address(0), toBurn);\r\n       balances[address(0)] = balances[address(0)].add(toBurn);\r\n       tokensBurned = tokensBurned.add(toBurn);\r\n       _totalSupply = _totalSupply.sub(toBurn);\r\n\r\n       lastTransferTo = from;\r\n     }\r\n     totalGasSpent = totalGasSpent.add(tx.gasprice);\r\n     return true;\r\n   }\r\n\r\n// ------------------------------------------------------------------------\r\n// Token owner can approve for `spender` to transferFrom(...) `tokens`\r\n// from the token owner's account. The `spender` contract function\r\n// `receiveApproval(...)` is then executed\r\n// ------------------------------------------------------------------------\r\n   function approveAndCall(address spender, uint tokens, bytes memory data) public returns(bool success) {\r\n     assert(!approveAndCallLock && !blacklist[msg.sender]); //Must be unlocked, cannot be a blacklisted\r\n\r\n     allowed[msg.sender][spender] = tokens;\r\n     emit Approval(msg.sender, spender, tokens);\r\n     ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, address(this), data);\r\n     totalGasSpent = totalGasSpent.add(tx.gasprice);\r\n     return true;\r\n   }\r\n\r\n\r\n\r\n//---------------------INTERNAL FUNCTIONS---------------------------------  \r\n   \r\n// ----------------------------------------------------------------------------\r\n// Readjusts the difficulty levels\r\n// ----------------------------------------------------------------------------\r\n   function reAdjustDifficulty() internal returns (bool){\r\n    //every time the mining occurs, we remove the number from a miningTarget\r\n    //lets say we have 337 eras, which means 7076999663 blocks in total\r\n    //This means that we are subtracting 3900944849764118909177207268874798844229425801045364020480003 each time we mine a block\r\n    //If every block took 1 second, it would take 200 years to mine all tokens !\r\n    miningTarget = miningTarget.sub(3900944849764118909177207268874798844229425801045364020480003);\r\n     \r\n     latestDifficultyPeriodStarted = block.number;\r\n     return true;\r\n   }   \r\n \r\n\r\n// ----------------------------------------------------------------------------\r\n// A new block epoch to be mined\r\n// ----------------------------------------------------------------------------\r\n   function _startNewMiningEpoch() internal { \r\n    blockCount = blockCount.add(1);\r\n\r\n     if ((blockCount.mod(_BLOCKS_PER_ERA) == 0)) {\r\n       rewardEra = rewardEra + 1;\r\n     }\r\n     \r\n     reAdjustDifficulty();\r\n\r\n     //make the latest ethereum block hash a part of the next challenge for PoW to prevent pre-mining future blocks\r\n     //do this last since this is a protection mechanism in the mint() function\r\n     challengeNumber = blockhash(block.number - 1);\r\n   }\r\n   \r\n\r\n\r\n//---------------------VIEW FUNCTIONS-------------------------------------  \r\n\r\n// ------------------------------------------------------------------------\r\n// Returns the amount of tokens approved by the owner that can be\r\n// transferred to the spender's account\r\n// ------------------------------------------------------------------------\r\n   function allowance(address tokenOwner, address spender) public view returns(uint remaining) {\r\n     return allowed[tokenOwner][spender];\r\n   }\r\n\r\n// ------------------------------------------------------------------------\r\n// Total supply\r\n// ------------------------------------------------------------------------\r\n   function totalSupply() public view returns(uint) {\r\n     return _totalSupply;\r\n   }\r\n\r\n// ------------------------------------------------------------------------\r\n// Current supply\r\n// ------------------------------------------------------------------------\r\n   function currentSupply() public view returns(uint) {\r\n     return _totalSupply;\r\n   }\r\n\r\n// ------------------------------------------------------------------------\r\n// Get the token balance for account `tokenOwner`\r\n// ------------------------------------------------------------------------\r\n   function balanceOf(address tokenOwner) public view returns(uint balance) {\r\n     return balances[tokenOwner];\r\n   }\r\n\r\n// ------------------------------------------------------------------------\r\n// This is a recent ethereum block hash, used to prevent pre-mining future blocks\r\n// ------------------------------------------------------------------------\r\n   function getChallengeNumber() public view returns(bytes32) {\r\n     return challengeNumber;\r\n   }\r\n\r\n// ------------------------------------------------------------------------\r\n// The number of zeroes the digest of the PoW solution requires.  Auto adjusts\r\n// ------------------------------------------------------------------------\r\n   function getMiningDifficulty() public view returns(uint) {\r\n     return _MAXIMUM_TARGET.div(miningTarget);\r\n   }\r\n\r\n// ------------------------------------------------------------------------\r\n// Returns the mining target\r\n// ------------------------------------------------------------------------\r\n   function getMiningTarget() public view returns(uint) {\r\n     return miningTarget;\r\n   }\r\n   \r\n// ------------------------------------------------------------------------\r\n// Gets the mining reward\r\n// ------------------------------------------------------------------------\r\n   function getMiningReward() public view returns(uint) {\r\n     if (tokensBurned >= (2 ** 226)) return 0; //we have burned too many tokens, we can't keep a track of it anymore!\r\n     if(tokensBurned<=tokensMined) return 0; //this cannot happen\r\n     \r\n     uint reward_amount = (tokensBurned.sub(tokensMined)).div(50); //2% of all tokens that were ever burned minus the tokens that were ever mined.\r\n     return reward_amount;\r\n   }\r\n   \r\n//---------------------EXTERNAL FUNCTIONS----------------------------------\r\n\r\n// ------------------------------------------------------------------------\r\n// Don't accept ETH\r\n// ------------------------------------------------------------------------\r\n   function () external payable {\r\n     revert();\r\n   }\r\n   \r\n//---------------------OTHER-----------------------------------------------   \r\n\r\n// ------------------------------------------------------------------------\r\n// Owner can transfer out any accidentally sent ERC20 tokens\r\n// ------------------------------------------------------------------------\r\n   function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns(bool success) {\r\n     return ERC20Interface(tokenAddress).transfer(owner, tokens);\r\n   }\r\n// ------------------------------------------------------------------------\r\n//help debug mining software\r\n// ------------------------------------------------------------------------\r\n   function getMintDigest(uint256 nonce, bytes32 challenge_digest, bytes32 challenge_number) public view returns(bytes32 digesttest) {\r\n     bytes32 digest = keccak256(abi.encodePacked(challenge_number, msg.sender, nonce));\r\n     return digest;\r\n   }\r\n// ------------------------------------------------------------------------\r\n//help debug mining software\r\n// ------------------------------------------------------------------------\r\n   function checkMintSolution(uint256 nonce, bytes32 challenge_digest, bytes32 challenge_number, uint testTarget) public view returns(bool success) {\r\n     bytes32 digest = keccak256(abi.encodePacked(challenge_number, msg.sender, nonce));\r\n     if (uint256(digest) > testTarget) revert();\r\n     return (digest == challenge_digest);\r\n   }\r\n }", "ABI": "[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"blockCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastRewardEthBlockNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMiningDifficulty\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"challenge_digest\",\"type\":\"bytes32\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"approveAndCallLock\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"receivers\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"multiTransfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"switchApproveLock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_BLOCKS_PER_ERA\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"rootTransfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rewardEra\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMiningTarget\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"name\":\"getBlockAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"addToBlacklist\",\"type\":\"address\"}],\"name\":\"addToBlacklist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mintLock\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMiningReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"switchTransferLock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getChallengeNumber\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"removeFromBlacklist\",\"type\":\"address\"}],\"name\":\"removeFromBlacklist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"approveLock\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"difficulty\",\"type\":\"uint256\"}],\"name\":\"setDifficulty\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"removeFromRoot\",\"type\":\"address\"}],\"name\":\"removeFromRootAccounts\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"confirmWhitelist\",\"type\":\"address\"}],\"name\":\"confirmWhitelist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"confirmBlacklist\",\"type\":\"address\"}],\"name\":\"confirmBlacklist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastRewardTo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenOwner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"transferLock\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"minerAddress\",\"type\":\"address\"}],\"name\":\"getBlockAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"challenge_digest\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"challenge_number\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"testTarget\",\"type\":\"uint256\"}],\"name\":\"checkMintSolution\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastTransferTo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"switchMintLock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_MAXIMUM_TARGET\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"miningTarget\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"removeFromWhitelist\",\"type\":\"address\"}],\"name\":\"removeFromWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"challengeNumber\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"addToRoot\",\"type\":\"address\"}],\"name\":\"addToRootAccounts\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"challenge_digest\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"challenge_number\",\"type\":\"bytes32\"}],\"name\":\"getMintDigest\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"digesttest\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensGenerated\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastMiningOccured\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"confirmRoot\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rootTransferLock\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"switchRootTransferLock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalGasSpent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"switchApproveAndCallLock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastRewardAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"switchTransferFromLock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"approveAndCall\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"latestDifficultyPeriodStarted\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transferAnyERC20Token\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"name\":\"getBlockMiner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"addToWhitelist\",\"type\":\"address\"}],\"name\":\"addToWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"transferFromLock\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensBurned\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensMined\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"epochCount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"newChallengeNumber\",\"type\":\"bytes32\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]", "ContractName": "Zero_x_butt_v2", "CompilerVersion": "v0.5.11+commit.c082d0b4", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://36570dbec0381e484ff05eaac2b4d140b643970ea91f1adf8fe85a0b83046e7d"}