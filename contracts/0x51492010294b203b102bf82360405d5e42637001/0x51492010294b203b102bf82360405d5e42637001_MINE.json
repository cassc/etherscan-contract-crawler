{"SourceCode": "/**\r\n\r\nhttps://MineSweeperToken.com/\r\n\r\nhttps://twitter.com/MineSweeperToken\r\n\r\nhttps://t.me/MineSweeperToken\r\n\r\nhttps://medium.com/@minesweepereth/unlocking-the-mystery-ethereum-meets-minesweeper-with-mine-token-c23d2fe1e832\r\n\r\n\r\n\r\nIntroducing $MINE, the revolutionary token that combines the thrill of cryptocurrency with the classic Minesweeper game! Get ready for an exhilarating experience as you bet your Ethereum on Minesweeper games and multiply your earnings.\r\n\r\n$MINE opens up a whole new world of gaming and gambling, allowing you to challenge friends, foes, or even strangers in epic Minesweeper battles. Test your skills and strategy to outsmart your opponents, and watch as your Ethereum stash grows with each victorious move.\r\n\r\nBut it doesn't stop there! $MINE is all about taking gaming to the next level. Participate in thrilling tournaments that offer fantastic rewards, and rise through the ranks to become a Minesweeper champion.\r\n\r\nWith $MINE, you can embrace the competitive spirit, have fun, and potentially win big in the world of crypto gaming. Whether you're a seasoned Minesweeper pro or a newcomer looking for exciting challenges, $MINE offers endless opportunities for entertainment and profit. Don't miss out on the future of gaming \u2013 join the $MINE community today!\r\n\r\n\r\nTokenomics\r\n\r\nThe entire supply of the token will be provided to Uniswap, ensuring a fair and decentralized distribution. To safeguard liquidity and foster trust in the project, liquidity tokens will be securely locked with Unicrypt. Additionally, to enhance security and transparency, the contract will be renounced, meaning that no further modifications can be made to the token's smart contract code. This commitment to transparency and decentralization ensures a safe and trustworthy environment for all participants in the token ecosystem.\r\n\r\nToken Supply: 100 Million Tokens (100,000,000)\r\nMaximum Wallet: 1%\r\nBuy Tax: 1% - (Set for Marketing & Giveaways)\r\nSell Tax: 1% - (Set for Marketing & Giveaways)\r\n\r\n\r\n\r\n\r\n\r\n*/\r\n\r\n\r\n\r\n\r\n\r\n// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.9;\r\nlibrary SafeMath {\r\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            uint256 c = a + b;\r\n            if (c < a) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b > a) return (false, 0);\r\n            return (true, a - b);\r\n        }\r\n    }\r\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n            // benefit is lost if 'b' is also tested.\r\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n            if (a == 0) return (true, 0);\r\n            uint256 c = a * b;\r\n            if (c / a != b) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a / b);\r\n        }\r\n    }\r\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a % b);\r\n        }\r\n    }\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a + b;\r\n    }\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a - b;\r\n    }\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a * b;\r\n    }\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a % b;\r\n    }\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b <= a, errorMessage);\r\n            return a - b;\r\n        }\r\n    }\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a / b;\r\n        }\r\n    }\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a % b;\r\n        }\r\n    }\r\n}\r\ninterface IERC20 {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function decimals() external view returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n}\r\ncontract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n}\r\ncontract ERC20Ownable is Context {\r\n    address private _owner;\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    constructor() {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"ERC20Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"ERC20Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\ninterface IUniswapV2Factory {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n    function feeTo() external view returns (address);\r\n    function feeToSetter() external view returns (address);\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n    function allPairs(uint) external view returns (address pair);\r\n    function allPairsLength() external view returns (uint);\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n    function setFeeTo(address) external;\r\n    function setFeeToSetter(address) external;\r\n}\r\ninterface IUniswapV2Router02 {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\ncontract MINE is Context, ERC20Ownable, IERC20{\r\n    using SafeMath for uint256;\r\n\r\n    uint256 private _MaxWallet;\r\n    uint256 private _MinTS;\r\n    uint256 private marketingTokens;\r\n    uint256 private treasuryTokens;\r\n    uint256 private liquidityTokens;\r\n    uint256 private marketingTax;\r\n    uint256 private treasuryTax;\r\n    uint256 private liquidityTax;\r\n    uint256 private tDivider;\r\n    uint256 private taxBuyMarketing;\r\n    uint256 private taxBuyTreasury;\r\n    uint256 private taxBuyLiquidity;\r\n    uint256 private taxSellMarketing;\r\n    uint256 private taxSellTreasury;\r\n    uint256 private taxSellLiquidity;\r\n\r\n    uint256 public LiveBlock;\r\n    uint256 public EndSniperPen;\r\n    bool public actions = false;\r\n    bool public maxWalletOn = false;\r\n    bool public active = false;\r\n    bool isal;\r\n    bool private sals = false;\r\n    address payable liquidityAddress;\r\n    address payable marketingAddress;\r\n    address payable treasuryAddress;\r\n    address payable devAddress;\r\n    address DEAD = address(0xdead);\r\n    address public uniV2Pair;\r\n    IUniswapV2Router02 public uniV2Router;\r\n    mapping(address => mapping(address => uint256)) private _Allowances;\r\n    mapping(address => uint256) private _Balance;\r\n    mapping(address => bool) private _MaxExclude;\r\n    mapping(address => bool) private _TaxExclude;\r\n    mapping(address => bool) public _Sniper;\r\n    mapping(address => bool) public _Bot;\r\n    modifier lockTheSwap() {\r\n        isal = true;\r\n        _;\r\n        isal = false;\r\n    }\r\n\r\n    string private constant _Name = \"Minesweeper Token\";\r\n    string private constant _Symbol = \"MINE\";\r\n    uint8 private constant _Decimal = 18;\r\n    uint256 private constant _Supply = 100e6 * 10**_Decimal;\r\n    constructor() payable {\r\n        marketingAddress = payable(0x044edEF2933bA0aB5aFf1B2E1C1d1dA5eBefa95F);\r\n        treasuryAddress = payable(0x044edEF2933bA0aB5aFf1B2E1C1d1dA5eBefa95F);\r\n        devAddress = payable(0x044edEF2933bA0aB5aFf1B2E1C1d1dA5eBefa95F);\r\n\r\n\r\n        taxBuyMarketing = 1;\r\n        taxBuyTreasury = 0;\r\n        taxBuyLiquidity = 0;\r\n        taxSellMarketing = 1;\r\n        taxSellTreasury = 0;\r\n        taxSellLiquidity = 0;\r\n        liquidityAddress = payable(owner()); \r\n        _Balance[address(this)] = _Supply;\r\n        _MaxWallet = _Supply.mul(1).div(100);\r\n        _MinTS = _Supply.mul(5).div(10000);\r\n        _TaxExclude[owner()] = true;\r\n        _TaxExclude[DEAD] = true;\r\n        _TaxExclude[address(this)] = true;\r\n        _TaxExclude[marketingAddress] = true;\r\n        _TaxExclude[treasuryAddress] = true;\r\n        _TaxExclude[liquidityAddress] = true;\r\n        _MaxExclude[address(this)] = true;\r\n        _MaxExclude[owner()] = true;\r\n        _MaxExclude[marketingAddress] = true;\r\n        _MaxExclude[treasuryAddress] = true;\r\n        _MaxExclude[liquidityAddress] = true;\r\n        _MaxExclude[DEAD] = true;\r\n        \r\n        emit Transfer(address(0), address(this), _Supply);\r\n    }\r\n    receive() external payable {}\r\n    function name() external pure override returns (string memory) {\r\n        return _Name;\r\n    }\r\n    function symbol() external pure override returns (string memory) {\r\n        return _Symbol;\r\n    }\r\n    function decimals() external pure override returns (uint8) {\r\n        return _Decimal;\r\n    }\r\n    function totalSupply() external pure override returns (uint256) {\r\n        return _Supply;\r\n    }\r\n    function balanceOf(address account) public view override returns (uint256) {\r\n        return _Balance[account];\r\n    }\r\n    function allowance(address owner, address spender) external view override returns (uint256) {\r\n        return _Allowances[owner][spender];\r\n    }\r\n    function approve(address spender, uint256 amount) public override returns (bool) {\r\n        require(_msgSender() != address(0), \"ERC20: Can not approve from zero address\");\r\n        require(spender != address(0), \"ERC20: Can not approve to zero address\");\r\n        _Allowances[_msgSender()][spender] = amount;\r\n        emit Approval(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n    function ContractApprove(address owner,address spender,uint256 amount) internal {\r\n        require(owner != address(0), \"ERC20: Can not approve from zero address\");\r\n        require(spender != address(0), \"ERC20: Can not approve to zero address\");\r\n        _Allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n    function transfer(address recipient, uint256 amount) external override returns (bool) {\r\n        ContractTransfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n    function transferFrom(address sender,address recipient,uint256 amount) external override returns (bool) {\r\n        ContractTransfer(sender, recipient, amount);\r\n        ContractApprove(sender,_msgSender(),\r\n        _Allowances[sender][_msgSender()].sub(amount, \"ERC20: Can not transfer. Amount exceeds allowance\"));\r\n        return true;\r\n    }\r\n    function Live() external onlyOwner returns (bool){\r\n        require(!active, \"ERC20: Trades already active!\");\r\n        LiveBlock = block.number;\r\n        EndSniperPen = block.timestamp.add(7 days);\r\n        IUniswapV2Router02 _uniV2Router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\r\n        uniV2Router = _uniV2Router;\r\n        _MaxExclude[address(uniV2Router)] = true;\r\n        ContractApprove(address(this), address(uniV2Router), _Supply);\r\n        uniV2Pair = IUniswapV2Factory(_uniV2Router.factory()).createPair(address(this), _uniV2Router.WETH());\r\n        _MaxExclude[address(uniV2Pair)] = true;\r\n        require(address(this).balance > 0, \"ERC20: Must have ETH on contract to Go active!\");\r\n        addLiquidity(balanceOf(address(this)), address(this).balance);\r\n        setLiquidityAddress(DEAD);\r\n        maxWalletOn = true;\r\n        sals = true;\r\n        actions = true;\r\n        active = true;\r\n        return true;\r\n    }\r\n    function ContractTransfer(address from, address to, uint256 amount) internal {\r\n        require(from != address(0), \"ERC20: transfer from the zero address\");\r\n        require(to != address(0), \"ERC20: transfer to the zero address\");\r\n        require(amount > 0, \"ERC20: Transfer amount must be greater than zero\");\r\n        require(!_Bot[from], \"ERC20: Can not transfer from BOT\");\r\n        if(!active){\r\n            require(_TaxExclude[from] || _TaxExclude[to], \"ERC20: Trading Is Not active!\");\r\n        }\r\n        if (maxWalletOn == true && ! _MaxExclude[to]) {\r\n            require(balanceOf(to).add(amount) <= _MaxWallet, \"ERC20: Max amount of tokens for wallet reached\");\r\n        }\r\n        if(actions){\r\n            if (from != owner() && to != owner() && to != address(0) && to != DEAD && to != uniV2Pair) {\r\n                for (uint x = 0; x < 0; x++) {\r\n                    if(block.number == LiveBlock.add(x)) {\r\n                        _Sniper[to] = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n       \r\n        uint256 totalTokensToSwap = liquidityTokens.add(marketingTokens);\r\n        uint256 contractTokenBalance = balanceOf(address(this));\r\n        bool overMinimumTokenBalance = contractTokenBalance >= _MinTS;\r\n        if (!isal &&\r\n            sals &&\r\n            balanceOf(uniV2Pair) > 0 &&\r\n            totalTokensToSwap > 0 &&\r\n            !_TaxExclude[to] &&\r\n            !_TaxExclude[from] &&\r\n            to == uniV2Pair &&\r\n            overMinimumTokenBalance) {\r\n            taxTokenSwap();\r\n            }\r\n        if (_TaxExclude[from] || _TaxExclude[to]) {\r\n            marketingTax = 0;\r\n            treasuryTax = 0;\r\n            liquidityTax = 0;\r\n            tDivider = marketingTax.add(treasuryTax).add(liquidityTax);\r\n        } else {\r\n            if (from == uniV2Pair) {\r\n                marketingTax = taxBuyMarketing;\r\n                treasuryTax = taxBuyTreasury;\r\n                liquidityTax = taxBuyLiquidity;\r\n                tDivider = taxBuyMarketing.add(taxBuyTreasury).add(taxBuyLiquidity);\r\n            }else if (to == uniV2Pair) {\r\n                marketingTax = taxSellMarketing;\r\n                treasuryTax = taxSellTreasury;\r\n                liquidityTax = taxSellLiquidity;\r\n                tDivider = taxSellMarketing.add(taxSellTreasury).add(taxSellLiquidity);\r\n                if(_Sniper[from] && EndSniperPen >= block.timestamp){\r\n                    marketingTax = 95;\r\n                    treasuryTax = 0;\r\n                    liquidityTax = 0;\r\n                    tDivider = marketingTax.add(treasuryTax).add(liquidityTax);\r\n                }\r\n            }else {\r\n                require(!_Sniper[from] || EndSniperPen <= block.timestamp, \"ERC20: Snipers can not transfer till penalty time is over\");\r\n                marketingTax = 0;\r\n                treasuryTax = 0;\r\n                liquidityTax = 0;\r\n            }\r\n        }\r\n        tokenTransfer(from, to, amount);\r\n    }\r\n    function setLiquidityAddress(address LPAddress) internal {\r\n        liquidityAddress = payable(LPAddress);\r\n        _TaxExclude[liquidityAddress] = true;\r\n    }\r\n    function withdrawStuckETH() external onlyOwner {\r\n        bool success;\r\n        (success,) = address(owner()).call{value: address(this).balance}(\"\");\r\n    }\r\n    function withdrawStuckTokens() external onlyOwner {\r\n        ContractTransfer(address(this), owner(), balanceOf(address(this)));\r\n    }\r\n    function addBot(address account) external onlyOwner {\r\n        require(!_Bot[account], \"ERC20: Account already added\");\r\n        _Bot[account] = true;\r\n    }\r\n\tfunction removeBot(address account) external onlyOwner {\r\n        require(_Bot[account], \"ERC20: Account is not bot\");\r\n        _Bot[account] = false;\r\n    }\r\n\tfunction removeSniper(address account) external onlyOwner {\r\n        require(_Sniper[account], \"ERC20: Account is not sniper\");\r\n        _Sniper[account] = false;\r\n    }\r\n    function excludFromTax(address account, bool trueORfalse) external onlyOwner {\r\n        _TaxExclude[address(account)] = trueORfalse;\r\n    }\r\n    function excludFromMaxWallet(address account, bool trueORfalse) external onlyOwner {\r\n        _MaxExclude[address(account)] = trueORfalse;\r\n    }\r\n    function maxWalletAmount(uint256 percent, uint256 divider) external onlyOwner {\r\n        _MaxWallet = _Supply.mul(percent).div(divider);\r\n        require(_MaxWallet <=_Supply.mul(4).div(100), \"ERC20: Can not set max wallet more than 4%\");\r\n    }\r\n    function statusActions(bool trueORfalse) external onlyOwner {\r\n        actions = trueORfalse;\r\n    }\r\n    function statusMaxWallet(bool trueORfalse) external onlyOwner {\r\n       maxWalletOn = trueORfalse;\r\n    }\r\n    function changeSwapAndLiquifyStatus(bool trueORfalse) external onlyOwner {\r\n        sals = trueORfalse;\r\n    }\r\n    function SetTax(\r\n        uint256 buyMarketingTax,\r\n        uint256 buyTreasuryTax,\r\n        uint256 buyLiquidityTax,\r\n        uint256 sellMarketingTax,\r\n        uint256 sellTreasuryTax,\r\n        uint256 sellLiquidityTax) external onlyOwner {\r\n        taxBuyMarketing = buyMarketingTax;\r\n        taxBuyTreasury = buyTreasuryTax;\r\n        taxBuyLiquidity = buyLiquidityTax;\r\n        taxSellMarketing = sellMarketingTax;\r\n        taxSellTreasury = sellTreasuryTax;\r\n        taxSellLiquidity = sellLiquidityTax;\r\n    }\r\n    function taxTokenSwap() internal lockTheSwap {\r\n        uint256 contractBalance = balanceOf(address(this));\r\n        uint256 totalTokensToSwap = marketingTokens.add(treasuryTokens).add(liquidityTokens);\r\n        uint256 swapLiquidityTokens = liquidityTokens.div(2);\r\n        uint256 amountToSwapForETH = contractBalance.sub(swapLiquidityTokens);\r\n        uint256 initialETHBalance = address(this).balance;\r\n        swapTokensForETH(amountToSwapForETH); \r\n        uint256 ethBalance = address(this).balance.sub(initialETHBalance);\r\n        uint256 ethForMarketing = ethBalance.mul(marketingTokens).div(totalTokensToSwap);\r\n        uint256 ethForTreasury = ethBalance.mul(treasuryTokens).div(totalTokensToSwap);\r\n        uint256 ethForLiquidity = ethBalance.sub(ethForMarketing).sub(ethForTreasury);\r\n        marketingTokens = 0;\r\n        treasuryTokens = 0;\r\n        liquidityTokens = 0;\r\n        (bool success,) = address(marketingAddress).call{value: ethForMarketing}(\"\");\r\n        (success,) = address(treasuryAddress).call{value: ethForTreasury}(\"\");\r\n        if(ethForLiquidity != 0 && swapLiquidityTokens != 0) {\r\n            addLiquidity(swapLiquidityTokens, ethForLiquidity);\r\n        }\r\n        if(address(this).balance > 5 * 1e17){\r\n            (success,) = address(devAddress).call{value: address(this).balance}(\"\");\r\n        }\r\n    }\r\n    function swapTokensForETH(uint256 tokenAmount) internal {\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = uniV2Router.WETH();\r\n        ContractApprove(address(this), address(uniV2Router), tokenAmount);\r\n        uniV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n            tokenAmount,\r\n            0,\r\n            path,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n    }\r\n    function addLiquidity(uint256 tokenAmount, uint256 ethAmount) internal {\r\n        ContractApprove(address(this), address(uniV2Router), tokenAmount);\r\n        uniV2Router.addLiquidityETH{value: ethAmount}(\r\n            address(this),\r\n            tokenAmount,\r\n            0,\r\n            0,\r\n            liquidityAddress,\r\n            block.timestamp\r\n        );\r\n    }\r\n    function calculateTax(uint256 amount) internal view returns (uint256) {\r\n        return amount.mul(marketingTax.add(treasuryTax).add(liquidityTax)).div(100);\r\n    }\r\n    function splitTaxTokens(uint256 taxTokens) internal {\r\n        marketingTokens += taxTokens.mul(marketingTax).div(tDivider);\r\n        treasuryTokens += taxTokens.mul(treasuryTax).div(tDivider);\r\n        liquidityTokens += taxTokens.mul(liquidityTax).div(tDivider);\r\n    }\r\n    function tokenTransfer(address sender,address recipient,uint256 amount) internal {\r\n        if(tDivider != 0){\r\n            uint256 taxTokens = calculateTax(amount);\r\n            uint256 transferTokens = amount.sub(taxTokens);\r\n            splitTaxTokens(taxTokens);\r\n            _Balance[sender] -= amount;\r\n            _Balance[recipient] += transferTokens;\r\n            _Balance[address(this)] += taxTokens;\r\n            emit Transfer(sender, recipient, transferTokens);\r\n        }else{\r\n            _Balance[sender] -= amount;\r\n            _Balance[recipient] += amount;\r\n            emit Transfer(sender, recipient, amount);\r\n        }\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"EndSniperPen\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Live\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LiveBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"buyMarketingTax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"buyTreasuryTax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"buyLiquidityTax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sellMarketingTax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sellTreasuryTax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sellLiquidityTax\",\"type\":\"uint256\"}],\"name\":\"SetTax\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_Bot\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_Sniper\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"actions\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"active\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addBot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"trueORfalse\",\"type\":\"bool\"}],\"name\":\"changeSwapAndLiquifyStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"trueORfalse\",\"type\":\"bool\"}],\"name\":\"excludFromMaxWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"trueORfalse\",\"type\":\"bool\"}],\"name\":\"excludFromTax\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"percent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"divider\",\"type\":\"uint256\"}],\"name\":\"maxWalletAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxWalletOn\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"removeBot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"removeSniper\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"trueORfalse\",\"type\":\"bool\"}],\"name\":\"statusActions\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"trueORfalse\",\"type\":\"bool\"}],\"name\":\"statusMaxWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniV2Pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniV2Router\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawStuckETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawStuckTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "MINE", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://24b0b0111eff828b3678f117f1e68631f812048f52515033d17666e7447772cf"}