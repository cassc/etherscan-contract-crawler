{"SourceCode": "//SPDX-License-Identifier: No\r\npragma solidity ^0.8.17;\r\n\r\n//--- Context ---//\r\nabstract contract Context {\r\n    constructor() {}\r\n\r\n    function _msgSender() internal view returns (address payable) {\r\n        return payable(msg.sender);\r\n    }\r\n\r\n    function _msgData() internal view returns (bytes memory) {\r\n        this;\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n//--- Pausable ---//\r\nabstract contract Pausable is Context {\r\n    event Paused(address account);\r\n\r\n    event Unpaused(address account);\r\n\r\n    bool private _paused;\r\n\r\n    constructor() {\r\n        _paused = false;\r\n    }\r\n\r\n    modifier whenNotPaused() {\r\n        _requireNotPaused();\r\n        _;\r\n    }\r\n\r\n    modifier whenPaused() {\r\n        _requirePaused();\r\n        _;\r\n    }\r\n\r\n    function paused() public view virtual returns (bool) {\r\n        return _paused;\r\n    }\r\n\r\n    function _requireNotPaused() internal view virtual {\r\n        require(!paused(), \"Pausable: paused\");\r\n    }\r\n\r\n    function _requirePaused() internal view virtual {\r\n        require(paused(), \"Pausable: not paused\");\r\n    }\r\n\r\n    function _pause() internal virtual whenNotPaused {\r\n        _paused = true;\r\n        emit Paused(_msgSender());\r\n    }\r\n\r\n    function _unpause() internal virtual whenPaused {\r\n        _paused = false;\r\n        emit Unpaused(_msgSender());\r\n    }\r\n}\r\n\r\n//--- Ownable ---//\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n    address private _multiSig;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n    event MultiSigTransferred(\r\n        address indexed oldMultiSig,\r\n        address indexed newMultiSig\r\n    );\r\n\r\n    constructor() {\r\n        _setOwner(_msgSender());\r\n        _setMultiSig(_msgSender());\r\n    }\r\n\r\n    function multisig() public view virtual returns (address) {\r\n        return _multiSig;\r\n    }\r\n\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(\r\n            owner() == _msgSender() || multisig() == _msgSender(),\r\n            \"Ownable: caller is not the owner\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier onlyMultiSignature() {\r\n        require(\r\n            multisig() == _msgSender(),\r\n            \"Ownable: caller is not the multisig\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _setOwner(address(0));\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(\r\n            newOwner != address(0),\r\n            \"Ownable: new owner is the zero address\"\r\n        );\r\n        _setOwner(newOwner);\r\n    }\r\n\r\n    function transferMultiSig(\r\n        address newMultiSig\r\n    ) public virtual onlyMultiSignature {\r\n        require(\r\n            newMultiSig != address(0),\r\n            \"Ownable: new owner is the zero address\"\r\n        );\r\n        _setMultiSig(newMultiSig);\r\n    }\r\n\r\n    function _setOwner(address newOwner) private {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n\r\n    function _setMultiSig(address newMultiSig) private {\r\n        address oldMultiSig = _multiSig;\r\n        _multiSig = newMultiSig;\r\n        emit MultiSigTransferred(oldMultiSig, newMultiSig);\r\n    }\r\n}\r\n\r\n//--- Interface for ERC20 ---//\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    function allowance(\r\n        address owner,\r\n        address spender\r\n    ) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\n\r\ncontract RefundStaking is Context, Pausable, Ownable {\r\n    event staking(uint256 amount);\r\n    event WithdrawFromStaking(uint256 amount);\r\n    event ClaimRewards(uint256 amount);\r\n\r\n    uint256 public TokenDedicatiAlloStaking; // Modalit\u00e0 1: Fixed amount of tokens staked.\r\n    uint256 public safeSeconds = 15;\r\n    uint256 public totalSupply; // amount of all token staked\r\n    bool public isStakingLive = false;\r\n    uint256 private dayzero;\r\n    uint256 private preApproval;\r\n    bool public Initalized = false;\r\n    mapping(address => uint256) private rewardsGiaPagati;\r\n    mapping(address => uint256) public rewards;\r\n    mapping(address => uint256) private quandoStake;\r\n    mapping(address => uint256) private quandoWithdraw;\r\n    mapping(address => uint256) private lastTimeStaked;\r\n    mapping(address => uint256) private holdingXstaking;\r\n    mapping(address => uint256) private lastClaimRewards;\r\n\r\n    mapping(address => bool) private AlreadyStaked;\r\n\r\n    uint256 private interestperDay = 1_0000000000;\r\n\r\n    IERC20 public Token;\r\n\r\n    function setToken(address _token) external onlyMultiSignature {\r\n        require(!Initalized);\r\n        Token = IERC20(_token);\r\n        Initalized = true;\r\n    }\r\n\r\n    function unPause() external onlyMultiSignature {\r\n        _unpause();\r\n    }\r\n\r\n    function setTokenDedicatiAlloStaking(uint256 amount) external onlyOwner {\r\n        uint256 tempBalance = Token.balanceOf(msg.sender); //\r\n        require(tempBalance >= amount, \"Not enough tokens\"); //\r\n        Token.transferFrom(msg.sender, address(this), amount); // make sure to give enough allowance\r\n        TokenDedicatiAlloStaking += amount;\r\n    }\r\n\r\n    function setStakingLive() external onlyOwner {\r\n        require(!isStakingLive, \"Staking is already live\");\r\n        isStakingLive = true;\r\n    }\r\n\r\n    function reset() external onlyMultiSignature {\r\n        uint256 tempBalance = Token.balanceOf(address(this));\r\n        if (tempBalance > 0) {\r\n            Token.transfer(msg.sender, tempBalance);\r\n        }\r\n        interestperDay = 0;\r\n        TokenDedicatiAlloStaking = 0;\r\n        isStakingLive = false;\r\n        _pause();\r\n    }\r\n\r\n    function stakeprivate(uint256 amount) private {\r\n        uint256 tempBalance = Token.balanceOf(msg.sender);\r\n        require(isStakingLive, \"Staking is not live\");\r\n        require(tempBalance >= amount, \"Not enough tokens\");\r\n        Token.transferFrom(msg.sender, address(this), amount);\r\n        holdingXstaking[msg.sender] += amount;\r\n        totalSupply += amount;\r\n        quandoStake[msg.sender] = block.timestamp; // Quando stake in secondi. https://www.site24x7.com/tools/time-stamp-converter.html\r\n        AlreadyStaked[msg.sender] = true;\r\n    }\r\n\r\n    function stake(uint256 amount) external whenNotPaused {\r\n        require(msg.sender != address(0));\r\n        require(isStakingLive, \"Staking is not live yet.\");\r\n\r\n        bool YesNoStaked = AlreadyStaked[msg.sender] == true;\r\n        if (YesNoStaked) {\r\n            if (pend(msg.sender) >= holdingXstaking[msg.sender] / 1000) {\r\n                revert(\r\n                    \"Claim Rewards, you have at least 0.1% rewards to claim\"\r\n                );\r\n            }\r\n        } else {}\r\n\r\n        stakeprivate(amount);\r\n\r\n        emit staking(amount);\r\n    }\r\n\r\n    function withdraw(uint256 amount) external whenNotPaused {\r\n        require(msg.sender != address(0));\r\n        require(amount > 0, \"Amount should be greater than 0\");\r\n        require(holdingXstaking[msg.sender] >= amount, \"Not enough tokens\");\r\n        holdingXstaking[msg.sender] -= amount;\r\n        totalSupply -= amount;\r\n\r\n        Token.transfer(msg.sender, amount);\r\n\r\n        quandoWithdraw[msg.sender] = block.timestamp;\r\n        bool goingToZero = holdingXstaking[msg.sender] == 0;\r\n        if (goingToZero) {\r\n            resetUser();\r\n        }\r\n\r\n        emit WithdrawFromStaking(amount);\r\n    }\r\n\r\n    function resetUser() private {\r\n        AlreadyStaked[msg.sender] = false;\r\n        rewards[msg.sender] = 0;\r\n        rewardsGiaPagati[msg.sender] = 0;\r\n        lastClaimRewards[msg.sender] = 0;\r\n        quandoStake[msg.sender] = 0;\r\n        holdingXstaking[msg.sender] = 0;\r\n    }\r\n\r\n    function calculateRewards() private {\r\n        uint256 interestPerSecond = interestperDay / 86400;\r\n        uint256 interest = (block.timestamp - quandoStake[msg.sender]) *\r\n            interestPerSecond;\r\n\r\n        rewards[msg.sender] = (holdingXstaking[msg.sender] * interest);\r\n        rewards[msg.sender] = checkZeroMath(msg.sender, rewards[msg.sender]);\r\n    }\r\n\r\n    function safe() private view whenNotPaused {\r\n        require(\r\n            block.timestamp > lastClaimRewards[msg.sender] + safeSeconds,\r\n            \"Cannot claim in the sameblock\"\r\n        );\r\n    }\r\n\r\n    function staked() private view {\r\n        bool YesNoStaked = AlreadyStaked[msg.sender] == true;\r\n        if (YesNoStaked) {} else {\r\n            safe();\r\n        }\r\n    }\r\n\r\n    function claimReward() public whenNotPaused {\r\n        require(msg.sender != address(0));\r\n        calculateRewards();\r\n        staked();\r\n\r\n        require(rewards[msg.sender] > 0, \"Can't claim less than zero tokens\");\r\n\r\n        uint256 yourrewards = rewards[msg.sender];\r\n\r\n        Token.transfer(msg.sender, yourrewards);\r\n        rewardsGiaPagati[msg.sender] += yourrewards;\r\n        lastClaimRewards[msg.sender] = block.timestamp;\r\n        require(\r\n            TokenDedicatiAlloStaking > yourrewards,\r\n            \"Token Holders need to be able to get back 100% of the tokens allocated\"\r\n        );\r\n        TokenDedicatiAlloStaking -= yourrewards;\r\n\r\n        emit ClaimRewards(yourrewards);\r\n    }\r\n\r\n    function compound() external whenNotPaused {\r\n        require(msg.sender != address(0));\r\n\r\n        calculateRewards(); // Calculate pending rewards\r\n        staked();\r\n\r\n        require(rewards[msg.sender] > 0, \"No rewards to compound\");\r\n\r\n        uint256 yourRewards = rewards[msg.sender];\r\n        uint256 compoundAmount = yourRewards;\r\n\r\n        // Add pending rewards to the user's staked amount\r\n        holdingXstaking[msg.sender] += compoundAmount;\r\n        totalSupply += compoundAmount;\r\n        rewardsGiaPagati[msg.sender] += yourRewards;\r\n        lastClaimRewards[msg.sender] = block.timestamp;\r\n       \r\n        require(\r\n            TokenDedicatiAlloStaking > yourRewards,\r\n            \"Token Holders need to be able to get back 100% of the tokens allocated\"\r\n        );\r\n        TokenDedicatiAlloStaking -= yourRewards;\r\n    }\r\n\r\n    function amountStaked(address holder) external view returns (uint256) {\r\n        return holdingXstaking[holder];\r\n    }\r\n\r\n    function rewardsPaid(address holder) external view returns (uint256) {\r\n        return rewardsGiaPagati[holder];\r\n    }\r\n\r\n    function whenStaking(address holder) external view returns (uint256) {\r\n        return quandoStake[holder];\r\n    }\r\n\r\n    function lastTimeClaim(address holder) external view returns (uint256) {\r\n        return lastClaimRewards[holder];\r\n    }\r\n\r\n    function _alreadyStaked(address holder) external view returns (bool) {\r\n        return AlreadyStaked[holder];\r\n    }\r\n\r\n    function pend(address account) private view returns (uint256) {\r\n        uint256 interestPerSecond = interestperDay / 86400;\r\n        uint256 interest = (block.timestamp - quandoStake[account]) *\r\n            interestPerSecond;\r\n        uint256 preRewards;\r\n        preRewards = (holdingXstaking[account] * interest);\r\n        preRewards = checkZeroMath(account, preRewards);\r\n\r\n        return preRewards;\r\n    }\r\n\r\n    function checkZeroMath(\r\n        address account,\r\n        uint256 a\r\n    ) internal view returns (uint256) {\r\n        uint256 _return;\r\n        if (((a / 100000000000)) / 100 >= rewardsGiaPagati[account]) {\r\n            _return = ((a / 100000000000)) / 100 - rewardsGiaPagati[account];\r\n        } else {\r\n            _return = 0;\r\n        }\r\n        return _return;\r\n    }\r\n\r\n    function pendingRewards(address account) external view returns (uint256) {\r\n        return pend(account);\r\n    }\r\n}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ClaimRewards\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldMultiSig\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newMultiSig\",\"type\":\"address\"}],\"name\":\"MultiSigTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawFromStaking\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"staking\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"Initalized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Token\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TokenDedicatiAlloStaking\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"}],\"name\":\"_alreadyStaked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"}],\"name\":\"amountStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"compound\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isStakingLive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"}],\"name\":\"lastTimeClaim\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"multisig\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"pendingRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reset\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"rewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"}],\"name\":\"rewardsPaid\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"safeSeconds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setStakingLive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"setToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setTokenDedicatiAlloStaking\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newMultiSig\",\"type\":\"address\"}],\"name\":\"transferMultiSig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unPause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"}],\"name\":\"whenStaking\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "RefundStaking", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://a1ec7939b9706151fa561fdb63311d10aa0e41c0ab5e586508be108c4790ec87"}