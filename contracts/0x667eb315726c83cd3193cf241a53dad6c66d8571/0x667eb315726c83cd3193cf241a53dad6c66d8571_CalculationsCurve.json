{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"Curve.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.2;\\nimport \\\"Ownable.sol\\\";\\n\\ninterface IERC20 {\\n    function decimals() external view returns (uint8);\\n\\n    function symbol() external view returns (string memory);\\n}\\n\\ninterface ICurvePool {\\n    function get_virtual_price() external view returns (uint256);\\n\\n    function coins(uint256 arg0) external view returns (address);\\n}\\n\\ninterface ICurveRegistry {\\n    function get_pool_from_lp_token(address arg0)\\n        external\\n        view\\n        returns (address);\\n\\n    function get_underlying_coins(address arg0)\\n        external\\n        view\\n        returns (address[8] memory);\\n\\n    function get_virtual_price_from_lp_token(address arg0)\\n        external\\n        view\\n        returns (uint256);\\n}\\n\\ninterface ICryptoPool {\\n    function balances(uint256) external view returns (uint256);\\n\\n    function price_oracle(uint256) external view returns (uint256);\\n\\n    // Some crypto pools only consist of 2 coins, one of which is usd so\\n    // it can be assumed that the price oracle doesn't need an argument\\n    // and the price of the oracle refers to the other coin.\\n    // This function is mutually exclusive with the price_oracle function that takes\\n    // an argument of the index of the coin, only one will be present on the pool\\n    function price_oracle() external view returns (uint256);\\n\\n    function coins(uint256) external view returns (address);\\n}\\n\\ninterface ILp {\\n    function totalSupply() external view returns (uint256);\\n}\\n\\ninterface IOracle {\\n    function getPriceUsdcRecommended(address tokenAddress)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function usdcAddress() external view returns (address);\\n}\\n\\ninterface IYearnAddressesProvider {\\n    function addressById(string memory) external view returns (address);\\n}\\n\\ninterface ICurveAddressesProvider {\\n    function get_registry() external view returns (address);\\n\\n    function get_address(uint256) external view returns (address);\\n}\\n\\ninterface ICalculationsChainlink {\\n    function oracleNamehashes(address) external view returns (bytes32);\\n}\\n\\ninterface ICurveMetaRegistry {\\n    function get_pool_from_lp_token(address) external view returns (address);\\n}\\n\\ninterface ITriCryptoPool {\\n    function lp_price() external view returns (uint256);\\n}\\n\\ncontract CalculationsCurve is Ownable {\\n    address public yearnAddressesProviderAddress;\\n    address public curveAddressesProviderAddress;\\n    address public curveMetaRegistryAddress;\\n    ICurveMetaRegistry public curveMetaRegistry;\\n    IYearnAddressesProvider internal yearnAddressesProvider;\\n    ICurveAddressesProvider internal curveAddressesProvider;\\n\\n    constructor(\\n        address _yearnAddressesProviderAddress,\\n        address _curveAddressesProviderAddress,\\n        address _curveMetaRegistryAddress\\n    ) {\\n        yearnAddressesProviderAddress = _yearnAddressesProviderAddress;\\n        curveAddressesProviderAddress = _curveAddressesProviderAddress;\\n        curveMetaRegistryAddress = _curveMetaRegistryAddress;\\n        yearnAddressesProvider = IYearnAddressesProvider(\\n            _yearnAddressesProviderAddress\\n        );\\n        curveAddressesProvider = ICurveAddressesProvider(\\n            _curveAddressesProviderAddress\\n        );\\n        curveMetaRegistry = ICurveMetaRegistry(\\n            _curveMetaRegistryAddress\\n        );\\n    }\\n\\n    function updateYearnAddressesProviderAddress(\\n        address _yearnAddressesProviderAddress\\n    ) external onlyOwner {\\n        yearnAddressesProviderAddress = _yearnAddressesProviderAddress;\\n        yearnAddressesProvider = IYearnAddressesProvider(\\n            _yearnAddressesProviderAddress\\n        );\\n    }\\n\\n    function updateCurveAddressesProviderAddress(\\n        address _curveAddressesProviderAddress\\n    ) external onlyOwner {\\n        curveAddressesProviderAddress = _curveAddressesProviderAddress;\\n        curveAddressesProvider = ICurveAddressesProvider(\\n            _curveAddressesProviderAddress\\n        );\\n    }\\n\\n    function oracle() internal view returns (IOracle) {\\n        return IOracle(yearnAddressesProvider.addressById(\\\"ORACLE\\\"));\\n    }\\n\\n    function curveRegistry() internal view returns (ICurveRegistry) {\\n        return ICurveRegistry(curveAddressesProvider.get_registry());\\n    }\\n\\n    function cryptoPoolRegistry() internal view returns (ICurveRegistry) {\\n        return ICurveRegistry(curveAddressesProvider.get_address(5));\\n    }\\n\\n    function getCurvePriceUsdc(address lpAddress)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        address poolAddress = curveMetaRegistry.get_pool_from_lp_token(lpAddress);\\n        require(poolAddress != address(0));\\n        \\n        if (isPoolTriCryptoPool(poolAddress)) {\\n            return triCryptoPoolLpPriceUsdc(poolAddress);\\n        }\\n        if (isPoolCryptoPool(poolAddress)) {\\n            return cryptoPoolLpPriceUsdc(lpAddress);\\n        }\\n        \\n        uint256 basePrice = getBasePrice(lpAddress);\\n        uint256 virtualPrice = getVirtualPrice(lpAddress);\\n        IERC20 usdc = IERC20(oracle().usdcAddress());\\n        uint256 decimals = usdc.decimals();\\n        uint256 decimalsAdjustment = 18 - decimals;\\n        uint256 priceUsdc = (virtualPrice *\\n            basePrice *\\n            (10**decimalsAdjustment)) / 10**(decimalsAdjustment + 18);\\n        return priceUsdc;\\n    }\\n\\n    function cryptoPoolLpTotalValueUsdc(address lpAddress)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        address poolAddress = getPoolFromLpToken(lpAddress);\\n\\n        address[]\\n            memory underlyingTokensAddresses = cryptoPoolUnderlyingTokensAddressesByPoolAddress(\\n                poolAddress\\n            );\\n        uint256 totalValue;\\n        for (\\n            uint256 tokenIdx;\\n            tokenIdx < underlyingTokensAddresses.length;\\n            tokenIdx++\\n        ) {\\n            uint256 tokenValueUsdc = cryptoPoolTokenAmountUsdc(\\n                poolAddress,\\n                tokenIdx\\n            );\\n            totalValue += tokenValueUsdc;\\n        }\\n        return totalValue;\\n    }\\n\\n    function cryptoPoolLpPriceUsdc(address lpAddress)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        uint256 totalValueUsdc = cryptoPoolLpTotalValueUsdc(lpAddress);\\n        uint256 totalSupply = ILp(lpAddress).totalSupply();\\n        uint256 priceUsdc = (totalValueUsdc * 10**18) / totalSupply;\\n        return priceUsdc;\\n    }\\n\\n    function triCryptoPoolLpPriceUsdc(address poolAddress)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return ITriCryptoPool(poolAddress).lp_price() / 10 ** 12; // Prices are returned in 18 decimals. Scale down to USDC decimals.\\n    }\\n\\n    struct TokenAmount {\\n        address tokenAddress;\\n        string tokenSymbol;\\n        uint256 amountUsdc;\\n    }\\n\\n    function cryptoPoolTokenAmountsUsdc(address poolAddress)\\n        public\\n        view\\n        returns (TokenAmount[] memory)\\n    {\\n        address[]\\n            memory underlyingTokensAddresses = cryptoPoolUnderlyingTokensAddressesByPoolAddress(\\n                poolAddress\\n            );\\n        TokenAmount[] memory _tokenAmounts = new TokenAmount[](\\n            underlyingTokensAddresses.length\\n        );\\n        for (\\n            uint256 tokenIdx;\\n            tokenIdx < underlyingTokensAddresses.length;\\n            tokenIdx++\\n        ) {\\n            address tokenAddress = underlyingTokensAddresses[tokenIdx];\\n            string memory tokenSymbol = IERC20(tokenAddress).symbol();\\n            uint256 amountUsdc = cryptoPoolTokenAmountUsdc(\\n                poolAddress,\\n                tokenIdx\\n            );\\n            _tokenAmounts[tokenIdx] = TokenAmount({\\n                tokenAddress: tokenAddress,\\n                tokenSymbol: tokenSymbol,\\n                amountUsdc: amountUsdc\\n            });\\n        }\\n        return _tokenAmounts;\\n    }\\n\\n    function cryptoPoolTokenAmountUsdc(address poolAddress, uint256 tokenIdx)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        ICryptoPool pool = ICryptoPool(poolAddress);\\n        address tokenAddress = pool.coins(tokenIdx);\\n        uint8 decimals = IERC20(tokenAddress).decimals();\\n        uint256 tokenPrice = oracle().getPriceUsdcRecommended(tokenAddress);\\n        uint256 tokenValueUsdc = (pool.balances(tokenIdx) * tokenPrice) /\\n            10**decimals;\\n        return tokenValueUsdc;\\n    }\\n\\n    function cryptoPoolUnderlyingTokensAddressesByPoolAddress(\\n        address poolAddress\\n    ) public view returns (address[] memory) {\\n        uint256 numberOfTokens;\\n        address[] memory _tokensAddresses = new address[](8);\\n        for (uint256 coinIdx; coinIdx < 8; coinIdx++) {\\n            (bool success, bytes memory data) = address(poolAddress).staticcall(\\n                abi.encodeWithSignature(\\\"coins(uint256)\\\", coinIdx)\\n            );\\n            if (success) {\\n                address tokenAddress = abi.decode(data, (address));\\n                _tokensAddresses[coinIdx] = tokenAddress;\\n                numberOfTokens++;\\n            } else {\\n                break;\\n            }\\n        }\\n        bytes memory encodedAddresses = abi.encode(_tokensAddresses);\\n        assembly {\\n            mstore(add(encodedAddresses, 0x40), numberOfTokens)\\n        }\\n        address[] memory filteredAddresses = abi.decode(\\n            encodedAddresses,\\n            (address[])\\n        );\\n        return filteredAddresses;\\n    }\\n\\n    function getBasePrice(address lpAddress) public view returns (uint256) {\\n        address poolAddress = getPoolFromLpToken(lpAddress);\\n        address underlyingCoinAddress = getUnderlyingCoinFromPool(poolAddress);\\n        uint256 basePriceUsdc = oracle().getPriceUsdcRecommended(\\n            underlyingCoinAddress\\n        );\\n        return basePriceUsdc;\\n    }\\n\\n    // should not be used with lpAddresses that are from the crypto swap registry\\n    function getVirtualPrice(address lpAddress) public view returns (uint256) {\\n        address pool = curveMetaRegistry.get_pool_from_lp_token(lpAddress);\\n        ICurvePool(pool).get_virtual_price();\\n        return curveRegistry().get_virtual_price_from_lp_token(lpAddress);\\n    }\\n\\n    function isCurveLpToken(address lpAddress) public view returns (bool) {\\n        address poolAddress = getPoolFromLpToken(lpAddress);\\n        return poolAddress != address(0);\\n    }\\n\\n    function isPoolCryptoPool(address poolAddress) public view returns (bool) {\\n        (bool success, ) = address(poolAddress).staticcall(\\n            abi.encodeWithSignature(\\\"price_oracle(uint256)\\\", 0)\\n        );\\n\\n        if (success) {\\n            return true;\\n        }\\n\\n        (bool successNoParams, ) = address(poolAddress).staticcall(\\n            abi.encodeWithSignature(\\\"price_oracle()\\\")\\n        );\\n\\n        return successNoParams;\\n    }\\n\\n    function isPoolTriCryptoPool(address poolAddress) public view returns (bool) {\\n        (bool success, ) = address(poolAddress).staticcall(\\n            abi.encodeWithSignature(\\\"lp_price()\\\")\\n        );\\n\\n        return success;\\n    }\\n\\n    function getPoolFromLpToken(address lpAddress)\\n        public\\n        view\\n        returns (address)\\n    {\\n        return curveMetaRegistry.get_pool_from_lp_token(lpAddress);\\n    }\\n\\n    function isBasicToken(address tokenAddress) public view returns (bool) {\\n        return\\n            ICalculationsChainlink(\\n                yearnAddressesProvider.addressById(\\\"CALCULATIONS_CHAINLINK\\\")\\n            ).oracleNamehashes(tokenAddress) != bytes32(0);\\n    }\\n\\n    // should not be used with pools from the crypto pool registry\\n    function getUnderlyingCoinFromPool(address poolAddress)\\n        public\\n        view\\n        returns (address)\\n    {\\n        address[8] memory coins = curveRegistry().get_underlying_coins(\\n            poolAddress\\n        );\\n\\n        return getPreferredCoinFromCoins(coins);\\n    }\\n\\n    function getPreferredCoinFromCoins(address[8] memory coins)\\n        internal\\n        view\\n        returns (address)\\n    {\\n        // Look for preferred coins (basic coins)\\n        address preferredCoinAddress;\\n        for (uint256 coinIdx = 0; coinIdx < 8; coinIdx++) {\\n            address coinAddress = coins[coinIdx];\\n            if (coinAddress != address(0) && isBasicToken(coinAddress)) {\\n                preferredCoinAddress = coinAddress;\\n                break;\\n            } else if (coinAddress != address(0)) {\\n                preferredCoinAddress = coinAddress;\\n            }\\n            // Found preferred coin and we're at the end of the token array\\n            if (\\n                (preferredCoinAddress != address(0) &&\\n                    coinAddress == address(0)) || coinIdx == 7\\n            ) {\\n                break;\\n            }\\n        }\\n        return preferredCoinAddress;\\n    }\\n\\n    function getPriceUsdc(address assetAddress) public view returns (uint256) {\\n        if (isCurveLpToken(assetAddress)) {\\n            return getCurvePriceUsdc(assetAddress);\\n        }\\n\\n        ICurvePool pool = ICurvePool(assetAddress);\\n        uint256 virtualPrice = pool.get_virtual_price();\\n        address[8] memory coins;\\n        for (uint256 i = 0; i < 8; i++) {\\n            try pool.coins(i) returns (address coin) {\\n                coins[i] = coin;\\n            } catch {}\\n        }\\n        address preferredCoin = getPreferredCoinFromCoins(coins);\\n        uint256 price = oracle().getPriceUsdcRecommended(preferredCoin);\\n        if (price == 0) {\\n            revert();\\n        }\\n        return (price * virtualPrice) / 10**18;\\n    }\\n}\\n\"\r\n    },\r\n    \"Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.7.6;\\n\\n/*******************************************************\\n *                     Ownable\\n *******************************************************/\\ncontract Ownable {\\n    address public ownerAddress;\\n\\n    constructor() {\\n        ownerAddress = msg.sender;\\n    }\\n\\n    modifier onlyOwner() {\\n        require(msg.sender == ownerAddress, \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    function setOwnerAddress(address _ownerAddress) public onlyOwner {\\n        ownerAddress = _ownerAddress;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"libraries\": {\r\n      \"Curve.sol\": {}\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_yearnAddressesProviderAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_curveAddressesProviderAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_curveMetaRegistryAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lpAddress\",\"type\":\"address\"}],\"name\":\"cryptoPoolLpPriceUsdc\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lpAddress\",\"type\":\"address\"}],\"name\":\"cryptoPoolLpTotalValueUsdc\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"poolAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenIdx\",\"type\":\"uint256\"}],\"name\":\"cryptoPoolTokenAmountUsdc\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"poolAddress\",\"type\":\"address\"}],\"name\":\"cryptoPoolTokenAmountsUsdc\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"tokenSymbol\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"amountUsdc\",\"type\":\"uint256\"}],\"internalType\":\"struct CalculationsCurve.TokenAmount[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"poolAddress\",\"type\":\"address\"}],\"name\":\"cryptoPoolUnderlyingTokensAddressesByPoolAddress\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"curveAddressesProviderAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"curveMetaRegistry\",\"outputs\":[{\"internalType\":\"contract ICurveMetaRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"curveMetaRegistryAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lpAddress\",\"type\":\"address\"}],\"name\":\"getBasePrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lpAddress\",\"type\":\"address\"}],\"name\":\"getCurvePriceUsdc\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lpAddress\",\"type\":\"address\"}],\"name\":\"getPoolFromLpToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"assetAddress\",\"type\":\"address\"}],\"name\":\"getPriceUsdc\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"poolAddress\",\"type\":\"address\"}],\"name\":\"getUnderlyingCoinFromPool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lpAddress\",\"type\":\"address\"}],\"name\":\"getVirtualPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"isBasicToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lpAddress\",\"type\":\"address\"}],\"name\":\"isCurveLpToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"poolAddress\",\"type\":\"address\"}],\"name\":\"isPoolCryptoPool\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"poolAddress\",\"type\":\"address\"}],\"name\":\"isPoolTriCryptoPool\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ownerAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_ownerAddress\",\"type\":\"address\"}],\"name\":\"setOwnerAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"poolAddress\",\"type\":\"address\"}],\"name\":\"triCryptoPoolLpPriceUsdc\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_curveAddressesProviderAddress\",\"type\":\"address\"}],\"name\":\"updateCurveAddressesProviderAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_yearnAddressesProviderAddress\",\"type\":\"address\"}],\"name\":\"updateYearnAddressesProviderAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"yearnAddressesProviderAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "CalculationsCurve", "CompilerVersion": "v0.8.21+commit.d9974bed", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000e11dc9f2ab122dc5978eaca41483da0d7d7e61280000000000000000000000000000000022d53366457f9d5e68ec105046fc4383000000000000000000000000f98b45fa17de75fb1ad0e7afd971b0ca00e379fc", "EVMVersion": "istanbul", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}