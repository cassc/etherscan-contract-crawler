{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface AggregatorV3Interface {\\n  function decimals() external view returns (uint8);\\n\\n  function description() external view returns (string memory);\\n\\n  function version() external view returns (uint256);\\n\\n  // getRoundData and latestRoundData should both raise \\\"No data present\\\"\\n  // if they do not have data to report, instead of returning unset values\\n  // which could be misinterpreted as actual reported values.\\n  function getRoundData(uint80 _roundId)\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n  function latestRoundData()\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./extensions/IERC20Metadata.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * The default value of {decimals} is 18. To select a different value for\\n     * {decimals} you should overload it.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\n     * overridden;\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``sender``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n\\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\\n        require(currentAllowance >= amount, \\\"ERC20: transfer amount exceeds allowance\\\");\\n        unchecked {\\n            _approve(sender, _msgSender(), currentAllowance - amount);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) internal virtual {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n\\n        uint256 senderBalance = _balances[sender];\\n        require(senderBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[sender] = senderBalance - amount;\\n        }\\n        _balances[recipient] += amount;\\n\\n        emit Transfer(sender, recipient, amount);\\n\\n        _afterTokenTransfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        _balances[account] += amount;\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n        }\\n        _totalSupply -= amount;\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IBaseSilo.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.13;\\n\\nimport \\\"./IShareToken.sol\\\";\\nimport \\\"./IFlashLiquidationReceiver.sol\\\";\\nimport \\\"./ISiloRepository.sol\\\";\\n\\ninterface IBaseSilo {\\n    enum AssetStatus { Undefined, Active, Removed }\\n\\n    /// @dev Storage struct that holds all required data for a single token market\\n    struct AssetStorage {\\n        /// @dev Token that represents a share in totalDeposits of Silo\\n        IShareToken collateralToken;\\n        /// @dev Token that represents a share in collateralOnlyDeposits of Silo\\n        IShareToken collateralOnlyToken;\\n        /// @dev Token that represents a share in totalBorrowAmount of Silo\\n        IShareToken debtToken;\\n        /// @dev COLLATERAL: Amount of asset token that has been deposited to Silo with interest earned by depositors.\\n        /// It also includes token amount that has been borrowed.\\n        uint256 totalDeposits;\\n        /// @dev COLLATERAL ONLY: Amount of asset token that has been deposited to Silo that can be ONLY used\\n        /// as collateral. These deposits do NOT earn interest and CANNOT be borrowed.\\n        uint256 collateralOnlyDeposits;\\n        /// @dev DEBT: Amount of asset token that has been borrowed with accrued interest.\\n        uint256 totalBorrowAmount;\\n    }\\n\\n    /// @dev Storage struct that holds data related to fees and interest\\n    struct AssetInterestData {\\n        /// @dev Total amount of already harvested protocol fees\\n        uint256 harvestedProtocolFees;\\n        /// @dev Total amount (ever growing) of asset token that has been earned by the protocol from\\n        /// generated interest.\\n        uint256 protocolFees;\\n        /// @dev Timestamp of the last time `interestRate` has been updated in storage.\\n        uint64 interestRateTimestamp;\\n        /// @dev True if asset was removed from the protocol. If so, deposit and borrow functions are disabled\\n        /// for that asset\\n        AssetStatus status;\\n    }\\n\\n    /// @notice data that InterestModel needs for calculations\\n    struct UtilizationData {\\n        uint256 totalDeposits;\\n        uint256 totalBorrowAmount;\\n        /// @dev timestamp of last interest accrual\\n        uint64 interestRateTimestamp;\\n    }\\n\\n    /// @dev Shares names and symbols that are generated while asset initialization\\n    struct AssetSharesMetadata {\\n        /// @dev Name for the collateral shares token\\n        string collateralName;\\n        /// @dev Symbol for the collateral shares token\\n        string collateralSymbol;\\n        /// @dev Name for the collateral only (protected collateral) shares token\\n        string protectedName;\\n        /// @dev Symbol for the collateral only (protected collateral) shares token\\n        string protectedSymbol;\\n        /// @dev Name for the debt shares token\\n        string debtName;\\n        /// @dev Symbol for the debt shares token\\n        string debtSymbol;\\n    }\\n\\n    /// @notice Emitted when deposit is made\\n    /// @param asset asset address that was deposited\\n    /// @param depositor wallet address that deposited asset\\n    /// @param amount amount of asset that was deposited\\n    /// @param collateralOnly type of deposit, true if collateralOnly deposit was used\\n    event Deposit(address indexed asset, address indexed depositor, uint256 amount, bool collateralOnly);\\n\\n    /// @notice Emitted when withdraw is made\\n    /// @param asset asset address that was withdrawn\\n    /// @param depositor wallet address that deposited asset\\n    /// @param receiver wallet address that received asset\\n    /// @param amount amount of asset that was withdrew\\n    /// @param collateralOnly type of withdraw, true if collateralOnly deposit was used\\n    event Withdraw(\\n        address indexed asset,\\n        address indexed depositor,\\n        address indexed receiver,\\n        uint256 amount,\\n        bool collateralOnly\\n    );\\n\\n    /// @notice Emitted on asset borrow\\n    /// @param asset asset address that was borrowed\\n    /// @param user wallet address that borrowed asset\\n    /// @param amount amount of asset that was borrowed\\n    event Borrow(address indexed asset, address indexed user, uint256 amount);\\n\\n    /// @notice Emitted on asset repay\\n    /// @param asset asset address that was repaid\\n    /// @param user wallet address that repaid asset\\n    /// @param amount amount of asset that was repaid\\n    event Repay(address indexed asset, address indexed user, uint256 amount);\\n\\n    /// @notice Emitted on user liquidation\\n    /// @param asset asset address that was liquidated\\n    /// @param user wallet address that was liquidated\\n    /// @param shareAmountRepaid amount of collateral-share token that was repaid. This is collateral token representing\\n    /// ownership of underlying deposit.\\n    /// @param seizedCollateral amount of underlying token that was seized by liquidator\\n    event Liquidate(address indexed asset, address indexed user, uint256 shareAmountRepaid, uint256 seizedCollateral);\\n\\n    /// @notice Emitted when the status for an asset is updated\\n    /// @param asset asset address that was updated\\n    /// @param status new asset status\\n    event AssetStatusUpdate(address indexed asset, AssetStatus indexed status);\\n\\n    /// @return version of the silo contract\\n    function VERSION() external returns (uint128); // solhint-disable-line func-name-mixedcase\\n\\n    /// @notice Synchronize current bridge assets with Silo\\n    /// @dev This function needs to be called on Silo deployment to setup all assets for Silo. It needs to be\\n    /// called every time a bridged asset is added or removed. When bridge asset is removed, depositing and borrowing\\n    /// should be disabled during asset sync.\\n    function syncBridgeAssets() external;\\n\\n    /// @notice Get Silo Repository contract address\\n    /// @return Silo Repository contract address\\n    function siloRepository() external view returns (ISiloRepository);\\n\\n    /// @notice Get asset storage data\\n    /// @param _asset asset address\\n    /// @return AssetStorage struct\\n    function assetStorage(address _asset) external view returns (AssetStorage memory);\\n\\n    /// @notice Get asset interest data\\n    /// @param _asset asset address\\n    /// @return AssetInterestData struct\\n    function interestData(address _asset) external view returns (AssetInterestData memory);\\n\\n    /// @dev helper method for InterestRateModel calculations\\n    function utilizationData(address _asset) external view returns (UtilizationData memory data);\\n\\n    /// @notice Calculates solvency of an account\\n    /// @param _user wallet address for which solvency is calculated\\n    /// @return true if solvent, false otherwise\\n    function isSolvent(address _user) external view returns (bool);\\n\\n    /// @notice Returns all initialized (synced) assets of Silo including current and removed bridge assets\\n    /// @return assets array of initialized assets of Silo\\n    function getAssets() external view returns (address[] memory assets);\\n\\n    /// @notice Returns all initialized (synced) assets of Silo including current and removed bridge assets\\n    /// with corresponding state\\n    /// @return assets array of initialized assets of Silo\\n    /// @return assetsStorage array of assets state corresponding to `assets` array\\n    function getAssetsWithState() external view returns (address[] memory assets, AssetStorage[] memory assetsStorage);\\n\\n    /// @notice Check if depositing an asset for given account is possible\\n    /// @dev Depositing an asset that has been already borrowed (and vice versa) is disallowed\\n    /// @param _asset asset we want to deposit\\n    /// @param _depositor depositor address\\n    /// @return true if asset can be deposited by depositor\\n    function depositPossible(address _asset, address _depositor) external view returns (bool);\\n\\n    /// @notice Check if borrowing an asset for given account is possible\\n    /// @dev Borrowing an asset that has been already deposited (and vice versa) is disallowed\\n    /// @param _asset asset we want to deposit\\n    /// @param _borrower borrower address\\n    /// @return true if asset can be borrowed by borrower\\n    function borrowPossible(address _asset, address _borrower) external view returns (bool);\\n\\n    /// @dev Amount of token that is available for borrowing\\n    /// @param _asset asset to get liquidity for\\n    /// @return Silo liquidity\\n    function liquidity(address _asset) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IFlashLiquidationReceiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\n/// @dev when performing Silo flash liquidation, FlashReceiver contract will receive all collaterals\\ninterface IFlashLiquidationReceiver {\\n    /// @dev this method is called when doing Silo flash liquidation\\n    ///         one can NOT assume, that if _seizedCollateral[i] != 0, then _shareAmountsToRepaid[i] must be 0\\n    ///         one should assume, that any combination of amounts is possible\\n    ///         on callback, one must call `Silo.repayFor` because at the end of transaction,\\n    ///         Silo will check if borrower is solvent.\\n    /// @param _user user address, that is liquidated\\n    /// @param _assets array of collateral assets received during user liquidation\\n    ///         this array contains all assets (collateral borrowed) without any order\\n    /// @param _receivedCollaterals array of collateral amounts received during user liquidation\\n    ///         indexes of amounts are related to `_assets`,\\n    /// @param _shareAmountsToRepaid array of amounts to repay for each asset\\n    ///         indexes of amounts are related to `_assets`,\\n    /// @param _flashReceiverData data that are passed from sender that executes liquidation\\n    function siloLiquidationCallback(\\n        address _user,\\n        address[] calldata _assets,\\n        uint256[] calldata _receivedCollaterals,\\n        uint256[] calldata _shareAmountsToRepaid,\\n        bytes memory _flashReceiverData\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IInterestRateModel.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.13;\\n\\ninterface IInterestRateModel {\\n    /* solhint-disable */\\n    struct Config {\\n        // uopt \u2208 (0, 1) \u2013 optimal utilization;\\n        int256 uopt;\\n        // ucrit \u2208 (uopt, 1) \u2013 threshold of large utilization;\\n        int256 ucrit;\\n        // ulow \u2208 (0, uopt) \u2013 threshold of low utilization\\n        int256 ulow;\\n        // ki > 0 \u2013 integrator gain\\n        int256 ki;\\n        // kcrit > 0 \u2013 proportional gain for large utilization\\n        int256 kcrit;\\n        // klow \u2265 0 \u2013 proportional gain for low utilization\\n        int256 klow;\\n        // klin \u2265 0 \u2013 coefficient of the lower linear bound\\n        int256 klin;\\n        // beta \u2265 0 - a scaling factor\\n        int256 beta;\\n        // ri \u2265 0 \u2013 initial value of the integrator\\n        int256 ri;\\n        // Tcrit \u2265 0 - the time during which the utilization exceeds the critical value\\n        int256 Tcrit;\\n    }\\n    /* solhint-enable */\\n\\n    /// @dev Set dedicated config for given asset in a Silo. Config is per asset per Silo so different assets\\n    /// in different Silo can have different configs.\\n    /// It will try to call `_silo.accrueInterest(_asset)` before updating config, but it is not guaranteed,\\n    /// that this call will be successful, if it fail config will be set anyway.\\n    /// @param _silo Silo address for which config should be set\\n    /// @param _asset asset address for which config should be set\\n    function setConfig(address _silo, address _asset, Config calldata _config) external;\\n\\n    /// @dev get compound interest rate and update model storage\\n    /// @param _asset address of an asset in Silo for which interest rate should be calculated\\n    /// @param _blockTimestamp current block timestamp\\n    /// @return rcomp compounded interest rate from last update until now (1e18 == 100%)\\n    function getCompoundInterestRateAndUpdate(\\n        address _asset,\\n        uint256 _blockTimestamp\\n    ) external returns (uint256 rcomp);\\n\\n    /// @dev Get config for given asset in a Silo. If dedicated config is not set, default one will be returned.\\n    /// @param _silo Silo address for which config should be set\\n    /// @param _asset asset address for which config should be set\\n    /// @return Config struct for asset in Silo\\n    function getConfig(address _silo, address _asset) external view returns (Config memory);\\n\\n    /// @dev get compound interest rate\\n    /// @param _silo address of Silo\\n    /// @param _asset address of an asset in Silo for which interest rate should be calculated\\n    /// @param _blockTimestamp current block timestamp\\n    /// @return rcomp compounded interest rate from last update until now (1e18 == 100%)\\n    function getCompoundInterestRate(\\n        address _silo,\\n        address _asset,\\n        uint256 _blockTimestamp\\n    ) external view returns (uint256 rcomp);\\n\\n    /// @dev get current annual interest rate\\n    /// @param _silo address of Silo\\n    /// @param _asset address of an asset in Silo for which interest rate should be calculated\\n    /// @param _blockTimestamp current block timestamp\\n    /// @return rcur current annual interest rate (1e18 == 100%)\\n    function getCurrentInterestRate(\\n        address _silo,\\n        address _asset,\\n        uint256 _blockTimestamp\\n    ) external view returns (uint256 rcur);\\n\\n    /// @notice get the flag to detect rcomp restriction (zero current interest) due to overflow\\n    /// overflow boolean flag to detect rcomp restriction\\n    function overflowDetected(\\n        address _silo,\\n        address _asset,\\n        uint256 _blockTimestamp\\n    ) external view returns (bool overflow);\\n\\n    /// @dev pure function that calculates current annual interest rate\\n    /// @param _c configuration object, InterestRateModel.Config\\n    /// @param _totalBorrowAmount current total borrows for asset\\n    /// @param _totalDeposits current total deposits for asset\\n    /// @param _interestRateTimestamp timestamp of last interest rate update\\n    /// @param _blockTimestamp current block timestamp\\n    /// @return rcur current annual interest rate (1e18 == 100%)\\n    function calculateCurrentInterestRate(\\n        Config memory _c,\\n        uint256 _totalDeposits,\\n        uint256 _totalBorrowAmount,\\n        uint256 _interestRateTimestamp,\\n        uint256 _blockTimestamp\\n    ) external pure returns (uint256 rcur);\\n\\n    /// @dev pure function that calculates interest rate based on raw input data\\n    /// @param _c configuration object, InterestRateModel.Config\\n    /// @param _totalBorrowAmount current total borrows for asset\\n    /// @param _totalDeposits current total deposits for asset\\n    /// @param _interestRateTimestamp timestamp of last interest rate update\\n    /// @param _blockTimestamp current block timestamp\\n    /// @return rcomp compounded interest rate from last update until now (1e18 == 100%)\\n    /// @return ri current integral part of the rate\\n    /// @return Tcrit time during which the utilization exceeds the critical value\\n    /// @return overflow boolean flag to detect rcomp restriction\\n    function calculateCompoundInterestRateWithOverflowDetection(\\n        Config memory _c,\\n        uint256 _totalDeposits,\\n        uint256 _totalBorrowAmount,\\n        uint256 _interestRateTimestamp,\\n        uint256 _blockTimestamp\\n    ) external pure returns (\\n        uint256 rcomp,\\n        int256 ri,\\n        int256 Tcrit, // solhint-disable-line var-name-mixedcase\\n        bool overflow\\n    );\\n\\n    /// @dev pure function that calculates interest rate based on raw input data\\n    /// @param _c configuration object, InterestRateModel.Config\\n    /// @param _totalBorrowAmount current total borrows for asset\\n    /// @param _totalDeposits current total deposits for asset\\n    /// @param _interestRateTimestamp timestamp of last interest rate update\\n    /// @param _blockTimestamp current block timestamp\\n    /// @return rcomp compounded interest rate from last update until now (1e18 == 100%)\\n    /// @return ri current integral part of the rate\\n    /// @return Tcrit time during which the utilization exceeds the critical value\\n    function calculateCompoundInterestRate(\\n        Config memory _c,\\n        uint256 _totalDeposits,\\n        uint256 _totalBorrowAmount,\\n        uint256 _interestRateTimestamp,\\n        uint256 _blockTimestamp\\n    ) external pure returns (\\n        uint256 rcomp,\\n        int256 ri,\\n        int256 Tcrit // solhint-disable-line var-name-mixedcase\\n    );\\n\\n    /// @dev returns decimal points used by model\\n    function DP() external pure returns (uint256); // solhint-disable-line func-name-mixedcase\\n\\n    /// @dev just a helper method to see if address is a InterestRateModel\\n    /// @return always true\\n    function interestRateModelPing() external pure returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/INotificationReceiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.13;\\n\\n/// @title Common interface for Silo Incentive Contract\\ninterface INotificationReceiver {\\n    /// @dev Informs the contract about token transfer\\n    /// @param _token address of the token that was transferred\\n    /// @param _from sender\\n    /// @param _to receiver\\n    /// @param _amount amount that was transferred\\n    function onAfterTransfer(address _token, address _from, address _to, uint256 _amount) external;\\n\\n    /// @dev Sanity check function\\n    /// @return always true\\n    function notificationReceiverPing() external pure returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPriceProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.7.6 <0.9.0;\\n\\n/// @title Common interface for Silo Price Providers\\ninterface IPriceProvider {\\n    /// @notice Returns \\\"Time-Weighted Average Price\\\" for an asset. Calculates TWAP price for quote/asset.\\n    /// It unifies all tokens decimal to 18, examples:\\n    /// - if asses == quote it returns 1e18\\n    /// - if asset is USDC and quote is ETH and ETH costs ~$3300 then it returns ~0.0003e18 WETH per 1 USDC\\n    /// @param _asset address of an asset for which to read price\\n    /// @return price of asses with 18 decimals, throws when pool is not ready yet to provide price\\n    function getPrice(address _asset) external view returns (uint256 price);\\n\\n    /// @dev Informs if PriceProvider is setup for asset. It does not means PriceProvider can provide price right away.\\n    /// Some providers implementations need time to \\\"build\\\" buffer for TWAP price,\\n    /// so price may not be available yet but this method will return true.\\n    /// @param _asset asset in question\\n    /// @return TRUE if asset has been setup, otherwise false\\n    function assetSupported(address _asset) external view returns (bool);\\n\\n    /// @notice Gets token address in which prices are quoted\\n    /// @return quoteToken address\\n    function quoteToken() external view returns (address);\\n\\n    /// @notice Helper method that allows easily detects, if contract is PriceProvider\\n    /// @dev this can save us from simple human errors, in case we use invalid address\\n    /// but this should NOT be treated as security check\\n    /// @return always true\\n    function priceProviderPing() external pure returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPriceProvidersRepository.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.7.6 <0.9.0;\\n\\nimport \\\"./IPriceProvider.sol\\\";\\n\\ninterface IPriceProvidersRepository {\\n    /// @notice Emitted when price provider is added\\n    /// @param newPriceProvider new price provider address\\n    event NewPriceProvider(IPriceProvider indexed newPriceProvider);\\n\\n    /// @notice Emitted when price provider is removed\\n    /// @param priceProvider removed price provider address\\n    event PriceProviderRemoved(IPriceProvider indexed priceProvider);\\n\\n    /// @notice Emitted when asset is assigned to price provider\\n    /// @param asset assigned asset   address\\n    /// @param priceProvider price provider address\\n    event PriceProviderForAsset(address indexed asset, IPriceProvider indexed priceProvider);\\n\\n    /// @notice Register new price provider\\n    /// @param _priceProvider address of price provider\\n    function addPriceProvider(IPriceProvider _priceProvider) external;\\n\\n    /// @notice Unregister price provider\\n    /// @param _priceProvider address of price provider to be removed\\n    function removePriceProvider(IPriceProvider _priceProvider) external;\\n\\n    /// @notice Sets price provider for asset\\n    /// @dev Request for asset price is forwarded to the price provider assigned to that asset\\n    /// @param _asset address of an asset for which price provider will be used\\n    /// @param _priceProvider address of price provider\\n    function setPriceProviderForAsset(address _asset, IPriceProvider _priceProvider) external;\\n\\n    /// @notice Returns \\\"Time-Weighted Average Price\\\" for an asset\\n    /// @param _asset address of an asset for which to read price\\n    /// @return price TWAP price of a token with 18 decimals\\n    function getPrice(address _asset) external view returns (uint256 price);\\n\\n    /// @notice Gets price provider assigned to an asset\\n    /// @param _asset address of an asset for which to get price provider\\n    /// @return priceProvider address of price provider\\n    function priceProviders(address _asset) external view returns (IPriceProvider priceProvider);\\n\\n    /// @notice Gets token address in which prices are quoted\\n    /// @return quoteToken address\\n    function quoteToken() external view returns (address);\\n\\n    /// @notice Gets manager role address\\n    /// @return manager role address\\n    function manager() external view returns (address);\\n\\n    /// @notice Checks if providers are available for an asset\\n    /// @param _asset asset address to check\\n    /// @return returns TRUE if price feed is ready, otherwise false\\n    function providersReadyForAsset(address _asset) external view returns (bool);\\n\\n    /// @notice Returns true if address is a registered price provider\\n    /// @param _provider address of price provider to be removed\\n    /// @return true if address is a registered price provider, otherwise false\\n    function isPriceProvider(IPriceProvider _provider) external view returns (bool);\\n\\n    /// @notice Gets number of price providers registered\\n    /// @return number of price providers registered\\n    function providersCount() external view returns (uint256);\\n\\n    /// @notice Gets an array of price providers\\n    /// @return array of price providers\\n    function providerList() external view returns (address[] memory);\\n\\n    /// @notice Sanity check function\\n    /// @return returns always TRUE\\n    function priceProvidersRepositoryPing() external pure returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPriceProviderV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.7.6 <0.9.0;\\n\\nimport \\\"./IPriceProvider.sol\\\";\\n\\n/// @title Common interface V2 for Silo Price Providers\\ninterface IPriceProviderV2 is IPriceProvider {\\n    /// @dev for liquidation purposes and for compatibility with naming convention we already using in LiquidationHelper\\n    /// we have this method to return on-chain provider that can be useful for liquidation\\n    function getFallbackProvider(address _asset) external view returns (IPriceProvider);\\n\\n    /// @dev this is info method for LiquidationHelper\\n    /// @return bool TRUE if provider is off-chain, means it is not a dex\\n    function offChainProvider() external pure returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IShareToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.13;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\n\\nimport \\\"./INotificationReceiver.sol\\\";\\n\\ninterface IShareToken is IERC20Metadata {\\n    /// @notice Emitted every time receiver is notified about token transfer\\n    /// @param notificationReceiver receiver address\\n    /// @param success false if TX reverted on `notificationReceiver` side, otherwise true\\n    event NotificationSent(\\n        INotificationReceiver indexed notificationReceiver,\\n        bool success\\n    );\\n\\n    /// @notice Mint method for Silo to create debt position\\n    /// @param _account wallet for which to mint token\\n    /// @param _amount amount of token to be minted\\n    function mint(address _account, uint256 _amount) external;\\n\\n    /// @notice Burn method for Silo to close debt position\\n    /// @param _account wallet for which to burn token\\n    /// @param _amount amount of token to be burned\\n    function burn(address _account, uint256 _amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ISilo.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.13;\\n\\nimport \\\"./IBaseSilo.sol\\\";\\n\\ninterface ISilo is IBaseSilo {\\n    /// @notice Deposit `_amount` of `_asset` tokens from `msg.sender` to the Silo\\n    /// @param _asset The address of the token to deposit\\n    /// @param _amount The amount of the token to deposit\\n    /// @param _collateralOnly True if depositing collateral only\\n    /// @return collateralAmount deposited amount\\n    /// @return collateralShare user collateral shares based on deposited amount\\n    function deposit(address _asset, uint256 _amount, bool _collateralOnly)\\n        external\\n        returns (uint256 collateralAmount, uint256 collateralShare);\\n\\n    /// @notice Router function to deposit `_amount` of `_asset` tokens to the Silo for the `_depositor`\\n    /// @param _asset The address of the token to deposit\\n    /// @param _depositor The address of the recipient of collateral tokens\\n    /// @param _amount The amount of the token to deposit\\n    /// @param _collateralOnly True if depositing collateral only\\n    /// @return collateralAmount deposited amount\\n    /// @return collateralShare `_depositor` collateral shares based on deposited amount\\n    function depositFor(address _asset, address _depositor, uint256 _amount, bool _collateralOnly)\\n        external\\n        returns (uint256 collateralAmount, uint256 collateralShare);\\n\\n    /// @notice Withdraw `_amount` of `_asset` tokens from the Silo to `msg.sender`\\n    /// @param _asset The address of the token to withdraw\\n    /// @param _amount The amount of the token to withdraw\\n    /// @param _collateralOnly True if withdrawing collateral only deposit\\n    /// @return withdrawnAmount withdrawn amount that was transferred to user\\n    /// @return withdrawnShare burned share based on `withdrawnAmount`\\n    function withdraw(address _asset, uint256 _amount, bool _collateralOnly)\\n        external\\n        returns (uint256 withdrawnAmount, uint256 withdrawnShare);\\n\\n    /// @notice Router function to withdraw `_amount` of `_asset` tokens from the Silo for the `_depositor`\\n    /// @param _asset The address of the token to withdraw\\n    /// @param _depositor The address that originally deposited the collateral tokens being withdrawn,\\n    /// it should be the one initiating the withdrawal through the router\\n    /// @param _receiver The address that will receive the withdrawn tokens\\n    /// @param _amount The amount of the token to withdraw\\n    /// @param _collateralOnly True if withdrawing collateral only deposit\\n    /// @return withdrawnAmount withdrawn amount that was transferred to `_receiver`\\n    /// @return withdrawnShare burned share based on `withdrawnAmount`\\n    function withdrawFor(\\n        address _asset,\\n        address _depositor,\\n        address _receiver,\\n        uint256 _amount,\\n        bool _collateralOnly\\n    ) external returns (uint256 withdrawnAmount, uint256 withdrawnShare);\\n\\n    /// @notice Borrow `_amount` of `_asset` tokens from the Silo to `msg.sender`\\n    /// @param _asset The address of the token to borrow\\n    /// @param _amount The amount of the token to borrow\\n    /// @return debtAmount borrowed amount\\n    /// @return debtShare user debt share based on borrowed amount\\n    function borrow(address _asset, uint256 _amount) external returns (uint256 debtAmount, uint256 debtShare);\\n\\n    /// @notice Router function to borrow `_amount` of `_asset` tokens from the Silo for the `_receiver`\\n    /// @param _asset The address of the token to borrow\\n    /// @param _borrower The address that will take the loan,\\n    /// it should be the one initiating the borrowing through the router\\n    /// @param _receiver The address of the asset receiver\\n    /// @param _amount The amount of the token to borrow\\n    /// @return debtAmount borrowed amount\\n    /// @return debtShare `_receiver` debt share based on borrowed amount\\n    function borrowFor(address _asset, address _borrower, address _receiver, uint256 _amount)\\n        external\\n        returns (uint256 debtAmount, uint256 debtShare);\\n\\n    /// @notice Repay `_amount` of `_asset` tokens from `msg.sender` to the Silo\\n    /// @param _asset The address of the token to repay\\n    /// @param _amount amount of asset to repay, includes interests\\n    /// @return repaidAmount amount repaid\\n    /// @return burnedShare burned debt share\\n    function repay(address _asset, uint256 _amount) external returns (uint256 repaidAmount, uint256 burnedShare);\\n\\n    /// @notice Allows to repay in behalf of borrower to execute liquidation\\n    /// @param _asset The address of the token to repay\\n    /// @param _borrower The address of the user to have debt tokens burned\\n    /// @param _amount amount of asset to repay, includes interests\\n    /// @return repaidAmount amount repaid\\n    /// @return burnedShare burned debt share\\n    function repayFor(address _asset, address _borrower, uint256 _amount)\\n        external\\n        returns (uint256 repaidAmount, uint256 burnedShare);\\n\\n    /// @dev harvest protocol fees from an array of assets\\n    /// @return harvestedAmounts amount harvested during tx execution for each of silo asset\\n    function harvestProtocolFees() external returns (uint256[] memory harvestedAmounts);\\n\\n    /// @notice Function to update interests for `_asset` token since the last saved state\\n    /// @param _asset The address of the token to be updated\\n    /// @return interest accrued interest\\n    function accrueInterest(address _asset) external returns (uint256 interest);\\n\\n    /// @notice this methods does not requires to have tokens in order to liquidate user\\n    /// @dev during liquidation process, msg.sender will be notified once all collateral will be send to him\\n    /// msg.sender needs to be `IFlashLiquidationReceiver`\\n    /// @param _users array of users to liquidate\\n    /// @param _flashReceiverData this data will be forward to msg.sender on notification\\n    /// @return assets array of all processed assets (collateral + debt, including removed)\\n    /// @return receivedCollaterals receivedCollaterals[userId][assetId] => amount\\n    /// amounts of collaterals send to `_flashReceiver`\\n    /// @return shareAmountsToRepaid shareAmountsToRepaid[userId][assetId] => amount\\n    /// required amounts of debt to be repaid\\n    function flashLiquidate(address[] memory _users, bytes memory _flashReceiverData)\\n        external\\n        returns (\\n            address[] memory assets,\\n            uint256[][] memory receivedCollaterals,\\n            uint256[][] memory shareAmountsToRepaid\\n        );\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ISiloFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.13;\\n\\ninterface ISiloFactory {\\n    /// @notice Emitted when Silo is deployed\\n    /// @param silo address of deployed Silo\\n    /// @param asset address of asset for which Silo was deployed\\n    /// @param version version of silo implementation\\n    event NewSiloCreated(address indexed silo, address indexed asset, uint128 version);\\n\\n    /// @notice Must be called by repository on constructor\\n    /// @param _siloRepository the SiloRepository to set\\n    function initRepository(address _siloRepository) external;\\n\\n    /// @notice Deploys Silo\\n    /// @param _siloAsset unique asset for which Silo is deployed\\n    /// @param _version version of silo implementation\\n    /// @param _data (optional) data that may be needed during silo creation\\n    /// @return silo deployed Silo address\\n    function createSilo(address _siloAsset, uint128 _version, bytes memory _data) external returns (address silo);\\n\\n    /// @dev just a helper method to see if address is a factory\\n    function siloFactoryPing() external pure returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ISiloRepository.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.13;\\n\\nimport \\\"./ISiloFactory.sol\\\";\\nimport \\\"./ITokensFactory.sol\\\";\\nimport \\\"./IPriceProvidersRepository.sol\\\";\\nimport \\\"./INotificationReceiver.sol\\\";\\nimport \\\"./IInterestRateModel.sol\\\";\\n\\ninterface ISiloRepository {\\n    /// @dev protocol fees in precision points (Solvency._PRECISION_DECIMALS), we do allow for fee == 0\\n    struct Fees {\\n        /// @dev One time protocol fee for opening a borrow position in precision points (Solvency._PRECISION_DECIMALS)\\n        uint64 entryFee;\\n        /// @dev Protocol revenue share in interest paid in precision points (Solvency._PRECISION_DECIMALS)\\n        uint64 protocolShareFee;\\n        /// @dev Protocol share in liquidation profit in precision points (Solvency._PRECISION_DECIMALS).\\n        /// It's calculated from total collateral amount to be transferred to liquidator.\\n        uint64 protocolLiquidationFee;\\n    }\\n\\n    struct SiloVersion {\\n        /// @dev Default version of Silo. If set to 0, it means it is not set. By default it is set to 1\\n        uint128 byDefault;\\n\\n        /// @dev Latest added version of Silo. If set to 0, it means it is not set. By default it is set to 1\\n        uint128 latest;\\n    }\\n\\n    /// @dev AssetConfig struct represents configurable parameters for each Silo\\n    struct AssetConfig {\\n        /// @dev Loan-to-Value ratio represents the maximum borrowing power of a specific collateral.\\n        ///      For example, if the collateral asset has an LTV of 75%, the user can borrow up to 0.75 worth\\n        ///      of quote token in the principal currency for every quote token worth of collateral.\\n        ///      value uses 18 decimals eg. 100% == 1e18\\n        ///      max valid value is 1e18 so it needs storage of 60 bits\\n        uint64 maxLoanToValue;\\n\\n        /// @dev Liquidation Threshold represents the threshold at which a borrow position will be considered\\n        ///      undercollateralized and subject to liquidation for each collateral. For example,\\n        ///      if a collateral has a liquidation threshold of 80%, it means that the loan will be\\n        ///      liquidated when the borrowAmount value is worth 80% of the collateral value.\\n        ///      value uses 18 decimals eg. 100% == 1e18\\n        uint64 liquidationThreshold;\\n\\n        /// @dev interest rate model address\\n        IInterestRateModel interestRateModel;\\n    }\\n\\n    event NewDefaultMaximumLTV(uint64 defaultMaximumLTV);\\n\\n    event NewDefaultLiquidationThreshold(uint64 defaultLiquidationThreshold);\\n\\n    /// @notice Emitted on new Silo creation\\n    /// @param silo deployed Silo address\\n    /// @param asset unique asset for deployed Silo\\n    /// @param siloVersion version of deployed Silo\\n    event NewSilo(address indexed silo, address indexed asset, uint128 siloVersion);\\n\\n    /// @notice Emitted when new Silo (or existing one) becomes a bridge pool (pool with only bridge tokens).\\n    /// @param pool address of the bridge pool, It can be zero address when bridge asset is removed and pool no longer\\n    /// is treated as bridge pool\\n    event BridgePool(address indexed pool);\\n\\n    /// @notice Emitted on new bridge asset\\n    /// @param newBridgeAsset address of added bridge asset\\n    event BridgeAssetAdded(address indexed newBridgeAsset);\\n\\n    /// @notice Emitted on removed bridge asset\\n    /// @param bridgeAssetRemoved address of removed bridge asset\\n    event BridgeAssetRemoved(address indexed bridgeAssetRemoved);\\n\\n    /// @notice Emitted when default interest rate model is changed\\n    /// @param newModel address of new interest rate model\\n    event InterestRateModel(IInterestRateModel indexed newModel);\\n\\n    /// @notice Emitted on price provider repository address update\\n    /// @param newProvider address of new oracle repository\\n    event PriceProvidersRepositoryUpdate(\\n        IPriceProvidersRepository indexed newProvider\\n    );\\n\\n    /// @notice Emitted on token factory address update\\n    /// @param newTokensFactory address of new token factory\\n    event TokensFactoryUpdate(address indexed newTokensFactory);\\n\\n    /// @notice Emitted on router address update\\n    /// @param newRouter address of new router\\n    event RouterUpdate(address indexed newRouter);\\n\\n    /// @notice Emitted on INotificationReceiver address update\\n    /// @param newIncentiveContract address of new INotificationReceiver\\n    event NotificationReceiverUpdate(INotificationReceiver indexed newIncentiveContract);\\n\\n    /// @notice Emitted when new Silo version is registered\\n    /// @param factory factory address that deploys registered Silo version\\n    /// @param siloLatestVersion Silo version of registered Silo\\n    /// @param siloDefaultVersion current default Silo version\\n    event RegisterSiloVersion(address indexed factory, uint128 siloLatestVersion, uint128 siloDefaultVersion);\\n\\n    /// @notice Emitted when Silo version is unregistered\\n    /// @param factory factory address that deploys unregistered Silo version\\n    /// @param siloVersion version that was unregistered\\n    event UnregisterSiloVersion(address indexed factory, uint128 siloVersion);\\n\\n    /// @notice Emitted when default Silo version is updated\\n    /// @param newDefaultVersion new default version\\n    event SiloDefaultVersion(uint128 newDefaultVersion);\\n\\n    /// @notice Emitted when default fee is updated\\n    /// @param newEntryFee new entry fee\\n    /// @param newProtocolShareFee new protocol share fee\\n    /// @param newProtocolLiquidationFee new protocol liquidation fee\\n    event FeeUpdate(\\n        uint64 newEntryFee,\\n        uint64 newProtocolShareFee,\\n        uint64 newProtocolLiquidationFee\\n    );\\n\\n    /// @notice Emitted when asset config is updated for a silo\\n    /// @param silo silo for which asset config is being set\\n    /// @param asset asset for which asset config is being set\\n    /// @param assetConfig new asset config\\n    event AssetConfigUpdate(address indexed silo, address indexed asset, AssetConfig assetConfig);\\n\\n    /// @notice Emitted when silo (silo factory) version is set for asset\\n    /// @param asset asset for which asset config is being set\\n    /// @param version Silo version\\n    event VersionForAsset(address indexed asset, uint128 version);\\n\\n    /// @param _siloAsset silo asset\\n    /// @return version of Silo that is assigned for provided asset, if not assigned it returns zero (default)\\n    function getVersionForAsset(address _siloAsset) external returns (uint128);\\n\\n    /// @notice setter for `getVersionForAsset` mapping\\n    /// @param _siloAsset silo asset\\n    /// @param _version version of Silo that will be assigned for `_siloAsset`, zero (default) is acceptable\\n    function setVersionForAsset(address _siloAsset, uint128 _version) external;\\n\\n    /// @notice use this method only when off-chain verification is OFF\\n    /// @dev Silo does NOT support rebase and deflationary tokens\\n    /// @param _siloAsset silo asset\\n    /// @param _siloData (optional) data that may be needed during silo creation\\n    /// @return createdSilo address of created silo\\n    function newSilo(address _siloAsset, bytes memory _siloData) external returns (address createdSilo);\\n\\n    /// @notice use this method to deploy new version of Silo for an asset that already has Silo deployed.\\n    /// Only owner (DAO) can replace.\\n    /// @dev Silo does NOT support rebase and deflationary tokens\\n    /// @param _siloAsset silo asset\\n    /// @param _siloVersion version of silo implementation. Use 0 for default version which is fine\\n    /// for 99% of cases.\\n    /// @param _siloData (optional) data that may be needed during silo creation\\n    /// @return createdSilo address of created silo\\n    function replaceSilo(\\n        address _siloAsset,\\n        uint128 _siloVersion,\\n        bytes memory _siloData\\n    ) external returns (address createdSilo);\\n\\n    /// @notice Set factory contract for debt and collateral tokens for each Silo asset\\n    /// @dev Callable only by owner\\n    /// @param _tokensFactory address of TokensFactory contract that deploys debt and collateral tokens\\n    function setTokensFactory(address _tokensFactory) external;\\n\\n    /// @notice Set default fees\\n    /// @dev Callable only by owner\\n    /// @param _fees:\\n    /// - _entryFee one time protocol fee for opening a borrow position in precision points\\n    /// (Solvency._PRECISION_DECIMALS)\\n    /// - _protocolShareFee protocol revenue share in interest paid in precision points\\n    /// (Solvency._PRECISION_DECIMALS)\\n    /// - _protocolLiquidationFee protocol share in liquidation profit in precision points\\n    /// (Solvency._PRECISION_DECIMALS). It's calculated from total collateral amount to be transferred\\n    /// to liquidator.\\n    function setFees(Fees calldata _fees) external;\\n\\n    /// @notice Set configuration for given asset in given Silo\\n    /// @dev Callable only by owner\\n    /// @param _silo Silo address for which config applies\\n    /// @param _asset asset address for which config applies\\n    /// @param _assetConfig:\\n    ///    - _maxLoanToValue maximum Loan-to-Value, for details see `Repository.AssetConfig.maxLoanToValue`\\n    ///    - _liquidationThreshold liquidation threshold, for details see `Repository.AssetConfig.maxLoanToValue`\\n    ///    - _interestRateModel interest rate model address, for details see `Repository.AssetConfig.interestRateModel`\\n    function setAssetConfig(\\n        address _silo,\\n        address _asset,\\n        AssetConfig calldata _assetConfig\\n    ) external;\\n\\n    /// @notice Set default interest rate model\\n    /// @dev Callable only by owner\\n    /// @param _defaultInterestRateModel default interest rate model\\n    function setDefaultInterestRateModel(IInterestRateModel _defaultInterestRateModel) external;\\n\\n    /// @notice Set default maximum LTV\\n    /// @dev Callable only by owner\\n    /// @param _defaultMaxLTV default maximum LTV in precision points (Solvency._PRECISION_DECIMALS)\\n    function setDefaultMaximumLTV(uint64 _defaultMaxLTV) external;\\n\\n    /// @notice Set default liquidation threshold\\n    /// @dev Callable only by owner\\n    /// @param _defaultLiquidationThreshold default liquidation threshold in precision points\\n    /// (Solvency._PRECISION_DECIMALS)\\n    function setDefaultLiquidationThreshold(uint64 _defaultLiquidationThreshold) external;\\n\\n    /// @notice Set price provider repository\\n    /// @dev Callable only by owner\\n    /// @param _repository price provider repository address\\n    function setPriceProvidersRepository(IPriceProvidersRepository _repository) external;\\n\\n    /// @notice Set router contract\\n    /// @dev Callable only by owner\\n    /// @param _router router address\\n    function setRouter(address _router) external;\\n\\n    /// @notice Set NotificationReceiver contract\\n    /// @dev Callable only by owner\\n    /// @param _silo silo address for which to set `_notificationReceiver`\\n    /// @param _notificationReceiver NotificationReceiver address\\n    function setNotificationReceiver(address _silo, INotificationReceiver _notificationReceiver) external;\\n\\n    /// @notice Adds new bridge asset\\n    /// @dev New bridge asset must be unique. Duplicates in bridge assets are not allowed. It's possible to add\\n    /// bridge asset that has been removed in the past. Note that all Silos must be synced manually. Callable\\n    /// only by owner.\\n    /// @param _newBridgeAsset bridge asset address\\n    function addBridgeAsset(address _newBridgeAsset) external;\\n\\n    /// @notice Removes bridge asset\\n    /// @dev Note that all Silos must be synced manually. Callable only by owner.\\n    /// @param _bridgeAssetToRemove bridge asset address to be removed\\n    function removeBridgeAsset(address _bridgeAssetToRemove) external;\\n\\n    /// @notice Registers new Silo version\\n    /// @dev User can choose which Silo version he wants to deploy. It's possible to have multiple versions of Silo.\\n    /// Callable only by owner.\\n    /// @param _factory factory contract that deploys new version of Silo\\n    /// @param _isDefault true if this version should be used as default\\n    function registerSiloVersion(ISiloFactory _factory, bool _isDefault) external;\\n\\n    /// @notice Unregisters Silo version\\n    /// @dev Callable only by owner.\\n    /// @param _siloVersion Silo version to be unregistered\\n    function unregisterSiloVersion(uint128 _siloVersion) external;\\n\\n    /// @notice Sets default Silo version\\n    /// @dev Callable only by owner.\\n    /// @param _defaultVersion Silo version to be set as default\\n    function setDefaultSiloVersion(uint128 _defaultVersion) external;\\n\\n    /// @notice Check if contract address is a Silo deployment\\n    /// @param _silo address of expected Silo\\n    /// @return true if address is Silo deployment, otherwise false\\n    function isSilo(address _silo) external view returns (bool);\\n\\n    /// @notice Get Silo address of asset\\n    /// @param _asset address of asset\\n    /// @return address of corresponding Silo deployment\\n    function getSilo(address _asset) external view returns (address);\\n\\n    /// @notice Get Silo Factory for given version\\n    /// @param _siloVersion version of Silo implementation\\n    /// @return ISiloFactory contract that deploys Silos of given version\\n    function siloFactory(uint256 _siloVersion) external view returns (ISiloFactory);\\n\\n    /// @notice Get debt and collateral Token Factory\\n    /// @return ITokensFactory contract that deploys debt and collateral tokens\\n    function tokensFactory() external view returns (ITokensFactory);\\n\\n    /// @notice Get Router contract\\n    /// @return address of router contract\\n    function router() external view returns (address);\\n\\n    /// @notice Get current bridge assets\\n    /// @dev Keep in mind that not all Silos may be synced with current bridge assets so it's possible that some\\n    /// assets in that list are not part of given Silo.\\n    /// @return address array of bridge assets\\n    function getBridgeAssets() external view returns (address[] memory);\\n\\n    /// @notice Get removed bridge assets\\n    /// @dev Keep in mind that not all Silos may be synced with bridge assets so it's possible that some\\n    /// assets in that list are still part of given Silo.\\n    /// @return address array of bridge assets\\n    function getRemovedBridgeAssets() external view returns (address[] memory);\\n\\n    /// @notice Get maximum LTV for asset in given Silo\\n    /// @dev If dedicated config is not set, method returns default config\\n    /// @param _silo address of Silo\\n    /// @param _asset address of an asset\\n    /// @return maximum LTV in precision points (Solvency._PRECISION_DECIMALS)\\n    function getMaximumLTV(address _silo, address _asset) external view returns (uint256);\\n\\n    /// @notice Get Interest Rate Model address for asset in given Silo\\n    /// @dev If dedicated config is not set, method returns default config\\n    /// @param _silo address of Silo\\n    /// @param _asset address of an asset\\n    /// @return address of interest rate model\\n    function getInterestRateModel(address _silo, address _asset) external view returns (IInterestRateModel);\\n\\n    /// @notice Get liquidation threshold for asset in given Silo\\n    /// @dev If dedicated config is not set, method returns default config\\n    /// @param _silo address of Silo\\n    /// @param _asset address of an asset\\n    /// @return liquidation threshold in precision points (Solvency._PRECISION_DECIMALS)\\n    function getLiquidationThreshold(address _silo, address _asset) external view returns (uint256);\\n\\n    /// @notice Get incentive contract address. Incentive contracts are responsible for distributing rewards\\n    /// to debt and/or collateral token holders of given Silo\\n    /// @param _silo address of Silo\\n    /// @return incentive contract address\\n    function getNotificationReceiver(address _silo) external view returns (INotificationReceiver);\\n\\n    /// @notice Get owner role address of Repository\\n    /// @return owner role address\\n    function owner() external view returns (address);\\n\\n    /// @notice get PriceProvidersRepository contract that manages price providers implementations\\n    /// @return IPriceProvidersRepository address\\n    function priceProvidersRepository() external view returns (IPriceProvidersRepository);\\n\\n    /// @dev Get protocol fee for opening a borrow position\\n    /// @return fee in precision points (Solvency._PRECISION_DECIMALS == 100%)\\n    function entryFee() external view returns (uint256);\\n\\n    /// @dev Get protocol share fee\\n    /// @return protocol share fee in precision points (Solvency._PRECISION_DECIMALS == 100%)\\n    function protocolShareFee() external view returns (uint256);\\n\\n    /// @dev Get protocol liquidation fee\\n    /// @return protocol liquidation fee in precision points (Solvency._PRECISION_DECIMALS == 100%)\\n    function protocolLiquidationFee() external view returns (uint256);\\n\\n    /// @dev Checks all conditions for new silo creation and throws when not possible to create\\n    /// @param _asset address of asset for which you want to create silo\\n    /// @param _assetIsABridge bool TRUE when `_asset` is bridge asset, FALSE when it is not\\n    function ensureCanCreateSiloFor(address _asset, bool _assetIsABridge) external view;\\n\\n    function siloRepositoryPing() external pure returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ISwapper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9.0;\\n\\ninterface ISwapper {\\n    /// @dev swaps `_amountIn` of `_tokenIn` for `_tokenOut`. It might require approvals.\\n    /// @return amountOut amount of _tokenOut received\\n    function swapAmountIn(\\n        address _tokenIn,\\n        address _tokenOut,\\n        uint256 _amountIn,\\n        address _priceProvider,\\n        address _siloAsset\\n    ) external returns (uint256 amountOut);\\n\\n    /// @dev swaps `_tokenIn` for `_amountOut` of  `_tokenOut`. It might require approvals\\n    /// @return amountIn amount of _tokenIn spend\\n    function swapAmountOut(\\n        address _tokenIn,\\n        address _tokenOut,\\n        uint256 _amountOut,\\n        address _priceProvider,\\n        address _siloAsset\\n    ) external returns (uint256 amountIn);\\n\\n    /// @return address that needs to have approval to spend tokens to execute a swap\\n    function spenderToApprove() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ITokensFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.13;\\n\\nimport \\\"./IShareToken.sol\\\";\\n\\ninterface ITokensFactory {\\n    /// @notice Emitted when collateral token is deployed\\n    /// @param token address of deployed collateral token\\n    event NewShareCollateralTokenCreated(address indexed token);\\n\\n    /// @notice Emitted when collateral token is deployed\\n    /// @param token address of deployed debt token\\n    event NewShareDebtTokenCreated(address indexed token);\\n\\n    ///@notice Must be called by repository on constructor\\n    /// @param _siloRepository the SiloRepository to set\\n    function initRepository(address _siloRepository) external;\\n\\n    /// @notice Deploys collateral token\\n    /// @param _name name of the token\\n    /// @param _symbol symbol of the token\\n    /// @param _asset underlying asset for which token is deployed\\n    /// @return address of deployed collateral share token\\n    function createShareCollateralToken(\\n        string memory _name,\\n        string memory _symbol,\\n        address _asset\\n    ) external returns (IShareToken);\\n\\n    /// @notice Deploys debt token\\n    /// @param _name name of the token\\n    /// @param _symbol symbol of the token\\n    /// @param _asset underlying asset for which token is deployed\\n    /// @return address of deployed debt share token\\n    function createShareDebtToken(\\n        string memory _name,\\n        string memory _symbol,\\n        address _asset\\n    )\\n        external\\n        returns (IShareToken);\\n\\n    /// @dev just a helper method to see if address is a factory\\n    /// @return always true\\n    function tokensFactoryPing() external pure returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IWrappedNativeToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.13;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IWrappedNativeToken is IERC20 {\\n    function deposit() external payable;\\n    function withdraw(uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/lib/EasyMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.13;\\n\\nlibrary EasyMath {\\n    error ZeroAssets();\\n    error ZeroShares();\\n\\n    function toShare(uint256 amount, uint256 totalAmount, uint256 totalShares) internal pure returns (uint256) {\\n        if (totalShares == 0 || totalAmount == 0) {\\n            return amount;\\n        }\\n\\n        uint256 result = amount * totalShares / totalAmount;\\n\\n        // Prevent rounding error\\n        if (result == 0 && amount != 0) {\\n            revert ZeroShares();\\n        }\\n\\n        return result;\\n    }\\n\\n    function toShareRoundUp(uint256 amount, uint256 totalAmount, uint256 totalShares) internal pure returns (uint256) {\\n        if (totalShares == 0 || totalAmount == 0) {\\n            return amount;\\n        }\\n\\n        uint256 numerator = amount * totalShares;\\n        uint256 result = numerator / totalAmount;\\n        \\n        // Round up\\n        if (numerator % totalAmount != 0) {\\n            result += 1;\\n        }\\n\\n        return result;\\n    }\\n\\n    function toAmount(uint256 share, uint256 totalAmount, uint256 totalShares) internal pure returns (uint256) {\\n        if (totalShares == 0 || totalAmount == 0) {\\n            return 0;\\n        }\\n\\n        uint256 result = share * totalAmount / totalShares;\\n\\n        // Prevent rounding error\\n        if (result == 0 && share != 0) {\\n            revert ZeroAssets();\\n        }\\n\\n        return result;\\n    }\\n\\n    function toAmountRoundUp(uint256 share, uint256 totalAmount, uint256 totalShares) internal pure returns (uint256) {\\n        if (totalShares == 0 || totalAmount == 0) {\\n            return 0;\\n        }\\n\\n        uint256 numerator = share * totalAmount;\\n        uint256 result = numerator / totalShares;\\n        \\n        // Round up\\n        if (numerator % totalShares != 0) {\\n            result += 1;\\n        }\\n\\n        return result;\\n    }\\n\\n    function toValue(uint256 _assetAmount, uint256 _assetPrice, uint256 _assetDecimals)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return _assetAmount * _assetPrice / 10 ** _assetDecimals;\\n    }\\n\\n    function sum(uint256[] memory _numbers) internal pure returns (uint256 s) {\\n        for(uint256 i; i < _numbers.length; i++) {\\n            s += _numbers[i];\\n        }\\n    }\\n\\n    /// @notice Calculates fraction between borrowed and deposited amount of tokens denominated in percentage\\n    /// @dev It assumes `_dp` = 100%.\\n    /// @param _dp decimal points used by model\\n    /// @param _totalDeposits current total deposits for assets\\n    /// @param _totalBorrowAmount current total borrows for assets\\n    /// @return utilization value\\n    function calculateUtilization(uint256 _dp, uint256 _totalDeposits, uint256 _totalBorrowAmount)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        if (_totalDeposits == 0 || _totalBorrowAmount == 0) return 0;\\n\\n        return _totalBorrowAmount * _dp / _totalDeposits;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/EasyMathV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.13;\\n\\n/// @dev EasyMathV2 is optimised version of EasyMath, many places was `unchecked` for lower gas cost.\\n/// There is also fixed version of `calculateUtilization()` method.\\nlibrary EasyMathV2 {\\n    error ZeroAssets();\\n    error ZeroShares();\\n\\n    function toShare(uint256 amount, uint256 totalAmount, uint256 totalShares)\\n        internal\\n        pure\\n        returns (uint256 result)\\n    {\\n        if (totalShares == 0 || totalAmount == 0) {\\n            return amount;\\n        }\\n\\n        result = amount * totalShares;\\n        // totalAmount is never 0 based on above check, so we can uncheck\\n        unchecked { result /= totalAmount; }\\n\\n        // Prevent rounding error\\n        if (result == 0 && amount != 0) {\\n            revert ZeroShares();\\n        }\\n    }\\n\\n    function toShareRoundUp(uint256 amount, uint256 totalAmount, uint256 totalShares)\\n        internal\\n        pure\\n        returns (uint256 result)\\n    {\\n        if (totalShares == 0 || totalAmount == 0) {\\n            return amount;\\n        }\\n\\n        uint256 numerator = amount * totalShares;\\n        // totalAmount is not 0, so it is safe to uncheck\\n        unchecked { result = numerator / totalAmount; }\\n        \\n        // Round up\\n        if (numerator % totalAmount != 0) {\\n            unchecked { result += 1; }\\n        }\\n    }\\n\\n    function toAmount(uint256 share, uint256 totalAmount, uint256 totalShares)\\n        internal\\n        pure\\n        returns (uint256 result)\\n    {\\n        if (totalShares == 0 || totalAmount == 0) {\\n            return 0;\\n        }\\n\\n        result = share * totalAmount;\\n        // totalShares are not 0, so we can uncheck\\n        unchecked { result /= totalShares; }\\n\\n        // Prevent rounding error\\n        if (result == 0 && share != 0) {\\n            revert ZeroAssets();\\n        }\\n    }\\n\\n    function toAmountRoundUp(uint256 share, uint256 totalAmount, uint256 totalShares)\\n        internal\\n        pure\\n        returns (uint256 result)\\n    {\\n        if (totalShares == 0 || totalAmount == 0) {\\n            return 0;\\n        }\\n\\n        uint256 numerator = share * totalAmount;\\n        // totalShares are not 0, based on above check, so we can uncheck\\n        unchecked { result = numerator / totalShares; }\\n        \\n        // Round up\\n        if (numerator % totalShares != 0) {\\n            unchecked { result += 1; }\\n        }\\n    }\\n\\n    function toValue(uint256 _assetAmount, uint256 _assetPrice, uint256 _assetDecimals)\\n        internal\\n        pure\\n        returns (uint256 value)\\n    {\\n        value = _assetAmount * _assetPrice;\\n        // power of 10 can not be 0, so we can uncheck\\n        unchecked { value /= 10 ** _assetDecimals; }\\n    }\\n\\n    function sum(uint256[] memory _numbers) internal pure returns (uint256 s) {\\n        for(uint256 i; i < _numbers.length;) {\\n            s += _numbers[i];\\n            unchecked { i++; }\\n        }\\n    }\\n\\n    /// @notice Calculates fraction between borrowed and deposited amount of tokens denominated in percentage\\n    /// @dev It assumes `_dp` = 100%.\\n    /// @param _dp decimal points used by model\\n    /// @param _totalDeposits current total deposits for assets\\n    /// @param _totalBorrowAmount current total borrows for assets\\n    /// @return utilization value, capped to 100%\\n    /// Limiting utilisation ratio by 100% max will allows us to perform better interest rate computations\\n    /// and should not affect any other part of protocol.\\n    function calculateUtilization(uint256 _dp, uint256 _totalDeposits, uint256 _totalBorrowAmount)\\n        internal\\n        pure\\n        returns (uint256 utilization)\\n    {\\n        if (_totalDeposits == 0 || _totalBorrowAmount == 0) return 0;\\n\\n        utilization = _totalBorrowAmount * _dp;\\n        // _totalDeposits is not 0 based on above check, so it is safe to uncheck this division\\n        unchecked { utilization /= _totalDeposits; }\\n\\n        // cap at 100%\\n        if (utilization > _dp) utilization = _dp;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/Ping.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.7.6 <0.9.0;\\n\\n\\nlibrary Ping {\\n    function pong(function() external pure returns(bytes4) pingFunction) internal pure returns (bool) {\\n        return pingFunction.address != address(0) && pingFunction.selector == pingFunction();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/RevertBytes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.7.6 <=0.9.0;\\n\\nlibrary RevertBytes {\\n    function revertBytes(bytes memory _errMsg, string memory _customErr) internal pure {\\n        if (_errMsg.length > 0) {\\n            assembly { // solhint-disable-line no-inline-assembly\\n                revert(add(32, _errMsg), mload(_errMsg))\\n            }\\n        }\\n\\n        revert(_customErr);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/SolvencyV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.13;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\n\\nimport \\\"../interfaces/IPriceProvidersRepository.sol\\\";\\nimport \\\"../interfaces/ISilo.sol\\\";\\nimport \\\"../interfaces/IInterestRateModel.sol\\\";\\nimport \\\"../interfaces/ISiloRepository.sol\\\";\\nimport \\\"./EasyMath.sol\\\";\\n\\nlibrary SolvencyV2 {\\n    using EasyMath for uint256;\\n\\n    /// @notice\\n    /// MaximumLTV - Maximum Loan-to-Value ratio represents the maximum borrowing power of all user's collateral\\n    /// positions in a Silo\\n    /// LiquidationThreshold - Liquidation Threshold represents the threshold at which all user's borrow positions\\n    /// in a Silo will be considered under collateralized and subject to liquidation\\n    enum TypeofLTV { MaximumLTV, LiquidationThreshold }\\n\\n    error DifferentArrayLength();\\n    error UnsupportedLTVType();\\n\\n    struct SolvencyParams {\\n        /// @param siloRepository SiloRepository address\\n        ISiloRepository siloRepository;\\n        /// @param silo Silo address\\n        ISilo silo;\\n        /// @param assets array with assets\\n        address[] assets;\\n        /// @param assetStates array of states for each asset, where index match the `assets` index\\n        ISilo.AssetStorage[] assetStates;\\n        /// @param user wallet address for which to read debt\\n        address user;\\n    }\\n\\n    /// @dev is value that used for integer calculations and decimal points for utilization ratios, LTV, protocol fees\\n    uint256 internal constant _PRECISION_DECIMALS = 1e18;\\n    uint256 internal constant _INFINITY = type(uint256).max;\\n\\n    /// @notice Returns current user LTV and second LTV chosen in params\\n    /// @dev This function is optimized for protocol use. In some cases there is no need to keep the calculation\\n    /// going and predefined results can be returned.\\n    /// @param _params `SolvencyV2.SolvencyParams` struct with needed params for calculation\\n    /// @param _secondLtvType type of LTV to be returned as second value\\n    /// @return currentUserLTV Loan-to-Value ratio represents current user's proportion of debt to collateral\\n    /// @return secondLTV second type of LTV which depends on _secondLtvType, zero is returned if the value of the loan\\n    /// or the collateral are zero\\n    function calculateLTVs(SolvencyParams memory _params, TypeofLTV _secondLtvType)\\n        internal\\n        view\\n        returns (uint256 currentUserLTV, uint256 secondLTV)\\n    {\\n        uint256[] memory totalBorrowAmounts = getBorrowAmounts(_params);\\n\\n        // this return avoids eg. additional checks on withdraw, when user did not borrow any asset\\n        if (EasyMath.sum(totalBorrowAmounts) == 0) return (0, 0);\\n\\n        IPriceProvidersRepository priceProvidersRepository = _params.siloRepository.priceProvidersRepository();\\n\\n        uint256[] memory borrowValues = convertAmountsToValues(\\n            priceProvidersRepository,\\n            _params.assets,\\n            totalBorrowAmounts\\n        );\\n\\n        // value of user's total debt\\n        uint256 borrowTotalValue = EasyMath.sum(borrowValues);\\n\\n        if (borrowTotalValue == 0) return (0, 0);\\n\\n        uint256[] memory collateralValues = getUserCollateralValues(priceProvidersRepository, _params);\\n\\n        // value of user's collateral\\n        uint256 collateralTotalValue = EasyMath.sum(collateralValues);\\n\\n        if (collateralTotalValue == 0) return (_INFINITY, 0);\\n\\n        // value of theoretical debt user can have depending on TypeofLTV\\n        uint256 borrowAvailableTotalValue = _getTotalAvailableToBorrowValue(\\n            _params.siloRepository,\\n            address(_params.silo),\\n            _params.assets,\\n            _secondLtvType,\\n            collateralValues\\n        );\\n\\n        currentUserLTV = borrowTotalValue * _PRECISION_DECIMALS / collateralTotalValue;\\n\\n        // one of SolvencyV2.TypeofLTV\\n        secondLTV = borrowAvailableTotalValue * _PRECISION_DECIMALS / collateralTotalValue;\\n    }\\n\\n    /// @notice Calculates chosen LTV limit\\n    /// @dev This function should be used by external actors like SiloLens and UI/subgraph. `calculateLTVs` is\\n    /// optimized for protocol use and may not return second LVT calculation when they are not needed.\\n    /// @param _params `SolvencyV2.SolvencyParams` struct with needed params for calculation\\n    /// @param _ltvType acceptable values are only TypeofLTV.MaximumLTV or TypeofLTV.LiquidationThreshold\\n    /// @return limit theoretical LTV limit of `_ltvType`\\n    function calculateLTVLimit(SolvencyParams memory _params, TypeofLTV _ltvType)\\n        internal\\n        view\\n        returns (uint256 limit)\\n    {\\n        IPriceProvidersRepository priceProvidersRepository = _params.siloRepository.priceProvidersRepository();\\n\\n        uint256[] memory collateralValues = getUserCollateralValues(priceProvidersRepository, _params);\\n\\n        // value of user's collateral\\n        uint256 collateralTotalValue = EasyMath.sum(collateralValues);\\n\\n        if (collateralTotalValue == 0) return 0;\\n\\n        // value of theoretical debt user can have depending on TypeofLTV\\n        uint256 borrowAvailableTotalValue = _getTotalAvailableToBorrowValue(\\n            _params.siloRepository,\\n            address(_params.silo),\\n            _params.assets,\\n            _ltvType,\\n            collateralValues\\n        );\\n\\n        limit = borrowAvailableTotalValue * _PRECISION_DECIMALS / collateralTotalValue;\\n    }\\n\\n    /// @notice Returns worth (in quote token) of each collateral deposit of a user\\n    /// @param _priceProvidersRepository address of IPriceProvidersRepository where prices are read\\n    /// @param _params `SolvencyV2.SolvencyParams` struct with needed params for calculation\\n    /// @return collateralValues worth of each collateral deposit of a user as an array\\n    function getUserCollateralValues(IPriceProvidersRepository _priceProvidersRepository, SolvencyParams memory _params)\\n        internal\\n        view\\n        returns(uint256[] memory collateralValues)\\n    {\\n        uint256[] memory collateralAmounts = getCollateralAmounts(_params);\\n        collateralValues = convertAmountsToValues(_priceProvidersRepository, _params.assets, collateralAmounts);\\n    }\\n\\n    /// @notice Convert assets amounts to values in quote token (amount * price)\\n    /// @param _priceProviderRepo address of IPriceProvidersRepository where prices are read\\n    /// @param _assets array with assets for which prices are read\\n    /// @param _amounts array of amounts\\n    /// @return values array of values for corresponding assets\\n    function convertAmountsToValues(\\n        IPriceProvidersRepository _priceProviderRepo,\\n        address[] memory _assets,\\n        uint256[] memory _amounts\\n    ) internal view returns (uint256[] memory values) {\\n        if (_assets.length != _amounts.length) revert DifferentArrayLength();\\n\\n        values = new uint256[](_assets.length);\\n\\n        for (uint256 i = 0; i < _assets.length; i++) {\\n            if (_amounts[i] == 0) continue;\\n\\n            uint256 assetPrice = _priceProviderRepo.getPrice(_assets[i]);\\n            uint8 assetDecimals = ERC20(_assets[i]).decimals();\\n\\n            values[i] = _amounts[i].toValue(assetPrice, assetDecimals);\\n        }\\n    }\\n\\n    /// @notice Get amount of collateral for each asset\\n    /// @param _params `SolvencyV2.SolvencyParams` struct with needed params for calculation\\n    /// @return collateralAmounts array of amounts for each token in Silo. May contain zero values if user\\n    /// did not deposit given collateral token.\\n    function getCollateralAmounts(SolvencyParams memory _params)\\n        internal\\n        view\\n        returns (uint256[] memory collateralAmounts)\\n    {\\n        if (_params.assets.length != _params.assetStates.length) {\\n            revert DifferentArrayLength();\\n        }\\n\\n        collateralAmounts = new uint256[](_params.assets.length);\\n\\n        for (uint256 i = 0; i < _params.assets.length; i++) {\\n            uint256 userCollateralTokenBalance = _params.assetStates[i].collateralToken.balanceOf(_params.user);\\n            uint256 userCollateralOnlyTokenBalance = _params.assetStates[i].collateralOnlyToken.balanceOf(_params.user);\\n\\n            if (userCollateralTokenBalance + userCollateralOnlyTokenBalance == 0) continue;\\n\\n            uint256 rcomp = getRcomp(_params.silo, _params.siloRepository, _params.assets[i], block.timestamp);\\n\\n            collateralAmounts[i] = getUserCollateralAmount(\\n                _params.assetStates[i],\\n                userCollateralTokenBalance,\\n                userCollateralOnlyTokenBalance,\\n                rcomp,\\n                _params.siloRepository\\n            );\\n        }\\n    }\\n\\n    /// @notice Get amount of debt for each asset\\n    /// @param _params `SolvencyV2.SolvencyParams` struct with needed params for calculation\\n    /// @return totalBorrowAmounts array of amounts for each token in Silo. May contain zero values if user\\n    /// did not borrow given token.\\n    function getBorrowAmounts(SolvencyParams memory _params)\\n        internal\\n        view\\n        returns (uint256[] memory totalBorrowAmounts)\\n    {\\n        if (_params.assets.length != _params.assetStates.length) {\\n            revert DifferentArrayLength();\\n        }\\n\\n        totalBorrowAmounts = new uint256[](_params.assets.length);\\n\\n        for (uint256 i = 0; i < _params.assets.length; i++) {\\n            uint256 rcomp = getRcomp(_params.silo, _params.siloRepository, _params.assets[i], block.timestamp);\\n            totalBorrowAmounts[i] = getUserBorrowAmount(_params.assetStates[i], _params.user, rcomp);\\n        }\\n    }\\n\\n    /// @notice Get amount of deposited token, including collateralOnly deposits\\n    /// @param _assetStates state of deposited asset in Silo\\n    /// @param _userCollateralTokenBalance balance of user's share collateral token\\n    /// @param _userCollateralOnlyTokenBalance balance of user's share collateralOnly token\\n    /// @param _rcomp compounded interest rate to account for during calculations, could be 0\\n    /// @param _siloRepository SiloRepository address\\n    /// @return amount of underlying token deposited, including collateralOnly deposit\\n    function getUserCollateralAmount(\\n        ISilo.AssetStorage memory _assetStates,\\n        uint256 _userCollateralTokenBalance,\\n        uint256 _userCollateralOnlyTokenBalance,\\n        uint256 _rcomp,\\n        ISiloRepository _siloRepository\\n    ) internal view returns (uint256) {\\n        uint256 assetAmount = _userCollateralTokenBalance == 0 ? 0 : _userCollateralTokenBalance.toAmount(\\n            totalDepositsWithInterest(\\n                _assetStates.totalDeposits,\\n                _assetStates.totalBorrowAmount,\\n                _siloRepository.protocolShareFee(),\\n                _rcomp\\n            ),\\n            _assetStates.collateralToken.totalSupply()\\n        );\\n\\n        uint256 assetCollateralOnlyAmount = _userCollateralOnlyTokenBalance == 0\\n            ? 0\\n            : _userCollateralOnlyTokenBalance.toAmount(\\n                _assetStates.collateralOnlyDeposits,\\n                _assetStates.collateralOnlyToken.totalSupply()\\n            );\\n\\n        return assetAmount + assetCollateralOnlyAmount;\\n    }\\n\\n    /// @notice Get amount of borrowed token\\n    /// @param _assetStates state of borrowed asset in Silo\\n    /// @param _user user wallet address for which to read debt\\n    /// @param _rcomp compounded interest rate to account for during calculations, could be 0\\n    /// @return amount of borrowed token\\n    function getUserBorrowAmount(ISilo.AssetStorage memory _assetStates, address _user, uint256 _rcomp)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        uint256 balance = _assetStates.debtToken.balanceOf(_user);\\n        if (balance == 0) return 0;\\n\\n        uint256 totalBorrowAmountCached = totalBorrowAmountWithInterest(_assetStates.totalBorrowAmount, _rcomp);\\n        return balance.toAmountRoundUp(totalBorrowAmountCached, _assetStates.debtToken.totalSupply());\\n    }\\n\\n    /// @notice Get compounded interest rate from the model\\n    /// @param _silo Silo address\\n    /// @param _siloRepository SiloRepository address\\n    /// @param _asset address of asset for which to read interest rate\\n    /// @param _timestamp used to determine amount of time from last rate update\\n    /// @return rcomp compounded interest rate for an asset\\n    function getRcomp(ISilo _silo, ISiloRepository _siloRepository, address _asset, uint256 _timestamp)\\n        internal\\n        view\\n        returns (uint256 rcomp)\\n    {\\n        IInterestRateModel model = _siloRepository.getInterestRateModel(address(_silo), _asset);\\n        rcomp = model.getCompoundInterestRate(address(_silo), _asset, _timestamp);\\n    }\\n\\n    /// @notice Returns total deposits with interest dynamically calculated with the provided rComp\\n    /// @param _assetTotalDeposits total deposits for asset\\n    /// @param _assetTotalBorrows total borrows for asset\\n    /// @param _protocolShareFee `siloRepository.protocolShareFee()`\\n    /// @param _rcomp compounded interest rate\\n    /// @return _totalDepositsWithInterests total deposits amount with interest\\n    function totalDepositsWithInterest(\\n        uint256 _assetTotalDeposits,\\n        uint256 _assetTotalBorrows,\\n        uint256 _protocolShareFee,\\n        uint256 _rcomp\\n    )\\n        internal\\n        pure\\n        returns (uint256 _totalDepositsWithInterests)\\n    {\\n        uint256 depositorsShare = _PRECISION_DECIMALS - _protocolShareFee;\\n\\n        return _assetTotalDeposits + _assetTotalBorrows * _rcomp / _PRECISION_DECIMALS * depositorsShare /\\n            _PRECISION_DECIMALS;\\n    }\\n\\n    /// @notice Returns total borrow amount with interest dynamically calculated with the provided rComp\\n    /// @param _totalBorrowAmount total borrow amount\\n    /// @param _rcomp compounded interest rate\\n    /// @return totalBorrowAmountWithInterests total borrow amount with interest\\n    function totalBorrowAmountWithInterest(uint256 _totalBorrowAmount, uint256 _rcomp)\\n        internal\\n        pure\\n        returns (uint256 totalBorrowAmountWithInterests)\\n    {\\n        totalBorrowAmountWithInterests = _totalBorrowAmount + _totalBorrowAmount * _rcomp / _PRECISION_DECIMALS;\\n    }\\n\\n    /// @notice Calculates protocol liquidation fee and new protocol total fees collected\\n    /// @param _protocolEarnedFees amount of total collected fees so far\\n    /// @param _amount amount on which we will apply fee\\n    /// @param _liquidationFee liquidation fee in SolvencyV2._PRECISION_DECIMALS\\n    /// @return liquidationFeeAmount calculated interest\\n    /// @return newProtocolEarnedFees the new total amount of protocol fees\\n    function calculateLiquidationFee(uint256 _protocolEarnedFees, uint256 _amount, uint256 _liquidationFee)\\n        internal\\n        pure\\n        returns (uint256 liquidationFeeAmount, uint256 newProtocolEarnedFees)\\n    {\\n        unchecked {\\n            // If we overflow on multiplication it should not revert tx, we will get lower fees\\n            liquidationFeeAmount = _amount * _liquidationFee / SolvencyV2._PRECISION_DECIMALS;\\n\\n            if (_protocolEarnedFees > type(uint256).max - liquidationFeeAmount) {\\n                newProtocolEarnedFees = type(uint256).max;\\n                liquidationFeeAmount = type(uint256).max - _protocolEarnedFees;\\n            } else {\\n                newProtocolEarnedFees = _protocolEarnedFees + liquidationFeeAmount;\\n            }\\n        }\\n    }\\n\\n    /// @notice Calculates theoretical value (in quote token) that user could borrow based given collateral value\\n    /// @param _siloRepository SiloRepository address\\n    /// @param _silo Silo address\\n    /// @param _asset address of collateral token\\n    /// @param _type type of LTV limit to use for calculations\\n    /// @param _collateralValue value of collateral deposit (in quote token)\\n    /// @return availableToBorrow value (in quote token) that user can borrow against collateral value\\n    function _getAvailableToBorrowValue(\\n        ISiloRepository _siloRepository,\\n        address _silo,\\n        address _asset,\\n        TypeofLTV _type,\\n        uint256 _collateralValue\\n    ) private view returns (uint256 availableToBorrow) {\\n        uint256 assetLTV;\\n\\n        if (_type == TypeofLTV.MaximumLTV) {\\n            assetLTV = _siloRepository.getMaximumLTV(_silo, _asset);\\n        } else if (_type == TypeofLTV.LiquidationThreshold) {\\n            assetLTV = _siloRepository.getLiquidationThreshold(_silo, _asset);\\n        } else {\\n            revert UnsupportedLTVType();\\n        }\\n\\n        // value that can be borrowed against the deposit\\n        // ie. for assetLTV = 50%, 1 ETH * 50% = 0.5 ETH of available to borrow\\n        availableToBorrow = _collateralValue * assetLTV / _PRECISION_DECIMALS;\\n    }\\n\\n    /// @notice Calculates theoretical value (in quote token) that user can borrow based on deposited collateral\\n    /// @param _siloRepository SiloRepository address\\n    /// @param _silo Silo address\\n    /// @param _assets array with assets\\n    /// @param _ltvType type of LTV limit to use for calculations\\n    /// acceptable values are only TypeofLTV.MaximumLTV or TypeofLTV.LiquidationThreshold\\n    /// @param _collateralValues value (worth in quote token) of each deposit made by user\\n    /// @return totalAvailableToBorrowValue value (in quote token) that user can borrow against collaterals\\n    function _getTotalAvailableToBorrowValue(\\n        ISiloRepository _siloRepository,\\n        address _silo,\\n        address[] memory _assets,\\n        TypeofLTV _ltvType,\\n        uint256[] memory _collateralValues\\n    ) private view returns (uint256 totalAvailableToBorrowValue) {\\n        if (_assets.length != _collateralValues.length) revert DifferentArrayLength();\\n\\n        for (uint256 i = 0; i < _assets.length; i++) {\\n            totalAvailableToBorrowValue += _getAvailableToBorrowValue(\\n                _siloRepository,\\n                _silo,\\n                _assets[i],\\n                _ltvType,\\n                _collateralValues[i]\\n            );\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/liquidation/interface/ILiquidationHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\n/// @notice LiquidationHelper IS NOT PART OF THE PROTOCOL. SILO CREATED THIS TOOL, MOSTLY AS AN EXAMPLE.\\ninterface ILiquidationHelper {\\n    /// @dev Liquidation scenarios that are supported by helper:\\n    /// - Internal: fully on-chain, using internal swappers, magicians etc\\n    ///   When 0x API can not handle the swap, we will use internal.\\n    /// - Full0x: 0x will handle swap for collateral -> repay asset, then contract needs to do repay.\\n    ///   Change that left after repay will be swapped to WETH using internal methods.\\n    ///   This scenario is for A -> B or A, B -> C cases.\\n    /// - Full0xWithChange: similar to Full0x, but all repay tokens that left, will be send to liquidator.\\n    ///   BE bot needs to do another tx to swap change to ETH\\n    ///   This scenario is for A -> B or A, B -> C cases\\n    ///   Exception: WETH -> A, it should be full or internal\\n    ///   Helper is supporting all the tokens internally, so only case, when we would need Full0xWithChange is when\\n    ///   we didn't develop swapper/magician for some new asset yet. Call `liquidationSupported` to check it.\\n    /// - Collateral0x: 0x will swap collateral to native token, then from native -> repay asset contract handle it\\n    ///   This is for A -> XAI, WETH, other cases of multiple repay tokens are not supported by 0x\\n    /// - *Force: force option allows to liquidate even when liquidation is not profitable\\n    enum LiquidationScenario {\\n        Internal, Collateral0x, Full0x, Full0xWithChange,\\n        InternalForce, Collateral0xForce, Full0xForce, Full0xWithChangeForce\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/liquidation/lib/LiquidationScenarioDetector.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport \\\"../interface/ILiquidationHelper.sol\\\";\\n\\n/// @notice Library for processing LiquidationScenarios data\\nlibrary LiquidationScenarioDetector {\\n    function isFull0x(ILiquidationHelper.LiquidationScenario _scenario) internal pure returns (bool) {\\n        return _scenario == ILiquidationHelper.LiquidationScenario.Full0x\\n            || _scenario == ILiquidationHelper.LiquidationScenario.Full0xForce;\\n    }\\n\\n    function isFull0xWithChange(ILiquidationHelper.LiquidationScenario _scenario) internal pure returns (bool) {\\n        return _scenario == ILiquidationHelper.LiquidationScenario.Full0xWithChange\\n            || _scenario == ILiquidationHelper.LiquidationScenario.Full0xWithChangeForce;\\n    }\\n\\n    function isCollateral0x(ILiquidationHelper.LiquidationScenario _scenario) internal pure returns (bool) {\\n        return _scenario == ILiquidationHelper.LiquidationScenario.Collateral0x\\n            || _scenario == ILiquidationHelper.LiquidationScenario.Collateral0xForce;\\n    }\\n\\n    function isInternal(ILiquidationHelper.LiquidationScenario _scenario) internal pure returns (bool) {\\n        return _scenario == ILiquidationHelper.LiquidationScenario.Internal\\n            || _scenario == ILiquidationHelper.LiquidationScenario.InternalForce;\\n    }\\n\\n    function calculateEarnings(ILiquidationHelper.LiquidationScenario _scenario) internal pure returns (bool) {\\n        return _scenario == ILiquidationHelper.LiquidationScenario.Internal\\n            || _scenario == ILiquidationHelper.LiquidationScenario.Collateral0x\\n            || _scenario == ILiquidationHelper.LiquidationScenario.Full0x\\n            || _scenario == ILiquidationHelper.LiquidationScenario.Full0xWithChange;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/liquidation/LiquidationHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\n\\nimport \\\"./magicians/interfaces/IMagician.sol\\\";\\nimport \\\"../SiloLens.sol\\\";\\nimport \\\"../interfaces/ISiloFactory.sol\\\";\\nimport \\\"../interfaces/IPriceProviderV2.sol\\\";\\nimport \\\"../interfaces/ISwapper.sol\\\";\\nimport \\\"../interfaces/ISiloRepository.sol\\\";\\nimport \\\"../interfaces/IPriceProvidersRepository.sol\\\";\\nimport \\\"../interfaces/IWrappedNativeToken.sol\\\";\\nimport \\\"../priceProviders/chainlinkV3/ChainlinkV3PriceProvider.sol\\\";\\n\\nimport \\\"../lib/Ping.sol\\\";\\nimport \\\"../lib/RevertBytes.sol\\\";\\nimport \\\"./ZeroExSwap.sol\\\";\\nimport \\\"./lib/LiquidationScenarioDetector.sol\\\";\\nimport \\\"./LiquidationRepay.sol\\\";\\n\\n/// @notice LiquidationHelper IS NOT PART OF THE PROTOCOL. SILO CREATED THIS TOOL, MOSTLY AS AN EXAMPLE.\\n/// see https://github.com/silo-finance/liquidation#readme for details how liquidation process should look like\\ncontract LiquidationHelper is ILiquidationHelper, IFlashLiquidationReceiver, ZeroExSwap, LiquidationRepay {\\n    using RevertBytes for bytes;\\n    using SafeERC20 for IERC20;\\n    using Address for address payable;\\n    using LiquidationScenarioDetector for LiquidationScenario;\\n\\n    struct MagicianConfig {\\n        address asset;\\n        IMagician magician;\\n    }\\n\\n    struct SwapperConfig {\\n        IPriceProvider provider;\\n        ISwapper swapper;\\n    }\\n\\n    uint256 immutable private _BASE_TX_COST; // solhint-disable-line var-name-mixedcase\\n    ISiloRepository public immutable SILO_REPOSITORY; // solhint-disable-line var-name-mixedcase\\n    IPriceProvidersRepository public immutable PRICE_PROVIDERS_REPOSITORY; // solhint-disable-line var-name-mixedcase\\n    SiloLens public immutable LENS; // solhint-disable-line var-name-mixedcase\\n    IERC20 public immutable QUOTE_TOKEN; // solhint-disable-line var-name-mixedcase\\n\\n    ChainlinkV3PriceProvider public immutable CHAINLINK_PRICE_PROVIDER; // solhint-disable-line var-name-mixedcase\\n\\n    mapping(IPriceProvider => ISwapper) public swappers;\\n    // asset => magician\\n    mapping(address => IMagician) public magicians;\\n\\n    error InvalidSiloLens();\\n    error InvalidSiloRepository();\\n    error LiquidationNotProfitable(uint256 inTheRed);\\n    error NotSilo();\\n    error PriceProviderNotFound();\\n    error FallbackPriceProviderNotSet();\\n    error SwapperNotFound();\\n    error MagicianNotFound();\\n    error SwapAmountInFailed();\\n    error SwapAmountOutFailed();\\n    error UsersMustMatchSilos();\\n    error InvalidChainlinkProviders();\\n    error InvalidMagicianConfig();\\n    error InvalidSwapperConfig();\\n    error InvalidTowardsAssetConvertion();\\n    error InvalidScenario();\\n    error Max0xSwapsIs2();\\n\\n    event SwapperConfigured(IPriceProvider provider, ISwapper swapper);\\n    event MagicianConfigured(address asset, IMagician magician);\\n    \\n    /// @dev event emitted on user liquidation\\n    /// @param silo Silo where liquidation happen\\n    /// @param user User that been liquidated\\n    /// @param earned amount of ETH earned (excluding gas cost)\\n    /// @param estimatedEarnings for LiquidationScenario.Full0xWithChange `earned` amount is estimated,\\n    /// because tokens were not sold for ETH inside transaction\\n    event LiquidationExecuted(address indexed silo, address indexed user, uint256 earned, bool estimatedEarnings);\\n\\n    constructor (\\n        address _repository,\\n        address _chainlinkPriceProvider,\\n        address _lens,\\n        address _exchangeProxy,\\n        MagicianConfig[] memory _magicians,\\n        SwapperConfig[] memory _swappers,\\n        uint256 _baseCost\\n    ) ZeroExSwap(_exchangeProxy) {\\n        if (!Ping.pong(SiloLens(_lens).lensPing)) revert InvalidSiloLens();\\n\\n        if (!Ping.pong(ISiloRepository(_repository).siloRepositoryPing)) {\\n            revert InvalidSiloRepository();\\n        }\\n\\n        SILO_REPOSITORY = ISiloRepository(_repository);\\n        LENS = SiloLens(_lens);\\n\\n        // configure swappers\\n        _configureSwappers(_swappers);\\n        // configure magicians\\n        _configureMagicians(_magicians);\\n\\n        PRICE_PROVIDERS_REPOSITORY = ISiloRepository(_repository).priceProvidersRepository();\\n\\n        CHAINLINK_PRICE_PROVIDER = ChainlinkV3PriceProvider(_chainlinkPriceProvider);\\n\\n        QUOTE_TOKEN = IERC20(PRICE_PROVIDERS_REPOSITORY.quoteToken());\\n        _BASE_TX_COST = _baseCost;\\n    }\\n\\n    receive() external payable {}\\n\\n    function executeLiquidation(\\n        address _user,\\n        ISilo _silo,\\n        LiquidationScenario _scenario,\\n        SwapInput0x[] calldata _swapsInputs0x\\n    ) external {\\n        if (_swapsInputs0x.length > 2) revert Max0xSwapsIs2();\\n\\n        uint256 gasStart = gasleft();\\n        address[] memory users = new address[](1);\\n        users[0] = _user;\\n\\n        _silo.flashLiquidate(users, abi.encode(msg.sender, gasStart, _scenario, _swapsInputs0x));\\n    }\\n\\n    function setSwappers(SwapperConfig[] calldata _swappers) external onlyOwner {\\n        _configureSwappers(_swappers);\\n    }\\n\\n    function setMagicians(MagicianConfig[] calldata _magicians) external onlyOwner {\\n        _configureMagicians(_magicians);\\n    }\\n\\n    /// @notice this is working example of how to perform liquidation, this method will be called by Silo\\n    /// Keep in mind, that this helper might NOT choose the best swap option.\\n    /// For best results (highest earnings) you probably want to implement your own callback and maybe use some\\n    /// dex aggregators.\\n    /// @dev after liquidation we always send remaining tokens so contract should never has any leftover\\n    function siloLiquidationCallback(\\n        address _user,\\n        address[] calldata _assets,\\n        uint256[] calldata _receivedCollaterals,\\n        uint256[] calldata _shareAmountsToRepaid,\\n        bytes calldata _flashReceiverData\\n    ) external override {\\n        if (!SILO_REPOSITORY.isSilo(msg.sender)) revert NotSilo();\\n\\n        (\\n            address payable executor,\\n            uint256 gasStart,\\n            LiquidationScenario scenario,\\n            SwapInput0x[] memory swapInputs\\n        ) = abi.decode(_flashReceiverData, (address, uint256, LiquidationScenario, SwapInput0x[]));\\n\\n        if (swapInputs.length != 0) {\\n            _execute0x(swapInputs);\\n        }\\n\\n        uint256 earned = _siloLiquidationCallbackExecution(\\n            scenario,\\n            _user,\\n            _assets,\\n            _receivedCollaterals,\\n            _shareAmountsToRepaid\\n        );\\n\\n        // I needed to move some part of execution from from `_siloLiquidationCallbackExecution`,\\n        // because of \\\"stack too deep\\\" error\\n        bool isFull0xWithChange = scenario.isFull0xWithChange();\\n        bool calculateEarnings = scenario.calculateEarnings();\\n\\n        if (isFull0xWithChange) {\\n            earned = _estimateEarningsAndTransferChange(_assets, _shareAmountsToRepaid, executor, calculateEarnings);\\n        } else {\\n            _transferNative(executor, earned);\\n        }\\n\\n        emit LiquidationExecuted(msg.sender, _user, earned, isFull0xWithChange);\\n\\n        // do not check for profitability when forcing\\n        if (calculateEarnings) {\\n            ensureTxIsProfitable(gasStart, earned);\\n        }\\n    }\\n\\n    /// @dev This method should be used to made decision about `Full0x` vs `Full0xWithChange` liquidation scenario.\\n    /// @return TRUE, if asset liquidation is supported internally, otherwise FALSE\\n    function liquidationSupported(address _asset) external view returns (bool) {\\n        if (_asset == address(QUOTE_TOKEN)) return true;\\n        if (address(magicians[_asset]) != address(0)) return true;\\n\\n        try this.findPriceProvider(_asset) returns (IPriceProvider) {\\n            return true;\\n        } catch (bytes memory) {\\n            // we do not care about reason\\n        }\\n\\n        return false;\\n    }\\n\\n    function checkSolvency(address[] calldata _users, ISilo[] calldata _silos) external view returns (bool[] memory) {\\n        if (_users.length != _silos.length) revert UsersMustMatchSilos();\\n\\n        bool[] memory solvency = new bool[](_users.length);\\n\\n        for (uint256 i; i < _users.length;) {\\n            solvency[i] = _silos[i].isSolvent(_users[i]);\\n            // we will never have that many users to overflow\\n            unchecked { i++; }\\n        }\\n\\n        return solvency;\\n    }\\n\\n    function checkDebt(address[] calldata _users, ISilo[] calldata _silos) external view returns (bool[] memory) {\\n        bool[] memory hasDebt = new bool[](_users.length);\\n\\n        for (uint256 i; i < _users.length;) {\\n            hasDebt[i] = LENS.inDebt(_silos[i], _users[i]);\\n            // we will never have that many users to overflow\\n            unchecked { i++; }\\n        }\\n\\n        return hasDebt;\\n    }\\n\\n    function ensureTxIsProfitable(uint256 _gasStart, uint256 _earnedEth) public view returns (uint256 txFee) {\\n        unchecked {\\n            // gas calculation will not overflow because values are never that high\\n            // `gasStart` is external value, but it value that we initiating and Silo contract passing it to us\\n            uint256 gasSpent = _gasStart - gasleft() + _BASE_TX_COST;\\n            txFee = tx.gasprice * gasSpent;\\n\\n            if (txFee > _earnedEth) {\\n                // it will not underflow because we check above\\n                revert LiquidationNotProfitable(txFee - _earnedEth);\\n            }\\n        }\\n    }\\n\\n    function findPriceProvider(address _asset) public view returns (IPriceProvider priceProvider) {\\n        priceProvider = PRICE_PROVIDERS_REPOSITORY.priceProviders(_asset);\\n\\n        if (address(priceProvider) == address(0)) revert PriceProviderNotFound();\\n\\n        // check for backwards compatibility with chainlink provider\\n        if (priceProvider == CHAINLINK_PRICE_PROVIDER) {\\n            priceProvider = CHAINLINK_PRICE_PROVIDER.getFallbackProvider(_asset);\\n            if (address(priceProvider) == address(0)) revert FallbackPriceProviderNotSet();\\n            return priceProvider;\\n        }\\n\\n        // only IPriceProviderV2 has `IPriceProviderV2()`\\n        try IPriceProviderV2(address(priceProvider)).offChainProvider() returns (bool isOffChainProvider) {\\n            if (isOffChainProvider) {\\n                priceProvider = IPriceProviderV2(address(priceProvider)).getFallbackProvider(_asset);\\n                if (address(priceProvider) == address(0)) revert FallbackPriceProviderNotSet();\\n            }\\n        } catch (bytes memory) {}\\n    }\\n\\n    function _execute0x(SwapInput0x[] memory _swapInputs) internal {\\n        for (uint256 i; i < _swapInputs.length;) {\\n            fillQuote(_swapInputs[i].sellToken, _swapInputs[i].allowanceTarget, _swapInputs[i].swapCallData);\\n            // we can not have that much data in array to overflow\\n            unchecked { i++; }\\n        }\\n    }\\n\\n    function _siloLiquidationCallbackExecution(\\n        LiquidationScenario _scenario,\\n        address _user,\\n        address[] calldata _assets,\\n        uint256[] calldata _receivedCollaterals,\\n        uint256[] calldata _shareAmountsToRepaid\\n    ) internal returns (uint256 earned) {\\n        if (_scenario.isFull0x()) {\\n            return _runFull0xScenario(\\n                _user,\\n                _assets,\\n                _shareAmountsToRepaid\\n            );\\n        }\\n\\n        if (_scenario.isInternal()) {\\n            return _runInternalScenario(\\n                _user,\\n                _assets,\\n                _receivedCollaterals,\\n                _shareAmountsToRepaid\\n            );\\n        }\\n\\n        if (_scenario.isFull0xWithChange()) {\\n            // we should have repay tokens ready to repay\\n            _repay(ISilo(msg.sender), _user, _assets, _shareAmountsToRepaid);\\n            // change that left after repay will be send to `_liquidator` by `_estimateEarningsAndTransferChange`\\n            return 0;\\n        }\\n\\n        if (_scenario.isCollateral0x()) {\\n            return _runCollateral0xScenario(\\n                _user,\\n                _assets,\\n                _shareAmountsToRepaid\\n            );\\n        }\\n\\n        revert InvalidScenario();\\n    }\\n\\n    function _runFull0xScenario(\\n        address _user,\\n        address[] calldata _assets,\\n        uint256[] calldata _shareAmountsToRepaid\\n    ) internal returns (uint256 earned) {\\n        // we should have repay tokens ready to repay\\n        _repay(ISilo(msg.sender), _user, _assets, _shareAmountsToRepaid);\\n\\n        // we left with some change, let's try to swap to WETH\\n        earned = _swapAssetsForQuote(_assets, _shareAmountsToRepaid);\\n    }\\n\\n    function _runCollateral0xScenario(\\n        address _user,\\n        address[] calldata _assets,\\n        uint256[] calldata _shareAmountsToRepaid\\n    ) internal returns (uint256 earned) {\\n        // we have WETH, we need to deal with swap WETH -> repay asset internally\\n        _swapWrappedNativeForRepayAssets(_assets, _shareAmountsToRepaid);\\n\\n        _repay(ISilo(msg.sender), _user, _assets, _shareAmountsToRepaid);\\n\\n        earned = QUOTE_TOKEN.balanceOf(address(this));\\n    }\\n\\n    function _runInternalScenario(\\n        address _user,\\n        address[] calldata _assets,\\n        uint256[] calldata _receivedCollaterals,\\n        uint256[] calldata _shareAmountsToRepaid\\n    ) internal returns (uint256 earned) {\\n        uint256 quoteAmountFromCollaterals = _swapAllForQuote(_assets, _receivedCollaterals);\\n        uint256 quoteSpentOnRepay = _swapWrappedNativeForRepayAssets(_assets, _shareAmountsToRepaid);\\n\\n        _repay(ISilo(msg.sender), _user, _assets, _shareAmountsToRepaid);\\n        earned = quoteAmountFromCollaterals - quoteSpentOnRepay;\\n    }\\n\\n    function _estimateEarningsAndTransferChange(\\n        address[] calldata _assets,\\n        uint256[] calldata _shareAmountsToRepaid,\\n        address payable _liquidator,\\n        bool _returnEarnedAmount\\n    ) internal returns (uint256 earned) {\\n        // change that left after repay will be send to `_liquidator`\\n        for (uint256 i = 0; i < _assets.length;) {\\n            if (_shareAmountsToRepaid[i] != 0) {\\n                uint256 amount = IERC20(_assets[i]).balanceOf(address(this));\\n\\n                if (_assets[i] == address(QUOTE_TOKEN)) {\\n                    if (_returnEarnedAmount) {\\n                        // balance will not overflow\\n                        unchecked { earned += amount; }\\n                    }\\n\\n                    _transferNative(_liquidator, amount);\\n                } else {\\n                    if (_returnEarnedAmount) {\\n                        // we processing numbers that Silo created, if Silo did not over/under flow, we will not as well\\n                        unchecked { earned += amount * PRICE_PROVIDERS_REPOSITORY.getPrice(_assets[i]) / 1e18; }\\n                    }\\n\\n                    IERC20(_assets[i]).transfer(_liquidator, amount);\\n                }\\n            }\\n\\n            // we will never have that many assets to overflow\\n            unchecked { i++; }\\n        }\\n    }\\n\\n    function _swapAllForQuote(\\n        address[] calldata _assets,\\n        uint256[] calldata _receivedCollaterals\\n    ) internal returns (uint256 quoteAmount) {\\n        // swap all for quote token\\n\\n        unchecked {\\n            // we will not overflow with `i` in a lifetime\\n            for (uint256 i = 0; i < _assets.length; i++) {\\n                // if silo was able to handle solvency calculations, then we can handle quoteAmount without safe math\\n                quoteAmount += _swapForQuote(_assets[i], _receivedCollaterals[i]);\\n            }\\n        }\\n    }\\n\\n    function _swapWrappedNativeForRepayAssets(\\n        address[] calldata _assets,\\n        uint256[] calldata _shareAmountsToRepaid\\n    ) internal returns (uint256 quoteSpendOnRepay) {\\n        for (uint256 i = 0; i < _assets.length;) {\\n            if (_shareAmountsToRepaid[i] != 0) {\\n                // if silo was able to handle solvency calculations, then we can handle amounts without safe math here\\n                unchecked {\\n                    quoteSpendOnRepay += _swapForAsset(_assets[i], _shareAmountsToRepaid[i]);\\n                }\\n            }\\n\\n            // we will never have that many assets to overflow\\n            unchecked { i++; }\\n        }\\n    }\\n\\n    /// @notice We assume that quoteToken is wrapped native token\\n    function _transferNative(address payable _to, uint256 _amount) internal {\\n        IWrappedNativeToken(address(QUOTE_TOKEN)).withdraw(_amount);\\n        _to.sendValue(_amount);\\n    }\\n\\n    function _swapAssetsForQuote(\\n        address[] calldata _assets,\\n        uint256[] calldata _amounts\\n    ) internal returns (uint256 received) {\\n        for (uint256 i = 0; i < _assets.length;) {\\n            if (_amounts[i] != 0) {\\n                uint256 amount = IERC20(_assets[i]).balanceOf(address(this));\\n                received += _swapForQuote(_assets[i], amount);\\n            }\\n\\n            // we will never have that many assets to overflow\\n            unchecked { i++; }\\n        }\\n    }\\n    \\n    /// @dev it swaps asset token for quote\\n    /// @param _asset address\\n    /// @param _amount exact amount of asset to swap\\n    /// @return amount of quote token\\n    function _swapForQuote(address _asset, uint256 _amount) internal returns (uint256) {\\n        address quoteToken = address(QUOTE_TOKEN);\\n\\n        if (_amount == 0 || _asset == quoteToken) return _amount;\\n\\n        address magician = address(magicians[_asset]);\\n\\n        if (magician != address(0)) {\\n            bytes memory result = _safeDelegateCall(\\n                magician,\\n                abi.encodeCall(IMagician.towardsNative, (_asset, _amount)),\\n                \\\"towardsNativeFailed\\\"\\n            );\\n\\n            (address tokenOut, uint256 amountOut) = abi.decode(result, (address, uint256));\\n\\n            return _swapForQuote(tokenOut, amountOut);\\n        }\\n\\n        (IPriceProvider provider, ISwapper swapper) = _resolveProviderAndSwapper(_asset);\\n\\n        // no need for safe approval, because we always using 100%\\n        // Low level call needed to support non-standard `ERC20.approve` eg like `USDT.approve`\\n        // solhint-disable-next-line avoid-low-level-calls\\n        _asset.call(abi.encodeCall(IERC20.approve, (swapper.spenderToApprove(), _amount)));\\n\\n        bytes memory callData = abi.encodeCall(ISwapper.swapAmountIn, (\\n            _asset, quoteToken, _amount, address(provider), _asset\\n        ));\\n\\n        bytes memory data = _safeDelegateCall(address(swapper), callData, \\\"swapAmountIn\\\");\\n\\n        return abi.decode(data, (uint256));\\n    }\\n\\n    /// @dev it swaps quote token for asset\\n    /// @param _asset address\\n    /// @param _amount exact amount OUT, what we want to receive\\n    /// @return amount of quote token used for swap\\n    function _swapForAsset(address _asset, uint256 _amount) internal returns (uint256) {\\n        address quoteToken = address(QUOTE_TOKEN);\\n\\n        if (_amount == 0 || quoteToken == _asset) return _amount;\\n\\n        address magician = address(magicians[_asset]);\\n\\n        if (magician != address(0)) {\\n            bytes memory result = _safeDelegateCall(\\n                magician,\\n                abi.encodeCall(IMagician.towardsAsset, (_asset, _amount)),\\n                \\\"towardsAssetFailed\\\"\\n            );\\n\\n            (address tokenOut, uint256 amountOut) = abi.decode(result, (address, uint256));\\n\\n            // towardsAsset should convert to `_asset`\\n            if (tokenOut != _asset) revert InvalidTowardsAssetConvertion();\\n\\n            return amountOut;\\n        }\\n\\n        (IPriceProvider provider, ISwapper swapper) = _resolveProviderAndSwapper(_asset);\\n\\n        address spender = swapper.spenderToApprove();\\n\\n        IERC20(quoteToken).approve(spender, type(uint256).max);\\n\\n        bytes memory callData = abi.encodeCall(ISwapper.swapAmountOut, (\\n            quoteToken, _asset, _amount, address(provider), _asset\\n        ));\\n\\n        bytes memory data = _safeDelegateCall(address(swapper), callData, \\\"SwapAmountOutFailed\\\");\\n\\n        IERC20(quoteToken).approve(spender, 0);\\n\\n        return abi.decode(data, (uint256));\\n    }\\n\\n    function _resolveProviderAndSwapper(address _asset) internal view returns (IPriceProvider, ISwapper) {\\n        IPriceProvider priceProvider = findPriceProvider(_asset);\\n\\n        ISwapper swapper = _resolveSwapper(priceProvider);\\n\\n        return (priceProvider, swapper);\\n    }\\n\\n    function _resolveSwapper(IPriceProvider priceProvider) internal view returns (ISwapper) {\\n        ISwapper swapper = swappers[priceProvider];\\n\\n        if (address(swapper) == address(0)) {\\n            revert SwapperNotFound();\\n        }\\n\\n        return swapper;\\n    }\\n\\n    function _safeDelegateCall(\\n        address _target,\\n        bytes memory _callData,\\n        string memory _mgs\\n    )\\n        internal\\n        returns (bytes memory data)\\n    {\\n        bool success;\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (success, data) = address(_target).delegatecall(_callData);\\n        if (!success || data.length == 0) data.revertBytes(_mgs);\\n    }\\n\\n    function _configureSwappers(SwapperConfig[] memory _swappers) internal {\\n        for (uint256 i = 0; i < _swappers.length; i++) {\\n            IPriceProvider provider = _swappers[i].provider;\\n            ISwapper swapper = _swappers[i].swapper;\\n\\n            if (address(provider) == address(0) || address(swapper) == address(0)) {\\n                revert InvalidSwapperConfig();\\n            }\\n\\n            swappers[provider] = swapper;\\n\\n            emit SwapperConfigured(provider, swapper);\\n        }\\n    }\\n\\n    function _configureMagicians(MagicianConfig[] memory _magicians) internal {\\n        for (uint256 i = 0; i < _magicians.length; i++) {\\n            address asset = _magicians[i].asset;\\n            IMagician magician = _magicians[i].magician;\\n\\n            if (asset == address(0) || address(magician) == address(0)) {\\n                revert InvalidMagicianConfig();\\n            }\\n\\n            magicians[asset] = magician;\\n\\n            emit MagicianConfigured(asset, magician);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/liquidation/LiquidationRepay.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"../interfaces/ISilo.sol\\\";\\n\\n/// @notice LiquidationHelper IS NOT PART OF THE PROTOCOL. SILO CREATED THIS TOOL, MOSTLY AS AN EXAMPLE.\\n/// see https://github.com/silo-finance/liquidation#readme for details how liquidation process should look like\\nabstract contract LiquidationRepay {\\n\\n    error RepayFailed();\\n\\n    function _repay(\\n        ISilo _silo,\\n        address _user,\\n        address[] calldata _assets,\\n        uint256[] calldata _shareAmountsToRepaid\\n    ) internal virtual {\\n        for (uint256 i = 0; i < _assets.length;) {\\n            if (_shareAmountsToRepaid[i] != 0) {\\n                _repayAsset(_silo, _user, _assets[i], _shareAmountsToRepaid[i]);\\n            }\\n\\n            // we will never have that many assets to overflow\\n            unchecked { i++; }\\n        }\\n    }\\n\\n    function _repayAsset(\\n        ISilo _silo,\\n        address _user,\\n        address _asset,\\n        uint256 _shareAmountToRepaid\\n    ) internal virtual {\\n        // Low level call needed to support non-standard `ERC20.approve` eg like `USDT.approve`\\n        // solhint-disable-next-line avoid-low-level-calls\\n        _asset.call(abi.encodeCall(IERC20.approve, (address(_silo), _shareAmountToRepaid)));\\n        _silo.repayFor(_asset, _user, _shareAmountToRepaid);\\n\\n        // DEFLATIONARY TOKENS ARE NOT SUPPORTED\\n        // we are not using lower limits for swaps so we may not get enough tokens to do full repay\\n        // our assumption here is that `_shareAmountsToRepaid[i]` is total amount to repay the full debt\\n        // if after repay user has no debt in this asset, the swap is acceptable\\n        if (_silo.assetStorage(_asset).debtToken.balanceOf(_user) != 0) {\\n            revert RepayFailed();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/liquidation/magicians/interfaces/IMagician.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9.0;\\n\\n/// @notice Extension for the Liquidation helper to support such operations as unwrapping\\ninterface IMagician {\\n    /// @notice Operates to unwrap an `_asset`\\n    /// @param _asset Asset to be unwrapped\\n    /// @param _amount Amount of the `_asset`\\n    /// @return tokenOut A token that the `_asset` has been converted to\\n    /// @return amountOut Amount of the `tokenOut` that we received\\n    function towardsNative(address _asset, uint256 _amount) external returns (address tokenOut, uint256 amountOut);\\n\\n    /// @notice Performs operation opposit to `towardsNative`\\n    /// @param _asset Asset to be wrapped\\n    /// @param _amount Amount of the `_asset`\\n    /// @return tokenOut A token that the `_asset` has been converted to\\n    /// @return amountOut Amount of the quote token that we spent to get `_amoun` of the `_asset`\\n    function towardsAsset(address _asset, uint256 _amount) external returns (address tokenOut, uint256 amountOut);\\n}\\n\"\r\n    },\r\n    \"contracts/liquidation/ZeroExSwap.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nimport \\\"../lib/RevertBytes.sol\\\";\\n\\n/// @dev Based on demo contract that swaps its ERC20 balance for another ERC20.\\n/// demo source: https://github.com/0xProject/0x-api-starter-guide-code/blob/master/contracts/SimpleTokenSwap.sol\\ncontract ZeroExSwap is Ownable {\\n    using RevertBytes for bytes;\\n\\n    /// @param sellToken The `sellTokenAddress` field from the API response.\\n    /// @param buyToken The `buyTokenAddress` field from the API response.\\n    /// @param allowanceTarget The `allowanceTarget` field from the API response.\\n    /// @param swapCallData The `data` field from the API response.\\n    struct SwapInput0x {\\n        address sellToken;\\n        address allowanceTarget;\\n        bytes swapCallData;\\n    }\\n\\n    /// @dev 0x ExchangeProxy address.\\n    /// See https://docs.0x.org/developer-resources/contract-addresses\\n    /// The `to` field from the API response, but at the same time,\\n    /// TODO: maybe unit test that will check, if it does not changed?\\n    // solhint-disable-next-line var-name-mixedcase\\n    address public immutable EXCHANGE_PROXY;\\n\\n    event BoughtTokens(address sellToken, address buyToken, uint256 boughtAmount);\\n\\n    error AddressZero();\\n    error TargetNotExchangeProxy();\\n    error ApprovalFailed();\\n\\n    constructor(address _exchangeProxy) {\\n        if (_exchangeProxy == address(0)) revert AddressZero();\\n\\n        EXCHANGE_PROXY = _exchangeProxy;\\n    }\\n\\n    /// @dev Swaps ERC20->ERC20 tokens held by this contract using a 0x-API quote.\\n    /// Must attach ETH equal to the `value` field from the API response.\\n    /// @param _sellToken The `sellTokenAddress` field from the API response.\\n    /// @param _spender The `allowanceTarget` field from the API response.\\n    /// @param _swapCallData The `data` field from the API response.\\n    function fillQuote(address _sellToken, address _spender, bytes memory _swapCallData) public {\\n        IERC20(_sellToken).approve(_spender, type(uint256).max);\\n\\n        // Call the encoded swap function call on the contract at `swapTarget`\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory data) = EXCHANGE_PROXY.call(_swapCallData);\\n        if (!success) data.revertBytes(\\\"SWAP_CALL_FAILED\\\");\\n\\n        IERC20(_sellToken).approve(_spender, 0);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/priceProviders/chainlinkV3/ChainlinkV3PriceProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\nimport \\\"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\\\";\\n\\nimport \\\"../PriceProvider.sol\\\";\\nimport \\\"../IERC20LikeV2.sol\\\";\\n\\ncontract ChainlinkV3PriceProvider is PriceProvider {\\n    using SafeMath for uint256;\\n\\n    struct AssetData {\\n        // Time threshold to invalidate stale prices\\n        uint256 heartbeat;\\n        // If true, we bypass the aggregator and consult the fallback provider directly\\n        bool forceFallback;\\n        // If true, the aggregator returns price in USD, so we need to convert to QUOTE\\n        bool convertToQuote;\\n        // Chainlink aggregator proxy\\n        AggregatorV3Interface aggregator;\\n        // Provider used if the aggregator's price is invalid or if it became disabled\\n        IPriceProvider fallbackProvider;\\n    }\\n\\n    /// @dev Aggregator that converts from USD to quote token\\n    AggregatorV3Interface internal immutable _QUOTE_AGGREGATOR; // solhint-disable-line var-name-mixedcase\\n\\n    /// @dev Decimals used by the _QUOTE_AGGREGATOR\\n    uint8 internal immutable _QUOTE_AGGREGATOR_DECIMALS; // solhint-disable-line var-name-mixedcase\\n\\n    /// @dev Used to optimize calculations in emergency disable function\\n    // solhint-disable-next-line var-name-mixedcase\\n    uint256 internal immutable _MAX_PRICE_DIFF = type(uint256).max / (100 * EMERGENCY_PRECISION);\\n    \\n    // @dev Precision to use for the EMERGENCY_THRESHOLD\\n    uint256 public constant EMERGENCY_PRECISION = 1e6;\\n\\n    /// @dev Disable the aggregator if the difference with the fallback is higher than this percentage (10%)\\n    uint256 public constant EMERGENCY_THRESHOLD = 10 * EMERGENCY_PRECISION; // solhint-disable-line var-name-mixedcase\\n\\n    /// @dev this is basically `PriceProvider.quoteToken.decimals()`\\n    uint8 internal immutable _QUOTE_TOKEN_DECIMALS; // solhint-disable-line var-name-mixedcase\\n\\n    /// @dev Address allowed to call the emergencyDisable function, can be set by the owner\\n    address public emergencyManager;\\n\\n    /// @dev Threshold used to determine if the price returned by the _QUOTE_AGGREGATOR is valid\\n    uint256 public quoteAggregatorHeartbeat;\\n\\n    /// @dev Data used for each asset\\n    mapping(address => AssetData) public assetData;\\n\\n    event NewAggregator(address indexed asset, AggregatorV3Interface indexed aggregator, bool convertToQuote);\\n    event NewFallbackPriceProvider(address indexed asset, IPriceProvider indexed fallbackProvider);\\n    event NewHeartbeat(address indexed asset, uint256 heartbeat);\\n    event NewQuoteAggregatorHeartbeat(uint256 heartbeat);\\n    event NewEmergencyManager(address indexed emergencyManager);\\n    event AggregatorDisabled(address indexed asset, AggregatorV3Interface indexed aggregator);\\n\\n    error AggregatorDidNotChange();\\n    error AggregatorPriceNotAvailable();\\n    error AssetNotSupported();\\n    error EmergencyManagerDidNotChange();\\n    error EmergencyThresholdNotReached();\\n    error FallbackProviderAlreadySet();\\n    error FallbackProviderDidNotChange();\\n    error FallbackProviderNotSet();\\n    error HeartbeatDidNotChange();\\n    error InvalidAggregator();\\n    error InvalidAggregatorDecimals();\\n    error InvalidFallbackPriceProvider();\\n    error InvalidHeartbeat();\\n    error OnlyEmergencyManager();\\n    error QuoteAggregatorHeartbeatDidNotChange();\\n\\n    modifier onlyAssetSupported(address _asset) {\\n        if (!assetSupported(_asset)) {\\n            revert AssetNotSupported();\\n        }\\n\\n        _;\\n    }\\n\\n    constructor(\\n        IPriceProvidersRepository _priceProvidersRepository,\\n        address _emergencyManager,\\n        AggregatorV3Interface _quoteAggregator,\\n        uint256 _quoteAggregatorHeartbeat\\n    ) PriceProvider(_priceProvidersRepository) {\\n        _setEmergencyManager(_emergencyManager);\\n        _QUOTE_TOKEN_DECIMALS = IERC20LikeV2(quoteToken).decimals();\\n        _QUOTE_AGGREGATOR = _quoteAggregator;\\n        _QUOTE_AGGREGATOR_DECIMALS = _quoteAggregator.decimals();\\n        quoteAggregatorHeartbeat = _quoteAggregatorHeartbeat;\\n    }\\n\\n    /// @inheritdoc IPriceProvider\\n    function assetSupported(address _asset) public view virtual override returns (bool) {\\n        AssetData storage data = assetData[_asset];\\n\\n        // Asset is supported if:\\n        //     - the asset is the quote token\\n        //       OR\\n        //     - the aggregator address is defined AND\\n        //         - the aggregator is not disabled\\n        //           OR\\n        //         - the fallback is defined\\n\\n        if (_asset == quoteToken) {\\n            return true;\\n        }\\n\\n        if (address(data.aggregator) != address(0)) {\\n            return !data.forceFallback || address(data.fallbackProvider) != address(0);\\n        }\\n\\n        return false;\\n    }\\n\\n    /// @dev Returns price directly from aggregator using all internal settings except of fallback provider\\n    /// @param _asset Asset for which we want to get the price\\n    function getAggregatorPrice(address _asset) public view virtual returns (bool success, uint256 price) {\\n        (success, price) = _getAggregatorPrice(_asset);\\n    }\\n    \\n    /// @inheritdoc IPriceProvider\\n    function getPrice(address _asset) public view virtual override returns (uint256) {\\n        address quote = quoteToken;\\n\\n        if (_asset == quote) {\\n            return 10 ** _QUOTE_TOKEN_DECIMALS;\\n        }\\n\\n        (bool success, uint256 price) = _getAggregatorPrice(_asset);\\n\\n        return success ? price : _getFallbackPrice(_asset);\\n    }\\n\\n    /// @dev Sets the aggregator, fallbackProvider and heartbeat for an asset. Can only be called by the manager.\\n    /// @param _asset Asset to setup\\n    /// @param _aggregator Chainlink aggregator proxy\\n    /// @param _fallbackProvider Provider to use if the price is invalid or if the aggregator was disabled\\n    /// @param _heartbeat Threshold in seconds to invalidate a stale price\\n    function setupAsset(\\n        address _asset,\\n        AggregatorV3Interface _aggregator,\\n        IPriceProvider _fallbackProvider,\\n        uint256 _heartbeat,\\n        bool _convertToQuote\\n    ) external virtual onlyManager {\\n        // This has to be done first so that `_setAggregator` works\\n        _setHeartbeat(_asset, _heartbeat);\\n\\n        if (!_setAggregator(_asset, _aggregator, _convertToQuote)) revert AggregatorDidNotChange();\\n\\n        // We don't care if this doesn't change\\n        _setFallbackPriceProvider(_asset, _fallbackProvider);\\n    }\\n\\n    /// @dev Sets the aggregator for an asset. Can only be called by the manager.\\n    /// @param _asset Asset for which to set the aggregator\\n    /// @param _aggregator Aggregator to set\\n    function setAggregator(address _asset, AggregatorV3Interface _aggregator, bool _convertToQuote)\\n        external\\n        virtual\\n        onlyManager\\n        onlyAssetSupported(_asset)\\n    {\\n        if (!_setAggregator(_asset, _aggregator, _convertToQuote)) revert AggregatorDidNotChange();\\n    }\\n\\n    /// @dev Sets the fallback provider for an asset. Can only be called by the manager.\\n    /// @param _asset Asset for which to set the fallback provider\\n    /// @param _fallbackProvider Provider to set\\n    function setFallbackPriceProvider(address _asset, IPriceProvider _fallbackProvider)\\n        external\\n        virtual\\n        onlyManager\\n        onlyAssetSupported(_asset)\\n    {\\n        if (!_setFallbackPriceProvider(_asset, _fallbackProvider)) {\\n            revert FallbackProviderDidNotChange();\\n        }\\n    }\\n\\n    /// @dev Sets the heartbeat threshold for an asset. Can only be called by the manager.\\n    /// @param _asset Asset for which to set the heartbeat threshold\\n    /// @param _heartbeat Threshold to set\\n    function setHeartbeat(address _asset, uint256 _heartbeat)\\n        external\\n        virtual\\n        onlyManager\\n        onlyAssetSupported(_asset)\\n    {\\n        if (!_setHeartbeat(_asset, _heartbeat)) revert HeartbeatDidNotChange();\\n    }\\n\\n    /// @dev Sets the quote aggregator heartbeat threshold. Can only be called by the manager.\\n    /// @param _heartbeat Threshold to set\\n    function setQuoteAggregatorHeartbeat(uint256 _heartbeat)\\n        external\\n        virtual\\n        onlyManager\\n    {\\n        if (!_setQuoteAggregatorHeartbeat(_heartbeat)) revert QuoteAggregatorHeartbeatDidNotChange();\\n    }\\n\\n    /// @dev Sets the emergencyManager. Can only be called by the manager.\\n    /// @param _emergencyManager Emergency manager to set\\n    function setEmergencyManager(address _emergencyManager) external virtual onlyManager {\\n        if (!_setEmergencyManager(_emergencyManager)) revert EmergencyManagerDidNotChange();\\n    }\\n\\n    /// @dev Disables the aggregator for an asset if there is a big discrepancy between the aggregator and the\\n    /// fallback provider. The only way to reenable the asset is by calling setupAsset or setAggregator again.\\n    /// Can only be called by the emergencyManager.\\n    /// @param _asset Asset for which to disable the aggregator\\n    function emergencyDisable(address _asset) external virtual {\\n        if (msg.sender != emergencyManager) {\\n            revert OnlyEmergencyManager();\\n        }\\n\\n        (bool success, uint256 price) = _getAggregatorPrice(_asset);\\n\\n        if (!success) {\\n            revert AggregatorPriceNotAvailable();\\n        }\\n\\n        uint256 fallbackPrice = _getFallbackPrice(_asset);\\n\\n        uint256 diff;\\n\\n        unchecked {\\n            // It is ok to uncheck because of the initial fallbackPrice >= price check\\n            diff = fallbackPrice >= price ? fallbackPrice - price : price - fallbackPrice;\\n        }\\n\\n        if (diff > _MAX_PRICE_DIFF || (diff * 100 * EMERGENCY_PRECISION) / price < EMERGENCY_THRESHOLD) {\\n            revert EmergencyThresholdNotReached();\\n        }\\n\\n        // Disable main aggregator, fallback stays enabled\\n        assetData[_asset].forceFallback = true;\\n\\n        emit AggregatorDisabled(_asset, assetData[_asset].aggregator);\\n    }\\n\\n    function getFallbackProvider(address _asset) external view virtual returns (IPriceProvider) {\\n        return assetData[_asset].fallbackProvider;\\n    }\\n\\n    function _getAggregatorPrice(address _asset) internal view virtual returns (bool success, uint256 price) {\\n        AssetData storage data = assetData[_asset];\\n\\n        uint256 heartbeat = data.heartbeat;\\n        bool forceFallback = data.forceFallback;\\n        AggregatorV3Interface aggregator = data.aggregator;\\n\\n        if (address(aggregator) == address(0)) revert AssetNotSupported();\\n\\n        (\\n            /*uint80 roundID*/,\\n            int256 aggregatorPrice,\\n            /*uint256 startedAt*/,\\n            uint256 timestamp,\\n            /*uint80 answeredInRound*/\\n        ) = aggregator.latestRoundData();\\n\\n        // If a valid price is returned and it was updated recently\\n        if (!forceFallback && _isValidPrice(aggregatorPrice, timestamp, heartbeat)) {\\n            uint256 result;\\n\\n            if (data.convertToQuote) {\\n                // _toQuote performs decimal normalization internally\\n                result = _toQuote(uint256(aggregatorPrice));\\n            } else {\\n                uint8 aggregatorDecimals = aggregator.decimals();\\n                result = _normalizeWithDecimals(uint256(aggregatorPrice), aggregatorDecimals);\\n            }\\n\\n            return (true, result);\\n        }\\n\\n        return (false, 0);\\n    }\\n\\n    function _getFallbackPrice(address _asset) internal view virtual returns (uint256) {\\n        IPriceProvider fallbackProvider = assetData[_asset].fallbackProvider;\\n\\n        if (address(fallbackProvider) == address(0)) revert FallbackProviderNotSet();\\n\\n        return fallbackProvider.getPrice(_asset);\\n    }\\n\\n    function _setEmergencyManager(address _emergencyManager) internal virtual returns (bool changed) {\\n        if (_emergencyManager == emergencyManager) {\\n            return false;\\n        }\\n\\n        emergencyManager = _emergencyManager;\\n\\n        emit NewEmergencyManager(_emergencyManager);\\n\\n        return true;\\n    }\\n\\n    function _setAggregator(\\n        address _asset,\\n        AggregatorV3Interface _aggregator,\\n        bool _convertToQuote\\n    ) internal virtual returns (bool changed) {\\n        if (address(_aggregator) == address(0)) revert InvalidAggregator();\\n\\n        AssetData storage data = assetData[_asset];\\n\\n        if (data.aggregator == _aggregator && data.forceFallback == false) {\\n            return false;\\n        }\\n\\n        // There doesn't seem to be a way to verify if this is a \\\"valid\\\" aggregator (other than getting the price)\\n        data.forceFallback = false;\\n        data.aggregator = _aggregator;\\n\\n        (bool success,) = _getAggregatorPrice(_asset);\\n\\n        if (!success) revert AggregatorPriceNotAvailable();\\n\\n        if (_convertToQuote && _aggregator.decimals() != _QUOTE_AGGREGATOR_DECIMALS) {\\n            revert InvalidAggregatorDecimals();\\n        }\\n\\n        // We want to always update this\\n        assetData[_asset].convertToQuote = _convertToQuote;\\n\\n        emit NewAggregator(_asset, _aggregator, _convertToQuote);\\n\\n        return true;\\n    }\\n\\n    function _setFallbackPriceProvider(address _asset, IPriceProvider _fallbackProvider)\\n        internal\\n        virtual\\n        returns (bool changed)\\n    {\\n        if (_fallbackProvider == assetData[_asset].fallbackProvider) {\\n            return false;\\n        }\\n\\n        assetData[_asset].fallbackProvider = _fallbackProvider;\\n\\n        if (address(_fallbackProvider) != address(0)) {\\n            if (\\n                !priceProvidersRepository.isPriceProvider(_fallbackProvider) ||\\n                !_fallbackProvider.assetSupported(_asset) ||\\n                _fallbackProvider.quoteToken() != quoteToken\\n            ) {\\n                revert InvalidFallbackPriceProvider();\\n            }\\n\\n            // Make sure it doesn't revert\\n            _getFallbackPrice(_asset);\\n        }\\n\\n        emit NewFallbackPriceProvider(_asset, _fallbackProvider);\\n\\n        return true;\\n    }\\n\\n    function _setHeartbeat(address _asset, uint256 _heartbeat) internal virtual returns (bool changed) {\\n        // Arbitrary limit, Chainlink's threshold is always less than a day\\n        if (_heartbeat > 2 days) revert InvalidHeartbeat();\\n\\n        if (_heartbeat == assetData[_asset].heartbeat) {\\n            return false;\\n        }\\n\\n        assetData[_asset].heartbeat = _heartbeat;\\n\\n        emit NewHeartbeat(_asset, _heartbeat);\\n\\n        return true;\\n    }\\n\\n    function _setQuoteAggregatorHeartbeat(uint256 _heartbeat) internal virtual returns (bool changed) {\\n        // Arbitrary limit, Chainlink's threshold is always less than a day\\n        if (_heartbeat > 2 days) revert InvalidHeartbeat();\\n\\n        if (_heartbeat == quoteAggregatorHeartbeat) {\\n            return false;\\n        }\\n\\n        quoteAggregatorHeartbeat = _heartbeat;\\n\\n        emit NewQuoteAggregatorHeartbeat(_heartbeat);\\n\\n        return true;\\n    }\\n\\n    /// @dev Adjusts the given price to use the same decimals as the quote token.\\n    /// @param _price Price to adjust decimals\\n    /// @param _decimals Decimals considered in `_price`\\n    function _normalizeWithDecimals(uint256 _price, uint8 _decimals) internal view virtual returns (uint256) {\\n        // We want to return the price of 1 asset token, but with the decimals of the quote token\\n        if (_QUOTE_TOKEN_DECIMALS == _decimals) {\\n            return _price;\\n        } else if (_QUOTE_TOKEN_DECIMALS < _decimals) {\\n            return _price / 10 ** (_decimals - _QUOTE_TOKEN_DECIMALS);\\n        } else {\\n            return _price * 10 ** (_QUOTE_TOKEN_DECIMALS - _decimals);\\n        }\\n    }\\n\\n    /// @dev Converts a price returned by an aggregator to quote units\\n    function _toQuote(uint256 _price) internal view virtual returns (uint256) {\\n       (\\n            /*uint80 roundID*/,\\n            int256 aggregatorPrice,\\n            /*uint256 startedAt*/,\\n            uint256 timestamp,\\n            /*uint80 answeredInRound*/\\n        ) = _QUOTE_AGGREGATOR.latestRoundData();\\n\\n        // If an invalid price is returned\\n        if (!_isValidPrice(aggregatorPrice, timestamp, quoteAggregatorHeartbeat)) {\\n            revert AggregatorPriceNotAvailable();\\n        }\\n\\n        // _price and aggregatorPrice should both have the same decimals so we normalize here\\n        return _price * 10 ** _QUOTE_TOKEN_DECIMALS / uint256(aggregatorPrice);\\n    }\\n\\n    function _isValidPrice(int256 _price, uint256 _timestamp, uint256 _heartbeat) internal view virtual returns (bool) {\\n        return _price > 0 && block.timestamp - _timestamp < _heartbeat;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/priceProviders/IERC20LikeV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.7.6;\\n\\n/// @dev This is only meant to be used by price providers, which use a different\\n/// Solidity version than the rest of the codebase. This way de won't need to include\\n/// an additional version of OpenZeppelin's library.\\ninterface IERC20LikeV2 {\\n    function decimals() external view returns (uint8);\\n    function balanceOf(address) external view returns(uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/priceProviders/PriceProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.7.6 <0.9.0;\\n\\nimport \\\"../lib/Ping.sol\\\";\\nimport \\\"../interfaces/IPriceProvider.sol\\\";\\nimport \\\"../interfaces/IPriceProvidersRepository.sol\\\";\\n\\n/// @title PriceProvider\\n/// @notice Abstract PriceProvider contract, parent of all PriceProviders\\n/// @dev Price provider is a contract that directly integrates with a price source, ie. a DEX or alternative system\\n/// like Chainlink to calculate TWAP prices for assets. Each price provider should support a single price source\\n/// and multiple assets.\\nabstract contract PriceProvider is IPriceProvider {\\n    /// @notice PriceProvidersRepository address\\n    IPriceProvidersRepository public immutable priceProvidersRepository;\\n\\n    /// @notice Token address which prices are quoted in. Must be the same as PriceProvidersRepository.quoteToken\\n    address public immutable override quoteToken;\\n\\n    modifier onlyManager() {\\n        if (priceProvidersRepository.manager() != msg.sender) revert(\\\"OnlyManager\\\");\\n        _;\\n    }\\n\\n    /// @param _priceProvidersRepository address of PriceProvidersRepository\\n    constructor(IPriceProvidersRepository _priceProvidersRepository) {\\n        if (\\n            !Ping.pong(_priceProvidersRepository.priceProvidersRepositoryPing)            \\n        ) {\\n            revert(\\\"InvalidPriceProviderRepository\\\");\\n        }\\n\\n        priceProvidersRepository = _priceProvidersRepository;\\n        quoteToken = _priceProvidersRepository.quoteToken();\\n    }\\n\\n    /// @inheritdoc IPriceProvider\\n    function priceProviderPing() external pure override returns (bytes4) {\\n        return this.priceProviderPing.selector;\\n    }\\n\\n    function _revertBytes(bytes memory _errMsg, string memory _customErr) internal pure {\\n        if (_errMsg.length > 0) {\\n            assembly { // solhint-disable-line no-inline-assembly\\n                revert(add(32, _errMsg), mload(_errMsg))\\n            }\\n        }\\n\\n        revert(_customErr);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/SiloLens.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.13;\\n\\nimport \\\"./interfaces/IBaseSilo.sol\\\";\\nimport \\\"./interfaces/ISilo.sol\\\";\\nimport \\\"./lib/EasyMathV2.sol\\\";\\nimport \\\"./lib/Ping.sol\\\";\\nimport \\\"./lib/SolvencyV2.sol\\\";\\n\\n/// @title SiloLens\\n/// @notice Utility contract that simplifies reading data from Silo protocol contracts\\n/// @custom:security-contact security@silo.finance\\ncontract SiloLens {\\n    using EasyMathV2 for uint256;\\n\\n    ISiloRepository immutable public siloRepository;\\n\\n    error InvalidRepository();\\n    error UserIsZero();\\n\\n    constructor (ISiloRepository _siloRepo) {\\n        if (!Ping.pong(_siloRepo.siloRepositoryPing)) revert InvalidRepository();\\n\\n        siloRepository = _siloRepo;\\n    }\\n\\n    /// @dev calculates solvency using SolvencyV2 library\\n    /// @param _silo Silo address from which to read data\\n    /// @param _user wallet address\\n    /// @return true if solvent, false otherwise\\n    function isSolvent(ISilo _silo, address _user) external view returns (bool) {\\n        if (_user == address(0)) revert UserIsZero();\\n\\n        (address[] memory assets, IBaseSilo.AssetStorage[] memory assetsStates) = _silo.getAssetsWithState();\\n\\n        (uint256 userLTV, uint256 liquidationThreshold) = SolvencyV2.calculateLTVs(\\n            SolvencyV2.SolvencyParams(\\n                siloRepository,\\n                ISilo(address(this)),\\n                assets,\\n                assetsStates,\\n                _user\\n            ),\\n            SolvencyV2.TypeofLTV.LiquidationThreshold\\n        );\\n\\n        return userLTV <= liquidationThreshold;\\n    }\\n\\n    /// @dev Amount of token that is available for borrowing.\\n    /// @param _silo Silo address from which to read data\\n    /// @param _asset asset address for which to read data\\n    /// @return Silo liquidity\\n    function liquidity(ISilo _silo, address _asset) external view returns (uint256) {\\n        return ERC20(_asset).balanceOf(address(_silo)) - _silo.assetStorage(_asset).collateralOnlyDeposits;\\n    }\\n\\n    /// @notice Get amount of asset token that has been deposited to Silo\\n    /// @dev It reads directly from storage so interest generated between last update and now is not taken for account\\n    /// @param _silo Silo address from which to read data\\n    /// @param _asset asset address for which to read data\\n    /// @return amount of all deposits made for given asset\\n    function totalDeposits(ISilo _silo, address _asset) external view returns (uint256) {\\n        return _silo.utilizationData(_asset).totalDeposits;\\n    }\\n\\n    /// @notice Get amount of asset token that has been deposited to Silo with option \\\"collateralOnly\\\"\\n    /// @dev It reads directly from storage so interest generated between last update and now is not taken for account\\n    /// @param _silo Silo address from which to read data\\n    /// @param _asset asset address for which to read data\\n    /// @return amount of all \\\"collateralOnly\\\" deposits made for given asset\\n    function collateralOnlyDeposits(ISilo _silo, address _asset) external view returns (uint256) {\\n        return _silo.assetStorage(_asset).collateralOnlyDeposits;\\n    }\\n\\n    /// @notice Get amount of asset that has been borrowed\\n    /// @dev It reads directly from storage so interest generated between last update and now is not taken for account\\n    /// @param _silo Silo address from which to read data\\n    /// @param _asset asset address for which to read data\\n    /// @return amount of asset that has been borrowed\\n    function totalBorrowAmount(ISilo _silo, address _asset) external view returns (uint256) {\\n        return _silo.assetStorage(_asset).totalBorrowAmount;\\n    }\\n\\n    /// @notice Get amount of fees earned by protocol to date\\n    /// @dev It reads directly from storage so interest generated between last update and now is not taken for account\\n    /// @param _silo Silo address from which to read data\\n    /// @param _asset asset address for which to read data\\n    /// @return amount of fees earned by protocol to date\\n    function protocolFees(ISilo _silo, address _asset) external view returns (uint256) {\\n        return _silo.interestData(_asset).protocolFees;\\n    }\\n\\n    /// @notice Returns Loan-To-Value for an account\\n    /// @dev Each Silo has multiple asset markets (bridge assets + unique asset). This function calculates\\n    /// a sum of all deposits and all borrows denominated in quote token. Returns fraction between borrow value\\n    /// and deposit value with 18 decimals.\\n    /// @param _silo Silo address from which to read data\\n    /// @param _user wallet address for which LTV is calculated\\n    /// @return userLTV user current LTV with 18 decimals\\n    function getUserLTV(ISilo _silo, address _user) external view returns (uint256 userLTV) {\\n        (address[] memory assets, ISilo.AssetStorage[] memory assetsStates) = _silo.getAssetsWithState();\\n\\n        (userLTV, ) = SolvencyV2.calculateLTVs(\\n            SolvencyV2.SolvencyParams(\\n                siloRepository,\\n                _silo,\\n                assets,\\n                assetsStates,\\n                _user\\n            ),\\n            SolvencyV2.TypeofLTV.MaximumLTV\\n        );\\n    }\\n\\n    /// @notice Get totalSupply of debt token\\n    /// @dev Debt token represents a share in total debt of given asset\\n    /// @param _silo Silo address from which to read data\\n    /// @param _asset asset address for which to read data\\n    /// @return totalSupply of debt token\\n    function totalBorrowShare(ISilo _silo, address _asset) external view returns (uint256) {\\n        return _silo.assetStorage(_asset).debtToken.totalSupply();\\n    }\\n\\n    /// @notice Calculates current borrow amount for user with interest\\n    /// @dev Interest is calculated based on the provided timestamp with is expected to be current time.\\n    /// @param _silo Silo address from which to read data\\n    /// @param _asset token address for which calculation are done\\n    /// @param _user account for which calculation are done\\n    /// @param _timestamp timestamp used for interest calculations\\n    /// @return total amount of asset user needs to repay at provided timestamp\\n    function getBorrowAmount(ISilo _silo, address _asset, address _user, uint256 _timestamp)\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        return SolvencyV2.getUserBorrowAmount(\\n            _silo.assetStorage(_asset),\\n            _user,\\n            SolvencyV2.getRcomp(_silo, siloRepository, _asset, _timestamp)\\n        );\\n    }\\n\\n    /// @notice Get debt token balance of a user\\n    /// @dev Debt token represents a share in total debt of given asset. This method calls balanceOf(_user)\\n    /// on that token.\\n    /// @param _silo Silo address from which to read data\\n    /// @param _asset asset address for which to read data\\n    /// @param _user wallet address for which to read data\\n    /// @return balance of debt token of given user\\n    function borrowShare(ISilo _silo, address _asset, address _user) external view returns (uint256) {\\n        return _silo.assetStorage(_asset).debtToken.balanceOf(_user);\\n    }\\n\\n    /// @notice Get underlying balance of all deposits of given token of given user including \\\"collateralOnly\\\"\\n    /// deposits\\n    /// @dev It reads directly from storage so interest generated between last update and now is not taken for account\\n    /// @param _silo Silo address from which to read data\\n    /// @param _asset asset address for which to read data\\n    /// @param _user wallet address for which to read data\\n    /// @return balance of underlying tokens for the given user\\n    function collateralBalanceOfUnderlying(ISilo _silo, address _asset, address _user) external view returns (uint256) {\\n        ISilo.AssetStorage memory _state = _silo.assetStorage(_asset);\\n\\n        // Overflow shouldn't happen if the underlying token behaves correctly, as the total supply of underlying\\n        // tokens can't overflow by definition\\n        unchecked {\\n            return balanceOfUnderlying(_state.totalDeposits, _state.collateralToken, _user) +\\n                balanceOfUnderlying(_state.collateralOnlyDeposits, _state.collateralOnlyToken, _user);\\n        }\\n    }\\n\\n    /// @notice Get amount of debt of underlying token for given user\\n    /// @dev It reads directly from storage so interest generated between last update and now is not taken for account\\n    /// @param _silo Silo address from which to read data\\n    /// @param _asset asset address for which to read data\\n    /// @param _user wallet address for which to read data\\n    /// @return balance of underlying token owed\\n    function debtBalanceOfUnderlying(ISilo _silo, address _asset, address _user) external view returns (uint256) {\\n        ISilo.AssetStorage memory _state = _silo.assetStorage(_asset);\\n\\n        return balanceOfUnderlying(_state.totalBorrowAmount, _state.debtToken, _user);\\n    }\\n\\n    /// @notice Calculate value of collateral asset for user\\n    /// @dev It dynamically adds interest earned. Takes for account collateral only deposits as well.\\n    /// @param _silo Silo address from which to read data\\n    /// @param _user account for which calculation are done\\n    /// @param _asset token address for which calculation are done\\n    /// @return value of collateral denominated in quote token with 18 decimal\\n    function calculateCollateralValue(ISilo _silo, address _user, address _asset)\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        IPriceProvidersRepository priceProviderRepo = siloRepository.priceProvidersRepository();\\n        ISilo.AssetStorage memory assetStorage = _silo.assetStorage(_asset);\\n\\n        uint256 assetPrice = priceProviderRepo.getPrice(_asset);\\n        uint8 assetDecimals = ERC20(_asset).decimals();\\n        uint256 userCollateralTokenBalance = assetStorage.collateralToken.balanceOf(_user);\\n        uint256 userCollateralOnlyTokenBalance = assetStorage.collateralOnlyToken.balanceOf(_user);\\n\\n        uint256 assetAmount = SolvencyV2.getUserCollateralAmount(\\n            assetStorage,\\n            userCollateralTokenBalance,\\n            userCollateralOnlyTokenBalance,\\n            SolvencyV2.getRcomp(_silo, siloRepository, _asset, block.timestamp),\\n            siloRepository\\n        );\\n\\n        return assetAmount.toValue(assetPrice, assetDecimals);\\n    }\\n\\n    /// @notice Calculate value of borrowed asset by user\\n    /// @dev It dynamically adds interest earned to borrowed amount\\n    /// @param _silo Silo address from which to read data\\n    /// @param _user account for which calculation are done\\n    /// @param _asset token address for which calculation are done\\n    /// @return value of debt denominated in quote token with 18 decimal\\n    function calculateBorrowValue(ISilo _silo, address _user, address _asset)\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        IPriceProvidersRepository priceProviderRepo = siloRepository.priceProvidersRepository();\\n        uint256 assetPrice = priceProviderRepo.getPrice(_asset);\\n        uint256 assetDecimals = ERC20(_asset).decimals();\\n\\n        uint256 rcomp = SolvencyV2.getRcomp(_silo, siloRepository, _asset, block.timestamp);\\n        uint256 borrowAmount = SolvencyV2.getUserBorrowAmount(_silo.assetStorage(_asset), _user, rcomp);\\n\\n        return borrowAmount.toValue(assetPrice, assetDecimals);\\n    }\\n\\n    /// @notice Get combined liquidation threshold for a user\\n    /// @dev Methodology for calculating liquidation threshold is as follows. Each Silo is combined form multiple\\n    /// assets (bridge assets + unique asset). Each of these assets may have different liquidation threshold.\\n    /// That means effective liquidation threshold must be calculated per asset based on current deposits and\\n    /// borrows of given account.\\n    /// @param _silo Silo address from which to read data\\n    /// @param _user wallet address for which to read data\\n    /// @return liquidationThreshold liquidation threshold of given user\\n    function getUserLiquidationThreshold(ISilo _silo, address _user)\\n        external\\n        view\\n        returns (uint256 liquidationThreshold)\\n    {\\n        (address[] memory assets, ISilo.AssetStorage[] memory assetsStates) = _silo.getAssetsWithState();\\n\\n        liquidationThreshold = SolvencyV2.calculateLTVLimit(\\n            SolvencyV2.SolvencyParams(\\n                siloRepository,\\n                _silo,\\n                assets,\\n                assetsStates,\\n                _user\\n            ),\\n            SolvencyV2.TypeofLTV.LiquidationThreshold\\n        );\\n    }\\n\\n    /// @notice Get combined maximum Loan-To-Value for a user\\n    /// @dev Methodology for calculating maximum LTV is as follows. Each Silo is combined form multiple assets\\n    /// (bridge assets + unique asset). Each of these assets may have different maximum Loan-To-Value for\\n    /// opening borrow position. That means effective maximum LTV must be calculated per asset based on\\n    /// current deposits and borrows of given account.\\n    /// @param _silo Silo address from which to read data\\n    /// @param _user wallet address for which to read data\\n    /// @return maximumLTV Maximum Loan-To-Value of given user\\n    function getUserMaximumLTV(ISilo _silo, address _user) external view returns (uint256 maximumLTV) {\\n        (address[] memory assets, ISilo.AssetStorage[] memory assetsStates) = _silo.getAssetsWithState();\\n\\n        maximumLTV = SolvencyV2.calculateLTVLimit(\\n            SolvencyV2.SolvencyParams(\\n                siloRepository,\\n                _silo,\\n                assets,\\n                assetsStates,\\n                _user\\n            ),\\n            SolvencyV2.TypeofLTV.MaximumLTV\\n        );\\n    }\\n\\n    /// @notice Check if user is in debt\\n    /// @param _silo Silo address from which to read data\\n    /// @param _user wallet address for which to read data\\n    /// @return TRUE if user borrowed any amount of any asset, otherwise FALSE\\n    function inDebt(ISilo _silo, address _user) external view returns (bool) {\\n        address[] memory allAssets = _silo.getAssets();\\n\\n        for (uint256 i; i < allAssets.length;) {\\n            if (_silo.assetStorage(allAssets[i]).debtToken.balanceOf(_user) != 0) return true;\\n\\n            unchecked {\\n                i++;\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    /// @notice Check if user has position (debt or borrow) in any asset\\n    /// @param _silo Silo address from which to read data\\n    /// @param _user wallet address for which to read data\\n    /// @return TRUE if user has position (debt or borrow) in any asset\\n    function hasPosition(ISilo _silo, address _user) external view returns (bool) {\\n        (, ISilo.AssetStorage[] memory assetsStorage) = _silo.getAssetsWithState();\\n\\n        for (uint256 i; i < assetsStorage.length; i++) {\\n            if (assetsStorage[i].debtToken.balanceOf(_user) != 0) return true;\\n            if (assetsStorage[i].collateralToken.balanceOf(_user) != 0) return true;\\n            if (assetsStorage[i].collateralOnlyToken.balanceOf(_user) != 0) return true;\\n        }\\n\\n        return false;\\n    }\\n\\n    /// @notice Calculates fraction between borrowed amount and the current liquidity of tokens for given asset\\n    /// denominated in percentage\\n    /// @dev Utilization is calculated current values in storage so it does not take for account earned\\n    /// interest and ever-increasing total borrow amount. It assumes `Model.DP()` = 100%.\\n    /// @param _silo Silo address from which to read data\\n    /// @param _asset asset address\\n    /// @return utilization value\\n    function getUtilization(ISilo _silo, address _asset) external view returns (uint256) {\\n        ISilo.UtilizationData memory data = ISilo(_silo).utilizationData(_asset);\\n\\n        return EasyMathV2.calculateUtilization(\\n            getModel(_silo, _asset).DP(),\\n            data.totalDeposits,\\n            data.totalBorrowAmount\\n        );\\n    }\\n\\n    /// @notice Yearly interest rate for depositing asset token, dynamically calculated for current block timestamp\\n    /// @param _silo Silo address from which to read data\\n    /// @param _asset asset address\\n    /// @return APY with 18 decimals\\n    function depositAPY(ISilo _silo, address _asset) external view returns (uint256) {\\n        uint256 dp = getModel(_silo, _asset).DP();\\n\\n        // amount of deposits in asset decimals\\n        uint256 totalDepositsAmount = totalDepositsWithInterest(_silo, _asset);\\n\\n        if (totalDepositsAmount == 0) return 0;\\n\\n        // amount of debt generated per year in asset decimals\\n        uint256 generatedDebtAmount = totalBorrowAmountWithInterest(_silo, _asset) * borrowAPY(_silo, _asset) / dp;\\n\\n        return generatedDebtAmount * SolvencyV2._PRECISION_DECIMALS / totalDepositsAmount;\\n    }\\n\\n    /// @notice Calculate amount of entry fee for given amount\\n    /// @param _amount amount for which to calculate fee\\n    /// @return Amount of token fee to be paid\\n    function calcFee(uint256 _amount) external view returns (uint256) {\\n        uint256 entryFee = siloRepository.entryFee();\\n        if (entryFee == 0) return 0; // no fee\\n\\n        unchecked {\\n            // If we overflow on multiplication it should not revert tx, we will get lower fees\\n            return _amount * entryFee / SolvencyV2._PRECISION_DECIMALS;\\n        }\\n    }\\n\\n    /// @dev Method for sanity check\\n    /// @return always true\\n    function lensPing() external pure returns (bytes4) {\\n        return this.lensPing.selector;\\n    }\\n\\n    /// @notice Yearly interest rate for borrowing asset token, dynamically calculated for current block timestamp\\n    /// @param _silo Silo address from which to read data\\n    /// @param _asset asset address\\n    /// @return APY with 18 decimals\\n    function borrowAPY(ISilo _silo, address _asset) public view returns (uint256) {\\n        return getModel(_silo, _asset).getCurrentInterestRate(address(_silo), _asset, block.timestamp);\\n    }\\n\\n    /// @notice returns total deposits with interest dynamically calculated at current block timestamp\\n    /// @param _asset asset address\\n    /// @return _totalDeposits total deposits amount with interest\\n    function totalDepositsWithInterest(ISilo _silo, address _asset) public view returns (uint256 _totalDeposits) {\\n        uint256 rcomp = getModel(_silo, _asset).getCompoundInterestRate(address(_silo), _asset, block.timestamp);\\n        uint256 protocolShareFee = siloRepository.protocolShareFee();\\n        ISilo.UtilizationData memory data = _silo.utilizationData(_asset);\\n\\n        return SolvencyV2.totalDepositsWithInterest(\\n            data.totalDeposits, data.totalBorrowAmount, protocolShareFee, rcomp\\n        );\\n    }\\n\\n    /// @notice Calculates current deposit (with interest) for user\\n    /// Collateral only deposits are not counted here. To get collateral only deposit call:\\n    /// `_silo.assetStorage(_asset).collateralOnlyDeposits`\\n    /// @dev Interest is calculated based on the provided timestamp with is expected to be current time.\\n    /// @param _silo Silo address from which to read data\\n    /// @param _asset token address for which calculation are done\\n    /// @param _user account for which calculation are done\\n    /// @param _timestamp timestamp used for interest calculations\\n    /// @return totalUserDeposits amount of asset user posses\\n    function getDepositAmount(ISilo _silo, address _asset, address _user, uint256 _timestamp)\\n        public\\n        view\\n        returns (uint256 totalUserDeposits)\\n    {\\n        ISilo.AssetStorage memory data = _silo.assetStorage(_asset);\\n\\n        uint256 share = data.collateralToken.balanceOf(_user);\\n\\n        if (share == 0) {\\n            return 0;\\n        }\\n\\n        uint256 rcomp = getModel(_silo, _asset).getCompoundInterestRate(address(_silo), _asset, _timestamp);\\n        uint256 protocolShareFee = siloRepository.protocolShareFee();\\n\\n        uint256 assetTotalDeposits = SolvencyV2.totalDepositsWithInterest(\\n            data.totalDeposits, data.totalBorrowAmount, protocolShareFee, rcomp\\n        );\\n\\n        return share.toAmount(assetTotalDeposits, data.collateralToken.totalSupply());\\n    }\\n\\n    /// @notice returns total borrow amount with interest dynamically calculated at current block timestamp\\n    /// @param _asset asset address\\n    /// @return _totalBorrowAmount total deposits amount with interest\\n    function totalBorrowAmountWithInterest(ISilo _silo, address _asset)\\n        public\\n        view\\n        returns (uint256 _totalBorrowAmount)\\n    {\\n        uint256 rcomp = SolvencyV2.getRcomp(_silo, siloRepository, _asset, block.timestamp);\\n        ISilo.UtilizationData memory data = _silo.utilizationData(_asset);\\n\\n        return SolvencyV2.totalBorrowAmountWithInterest(data.totalBorrowAmount, rcomp);\\n    }\\n\\n    /// @notice Get underlying balance of collateral or debt token\\n    /// @dev You can think about debt and collateral tokens as cToken in compound. They represent ownership of\\n    /// debt or collateral in given Silo. This method converts that ownership to exact amount of underlying token.\\n    /// @param _assetTotalDeposits Total amount of assets that has been deposited or borrowed. For collateral token,\\n    /// use `totalDeposits` to get this value. For debt token, use `totalBorrowAmount` to get this value.\\n    /// @param _shareToken share token address. It's the collateral and debt share token address. You can find\\n    /// these addresses in:\\n    /// - `ISilo.AssetStorage.collateralToken`\\n    /// - `ISilo.AssetStorage.collateralOnlyToken`\\n    /// - `ISilo.AssetStorage.debtToken`\\n    /// @param _user wallet address for which to read data\\n    /// @return balance of underlying token deposited or borrowed of given user\\n    function balanceOfUnderlying(uint256 _assetTotalDeposits, IShareToken _shareToken, address _user)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        uint256 share = _shareToken.balanceOf(_user);\\n        return share.toAmount(_assetTotalDeposits, _shareToken.totalSupply());\\n    }\\n\\n    /// @dev gets interest rates model object\\n    /// @param _silo Silo address from which to read data\\n    /// @param _asset asset for which to calculate interest rate\\n    /// @return IInterestRateModel interest rates model object\\n    function getModel(ISilo _silo, address _asset) public view returns (IInterestRateModel) {\\n        return IInterestRateModel(siloRepository.getInterestRateModel(address(_silo), _asset));\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_repository\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_chainlinkPriceProvider\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_lens\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_exchangeProxy\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"contract IMagician\",\"name\":\"magician\",\"type\":\"address\"}],\"internalType\":\"struct LiquidationHelper.MagicianConfig[]\",\"name\":\"_magicians\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"contract IPriceProvider\",\"name\":\"provider\",\"type\":\"address\"},{\"internalType\":\"contract ISwapper\",\"name\":\"swapper\",\"type\":\"address\"}],\"internalType\":\"struct LiquidationHelper.SwapperConfig[]\",\"name\":\"_swappers\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"_baseCost\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AddressZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ApprovalFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FallbackPriceProviderNotSet\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidChainlinkProviders\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidMagicianConfig\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidScenario\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSiloLens\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSiloRepository\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSwapperConfig\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidTowardsAssetConvertion\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"inTheRed\",\"type\":\"uint256\"}],\"name\":\"LiquidationNotProfitable\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MagicianNotFound\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Max0xSwapsIs2\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotSilo\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PriceProviderNotFound\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RepayFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SwapAmountInFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SwapAmountOutFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SwapperNotFound\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TargetNotExchangeProxy\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UsersMustMatchSilos\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sellToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"buyToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"boughtAmount\",\"type\":\"uint256\"}],\"name\":\"BoughtTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"silo\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"earned\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"estimatedEarnings\",\"type\":\"bool\"}],\"name\":\"LiquidationExecuted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"contract IMagician\",\"name\":\"magician\",\"type\":\"address\"}],\"name\":\"MagicianConfigured\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract IPriceProvider\",\"name\":\"provider\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"contract ISwapper\",\"name\":\"swapper\",\"type\":\"address\"}],\"name\":\"SwapperConfigured\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CHAINLINK_PRICE_PROVIDER\",\"outputs\":[{\"internalType\":\"contract ChainlinkV3PriceProvider\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"EXCHANGE_PROXY\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LENS\",\"outputs\":[{\"internalType\":\"contract SiloLens\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PRICE_PROVIDERS_REPOSITORY\",\"outputs\":[{\"internalType\":\"contract IPriceProvidersRepository\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"QUOTE_TOKEN\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SILO_REPOSITORY\",\"outputs\":[{\"internalType\":\"contract ISiloRepository\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_users\",\"type\":\"address[]\"},{\"internalType\":\"contract ISilo[]\",\"name\":\"_silos\",\"type\":\"address[]\"}],\"name\":\"checkDebt\",\"outputs\":[{\"internalType\":\"bool[]\",\"name\":\"\",\"type\":\"bool[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_users\",\"type\":\"address[]\"},{\"internalType\":\"contract ISilo[]\",\"name\":\"_silos\",\"type\":\"address[]\"}],\"name\":\"checkSolvency\",\"outputs\":[{\"internalType\":\"bool[]\",\"name\":\"\",\"type\":\"bool[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_gasStart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_earnedEth\",\"type\":\"uint256\"}],\"name\":\"ensureTxIsProfitable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"txFee\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"contract ISilo\",\"name\":\"_silo\",\"type\":\"address\"},{\"internalType\":\"enum ILiquidationHelper.LiquidationScenario\",\"name\":\"_scenario\",\"type\":\"uint8\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"sellToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"allowanceTarget\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"swapCallData\",\"type\":\"bytes\"}],\"internalType\":\"struct ZeroExSwap.SwapInput0x[]\",\"name\":\"_swapsInputs0x\",\"type\":\"tuple[]\"}],\"name\":\"executeLiquidation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sellToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_swapCallData\",\"type\":\"bytes\"}],\"name\":\"fillQuote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"}],\"name\":\"findPriceProvider\",\"outputs\":[{\"internalType\":\"contract IPriceProvider\",\"name\":\"priceProvider\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"}],\"name\":\"liquidationSupported\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"magicians\",\"outputs\":[{\"internalType\":\"contract IMagician\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"contract IMagician\",\"name\":\"magician\",\"type\":\"address\"}],\"internalType\":\"struct LiquidationHelper.MagicianConfig[]\",\"name\":\"_magicians\",\"type\":\"tuple[]\"}],\"name\":\"setMagicians\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"contract IPriceProvider\",\"name\":\"provider\",\"type\":\"address\"},{\"internalType\":\"contract ISwapper\",\"name\":\"swapper\",\"type\":\"address\"}],\"internalType\":\"struct LiquidationHelper.SwapperConfig[]\",\"name\":\"_swappers\",\"type\":\"tuple[]\"}],\"name\":\"setSwappers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_assets\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_receivedCollaterals\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_shareAmountsToRepaid\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"_flashReceiverData\",\"type\":\"bytes\"}],\"name\":\"siloLiquidationCallback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IPriceProvider\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"swappers\",\"outputs\":[{\"internalType\":\"contract ISwapper\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "LiquidationHelper", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000d998c35b7900b344bbbe6555cc11576942cf309d000000000000000000000000e37b8c83138caf12e57632d19c06eb561d47e4230000000000000000000000000e466fc22386997dac23d1f89a43ecb2cb1e76e90000000000000000000000001111111254eeb25477b68fb85ed929f73a96058200000000000000000000000000000000000000000000000000000000000000e000000000000000000000000000000000000000000000000000000000000004c00000000000000000000000000000000000000000000000000000000000005208000000000000000000000000000000000000000000000000000000000000000f0000000000000000000000007f39c581f595b53c5cb19bd0b3f8da6c935e2ca0000000000000000000000000a2ed88339701c209f3a72215164f0d97e7403a05000000000000000000000000ae7ab96520de3a18e5e111b5eaab095312d7fe84000000000000000000000000c07b94b2a1f1bfc7381ffc72fe217063bf6946fb0000000000000000000000000ab87046fbb341d058f17cbc4c1133f25a20a52f000000000000000000000000d4240aed295ff0fc2d76b3160e5d63692ba7213300000000000000000000000064aa3364f17a4d01c6f1751fd97c2bd3d7e7f1d5000000000000000000000000d4bdddca31668f37dba5115f68422d043cb5ee08000000000000000000000000d7c9f0e536dc865ae858b0c0453fe76d13c3beac000000000000000000000000138f032e839f247e5fa913e7ba52bea509c1622500000000000000000000000006325440d014e39736583c165c2963ba99faf14e000000000000000000000000bacc38fdd9cd697cd9082dd6a790b58bca30628800000000000000000000000021e27a5e5513d6e65c4f830167390997aa84843a000000000000000000000000bacc38fdd9cd697cd9082dd6a790b58bca3062880000000000000000000000005b6c539b224014a09b3388e51caaa8e354c959c80000000000000000000000000527e1aa1bdf0f6942bb1983a09f81dc34df8e980000000000000000000000003175df0976dfa876431c2e9ee6bc45b65d3473cc000000000000000000000000e067b967a36a136084eb9df0149dde64f01ea7d1000000000000000000000000ed279fdd11ca84beef15af5d39bb4d4bee23f0ca0000000000000000000000004166487056a922d784b073d4d928a516b074b719000000000000000000000000a600df1fb4c79a668c4d9e3016504d28bfaaff1a00000000000000000000000076577efdcb4539b7d0afe6f31d3c76d546e3c79d0000000000000000000000003d077847c98e3f370d3355e4ed3aedd4e92cfe5300000000000000000000000076577efdcb4539b7d0afe6f31d3c76d546e3c79d000000000000000000000000fcdeee2bfeae88e749e88a628e2c3401ec5eda3c00000000000000000000000076577efdcb4539b7d0afe6f31d3c76d546e3c79d000000000000000000000000041dfd7e8497b3b47b2260fc0ced9443c67c9ed200000000000000000000000076577efdcb4539b7d0afe6f31d3c76d546e3c79d000000000000000000000000470f9f350642edf3cb3f2a6eb4569c0219386f0b00000000000000000000000076577efdcb4539b7d0afe6f31d3c76d546e3c79d00000000000000000000000000000000000000000000000000000000000000040000000000000000000000009d46f86516d6083aca3f9850d060cb62cd0f6924000000000000000000000000ff36fdf7de2aa239b0295d406a6ca5c25c6c9e99000000000000000000000000fae64471ae04068e872c6a73c9f5a255c37ddbdc00000000000000000000000096fbf6f0a431e64e05e22e5dbf6f1d92e5dda81f0000000000000000000000002f0a401966219351887a608493954a7078ef1bc000000000000000000000000096fbf6f0a431e64e05e22e5dbf6f1d92e5dda81f0000000000000000000000002f1aa93249bcc0df7d89739f86308c7a270f5eed000000000000000000000000a40158686a5bdbe6c3ea8a32f6e4e045c1c13f90", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}