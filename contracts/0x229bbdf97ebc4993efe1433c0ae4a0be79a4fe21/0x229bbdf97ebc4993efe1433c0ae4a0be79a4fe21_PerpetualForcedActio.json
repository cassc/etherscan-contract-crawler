{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"ActionHash.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2019-2023 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.12;\\n\\nimport \\\"MainStorage.sol\\\";\\nimport \\\"LibConstants.sol\\\";\\n\\n/*\\n  Calculation action hash for the various forced actions in a generic manner.\\n*/\\ncontract ActionHash is MainStorage, LibConstants {\\n    function getActionHash(string memory actionName, bytes memory packedActionParameters)\\n        internal\\n        pure\\n        returns (bytes32 actionHash)\\n    {\\n        actionHash = keccak256(abi.encodePacked(actionName, packedActionParameters));\\n    }\\n\\n    function setActionHash(bytes32 actionHash, bool premiumCost) internal {\\n        // The rate of forced trade requests is restricted.\\n        // First restriction is by capping the number of requests in a block.\\n        // User can override this cap by requesting with a permium flag set,\\n        // in this case, the gas cost is high (~1M) but no \\\"technical\\\" limit is set.\\n        // However, the high gas cost creates an obvious limitation due to the block gas limit.\\n        if (premiumCost) {\\n            for (uint256 i = 0; i < 21129; i++) {}\\n        } else {\\n            require(\\n                forcedRequestsInBlock[block.number] < MAX_FORCED_ACTIONS_REQS_PER_BLOCK,\\n                \\\"MAX_REQUESTS_PER_BLOCK_REACHED\\\"\\n            );\\n            forcedRequestsInBlock[block.number] += 1;\\n        }\\n        forcedActionRequests[actionHash] = block.timestamp;\\n        actionHashList.push(actionHash);\\n    }\\n\\n    function getActionCount() external view returns (uint256) {\\n        return actionHashList.length;\\n    }\\n\\n    function getActionHashByIndex(uint256 actionIndex) external view returns (bytes32) {\\n        require(actionIndex < actionHashList.length, \\\"ACTION_INDEX_TOO_HIGH\\\");\\n        return actionHashList[actionIndex];\\n    }\\n}\\n\"\r\n    },\r\n    \"Addresses.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2019-2023 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.12;\\n\\n/*\\n  Common Utility Libraries.\\n  I. Addresses (extending address).\\n*/\\nlibrary Addresses {\\n    /*\\n      Note: isContract function has some known limitation.\\n      See https://github.com/OpenZeppelin/\\n      openzeppelin-contracts/blob/master/contracts/utils/Address.sol.\\n    */\\n    function isContract(address account) internal view returns (bool) {\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    function performEthTransfer(address recipient, uint256 amount) internal {\\n        if (amount == 0) return;\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\"); // NOLINT: low-level-calls.\\n        require(success, \\\"ETH_TRANSFER_FAILED\\\");\\n    }\\n\\n    /*\\n      Safe wrapper around ERC20/ERC721 calls.\\n      This is required because many deployed ERC20 contracts don't return a value.\\n      See https://github.com/ethereum/solidity/issues/4116.\\n    */\\n    function safeTokenContractCall(address tokenAddress, bytes memory callData) internal {\\n        require(isContract(tokenAddress), \\\"BAD_TOKEN_ADDRESS\\\");\\n        // NOLINTNEXTLINE: low-level-calls.\\n        (bool success, bytes memory returndata) = tokenAddress.call(callData);\\n        require(success, string(returndata));\\n\\n        if (returndata.length > 0) {\\n            require(abi.decode(returndata, (bool)), \\\"TOKEN_OPERATION_FAILED\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"ECDSA.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2019-2023 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.12;\\n\\nimport \\\"EllipticCurve.sol\\\";\\n\\nlibrary ECDSA {\\n    using EllipticCurve for uint256;\\n    uint256 constant FIELD_PRIME =\\n        0x800000000000011000000000000000000000000000000000000000000000001;\\n    uint256 constant ALPHA = 1;\\n    uint256 constant BETA =\\n        3141592653589793238462643383279502884197169399375105820974944592307816406665;\\n    uint256 constant EC_ORDER =\\n        3618502788666131213697322783095070105526743751716087489154079457884512865583;\\n    uint256 constant N_ELEMENT_BITS_ECDSA = 251;\\n    uint256 constant EC_GEN_X = 0x1ef15c18599971b7beced415a40f0c7deacfd9b0d1819e03d723d8bc943cfca;\\n    uint256 constant EC_GEN_Y = 0x5668060aa49730b7be4801df46ec62de53ecd11abe43a32873000c36e8dc1f;\\n\\n    function verify(\\n        uint256 msgHash,\\n        uint256 r,\\n        uint256 s,\\n        uint256 pubX,\\n        uint256 pubY\\n    ) internal pure {\\n        require(msgHash % EC_ORDER == msgHash, \\\"msgHash out of range\\\");\\n        require((1 <= s) && (s < EC_ORDER), \\\"s out of range\\\");\\n        uint256 w = s.invMod(EC_ORDER);\\n        require((1 <= r) && (r < (1 << N_ELEMENT_BITS_ECDSA)), \\\"r out of range\\\");\\n        require((1 <= w) && (w < (1 << N_ELEMENT_BITS_ECDSA)), \\\"w out of range\\\");\\n\\n        // Verify that pub is a valid point (y^2 = x^3 + x + BETA).\\n        {\\n            uint256 x3 = mulmod(mulmod(pubX, pubX, FIELD_PRIME), pubX, FIELD_PRIME);\\n            uint256 y2 = mulmod(pubY, pubY, FIELD_PRIME);\\n            require(\\n                y2 == addmod(addmod(x3, pubX, FIELD_PRIME), BETA, FIELD_PRIME),\\n                \\\"INVALID_STARK_KEY\\\"\\n            );\\n        }\\n\\n        // Verify signature.\\n        uint256 b_x;\\n        uint256 b_y;\\n        {\\n            (uint256 zG_x, uint256 zG_y) = msgHash.ecMul(EC_GEN_X, EC_GEN_Y, ALPHA, FIELD_PRIME);\\n\\n            (uint256 rQ_x, uint256 rQ_y) = r.ecMul(pubX, pubY, ALPHA, FIELD_PRIME);\\n\\n            (b_x, b_y) = zG_x.ecAdd(zG_y, rQ_x, rQ_y, ALPHA, FIELD_PRIME);\\n        }\\n        (uint256 res_x, ) = w.ecMul(b_x, b_y, ALPHA, FIELD_PRIME);\\n\\n        require(res_x == r, \\\"INVALID_STARK_SIGNATURE\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"EllipticCurve.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2019-2023 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: MIT.\\n/*\\n  MIT License\\n\\n  Copyright (c) 2019 Witnet Project\\n\\n  Permission is hereby granted, free of charge, to any person obtaining a copy\\n  of this software and associated documentation files (the \\\"Software\\\"), to deal\\n  in the Software without restriction, including without limitation the rights\\n  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n  copies of the Software, and to permit persons to whom the Software is\\n  furnished to do so, subject to the following conditions:\\n\\n  The above copyright notice and this permission notice shall be included in all\\n  copies or substantial portions of the Software.\\n\\n  THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n  SOFTWARE.\\n*/\\n// https://github.com/witnet/elliptic-curve-solidity/blob/master/contracts/EllipticCurve.sol\\npragma solidity >=0.5.3 <0.7.0; // NOLINT pragma.\\n\\n/**\\n * @title Elliptic Curve Library\\n * @dev Library providing arithmetic operations over elliptic curves.\\n * This library does not check whether the inserted points belong to the curve\\n * `isOnCurve` function should be used by the library user to check the aforementioned statement.\\n * @author Witnet Foundation\\n */\\nlibrary EllipticCurve {\\n\\n  // Pre-computed constant for 2 ** 255\\n  uint256 constant private U255_MAX_PLUS_1 = 57896044618658097711785492504343953926634992332820282019728792003956564819968;\\n\\n  /// @dev Modular euclidean inverse of a number (mod p).\\n  /// @param _x The number\\n  /// @param _pp The modulus\\n  /// @return q such that x*q = 1 (mod _pp)\\n  function invMod(uint256 _x, uint256 _pp) internal pure returns (uint256) {\\n    require(_x != 0 && _x != _pp && _pp != 0, \\\"Invalid number\\\");\\n    uint256 q = 0;\\n    uint256 newT = 1;\\n    uint256 r = _pp;\\n    uint256 t;\\n    while (_x != 0) {\\n      t = r / _x;\\n      (q, newT) = (newT, addmod(q, (_pp - mulmod(t, newT, _pp)), _pp));\\n      (r, _x) = (_x, r - t * _x);\\n    }\\n\\n    return q;\\n  }\\n\\n  /// @dev Modular exponentiation, b^e % _pp.\\n  /// Source: https://github.com/androlo/standard-contracts/blob/master/contracts/src/crypto/ECCMath.sol\\n  /// @param _base base\\n  /// @param _exp exponent\\n  /// @param _pp modulus\\n  /// @return r such that r = b**e (mod _pp)\\n  function expMod(uint256 _base, uint256 _exp, uint256 _pp) internal pure returns (uint256) {\\n    require(_pp!=0, \\\"Modulus is zero\\\");\\n\\n    if (_base == 0)\\n      return 0;\\n    if (_exp == 0)\\n      return 1;\\n\\n    uint256 r = 1;\\n    uint256 bit = U255_MAX_PLUS_1;\\n    assembly {\\n      for { } gt(bit, 0) { }{\\n        r := mulmod(mulmod(r, r, _pp), exp(_base, iszero(iszero(and(_exp, bit)))), _pp)\\n        r := mulmod(mulmod(r, r, _pp), exp(_base, iszero(iszero(and(_exp, div(bit, 2))))), _pp)\\n        r := mulmod(mulmod(r, r, _pp), exp(_base, iszero(iszero(and(_exp, div(bit, 4))))), _pp)\\n        r := mulmod(mulmod(r, r, _pp), exp(_base, iszero(iszero(and(_exp, div(bit, 8))))), _pp)\\n        bit := div(bit, 16)\\n      }\\n    }\\n\\n    return r;\\n  }\\n\\n  /// @dev Converts a point (x, y, z) expressed in Jacobian coordinates to affine coordinates (x', y', 1).\\n  /// @param _x coordinate x\\n  /// @param _y coordinate y\\n  /// @param _z coordinate z\\n  /// @param _pp the modulus\\n  /// @return (x', y') affine coordinates\\n  function toAffine(\\n    uint256 _x,\\n    uint256 _y,\\n    uint256 _z,\\n    uint256 _pp)\\n  internal pure returns (uint256, uint256)\\n  {\\n    uint256 zInv = invMod(_z, _pp);\\n    uint256 zInv2 = mulmod(zInv, zInv, _pp);\\n    uint256 x2 = mulmod(_x, zInv2, _pp);\\n    uint256 y2 = mulmod(_y, mulmod(zInv, zInv2, _pp), _pp);\\n\\n    return (x2, y2);\\n  }\\n\\n  /// @dev Derives the y coordinate from a compressed-format point x [[SEC-1]](https://www.secg.org/SEC1-Ver-1.0.pdf).\\n  /// @param _prefix parity byte (0x02 even, 0x03 odd)\\n  /// @param _x coordinate x\\n  /// @param _aa constant of curve\\n  /// @param _bb constant of curve\\n  /// @param _pp the modulus\\n  /// @return y coordinate y\\n  function deriveY(\\n    uint8 _prefix,\\n    uint256 _x,\\n    uint256 _aa,\\n    uint256 _bb,\\n    uint256 _pp)\\n  internal pure returns (uint256)\\n  {\\n    require(_prefix == 0x02 || _prefix == 0x03, \\\"Invalid compressed EC point prefix\\\");\\n\\n    // x^3 + ax + b\\n    uint256 y2 = addmod(mulmod(_x, mulmod(_x, _x, _pp), _pp), addmod(mulmod(_x, _aa, _pp), _bb, _pp), _pp);\\n    y2 = expMod(y2, (_pp + 1) / 4, _pp);\\n    // uint256 cmp = yBit ^ y_ & 1;\\n    uint256 y = (y2 + _prefix) % 2 == 0 ? y2 : _pp - y2;\\n\\n    return y;\\n  }\\n\\n  /// @dev Check whether point (x,y) is on curve defined by a, b, and _pp.\\n  /// @param _x coordinate x of P1\\n  /// @param _y coordinate y of P1\\n  /// @param _aa constant of curve\\n  /// @param _bb constant of curve\\n  /// @param _pp the modulus\\n  /// @return true if x,y in the curve, false else\\n  function isOnCurve(\\n    uint _x,\\n    uint _y,\\n    uint _aa,\\n    uint _bb,\\n    uint _pp)\\n  internal pure returns (bool)\\n  {\\n    if (0 == _x || _x >= _pp || 0 == _y || _y >= _pp) {\\n      return false;\\n    }\\n    // y^2\\n    uint lhs = mulmod(_y, _y, _pp);\\n    // x^3\\n    uint rhs = mulmod(mulmod(_x, _x, _pp), _x, _pp);\\n    if (_aa != 0) {\\n      // x^3 + a*x\\n      rhs = addmod(rhs, mulmod(_x, _aa, _pp), _pp);\\n    }\\n    if (_bb != 0) {\\n      // x^3 + a*x + b\\n      rhs = addmod(rhs, _bb, _pp);\\n    }\\n\\n    return lhs == rhs;\\n  }\\n\\n  /// @dev Calculate inverse (x, -y) of point (x, y).\\n  /// @param _x coordinate x of P1\\n  /// @param _y coordinate y of P1\\n  /// @param _pp the modulus\\n  /// @return (x, -y)\\n  function ecInv(\\n    uint256 _x,\\n    uint256 _y,\\n    uint256 _pp)\\n  internal pure returns (uint256, uint256)\\n  {\\n    return (_x, (_pp - _y) % _pp);\\n  }\\n\\n  /// @dev Add two points (x1, y1) and (x2, y2) in affine coordinates.\\n  /// @param _x1 coordinate x of P1\\n  /// @param _y1 coordinate y of P1\\n  /// @param _x2 coordinate x of P2\\n  /// @param _y2 coordinate y of P2\\n  /// @param _aa constant of the curve\\n  /// @param _pp the modulus\\n  /// @return (qx, qy) = P1+P2 in affine coordinates\\n  function ecAdd(\\n    uint256 _x1,\\n    uint256 _y1,\\n    uint256 _x2,\\n    uint256 _y2,\\n    uint256 _aa,\\n    uint256 _pp)\\n    internal pure returns(uint256, uint256)\\n  {\\n    uint x = 0;\\n    uint y = 0;\\n    uint z = 0;\\n\\n    // Double if x1==x2 else add\\n    if (_x1==_x2) {\\n      // y1 = -y2 mod p\\n      if (addmod(_y1, _y2, _pp) == 0) {\\n        return(0, 0);\\n      } else {\\n        // P1 = P2\\n        (x, y, z) = jacDouble(\\n          _x1,\\n          _y1,\\n          1,\\n          _aa,\\n          _pp);\\n      }\\n    } else {\\n      (x, y, z) = jacAdd(\\n        _x1,\\n        _y1,\\n        1,\\n        _x2,\\n        _y2,\\n        1,\\n        _pp);\\n    }\\n    // Get back to affine\\n    return toAffine(\\n      x,\\n      y,\\n      z,\\n      _pp);\\n  }\\n\\n  /// @dev Substract two points (x1, y1) and (x2, y2) in affine coordinates.\\n  /// @param _x1 coordinate x of P1\\n  /// @param _y1 coordinate y of P1\\n  /// @param _x2 coordinate x of P2\\n  /// @param _y2 coordinate y of P2\\n  /// @param _aa constant of the curve\\n  /// @param _pp the modulus\\n  /// @return (qx, qy) = P1-P2 in affine coordinates\\n  function ecSub(\\n    uint256 _x1,\\n    uint256 _y1,\\n    uint256 _x2,\\n    uint256 _y2,\\n    uint256 _aa,\\n    uint256 _pp)\\n  internal pure returns(uint256, uint256)\\n  {\\n    // invert square\\n    (uint256 x, uint256 y) = ecInv(_x2, _y2, _pp);\\n    // P1-square\\n    return ecAdd(\\n      _x1,\\n      _y1,\\n      x,\\n      y,\\n      _aa,\\n      _pp);\\n  }\\n\\n  /// @dev Multiply point (x1, y1, z1) times d in affine coordinates.\\n  /// @param _k scalar to multiply\\n  /// @param _x coordinate x of P1\\n  /// @param _y coordinate y of P1\\n  /// @param _aa constant of the curve\\n  /// @param _pp the modulus\\n  /// @return (qx, qy) = d*P in affine coordinates\\n  function ecMul(\\n    uint256 _k,\\n    uint256 _x,\\n    uint256 _y,\\n    uint256 _aa,\\n    uint256 _pp)\\n  internal pure returns(uint256, uint256)\\n  {\\n    // Jacobian multiplication\\n    (uint256 x1, uint256 y1, uint256 z1) = jacMul(\\n      _k,\\n      _x,\\n      _y,\\n      1,\\n      _aa,\\n      _pp);\\n    // Get back to affine\\n    return toAffine(\\n      x1,\\n      y1,\\n      z1,\\n      _pp);\\n  }\\n\\n  /// @dev Adds two points (x1, y1, z1) and (x2 y2, z2).\\n  /// @param _x1 coordinate x of P1\\n  /// @param _y1 coordinate y of P1\\n  /// @param _z1 coordinate z of P1\\n  /// @param _x2 coordinate x of square\\n  /// @param _y2 coordinate y of square\\n  /// @param _z2 coordinate z of square\\n  /// @param _pp the modulus\\n  /// @return (qx, qy, qz) P1+square in Jacobian\\n  function jacAdd(\\n    uint256 _x1,\\n    uint256 _y1,\\n    uint256 _z1,\\n    uint256 _x2,\\n    uint256 _y2,\\n    uint256 _z2,\\n    uint256 _pp)\\n  internal pure returns (uint256, uint256, uint256)\\n  {\\n    if (_x1==0 && _y1==0)\\n      return (_x2, _y2, _z2);\\n    if (_x2==0 && _y2==0)\\n      return (_x1, _y1, _z1);\\n\\n    // We follow the equations described in https://pdfs.semanticscholar.org/5c64/29952e08025a9649c2b0ba32518e9a7fb5c2.pdf Section 5\\n    uint[4] memory zs; // z1^2, z1^3, z2^2, z2^3\\n    zs[0] = mulmod(_z1, _z1, _pp);\\n    zs[1] = mulmod(_z1, zs[0], _pp);\\n    zs[2] = mulmod(_z2, _z2, _pp);\\n    zs[3] = mulmod(_z2, zs[2], _pp);\\n\\n    // u1, s1, u2, s2\\n    zs = [\\n      mulmod(_x1, zs[2], _pp),\\n      mulmod(_y1, zs[3], _pp),\\n      mulmod(_x2, zs[0], _pp),\\n      mulmod(_y2, zs[1], _pp)\\n    ];\\n\\n    // In case of zs[0] == zs[2] && zs[1] == zs[3], double function should be used\\n    require(zs[0] != zs[2] || zs[1] != zs[3], \\\"Use jacDouble function instead\\\");\\n\\n    uint[4] memory hr;\\n    //h\\n    hr[0] = addmod(zs[2], _pp - zs[0], _pp);\\n    //r\\n    hr[1] = addmod(zs[3], _pp - zs[1], _pp);\\n    //h^2\\n    hr[2] = mulmod(hr[0], hr[0], _pp);\\n    // h^3\\n    hr[3] = mulmod(hr[2], hr[0], _pp);\\n    // qx = -h^3  -2u1h^2+r^2\\n    uint256 qx = addmod(mulmod(hr[1], hr[1], _pp), _pp - hr[3], _pp);\\n    qx = addmod(qx, _pp - mulmod(2, mulmod(zs[0], hr[2], _pp), _pp), _pp);\\n    // qy = -s1*z1*h^3+r(u1*h^2 -x^3)\\n    uint256 qy = mulmod(hr[1], addmod(mulmod(zs[0], hr[2], _pp), _pp - qx, _pp), _pp);\\n    qy = addmod(qy, _pp - mulmod(zs[1], hr[3], _pp), _pp);\\n    // qz = h*z1*z2\\n    uint256 qz = mulmod(hr[0], mulmod(_z1, _z2, _pp), _pp);\\n    return(qx, qy, qz);\\n  }\\n\\n  /// @dev Doubles a points (x, y, z).\\n  /// @param _x coordinate x of P1\\n  /// @param _y coordinate y of P1\\n  /// @param _z coordinate z of P1\\n  /// @param _aa the a scalar in the curve equation\\n  /// @param _pp the modulus\\n  /// @return (qx, qy, qz) 2P in Jacobian\\n  function jacDouble(\\n    uint256 _x,\\n    uint256 _y,\\n    uint256 _z,\\n    uint256 _aa,\\n    uint256 _pp)\\n  internal pure returns (uint256, uint256, uint256)\\n  {\\n    if (_z == 0)\\n      return (_x, _y, _z);\\n\\n    // We follow the equations described in https://pdfs.semanticscholar.org/5c64/29952e08025a9649c2b0ba32518e9a7fb5c2.pdf Section 5\\n    // Note: there is a bug in the paper regarding the m parameter, M=3*(x1^2)+a*(z1^4)\\n    // x, y, z at this point represent the squares of _x, _y, _z\\n    uint256 x = mulmod(_x, _x, _pp); //x1^2\\n    uint256 y = mulmod(_y, _y, _pp); //y1^2\\n    uint256 z = mulmod(_z, _z, _pp); //z1^2\\n\\n    // s\\n    uint s = mulmod(4, mulmod(_x, y, _pp), _pp);\\n    // m\\n    uint m = addmod(mulmod(3, x, _pp), mulmod(_aa, mulmod(z, z, _pp), _pp), _pp);\\n\\n    // x, y, z at this point will be reassigned and rather represent qx, qy, qz from the paper\\n    // This allows to reduce the gas cost and stack footprint of the algorithm\\n    // qx\\n    x = addmod(mulmod(m, m, _pp), _pp - addmod(s, s, _pp), _pp);\\n    // qy = -8*y1^4 + M(S-T)\\n    y = addmod(mulmod(m, addmod(s, _pp - x, _pp), _pp), _pp - mulmod(8, mulmod(y, y, _pp), _pp), _pp);\\n    // qz = 2*y1*z1\\n    z = mulmod(2, mulmod(_y, _z, _pp), _pp);\\n\\n    return (x, y, z);\\n  }\\n\\n  /// @dev Multiply point (x, y, z) times d.\\n  /// @param _d scalar to multiply\\n  /// @param _x coordinate x of P1\\n  /// @param _y coordinate y of P1\\n  /// @param _z coordinate z of P1\\n  /// @param _aa constant of curve\\n  /// @param _pp the modulus\\n  /// @return (qx, qy, qz) d*P1 in Jacobian\\n  function jacMul(\\n    uint256 _d,\\n    uint256 _x,\\n    uint256 _y,\\n    uint256 _z,\\n    uint256 _aa,\\n    uint256 _pp)\\n  internal pure returns (uint256, uint256, uint256)\\n  {\\n    // Early return in case that `_d == 0`\\n    if (_d == 0) {\\n      return (_x, _y, _z);\\n    }\\n\\n    uint256 remaining = _d;\\n    uint256 qx = 0;\\n    uint256 qy = 0;\\n    uint256 qz = 1;\\n\\n    // Double and add algorithm\\n    while (remaining != 0) {\\n      if ((remaining & 1) != 0) {\\n        (qx, qy, qz) = jacAdd(\\n          qx,\\n          qy,\\n          qz,\\n          _x,\\n          _y,\\n          _z,\\n          _pp);\\n      }\\n      remaining = remaining / 2;\\n      (_x, _y, _z) = jacDouble(\\n        _x,\\n        _y,\\n        _z,\\n        _aa,\\n        _pp);\\n    }\\n    return (qx, qy, qz);\\n  }\\n}\\n\"\r\n    },\r\n    \"ForcedTradeActionState.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2019-2023 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.12;\\n\\nimport \\\"PerpetualStorage.sol\\\";\\nimport \\\"MForcedTradeActionState.sol\\\";\\nimport \\\"ActionHash.sol\\\";\\n\\n/*\\n  ForcedTrade specific action hashses.\\n*/\\ncontract ForcedTradeActionState is PerpetualStorage, ActionHash, MForcedTradeActionState {\\n    function forcedTradeActionHash(\\n        uint256 starkKeyA,\\n        uint256 starkKeyB,\\n        uint256 vaultIdA,\\n        uint256 vaultIdB,\\n        uint256 collateralAssetId,\\n        uint256 syntheticAssetId,\\n        uint256 amountCollateral,\\n        uint256 amountSynthetic,\\n        bool aIsBuyingSynthetic,\\n        uint256 nonce\\n    ) internal pure override returns (bytes32) {\\n        return\\n            getActionHash(\\n                \\\"FORCED_TRADE\\\",\\n                abi.encodePacked(\\n                    starkKeyA,\\n                    starkKeyB,\\n                    vaultIdA,\\n                    vaultIdB,\\n                    collateralAssetId,\\n                    syntheticAssetId,\\n                    amountCollateral,\\n                    amountSynthetic,\\n                    aIsBuyingSynthetic,\\n                    nonce\\n                )\\n            );\\n    }\\n\\n    function clearForcedTradeRequest(\\n        uint256 starkKeyA,\\n        uint256 starkKeyB,\\n        uint256 vaultIdA,\\n        uint256 vaultIdB,\\n        uint256 collateralAssetId,\\n        uint256 syntheticAssetId,\\n        uint256 amountCollateral,\\n        uint256 amountSynthetic,\\n        bool aIsBuyingSynthetic,\\n        uint256 nonce\\n    ) internal override {\\n        /*\\n          We don't clear the entry, but set the time to max so that\\n          it cannot be replayed.\\n        */\\n        bytes32 actionHash = forcedTradeActionHash(\\n            starkKeyA,\\n            starkKeyB,\\n            vaultIdA,\\n            vaultIdB,\\n            collateralAssetId,\\n            syntheticAssetId,\\n            amountCollateral,\\n            amountSynthetic,\\n            aIsBuyingSynthetic,\\n            nonce\\n        );\\n        // A cleared ForcedTrade action is marked with ~0 and not zero, to prevent party A from\\n        // replaying the trade without a new signature from party B.\\n        require(forcedActionRequests[actionHash] != uint256(~0), \\\"ACTION_ALREADY_CLEARED\\\");\\n        require(forcedActionRequests[actionHash] != 0, \\\"NON_EXISTING_ACTION\\\");\\n        forcedActionRequests[actionHash] = uint256(~0);\\n    }\\n\\n    function getForcedTradeRequest(\\n        uint256 starkKeyA,\\n        uint256 starkKeyB,\\n        uint256 vaultIdA,\\n        uint256 vaultIdB,\\n        uint256 collateralAssetId,\\n        uint256 syntheticAssetId,\\n        uint256 amountCollateral,\\n        uint256 amountSynthetic,\\n        bool aIsBuyingSynthetic,\\n        uint256 nonce\\n    ) public view override returns (uint256) {\\n        return\\n            forcedActionRequests[\\n                forcedTradeActionHash(\\n                    starkKeyA,\\n                    starkKeyB,\\n                    vaultIdA,\\n                    vaultIdB,\\n                    collateralAssetId,\\n                    syntheticAssetId,\\n                    amountCollateral,\\n                    amountSynthetic,\\n                    aIsBuyingSynthetic,\\n                    nonce\\n                )\\n            ];\\n    }\\n\\n    function setForcedTradeRequest(\\n        uint256 starkKeyA,\\n        uint256 starkKeyB,\\n        uint256 vaultIdA,\\n        uint256 vaultIdB,\\n        uint256 collateralAssetId,\\n        uint256 syntheticAssetId,\\n        uint256 amountCollateral,\\n        uint256 amountSynthetic,\\n        bool aIsBuyingSynthetic,\\n        uint256 nonce,\\n        bool premiumCost\\n    ) internal override {\\n        bytes32 actionHash = forcedTradeActionHash(\\n            starkKeyA,\\n            starkKeyB,\\n            vaultIdA,\\n            vaultIdB,\\n            collateralAssetId,\\n            syntheticAssetId,\\n            amountCollateral,\\n            amountSynthetic,\\n            aIsBuyingSynthetic,\\n            nonce\\n        );\\n        // NOLINTNEXTLINE: timestamp.\\n        require(forcedActionRequests[actionHash] == 0, \\\"FORCED_TRADE_REPLAYED\\\");\\n        setActionHash(actionHash, premiumCost);\\n    }\\n}\\n\"\r\n    },\r\n    \"ForcedTrades.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2019-2023 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.12;\\n\\nimport \\\"PerpetualStorage.sol\\\";\\nimport \\\"MForcedTradeActionState.sol\\\";\\nimport \\\"PerpetualConstants.sol\\\";\\nimport \\\"MFreezable.sol\\\";\\nimport \\\"MKeyGetters.sol\\\";\\n\\nabstract contract ForcedTrades is\\n    PerpetualStorage,\\n    PerpetualConstants,\\n    MForcedTradeActionState,\\n    MFreezable,\\n    MKeyGetters\\n{\\n    event LogForcedTradeRequest(\\n        uint256 starkKeyA,\\n        uint256 starkKeyB,\\n        uint256 vaultIdA,\\n        uint256 vaultIdB,\\n        uint256 collateralAssetId,\\n        uint256 syntheticAssetId,\\n        uint256 amountCollateral,\\n        uint256 amountSynthetic,\\n        bool aIsBuyingSynthetic,\\n        uint256 nonce\\n    );\\n\\n    // NOLINTNEXTLINE: uninitialized-state.\\n    function forcedTradeRequest(\\n        uint256 starkKeyA,\\n        uint256 starkKeyB,\\n        uint256 vaultIdA,\\n        uint256 vaultIdB,\\n        uint256 collateralAssetId,\\n        uint256 syntheticAssetId,\\n        uint256 amountCollateral,\\n        uint256 amountSynthetic,\\n        bool aIsBuyingSynthetic,\\n        uint256 submissionExpirationTime,\\n        uint256 nonce,\\n        bytes calldata signature,\\n        bool premiumCost\\n    ) external notFrozen onlyKeyOwner(starkKeyA) {\\n        require(vaultIdA < PERPETUAL_POSITION_ID_UPPER_BOUND, \\\"OUT_OF_RANGE_POSITION_ID\\\");\\n        require(vaultIdB < PERPETUAL_POSITION_ID_UPPER_BOUND, \\\"OUT_OF_RANGE_POSITION_ID\\\");\\n\\n        require(vaultIdA != vaultIdB, \\\"IDENTICAL_VAULTS\\\");\\n        require(collateralAssetId == systemAssetType, \\\"SYSTEM_ASSET_NOT_IN_TRADE\\\");\\n        require(collateralAssetId != uint256(0x0), \\\"SYSTEM_ASSET_NOT_SET\\\");\\n        require(collateralAssetId != syntheticAssetId, \\\"IDENTICAL_ASSETS\\\");\\n        require(configurationHash[syntheticAssetId] != bytes32(0x0), \\\"UNKNOWN_ASSET\\\");\\n        require(amountCollateral < PERPETUAL_AMOUNT_UPPER_BOUND, \\\"ILLEGAL_AMOUNT\\\");\\n        require(amountSynthetic < PERPETUAL_AMOUNT_UPPER_BOUND, \\\"ILLEGAL_AMOUNT\\\");\\n        require(nonce < K_MODULUS, \\\"INVALID_NONCE_VALUE\\\");\\n        require(submissionExpirationTime >= block.timestamp / 3600, \\\"REQUEST_TIME_EXPIRED\\\");\\n\\n        // Start timer on escape request.\\n        setForcedTradeRequest(\\n            starkKeyA,\\n            starkKeyB,\\n            vaultIdA,\\n            vaultIdB,\\n            collateralAssetId,\\n            syntheticAssetId,\\n            amountCollateral,\\n            amountSynthetic,\\n            aIsBuyingSynthetic,\\n            nonce,\\n            premiumCost\\n        );\\n\\n        validatePartyBSignature(\\n            starkKeyA,\\n            starkKeyB,\\n            vaultIdA,\\n            vaultIdB,\\n            collateralAssetId,\\n            syntheticAssetId,\\n            amountCollateral,\\n            amountSynthetic,\\n            aIsBuyingSynthetic,\\n            submissionExpirationTime,\\n            nonce,\\n            signature\\n        );\\n\\n        // Log request.\\n        emit LogForcedTradeRequest(\\n            starkKeyA,\\n            starkKeyB,\\n            vaultIdA,\\n            vaultIdB,\\n            collateralAssetId,\\n            syntheticAssetId,\\n            amountCollateral,\\n            amountSynthetic,\\n            aIsBuyingSynthetic,\\n            nonce\\n        );\\n    }\\n\\n    function freezeRequest(\\n        uint256 starkKeyA,\\n        uint256 starkKeyB,\\n        uint256 vaultIdA,\\n        uint256 vaultIdB,\\n        uint256 collateralAssetId,\\n        uint256 syntheticAssetId,\\n        uint256 amountCollateral,\\n        uint256 amountSynthetic,\\n        bool aIsBuyingSynthetic,\\n        uint256 nonce\\n    ) external notFrozen {\\n        // Verify vaultId in range.\\n        require(vaultIdA < PERPETUAL_POSITION_ID_UPPER_BOUND, \\\"OUT_OF_RANGE_POSITION_ID\\\");\\n        require(vaultIdB < PERPETUAL_POSITION_ID_UPPER_BOUND, \\\"OUT_OF_RANGE_POSITION_ID\\\");\\n\\n        // Load request time.\\n        uint256 requestTime = getForcedTradeRequest(\\n            starkKeyA,\\n            starkKeyB,\\n            vaultIdA,\\n            vaultIdB,\\n            collateralAssetId,\\n            syntheticAssetId,\\n            amountCollateral,\\n            amountSynthetic,\\n            aIsBuyingSynthetic,\\n            nonce\\n        );\\n\\n        validateFreezeRequest(requestTime);\\n        freeze();\\n    }\\n\\n    function validatePartyBSignature(\\n        uint256 starkKeyA,\\n        uint256 starkKeyB,\\n        uint256 vaultIdA,\\n        uint256 vaultIdB,\\n        uint256 collateralAssetId,\\n        uint256 syntheticAssetId,\\n        uint256 amountCollateral,\\n        uint256 amountSynthetic,\\n        bool aIsBuyingSynthetic,\\n        uint256 submissionExpirationTime,\\n        uint256 nonce,\\n        bytes memory signature\\n    ) internal view {\\n        bytes32 actionHash = forcedTradeActionHash(\\n            starkKeyA,\\n            starkKeyB,\\n            vaultIdA,\\n            vaultIdB,\\n            collateralAssetId,\\n            syntheticAssetId,\\n            amountCollateral,\\n            amountSynthetic,\\n            aIsBuyingSynthetic,\\n            nonce\\n        );\\n\\n        bytes32 signedData = keccak256(abi.encodePacked(actionHash, submissionExpirationTime));\\n        address signer;\\n        {\\n            uint8 v = uint8(signature[64]);\\n            bytes32 r;\\n            bytes32 s;\\n\\n            assembly {\\n                r := mload(add(signature, 32))\\n                s := mload(add(signature, 64))\\n            }\\n            signer = ecrecover(signedData, v, r, s);\\n        }\\n        address starkKeyBOwner = getEthKey(starkKeyB);\\n        require(starkKeyBOwner != address(0x0), \\\"USER_B_UNREGISTERED\\\");\\n        require(signer == starkKeyBOwner, \\\"INVALID_SIGNATURE\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"ForcedWithdrawalActionState.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2019-2023 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.12;\\n\\nimport \\\"PerpetualStorage.sol\\\";\\nimport \\\"MForcedWithdrawalActionState.sol\\\";\\nimport \\\"ActionHash.sol\\\";\\n\\n/*\\n  ForcedWithdrawal specific action hashses.\\n*/\\ncontract ForcedWithdrawalActionState is PerpetualStorage, ActionHash, MForcedWithdrawalActionState {\\n    function forcedWithdrawActionHash(\\n        uint256 starkKey,\\n        uint256 vaultId,\\n        uint256 quantizedAmount\\n    ) internal pure override returns (bytes32) {\\n        return getActionHash(\\\"FORCED_WITHDRAWAL\\\", abi.encode(starkKey, vaultId, quantizedAmount));\\n    }\\n\\n    function clearForcedWithdrawalRequest(\\n        uint256 starkKey,\\n        uint256 vaultId,\\n        uint256 quantizedAmount\\n    ) internal override {\\n        bytes32 actionHash = forcedWithdrawActionHash(starkKey, vaultId, quantizedAmount);\\n        require(forcedActionRequests[actionHash] != 0, \\\"NON_EXISTING_ACTION\\\");\\n        delete forcedActionRequests[actionHash];\\n    }\\n\\n    function getForcedWithdrawalRequest(\\n        uint256 starkKey,\\n        uint256 vaultId,\\n        uint256 quantizedAmount\\n    ) public view override returns (uint256) {\\n        // Return request value. Expect zero if the request doesn't exist or has been serviced, and\\n        // a non-zero value otherwise.\\n        return forcedActionRequests[forcedWithdrawActionHash(starkKey, vaultId, quantizedAmount)];\\n    }\\n\\n    function setForcedWithdrawalRequest(\\n        uint256 starkKey,\\n        uint256 vaultId,\\n        uint256 quantizedAmount,\\n        bool premiumCost\\n    ) internal override {\\n        setActionHash(forcedWithdrawActionHash(starkKey, vaultId, quantizedAmount), premiumCost);\\n    }\\n}\\n\"\r\n    },\r\n    \"ForcedWithdrawals.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2019-2023 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.12;\\n\\nimport \\\"MForcedWithdrawalActionState.sol\\\";\\nimport \\\"PerpetualConstants.sol\\\";\\nimport \\\"MFreezable.sol\\\";\\nimport \\\"MKeyGetters.sol\\\";\\n\\nabstract contract ForcedWithdrawals is\\n    PerpetualConstants,\\n    MForcedWithdrawalActionState,\\n    MFreezable,\\n    MKeyGetters\\n{\\n    event LogForcedWithdrawalRequest(uint256 starkKey, uint256 vaultId, uint256 quantizedAmount);\\n\\n    function forcedWithdrawalRequest(\\n        uint256 starkKey,\\n        uint256 vaultId,\\n        uint256 quantizedAmount,\\n        bool premiumCost\\n    ) external notFrozen onlyKeyOwner(starkKey) {\\n        // Verify vault ID in range.\\n        require(vaultId < PERPETUAL_POSITION_ID_UPPER_BOUND, \\\"OUT_OF_RANGE_POSITION_ID\\\");\\n        require(quantizedAmount < PERPETUAL_AMOUNT_UPPER_BOUND, \\\"ILLEGAL_AMOUNT\\\");\\n\\n        // We cannot handle two identical forced withdraw request at the same time.\\n        // User can either wait for pending one to be cleared, or issue one with different amount.\\n        require(\\n            getForcedWithdrawalRequest(starkKey, vaultId, quantizedAmount) == 0,\\n            \\\"REQUEST_ALREADY_PENDING\\\"\\n        );\\n\\n        // Start timer on escape request.\\n        setForcedWithdrawalRequest(starkKey, vaultId, quantizedAmount, premiumCost);\\n\\n        // Log request.\\n        emit LogForcedWithdrawalRequest(starkKey, vaultId, quantizedAmount);\\n    }\\n\\n    function freezeRequest(\\n        uint256 starkKey,\\n        uint256 vaultId,\\n        uint256 quantizedAmount\\n    ) external notFrozen {\\n        // Verify vaultId in range.\\n        require(vaultId < PERPETUAL_POSITION_ID_UPPER_BOUND, \\\"OUT_OF_RANGE_POSITION_ID\\\");\\n\\n        // Load request time.\\n        uint256 requestTime = getForcedWithdrawalRequest(starkKey, vaultId, quantizedAmount);\\n\\n        validateFreezeRequest(requestTime);\\n        freeze();\\n    }\\n}\\n\"\r\n    },\r\n    \"Freezable.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2019-2023 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.12;\\n\\nimport \\\"LibConstants.sol\\\";\\nimport \\\"MFreezable.sol\\\";\\nimport \\\"MGovernance.sol\\\";\\nimport \\\"MainStorage.sol\\\";\\n\\n/*\\n  Implements MFreezable.\\n*/\\nabstract contract Freezable is MainStorage, LibConstants, MGovernance, MFreezable {\\n    event LogFrozen();\\n    event LogUnFrozen();\\n\\n    function isFrozen() public view override returns (bool) {\\n        return stateFrozen;\\n    }\\n\\n    function validateFreezeRequest(uint256 requestTime) internal override {\\n        require(requestTime != 0, \\\"FORCED_ACTION_UNREQUESTED\\\");\\n        // Verify timer on escape request.\\n        uint256 freezeTime = requestTime + FREEZE_GRACE_PERIOD;\\n\\n        // Prevent wraparound.\\n        assert(freezeTime >= FREEZE_GRACE_PERIOD);\\n        require(block.timestamp >= freezeTime, \\\"FORCED_ACTION_PENDING\\\"); // NOLINT: timestamp.\\n\\n        // Forced action requests placed before freeze, are no longer valid after the un-freeze.\\n        require(freezeTime > unFreezeTime, \\\"REFREEZE_ATTEMPT\\\");\\n    }\\n\\n    function freeze() internal override notFrozen {\\n        unFreezeTime = block.timestamp + UNFREEZE_DELAY;\\n\\n        // Update state.\\n        stateFrozen = true;\\n\\n        // Log event.\\n        emit LogFrozen();\\n    }\\n\\n    function unFreeze() external onlyFrozen onlyGovernance {\\n        require(block.timestamp >= unFreezeTime, \\\"UNFREEZE_NOT_ALLOWED_YET\\\");\\n\\n        // Update state.\\n        stateFrozen = false;\\n\\n        // Increment roots to invalidate them, w/o losing information.\\n        validiumVaultRoot += 1;\\n        rollupVaultRoot += 1;\\n        orderRoot += 1;\\n\\n        // Log event.\\n        emit LogUnFrozen();\\n    }\\n}\\n\"\r\n    },\r\n    \"Governance.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2019-2023 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.12;\\n\\nimport \\\"MGovernance.sol\\\";\\n\\n/*\\n  Implements Generic Governance, applicable for both proxy and main contract, and possibly others.\\n  Notes:\\n   The use of the same function names by both the Proxy and a delegated implementation\\n   is not possible since calling the implementation functions is done via the default function\\n   of the Proxy. For this reason, for example, the implementation of MainContract (MainGovernance)\\n   exposes mainIsGovernor, which calls the internal _isGovernor method.\\n*/\\nstruct GovernanceInfoStruct {\\n    mapping(address => bool) effectiveGovernors;\\n    address candidateGovernor;\\n    bool initialized;\\n}\\n\\nabstract contract Governance is MGovernance {\\n    event LogNominatedGovernor(address nominatedGovernor);\\n    event LogNewGovernorAccepted(address acceptedGovernor);\\n    event LogRemovedGovernor(address removedGovernor);\\n    event LogNominationCancelled();\\n\\n    function getGovernanceInfo() internal view virtual returns (GovernanceInfoStruct storage);\\n\\n    /*\\n      Current code intentionally prevents governance re-initialization.\\n      This may be a problem in an upgrade situation, in a case that the upgrade-to implementation\\n      performs an initialization (for real) and within that calls initGovernance().\\n\\n      Possible workarounds:\\n      1. Clearing the governance info altogether by changing the MAIN_GOVERNANCE_INFO_TAG.\\n         This will remove existing main governance information.\\n      2. Modify the require part in this function, so that it will exit quietly\\n         when trying to re-initialize (uncomment the lines below).\\n    */\\n    function initGovernance() internal {\\n        GovernanceInfoStruct storage gub = getGovernanceInfo();\\n        require(!gub.initialized, \\\"ALREADY_INITIALIZED\\\");\\n        gub.initialized = true; // to ensure acceptNewGovernor() won't fail.\\n        // Add the initial governer.\\n        acceptNewGovernor(msg.sender);\\n    }\\n\\n    function _isGovernor(address user) internal view override returns (bool) {\\n        GovernanceInfoStruct storage gub = getGovernanceInfo();\\n        return gub.effectiveGovernors[user];\\n    }\\n\\n    /*\\n      Cancels the nomination of a governor candidate.\\n    */\\n    function _cancelNomination() internal onlyGovernance {\\n        GovernanceInfoStruct storage gub = getGovernanceInfo();\\n        if (gub.candidateGovernor != address(0x0)) {\\n            gub.candidateGovernor = address(0x0);\\n            emit LogNominationCancelled();\\n        }\\n    }\\n\\n    function _nominateNewGovernor(address newGovernor) internal onlyGovernance {\\n        GovernanceInfoStruct storage gub = getGovernanceInfo();\\n        require(newGovernor != address(0x0), \\\"BAD_ADDRESS\\\");\\n        require(!_isGovernor(newGovernor), \\\"ALREADY_GOVERNOR\\\");\\n        require(gub.candidateGovernor == address(0x0), \\\"OTHER_CANDIDATE_PENDING\\\");\\n        gub.candidateGovernor = newGovernor;\\n        emit LogNominatedGovernor(newGovernor);\\n    }\\n\\n    /*\\n      The acceptNewGovernor is called in two cases:\\n      1. by _acceptGovernance when a new governor accepts its role.\\n      2. by initGovernance to add the initial governor.\\n      The difference is that the init path skips the nominate step\\n      that would fail because of the onlyGovernance modifier.\\n    */\\n    function acceptNewGovernor(address newGovernor) private {\\n        require(!_isGovernor(newGovernor), \\\"ALREADY_GOVERNOR\\\");\\n        GovernanceInfoStruct storage gub = getGovernanceInfo();\\n        gub.effectiveGovernors[newGovernor] = true;\\n\\n        // Emit governance information.\\n        emit LogNewGovernorAccepted(newGovernor);\\n    }\\n\\n    function _acceptGovernance() internal {\\n        // The new governor was proposed as a candidate by the current governor.\\n        GovernanceInfoStruct storage gub = getGovernanceInfo();\\n        require(msg.sender == gub.candidateGovernor, \\\"ONLY_CANDIDATE_GOVERNOR\\\");\\n\\n        // Update state.\\n        acceptNewGovernor(msg.sender);\\n        gub.candidateGovernor = address(0x0);\\n    }\\n\\n    /*\\n      Remove a governor from office.\\n    */\\n    function _removeGovernor(address governorForRemoval) internal onlyGovernance {\\n        require(msg.sender != governorForRemoval, \\\"GOVERNOR_SELF_REMOVE\\\");\\n        GovernanceInfoStruct storage gub = getGovernanceInfo();\\n        require(_isGovernor(governorForRemoval), \\\"NOT_GOVERNOR\\\");\\n        gub.effectiveGovernors[governorForRemoval] = false;\\n        emit LogRemovedGovernor(governorForRemoval);\\n    }\\n}\\n\"\r\n    },\r\n    \"GovernanceStorage.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2019-2023 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.12;\\nimport {GovernanceInfoStruct} from \\\"Governance.sol\\\";\\n\\n/*\\n  Holds the governance slots for ALL entities, including proxy and the main contract.\\n*/\\ncontract GovernanceStorage {\\n    // A map from a Governor tag to its own GovernanceInfoStruct.\\n    mapping(string => GovernanceInfoStruct) internal governanceInfo; //NOLINT uninitialized-state.\\n}\\n\"\r\n    },\r\n    \"Identity.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2019-2023 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.12;\\n\\ninterface Identity {\\n    /*\\n      Allows a caller to ensure that the provided address is of the expected type and version.\\n    */\\n    function identify() external pure returns (string memory);\\n}\\n\"\r\n    },\r\n    \"KeyGetters.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2019-2023 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.12;\\n\\nimport \\\"MainStorage.sol\\\";\\nimport \\\"MKeyGetters.sol\\\";\\n\\n/*\\n  Implements MKeyGetters.\\n*/\\ncontract KeyGetters is MainStorage, MKeyGetters {\\n    uint256 internal constant MASK_ADDRESS = (1 << 160) - 1;\\n\\n    /*\\n      Returns the Ethereum public key (address) that owns the given ownerKey.\\n      If the ownerKey size is within the range of an Ethereum address (i.e. < 2**160)\\n      it returns the owner key itself.\\n\\n      If the ownerKey is larger than a potential eth address, the eth address for which the starkKey\\n      was registered is returned, and 0 if the starkKey is not registered.\\n\\n      Note - prior to version 4.0 this function reverted on an unregistered starkKey.\\n      For a variant of this function that reverts on an unregistered starkKey, use strictGetEthKey.\\n    */\\n    function getEthKey(uint256 ownerKey) public view override returns (address) {\\n        address registeredEth = ethKeys[ownerKey];\\n\\n        if (registeredEth != address(0x0)) {\\n            return registeredEth;\\n        }\\n\\n        return ownerKey == (ownerKey & MASK_ADDRESS) ? address(ownerKey) : address(0x0);\\n    }\\n\\n    /*\\n      Same as getEthKey, but fails when a stark key is not registered.\\n    */\\n    function strictGetEthKey(uint256 ownerKey) internal view override returns (address ethKey) {\\n        ethKey = getEthKey(ownerKey);\\n        require(ethKey != address(0x0), \\\"USER_UNREGISTERED\\\");\\n    }\\n\\n    function isMsgSenderKeyOwner(uint256 ownerKey) internal view override returns (bool) {\\n        return msg.sender == getEthKey(ownerKey);\\n    }\\n}\\n\"\r\n    },\r\n    \"LibConstants.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2019-2023 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.12;\\n\\ncontract LibConstants {\\n    // Durations for time locked mechanisms (in seconds).\\n    // Note that it is known that miners can manipulate block timestamps\\n    // up to a deviation of a few seconds.\\n    // This mechanism should not be used for fine grained timing.\\n\\n    // The time required to cancel a deposit, in the case the operator does not move the funds\\n    // to the off-chain storage.\\n    uint256 public constant DEPOSIT_CANCEL_DELAY = 2 days;\\n\\n    // The time required to freeze the exchange, in the case the operator does not execute a\\n    // requested full withdrawal.\\n    uint256 public constant FREEZE_GRACE_PERIOD = 7 days;\\n\\n    // The time after which the exchange may be unfrozen after it froze. This should be enough time\\n    // for users to perform escape hatches to get back their funds.\\n    uint256 public constant UNFREEZE_DELAY = 365 days;\\n\\n    // Maximal number of verifiers which may co-exist.\\n    uint256 public constant MAX_VERIFIER_COUNT = uint256(64);\\n\\n    // The time required to remove a verifier in case of a verifier upgrade.\\n    uint256 public constant VERIFIER_REMOVAL_DELAY = FREEZE_GRACE_PERIOD + (21 days);\\n\\n    address constant ZERO_ADDRESS = address(0x0);\\n\\n    uint256 constant K_MODULUS = 0x800000000000011000000000000000000000000000000000000000000000001;\\n\\n    uint256 constant K_BETA = 0x6f21413efbe40de150e596d72f7a8c5609ad26c15c915c1f4cdfcb99cee9e89;\\n\\n    uint256 internal constant MASK_250 =\\n        0x03FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n    uint256 internal constant MASK_240 =\\n        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n    uint256 public constant MAX_FORCED_ACTIONS_REQS_PER_BLOCK = 10;\\n\\n    uint256 constant QUANTUM_UPPER_BOUND = 2**128;\\n\\n    // All mintable asset ids have the MINTABLE_ASSET_ID_FLAG (251st bit) set.\\n    // Mintable ERC1155 and ERC20 assets have NON_UNIQUE_MINTABLE_ASSET_ID_FLAG (250th bit) set too.\\n    // Mintable ERC20s also have the MINTABLE_ERC20_ASSET_ID_FLAG (249th bit) set.\\n    // I.e. mintable asset ids that start with: 100 => ERC721, 110 => ERC1155, 111 => ERC20.\\n    // All non-mintable asset ids have the MINTABLE_ASSET_ID_FLAG bit off.\\n    uint256 internal constant MINTABLE_ASSET_ID_FLAG = 1 << 250;\\n    uint256 internal constant NON_UNIQUE_MINTABLE_ASSET_ID_FLAG = 1 << 249;\\n    uint256 internal constant MINTABLE_ERC20_ASSET_ID_FLAG = 1 << 248;\\n\\n    // Bit 64 (indexed 63, counting from 0) is a flag indicating a rollup vault id.\\n    uint256 constant ROLLUP_VAULTS_BIT = 63;\\n}\\n\"\r\n    },\r\n    \"MForcedTradeActionState.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2019-2023 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.12;\\n\\nabstract contract MForcedTradeActionState {\\n    function forcedTradeActionHash(\\n        uint256 starkKeyA,\\n        uint256 starkKeyB,\\n        uint256 vaultIdA,\\n        uint256 vaultIdB,\\n        uint256 collateralAssetId,\\n        uint256 syntheticAssetId,\\n        uint256 amountCollateral,\\n        uint256 amountSynthetic,\\n        bool aIsBuyingSynthetic,\\n        uint256 nonce\\n    ) internal pure virtual returns (bytes32);\\n\\n    function clearForcedTradeRequest(\\n        uint256 starkKeyA,\\n        uint256 starkKeyB,\\n        uint256 vaultIdA,\\n        uint256 vaultIdB,\\n        uint256 collateralAssetId,\\n        uint256 syntheticAssetId,\\n        uint256 amountCollateral,\\n        uint256 amountSynthetic,\\n        bool aIsBuyingSynthetic,\\n        uint256 nonce\\n    ) internal virtual;\\n\\n    // NOLINTNEXTLINE: external-function.\\n    function getForcedTradeRequest(\\n        uint256 starkKeyA,\\n        uint256 starkKeyB,\\n        uint256 vaultIdA,\\n        uint256 vaultIdB,\\n        uint256 collateralAssetId,\\n        uint256 syntheticAssetId,\\n        uint256 amountCollateral,\\n        uint256 amountSynthetic,\\n        bool aIsBuyingSynthetic,\\n        uint256 nonce\\n    ) public view virtual returns (uint256 res);\\n\\n    function setForcedTradeRequest(\\n        uint256 starkKeyA,\\n        uint256 starkKeyB,\\n        uint256 vaultIdA,\\n        uint256 vaultIdB,\\n        uint256 collateralAssetId,\\n        uint256 syntheticAssetId,\\n        uint256 amountCollateral,\\n        uint256 amountSynthetic,\\n        bool aIsBuyingSynthetic,\\n        uint256 nonce,\\n        bool premiumCost\\n    ) internal virtual;\\n}\\n\"\r\n    },\r\n    \"MForcedWithdrawalActionState.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2019-2023 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.12;\\n\\nabstract contract MForcedWithdrawalActionState {\\n    function forcedWithdrawActionHash(\\n        uint256 starkKey,\\n        uint256 vaultId,\\n        uint256 quantizedAmount\\n    ) internal pure virtual returns (bytes32);\\n\\n    function clearForcedWithdrawalRequest(\\n        uint256 starkKey,\\n        uint256 vaultId,\\n        uint256 quantizedAmount\\n    ) internal virtual;\\n\\n    // NOLINTNEXTLINE: external-function.\\n    function getForcedWithdrawalRequest(\\n        uint256 starkKey,\\n        uint256 vaultId,\\n        uint256 quantizedAmount\\n    ) public view virtual returns (uint256 res);\\n\\n    function setForcedWithdrawalRequest(\\n        uint256 starkKey,\\n        uint256 vaultId,\\n        uint256 quantizedAmount,\\n        bool premiumCost\\n    ) internal virtual;\\n}\\n\"\r\n    },\r\n    \"MFreezable.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2019-2023 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.12;\\n\\nabstract contract MFreezable {\\n    /*\\n      Returns true if the exchange is frozen.\\n    */\\n    function isFrozen() public view virtual returns (bool); // NOLINT: external-function.\\n\\n    /*\\n      Forbids calling the function if the exchange is frozen.\\n    */\\n    modifier notFrozen() {\\n        require(!isFrozen(), \\\"STATE_IS_FROZEN\\\");\\n        _;\\n    }\\n\\n    function validateFreezeRequest(uint256 requestTime) internal virtual;\\n\\n    /*\\n      Allows calling the function only if the exchange is frozen.\\n    */\\n    modifier onlyFrozen() {\\n        require(isFrozen(), \\\"STATE_NOT_FROZEN\\\");\\n        _;\\n    }\\n\\n    /*\\n      Freezes the exchange.\\n    */\\n    function freeze() internal virtual;\\n}\\n\"\r\n    },\r\n    \"MGovernance.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2019-2023 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.12;\\n\\nabstract contract MGovernance {\\n    function _isGovernor(address user) internal view virtual returns (bool);\\n\\n    /*\\n      Allows calling the function only by a Governor.\\n    */\\n    modifier onlyGovernance() {\\n        require(_isGovernor(msg.sender), \\\"ONLY_GOVERNANCE\\\");\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"MKeyGetters.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2019-2023 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.12;\\n\\nabstract contract MKeyGetters {\\n    // NOLINTNEXTLINE: external-function.\\n    function getEthKey(uint256 ownerKey) public view virtual returns (address);\\n\\n    function strictGetEthKey(uint256 ownerKey) internal view virtual returns (address);\\n\\n    function isMsgSenderKeyOwner(uint256 ownerKey) internal view virtual returns (bool);\\n\\n    /*\\n      Allows calling the function only if ownerKey is registered to msg.sender.\\n    */\\n    modifier onlyKeyOwner(uint256 ownerKey) {\\n        // Require the calling user to own the stark key.\\n        require(msg.sender == strictGetEthKey(ownerKey), \\\"MISMATCHING_STARK_ETH_KEYS\\\");\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"MainGovernance.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2019-2023 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.12;\\n\\nimport \\\"Governance.sol\\\";\\nimport \\\"GovernanceStorage.sol\\\";\\n\\n/**\\n  The StarkEx contract is governed by one or more Governors of which the initial one is the\\n  deployer of the contract.\\n\\n  A governor has the sole authority to perform the following operations:\\n\\n  1. Nominate additional governors (:sol:func:`mainNominateNewGovernor`)\\n  2. Remove other governors (:sol:func:`mainRemoveGovernor`)\\n  3. Add new :sol:mod:`Verifiers` and :sol:mod:`AvailabilityVerifiers`\\n  4. Remove :sol:mod:`Verifiers` and :sol:mod:`AvailabilityVerifiers` after a timelock allows it\\n  5. Nominate Operators (see :sol:mod:`Operator`) and Token Administrators (see :sol:mod:`TokenRegister`)\\n\\n  Adding governors is performed in a two step procedure:\\n\\n  1. First, an existing governor nominates a new governor (:sol:func:`mainNominateNewGovernor`)\\n  2. Then, the new governor must accept governance to become a governor (:sol:func:`mainAcceptGovernance`)\\n\\n  This two step procedure ensures that a governor public key cannot be nominated unless there is an\\n  entity that has the corresponding private key. This is intended to prevent errors in the addition\\n  process.\\n\\n  The governor private key should typically be held in a secure cold wallet.\\n*/\\n/*\\n  Implements Governance for the StarkDex main contract.\\n  The wrapper methods (e.g. mainIsGovernor wrapping _isGovernor) are needed to give\\n  the method unique names.\\n  Both Proxy and StarkExchange inherit from Governance. Thus, the logical contract method names\\n  must have unique names in order for the proxy to successfully delegate to them.\\n*/\\ncontract MainGovernance is GovernanceStorage, Governance {\\n    // The tag is the sting key that is used in the Governance storage mapping.\\n    string public constant MAIN_GOVERNANCE_INFO_TAG = \\\"StarkEx.Main.2019.GovernorsInformation\\\";\\n\\n    /*\\n      Returns the GovernanceInfoStruct associated with the governance tag.\\n    */\\n    function getGovernanceInfo() internal view override returns (GovernanceInfoStruct storage) {\\n        return governanceInfo[MAIN_GOVERNANCE_INFO_TAG];\\n    }\\n\\n    function mainIsGovernor(address user) external view returns (bool) {\\n        return _isGovernor(user);\\n    }\\n\\n    function mainNominateNewGovernor(address newGovernor) external {\\n        _nominateNewGovernor(newGovernor);\\n    }\\n\\n    function mainRemoveGovernor(address governorForRemoval) external {\\n        _removeGovernor(governorForRemoval);\\n    }\\n\\n    function mainAcceptGovernance() external {\\n        _acceptGovernance();\\n    }\\n\\n    function mainCancelNomination() external {\\n        _cancelNomination();\\n    }\\n}\\n\"\r\n    },\r\n    \"MainStorage.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2019-2023 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.12;\\n\\nimport \\\"ProxyStorage.sol\\\";\\nimport \\\"Addresses.sol\\\";\\nimport {ApprovalChainData} from \\\"StarkExTypes.sol\\\";\\n\\n/*\\n  Holds ALL the main contract state (storage) variables.\\n*/\\ncontract MainStorage is ProxyStorage {\\n    uint256 internal constant LAYOUT_LENGTH = 2**64;\\n\\n    address escapeVerifierAddress; // NOLINT: constable-states.\\n\\n    // Global dex-frozen flag.\\n    bool stateFrozen; // NOLINT: constable-states.\\n\\n    // Time when unFreeze can be successfully called (UNFREEZE_DELAY after freeze).\\n    uint256 unFreezeTime; // NOLINT: constable-states.\\n\\n    // Pending deposits.\\n    // A map STARK key => asset id => vault id => quantized amount.\\n    mapping(uint256 => mapping(uint256 => mapping(uint256 => uint256))) pendingDeposits;\\n\\n    // Cancellation requests.\\n    // A map STARK key => asset id => vault id => request timestamp.\\n    mapping(uint256 => mapping(uint256 => mapping(uint256 => uint256))) cancellationRequests;\\n\\n    // Pending withdrawals.\\n    // A map STARK key => asset id => quantized amount.\\n    mapping(uint256 => mapping(uint256 => uint256)) pendingWithdrawals;\\n\\n    // vault_id => escape used boolean.\\n    mapping(uint256 => bool) escapesUsed;\\n\\n    // Number of escapes that were performed when frozen.\\n    uint256 escapesUsedCount; // NOLINT: constable-states.\\n\\n    // NOTE: fullWithdrawalRequests is deprecated, and replaced by forcedActionRequests.\\n    // NOLINTNEXTLINE naming-convention.\\n    mapping(uint256 => mapping(uint256 => uint256)) fullWithdrawalRequests_DEPRECATED;\\n\\n    // State sequence number.\\n    uint256 sequenceNumber; // NOLINT: constable-states uninitialized-state.\\n\\n    // Validium Vaults Tree Root & Height.\\n    uint256 validiumVaultRoot; // NOLINT: constable-states uninitialized-state.\\n    uint256 validiumTreeHeight; // NOLINT: constable-states uninitialized-state.\\n\\n    // Order Tree Root & Height.\\n    uint256 orderRoot; // NOLINT: constable-states uninitialized-state.\\n    uint256 orderTreeHeight; // NOLINT: constable-states uninitialized-state.\\n\\n    // True if and only if the address is allowed to add tokens.\\n    mapping(address => bool) tokenAdmins;\\n\\n    // This mapping is no longer in use, remains for backwards compatibility.\\n    mapping(address => bool) userAdmins_DEPRECATED; // NOLINT: naming-convention.\\n\\n    // True if and only if the address is an operator (allowed to update state).\\n    mapping(address => bool) operators; // NOLINT: uninitialized-state.\\n\\n    // Mapping of contract ID to asset data.\\n    mapping(uint256 => bytes) assetTypeToAssetInfo; // NOLINT: uninitialized-state.\\n\\n    // Mapping of registered contract IDs.\\n    mapping(uint256 => bool) registeredAssetType; // NOLINT: uninitialized-state.\\n\\n    // Mapping from contract ID to quantum.\\n    mapping(uint256 => uint256) assetTypeToQuantum; // NOLINT: uninitialized-state.\\n\\n    // This mapping is no longer in use, remains for backwards compatibility.\\n    mapping(address => uint256) starkKeys_DEPRECATED; // NOLINT: naming-convention.\\n\\n    // Mapping from STARK public key to the Ethereum public key of its owner.\\n    mapping(uint256 => address) ethKeys; // NOLINT: uninitialized-state.\\n\\n    // Timelocked state transition and availability verification chain.\\n    ApprovalChainData verifiersChain;\\n    ApprovalChainData availabilityVerifiersChain;\\n\\n    // Batch id of last accepted proof.\\n    uint256 lastBatchId; // NOLINT: constable-states uninitialized-state.\\n\\n    // Mapping between sub-contract index to sub-contract address.\\n    mapping(uint256 => address) subContracts; // NOLINT: uninitialized-state.\\n\\n    mapping(uint256 => bool) permissiveAssetType_DEPRECATED; // NOLINT: naming-convention.\\n    // ---- END OF MAIN STORAGE AS DEPLOYED IN STARKEX2.0 ----\\n\\n    // Onchain-data version configured for the system.\\n    uint256 onchainDataVersion_DEPRECATED; // NOLINT: naming-convention constable-states.\\n\\n    // Counter of forced action request in block. The key is the block number.\\n    mapping(uint256 => uint256) forcedRequestsInBlock;\\n\\n    // ForcedAction requests: actionHash => requestTime.\\n    mapping(bytes32 => uint256) forcedActionRequests;\\n\\n    // Mapping for timelocked actions.\\n    // A actionKey => activation time.\\n    mapping(bytes32 => uint256) actionsTimeLock;\\n\\n    // Append only list of requested forced action hashes.\\n    bytes32[] actionHashList;\\n    // ---- END OF MAIN STORAGE AS DEPLOYED IN STARKEX3.0 ----\\n    // ---- END OF MAIN STORAGE AS DEPLOYED IN STARKEX4.0 ----\\n\\n    // Rollup Vaults Tree Root & Height.\\n    uint256 rollupVaultRoot; // NOLINT: constable-states uninitialized-state.\\n    uint256 rollupTreeHeight; // NOLINT: constable-states uninitialized-state.\\n\\n    uint256 globalConfigCode; // NOLINT: constable-states uninitialized-state.\\n\\n    // Reserved storage space for Extensibility.\\n    // Every added MUST be added above the end gap, and the __endGap size must be reduced\\n    // accordingly.\\n    // NOLINTNEXTLINE: naming-convention.\\n    uint256[LAYOUT_LENGTH - 40] private __endGap; // __endGap complements layout to LAYOUT_LENGTH.\\n}\\n\"\r\n    },\r\n    \"PerpetualConstants.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2019-2023 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.12;\\n\\nimport \\\"LibConstants.sol\\\";\\n\\ncontract PerpetualConstants is LibConstants {\\n    uint256 constant PERPETUAL_POSITION_ID_UPPER_BOUND = 2**64;\\n    uint256 constant PERPETUAL_AMOUNT_UPPER_BOUND = 2**64;\\n    uint256 constant PERPETUAL_TIMESTAMP_BITS = 32;\\n    uint256 constant PERPETUAL_ASSET_ID_UPPER_BOUND = 2**120;\\n    uint256 constant PERPETUAL_SYSTEM_TIME_LAG_BOUND = 7 days;\\n    uint256 constant PERPETUAL_SYSTEM_TIME_ADVANCE_BOUND = 4 hours;\\n    uint256 constant PERPETUAL_CONFIGURATION_DELAY = 0;\\n}\\n\"\r\n    },\r\n    \"PerpetualForcedActions.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2019-2023 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.12;\\n\\nimport \\\"ForcedTrades.sol\\\";\\nimport \\\"ForcedTradeActionState.sol\\\";\\nimport \\\"ForcedWithdrawals.sol\\\";\\nimport \\\"ForcedWithdrawalActionState.sol\\\";\\nimport \\\"Freezable.sol\\\";\\nimport \\\"KeyGetters.sol\\\";\\nimport \\\"MainGovernance.sol\\\";\\nimport \\\"Users.sol\\\";\\nimport \\\"SubContractor.sol\\\";\\n\\ncontract PerpetualForcedActions is\\n    SubContractor,\\n    MainGovernance,\\n    Freezable,\\n    KeyGetters,\\n    Users,\\n    ForcedTrades,\\n    ForcedTradeActionState,\\n    ForcedWithdrawals,\\n    ForcedWithdrawalActionState\\n{\\n    function initialize(\\n        bytes calldata /* data */\\n    ) external override {\\n        revert(\\\"NOT_IMPLEMENTED\\\");\\n    }\\n\\n    function initializerSize() external view override returns (uint256) {\\n        return 0;\\n    }\\n\\n    function validatedSelectors() external pure override returns (bytes4[] memory selectors) {\\n        uint256 len_ = 5;\\n        uint256 index_ = 0;\\n\\n        selectors = new bytes4[](len_);\\n        selectors[index_++] = ForcedTrades.forcedTradeRequest.selector;\\n        selectors[index_++] = ForcedTrades.freezeRequest.selector;\\n        selectors[index_++] = ForcedWithdrawals.forcedWithdrawalRequest.selector;\\n        selectors[index_++] = ForcedWithdrawals.freezeRequest.selector;\\n        selectors[index_++] = Users.registerEthAddress.selector;\\n        require(index_ == len_, \\\"INCORRECT_SELECTORS_ARRAY_LENGTH\\\");\\n    }\\n\\n    function identify() external pure override returns (string memory) {\\n        return \\\"StarkWare_PerpetualForcedActions_2022_2\\\";\\n    }\\n}\\n\"\r\n    },\r\n    \"PerpetualStorage.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2019-2023 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.12;\\n\\nimport \\\"MainStorage.sol\\\";\\n\\n/*\\n  Extends MainStorage, holds Perpetual App specific state (storage) variables.\\n\\n  ALL State variables that are common to all applications, reside in MainStorage,\\n  whereas ALL the Perpetual app specific ones reside here.\\n*/\\ncontract PerpetualStorage is MainStorage {\\n    uint256 systemAssetType; // NOLINT: constable-states uninitialized-state.\\n\\n    bytes32 public globalConfigurationHash; // NOLINT: constable-states uninitialized-state.\\n\\n    mapping(uint256 => bytes32) public configurationHash; // NOLINT: uninitialized-state.\\n\\n    bytes32 sharedStateHash; // NOLINT: constable-states uninitialized-state.\\n\\n    // Configuration apply time-lock.\\n    // The delay is held in storage (and not constant)\\n    // So that it can be modified during upgrade.\\n    uint256 public configurationDelay; // NOLINT: constable-states.\\n\\n    // Reserved storage space for Extensibility.\\n    // Every added MUST be added above the end gap, and the __endGap size must be reduced\\n    // accordingly.\\n    // NOLINTNEXTLINE: naming-convention shadowing-abstract.\\n    uint256[LAYOUT_LENGTH - 5] private __endGap; // __endGap complements layout to LAYOUT_LENGTH.\\n}\\n\"\r\n    },\r\n    \"ProxyStorage.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2019-2023 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.12;\\n\\nimport \\\"GovernanceStorage.sol\\\";\\n\\n/*\\n  Holds the Proxy-specific state variables.\\n  This contract is inherited by the GovernanceStorage (and indirectly by MainStorage)\\n  to prevent collision hazard.\\n*/\\ncontract ProxyStorage is GovernanceStorage {\\n    // NOLINTNEXTLINE: naming-convention uninitialized-state.\\n    mapping(address => bytes32) internal initializationHash_DEPRECATED;\\n\\n    // The time after which we can switch to the implementation.\\n    // Hash(implementation, data, finalize) => time.\\n    mapping(bytes32 => uint256) internal enabledTime;\\n\\n    // A central storage of the flags whether implementation has been initialized.\\n    // Note - it can be used flexibly enough to accommodate multiple levels of initialization\\n    // (i.e. using different key salting schemes for different initialization levels).\\n    mapping(bytes32 => bool) internal initialized;\\n}\\n\"\r\n    },\r\n    \"StarkExTypes.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2019-2023 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.12;\\n\\n// Structure representing a list of verifiers (validity/availability).\\n// A statement is valid only if all the verifiers in the list agree on it.\\n// Adding a verifier to the list is immediate - this is used for fast resolution of\\n// any soundness issues.\\n// Removing a verifier from the list is time-locked, to ensure that any user of the system\\n// not content with the announced removal has ample time to leave the system before it is\\n// removed.\\nstruct ApprovalChainData {\\n    address[] verifiers;\\n    // Represents the time after which the verifier with the given address can be removed.\\n    // Removal of the verifier with address A is allowed only in the case the value\\n    // of verifierAllowedRemovalTime[A] != 0 and verifierAllowedRemovalTime[A] < (current time).\\n    mapping(address => uint256) verifierAllowedRemovalTime;\\n}\\n\"\r\n    },\r\n    \"SubContractor.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2019-2023 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.12;\\n\\nimport \\\"Identity.sol\\\";\\n\\ninterface SubContractor is Identity {\\n    function initialize(bytes calldata data) external;\\n\\n    function initializerSize() external view returns (uint256);\\n\\n    /*\\n      Returns an array with selectors for validation.\\n      These selectors are the critical ones for maintaining self custody and anti censorship.\\n      During the upgrade process, as part of the sub-contract validation, the MainDispatcher\\n      validates that the selectos are mapped to the correct sub-contract.\\n    */\\n    function validatedSelectors() external pure returns (bytes4[] memory);\\n}\\n\"\r\n    },\r\n    \"Users.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2019-2023 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.12;\\n\\nimport \\\"ECDSA.sol\\\";\\nimport \\\"MainStorage.sol\\\";\\nimport \\\"LibConstants.sol\\\";\\n\\n/**\\n  Users of the Stark Exchange are identified within the exchange by their Stark Key which is a\\n  public key defined over a Stark-friendly elliptic curve that is different from the standard\\n  Ethereum elliptic curve.\\n\\n  The Stark-friendly elliptic curve used is defined as follows:\\n\\n  .. math:: y^2 = (x^3 + \\\\alpha \\\\cdot x + \\\\beta) \\\\% p\\n\\n  where:\\n\\n  .. math:: \\\\alpha = 1\\n  .. math:: \\\\beta = 3141592653589793238462643383279502884197169399375105820974944592307816406665\\n  .. math:: p = 3618502788666131213697322783095070105623107215331596699973092056135872020481\\n\\n  User registration is the mechanism that associates an Ethereum address with a StarkKey\\n  within the main contract context.\\n\\n  User registrations that were done on previous versions (up to v3.0) are still supported.\\n  However, in most cases, there is no need to register a user.\\n  The only flows that require user registration are the anti-concorship flows:\\n  forced actions and deposit cancellation.\\n\\n  User registration is performed by calling :sol:func:`registerEthAddress` with the selected\\n  Stark Key, representing an `x` coordinate on the Stark-friendly elliptic curve,\\n  and the `y` coordinate of the key on the curve (due to the nature of the curve,\\n  only two such possible `y` coordinates exist).\\n\\n  The registration is accepted if the following holds:\\n\\n  1. The key registered is not zero and has not been registered in the past by the user or anyone else.\\n  2. The key provided represents a valid point on the Stark-friendly elliptic curve.\\n  3. The linkage between the provided Ethereum address and the selected Stark Key is signed using\\n     the privte key of the selected Stark Key.\\n\\n  If the above holds, the Ethereum address is registered by the contract, mapping it to the Stark Key.\\n*/\\nabstract contract Users is MainStorage, LibConstants {\\n    event LogUserRegistered(address ethKey, uint256 starkKey, address sender);\\n\\n    function isOnCurve(uint256 starkKey) private view returns (bool) {\\n        uint256 xCubed = mulmod(mulmod(starkKey, starkKey, K_MODULUS), starkKey, K_MODULUS);\\n        return isQuadraticResidue(addmod(addmod(xCubed, starkKey, K_MODULUS), K_BETA, K_MODULUS));\\n    }\\n\\n    function registerSender(uint256 starkKey, bytes calldata starkSignature) external {\\n        registerEthAddress(msg.sender, starkKey, starkSignature);\\n    }\\n\\n    function registerEthAddress(\\n        address ethKey,\\n        uint256 starkKey,\\n        bytes calldata starkSignature\\n    ) public {\\n        // Validate keys and availability.\\n        require(starkKey != 0, \\\"INVALID_STARK_KEY\\\");\\n        require(starkKey < K_MODULUS, \\\"INVALID_STARK_KEY\\\");\\n        require(ethKey != ZERO_ADDRESS, \\\"INVALID_ETH_ADDRESS\\\");\\n        require(ethKeys[starkKey] == ZERO_ADDRESS, \\\"STARK_KEY_UNAVAILABLE\\\");\\n        require(isOnCurve(starkKey), \\\"INVALID_STARK_KEY\\\");\\n        require(starkSignature.length == 32 * 3, \\\"INVALID_STARK_SIGNATURE_LENGTH\\\");\\n\\n        bytes memory sig = starkSignature;\\n        (uint256 r, uint256 s, uint256 StarkKeyY) = abi.decode(sig, (uint256, uint256, uint256));\\n\\n        uint256 msgHash = uint256(\\n            keccak256(abi.encodePacked(\\\"UserRegistration:\\\", ethKey, starkKey))\\n        ) % ECDSA.EC_ORDER;\\n\\n        ECDSA.verify(msgHash, r, s, starkKey, StarkKeyY);\\n\\n        // Update state.\\n        ethKeys[starkKey] = ethKey;\\n\\n        // Log new user.\\n        emit LogUserRegistered(ethKey, starkKey, msg.sender);\\n    }\\n\\n    function fieldPow(uint256 base, uint256 exponent) internal view returns (uint256) {\\n        // NOLINTNEXTLINE: low-level-calls reentrancy-events reentrancy-no-eth.\\n        (bool success, bytes memory returndata) = address(5).staticcall(\\n            abi.encode(0x20, 0x20, 0x20, base, exponent, K_MODULUS)\\n        );\\n        require(success, string(returndata));\\n        return abi.decode(returndata, (uint256));\\n    }\\n\\n    function isQuadraticResidue(uint256 fieldElement) private view returns (bool) {\\n        return 1 == fieldPow(fieldElement, ((K_MODULUS - 1) / 2));\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {},\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 100\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"starkKeyA\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"starkKeyB\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"vaultIdA\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"vaultIdB\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"collateralAssetId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"syntheticAssetId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountCollateral\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountSynthetic\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"aIsBuyingSynthetic\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"LogForcedTradeRequest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"starkKey\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"quantizedAmount\",\"type\":\"uint256\"}],\"name\":\"LogForcedWithdrawalRequest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"LogFrozen\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"acceptedGovernor\",\"type\":\"address\"}],\"name\":\"LogNewGovernorAccepted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"nominatedGovernor\",\"type\":\"address\"}],\"name\":\"LogNominatedGovernor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"LogNominationCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"removedGovernor\",\"type\":\"address\"}],\"name\":\"LogRemovedGovernor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"LogUnFrozen\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"ethKey\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"starkKey\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"LogUserRegistered\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DEPOSIT_CANCEL_DELAY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FREEZE_GRACE_PERIOD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAIN_GOVERNANCE_INFO_TAG\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_FORCED_ACTIONS_REQS_PER_BLOCK\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_VERIFIER_COUNT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"UNFREEZE_DELAY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VERIFIER_REMOVAL_DELAY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"configurationDelay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"configurationHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"starkKeyA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"starkKeyB\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vaultIdA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vaultIdB\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralAssetId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"syntheticAssetId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountCollateral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountSynthetic\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"aIsBuyingSynthetic\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"submissionExpirationTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"internalType\":\"bool\",\"name\":\"premiumCost\",\"type\":\"bool\"}],\"name\":\"forcedTradeRequest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"starkKey\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quantizedAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"premiumCost\",\"type\":\"bool\"}],\"name\":\"forcedWithdrawalRequest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"starkKeyA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"starkKeyB\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vaultIdA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vaultIdB\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralAssetId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"syntheticAssetId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountCollateral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountSynthetic\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"aIsBuyingSynthetic\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"freezeRequest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"starkKey\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quantizedAmount\",\"type\":\"uint256\"}],\"name\":\"freezeRequest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getActionCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"actionIndex\",\"type\":\"uint256\"}],\"name\":\"getActionHashByIndex\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ownerKey\",\"type\":\"uint256\"}],\"name\":\"getEthKey\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"starkKeyA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"starkKeyB\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vaultIdA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vaultIdB\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralAssetId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"syntheticAssetId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountCollateral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountSynthetic\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"aIsBuyingSynthetic\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"getForcedTradeRequest\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"starkKey\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quantizedAmount\",\"type\":\"uint256\"}],\"name\":\"getForcedWithdrawalRequest\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"globalConfigurationHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"identify\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initializerSize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isFrozen\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mainAcceptGovernance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mainCancelNomination\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"mainIsGovernor\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newGovernor\",\"type\":\"address\"}],\"name\":\"mainNominateNewGovernor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"governorForRemoval\",\"type\":\"address\"}],\"name\":\"mainRemoveGovernor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ethKey\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"starkKey\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"starkSignature\",\"type\":\"bytes\"}],\"name\":\"registerEthAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"starkKey\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"starkSignature\",\"type\":\"bytes\"}],\"name\":\"registerSender\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unFreeze\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"validatedSelectors\",\"outputs\":[{\"internalType\":\"bytes4[]\",\"name\":\"selectors\",\"type\":\"bytes4[]\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]", "ContractName": "PerpetualForcedActions", "CompilerVersion": "v0.6.12+commit.27d51765", "OptimizationUsed": "1", "Runs": "100", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "Apache-2.0", "Proxy": "0", "Implementation": "", "SwarmSource": ""}