{"SourceCode": "pragma solidity ^0.4.26;\r\n\r\n// This is the ETH/ERC20 multisig contract for Ownbit.\r\n//\r\n// For 2-of-3 multisig, to authorize a spend, two signtures must be provided by 2 of the 3 owners.\r\n// To generate the message to be signed, provide the destination address and\r\n// spend amount (in wei) to the generateMessageToSign method.\r\n// The signatures must be provided as the (v, r, s) hex-encoded coordinates.\r\n// The S coordinate must be 0x00 or 0x01 corresponding to 0x1b and 0x1c, respectively.\r\n//\r\n// WARNING: The generated message is only valid until the next spend is executed.\r\n//          after that, a new message will need to be calculated.\r\n//\r\n//\r\n// INFO: This contract is ERC20 compatible.\r\n// This contract can both receive ETH and ERC20 tokens.\r\n// Notice that NFT (ERC721/ERC1155) is not supported.\r\n\r\ninterface Erc20 {\r\n  function approve(address, uint256) public;\r\n\r\n  function transfer(address, uint256) public;\r\n    \r\n  //function balanceOf(address) view public returns (uint256);\r\n}\r\n\r\ncontract OwnbitMultiSig {\r\n    \r\n  uint constant public MAX_OWNER_COUNT = 9;\r\n\r\n  // The N addresses which control the funds in this contract. The\r\n  // owners of M of these addresses will need to both sign a message\r\n  // allowing the funds in this contract to be spent.\r\n  mapping(address => bool) private isOwner;\r\n  address[] private owners;\r\n  uint private required;\r\n\r\n  // The contract nonce is not accessible to the contract so we\r\n  // implement a nonce-like variable for replay protection.\r\n  uint256 private spendNonce = 0;\r\n  \r\n  // An event sent when funds are received.\r\n  event Funded(address from, uint value);\r\n  \r\n  // An event sent when a spend is triggered to the given address.\r\n  event Spent(address to, uint transfer);\r\n  \r\n  // An event sent when a spendERC20 is triggered to the given address.\r\n  event SpentERC20(address erc20contract, address to, uint transfer);\r\n  \r\n  // An event sent when an spendAny is executed.\r\n  event SpentAny(address to, uint transfer);\r\n\r\n  modifier validRequirement(uint ownerCount, uint _required) {\r\n    require (ownerCount <= MAX_OWNER_COUNT\r\n            && _required <= ownerCount\r\n            && _required >= 1);\r\n    _;\r\n  }\r\n  \r\n  /// @dev Contract constructor sets initial owners and required number of confirmations.\r\n  /// @param _owners List of initial owners.\r\n  /// @param _required Number of required confirmations.\r\n  constructor(address[] _owners, uint _required) public validRequirement(_owners.length, _required) {\r\n    for (uint i = 0; i < _owners.length; i++) {\r\n        //onwer should be distinct, and non-zero\r\n        if (isOwner[_owners[i]] || _owners[i] == address(0x0)) {\r\n            revert();\r\n        }\r\n        isOwner[_owners[i]] = true;\r\n    }\r\n    owners = _owners;\r\n    required = _required;\r\n  }\r\n\r\n\r\n  // The fallback function for this contract.\r\n  function() public payable {\r\n    if (msg.value > 0) {\r\n        emit Funded(msg.sender, msg.value);\r\n    }\r\n  }\r\n  \r\n  // @dev Returns list of owners.\r\n  // @return List of owner addresses.\r\n  function getOwners() public view returns (address[]) {\r\n    return owners;\r\n  }\r\n    \r\n  function getSpendNonce() public view returns (uint256) {\r\n    return spendNonce;\r\n  }\r\n    \r\n  function getRequired() public view returns (uint) {\r\n    return required;\r\n  }\r\n\r\n  // Generates the message to sign given the output destination address and amount.\r\n  // includes this contract's address and a nonce for replay protection.\r\n  // One option to independently verify: https://leventozturk.com/engineering/sha3/ and select keccak\r\n  function generateMessageToSign(address erc20Contract, address destination, uint256 value) private view returns (bytes32) {\r\n    //the sequence should match generateMultiSigV2 in JS\r\n    bytes32 message = keccak256(abi.encodePacked(address(this), erc20Contract, destination, value, spendNonce));\r\n    return message;\r\n  }\r\n  \r\n  function _messageToRecover(address erc20Contract, address destination, uint256 value) private view returns (bytes32) {\r\n    bytes32 hashedUnsignedMessage = generateMessageToSign(erc20Contract, destination, value);\r\n    bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";\r\n    return keccak256(abi.encodePacked(prefix, hashedUnsignedMessage));\r\n  }\r\n  \r\n  // @destination: the ether receiver address.\r\n  // @value: the ether value, in wei.\r\n  // @vs, rs, ss: the signatures\r\n  function spend(address destination, uint256 value, uint8[] vs, bytes32[] rs, bytes32[] ss) external {\r\n    require(destination != address(this), \"Not allow sending to yourself\");\r\n    require(address(this).balance >= value && value > 0, \"balance or spend value invalid\");\r\n    require(_validSignature(address(0x0), destination, value, vs, rs, ss), \"invalid signatures\");\r\n    spendNonce = spendNonce + 1;\r\n    //transfer will throw if fails\r\n    destination.transfer(value);\r\n    emit Spent(destination, value);\r\n  }\r\n  \r\n  // @erc20contract: the erc20 contract address.\r\n  // @destination: the token receiver address.\r\n  // @value: the token value, in token minimum unit.\r\n  // @vs, rs, ss: the signatures\r\n  function spendERC20(address destination, address erc20contract, uint256 value, uint8[] vs, bytes32[] rs, bytes32[] ss) external {\r\n    require(destination != address(this), \"Not allow sending to yourself\");\r\n    //transfer erc20 token\r\n    //uint256 tokenValue = Erc20(erc20contract).balanceOf(address(this));\r\n    require(value > 0, \"Erc20 spend value invalid\");\r\n    require(_validSignature(erc20contract, destination, value, vs, rs, ss), \"invalid signatures\");\r\n    spendNonce = spendNonce + 1;\r\n    // transfer tokens from this contract to the destination address\r\n    Erc20(erc20contract).transfer(destination, value);\r\n    emit SpentERC20(erc20contract, destination, value);\r\n  }\r\n  \r\n  //0x9 is used for spendAny\r\n  //be careful with any action, data is not included into signature computation. So any data can be included in spendAny.\r\n  //This is usually for some emergent recovery, for example, recovery of NTFs, etc.\r\n  //Owners should not generate 0x9 based signatures in normal cases.\r\n  function spendAny(address destination, uint256 value, uint8[] vs, bytes32[] rs, bytes32[] ss, bytes data) external {\r\n    require(destination != address(this), \"Not allow sending to yourself\");\r\n    require(_validSignature(address(0x9), destination, value, vs, rs, ss), \"invalid signatures\");\r\n    spendNonce = spendNonce + 1;\r\n    //transfer tokens from this contract to the destination address\r\n    if (destination.call.value(value)(data)) {\r\n        emit SpentAny(destination, value);\r\n    }\r\n  }\r\n\r\n  // Confirm that the signature triplets (v1, r1, s1) (v2, r2, s2) ...\r\n  // authorize a spend of this contract's funds to the given destination address.\r\n  function _validSignature(address erc20Contract, address destination, uint256 value, uint8[] vs, bytes32[] rs, bytes32[] ss) private view returns (bool) {\r\n    require(vs.length == rs.length);\r\n    require(rs.length == ss.length);\r\n    require(vs.length <= owners.length);\r\n    require(vs.length >= required);\r\n    bytes32 message = _messageToRecover(erc20Contract, destination, value);\r\n    address[] memory addrs = new address[](vs.length);\r\n    for (uint i = 0; i < vs.length; i++) {\r\n        //recover the address associated with the public key from elliptic curve signature or return zero on error \r\n        addrs[i] = ecrecover(message, vs[i]+27, rs[i], ss[i]);\r\n    }\r\n    require(_distinctOwners(addrs));\r\n    return true;\r\n  }\r\n  \r\n  // Confirm the addresses as distinct owners of this contract.\r\n  function _distinctOwners(address[] addrs) private view returns (bool) {\r\n    if (addrs.length > owners.length) {\r\n        return false;\r\n    }\r\n    for (uint i = 0; i < addrs.length; i++) {\r\n        if (!isOwner[addrs[i]]) {\r\n            return false;\r\n        }\r\n        //address should be distinct\r\n        for (uint j = 0; j < i; j++) {\r\n            if (addrs[i] == addrs[j]) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n  }\r\n  \r\n}", "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"destination\",\"type\":\"address\"},{\"name\":\"erc20contract\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"vs\",\"type\":\"uint8[]\"},{\"name\":\"rs\",\"type\":\"bytes32[]\"},{\"name\":\"ss\",\"type\":\"bytes32[]\"}],\"name\":\"spendERC20\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getRequired\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"destination\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"vs\",\"type\":\"uint8[]\"},{\"name\":\"rs\",\"type\":\"bytes32[]\"},{\"name\":\"ss\",\"type\":\"bytes32[]\"}],\"name\":\"spend\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOwners\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"destination\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"vs\",\"type\":\"uint8[]\"},{\"name\":\"rs\",\"type\":\"bytes32[]\"},{\"name\":\"ss\",\"type\":\"bytes32[]\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"spendAny\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getSpendNonce\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_OWNER_COUNT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owners\",\"type\":\"address[]\"},{\"name\":\"_required\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Funded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"transfer\",\"type\":\"uint256\"}],\"name\":\"Spent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"erc20contract\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"transfer\",\"type\":\"uint256\"}],\"name\":\"SpentERC20\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"transfer\",\"type\":\"uint256\"}],\"name\":\"SpentAny\",\"type\":\"event\"}]", "ContractName": "OwnbitMultiSig", "CompilerVersion": "v0.4.26+commit.4563c3fc", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000003000000000000000000000000dbabb0998c151d63bb4c085cdd2fe8207e26bd07000000000000000000000000b7f192ee414e3a66e1fb7a66cdd1d83ba7ab83f00000000000000000000000000d4814854c3168ad0a7af740d3c07fc71afd9c75", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://78b9bd2ebc8e0cff6a86028165c6917f9c74aace4df5f27fa2001ad2db0e533d"}