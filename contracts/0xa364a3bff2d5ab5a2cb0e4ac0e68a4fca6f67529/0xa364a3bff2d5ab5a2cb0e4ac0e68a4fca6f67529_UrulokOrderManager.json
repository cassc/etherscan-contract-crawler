{"SourceCode": "// SPDX-License-Identifier: UNLICENSED\r\n// Uruloki DEX is NOT LICENSED FOR COPYING.\r\n// Uruloki DEX (C) 2022. All Rights Reserved.\r\n\r\npragma solidity ^0.8.4;\r\n\r\ncontract UrulokOrderManager {\r\n    //// Define enums\r\n    enum OrderType {\r\n        TargetPrice,\r\n        PriceRange\r\n    }\r\n    enum OrderStatus {\r\n        Active,\r\n        Cancelled,\r\n        OutOfFunds,\r\n        Completed\r\n    }\r\n\r\n    //// Define structs\r\n    // One time order, it's a base order struct\r\n    struct OrderBase {\r\n        address userAddress;\r\n        address pairedTokenAddress;\r\n        address tokenAddress;\r\n        OrderType orderType;\r\n        uint256 targetPrice;\r\n        bool isBuy;\r\n        uint256 maxPrice;\r\n        uint256 minPrice;\r\n        OrderStatus status;\r\n        uint256 amount;\r\n        uint256 predictionAmount;\r\n        bool isContinuous;\r\n    }\r\n\r\n    // Continuous Order, it's an extended order struct, including the base order struct\r\n    struct Order {\r\n        OrderBase orderBase;\r\n        uint256 numExecutions;\r\n        uint256 resetPercentage;\r\n        bool hasPriceReset;\r\n    }\r\n\r\n    address public dexAddress;\r\n    mapping(uint256 => Order) public orders;\r\n    uint256 public orderCounter;\r\n\r\n    constructor(address _dexAddress) {\r\n        require(_dexAddress != address(0), \"Error zero address\");\r\n        dexAddress = _dexAddress;\r\n    }\r\n\r\n    modifier onlyDex() {\r\n        require(msg.sender == dexAddress, \"Caller not allowed\");\r\n        _;\r\n    }\r\n\r\n    modifier isExistOrder(uint256 orderId) {\r\n        require(orderId != 0, \"isExistOrder: invalid order id\");\r\n        require(\r\n            orders[orderId].orderBase.userAddress != address(0),\r\n            \"isExistOrder: not exist\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier validatePredictionAmount(uint256 predictionAmount){\r\n        require(predictionAmount >= 0, \"Incorrect predictionAmount\");\r\n        _;\r\n    }\r\n\r\n    function createOneTimeOrder(\r\n        address userAddress,\r\n        address pairedTokenAddress,\r\n        address tokenAddress,\r\n        bool isBuy,\r\n        uint256 targetPrice,\r\n        uint256 minPrice,\r\n        uint256 maxPrice,\r\n        uint256 amount,\r\n        uint256 predictionAmount\r\n    ) \r\n        external \r\n        onlyDex \r\n        validatePredictionAmount(predictionAmount)\r\n        returns (uint256) \r\n    {\r\n        require(userAddress != address(0), \"zero user address\");\r\n        require(amount > 0, \"Amount must be greater than zero\");\r\n        // Check if the token and pair addresses are valid\r\n        require(\r\n            pairedTokenAddress != tokenAddress,\r\n            \"Token and pair addresses must be different\"\r\n        );\r\n        if (targetPrice > 0) {\r\n            require(\r\n                minPrice == 0 && maxPrice == 0,\r\n                \"validateOrder: not target price order\"\r\n            );\r\n        } else {\r\n            require(\r\n                minPrice > 0 && minPrice < maxPrice,\r\n                \"validateOrder: not price range order\"\r\n            );\r\n        }\r\n        OrderBase memory orderBase = OrderBase({\r\n            userAddress: userAddress,\r\n            pairedTokenAddress: pairedTokenAddress,\r\n            tokenAddress: tokenAddress,\r\n            orderType: targetPrice > 0\r\n                ? OrderType.TargetPrice\r\n                : OrderType.PriceRange,\r\n            targetPrice: targetPrice,\r\n            isBuy: isBuy,\r\n            minPrice: minPrice,\r\n            maxPrice: maxPrice,\r\n            status: OrderStatus.Active,\r\n            amount: amount,\r\n            predictionAmount: predictionAmount,\r\n            isContinuous: false\r\n        });\r\n        Order memory order = Order({\r\n            orderBase: orderBase,\r\n            numExecutions: 0,\r\n            resetPercentage: 0,\r\n            hasPriceReset: false\r\n        });\r\n\r\n        // Add the ContinuousOrder to the orders mapping\r\n        orders[++orderCounter] = order;\r\n        return orderCounter;\r\n    }\r\n\r\n    function createContinuousOrder(\r\n        address userAddress,\r\n        address pairedTokenAddress,\r\n        address tokenAddress,\r\n        bool isBuy,\r\n        uint256 targetPrice,\r\n        uint256 minPrice,\r\n        uint256 maxPrice,\r\n        uint256 amount,\r\n        uint256 predictionAmount,\r\n        uint256 resetPercentage\r\n    ) \r\n        external \r\n        onlyDex \r\n        validatePredictionAmount(predictionAmount)\r\n        returns (uint256) \r\n    {\r\n        require(userAddress != address(0), \"zero user address\");\r\n        require(amount > 0, \"Amount must be greater than zero\");\r\n        // Check if the token and pair addresses are valid\r\n        require(\r\n            pairedTokenAddress != tokenAddress,\r\n            \"Token and pair addresses must be different\"\r\n        );\r\n        if (targetPrice > 0) {\r\n            require(\r\n                minPrice == 0 && maxPrice == 0,\r\n                \"validateOrder: not target price order\"\r\n            );\r\n        } else {\r\n            require(\r\n                minPrice > 0 && minPrice < maxPrice,\r\n                \"validateOrder: not price range order\"\r\n            );\r\n        }\r\n        // Validate inputs\r\n        require(\r\n            resetPercentage > 0 && resetPercentage < 100,\r\n            \"Invalid reset percentage\"\r\n        );\r\n\r\n        // Create the ContinuousOrder struct\r\n        OrderBase memory orderBase = OrderBase({\r\n            userAddress: userAddress,\r\n            pairedTokenAddress: pairedTokenAddress,\r\n            tokenAddress: tokenAddress,\r\n            orderType: targetPrice > 0\r\n                ? OrderType.TargetPrice\r\n                : OrderType.PriceRange,\r\n            targetPrice: targetPrice,\r\n            isBuy: isBuy,\r\n            minPrice: minPrice,\r\n            maxPrice: maxPrice,\r\n            status: OrderStatus.Active,\r\n            amount: amount,\r\n            predictionAmount: predictionAmount,\r\n            isContinuous: true\r\n        });\r\n        Order memory order = Order({\r\n            orderBase: orderBase,\r\n            numExecutions: 0,\r\n            resetPercentage: resetPercentage,\r\n            hasPriceReset: true\r\n        });\r\n\r\n        // Add the ContinuousOrder to the orders mapping\r\n        orders[++orderCounter] = order;\r\n        return orderCounter;\r\n    }\r\n\r\n    function updateOrder(\r\n        uint256 orderId,\r\n        address pairedTokenAddress,\r\n        address tokenAddress,\r\n        bool isBuy,\r\n        uint256 targetPrice,\r\n        uint256 minPrice,\r\n        uint256 maxPrice,\r\n        uint256 amount,\r\n        uint256 predictionAmount,\r\n        uint256 resetPercentage\r\n    ) \r\n        external \r\n        onlyDex \r\n        isExistOrder(orderId) \r\n        validatePredictionAmount(predictionAmount)\r\n    {\r\n        require(amount > 0, \"Amount must be greater than zero\");\r\n        // Check if the token and pair addresses are valid\r\n        require(\r\n            pairedTokenAddress != tokenAddress,\r\n            \"Token and pair addresses must be different\"\r\n        );\r\n\r\n        if (targetPrice > 0) {\r\n            require(\r\n                minPrice == 0 && maxPrice == 0,\r\n                \"validateOrder: not target price order\"\r\n            );\r\n        } else {\r\n            require(\r\n                minPrice > 0 && minPrice < maxPrice,\r\n                \"validateOrder: not price range order\"\r\n            );\r\n        }\r\n        if (orders[orderId].orderBase.isContinuous) {\r\n            require(\r\n                resetPercentage > 0 && resetPercentage < 100,\r\n                \"Invalid reset percentage\"\r\n            );\r\n        }\r\n\r\n        orders[orderId].orderBase.pairedTokenAddress = pairedTokenAddress;\r\n        orders[orderId].orderBase.tokenAddress = tokenAddress;\r\n        orders[orderId].orderBase.isBuy = isBuy;\r\n        orders[orderId].orderBase.orderType = targetPrice > 0\r\n            ? OrderType.TargetPrice\r\n            : OrderType.PriceRange;\r\n        orders[orderId].orderBase.targetPrice = targetPrice;\r\n        orders[orderId].orderBase.minPrice = minPrice;\r\n        orders[orderId].orderBase.maxPrice = maxPrice;\r\n        orders[orderId].orderBase.amount = amount;\r\n        orders[orderId].orderBase.predictionAmount = predictionAmount;\r\n        orders[orderId].resetPercentage = resetPercentage;\r\n    }\r\n\r\n    /**\r\n     * @dev cancel exist order\r\n     * @param orderId order id\r\n     * @return orderId\r\n     */\r\n    function cancelOrder(\r\n        uint256 orderId\r\n    ) external onlyDex isExistOrder(orderId) returns (uint256) {\r\n        Order memory order = orders[orderId];\r\n        if (order.orderBase.isContinuous == false) {\r\n            require(\r\n                order.orderBase.status == OrderStatus.Active,\r\n                \"cancelOrder: order not active\"\r\n            );\r\n        } else {\r\n            require(\r\n                order.orderBase.status != OrderStatus.Cancelled,\r\n                \"cancelOrder: order already cancelled\"\r\n            );\r\n        }\r\n        orders[orderId].orderBase.status = OrderStatus.Cancelled;\r\n        return orderId;\r\n    }\r\n\r\n    function getOrder(\r\n        uint256 orderId\r\n    ) external view isExistOrder(orderId) returns (Order memory) {\r\n        return orders[orderId];\r\n    }\r\n\r\n    function setOrderStatus(\r\n        uint256 orderId,\r\n        OrderStatus status\r\n    ) external onlyDex isExistOrder(orderId) {\r\n        orders[orderId].orderBase.status = status;\r\n    }\r\n\r\n    function incNumExecutions(\r\n        uint256 orderId\r\n    ) external onlyDex isExistOrder(orderId) {\r\n        orders[orderId].numExecutions++;\r\n    }\r\n\r\n    function setHasPriceReset(\r\n        uint256 orderId,\r\n        bool flag\r\n    ) external onlyDex isExistOrder(orderId) {\r\n        orders[orderId].hasPriceReset = flag;\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_dexAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"}],\"name\":\"cancelOrder\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"pairedTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isBuy\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"targetPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"predictionAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"resetPercentage\",\"type\":\"uint256\"}],\"name\":\"createContinuousOrder\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"pairedTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isBuy\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"targetPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"predictionAmount\",\"type\":\"uint256\"}],\"name\":\"createOneTimeOrder\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dexAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"}],\"name\":\"getOrder\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"pairedTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"enum UrulokOrderManager.OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"targetPrice\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isBuy\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"maxPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minPrice\",\"type\":\"uint256\"},{\"internalType\":\"enum UrulokOrderManager.OrderStatus\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"predictionAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isContinuous\",\"type\":\"bool\"}],\"internalType\":\"struct UrulokOrderManager.OrderBase\",\"name\":\"orderBase\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"numExecutions\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"resetPercentage\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"hasPriceReset\",\"type\":\"bool\"}],\"internalType\":\"struct UrulokOrderManager.Order\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"}],\"name\":\"incNumExecutions\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"orderCounter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"orders\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"pairedTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"enum UrulokOrderManager.OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"targetPrice\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isBuy\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"maxPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minPrice\",\"type\":\"uint256\"},{\"internalType\":\"enum UrulokOrderManager.OrderStatus\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"predictionAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isContinuous\",\"type\":\"bool\"}],\"internalType\":\"struct UrulokOrderManager.OrderBase\",\"name\":\"orderBase\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"numExecutions\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"resetPercentage\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"hasPriceReset\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"flag\",\"type\":\"bool\"}],\"name\":\"setHasPriceReset\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"},{\"internalType\":\"enum UrulokOrderManager.OrderStatus\",\"name\":\"status\",\"type\":\"uint8\"}],\"name\":\"setOrderStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"pairedTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isBuy\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"targetPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"predictionAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"resetPercentage\",\"type\":\"uint256\"}],\"name\":\"updateOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "UrulokOrderManager", "CompilerVersion": "v0.8.21+commit.d9974bed", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000007a250d5630b4cf539739df2c5dacb4c659f2488d", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://57f94ba62162c193534af7aa1c3beafed859f6fcf9b64beed8097dc9da56b6b4"}