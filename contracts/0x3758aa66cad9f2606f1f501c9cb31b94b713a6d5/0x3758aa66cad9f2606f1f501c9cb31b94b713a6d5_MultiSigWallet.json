{"SourceCode": "/**\r\n *Submitted for verification at Etherscan.io on 2020-07-09\r\n*/\r\n\r\npragma solidity ^0.5.5;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following \r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts an `address` into `address payable`. Note that this is\r\n     * simply a type cast: the actual underlying value is not changed.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function toPayable(address account) internal pure returns (address payable) {\r\n        return address(uint160(account));\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-call-value\r\n        (bool success, ) = recipient.call.value(amount)(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n}\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see {ERC20Detailed}.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves.\r\n\r\n        // A Solidity high level call has three parts:\r\n        //  1. The target address is checked to verify it contains contract code\r\n        //  2. The call itself is made, and success asserted\r\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\r\n        // solhint-disable-next-line max-line-length\r\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success, \"SafeERC20: low-level call failed\");\r\n\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\ncontract MultiSigWallet {\r\n    using Address for address;\r\n    using SafeERC20 for IERC20;\r\n    using SafeMath for uint256;\r\n\r\n    modifier isOwner{\r\n        require(owner == msg.sender, \"Only owner can execute it\");\r\n        _;\r\n    }\r\n    modifier isManager{\r\n        require(managers[msg.sender] == 1, \"Only manager can execute it\");\r\n        _;\r\n    }\r\n    // \u7528\u4e8e\u63d0\u73b0\r\n    struct TxWithdraw {\r\n        uint8 e;\r\n        address payable to;\r\n        uint256 amount;\r\n        bool isERC20;\r\n        address ERC20;\r\n        Signature signature;\r\n    }\r\n    // \u7528\u4e8e\u7ba1\u7406\u5458\u53d8\u66f4\r\n    struct TxManagerChange {\r\n        uint8 e;\r\n        address[] adds;\r\n        address[] removes;\r\n        Signature signature;\r\n    }\r\n    // \u7528\u4e8e\u5408\u7ea6\u5347\u7ea7\r\n    struct TxUpgrade {\r\n        uint8 e;\r\n        Signature signature;\r\n    }\r\n    struct Signature {\r\n        uint8 signatureCount;\r\n        address[] signed;\r\n        mapping(address => uint8) signatures;\r\n    }\r\n    struct Validator {\r\n        uint8 e;\r\n        mapping(address => uint8) addsMap;\r\n        mapping(address => uint8) removesMap;\r\n    }\r\n    bool public upgrade = false;\r\n    // \u6700\u5927\u7ba1\u7406\u5458\u6570\u91cf\r\n    uint public max_managers = 15;\r\n    // \u6700\u5c0f\u7b7e\u540d\u6bd4\u4f8b 66%\r\n    uint public rate = 66;\r\n    // \u6bd4\u4f8b\u5206\u6bcd\r\n    uint constant DENOMINATOR = 100;\r\n    string constant UPDATE_SEED_MANAGERS = \"updateSeedManagers\";\r\n    // \u5f53\u524d\u63d0\u73b0\u4ea4\u6613\u7684\u6700\u5c0f\u7b7e\u540d\u6570\u91cf\r\n    uint8 public current_withdraw_min_signatures;\r\n    address public owner;\r\n    mapping(address => uint8) private seedManagers;\r\n    address[] public seedManagerArray;\r\n    mapping(address => uint8) private managers;\r\n    address[] private managerArray;\r\n    mapping(string => TxWithdraw) private pendingTxWithdraws;\r\n    mapping(string => TxManagerChange) private pendingTxManagerChanges;\r\n    mapping(string => TxUpgrade) private pendingTxUpgrade;\r\n    uint public pendingChangeCount = 0;\r\n    mapping(string => uint8) private completedTxs;\r\n    mapping(string => Validator) private validatorManager;\r\n\r\n    constructor(address[] memory _managers) public{\r\n        require(_managers.length <= max_managers, \"Exceeded the maximum number of managers\");\r\n        owner = msg.sender;\r\n        managerArray = _managers;\r\n        for (uint8 i = 0; i < managerArray.length; i++) {\r\n            managers[managerArray[i]] = 1;\r\n            seedManagers[managerArray[i]] = 1;\r\n            seedManagerArray.push(managerArray[i]);\r\n        }\r\n        require(managers[owner] == 0, \"Contract creator cannot act as manager\");\r\n        // \u8bbe\u7f6e\u5f53\u524d\u63d0\u73b0\u4ea4\u6613\u7684\u6700\u5c0f\u7b7e\u540d\u6570\u91cf\r\n        current_withdraw_min_signatures = calMinSignatures(managerArray.length);\r\n    }\r\n    function() external payable {\r\n        emit DepositFunds(msg.sender, msg.value);\r\n    }\r\n    function createOrSignWithdraw(string memory txKey, address payable to, uint256 amount, bool isERC20, address ERC20) public isManager {\r\n        require(to != address(0), \"Withdraw: transfer to the zero address\");\r\n        require(amount > 0, \"Withdrawal amount must be greater than 0\");\r\n        // \u6821\u9a8c\u5df2\u7ecf\u5b8c\u6210\u7684\u4ea4\u6613\r\n        require(completedTxs[txKey] == 0, \"Transaction has been completed\");\r\n        // \u82e5\u4ea4\u6613\u5df2\u521b\u5efa\uff0c\u5219\u7b7e\u540d\u4ea4\u6613\r\n        if (pendingTxWithdraws[txKey].e != 0) {\r\n            signTx(txKey);\r\n            return;\r\n        }\r\n        if (isERC20) {\r\n            validateTransferERC20(ERC20, to, amount);\r\n        } else {\r\n            require(address(this).balance >= amount, \"This contract address does not have sufficient balance of ether\");\r\n        }\r\n        TxWithdraw memory tx1;\r\n        pendingTxWithdraws[txKey] = tx1;\r\n        TxWithdraw storage _tx = pendingTxWithdraws[txKey];\r\n        _tx.e = 1;\r\n        _tx.to = to;\r\n        _tx.amount = amount;\r\n        _tx.isERC20 = isERC20;\r\n        _tx.ERC20 = ERC20;\r\n        _tx.signature.signatureCount = 1;\r\n        _tx.signature.signed.push(msg.sender);\r\n        _tx.signature.signatures[msg.sender] = 1;\r\n    }\r\n    function signTx(string memory txKey) internal {\r\n        TxWithdraw storage tx1 = pendingTxWithdraws[txKey];\r\n        bool canWithdraw = isCompleteSign(tx1.signature, current_withdraw_min_signatures, 0);\r\n        if (canWithdraw) {\r\n            address[] memory signers = getSigners(tx1.signature);\r\n            if (tx1.isERC20) {\r\n                transferERC20(tx1.ERC20, tx1.to, tx1.amount);\r\n            } else {\r\n                // \u5b9e\u9645\u5230\u8d26\r\n                uint transferAmount = tx1.amount;\r\n                require(address(this).balance >= transferAmount, \"This contract address does not have sufficient balance of ether\");\r\n                tx1.to.transfer(transferAmount);\r\n                emit TransferFunds(tx1.to, transferAmount);\r\n            }\r\n            emit TxWithdrawCompleted(signers, txKey);\r\n            // \u79fb\u9664\u6682\u5b58\u6570\u636e\r\n            deletePendingTx(txKey, tx1.e, 1);\r\n        }\r\n    }\r\n    function createOrSignManagerChange(string memory txKey, address[] memory adds, address[] memory removes, uint8 count) public isManager {\r\n        require(adds.length > 0 || removes.length > 0, \"There are no managers joining or exiting\");\r\n        // \u6821\u9a8c\u5df2\u7ecf\u5b8c\u6210\u7684\u4ea4\u6613\r\n        require(completedTxs[txKey] == 0, \"Transaction has been completed\");\r\n        // \u82e5\u4ea4\u6613\u5df2\u521b\u5efa\uff0c\u5219\u7b7e\u540d\u4ea4\u6613\r\n        if (pendingTxManagerChanges[txKey].e != 0) {\r\n            signTxManagerChange(txKey);\r\n            return;\r\n        }\r\n        preValidateAddsAndRemoves(txKey, adds, removes, false);\r\n        TxManagerChange memory tx1;\r\n        pendingTxManagerChanges[txKey] = tx1;\r\n        TxManagerChange storage _tx = pendingTxManagerChanges[txKey];\r\n        if (count == 0) {\r\n            count = 1;\r\n        }\r\n        _tx.e = count;\r\n        _tx.adds = adds;\r\n        _tx.removes = removes;\r\n        _tx.signature.signed.push(msg.sender);\r\n        _tx.signature.signatures[msg.sender] = 1;\r\n        _tx.signature.signatureCount = 1;\r\n        pendingChangeCount++;\r\n    }\r\n    function signTxManagerChange(string memory txKey) internal {\r\n        TxManagerChange storage tx1 = pendingTxManagerChanges[txKey];\r\n        address[] memory removes = tx1.removes;\r\n        uint removeLengh = removes.length;\r\n        if(removeLengh > 0) {\r\n            for (uint i = 0; i < removeLengh; i++) {\r\n                if (removes[i] == msg.sender) {\r\n                    revert(\"Exiting manager cannot participate in manager change transactions\");\r\n                }\r\n            }\r\n        }\r\n        bool canChange = isCompleteSign(tx1.signature, 0, removeLengh);\r\n        if (canChange) {\r\n            // \u53d8\u66f4\u7ba1\u7406\u5458\r\n            removeManager(tx1.removes, false);\r\n            addManager(tx1.adds, false);\r\n            // \u66f4\u65b0\u5f53\u524d\u63d0\u73b0\u4ea4\u6613\u7684\u6700\u5c0f\u7b7e\u540d\u6570\r\n            current_withdraw_min_signatures = calMinSignatures(managerArray.length);\r\n            pendingChangeCount--;\r\n            address[] memory signers = getSigners(tx1.signature);\r\n            // add managerChange event\r\n            emit TxManagerChangeCompleted(signers, txKey);\r\n            // \u79fb\u9664\u6682\u5b58\u6570\u636e\r\n            deletePendingTx(txKey, tx1.e, 2);\r\n        }\r\n    }\r\n    function createOrSignUpgrade(string memory txKey) public isManager {\r\n        // \u6821\u9a8c\u5df2\u7ecf\u5b8c\u6210\u7684\u4ea4\u6613\r\n        require(completedTxs[txKey] == 0, \"Transaction has been completed\");\r\n        // \u82e5\u4ea4\u6613\u5df2\u521b\u5efa\uff0c\u5219\u7b7e\u540d\u4ea4\u6613\r\n        if (pendingTxUpgrade[txKey].e != 0) {\r\n            signTxUpgrade(txKey);\r\n            return;\r\n        }\r\n        TxUpgrade memory tx1;\r\n        pendingTxUpgrade[txKey] = tx1;\r\n        TxUpgrade storage _tx = pendingTxUpgrade[txKey];\r\n        _tx.e = 1;\r\n        _tx.signature.signed.push(msg.sender);\r\n        _tx.signature.signatures[msg.sender] = 1;\r\n        _tx.signature.signatureCount = 1;\r\n    }\r\n    function signTxUpgrade(string memory txKey) internal {\r\n        TxUpgrade storage tx1 = pendingTxUpgrade[txKey];\r\n        bool canUpgrade= isCompleteSign(tx1.signature, current_withdraw_min_signatures, 0);\r\n        if (canUpgrade) {\r\n            // \u53d8\u66f4\u53ef\u5347\u7ea7\r\n            upgrade = true;\r\n            address[] memory signers = getSigners(tx1.signature);\r\n            // add managerChange event\r\n            emit TxUpgradeCompleted(signers, txKey);\r\n            // \u79fb\u9664\u6682\u5b58\u6570\u636e\r\n            deletePendingTx(txKey, tx1.e, 3);\r\n        }\r\n    }\r\n    function isCompleteSign(Signature storage signature, uint8 min_signatures, uint removeLengh) internal returns (bool){\r\n        bool complete = false;\r\n        // \u8ba1\u7b97\u5f53\u524d\u6709\u6548\u7b7e\u540d\r\n        signature.signatureCount = calValidSignatureCount(signature);\r\n        if (min_signatures == 0) {\r\n            min_signatures = calMinSignatures(managerArray.length - removeLengh);\r\n        }\r\n        if (signature.signatureCount >= min_signatures) {\r\n            complete = true;\r\n        }\r\n        if (!complete) {\r\n            require(signature.signatures[msg.sender] == 0, \"Duplicate signature\");\r\n            signature.signed.push(msg.sender);\r\n            signature.signatures[msg.sender] = 1;\r\n            signature.signatureCount++;\r\n            if (signature.signatureCount >= min_signatures) {\r\n                complete = true;\r\n            }\r\n        }\r\n        return complete;\r\n    }\r\n    function calValidSignatureCount(Signature storage signature) internal returns (uint8){\r\n        // \u904d\u5386\u5df2\u7b7e\u540d\u5217\u8868\uff0c\u7b5b\u9009\u6709\u6548\u7b7e\u540d\u6570\u91cf\r\n        uint8 count = 0;\r\n        uint len = signature.signed.length;\r\n        for (uint i = 0; i < len; i++) {\r\n            if (managers[signature.signed[i]] > 0) {\r\n                count++;\r\n            } else {\r\n                delete signature.signatures[signature.signed[i]];\r\n            }\r\n        }\r\n        return count;\r\n    }\r\n    function getSigners(Signature storage signature) internal returns (address[] memory){\r\n        address[] memory signers = new address[](signature.signatureCount);\r\n        // \u904d\u5386\u7ba1\u7406\u5458\u5217\u8868\uff0c\u7b5b\u9009\u5df2\u7b7e\u540d\u6570\u7ec4\r\n        uint len = managerArray.length;\r\n        uint k = 0;\r\n        for (uint i = 0; i < len; i++) {\r\n            if (signature.signatures[managerArray[i]] > 0) {\r\n                signers[k++] = managerArray[i];\r\n                delete signature.signatures[managerArray[i]];\r\n            }\r\n        }\r\n        return signers;\r\n    }\r\n    function preValidateAddsAndRemoves(string memory txKey, address[] memory adds, address[] memory removes, bool _isOwner) internal {\r\n        Validator memory _validator;\r\n        validatorManager[txKey] = _validator;\r\n        // \u6821\u9a8cadds\r\n        mapping(address => uint8) storage validateAdds = validatorManager[txKey].addsMap;\r\n        uint addLen = adds.length;\r\n        for (uint i = 0; i < addLen; i++) {\r\n            address add = adds[i];\r\n            require(managers[add] == 0, \"The address list that is being added already exists as a manager\");\r\n            require(validateAdds[add] == 0, \"Duplicate parameters for the address to join\");\r\n            validateAdds[add] = 1;\r\n        }\r\n        require(validateAdds[owner] == 0, \"Contract creator cannot act as manager\");\r\n        // \u6821\u9a8cremoves\r\n        mapping(address => uint8) storage validateRemoves = validatorManager[txKey].removesMap;\r\n        uint removeLen = removes.length;\r\n        for (uint i = 0; i < removeLen; i++) {\r\n            address remove = removes[i];\r\n            require(_isOwner || seedManagers[remove] == 0, \"Can't exit seed manager\");\r\n            require(!_isOwner || seedManagers[remove] == 1, \"Can only exit the seed manager\");\r\n            require(managers[remove] == 1, \"There are addresses in the exiting address list that are not manager\");\r\n            require(validateRemoves[remove] == 0, \"Duplicate parameters for the address to exit\");\r\n            validateRemoves[remove] = 1;\r\n        }\r\n        require(validateRemoves[msg.sender] == 0, \"Exiting manager cannot participate in manager change transactions\");\r\n        require(managerArray.length + addLen - removeLen <= max_managers, \"Exceeded the maximum number of managers\");\r\n        clearValidatorManager(txKey, adds, removes);\r\n    }\r\n    function clearValidatorManager(string memory txKey, address[] memory adds, address[] memory removes) internal {\r\n        uint addLen = adds.length;\r\n        if(addLen > 0) {\r\n            mapping(address => uint8) storage validateAdds = validatorManager[txKey].addsMap;\r\n            for (uint i = 0; i < addLen; i++) {\r\n                delete validateAdds[adds[i]];\r\n            }\r\n        }\r\n        uint removeLen = removes.length;\r\n        if(removeLen > 0) {\r\n            mapping(address => uint8) storage validateRemoves = validatorManager[txKey].removesMap;\r\n            for (uint i = 0; i < removeLen; i++) {\r\n                delete validateRemoves[removes[i]];\r\n            }\r\n        }\r\n        delete validatorManager[txKey];\r\n    }\r\n    function updateSeedManagers(address[] memory adds, address[] memory removes) public isOwner {\r\n        require(adds.length > 0 || removes.length > 0, \"There are no managers joining or exiting\");\r\n        preValidateAddsAndRemoves(UPDATE_SEED_MANAGERS, adds, removes, true);\r\n        // \u53d8\u66f4\u7ba1\u7406\u5458\r\n        removeManager(removes, true);\r\n        addManager(adds, true);\r\n        // \u66f4\u65b0\u5f53\u524d\u63d0\u73b0\u4ea4\u6613\u7684\u6700\u5c0f\u7b7e\u540d\u6570\r\n        current_withdraw_min_signatures = calMinSignatures(managerArray.length);\r\n        // add managerChange event\r\n        emit TxManagerChangeCompleted(new address[](0), UPDATE_SEED_MANAGERS);\r\n    }\r\n    function updateMaxManagers(uint _max_managers) public isOwner {\r\n        max_managers = _max_managers;\r\n    }\r\n    /*\r\n     \u6839\u636e `\u5f53\u524d\u6709\u6548\u7ba1\u7406\u5458\u6570\u91cf` \u548c `\u6700\u5c0f\u7b7e\u540d\u6bd4\u4f8b` \u8ba1\u7b97\u6700\u5c0f\u7b7e\u540d\u6570\u91cf\uff0c\u5411\u4e0a\u53d6\u6574\r\n    */\r\n    function calMinSignatures(uint managerCounts) internal view returns (uint8) {\r\n        if (managerCounts == 0) {\r\n            return 0;\r\n        }\r\n        uint numerator = rate * managerCounts + DENOMINATOR - 1;\r\n        return uint8(numerator / DENOMINATOR);\r\n    }\r\n    function removeManager(address[] memory removes, bool _isSeed) internal {\r\n        if (removes.length == 0) {\r\n            return;\r\n        }\r\n        for (uint i = 0; i < removes.length; i++) {\r\n            address remove = removes[i];\r\n            managers[remove] = 0;\r\n            if (_isSeed) {\r\n                seedManagers[remove] = 0;\r\n            }\r\n        }\r\n        uint newLength = managerArray.length - removes.length;\r\n        address[] memory tempManagers = new address[](newLength);\r\n        // \u904d\u5386\u4fee\u6539\u524d\u7ba1\u7406\u5458\u5217\u8868\r\n        uint k = 0;\r\n        for (uint i = 0; i < managerArray.length; i++) {\r\n            if (managers[managerArray[i]] == 1) {\r\n                tempManagers[k++] = managerArray[i];\r\n            }\r\n        }\r\n        delete managerArray;\r\n        managerArray = tempManagers;\r\n        if (_isSeed) {\r\n            uint _newLength = seedManagerArray.length - removes.length;\r\n            address[] memory _tempManagers = new address[](_newLength);\r\n            // \u904d\u5386\u4fee\u6539\u524d\u7ba1\u7406\u5458\u5217\u8868\r\n            uint t = 0;\r\n            for (uint i = 0; i < seedManagerArray.length; i++) {\r\n                if (seedManagers[seedManagerArray[i]] == 1) {\r\n                    _tempManagers[t++] = seedManagerArray[i];\r\n                }\r\n            }\r\n            delete seedManagerArray;\r\n            seedManagerArray = _tempManagers;\r\n        }\r\n    }\r\n    function addManager(address[] memory adds, bool _isSeed) internal {\r\n        if (adds.length == 0) {\r\n            return;\r\n        }\r\n        for (uint i = 0; i < adds.length; i++) {\r\n            address add = adds[i];\r\n            if(managers[add] == 0) {\r\n                managers[add] = 1;\r\n                managerArray.push(add);\r\n            }\r\n            if (_isSeed && seedManagers[add] == 0) {\r\n                seedManagers[add] = 1;\r\n                seedManagerArray.push(add);\r\n            }\r\n        }\r\n    }\r\n    function deletePendingTx(string memory txKey, uint8 e, uint types) internal {\r\n        completedTxs[txKey] = e;\r\n        if (types == 1) {\r\n            delete pendingTxWithdraws[txKey];\r\n        } else if (types == 3) {\r\n            delete pendingTxUpgrade[txKey];\r\n        }\r\n    }\r\n    function validateTransferERC20(address ERC20, address to, uint256 amount) internal view {\r\n        require(to != address(0), \"ERC20: transfer to the zero address\");\r\n        require(address(this) != ERC20, \"Do nothing by yourself\");\r\n        require(ERC20.isContract(), \"the address is not a contract address\");\r\n        IERC20 token = IERC20(ERC20);\r\n        uint256 balance = token.balanceOf(address(this));\r\n        require(balance >= amount, \"No enough balance\");\r\n    }\r\n    function transferERC20(address ERC20, address to, uint256 amount) internal {\r\n        IERC20 token = IERC20(ERC20);\r\n        uint256 balance = token.balanceOf(address(this));\r\n        require(balance >= amount, \"No enough balance\");\r\n        token.safeTransfer(to, amount);\r\n    }\r\n    function upgradeContractS1() public isOwner {\r\n        require(upgrade, \"Denied\");\r\n        address(uint160(owner)).transfer(address(this).balance);\r\n    }\r\n    function upgradeContractS2(address ERC20, address to, uint256 amount) public isOwner {\r\n        require(upgrade, \"Denied\");\r\n        validateTransferERC20(ERC20, to, amount);\r\n        transferERC20(ERC20, to, amount);\r\n    }\r\n    function isCompletedTx(string memory txKey) public view returns (bool){\r\n        return completedTxs[txKey] > 0;\r\n    }\r\n    function pendingWithdrawTx(string memory txKey) public view returns (address to, uint256 amount, bool isERC20, address ERC20, uint8 signatureCount) {\r\n        TxWithdraw storage tx1 = pendingTxWithdraws[txKey];\r\n        return (tx1.to, tx1.amount, tx1.isERC20, tx1.ERC20, tx1.signature.signatureCount);\r\n    }\r\n    function pendingManagerChangeTx(string memory txKey) public view returns (uint8 txCount, string memory key, address[] memory adds, address[] memory removes, uint8 signatureCount) {\r\n        TxManagerChange storage tx1 = pendingTxManagerChanges[txKey];\r\n        return (tx1.e, txKey, tx1.adds, tx1.removes, tx1.signature.signatureCount);\r\n    }\r\n    function ifManager(address _manager) public view returns (bool) {\r\n        return managers[_manager] == 1;\r\n    }\r\n    function allManagers() public view returns (address[] memory) {\r\n        return managerArray;\r\n    }\r\n    event DepositFunds(address from, uint amount);\r\n    event TransferFunds( address to, uint amount );\r\n    event TxWithdrawCompleted( address[] signers, string txKey );\r\n    event TxManagerChangeCompleted( address[] signers, string txKey );\r\n    event TxUpgradeCompleted( address[] signers, string txKey );\r\n}", "ABI": "[{\"constant\":false,\"inputs\":[],\"name\":\"upgradeContractS1\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"txKey\",\"type\":\"string\"}],\"name\":\"pendingManagerChangeTx\",\"outputs\":[{\"name\":\"txCount\",\"type\":\"uint8\"},{\"name\":\"key\",\"type\":\"string\"},{\"name\":\"adds\",\"type\":\"address[]\"},{\"name\":\"removes\",\"type\":\"address[]\"},{\"name\":\"signatureCount\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"txKey\",\"type\":\"string\"}],\"name\":\"pendingWithdrawTx\",\"outputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"isERC20\",\"type\":\"bool\"},{\"name\":\"ERC20\",\"type\":\"address\"},{\"name\":\"signatureCount\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"txKey\",\"type\":\"string\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"isERC20\",\"type\":\"bool\"},{\"name\":\"ERC20\",\"type\":\"address\"}],\"name\":\"createOrSignWithdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_manager\",\"type\":\"address\"}],\"name\":\"ifManager\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"txKey\",\"type\":\"string\"}],\"name\":\"createOrSignUpgrade\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"allManagers\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"seedManagerArray\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"current_withdraw_min_signatures\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"txKey\",\"type\":\"string\"}],\"name\":\"isCompletedTx\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"ERC20\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"upgradeContractS2\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"txKey\",\"type\":\"string\"},{\"name\":\"adds\",\"type\":\"address[]\"},{\"name\":\"removes\",\"type\":\"address[]\"},{\"name\":\"count\",\"type\":\"uint8\"}],\"name\":\"createOrSignManagerChange\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_max_managers\",\"type\":\"uint256\"}],\"name\":\"updateMaxManagers\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"upgrade\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"adds\",\"type\":\"address[]\"},{\"name\":\"removes\",\"type\":\"address[]\"}],\"name\":\"updateSeedManagers\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pendingChangeCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"max_managers\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_managers\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DepositFunds\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TransferFunds\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"signers\",\"type\":\"address[]\"},{\"indexed\":false,\"name\":\"txKey\",\"type\":\"string\"}],\"name\":\"TxWithdrawCompleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"signers\",\"type\":\"address[]\"},{\"indexed\":false,\"name\":\"txKey\",\"type\":\"string\"}],\"name\":\"TxManagerChangeCompleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"signers\",\"type\":\"address[]\"},{\"indexed\":false,\"name\":\"txKey\",\"type\":\"string\"}],\"name\":\"TxUpgradeCompleted\",\"type\":\"event\"}]", "ContractName": "MultiSigWallet", "CompilerVersion": "v0.5.8+commit.23d335f2", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000005000000000000000000000000d87f2ad3ef011817319fd25454fc186ca71b3b560000000000000000000000000eb9e4427a0af1fa457230bef3481d028488363e000000000000000000000000d6946039519bccc0b302f89493bec60f4f0b461000000000000000000000000044cf632c33f3ff93a7892c3dd3b92b0691ec05480000000000000000000000009acde52a9db00815326fd85973e3294cebe447ab", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://04abece96ffaa650af837e44fd2577747ed78606440ca85229a4813cabb976b9"}