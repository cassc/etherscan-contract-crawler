{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Helpers.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\nimport { wadDiv, wadMul } from \\\"solmate/src/utils/SignedWadMath.sol\\\";\\nimport { InvalidCollateralType } from \\\"./lib/Errors.sol\\\";\\nimport { CollateralType, Fee } from \\\"./lib/Structs.sol\\\";\\n\\nlibrary Helpers {\\n    int256 private constant _YEAR_WAD = 365 days * 1e18;\\n    uint256 private constant _LIQUIDATION_THRESHOLD = 100_000;\\n    uint256 private constant _BASIS_POINTS = 10_000;\\n\\n    function bipsToSignedWads(uint256 bips) public pure returns (int256) {\\n        return int256((bips * 1e18) / _BASIS_POINTS);\\n    }\\n\\n    function computeCurrentDebt(\\n        uint256 amount,\\n        uint256 rate,\\n        uint256 duration\\n    ) public pure returns (uint256) {\\n        int256 yearsWad = wadDiv(int256(duration) * 1e18, _YEAR_WAD);\\n        return\\n            amount +\\n            uint256(\\n                wadMul(int256(amount), wadMul(yearsWad, bipsToSignedWads(rate)))\\n            );\\n    }\\n\\n    function computeAmountAfterFees(\\n        uint256 amount,\\n        Fee[] memory fees\\n    ) public pure returns (uint256 netAmount) {\\n        netAmount = amount;\\n        for (uint256 i = 0; i < fees.length; i++) {\\n            netAmount = netAmount - computeFeeAmount(amount, fees[i].rate);\\n        }\\n        return netAmount;\\n    }\\n\\n    function computeFeeAmount(\\n        uint256 amount,\\n        uint16 rate\\n    ) public pure returns (uint256) {\\n        return ((amount * rate) + _BASIS_POINTS - 1) / _BASIS_POINTS;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/Errors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\n// Kettle\\nerror Unauthorized();\\nerror InvalidLoan();\\nerror InvalidLien();\\nerror InvalidLoanAmount();\\nerror InsufficientOffer();\\nerror InvalidRepayment();\\nerror LienIsDefaulted();\\nerror LienNotDefaulted();\\nerror AuctionIsActive();\\nerror AuctionIsNotActive();\\nerror InvalidRefinanceRate();\\nerror InvalidRefinanceDuration();\\nerror RateTooHigh();\\nerror FeesTooHigh();\\nerror CollectionsDoNotMatch();\\nerror CurrenciesDoNotMatch();\\nerror InsufficientRefinance();\\nerror InvalidAuctionDuration();\\nerror NoEscrowImplementation();\\nerror TotalFeeTooHigh();\\n\\n// CollateralVerifier\\nerror InvalidCollateral();\\nerror InvalidCollateralCriteria();\\nerror InvalidCollateralType();\\nerror InvalidCollateralAmount();\\n\\n// OfferController\\nerror OfferExpired();\\nerror OfferUnavailable();\\n\\n// Signatures\\nerror UnauthorizedOracle();\\nerror SignatureExpired();\\nerror InvalidSignature();\\nerror InvalidVParameter();\\n\\n// Auth\\nerror AuthorizationExpired();\\nerror UnauthorizedTaker();\\nerror UnauthorizedOffer();\\nerror UnauthorizedCollateral();\\n\"\r\n    },\r\n    \"contracts/lib/Structs.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\n/*//////////////////////////////////////////////////\\n                COLLATERAL TYPES\\n//////////////////////////////////////////////////*/\\n\\nenum CollateralType {\\n    ERC721,\\n    ERC1155,\\n    ERC721_WITH_CRITERIA,\\n    ERC1155_WITH_CRITERIA\\n}\\n\\nstruct Collateral {\\n    uint8 collateralType;\\n    address collection;\\n    uint256 collateralId;\\n    uint256 collateralAmount;\\n}\\n\\n/*//////////////////////////////////////////////////\\n                LIEN STRUCTS\\n//////////////////////////////////////////////////*/\\n\\nstruct LienPointer {\\n    Lien lien;\\n    uint256 lienId;\\n}\\n\\nstruct Lien {\\n    address lender;\\n    address borrower;\\n    uint8 collateralType;\\n    address collection;\\n    uint256 tokenId;\\n    uint256 amount;\\n    address currency;\\n    uint256 borrowAmount;\\n    uint256 duration;\\n    uint256 rate;\\n    uint256 startTime;\\n}\\n\\n/*//////////////////////////////////////////////////\\n                LOAN OFFER STRUCTS\\n//////////////////////////////////////////////////*/\\n\\nstruct LoanOffer {\\n    address lender;\\n    address collection;\\n    uint8 collateralType;\\n    uint256 collateralIdentifier;\\n    uint256 collateralAmount;\\n    address currency;\\n    uint256 totalAmount;\\n    uint256 minAmount;\\n    uint256 maxAmount;\\n    uint256 duration;\\n    uint256 rate;\\n    uint256 salt;\\n    uint256 expiration;\\n    Fee[] fees;\\n}\\n\\nstruct LoanOfferInput {\\n    LoanOffer offer;\\n    bytes offerSignature;\\n}\\n\\nstruct LoanFullfillment {\\n    uint256 offerIndex;\\n    uint256 loanAmount;\\n    uint256 collateralIdentifier;\\n    OfferAuth auth;\\n    bytes authSignature;\\n    bytes32[] proof;\\n}\\n\\n/*//////////////////////////////////////////////////\\n                BORROW OFFER STRUCTS\\n//////////////////////////////////////////////////*/\\n\\nstruct BorrowOffer {\\n    address borrower;\\n    address collection;\\n    uint8 collateralType;\\n    uint256 collateralIdentifier;\\n    uint256 collateralAmount;\\n    address currency;\\n    uint256 loanAmount;\\n    uint256 duration;\\n    uint256 rate;\\n    uint256 salt;\\n    uint256 expiration;\\n    Fee[] fees;\\n}\\n\\nstruct BorrowOfferInput {\\n    BorrowOffer offer;\\n    bytes offerSignature;\\n}\\n\\nstruct BorrowFullfillment {\\n    uint256 offerIndex;\\n    OfferAuth auth;\\n    bytes authSignature;\\n}\\n\\n/*//////////////////////////////////////////////////\\n                REPAY STRUCTS\\n//////////////////////////////////////////////////*/\\n\\nstruct RepayFullfillment {\\n    Lien lien;\\n    uint256 lienId;\\n}\\n\\n/*//////////////////////////////////////////////////\\n                REFINANCE STRUCTS\\n//////////////////////////////////////////////////*/\\n\\nstruct RefinanceFullfillment {\\n    Lien lien;\\n    uint256 lienId;\\n    uint256 offerIndex;\\n    uint256 loanAmount;\\n    bytes32[] proof;\\n    OfferAuth auth;\\n    bytes authSignature;\\n}\\n\\n/*//////////////////////////////////////////////////\\n                FEE STRUCTS\\n//////////////////////////////////////////////////*/\\n\\nstruct Fee {\\n    uint16 rate;\\n    address recipient;\\n}\\n\\n/*//////////////////////////////////////////////////\\n                AUTH STRUCTS\\n//////////////////////////////////////////////////*/\\nstruct OfferAuth {\\n    bytes32 offerHash;\\n    address taker;\\n    uint256 expiration;\\n    bytes32 collateralHash;\\n}\\n\"\r\n    },\r\n    \"solmate/src/utils/SignedWadMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\n/// @notice Signed 18 decimal fixed point (wad) arithmetic library.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SignedWadMath.sol)\\n/// @author Modified from Remco Bloemen (https://xn--2-umb.com/22/exp-ln/index.html)\\n\\n/// @dev Will not revert on overflow, only use where overflow is not possible.\\nfunction toWadUnsafe(uint256 x) pure returns (int256 r) {\\n    /// @solidity memory-safe-assembly\\n    assembly {\\n        // Multiply x by 1e18.\\n        r := mul(x, 1000000000000000000)\\n    }\\n}\\n\\n/// @dev Takes an integer amount of seconds and converts it to a wad amount of days.\\n/// @dev Will not revert on overflow, only use where overflow is not possible.\\n/// @dev Not meant for negative second amounts, it assumes x is positive.\\nfunction toDaysWadUnsafe(uint256 x) pure returns (int256 r) {\\n    /// @solidity memory-safe-assembly\\n    assembly {\\n        // Multiply x by 1e18 and then divide it by 86400.\\n        r := div(mul(x, 1000000000000000000), 86400)\\n    }\\n}\\n\\n/// @dev Takes a wad amount of days and converts it to an integer amount of seconds.\\n/// @dev Will not revert on overflow, only use where overflow is not possible.\\n/// @dev Not meant for negative day amounts, it assumes x is positive.\\nfunction fromDaysWadUnsafe(int256 x) pure returns (uint256 r) {\\n    /// @solidity memory-safe-assembly\\n    assembly {\\n        // Multiply x by 86400 and then divide it by 1e18.\\n        r := div(mul(x, 86400), 1000000000000000000)\\n    }\\n}\\n\\n/// @dev Will not revert on overflow, only use where overflow is not possible.\\nfunction unsafeWadMul(int256 x, int256 y) pure returns (int256 r) {\\n    /// @solidity memory-safe-assembly\\n    assembly {\\n        // Multiply x by y and divide by 1e18.\\n        r := sdiv(mul(x, y), 1000000000000000000)\\n    }\\n}\\n\\n/// @dev Will return 0 instead of reverting if y is zero and will\\n/// not revert on overflow, only use where overflow is not possible.\\nfunction unsafeWadDiv(int256 x, int256 y) pure returns (int256 r) {\\n    /// @solidity memory-safe-assembly\\n    assembly {\\n        // Multiply x by 1e18 and divide it by y.\\n        r := sdiv(mul(x, 1000000000000000000), y)\\n    }\\n}\\n\\nfunction wadMul(int256 x, int256 y) pure returns (int256 r) {\\n    /// @solidity memory-safe-assembly\\n    assembly {\\n        // Store x * y in r for now.\\n        r := mul(x, y)\\n\\n        // Equivalent to require(x == 0 || (x * y) / x == y)\\n        if iszero(or(iszero(x), eq(sdiv(r, x), y))) {\\n            revert(0, 0)\\n        }\\n\\n        // Scale the result down by 1e18.\\n        r := sdiv(r, 1000000000000000000)\\n    }\\n}\\n\\nfunction wadDiv(int256 x, int256 y) pure returns (int256 r) {\\n    /// @solidity memory-safe-assembly\\n    assembly {\\n        // Store x * 1e18 in r for now.\\n        r := mul(x, 1000000000000000000)\\n\\n        // Equivalent to require(y != 0 && ((x * 1e18) / 1e18 == x))\\n        if iszero(and(iszero(iszero(y)), eq(sdiv(r, 1000000000000000000), x))) {\\n            revert(0, 0)\\n        }\\n\\n        // Divide r by y.\\n        r := sdiv(r, y)\\n    }\\n}\\n\\n/// @dev Will not work with negative bases, only use when x is positive.\\nfunction wadPow(int256 x, int256 y) pure returns (int256) {\\n    // Equivalent to x to the power of y because x ** y = (e ** ln(x)) ** y = e ** (ln(x) * y)\\n    return wadExp((wadLn(x) * y) / 1e18); // Using ln(x) means x must be greater than 0.\\n}\\n\\nfunction wadExp(int256 x) pure returns (int256 r) {\\n    unchecked {\\n        // When the result is < 0.5 we return zero. This happens when\\n        // x <= floor(log(0.5e18) * 1e18) ~ -42e18\\n        if (x <= -42139678854452767551) return 0;\\n\\n        // When the result is > (2**255 - 1) / 1e18 we can not represent it as an\\n        // int. This happens when x >= floor(log((2**255 - 1) / 1e18) * 1e18) ~ 135.\\n        if (x >= 135305999368893231589) revert(\\\"EXP_OVERFLOW\\\");\\n\\n        // x is now in the range (-42, 136) * 1e18. Convert to (-42, 136) * 2**96\\n        // for more intermediate precision and a binary basis. This base conversion\\n        // is a multiplication by 1e18 / 2**96 = 5**18 / 2**78.\\n        x = (x << 78) / 5**18;\\n\\n        // Reduce range of x to (-\u00bd ln 2, \u00bd ln 2) * 2**96 by factoring out powers\\n        // of two such that exp(x) = exp(x') * 2**k, where k is an integer.\\n        // Solving this gives k = round(x / log(2)) and x' = x - k * log(2).\\n        int256 k = ((x << 96) / 54916777467707473351141471128 + 2**95) >> 96;\\n        x = x - k * 54916777467707473351141471128;\\n\\n        // k is in the range [-61, 195].\\n\\n        // Evaluate using a (6, 7)-term rational approximation.\\n        // p is made monic, we'll multiply by a scale factor later.\\n        int256 y = x + 1346386616545796478920950773328;\\n        y = ((y * x) >> 96) + 57155421227552351082224309758442;\\n        int256 p = y + x - 94201549194550492254356042504812;\\n        p = ((p * y) >> 96) + 28719021644029726153956944680412240;\\n        p = p * x + (4385272521454847904659076985693276 << 96);\\n\\n        // We leave p in 2**192 basis so we don't need to scale it back up for the division.\\n        int256 q = x - 2855989394907223263936484059900;\\n        q = ((q * x) >> 96) + 50020603652535783019961831881945;\\n        q = ((q * x) >> 96) - 533845033583426703283633433725380;\\n        q = ((q * x) >> 96) + 3604857256930695427073651918091429;\\n        q = ((q * x) >> 96) - 14423608567350463180887372962807573;\\n        q = ((q * x) >> 96) + 26449188498355588339934803723976023;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Div in assembly because solidity adds a zero check despite the unchecked.\\n            // The q polynomial won't have zeros in the domain as all its roots are complex.\\n            // No scaling is necessary because p is already 2**96 too large.\\n            r := sdiv(p, q)\\n        }\\n\\n        // r should be in the range (0.09, 0.25) * 2**96.\\n\\n        // We now need to multiply r by:\\n        // * the scale factor s = ~6.031367120.\\n        // * the 2**k factor from the range reduction.\\n        // * the 1e18 / 2**96 factor for base conversion.\\n        // We do this all at once, with an intermediate result in 2**213\\n        // basis, so the final right shift is always by a positive amount.\\n        r = int256((uint256(r) * 3822833074963236453042738258902158003155416615667) >> uint256(195 - k));\\n    }\\n}\\n\\nfunction wadLn(int256 x) pure returns (int256 r) {\\n    unchecked {\\n        require(x > 0, \\\"UNDEFINED\\\");\\n\\n        // We want to convert x from 10**18 fixed point to 2**96 fixed point.\\n        // We do this by multiplying by 2**96 / 10**18. But since\\n        // ln(x * C) = ln(x) + ln(C), we can simply do nothing here\\n        // and add ln(2**96 / 10**18) at the end.\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\\n            r := or(r, shl(2, lt(0xf, shr(r, x))))\\n            r := or(r, shl(1, lt(0x3, shr(r, x))))\\n            r := or(r, lt(0x1, shr(r, x)))\\n        }\\n\\n        // Reduce range of x to (1, 2) * 2**96\\n        // ln(2^k * x) = k * ln(2) + ln(x)\\n        int256 k = r - 96;\\n        x <<= uint256(159 - k);\\n        x = int256(uint256(x) >> 159);\\n\\n        // Evaluate using a (8, 8)-term rational approximation.\\n        // p is made monic, we will multiply by a scale factor later.\\n        int256 p = x + 3273285459638523848632254066296;\\n        p = ((p * x) >> 96) + 24828157081833163892658089445524;\\n        p = ((p * x) >> 96) + 43456485725739037958740375743393;\\n        p = ((p * x) >> 96) - 11111509109440967052023855526967;\\n        p = ((p * x) >> 96) - 45023709667254063763336534515857;\\n        p = ((p * x) >> 96) - 14706773417378608786704636184526;\\n        p = p * x - (795164235651350426258249787498 << 96);\\n\\n        // We leave p in 2**192 basis so we don't need to scale it back up for the division.\\n        // q is monic by convention.\\n        int256 q = x + 5573035233440673466300451813936;\\n        q = ((q * x) >> 96) + 71694874799317883764090561454958;\\n        q = ((q * x) >> 96) + 283447036172924575727196451306956;\\n        q = ((q * x) >> 96) + 401686690394027663651624208769553;\\n        q = ((q * x) >> 96) + 204048457590392012362485061816622;\\n        q = ((q * x) >> 96) + 31853899698501571402653359427138;\\n        q = ((q * x) >> 96) + 909429971244387300277376558375;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Div in assembly because solidity adds a zero check despite the unchecked.\\n            // The q polynomial is known not to have zeros in the domain.\\n            // No scaling required because p is already 2**96 too large.\\n            r := sdiv(p, q)\\n        }\\n\\n        // r is in the range (0, 0.125) * 2**96\\n\\n        // Finalization, we need to:\\n        // * multiply by the scale factor s = 5.549\u2026\\n        // * add ln(2**96 / 10**18)\\n        // * add k * ln(2)\\n        // * multiply by 10**18 / 2**96 = 5**18 >> 78\\n\\n        // mul s * 5e18 * 2**96, base is now 5**18 * 2**192\\n        r *= 1677202110996718588342820967067443963516166;\\n        // add ln(2) * k * 5e18 * 2**192\\n        r += 16597577552685614221487285958193947469193820559219878177908093499208371 * k;\\n        // add ln(2**96 / 10**18) * 5e18 * 2**192\\n        r += 600920179829731861736702779321621459595472258049074101567377883020018308;\\n        // base conversion: mul 2**18 / 2**192\\n        r >>= 174;\\n    }\\n}\\n\\n/// @dev Will return 0 instead of reverting if y is zero.\\nfunction unsafeDiv(int256 x, int256 y) pure returns (int256 r) {\\n    /// @solidity memory-safe-assembly\\n    assembly {\\n        // Divide x by y.\\n        r := sdiv(x, y)\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"viaIR\": true,\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 100000,\r\n      \"details\": {\r\n        \"yulDetails\": {\r\n          \"optimizerSteps\": \"u\"\r\n        }\r\n      }\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"bips\",\"type\":\"uint256\"}],\"name\":\"bipsToSignedWads\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint16\",\"name\":\"rate\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"internalType\":\"struct Fee[]\",\"name\":\"fees\",\"type\":\"tuple[]\"}],\"name\":\"computeAmountAfterFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"netAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"}],\"name\":\"computeCurrentDebt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"rate\",\"type\":\"uint16\"}],\"name\":\"computeFeeAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]", "ContractName": "Helpers", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "100000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}