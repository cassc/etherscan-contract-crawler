{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\n\r\npragma solidity >=0.5.16 <0.7.0;\r\n\r\n/**\r\n * @title Proxy\r\n *\r\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\r\n * different contract through the {_delegate} function.\r\n * \r\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\r\n */\r\nabstract contract Proxy {\r\n    /**\r\n     * @dev Delegates the current call to `implementation`.\r\n     * \r\n     * This function does not return to its internall call site, it will return directly to the external caller.\r\n     */\r\n    function _delegate(address implementation) internal {\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            // Copy msg.data. We take full control of memory in this inline assembly\r\n            // block because it will not return to Solidity code. We overwrite the\r\n            // Solidity scratch pad at memory position 0.\r\n            calldatacopy(0, 0, calldatasize())\r\n\r\n            // Call the implementation.\r\n            // out and outsize are 0 because we don't know the size yet.\r\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\r\n\r\n            // Copy the returned data.\r\n            returndatacopy(0, 0, returndatasize())\r\n\r\n            switch result\r\n            // delegatecall returns 0 on error.\r\n            case 0 { revert(0, returndatasize()) }\r\n            default { return(0, returndatasize()) }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev This is a virtual function that should be overriden so it returns the address to which the fallback function\r\n     * and {_fallback} should delegate.\r\n     */\r\n    function _implementation() internal virtual view returns (address);\r\n\r\n    /**\r\n     * @dev Delegates the current call to the address returned by `_implementation()`.\r\n     * \r\n     * This function does not return to its internall call site, it will return directly to the external caller.\r\n     */\r\n    function _fallback() internal {\r\n        _beforeFallback();\r\n        _delegate(_implementation());\r\n    }\r\n\r\n    /**\r\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\r\n     * function in the contract matches the call data.\r\n     */\r\n    fallback () payable external {\r\n        _fallback();\r\n    }\r\n\r\n    /**\r\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\r\n     * is empty.\r\n     */\r\n    receive () payable external {\r\n        _fallback();\r\n    }\r\n\r\n    /**\r\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\r\n     * call, or as part of the Solidity `fallback` or `receive` functions.\r\n     * \r\n     * If overriden should call `super._beforeFallback()`.\r\n     */\r\n    function _beforeFallback() internal virtual {\r\n    }\r\n}\r\n\r\n\r\npragma solidity >=0.5.16 <0.7.0;\r\n\r\n/**\r\n * Utility library of inline functions on addresses\r\n */\r\nlibrary AddressUtils {\r\n    /**\r\n     * Returns whether the target address is a contract\r\n     * @dev This function will return false if invoked during the constructor of a contract,\r\n     * as the code is not actually created until after the constructor finishes.\r\n     * @param addr address to check\r\n     * @return whether the target address is a contract\r\n     */\r\n    function isContract(address addr) internal view returns (bool) {\r\n        uint256 size;\r\n        // XXX Currently there is no better way to check if there is a contract in an address\r\n        // than to check the size of the code at that address.\r\n        // See https://ethereum.stackexchange.com/a/14016/36603\r\n        // for more details about how this works.\r\n        // TODO Check this again before the Serenity release, because all addresses will be\r\n        // contracts then.\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            size := extcodesize(addr)\r\n        }\r\n        return size > 0;\r\n    }\r\n\r\n}\r\n\r\n\r\npragma solidity >=0.5.16 <0.7.0;\r\n\r\n\r\n\r\n/**\r\n * @title UpgradeableProxyV1\r\n *\r\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\r\n * implementation address that can be changed. This address is stored in storage in the location specified by\r\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\r\n * implementation behind the proxy.\r\n *\r\n * Upgradeability is only provided internally through {_upgradeTo}. For an externally upgradeable proxy see\r\n * {TransparentUpgradeableProxy}.\r\n */\r\nabstract contract UpgradeableProxyV1 is Proxy {\r\n    /**\r\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `logic`.\r\n     *\r\n     * If `_data` is nonempty, it's used as data in a delegate call to `logic`. This will typically be an encoded\r\n     * function call, and allows initializating the storage of the proxy like a Solidity constructor.\r\n     */\r\n    constructor(address logic, bytes memory data) public payable {\r\n        if (logic == address(0x0)) {\r\n            return;\r\n        }\r\n        assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1));\r\n        _setImplementation(logic);\r\n        if (data.length > 0) {\r\n            // solhint-disable-next-line avoid-low-level-calls\r\n            (bool success, ) = logic.delegatecall(data);\r\n            require(success, \"Call impl with data failed\");\r\n        }\r\n    }\r\n\r\n    function _initProxyImpl(\r\n        address logic,\r\n        bytes memory data\r\n    ) internal virtual {\r\n        require(_implementation() == address(0x0), \"Impl had been set\");\r\n        _setImplementation(logic);\r\n        if (data.length > 0) {\r\n            // solhint-disable-next-line avoid-low-level-calls\r\n            (bool success, ) = logic.delegatecall(data);\r\n            require(success, \"Call impl with data failed\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Emitted when the implementation is upgraded.\r\n     */\r\n    event Upgraded(address indexed implementation);\r\n\r\n    /**\r\n     * @dev Storage slot with the address of the current implementation.\r\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\r\n     * validated in the constructor.\r\n     */\r\n    bytes32 private constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\r\n\r\n    /**\r\n     * @dev Returns the current implementation.\r\n     * @return impl Address of the current implementation\r\n     */\r\n    function _implementation() internal virtual override view returns (address impl) {\r\n        bytes32 slot = _IMPLEMENTATION_SLOT;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            impl := sload(slot)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Upgrades the proxy to a new implementation.\r\n     *\r\n     * Emits an {Upgraded} event.\r\n     */\r\n    function _upgradeTo(address newImplementation) internal {\r\n        _setImplementation(newImplementation);\r\n        emit Upgraded(newImplementation);\r\n    }\r\n\r\n    /**\r\n     * @dev Stores a new address in the EIP1967 implementation slot.\r\n     */\r\n    function _setImplementation(address newImplementation) private {\r\n        require(AddressUtils.isContract(newImplementation), \"UpgradeableProxy: new implementation is not a contract\");\r\n\r\n        bytes32 slot = _IMPLEMENTATION_SLOT;\r\n\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            sstore(slot, newImplementation)\r\n        }\r\n    }\r\n}\r\n\r\n\r\npragma solidity >=0.5.16 <0.7.0;\r\n\r\n\r\n/**\r\n * @title ManagedProxyV2\r\n *\r\n * @dev This contract implements a proxy that is upgradeable by an admin.\r\n * initializing the implementation, admin, and init data.\r\n */\r\ncontract ManagedProxyV2 is UpgradeableProxyV1 {\r\n    /**\r\n     * @dev Initializes an upgradeable proxy managed by `admin`, backed by the implementation at `logic`, and\r\n     * optionally initialized with `data` as explained in {UpgradeableProxy-constructor}.\r\n     */\r\n    constructor(\r\n        address logic,\r\n        address admin,\r\n        bytes memory data\r\n    ) public payable UpgradeableProxyV1(logic, data) {\r\n        assert(_ADMIN_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1));\r\n        if (admin != address(0x0)) {\r\n            _setAdmin(admin);\r\n        }\r\n    }\r\n\r\n    function _initManagedProxy(\r\n        address logic,\r\n        address admin,\r\n        bytes memory data\r\n    ) internal {\r\n        require(_admin() == address(0x0), \"Admin had been set\");\r\n        _initProxyImpl(logic, data);\r\n        _setAdmin(admin);\r\n    }\r\n\r\n    /**\r\n     * @dev Emitted when the admin account has changed.\r\n     */\r\n    event AdminChanged(address previousAdmin, address newAdmin);\r\n\r\n    /**\r\n     * @dev Storage slot with the admin of the contract.\r\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\r\n     * validated in the constructor.\r\n     */\r\n    bytes32 private constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\r\n\r\n    /**\r\n     * @dev Modifier used internally that will delegate the call to the implementation unless the sender is the admin.\r\n     */\r\n    modifier ifAdmin() {\r\n        if (msg.sender == _admin()) {\r\n            _;\r\n        } else {\r\n            _fallback();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the current admin.\r\n     *\r\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyAdmin}.\r\n     *\r\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\r\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\r\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\r\n     */\r\n    function admin() external ifAdmin returns (address) {\r\n        return _admin();\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the current implementation.\r\n     *\r\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}.\r\n     *\r\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\r\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\r\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\r\n     */\r\n    function implementation() external ifAdmin returns (address) {\r\n        return _implementation();\r\n    }\r\n\r\n    /**\r\n     * @dev Changes the admin of the proxy.\r\n     *\r\n     * Emits an {AdminChanged} event.\r\n     *\r\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-changeProxyAdmin}.\r\n     */\r\n    function changeAdmin(address newAdmin) external ifAdmin {\r\n        require(newAdmin != address(0), \"ManagedProxy: new admin is the zero address\");\r\n        emit AdminChanged(_admin(), newAdmin);\r\n        _setAdmin(newAdmin);\r\n    }\r\n\r\n    /**\r\n     * @dev Upgrade the implementation of the proxy.\r\n     *\r\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgrade}.\r\n     */\r\n    function upgradeTo(address newImplementation) external ifAdmin {\r\n        _upgradeTo(newImplementation);\r\n    }\r\n\r\n    /**\r\n     * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified\r\n     * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the\r\n     * proxied contract.\r\n     *\r\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgradeAndCall}.\r\n     */\r\n    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable ifAdmin {\r\n        _upgradeTo(newImplementation);\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, ) = newImplementation.delegatecall(data);\r\n        require(success);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the current admin.\r\n     */\r\n    function _admin() internal view returns (address adm) {\r\n        bytes32 slot = _ADMIN_SLOT;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            adm := sload(slot)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Stores a new address in the EIP1967 admin slot.\r\n     */\r\n    function _setAdmin(address newAdmin) private {\r\n        bytes32 slot = _ADMIN_SLOT;\r\n\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            sstore(slot, newAdmin)\r\n        }\r\n    }\r\n}\r\n\r\npragma solidity >=0.5.16 <0.7.0;\r\n\r\ncontract TokenChildProxyV2 is ManagedProxyV2 {\r\n    constructor() public payable ManagedProxyV2(address(0x0), msg.sender, \"\") {}\r\n\r\n    function _initProxyOfProxy(\r\n        address impl,\r\n        address admin,\r\n        bytes memory data\r\n    ) public {\r\n        _initManagedProxy(impl, admin, data);\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"AdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"Upgraded\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"impl\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"_initProxyOfProxy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"changeAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"implementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"}],\"name\":\"upgradeTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"upgradeToAndCall\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "TokenChildProxyV2", "CompilerVersion": "v0.6.12+commit.27d51765", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://abe88c043f89697f215c4b89c986322a6ee8a11e852d257ee23c0b2b1bf8d946"}