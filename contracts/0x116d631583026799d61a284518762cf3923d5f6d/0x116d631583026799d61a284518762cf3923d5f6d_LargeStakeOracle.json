{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"lib/openzeppelin-contracts/contracts/utils/math/SafeCast.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SafeCast.sol)\\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n *\\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\\n * all math on `uint256` and `int256` and then downcasting.\\n */\\nlibrary SafeCast {\\n    /**\\n     * @dev Returns the downcasted uint248 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint248).\\n     *\\n     * Counterpart to Solidity's `uint248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint248(uint256 value) internal pure returns (uint248) {\\n        require(value <= type(uint248).max, \\\"SafeCast: value doesn't fit in 248 bits\\\");\\n        return uint248(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint240 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint240).\\n     *\\n     * Counterpart to Solidity's `uint240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint240(uint256 value) internal pure returns (uint240) {\\n        require(value <= type(uint240).max, \\\"SafeCast: value doesn't fit in 240 bits\\\");\\n        return uint240(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint232 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint232).\\n     *\\n     * Counterpart to Solidity's `uint232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint232(uint256 value) internal pure returns (uint232) {\\n        require(value <= type(uint232).max, \\\"SafeCast: value doesn't fit in 232 bits\\\");\\n        return uint232(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint224 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint224).\\n     *\\n     * Counterpart to Solidity's `uint224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     *\\n     * _Available since v4.2._\\n     */\\n    function toUint224(uint256 value) internal pure returns (uint224) {\\n        require(value <= type(uint224).max, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n        return uint224(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint216 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint216).\\n     *\\n     * Counterpart to Solidity's `uint216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint216(uint256 value) internal pure returns (uint216) {\\n        require(value <= type(uint216).max, \\\"SafeCast: value doesn't fit in 216 bits\\\");\\n        return uint216(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint208 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint208).\\n     *\\n     * Counterpart to Solidity's `uint208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint208(uint256 value) internal pure returns (uint208) {\\n        require(value <= type(uint208).max, \\\"SafeCast: value doesn't fit in 208 bits\\\");\\n        return uint208(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint200 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint200).\\n     *\\n     * Counterpart to Solidity's `uint200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint200(uint256 value) internal pure returns (uint200) {\\n        require(value <= type(uint200).max, \\\"SafeCast: value doesn't fit in 200 bits\\\");\\n        return uint200(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint192 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint192).\\n     *\\n     * Counterpart to Solidity's `uint192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint192(uint256 value) internal pure returns (uint192) {\\n        require(value <= type(uint192).max, \\\"SafeCast: value doesn't fit in 192 bits\\\");\\n        return uint192(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint184 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint184).\\n     *\\n     * Counterpart to Solidity's `uint184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint184(uint256 value) internal pure returns (uint184) {\\n        require(value <= type(uint184).max, \\\"SafeCast: value doesn't fit in 184 bits\\\");\\n        return uint184(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint176 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint176).\\n     *\\n     * Counterpart to Solidity's `uint176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint176(uint256 value) internal pure returns (uint176) {\\n        require(value <= type(uint176).max, \\\"SafeCast: value doesn't fit in 176 bits\\\");\\n        return uint176(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint168 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint168).\\n     *\\n     * Counterpart to Solidity's `uint168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint168(uint256 value) internal pure returns (uint168) {\\n        require(value <= type(uint168).max, \\\"SafeCast: value doesn't fit in 168 bits\\\");\\n        return uint168(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint160 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint160).\\n     *\\n     * Counterpart to Solidity's `uint160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint160(uint256 value) internal pure returns (uint160) {\\n        require(value <= type(uint160).max, \\\"SafeCast: value doesn't fit in 160 bits\\\");\\n        return uint160(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint152 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint152).\\n     *\\n     * Counterpart to Solidity's `uint152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint152(uint256 value) internal pure returns (uint152) {\\n        require(value <= type(uint152).max, \\\"SafeCast: value doesn't fit in 152 bits\\\");\\n        return uint152(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint144 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint144).\\n     *\\n     * Counterpart to Solidity's `uint144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint144(uint256 value) internal pure returns (uint144) {\\n        require(value <= type(uint144).max, \\\"SafeCast: value doesn't fit in 144 bits\\\");\\n        return uint144(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint136 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint136).\\n     *\\n     * Counterpart to Solidity's `uint136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint136(uint256 value) internal pure returns (uint136) {\\n        require(value <= type(uint136).max, \\\"SafeCast: value doesn't fit in 136 bits\\\");\\n        return uint136(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity's `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        require(value <= type(uint128).max, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n        return uint128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint120 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint120).\\n     *\\n     * Counterpart to Solidity's `uint120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint120(uint256 value) internal pure returns (uint120) {\\n        require(value <= type(uint120).max, \\\"SafeCast: value doesn't fit in 120 bits\\\");\\n        return uint120(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint112 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint112).\\n     *\\n     * Counterpart to Solidity's `uint112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint112(uint256 value) internal pure returns (uint112) {\\n        require(value <= type(uint112).max, \\\"SafeCast: value doesn't fit in 112 bits\\\");\\n        return uint112(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint104 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint104).\\n     *\\n     * Counterpart to Solidity's `uint104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint104(uint256 value) internal pure returns (uint104) {\\n        require(value <= type(uint104).max, \\\"SafeCast: value doesn't fit in 104 bits\\\");\\n        return uint104(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint96 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint96).\\n     *\\n     * Counterpart to Solidity's `uint96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     *\\n     * _Available since v4.2._\\n     */\\n    function toUint96(uint256 value) internal pure returns (uint96) {\\n        require(value <= type(uint96).max, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n        return uint96(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint88 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint88).\\n     *\\n     * Counterpart to Solidity's `uint88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint88(uint256 value) internal pure returns (uint88) {\\n        require(value <= type(uint88).max, \\\"SafeCast: value doesn't fit in 88 bits\\\");\\n        return uint88(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint80 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint80).\\n     *\\n     * Counterpart to Solidity's `uint80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint80(uint256 value) internal pure returns (uint80) {\\n        require(value <= type(uint80).max, \\\"SafeCast: value doesn't fit in 80 bits\\\");\\n        return uint80(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint72 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint72).\\n     *\\n     * Counterpart to Solidity's `uint72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint72(uint256 value) internal pure returns (uint72) {\\n        require(value <= type(uint72).max, \\\"SafeCast: value doesn't fit in 72 bits\\\");\\n        return uint72(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint64).\\n     *\\n     * Counterpart to Solidity's `uint64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        require(value <= type(uint64).max, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n        return uint64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint56 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint56).\\n     *\\n     * Counterpart to Solidity's `uint56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint56(uint256 value) internal pure returns (uint56) {\\n        require(value <= type(uint56).max, \\\"SafeCast: value doesn't fit in 56 bits\\\");\\n        return uint56(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint48 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint48).\\n     *\\n     * Counterpart to Solidity's `uint48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint48(uint256 value) internal pure returns (uint48) {\\n        require(value <= type(uint48).max, \\\"SafeCast: value doesn't fit in 48 bits\\\");\\n        return uint48(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint40 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint40).\\n     *\\n     * Counterpart to Solidity's `uint40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint40(uint256 value) internal pure returns (uint40) {\\n        require(value <= type(uint40).max, \\\"SafeCast: value doesn't fit in 40 bits\\\");\\n        return uint40(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint32).\\n     *\\n     * Counterpart to Solidity's `uint32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\n        require(value <= type(uint32).max, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n        return uint32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint24 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint24).\\n     *\\n     * Counterpart to Solidity's `uint24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint24(uint256 value) internal pure returns (uint24) {\\n        require(value <= type(uint24).max, \\\"SafeCast: value doesn't fit in 24 bits\\\");\\n        return uint24(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint16).\\n     *\\n     * Counterpart to Solidity's `uint16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\n        require(value <= type(uint16).max, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n        return uint16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint8).\\n     *\\n     * Counterpart to Solidity's `uint8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\n        require(value <= type(uint8).max, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n        return uint8(value);\\n    }\\n\\n    /**\\n     * @dev Converts a signed int256 into an unsigned uint256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be greater than or equal to 0.\\n     *\\n     * _Available since v3.0._\\n     */\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        require(value >= 0, \\\"SafeCast: value must be positive\\\");\\n        return uint256(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int248 from int256, reverting on\\n     * overflow (when the input is less than smallest int248 or\\n     * greater than largest int248).\\n     *\\n     * Counterpart to Solidity's `int248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\\n        downcasted = int248(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 248 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int240 from int256, reverting on\\n     * overflow (when the input is less than smallest int240 or\\n     * greater than largest int240).\\n     *\\n     * Counterpart to Solidity's `int240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\\n        downcasted = int240(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 240 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int232 from int256, reverting on\\n     * overflow (when the input is less than smallest int232 or\\n     * greater than largest int232).\\n     *\\n     * Counterpart to Solidity's `int232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\\n        downcasted = int232(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 232 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int224 from int256, reverting on\\n     * overflow (when the input is less than smallest int224 or\\n     * greater than largest int224).\\n     *\\n     * Counterpart to Solidity's `int224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\\n        downcasted = int224(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int216 from int256, reverting on\\n     * overflow (when the input is less than smallest int216 or\\n     * greater than largest int216).\\n     *\\n     * Counterpart to Solidity's `int216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\\n        downcasted = int216(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 216 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int208 from int256, reverting on\\n     * overflow (when the input is less than smallest int208 or\\n     * greater than largest int208).\\n     *\\n     * Counterpart to Solidity's `int208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\\n        downcasted = int208(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 208 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int200 from int256, reverting on\\n     * overflow (when the input is less than smallest int200 or\\n     * greater than largest int200).\\n     *\\n     * Counterpart to Solidity's `int200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\\n        downcasted = int200(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 200 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int192 from int256, reverting on\\n     * overflow (when the input is less than smallest int192 or\\n     * greater than largest int192).\\n     *\\n     * Counterpart to Solidity's `int192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\\n        downcasted = int192(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 192 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int184 from int256, reverting on\\n     * overflow (when the input is less than smallest int184 or\\n     * greater than largest int184).\\n     *\\n     * Counterpart to Solidity's `int184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\\n        downcasted = int184(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 184 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int176 from int256, reverting on\\n     * overflow (when the input is less than smallest int176 or\\n     * greater than largest int176).\\n     *\\n     * Counterpart to Solidity's `int176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\\n        downcasted = int176(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 176 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int168 from int256, reverting on\\n     * overflow (when the input is less than smallest int168 or\\n     * greater than largest int168).\\n     *\\n     * Counterpart to Solidity's `int168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\\n        downcasted = int168(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 168 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int160 from int256, reverting on\\n     * overflow (when the input is less than smallest int160 or\\n     * greater than largest int160).\\n     *\\n     * Counterpart to Solidity's `int160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\\n        downcasted = int160(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 160 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int152 from int256, reverting on\\n     * overflow (when the input is less than smallest int152 or\\n     * greater than largest int152).\\n     *\\n     * Counterpart to Solidity's `int152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\\n        downcasted = int152(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 152 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int144 from int256, reverting on\\n     * overflow (when the input is less than smallest int144 or\\n     * greater than largest int144).\\n     *\\n     * Counterpart to Solidity's `int144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\\n        downcasted = int144(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 144 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int136 from int256, reverting on\\n     * overflow (when the input is less than smallest int136 or\\n     * greater than largest int136).\\n     *\\n     * Counterpart to Solidity's `int136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\\n        downcasted = int136(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 136 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int128 from int256, reverting on\\n     * overflow (when the input is less than smallest int128 or\\n     * greater than largest int128).\\n     *\\n     * Counterpart to Solidity's `int128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\\n        downcasted = int128(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int120 from int256, reverting on\\n     * overflow (when the input is less than smallest int120 or\\n     * greater than largest int120).\\n     *\\n     * Counterpart to Solidity's `int120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\\n        downcasted = int120(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 120 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int112 from int256, reverting on\\n     * overflow (when the input is less than smallest int112 or\\n     * greater than largest int112).\\n     *\\n     * Counterpart to Solidity's `int112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\\n        downcasted = int112(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 112 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int104 from int256, reverting on\\n     * overflow (when the input is less than smallest int104 or\\n     * greater than largest int104).\\n     *\\n     * Counterpart to Solidity's `int104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\\n        downcasted = int104(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 104 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int96 from int256, reverting on\\n     * overflow (when the input is less than smallest int96 or\\n     * greater than largest int96).\\n     *\\n     * Counterpart to Solidity's `int96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\\n        downcasted = int96(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int88 from int256, reverting on\\n     * overflow (when the input is less than smallest int88 or\\n     * greater than largest int88).\\n     *\\n     * Counterpart to Solidity's `int88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\\n        downcasted = int88(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 88 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int80 from int256, reverting on\\n     * overflow (when the input is less than smallest int80 or\\n     * greater than largest int80).\\n     *\\n     * Counterpart to Solidity's `int80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\\n        downcasted = int80(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 80 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int72 from int256, reverting on\\n     * overflow (when the input is less than smallest int72 or\\n     * greater than largest int72).\\n     *\\n     * Counterpart to Solidity's `int72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\\n        downcasted = int72(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 72 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int64 from int256, reverting on\\n     * overflow (when the input is less than smallest int64 or\\n     * greater than largest int64).\\n     *\\n     * Counterpart to Solidity's `int64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\\n        downcasted = int64(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int56 from int256, reverting on\\n     * overflow (when the input is less than smallest int56 or\\n     * greater than largest int56).\\n     *\\n     * Counterpart to Solidity's `int56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\\n        downcasted = int56(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 56 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int48 from int256, reverting on\\n     * overflow (when the input is less than smallest int48 or\\n     * greater than largest int48).\\n     *\\n     * Counterpart to Solidity's `int48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\\n        downcasted = int48(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 48 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int40 from int256, reverting on\\n     * overflow (when the input is less than smallest int40 or\\n     * greater than largest int40).\\n     *\\n     * Counterpart to Solidity's `int40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\\n        downcasted = int40(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 40 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int32 from int256, reverting on\\n     * overflow (when the input is less than smallest int32 or\\n     * greater than largest int32).\\n     *\\n     * Counterpart to Solidity's `int32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\\n        downcasted = int32(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int24 from int256, reverting on\\n     * overflow (when the input is less than smallest int24 or\\n     * greater than largest int24).\\n     *\\n     * Counterpart to Solidity's `int24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\\n        downcasted = int24(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 24 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int16 from int256, reverting on\\n     * overflow (when the input is less than smallest int16 or\\n     * greater than largest int16).\\n     *\\n     * Counterpart to Solidity's `int16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\\n        downcasted = int16(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int8 from int256, reverting on\\n     * overflow (when the input is less than smallest int8 or\\n     * greater than largest int8).\\n     *\\n     * Counterpart to Solidity's `int8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\\n        downcasted = int8(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Converts an unsigned uint256 into a signed int256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be less than or equal to maxInt256.\\n     *\\n     * _Available since v3.0._\\n     */\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\\n        require(value <= uint256(type(int256).max), \\\"SafeCast: value doesn't fit in an int256\\\");\\n        return int256(value);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/access/OwnableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    function __Ownable_init() internal onlyInitializing {\\n        __Ownable_init_unchained();\\n    }\\n\\n    function __Ownable_init_unchained() internal onlyInitializing {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/interfaces/draft-IERC1822Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\\n * proxy whose upgrades are fully controlled by the current implementation.\\n */\\ninterface IERC1822ProxiableUpgradeable {\\n    /**\\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\\n     * address.\\n     *\\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\\n     * function revert if invoked through a proxy.\\n     */\\n    function proxiableUUID() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/proxy/ERC1967/ERC1967UpgradeUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/ERC1967/ERC1967Upgrade.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../beacon/IBeaconUpgradeable.sol\\\";\\nimport \\\"../../interfaces/draft-IERC1822Upgradeable.sol\\\";\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\nimport \\\"../../utils/StorageSlotUpgradeable.sol\\\";\\nimport \\\"../utils/Initializable.sol\\\";\\n\\n/**\\n * @dev This abstract contract provides getters and event emitting update functions for\\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\\n *\\n * _Available since v4.1._\\n *\\n * @custom:oz-upgrades-unsafe-allow delegatecall\\n */\\nabstract contract ERC1967UpgradeUpgradeable is Initializable {\\n    function __ERC1967Upgrade_init() internal onlyInitializing {\\n    }\\n\\n    function __ERC1967Upgrade_init_unchained() internal onlyInitializing {\\n    }\\n    // This is the keccak-256 hash of \\\"eip1967.proxy.rollback\\\" subtracted by 1\\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\\n\\n    /**\\n     * @dev Storage slot with the address of the current implementation.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.implementation\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    /**\\n     * @dev Emitted when the implementation is upgraded.\\n     */\\n    event Upgraded(address indexed implementation);\\n\\n    /**\\n     * @dev Returns the current implementation address.\\n     */\\n    function _getImplementation() internal view returns (address) {\\n        return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 implementation slot.\\n     */\\n    function _setImplementation(address newImplementation) private {\\n        require(AddressUpgradeable.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeTo(address newImplementation) internal {\\n        _setImplementation(newImplementation);\\n        emit Upgraded(newImplementation);\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade with additional setup call.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeToAndCall(\\n        address newImplementation,\\n        bytes memory data,\\n        bool forceCall\\n    ) internal {\\n        _upgradeTo(newImplementation);\\n        if (data.length > 0 || forceCall) {\\n            _functionDelegateCall(newImplementation, data);\\n        }\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeToAndCallUUPS(\\n        address newImplementation,\\n        bytes memory data,\\n        bool forceCall\\n    ) internal {\\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\\n        if (StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT).value) {\\n            _setImplementation(newImplementation);\\n        } else {\\n            try IERC1822ProxiableUpgradeable(newImplementation).proxiableUUID() returns (bytes32 slot) {\\n                require(slot == _IMPLEMENTATION_SLOT, \\\"ERC1967Upgrade: unsupported proxiableUUID\\\");\\n            } catch {\\n                revert(\\\"ERC1967Upgrade: new implementation is not UUPS\\\");\\n            }\\n            _upgradeToAndCall(newImplementation, data, forceCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Storage slot with the admin of the contract.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.admin\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n    /**\\n     * @dev Emitted when the admin account has changed.\\n     */\\n    event AdminChanged(address previousAdmin, address newAdmin);\\n\\n    /**\\n     * @dev Returns the current admin.\\n     */\\n    function _getAdmin() internal view returns (address) {\\n        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 admin slot.\\n     */\\n    function _setAdmin(address newAdmin) private {\\n        require(newAdmin != address(0), \\\"ERC1967: new admin is the zero address\\\");\\n        StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\\n    }\\n\\n    /**\\n     * @dev Changes the admin of the proxy.\\n     *\\n     * Emits an {AdminChanged} event.\\n     */\\n    function _changeAdmin(address newAdmin) internal {\\n        emit AdminChanged(_getAdmin(), newAdmin);\\n        _setAdmin(newAdmin);\\n    }\\n\\n    /**\\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\\n     */\\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\\n\\n    /**\\n     * @dev Emitted when the beacon is upgraded.\\n     */\\n    event BeaconUpgraded(address indexed beacon);\\n\\n    /**\\n     * @dev Returns the current beacon.\\n     */\\n    function _getBeacon() internal view returns (address) {\\n        return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\\n     */\\n    function _setBeacon(address newBeacon) private {\\n        require(AddressUpgradeable.isContract(newBeacon), \\\"ERC1967: new beacon is not a contract\\\");\\n        require(\\n            AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),\\n            \\\"ERC1967: beacon implementation is not a contract\\\"\\n        );\\n        StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;\\n    }\\n\\n    /**\\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\\n     *\\n     * Emits a {BeaconUpgraded} event.\\n     */\\n    function _upgradeBeaconToAndCall(\\n        address newBeacon,\\n        bytes memory data,\\n        bool forceCall\\n    ) internal {\\n        _setBeacon(newBeacon);\\n        emit BeaconUpgraded(newBeacon);\\n        if (data.length > 0 || forceCall) {\\n            _functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);\\n        }\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function _functionDelegateCall(address target, bytes memory data) private returns (bytes memory) {\\n        require(AddressUpgradeable.isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return AddressUpgradeable.verifyCallResult(success, returndata, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/proxy/beacon/IBeaconUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\\n */\\ninterface IBeaconUpgradeable {\\n    /**\\n     * @dev Must return an address that can be used as a delegate call target.\\n     *\\n     * {BeaconProxy} will check that this address is a contract.\\n     */\\n    function implementation() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     * @custom:oz-retyped-from bool\\n     */\\n    uint8 private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint8 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts.\\n     *\\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\\n     * constructor.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier initializer() {\\n        bool isTopLevelCall = !_initializing;\\n        require(\\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\\n            \\\"Initializable: contract is already initialized\\\"\\n        );\\n        _initialized = 1;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\\n     * are added through upgrades and that require initialization.\\n     *\\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     *\\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier reinitializer(uint8 version) {\\n        require(!_initializing && _initialized < version, \\\"Initializable: contract is already initialized\\\");\\n        _initialized = version;\\n        _initializing = true;\\n        _;\\n        _initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     *\\n     * Emits an {Initialized} event the first time it is successfully executed.\\n     */\\n    function _disableInitializers() internal virtual {\\n        require(!_initializing, \\\"Initializable: contract is initializing\\\");\\n        if (_initialized != type(uint8).max) {\\n            _initialized = type(uint8).max;\\n            emit Initialized(type(uint8).max);\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal function that returns the initialized version. Returns `_initialized`\\n     */\\n    function _getInitializedVersion() internal view returns (uint8) {\\n        return _initialized;\\n    }\\n\\n    /**\\n     * @dev Internal function that returns the initialized version. Returns `_initializing`\\n     */\\n    function _isInitializing() internal view returns (bool) {\\n        return _initializing;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/proxy/utils/UUPSUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/utils/UUPSUpgradeable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../interfaces/draft-IERC1822Upgradeable.sol\\\";\\nimport \\\"../ERC1967/ERC1967UpgradeUpgradeable.sol\\\";\\nimport \\\"./Initializable.sol\\\";\\n\\n/**\\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\\n *\\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\\n * `UUPSUpgradeable` with a custom implementation of upgrades.\\n *\\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\\n *\\n * _Available since v4.1._\\n */\\nabstract contract UUPSUpgradeable is Initializable, IERC1822ProxiableUpgradeable, ERC1967UpgradeUpgradeable {\\n    function __UUPSUpgradeable_init() internal onlyInitializing {\\n    }\\n\\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\\n    }\\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\\n    address private immutable __self = address(this);\\n\\n    /**\\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\\n     * fail.\\n     */\\n    modifier onlyProxy() {\\n        require(address(this) != __self, \\\"Function must be called through delegatecall\\\");\\n        require(_getImplementation() == __self, \\\"Function must be called through active proxy\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\\n     * callable on the implementing contract but not through proxies.\\n     */\\n    modifier notDelegated() {\\n        require(address(this) == __self, \\\"UUPSUpgradeable: must not be called through delegatecall\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the\\n     * implementation. It is used to validate the implementation's compatibility when performing an upgrade.\\n     *\\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\\n     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\\n     */\\n    function proxiableUUID() external view virtual override notDelegated returns (bytes32) {\\n        return _IMPLEMENTATION_SLOT;\\n    }\\n\\n    /**\\n     * @dev Upgrade the implementation of the proxy to `newImplementation`.\\n     *\\n     * Calls {_authorizeUpgrade}.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function upgradeTo(address newImplementation) external virtual onlyProxy {\\n        _authorizeUpgrade(newImplementation);\\n        _upgradeToAndCallUUPS(newImplementation, new bytes(0), false);\\n    }\\n\\n    /**\\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\\n     * encoded in `data`.\\n     *\\n     * Calls {_authorizeUpgrade}.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function upgradeToAndCall(address newImplementation, bytes memory data) external payable virtual onlyProxy {\\n        _authorizeUpgrade(newImplementation);\\n        _upgradeToAndCallUUPS(newImplementation, data, true);\\n    }\\n\\n    /**\\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\\n     * {upgradeTo} and {upgradeToAndCall}.\\n     *\\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\\n     *\\n     * ```solidity\\n     * function _authorizeUpgrade(address) internal override onlyOwner {}\\n     * ```\\n     */\\n    function _authorizeUpgrade(address newImplementation) internal virtual;\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/security/PausableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    function __Pausable_init() internal onlyInitializing {\\n        __Pausable_init_unchained();\\n    }\\n\\n    function __Pausable_init_unchained() internal onlyInitializing {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        _requireNotPaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        _requirePaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is paused.\\n     */\\n    function _requireNotPaused() internal view virtual {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is not paused.\\n     */\\n    function _requirePaused() internal view virtual {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/utils/AddressUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/utils/ContextUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal onlyInitializing {\\n    }\\n\\n    function __Context_init_unchained() internal onlyInitializing {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/utils/StorageSlotUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/StorageSlot.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for reading and writing primitive types to specific storage slots.\\n *\\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\\n * This library helps with reading and writing to such slots without the need for inline assembly.\\n *\\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\\n *\\n * Example usage to set ERC1967 implementation slot:\\n * ```\\n * contract ERC1967 {\\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n *\\n *     function _getImplementation() internal view returns (address) {\\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n *     }\\n *\\n *     function _setImplementation(address newImplementation) internal {\\n *         require(Address.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n *     }\\n * }\\n * ```\\n *\\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\\n */\\nlibrary StorageSlotUpgradeable {\\n    struct AddressSlot {\\n        address value;\\n    }\\n\\n    struct BooleanSlot {\\n        bool value;\\n    }\\n\\n    struct Bytes32Slot {\\n        bytes32 value;\\n    }\\n\\n    struct Uint256Slot {\\n        uint256 value;\\n    }\\n\\n    /**\\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\\n     */\\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\\n     */\\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\\n     */\\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\\n     */\\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ILargeStaking.sol\": {\r\n      \"content\": \"pragma solidity 0.8.8;\\n\\n/**\\n * @title Interface for LargeStaking\\n * @notice Vault factory\\n */\\n\\nimport {CLStakingExitInfo, CLStakingSlashInfo} from \\\"src/library/ConsensusStruct.sol\\\";\\n\\ninterface ILargeStaking {\\n    event SharedRewardPoolStart(uint256 _operatorId, address _elRewardPoolAddr);\\n    event LargeStake(\\n        uint256 _operatorId,\\n        uint256 _curStakingId,\\n        uint256 _amount,\\n        address _owner,\\n        address _elRewardAddr,\\n        address _withdrawCredentials,\\n        bool _isELRewardSharing\\n    );\\n    event MigretaStake(\\n        uint256 _operatorId,\\n        uint256 _curStakingId,\\n        uint256 _amount,\\n        address _owner,\\n        address _elRewardAddr,\\n        address _withdrawCredentials,\\n        bool _isELRewardSharing\\n    );\\n    event AppendStake(uint256 _stakingId, uint256 _amount);\\n    event AppendMigretaStake(uint256 _stakingId, uint256 _stakeAmounts);\\n    event ValidatorRegistered(uint256 _operatorId, uint256 _stakeingId, bytes _pubKey);\\n    event FastUnstake(uint256 _stakingId, uint256 _unstakeAmount);\\n    event LargeUnstake(uint256 _stakingId, uint256 _amount);\\n    event ELShareingRewardSettle(uint256 _operatorId, uint256 _daoReward, uint256 _operatorReward, uint256 _poolReward);\\n    event ElPrivateRewardSettle(\\n        uint256 _stakingId, uint256 _operatorId, uint256 _daoReward, uint256 _operatorReward, uint256 _poolReward\\n    );\\n    event UserRewardClaimed(uint256 _stakingId, address _beneficiary, uint256 _rewards);\\n    event OperatorRewardClaimed(uint256 _operatorId, address _rewardAddresses, uint256 _rewardAmounts);\\n    event OperatorPrivateRewardClaimed(uint256 _stakingId, uint256 _operatorId, uint256 _operatorRewards);\\n    event OperatorSharedRewardClaimed(uint256 _operatorId, uint256 _operatorRewards);\\n    event DaoPrivateRewardClaimed(uint256 _stakingId, address _daoVaultAddress, uint256 _daoRewards);\\n    event DaoSharedRewardClaimed(uint256 _operatorId, address daoVaultAddress, uint256 _daoRewards);\\n    event LargeStakingSlash(uint256 _stakingIds, uint256 _operatorIds, bytes _pubkey, uint256 _amounts);\\n    event ValidatorExitReport(uint256 _operatorId, bytes[] _pubkey);\\n    event DaoAddressChanged(address _oldDao, address _dao);\\n    event DaoVaultAddressChanged(address _oldDaoVaultAddress, address _daoVaultAddress);\\n    event DaoELCommissionRateChanged(uint256 _oldDaoElCommissionRate, uint256 _daoElCommissionRate);\\n    event NodeOperatorsRegistryChanged(address _oldNodeOperatorRegistryContract, address _nodeOperatorRegistryAddress);\\n    event ConsensusOracleChanged(address _oldLargeOracleContractAddr, address _largeOracleContractAddr);\\n    event ELRewardFactoryChanged(address _oldElRewardFactory, address _elRewardFactory);\\n    event OperatorSlashChanged(address _oldOperatorSlashContract, address _operatorSlashContract);\\n    event MinStakeAmountChanged(uint256 _oldMinStakeAmount, uint256 _minStakeAmount);\\n    event MaxSlashAmountChanged(uint256 _oldMaxSlashAmount, uint256 _maxSlashAmount);\\n    event ElRewardAddressChanged(address _oldElRewardAddr, address _elRewardAddr);\\n\\n    function getOperatorValidatorCounts(uint256 _operatorId) external view returns (uint256);\\n\\n    function reportCLStakingData(\\n        CLStakingExitInfo[] memory _clStakingExitInfo,\\n        CLStakingSlashInfo[] memory _clStakingSlashInfo\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"src/library/ConsensusStruct.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.8;\\n\\nstruct WithdrawInfo {\\n    uint64 operatorId;\\n    // The income that should be issued by this operatorId in this settlement\\n    uint96 clReward;\\n    // For this settlement, whether operatorId has exit node, if no exit node is 0;\\n    // The value of one node exiting is 32 eth(or 32.9 ETH), and the value of two nodes exiting is 64eth (or 63 ETH).\\n    // If the value is less than 32, the corresponding amount will be punished\\n    // clCapital is the principal of nft exit held by the protocol\\n    uint96 clCapital;\\n}\\n\\nstruct ExitValidatorInfo {\\n    // Example Exit the token Id of the validator. No exit is an empty array.\\n    uint64 exitTokenId;\\n    // Height of exit block\\n    uint96 exitBlockNumber;\\n    // Amount of slash\\n    uint96 slashAmount;\\n}\\n\\n// Validator quits reporting information\\nstruct CLStakingExitInfo {\\n    uint128 stakingId;\\n    bytes[] pubkeys;\\n}\\n\\n// Verifier penalty reporting information\\nstruct CLStakingSlashInfo {\\n    uint128 stakingId;\\n    // Trigger penalty on operator if slash occurs\\n    uint128 slashAmount;\\n    bytes pubkey;\\n}\\n\"\r\n    },\r\n    \"src/library/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.8;\\n\\nlibrary MathUtil {\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /// @notice Tests if x \u2208 [a, b) (mod n)\\n    ///\\n    function pointInHalfOpenIntervalModN(uint256 x, uint256 a, uint256 b, uint256 n) internal pure returns (bool) {\\n        return (x + n - a) % n < (b - a) % n;\\n    }\\n\\n    /// @notice Tests if x \u2208 [a, b] (mod n)\\n    ///\\n    function pointInClosedIntervalModN(uint256 x, uint256 a, uint256 b, uint256 n) internal pure returns (bool) {\\n        return (x + n - a) % n <= (b - a) % n;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/oracles/BaseOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.8;\\n\\nimport \\\"openzeppelin-contracts/utils/math/SafeCast.sol\\\";\\nimport \\\"openzeppelin-contracts-upgradeable/access/OwnableUpgradeable.sol\\\";\\nimport \\\"openzeppelin-contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\\\";\\nimport \\\"openzeppelin-contracts-upgradeable/security/PausableUpgradeable.sol\\\";\\nimport \\\"src/utils/Versioned.sol\\\";\\nimport \\\"src/utils/Dao.sol\\\";\\nimport {IReportAsyncProcessor} from \\\"src/oracles/MultiHashConsensus.sol\\\";\\n\\ninterface IConsensusContract {\\n    function getIsMember(address addr) external view returns (bool);\\n\\n    function getCurrentFrame() external view returns (uint256 refSlot, uint256 reportProcessingDeadlineSlot);\\n\\n    function getChainConfig()\\n        external\\n        view\\n        returns (uint256 slotsPerEpoch, uint256 secondsPerSlot, uint256 genesisTime);\\n\\n    function getFrameConfig() external view returns (uint256 initialEpoch, uint256 epochsPerFrame);\\n\\n    function getInitialRefSlot() external view returns (uint256);\\n\\n    function getReportModuleId(address reportProcessor) external view returns (uint256);\\n}\\n\\nabstract contract BaseOracle is\\n    OwnableUpgradeable,\\n    UUPSUpgradeable,\\n    PausableUpgradeable,\\n    Dao,\\n    Versioned,\\n    IReportAsyncProcessor\\n{\\n    using SafeCast for uint256;\\n\\n    error SenderNotAllowed();\\n    error InvalidAddr();\\n    error AddressCannotBeZero();\\n    error AddressCannotBeSame();\\n    error VersionCannotBeSame();\\n    error UnexpectedChainConfig();\\n    error OnlyConsensusContractCanSubmitReport();\\n    error ModuleIdIsZero();\\n    error ModuleIdNotEqual();\\n    error PermissionDenied();\\n    error InitialRefSlotCannotBeLessThanProcessingOne(uint256 initialRefSlot, uint256 processingRefSlot);\\n    error RefSlotMustBeGreaterThanProcessingOne(uint256 refSlot, uint256 processingRefSlot);\\n    error RefSlotCannotDecrease(uint256 refSlot, uint256 prevRefSlot);\\n    error ProcessingDeadlineMissed(uint256 deadline);\\n    error RefSlotAlreadyProcessing();\\n    error UnexpectedRefSlot(uint256 consensusRefSlot, uint256 dataRefSlot);\\n    error UnexpectedConsensusVersion(uint256 expectedVersion, uint256 receivedVersion);\\n    error UnexpectedDataHash(bytes32 consensusHash, bytes32 receivedHash);\\n\\n    event ConsensusHashContractSet(address indexed addr, address indexed prevAddr);\\n    event ConsensusVersionSet(uint256 indexed version, uint256 indexed prevVersion);\\n    event WarnProcessingMissed(uint256 indexed refSlot);\\n\\n    struct ConsensusReport {\\n        bytes32 hash;\\n        uint64 refSlot;\\n        uint64 processingDeadlineTime;\\n    }\\n\\n    address internal consensusContract;\\n\\n    uint256 internal consensusVersion;\\n\\n    uint256 internal lastProcessingRefSlot;\\n\\n    ConsensusReport internal consensusReport;\\n\\n    uint256 public SECONDS_PER_SLOT;\\n\\n    uint256 public GENESIS_TIME;\\n\\n    ///\\n    /// Descendant contract interface\\n    ///\\n\\n    /// @notice Initializes the contract storage. Must be called by a descendant\\n    /// contract as part of its initialization.\\n    ///\\n    function __BaseOracle_init(\\n        uint256 secondsPerSlot,\\n        uint256 genesisTime,\\n        address _consensusContract,\\n        uint256 _consensusVersion,\\n        uint256 _lastProcessingRefSlot,\\n        address _dao\\n    ) internal virtual onlyInitializing {\\n        __Ownable_init();\\n        __UUPSUpgradeable_init();\\n        __Pausable_init();\\n\\n        if (_dao == address(0)) revert DaoCannotBeZero();\\n        dao = _dao;\\n        SECONDS_PER_SLOT = secondsPerSlot;\\n        GENESIS_TIME = genesisTime;\\n\\n        _initializeContractVersionTo(1);\\n        _setConsensusContract(_consensusContract, _lastProcessingRefSlot);\\n        _setConsensusVersion(_consensusVersion);\\n        lastProcessingRefSlot = _lastProcessingRefSlot;\\n\\n        consensusReport.refSlot = uint64(_lastProcessingRefSlot);\\n    }\\n\\n    /**\\n     * @notice In the event of an emergency, stop protocol\\n     */\\n    function pause() external onlyDao {\\n        _pause();\\n    }\\n\\n    /**\\n     * @notice restart protocol\\n     */\\n    function unpause() external onlyDao {\\n        _unpause();\\n    }\\n\\n    // set dao vault address\\n    function setDaoAddress(address _dao) external override onlyOwner {\\n        if (_dao == address(0)) revert InvalidAddr();\\n        emit DaoAddressChanged(dao, _dao);\\n        dao = _dao;\\n    }\\n\\n    /// @notice Returns the address of the HashConsensus contract.\\n    ///\\n    function getConsensusContract() external view returns (address) {\\n        return consensusContract;\\n    }\\n\\n    /// @notice Sets the address of the HashConsensus contract.\\n    ///\\n    function setConsensusContract(address addr) external onlyOwner {\\n        _setConsensusContract(addr, lastProcessingRefSlot);\\n    }\\n\\n    /// @notice Returns the current consensus version expected by the oracle contract.\\n    ///\\n    /// Consensus version must change every time consensus rules change, meaning that\\n    /// an oracle looking at the same reference slot would calculate a different hash.\\n    ///\\n    function getConsensusVersion() external view returns (uint256) {\\n        return consensusVersion;\\n    }\\n\\n    /// @notice Sets the consensus version expected by the oracle contract.\\n    ///\\n    function setConsensusVersion(uint256 version) external onlyDao {\\n        _setConsensusVersion(version);\\n    }\\n\\n    /// @notice Sets the oracle contract version.\\n    function updateContractVersion(uint256 version) external onlyDao {\\n        _updateContractVersion(version);\\n    }\\n\\n    ///\\n    /// Data provider interface\\n    ///\\n\\n    /// @notice Returns the last consensus report hash and metadata.\\n    ///\\n    function getConsensusReport()\\n        external\\n        view\\n        returns (bytes32 hash, uint256 refSlot, uint256 processingDeadlineTime, bool processingStarted)\\n    {\\n        ConsensusReport memory report = consensusReport;\\n        uint256 processingRefSlot = lastProcessingRefSlot;\\n        return (\\n            report.hash,\\n            report.refSlot,\\n            report.processingDeadlineTime,\\n            report.hash != bytes32(0) && report.refSlot == processingRefSlot\\n        );\\n    }\\n\\n    ///\\n    /// Consensus contract interface\\n    ///\\n\\n    /// @notice Called by HashConsensus contract to push a consensus report for processing.\\n    ///\\n    /// Note that submitting the report doesn't require the oracle to start processing it\\n    /// right away, this can happen later. Until the processing is started, HashConsensus is\\n    /// free to reach consensus on another report for the same reporting frame and submit it\\n    /// using this same function.\\n    ///\\n    function submitConsensusReport(bytes32 reportHash, uint256 refSlot, uint256 deadline, uint256 _moduleId) external {\\n        uint256 moduleId = IConsensusContract(consensusContract).getReportModuleId(address(this));\\n        if (moduleId == 0) revert ModuleIdIsZero();\\n        if (moduleId != _moduleId) revert ModuleIdNotEqual();\\n\\n        if (_msgSender() != consensusContract) {\\n            revert OnlyConsensusContractCanSubmitReport();\\n        }\\n\\n        uint256 prevSubmittedRefSlot = consensusReport.refSlot;\\n        if (refSlot < prevSubmittedRefSlot) {\\n            revert RefSlotCannotDecrease(refSlot, prevSubmittedRefSlot);\\n        }\\n\\n        uint256 prevProcessingRefSlot = lastProcessingRefSlot;\\n        if (refSlot <= prevProcessingRefSlot) {\\n            revert RefSlotMustBeGreaterThanProcessingOne(refSlot, prevProcessingRefSlot);\\n        }\\n\\n        if (refSlot != prevSubmittedRefSlot && prevProcessingRefSlot != prevSubmittedRefSlot) {\\n            emit WarnProcessingMissed(prevSubmittedRefSlot);\\n        }\\n\\n        ConsensusReport memory report = ConsensusReport({\\n            hash: reportHash,\\n            refSlot: refSlot.toUint64(),\\n            processingDeadlineTime: deadline.toUint64()\\n        });\\n\\n        consensusReport = report;\\n        _handleConsensusReport(report, prevSubmittedRefSlot, prevProcessingRefSlot);\\n    }\\n\\n    /// @notice Returns the last reference slot for which processing of the report was started.\\n    ///\\n    function getLastProcessingRefSlot() external view returns (uint256) {\\n        return lastProcessingRefSlot;\\n    }\\n\\n    /// @notice Returns whether the given address is a member of the oracle committee.\\n    ///\\n    function _isConsensusMember(address addr) internal view returns (bool) {\\n        return IConsensusContract(consensusContract).getIsMember(addr);\\n    }\\n\\n    /// @notice Called when oracle gets a new consensus report from the HashConsensus contract.\\n    ///\\n    /// Keep in mind that, until you call `_startProcessing`, the oracle committee is free to\\n    /// reach consensus on another report for the same reporting frame and re-submit it using\\n    /// this function.\\n    ///\\n    function _handleConsensusReport(\\n        ConsensusReport memory report,\\n        uint256 prevSubmittedRefSlot,\\n        uint256 prevProcessingRefSlot\\n    ) internal virtual;\\n\\n    function _checkMsgSenderIsAllowedToSubmitData() internal view {\\n        address sender = _msgSender();\\n        if (!_isConsensusMember(sender)) {\\n            revert SenderNotAllowed();\\n        }\\n    }\\n\\n    /// @notice May be called by a descendant contract to check if the received data matches\\n    /// the currently submitted consensus report, and that processing deadline is not missed.\\n    /// Reverts otherwise.\\n    function _checkConsensusData(uint256 refSlot, uint256 _consensusVersion, bytes32 hash, uint256 _moduleId)\\n        internal\\n        view\\n    {\\n        // If the processing deadline for the current consensus report is missed, an error is reported\\n        _checkProcessingDeadline();\\n\\n        uint256 moduleId = IConsensusContract(consensusContract).getReportModuleId(address(this));\\n\\n        if (moduleId == 0) revert ModuleIdIsZero();\\n        if (moduleId != _moduleId) revert ModuleIdNotEqual();\\n\\n        ConsensusReport memory report = consensusReport;\\n        if (refSlot != report.refSlot) {\\n            revert UnexpectedRefSlot(report.refSlot, refSlot);\\n        }\\n\\n        uint256 expectedConsensusVersion = _consensusVersion;\\n        if (consensusVersion != expectedConsensusVersion) {\\n            revert UnexpectedConsensusVersion(expectedConsensusVersion, consensusVersion);\\n        }\\n\\n        if (hash != report.hash) {\\n            revert UnexpectedDataHash(report.hash, hash);\\n        }\\n    }\\n\\n    /// @notice Called by a descendant contract to mark the current consensus report\\n    /// as being processed. Returns the last ref. slot which processing was started\\n    /// before the call.\\n    ///\\n    /// Before this function is called, the oracle committee is free to reach consensus\\n    /// on another report for the same reporting frame. After this function is called,\\n    /// the consensus report for the current frame is guaranteed to remain the same.\\n    ///\\n    function _startProcessing() internal returns (uint256) {\\n        _checkProcessingDeadline();\\n\\n        ConsensusReport memory report = consensusReport;\\n\\n        // If the slot has been reported, an error is reported\\n        uint256 prevProcessingRefSlot = lastProcessingRefSlot;\\n        if (prevProcessingRefSlot == report.refSlot) {\\n            revert RefSlotAlreadyProcessing();\\n        }\\n\\n        lastProcessingRefSlot = report.refSlot;\\n        return prevProcessingRefSlot;\\n    }\\n\\n    /// @notice Reverts if the processing deadline for the current consensus report is missed.\\n    ///\\n    function _checkProcessingDeadline() internal view {\\n        uint256 deadline = consensusReport.processingDeadlineTime;\\n        if (_getTime() > deadline) revert ProcessingDeadlineMissed(deadline);\\n    }\\n\\n    /// @notice Returns the reference slot for the current frame.\\n    ///\\n    function _getCurrentRefSlot() internal view returns (uint256) {\\n        (uint256 refSlot,) = IConsensusContract(consensusContract).getCurrentFrame();\\n        return refSlot;\\n    }\\n\\n    ///\\n    /// Implementation & helpers\\n    ///\\n\\n    function _setConsensusVersion(uint256 version) internal {\\n        uint256 prevVersion = consensusVersion;\\n        if (version == prevVersion) revert VersionCannotBeSame();\\n        consensusVersion = version;\\n        emit ConsensusVersionSet(version, prevVersion);\\n    }\\n\\n    function _setConsensusContract(address addr, uint256 _lastProcessingRefSlot) internal {\\n        if (addr == address(0)) revert AddressCannotBeZero();\\n\\n        address prevAddr = consensusContract;\\n        if (addr == prevAddr) revert AddressCannotBeSame();\\n\\n        (, uint256 secondsPerSlot, uint256 genesisTime) = IConsensusContract(addr).getChainConfig();\\n        if (secondsPerSlot != SECONDS_PER_SLOT || genesisTime != GENESIS_TIME) {\\n            revert UnexpectedChainConfig();\\n        }\\n\\n        uint256 initialRefSlot = IConsensusContract(addr).getInitialRefSlot();\\n        if (initialRefSlot < _lastProcessingRefSlot) {\\n            revert InitialRefSlotCannotBeLessThanProcessingOne(initialRefSlot, _lastProcessingRefSlot);\\n        }\\n\\n        consensusContract = addr;\\n        emit ConsensusHashContractSet(addr, prevAddr);\\n    }\\n\\n    function _getTime() internal view virtual returns (uint256) {\\n        return block.timestamp; // solhint-disable-line not-rely-on-time\\n    }\\n\\n    function _authorizeUpgrade(address) internal override onlyOwner {}\\n}\\n\"\r\n    },\r\n    \"src/oracles/LargeStakeOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.8;\\n\\nimport \\\"src/oracles/BaseOracle.sol\\\";\\nimport \\\"src/interfaces/ILargeStaking.sol\\\";\\nimport {CLStakingExitInfo, CLStakingSlashInfo} from \\\"src/library/ConsensusStruct.sol\\\";\\n\\ncontract LargeStakeOracle is BaseOracle {\\n    event LargeStakeContractChanged(address oldLargeStake, address newLargeStake);\\n    event ReportSuccess(\\n        uint256 indexed refSlot,\\n        uint256 consensusVersion,\\n        CLStakingExitInfo[] cLStakingExitInfos,\\n        CLStakingSlashInfo[] cLStakingSlashInfos\\n    );\\n    event UpdateExitLimit(uint256 oldExitLimit, uint256 newExitLimit);\\n\\n    error ReportDataIsEmpty();\\n    error ExitLimitNotZero();\\n    error OverExitLimit();\\n\\n    struct ProcessingState {\\n        /// @notice Reference slot for the current reporting frame.\\n        uint256 currentFrameRefSlot;\\n        /// @notice The last time at which a report data can be submitted for the current\\n        /// reporting frame.\\n        uint256 processingDeadlineTime;\\n        /// @notice Hash of the report data. Zero bytes if consensus on the hash hasn't\\n        /// been reached yet for the current reporting frame.\\n        bytes32 dataHash;\\n        /// @notice Whether any report data for the for the current reporting frame has been\\n        /// already submitted.\\n        bool dataSubmitted;\\n    }\\n\\n    /// Data provider interface\\n    struct ReportData {\\n        // @dev Version of the oracle consensus rules. Current version expected\\n        // by the oracle can be obtained by calling getConsensusVersion().\\n        uint256 consensusVersion;\\n        // @dev Reference slot for which the report was calculated. If the slot\\n        // contains a block, the exitBlockNumbers being reported should include all state\\n        // changes resulting from that block. The epoch containing the slot\\n        // should be finalized prior to calculating the report.\\n        // beacon slot for reference\\n        uint256 refSlot;\\n        // @dev Validator quits reporting information.\\n        // Only validator exits are reported.\\n        CLStakingExitInfo[] clStakingExitInfos;\\n        // @dev Verifier slash reporting information.\\n        // Only validator slash are reported.\\n        CLStakingSlashInfo[] clStakingSlashInfos;\\n    }\\n\\n    address public largeStakeContract;\\n\\n    // Specifies the maximum number of validator exits reported each time\\n    uint256 public exitLimit;\\n\\n    function initialize(\\n        uint256 secondsPerSlot,\\n        uint256 genesisTime,\\n        address consensusContract,\\n        uint256 consensusVersion,\\n        uint256 lastProcessingRefSlot,\\n        address _dao,\\n        address _largeStakeContract\\n    ) public initializer {\\n        __BaseOracle_init(secondsPerSlot, genesisTime, consensusContract, consensusVersion, lastProcessingRefSlot, _dao);\\n        largeStakeContract = _largeStakeContract;\\n        exitLimit = 100;\\n    }\\n\\n    /// Set the number limit for the validator to report\\n    function setExitLimit(uint256 _exitLimit) external onlyDao {\\n        if (_exitLimit == 0) revert ExitLimitNotZero();\\n        emit UpdateExitLimit(exitLimit, _exitLimit);\\n        exitLimit = _exitLimit;\\n    }\\n\\n    /**\\n     * @notice set LargeStake contract address\\n     */\\n    function setLargeStakeContract(address _largeStakeContractAddress) external onlyDao {\\n        if (_largeStakeContractAddress == address(0)) revert InvalidAddr();\\n        emit LargeStakeContractChanged(largeStakeContract, _largeStakeContractAddress);\\n        largeStakeContract = _largeStakeContractAddress;\\n    }\\n\\n    /// @notice Returns data processing state for the current reporting frame.\\n    /// @return result See the docs for the `ProcessingState` struct.\\n    function getProcessingState() external view returns (ProcessingState memory result) {\\n        ConsensusReport memory report = consensusReport;\\n        result.currentFrameRefSlot = _getCurrentRefSlot();\\n\\n        if (result.currentFrameRefSlot != report.refSlot) {\\n            return result;\\n        }\\n\\n        result.processingDeadlineTime = report.processingDeadlineTime;\\n        result.dataHash = report.hash;\\n\\n        result.dataSubmitted = lastProcessingRefSlot == result.currentFrameRefSlot;\\n        if (!result.dataSubmitted) {\\n            return result;\\n        }\\n    }\\n\\n    /// @notice Submits report data for processing.\\n    ///\\n    /// @param data The data. See the `ReportData` structure's docs for details.\\n    /// @param _contractVersion Expected version of the oracle contract.\\n    /// @param _moduleId oracle module id.\\n    function submitReportData(ReportData calldata data, uint256 _contractVersion, uint256 _moduleId)\\n        external\\n        whenNotPaused\\n    {\\n        _checkMsgSenderIsAllowedToSubmitData();\\n        _checkContractVersion(_contractVersion);\\n        // it's a waste of gas to copy the whole calldata into mem but seems there's no way around\\n        _checkConsensusData(data.refSlot, data.consensusVersion, keccak256(abi.encode(data)), _moduleId);\\n        _startProcessing();\\n        _handleConsensusReportData(data);\\n    }\\n\\n    function _handleConsensusReportData(ReportData calldata data) internal {\\n        if (data.clStakingExitInfos.length == 0 && data.clStakingSlashInfos.length == 0) {\\n            revert ReportDataIsEmpty();\\n        }\\n        if (data.clStakingExitInfos.length > exitLimit || data.clStakingSlashInfos.length > exitLimit) {\\n            revert OverExitLimit();\\n        }\\n        ILargeStaking(largeStakeContract).reportCLStakingData(data.clStakingExitInfos, data.clStakingSlashInfos);\\n\\n        emit ReportSuccess(data.refSlot, data.consensusVersion, data.clStakingExitInfos, data.clStakingSlashInfos);\\n    }\\n\\n    /// @notice Called when oracle gets a new consensus report from the HashConsensus contract.\\n    ///\\n    /// Keep in mind that, until you call `_startProcessing`, the oracle committee is free to\\n    /// reach consensus on another report for the same reporting frame and re-submit it using\\n    /// this function.\\n    ///\\n    function _handleConsensusReport(\\n        ConsensusReport memory report,\\n        uint256 prevSubmittedRefSlot,\\n        uint256 prevProcessingRefSlot\\n    ) internal override {}\\n}\\n\"\r\n    },\r\n    \"src/oracles/MultiHashConsensus.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.8;\\n\\nimport {SafeCast} from \\\"openzeppelin-contracts/utils/math/SafeCast.sol\\\";\\nimport \\\"openzeppelin-contracts-upgradeable/access/OwnableUpgradeable.sol\\\";\\nimport \\\"openzeppelin-contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\\\";\\nimport {MathUtil} from \\\"src/library/Math.sol\\\";\\nimport \\\"src/utils/Dao.sol\\\";\\nimport \\\"src/utils/Array.sol\\\";\\n\\n/// @notice A contract that gets consensus reports (i.e. hashes) pushed to and processes them\\n/// asynchronously.\\n///\\n/// HashConsensus doesn't expect any specific behavior from a report processor, and guarantees\\n/// the following:\\n///\\n/// 1. HashConsensus won't submit reports via `IReportAsyncProcessor.submitConsensusReport` for the\\n///    slot returned from `IReportAsyncProcessor.getLastProcessingRefSlot` and any slot preceding it.\\n///\\n/// 2. HashConsensus won't accept member reports (and thus won't include such reports in calculating\\n///    the consensus) that have `consensusVersion` argument of the `HashConsensus.submitReport` call\\n///    holding a diff. value than the one returned from `IReportAsyncProcessor.getConsensusVersion()`\\n///    at the moment of the `HashConsensus.submitReport` call.\\n///\\ninterface IReportAsyncProcessor {\\n    /// @notice Submits a consensus report for processing.\\n    ///\\n    /// Note that submitting the report doesn't require the processor to start processing it\\n    /// right away, this can happen later. Until the processing is started, HashConsensus is\\n    /// free to reach consensus on another report for the same reporting frame and submit it\\n    /// using this same function.\\n    ///\\n    function submitConsensusReport(bytes32 report, uint256 refSlot, uint256 deadline, uint256 moduleId) external;\\n\\n    /// @notice Returns the last reference slot for which processing of the report was started.\\n    ///\\n    /// HashConsensus won't submit reports for any slot less than or equal to this slot.\\n    ///\\n    function getLastProcessingRefSlot() external view returns (uint256);\\n\\n    /// @notice Returns the current consensus version.\\n    ///\\n    /// Consensus version must change every time consensus rules change, meaning that\\n    /// an oracle looking at the same reference slot would calculate a different hash.\\n    ///\\n    /// HashConsensus won't accept member reports any consensus version different form the\\n    /// one returned from this function.\\n    ///\\n    function getConsensusVersion() external view returns (uint256);\\n}\\n\\ncontract MultiHashConsensus is OwnableUpgradeable, UUPSUpgradeable, Dao {\\n    using SafeCast for uint256;\\n\\n    error InvalidAddr();\\n    error InvalidModuleId();\\n    error NumericOverflow();\\n    error ReportProcessorCannotBeZero();\\n    error FrameMultipleCannotBeZero();\\n    error DuplicateMember();\\n    error DuplicateReportProcessor();\\n    error ReportProcessorNotFound(address reportProcessor);\\n    error AddressCannotBeZero();\\n    error InitialEpochIsYetToArrive();\\n    error InitialEpochAlreadyArrived();\\n    error InitialEpochRefSlotCannotBeEarlierThanProcessingSlot();\\n    error EpochsPerFrameCannotBeZero();\\n    error NonMember();\\n    error UnexpectedConsensusVersion(uint256 expected, uint256 received);\\n    error QuorumTooSmall(uint256 minQuorum, uint256 receivedQuorum);\\n    error InvalidSlot();\\n    error OracleIndexReportShouldZeroHash(uint256 refSlot, bytes32[] report, uint256 moduleId, uint64 frameMultiple);\\n    error DuplicateReport();\\n    error EmptyReport();\\n    error ReportLenNotEqualReportProcessorsLen();\\n    error StaleReport();\\n    error NonFastLaneMemberCannotReportWithinFastLaneInterval();\\n    error ConsensusReportAlreadyProcessing();\\n    error FastLanePeriodCannotBeLongerThanFrame();\\n\\n    event FrameConfigSet(uint256 newInitialEpoch, uint256 newEpochsPerFrame);\\n    event FastLaneConfigSet(uint256 fastLaneLengthSlots);\\n    event MemberAdded(address indexed addr, uint256 newTotalMembers, uint256 newQuorum);\\n    event MemberRemoved(address indexed addr, uint256 newTotalMembers, uint256 newQuorum);\\n    event QuorumSet(uint256 newQuorum, uint256 totalMembers, uint256 prevQuorum);\\n    event ConsensusReportReceived(\\n        uint256 indexed refSlot, address indexed member, bytes32[] report, bool isReached, uint256 support\\n    );\\n    event ConsensusReached(uint256 indexed refSlot, bytes32[] report, uint256 support);\\n    event ReportProcessorAdd(address indexed processor, uint256 indexed moduleId, uint64 frameMultiple);\\n    event ReportProcessorUpdate(\\n        address indexed oldProcessor, address indexed newProcessor, uint256 indexed moduleId, uint64 frameMultiple\\n    );\\n\\n    struct FrameConfig {\\n        uint64 initialEpoch;\\n        uint64 epochsPerFrame;\\n        uint64 fastLaneLengthSlots;\\n    }\\n\\n    /// @dev Oracle reporting is divided into frames, each lasting the same number of slots\\n    struct ConsensusFrame {\\n        // frame index; increments by 1 with each frame but resets to zero on frame size change\\n        uint256 index;\\n        // the slot at which to read the state around which consensus is being reached;\\n        // if the slot contains a block, the state should include all changes from that block\\n        uint256 refSlot;\\n        // the last slot at which a report can be processed\\n        uint256 reportProcessingDeadlineSlot;\\n    }\\n\\n    struct ReportingState {\\n        // the last reference slot any report was received for\\n        uint64 lastReportRefSlot;\\n        // the last reference slot a consensus was reached for\\n        uint64 lastConsensusRefSlot;\\n        // the last consensus variant index\\n        uint64 lastConsensusVariantIndex;\\n    }\\n\\n    struct MemberState {\\n        // the last reference slot a report from this member was received for\\n        uint64 lastReportRefSlot;\\n        // the variant index of the last report from this member\\n        uint64 lastReportVariantIndex;\\n    }\\n\\n    struct ReportVariant {\\n        // the reported hash\\n        bytes32[] hashArr;\\n        // how many unique members from the current set reported this hash in the current frame\\n        uint64 support;\\n    }\\n\\n    struct ReportProcessor {\\n        // the report address\\n        address processor;\\n        // The multiple of the frequency of the Frame(`FrameConfig.epochsPerFrame`).\\n        uint64 frameMultiple;\\n    }\\n\\n    /// Chain specification\\n    uint64 internal SLOTS_PER_EPOCH;\\n    uint64 internal SECONDS_PER_SLOT;\\n    uint64 internal GENESIS_TIME;\\n\\n    /// @dev A quorum value that effectively disables the oracle.\\n    uint256 internal constant UNREACHABLE_QUORUM = type(uint256).max;\\n    bytes32 internal constant ZERO_HASH = bytes32(0);\\n\\n    /// @dev Reporting frame configuration\\n    FrameConfig internal _frameConfig;\\n\\n    /// @dev Oracle committee members states array\\n    MemberState[] internal _memberStates;\\n\\n    /// @dev Oracle committee members' addresses array\\n    address[] internal _memberAddresses;\\n\\n    /// @dev Mapping from an oracle committee member address to the 1-based index in the\\n    /// members array\\n    mapping(address => uint256) internal _memberIndices1b;\\n\\n    /// @dev A structure containing the last reference slot any report was received for, the last\\n    /// reference slot consensus report was achieved for, and the last consensus variant index\\n    ReportingState internal reportingState;\\n\\n    /// @dev Oracle committee members quorum value, must be larger than totalMembers // 2\\n    uint256 internal _quorum;\\n\\n    /// @dev Mapping from a report variant index to the ReportVariant structure\\n    mapping(uint256 => ReportVariant) internal _reportVariants;\\n\\n    /// @dev The number of report variants\\n    uint256 internal _reportVariantsLength;\\n\\n    // @dev Oracle service list\\n    ReportProcessor[] internal reportProcessors;\\n\\n    // @dev The module ID of the report processor, starting with 1\\n    mapping(address => uint256) internal reportIndices1b;\\n\\n    // Initialization\\n    function initialize(\\n        uint256 slotsPerEpoch,\\n        uint256 secondsPerSlot,\\n        uint256 genesisTime,\\n        uint256 epochsPerFrame,\\n        uint256 fastLaneLengthSlots,\\n        address _dao\\n    ) public initializer {\\n        __Ownable_init();\\n        __UUPSUpgradeable_init();\\n\\n        if (_dao == address(0)) revert DaoCannotBeZero();\\n\\n        SLOTS_PER_EPOCH = slotsPerEpoch.toUint64();\\n        SECONDS_PER_SLOT = secondsPerSlot.toUint64();\\n        GENESIS_TIME = genesisTime.toUint64();\\n\\n        dao = _dao;\\n        uint256 farFutureEpoch = _computeEpochAtTimestamp(type(uint64).max);\\n        _setFrameConfig(farFutureEpoch, epochsPerFrame, fastLaneLengthSlots, FrameConfig(0, 0, 0));\\n    }\\n\\n    // set dao address\\n    function setDaoAddress(address _dao) external override onlyOwner {\\n        if (_dao == address(0)) revert InvalidAddr();\\n        emit DaoAddressChanged(dao, _dao);\\n        dao = _dao;\\n    }\\n\\n    /// @notice Returns the immutable chain parameters required to calculate epoch and slot\\n    /// given a timestamp.\\n    ///\\n    function getChainConfig()\\n        external\\n        view\\n        returns (uint256 slotsPerEpoch, uint256 secondsPerSlot, uint256 genesisTime)\\n    {\\n        return (SLOTS_PER_EPOCH, SECONDS_PER_SLOT, GENESIS_TIME);\\n    }\\n\\n    /// @notice Returns the time-related configuration.\\n    ///\\n    /// @return initialEpoch Epoch of the frame with zero index.\\n    /// @return epochsPerFrame Length of a frame in epochs.\\n    /// @return fastLaneLengthSlots Length of the fast lane interval in slots; see `getIsFastLaneMember`.\\n    ///\\n    function getFrameConfig()\\n        external\\n        view\\n        returns (uint256 initialEpoch, uint256 epochsPerFrame, uint256 fastLaneLengthSlots)\\n    {\\n        FrameConfig memory config = _frameConfig;\\n        return (config.initialEpoch, config.epochsPerFrame, config.fastLaneLengthSlots);\\n    }\\n\\n    /// @notice Returns the current reporting frame.\\n    ///\\n    /// @return refSlot The frame's reference slot: if the data the consensus is being reached upon\\n    ///         includes or depends on any onchain state, this state should be queried at the\\n    ///         reference slot. If the slot contains a block, the state should include all changes\\n    ///         from that block.\\n    ///\\n    /// @return reportProcessingDeadlineSlot The last slot at which the report can be processed by\\n    ///         the report processor contract.\\n    ///\\n    function getCurrentFrame() external view returns (uint256 refSlot, uint256 reportProcessingDeadlineSlot) {\\n        ConsensusFrame memory frame = _getCurrentFrame();\\n        return (frame.refSlot, frame.reportProcessingDeadlineSlot);\\n    }\\n\\n    /// @notice Returns the earliest possible reference slot, i.e. the reference slot of the\\n    /// reporting frame with zero index.\\n    ///\\n    function getInitialRefSlot() external view returns (uint256) {\\n        return _getInitialFrame().refSlot;\\n    }\\n\\n    /// @notice Sets a new initial epoch given that the current initial epoch is in the future.\\n    ///\\n    /// @param initialEpoch The new initial epoch.\\n    ///\\n    function updateInitialEpoch(uint256 initialEpoch) external onlyDao {\\n        FrameConfig memory prevConfig = _frameConfig;\\n\\n        if (_computeEpochAtTimestamp(_getTime()) >= prevConfig.initialEpoch) {\\n            revert InitialEpochAlreadyArrived();\\n        }\\n\\n        _setFrameConfig(initialEpoch, prevConfig.epochsPerFrame, prevConfig.fastLaneLengthSlots, prevConfig);\\n    }\\n\\n    /// @notice Updates the time-related configuration.\\n    ///\\n    /// @param epochsPerFrame Length of a frame in epochs.\\n    /// @param fastLaneLengthSlots Length of the fast lane interval in slots; see `getIsFastLaneMember`.\\n    ///\\n    function setFrameConfig(uint256 epochsPerFrame, uint256 fastLaneLengthSlots) external onlyDao {\\n        // Updates epochsPerFrame in a way that either keeps the current reference slot the same\\n        // or increases it by at least the minimum of old and new frame sizes.\\n        uint256 timestamp = _getTime();\\n        uint256 currentFrameStartEpoch = _computeFrameStartEpoch(timestamp, _frameConfig);\\n        _setFrameConfig(currentFrameStartEpoch, epochsPerFrame, fastLaneLengthSlots, _frameConfig);\\n    }\\n\\n    ///\\n    /// Members\\n    ///\\n\\n    /// @notice Returns whether the given address is currently a member of the consensus.\\n    ///\\n    function getIsMember(address addr) external view returns (bool) {\\n        return _isMember(addr);\\n    }\\n\\n    /// @notice Returns whether the given address is a fast lane member for the current reporting\\n    /// frame.\\n    ///\\n    /// Fast lane members is a subset of all members that changes each reporting frame. These\\n    /// members can, and are expected to, submit a report during the first part of the frame called\\n    /// the \\\"fast lane interval\\\" and defined via `setFrameConfig` or `setFastLaneLengthSlots`. Under\\n    /// regular circumstances, all other members are only allowed to submit a report after the fast\\n    /// lane interval passes.\\n    ///\\n    /// The fast lane subset consists of `quorum` members; selection is implemented as a sliding\\n    /// window of the `quorum` width over member indices (mod total members). The window advances\\n    /// by one index each reporting frame.\\n    ///\\n    /// This is done to encourage each member from the full set to participate in reporting on a\\n    /// regular basis, and identify any malfunctioning members.\\n    ///\\n    /// With the fast lane mechanism active, it's sufficient for the monitoring to check that\\n    /// consensus is consistently reached during the fast lane part of each frame to conclude that\\n    /// all members are active and share the same consensus rules.\\n    ///\\n    /// However, there is no guarantee that, at any given time, it holds true that only the current\\n    /// fast lane members can or were able to report during the currently-configured fast lane\\n    /// interval of the current frame. In particular, this assumption can be violated in any frame\\n    /// during which the members set, initial epoch, or the quorum number was changed, or the fast\\n    /// lane interval length was increased. Thus, the fast lane mechanism should not be used for any\\n    /// purpose other than monitoring of the members liveness, and monitoring tools should take into\\n    /// consideration the potential irregularities within frames with any configuration changes.\\n    ///\\n    function getIsFastLaneMember(address addr) external view returns (bool) {\\n        uint256 index1b = _memberIndices1b[addr];\\n        unchecked {\\n            return index1b > 0 && _isFastLaneMember(index1b - 1, _getCurrentFrame().index);\\n        }\\n    }\\n\\n    /// @notice Returns all current members, together with the last reference slot each member\\n    /// submitted a report for.\\n    ///\\n    function getMembers() external view returns (address[] memory addresses, uint256[] memory lastReportedRefSlots) {\\n        return _getMembers(false);\\n    }\\n\\n    /// @notice Returns the subset of the oracle committee members (consisting of `quorum` items)\\n    /// that changes each frame.\\n    ///\\n    /// See `getIsFastLaneMember`.\\n    ///\\n    function getFastLaneMembers()\\n        external\\n        view\\n        returns (address[] memory addresses, uint256[] memory lastReportedRefSlots)\\n    {\\n        return _getMembers(true);\\n    }\\n\\n    /// @notice Sets the duration of the fast lane interval of the reporting frame.\\n    ///\\n    /// See `getIsFastLaneMember`.\\n    ///\\n    /// @param fastLaneLengthSlots The length of the fast lane reporting interval in slots. Setting\\n    ///        it to zero disables the fast lane subset, allowing any oracle to report starting from\\n    ///        the first slot of a frame and until the frame's reporting deadline.\\n    ///\\n    function setFastLaneLengthSlots(uint256 fastLaneLengthSlots) external onlyDao {\\n        _setFastLaneLengthSlots(fastLaneLengthSlots);\\n    }\\n\\n    function addMember(address addr, uint256 quorum) external onlyDao {\\n        _addMember(addr, quorum);\\n    }\\n\\n    function removeMember(address addr, uint256 quorum) external onlyDao {\\n        _removeMember(addr, quorum);\\n    }\\n\\n    function getQuorum() external view returns (uint256) {\\n        return _quorum;\\n    }\\n\\n    function setQuorum(uint256 quorum) external onlyDao {\\n        // access control is performed inside the next call\\n        _setQuorumAndCheckConsensus(quorum, _memberStates.length);\\n    }\\n\\n    /// @notice Disables the oracle by setting the quorum to an unreachable value.\\n    ///\\n    function disableConsensus() external onlyOwner {\\n        // access control is performed inside the next call\\n        _setQuorumAndCheckConsensus(UNREACHABLE_QUORUM, _memberStates.length);\\n    }\\n\\n    ///\\n    /// Report processor\\n    ///\\n\\n    // @notice Get all Oracle modules info\\n    function getReportProcessors() external view returns (ReportProcessor[] memory) {\\n        return reportProcessors;\\n    }\\n\\n    // @notice Whether it is a module of Oracle\\n    function getIsReportProcessor(address addr) public view returns (bool) {\\n        return reportIndices1b[addr] != 0;\\n    }\\n\\n    // @notice Get the module ID of Oracle\\n    function getReportModuleId(address reportProcessor) external view returns (uint256) {\\n        return reportIndices1b[reportProcessor];\\n    }\\n\\n    // @notice Add the Oracle module and set its reporting frequency\\n    // @param newProcessor oracle address\\n    // @param frameMultiple Reporting frequency. @see `isModuleReport`\\n    function addReportProcessor(address newProcessor, uint64 frameMultiple) public onlyDao {\\n        if (newProcessor == address(0)) revert ReportProcessorCannotBeZero();\\n        if (getIsReportProcessor(newProcessor)) revert DuplicateReportProcessor();\\n        if (frameMultiple == 0) revert FrameMultipleCannotBeZero();\\n\\n        reportProcessors.push(ReportProcessor({processor: newProcessor, frameMultiple: frameMultiple}));\\n        uint256 newTotalReportProcessors = reportProcessors.length;\\n        reportIndices1b[newProcessor] = newTotalReportProcessors;\\n\\n        emit ReportProcessorAdd(newProcessor, newTotalReportProcessors, frameMultiple);\\n    }\\n\\n    // @notice Update the contract address or reporting frequency of the Oracle module.\\n    function updateReportProcessor(address oldProcessor, address newProcessor, uint64 frameMultiple) external onlyDao {\\n        if (oldProcessor == address(0) || newProcessor == address(0)) revert ReportProcessorCannotBeZero();\\n        if (!getIsReportProcessor(oldProcessor)) revert ReportProcessorNotFound(oldProcessor);\\n\\n        uint256 oldIndex = reportIndices1b[oldProcessor] - 1;\\n        reportProcessors[oldIndex] = ReportProcessor({processor: newProcessor, frameMultiple: frameMultiple});\\n\\n        emit ReportProcessorUpdate(oldProcessor, newProcessor, oldIndex + 1, frameMultiple);\\n    }\\n\\n    // @notice Whether the Oracle module needs to report data in the current slot.\\n    // If false, there is no need to report the real data, and the consensus data is reported to 'ZERO_HASH'.\\n    function isModuleReport(uint256 moduleId, uint256 slot) public view returns (bool) {\\n        if (moduleId == 0) return false;\\n        uint256 refSlot = _getCurrentFrame().refSlot;\\n        if (slot < refSlot) return false;\\n        uint64 frameMultiple = reportProcessors[moduleId - 1].frameMultiple;\\n        if (\\n            ((slot + 1) - (_frameConfig.initialEpoch * SLOTS_PER_EPOCH))\\n                % (frameMultiple * _frameConfig.epochsPerFrame * SLOTS_PER_EPOCH) != 0\\n        ) {\\n            return false;\\n        }\\n        return true;\\n    }\\n\\n    // @notice Whether the Oracle module needs to report data.\\n    // @param moduleId Oracle module ID\\n    // @return isCurrentFrameReport Whether the oracle needs to report in the current frame?\\n    // @return frameMultiple Oracle's reporting frequency (frameMultiple * frame)\\n    // @return nextCanReportSlot The next slot that Oracle can escalate\\n    function moduleReportFrameMultiple(uint256 moduleId)\\n        public\\n        view\\n        returns (bool isCurrentFrameReport, uint64 frameMultiple, uint256 nextCanReportSlot)\\n    {\\n        if (moduleId == 0) revert InvalidModuleId();\\n        uint256 currentSlot = _getCurrentFrame().refSlot;\\n        isCurrentFrameReport = isModuleReport(moduleId, currentSlot);\\n        frameMultiple = reportProcessors[moduleId - 1].frameMultiple;\\n\\n        uint256 nextSlot = currentSlot;\\n        for (;;) {\\n            nextSlot += _frameConfig.epochsPerFrame * SLOTS_PER_EPOCH;\\n            if (isModuleReport(moduleId, nextSlot)) {\\n                nextCanReportSlot = nextSlot;\\n                break;\\n            }\\n        }\\n    }\\n\\n    ///\\n    /// Consensus\\n    ///\\n\\n    /// @notice Returns info about the current frame and consensus state in that frame.\\n    ///\\n    /// @return refSlot Reference slot of the current reporting frame.\\n    ///\\n    /// @return consensusReport Consensus report for the current frame, if any.\\n    ///         Zero bytes otherwise.\\n    function getConsensusState() external view returns (uint256 refSlot, bytes32[] memory consensusReport) {\\n        refSlot = _getCurrentFrame().refSlot;\\n        (consensusReport,,) = _getConsensusReport(refSlot, _quorum);\\n    }\\n\\n    /// @return isReportProcessing If consensus report for the current frame is already\\n    ///         being processed. Consensus can be changed before the processing starts.\\n    function getIsReportProcessing(address _reportProcessor) external view returns (bool) {\\n        return _getLastProcessingRefSlot(_reportProcessor) == _getCurrentFrame().refSlot;\\n    }\\n\\n    /// @notice Returns report variants and their support for the current reference slot.\\n    ///\\n    function getReportVariants() external view returns (bytes32[][] memory variants, uint256[] memory support) {\\n        if (reportingState.lastReportRefSlot != _getCurrentFrame().refSlot) {\\n            return (variants, support);\\n        }\\n\\n        uint256 variantsLength = _reportVariantsLength;\\n        variants = new bytes32[][](variantsLength);\\n        support = new uint256[](variantsLength);\\n\\n        for (uint256 i = 0; i < variantsLength; ++i) {\\n            ReportVariant memory variant = _reportVariants[i];\\n            variants[i] = variant.hashArr;\\n            support[i] = variant.support;\\n        }\\n    }\\n\\n    struct MemberConsensusState {\\n        /// @notice Current frame's reference slot.\\n        uint256 currentFrameRefSlot;\\n        /// @notice Consensus report for the current frame, if any. Zero bytes otherwise.\\n        bytes32[] currentFrameConsensusReport;\\n        /// @notice Whether the provided address is a member of the oracle committee.\\n        bool isMember;\\n        /// @notice Whether the oracle committee member is in the fast lane members subset\\n        /// of the current reporting frame. See `getIsFastLaneMember`.\\n        bool isFastLane;\\n        /// @notice Whether the oracle committee member is allowed to submit a report at\\n        /// the moment of the call.\\n        bool canReport;\\n        /// @notice The last reference slot for which the member submitted a report.\\n        uint256 lastMemberReportRefSlot;\\n        /// @notice The hash reported by the member for the current frame, if any.\\n        /// Zero bytes otherwise.\\n        bytes32[] currentFrameMemberReport;\\n    }\\n\\n    /// @notice Returns the extended information related to an oracle committee member with the\\n    /// given address and the current consensus state. Provides all the information needed for\\n    /// an oracle daemon to decide if it needs to submit a report.\\n    ///\\n    /// @param addr The member address.\\n    /// @return result See the docs for `MemberConsensusState`.\\n    ///\\n    function getConsensusStateForMember(address addr) external view returns (MemberConsensusState memory result) {\\n        ConsensusFrame memory frame = _getCurrentFrame();\\n        result.currentFrameRefSlot = frame.refSlot;\\n        (result.currentFrameConsensusReport,,) = _getConsensusReport(frame.refSlot, _quorum);\\n\\n        uint256 index = _memberIndices1b[addr];\\n        result.isMember = index != 0;\\n\\n        if (index != 0) {\\n            unchecked {\\n                --index;\\n            } // convert to 0-based\\n            MemberState memory memberState = _memberStates[index];\\n\\n            result.lastMemberReportRefSlot = memberState.lastReportRefSlot;\\n            if (result.lastMemberReportRefSlot == frame.refSlot) {\\n                result.currentFrameMemberReport = _reportVariants[memberState.lastReportVariantIndex].hashArr;\\n            }\\n\\n            uint256 slot = _computeSlotAtTimestamp(_getTime());\\n\\n            result.canReport = slot <= frame.reportProcessingDeadlineSlot;\\n\\n            result.isFastLane = _isFastLaneMember(index, frame.index);\\n\\n            if (!result.isFastLane && result.canReport) {\\n                result.canReport = slot > frame.refSlot + _frameConfig.fastLaneLengthSlots;\\n            }\\n        }\\n    }\\n\\n    /// @notice Used by oracle members to submit hash of the data calculated for the given\\n    /// reference slot.\\n    ///\\n    /// @param slot The reference slot the data was calculated for. Reverts if doesn't match\\n    ///        the current reference slot.\\n    ///\\n    /// @param report Hash of the data calculated for the given reference slot.\\n    function submitReport(uint256 slot, bytes32[] calldata report) external {\\n        _submitReport(slot, report);\\n    }\\n\\n    ///\\n    /// Implementation: time\\n    ///\\n\\n    function _setFrameConfig(\\n        uint256 initialEpoch,\\n        uint256 epochsPerFrame,\\n        uint256 fastLaneLengthSlots,\\n        FrameConfig memory prevConfig\\n    ) internal {\\n        if (epochsPerFrame == 0) revert EpochsPerFrameCannotBeZero();\\n\\n        if (fastLaneLengthSlots > epochsPerFrame * SLOTS_PER_EPOCH) {\\n            revert FastLanePeriodCannotBeLongerThanFrame();\\n        }\\n\\n        _frameConfig = FrameConfig(initialEpoch.toUint64(), epochsPerFrame.toUint64(), fastLaneLengthSlots.toUint64());\\n\\n        if (initialEpoch != prevConfig.initialEpoch || epochsPerFrame != prevConfig.epochsPerFrame) {\\n            emit FrameConfigSet(initialEpoch, epochsPerFrame);\\n        }\\n\\n        if (fastLaneLengthSlots != prevConfig.fastLaneLengthSlots) {\\n            emit FastLaneConfigSet(fastLaneLengthSlots);\\n        }\\n    }\\n\\n    function _getCurrentFrame() internal view returns (ConsensusFrame memory) {\\n        return _getCurrentFrame(_frameConfig);\\n    }\\n\\n    function _getCurrentFrame(FrameConfig memory config) internal view returns (ConsensusFrame memory) {\\n        return _getFrameAtTimestamp(_getTime(), config);\\n    }\\n\\n    function _getInitialFrame() internal view returns (ConsensusFrame memory) {\\n        return _getFrameAtIndex(0, _frameConfig);\\n    }\\n\\n    function _getFrameAtTimestamp(uint256 timestamp, FrameConfig memory config)\\n        internal\\n        view\\n        returns (ConsensusFrame memory)\\n    {\\n        return _getFrameAtIndex(_computeFrameIndex(timestamp, config), config);\\n    }\\n\\n    function _getFrameAtIndex(uint256 frameIndex, FrameConfig memory config)\\n        internal\\n        view\\n        returns (ConsensusFrame memory)\\n    {\\n        uint256 frameStartEpoch = _computeStartEpochOfFrameWithIndex(frameIndex, config);\\n        uint256 frameStartSlot = _computeStartSlotAtEpoch(frameStartEpoch);\\n        uint256 nextFrameStartSlot = frameStartSlot + config.epochsPerFrame * SLOTS_PER_EPOCH;\\n\\n        return ConsensusFrame({\\n            index: frameIndex,\\n            refSlot: uint64(frameStartSlot - 1),\\n            reportProcessingDeadlineSlot: uint64(nextFrameStartSlot - 1)\\n        });\\n    }\\n\\n    function _computeFrameStartEpoch(uint256 timestamp, FrameConfig memory config) internal view returns (uint256) {\\n        return _computeStartEpochOfFrameWithIndex(_computeFrameIndex(timestamp, config), config);\\n    }\\n\\n    function _computeStartEpochOfFrameWithIndex(uint256 frameIndex, FrameConfig memory config)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return config.initialEpoch + frameIndex * config.epochsPerFrame;\\n    }\\n\\n    function _computeFrameIndex(uint256 timestamp, FrameConfig memory config) internal view returns (uint256) {\\n        uint256 epoch = _computeEpochAtTimestamp(timestamp);\\n        if (epoch < config.initialEpoch) {\\n            revert InitialEpochIsYetToArrive();\\n        }\\n        return (epoch - config.initialEpoch) / config.epochsPerFrame;\\n    }\\n\\n    function _computeTimestampAtSlot(uint256 slot) internal view returns (uint256) {\\n        // See: github.com/ethereum/consensus-specs/blob/dev/specs/bellatrix/beacon-chain.md#compute_timestamp_at_slot\\n        return GENESIS_TIME + slot * SECONDS_PER_SLOT;\\n    }\\n\\n    function _computeSlotAtTimestamp(uint256 timestamp) internal view returns (uint256) {\\n        return (timestamp - GENESIS_TIME) / SECONDS_PER_SLOT;\\n    }\\n\\n    function _computeEpochAtSlot(uint256 slot) internal view returns (uint256) {\\n        // See: github.com/ethereum/consensus-specs/blob/dev/specs/phase0/beacon-chain.md#compute_epoch_at_slot\\n        return slot / SLOTS_PER_EPOCH;\\n    }\\n\\n    function _computeEpochAtTimestamp(uint256 timestamp) internal view returns (uint256) {\\n        return _computeEpochAtSlot(_computeSlotAtTimestamp(timestamp));\\n    }\\n\\n    function _computeStartSlotAtEpoch(uint256 epoch) internal view returns (uint256) {\\n        // See: github.com/ethereum/consensus-specs/blob/dev/specs/phase0/beacon-chain.md#compute_start_slot_at_epoch\\n        return epoch * SLOTS_PER_EPOCH;\\n    }\\n\\n    function _getTime() internal view virtual returns (uint256) {\\n        return block.timestamp; // solhint-disable-line not-rely-on-time\\n    }\\n\\n    ///\\n    /// Implementation: members\\n    ///\\n\\n    function _isMember(address addr) internal view returns (bool) {\\n        return _memberIndices1b[addr] != 0;\\n    }\\n\\n    function _getMemberIndex(address addr) internal view returns (uint256) {\\n        uint256 index1b = _memberIndices1b[addr];\\n        if (index1b == 0) {\\n            revert NonMember();\\n        }\\n        unchecked {\\n            return uint256(index1b - 1);\\n        }\\n    }\\n\\n    function _addMember(address addr, uint256 quorum) internal {\\n        if (_isMember(addr)) revert DuplicateMember();\\n        if (addr == address(0)) revert AddressCannotBeZero();\\n\\n        _memberStates.push(MemberState(0, 0));\\n        _memberAddresses.push(addr);\\n\\n        uint256 newTotalMembers = _memberStates.length;\\n        _memberIndices1b[addr] = newTotalMembers;\\n\\n        emit MemberAdded(addr, newTotalMembers, quorum);\\n\\n        _setQuorumAndCheckConsensus(quorum, newTotalMembers);\\n    }\\n\\n    function _removeMember(address addr, uint256 quorum) internal {\\n        uint256 index = _getMemberIndex(addr);\\n        uint256 newTotalMembers = _memberStates.length - 1;\\n\\n        assert(index <= newTotalMembers);\\n\\n        if (index != newTotalMembers) {\\n            address addrToMove = _memberAddresses[newTotalMembers];\\n            _memberAddresses[index] = addrToMove;\\n            _memberStates[index] = _memberStates[newTotalMembers];\\n            _memberIndices1b[addrToMove] = index + 1;\\n        }\\n\\n        _memberStates.pop();\\n        _memberAddresses.pop();\\n        _memberIndices1b[addr] = 0;\\n\\n        emit MemberRemoved(addr, newTotalMembers, quorum);\\n\\n        _setQuorumAndCheckConsensus(quorum, newTotalMembers);\\n    }\\n\\n    function _setFastLaneLengthSlots(uint256 fastLaneLengthSlots) internal {\\n        FrameConfig memory frameConfig = _frameConfig;\\n        if (fastLaneLengthSlots > frameConfig.epochsPerFrame * SLOTS_PER_EPOCH) {\\n            revert FastLanePeriodCannotBeLongerThanFrame();\\n        }\\n        if (fastLaneLengthSlots != frameConfig.fastLaneLengthSlots) {\\n            _frameConfig.fastLaneLengthSlots = fastLaneLengthSlots.toUint64();\\n            emit FastLaneConfigSet(fastLaneLengthSlots);\\n        }\\n    }\\n\\n    /// @dev Returns start and past-end incides (mod totalMembers) of the fast lane members subset.\\n    ///\\n    function _getFastLaneSubset(uint256 frameIndex, uint256 totalMembers)\\n        internal\\n        view\\n        returns (uint256 startIndex, uint256 pastEndIndex)\\n    {\\n        if (totalMembers != 0) {\\n            startIndex = frameIndex % totalMembers;\\n            pastEndIndex = startIndex + _quorum;\\n        }\\n    }\\n\\n    /// @dev Tests whether the member with the given `index` is in the fast lane subset for the\\n    /// given reporting `frameIndex`.\\n    ///\\n    function _isFastLaneMember(uint256 index, uint256 frameIndex) internal view returns (bool) {\\n        uint256 totalMembers = _memberStates.length;\\n        (uint256 flLeft, uint256 flPastRight) = _getFastLaneSubset(frameIndex, totalMembers);\\n        unchecked {\\n            return\\n                (flPastRight != 0 && MathUtil.pointInClosedIntervalModN(index, flLeft, flPastRight - 1, totalMembers));\\n        }\\n    }\\n\\n    function _getMembers(bool fastLane)\\n        internal\\n        view\\n        returns (address[] memory addresses, uint256[] memory lastReportedRefSlots)\\n    {\\n        uint256 totalMembers = _memberStates.length;\\n        uint256 left;\\n        uint256 right;\\n\\n        if (fastLane) {\\n            (left, right) = _getFastLaneSubset(_getCurrentFrame().index, totalMembers);\\n        } else {\\n            right = totalMembers;\\n        }\\n\\n        addresses = new address[](right - left);\\n        lastReportedRefSlots = new uint256[](addresses.length);\\n\\n        for (uint256 i = left; i < right; ++i) {\\n            uint256 iModTotal = i % totalMembers;\\n            MemberState memory memberState = _memberStates[iModTotal];\\n            uint256 k = i - left;\\n            addresses[k] = _memberAddresses[iModTotal];\\n            lastReportedRefSlots[k] = memberState.lastReportRefSlot;\\n        }\\n    }\\n\\n    ///\\n    /// Implementation: consensus\\n    ///\\n    function _submitReport(uint256 slot, bytes32[] calldata report) internal {\\n        if (slot > type(uint64).max) revert NumericOverflow();\\n\\n        uint256 memberIndex = _getMemberIndex(_msgSender());\\n        MemberState memory memberState = _memberStates[memberIndex];\\n\\n        uint256 timestamp = _getTime();\\n        uint256 currentSlot = _computeSlotAtTimestamp(timestamp);\\n        FrameConfig memory config = _frameConfig;\\n        ConsensusFrame memory frame = _getFrameAtTimestamp(timestamp, config);\\n\\n        if (report.length == 0) revert EmptyReport();\\n        if (report.length != reportProcessors.length) revert ReportLenNotEqualReportProcessorsLen();\\n        if (slot != frame.refSlot) revert InvalidSlot();\\n        if (currentSlot > frame.reportProcessingDeadlineSlot) revert StaleReport();\\n\\n        if (currentSlot <= frame.refSlot + config.fastLaneLengthSlots && !_isFastLaneMember(memberIndex, frame.index)) {\\n            revert NonFastLaneMemberCannotReportWithinFastLaneInterval();\\n        }\\n\\n        _checkFrameMultiple(slot, report);\\n\\n        uint256 variantsLength;\\n\\n        if (reportingState.lastReportRefSlot != slot) {\\n            // first report for a new slot => clear report variants\\n            reportingState.lastReportRefSlot = uint64(slot);\\n            variantsLength = 0;\\n        } else {\\n            variantsLength = _reportVariantsLength;\\n        }\\n\\n        uint64 varIndex = 0;\\n        uint64 support;\\n\\n        while (varIndex < variantsLength && !Array.compareBytes32Arrays(_reportVariants[varIndex].hashArr, report)) {\\n            ++varIndex;\\n        }\\n\\n        if (slot == memberState.lastReportRefSlot) {\\n            uint64 prevVarIndex = memberState.lastReportVariantIndex;\\n            assert(prevVarIndex < variantsLength);\\n            if (varIndex == prevVarIndex) {\\n                revert DuplicateReport();\\n            } else {\\n                --_reportVariants[prevVarIndex].support;\\n            }\\n        }\\n\\n        if (varIndex < variantsLength) {\\n            support = ++_reportVariants[varIndex].support;\\n        } else {\\n            support = 1;\\n            _reportVariants[varIndex] = ReportVariant({hashArr: report, support: 1});\\n            _reportVariantsLength = ++variantsLength;\\n        }\\n\\n        _memberStates[memberIndex] = MemberState({lastReportRefSlot: uint64(slot), lastReportVariantIndex: varIndex});\\n\\n        if (support >= _quorum) {\\n            _consensusReached(frame, report, varIndex, support);\\n        } else {\\n            emit ConsensusReportReceived(slot, _msgSender(), report, false, support);\\n        }\\n    }\\n\\n    function _checkFrameMultiple(uint256 slot, bytes32[] calldata report) internal {\\n        for (uint256 i = 0; i < report.length; ++i) {\\n            uint64 frameMultiple = reportProcessors[i].frameMultiple;\\n            if (frameMultiple > 1) {\\n                if (\\n                    ((slot + 1) - (_frameConfig.initialEpoch * SLOTS_PER_EPOCH))\\n                        % (frameMultiple * _frameConfig.epochsPerFrame * SLOTS_PER_EPOCH) != 0 && report[i] != ZERO_HASH\\n                ) {\\n                    revert OracleIndexReportShouldZeroHash(slot, report, i + 1, frameMultiple);\\n                }\\n            }\\n        }\\n    }\\n\\n    function _consensusReached(\\n        ConsensusFrame memory frame,\\n        bytes32[] memory report,\\n        uint256 variantIndex,\\n        uint256 support\\n    ) internal {\\n        if (\\n            reportingState.lastConsensusRefSlot != frame.refSlot\\n                || reportingState.lastConsensusVariantIndex != variantIndex\\n        ) {\\n            reportingState.lastConsensusRefSlot = uint64(frame.refSlot);\\n            reportingState.lastConsensusVariantIndex = uint64(variantIndex);\\n\\n            _submitReportForProcessing(frame, report);\\n\\n            emit ConsensusReportReceived(frame.refSlot, _msgSender(), report, true, support);\\n        }\\n    }\\n\\n    function _setQuorumAndCheckConsensus(uint256 quorum, uint256 totalMembers) internal {\\n        if (quorum <= totalMembers / 2) {\\n            revert QuorumTooSmall(totalMembers / 2 + 1, quorum);\\n        }\\n\\n        // we're explicitly allowing quorum values greater than the number of members to\\n        // allow effectively disabling the oracle in case something unpredictable happens\\n\\n        uint256 prevQuorum = _quorum;\\n        if (quorum != prevQuorum) {\\n            _quorum = quorum;\\n            emit QuorumSet(quorum, totalMembers, prevQuorum);\\n        }\\n\\n        if (quorum < prevQuorum) {\\n            // consensus can only change as the result of the quorum being decreased\\n            _checkConsensus(quorum);\\n        }\\n    }\\n\\n    function _checkConsensus(uint256 quorum) internal {\\n        uint256 timestamp = _getTime();\\n        ConsensusFrame memory frame = _getFrameAtTimestamp(timestamp, _frameConfig);\\n\\n        if (_computeSlotAtTimestamp(timestamp) > frame.reportProcessingDeadlineSlot) {\\n            // reference slot is not reportable anymore\\n            return;\\n        }\\n\\n        (bytes32[] memory consensusReport, int256 consensusVariantIndex, uint256 support) =\\n            _getConsensusReport(frame.refSlot, quorum);\\n\\n        if (consensusVariantIndex >= 0) {\\n            _consensusReached(frame, consensusReport, uint256(consensusVariantIndex), support);\\n        }\\n    }\\n\\n    function _getConsensusReport(uint256 currentRefSlot, uint256 quorum)\\n        internal\\n        view\\n        returns (bytes32[] memory report, int256 variantIndex, uint256 support)\\n    {\\n        if (reportingState.lastReportRefSlot != currentRefSlot) {\\n            // there were no reports for the current ref. slot\\n            return (report, -1, 0);\\n        }\\n\\n        uint256 variantsLength = _reportVariantsLength;\\n        variantIndex = -1;\\n        support = 0;\\n\\n        for (uint256 i = 0; i < variantsLength && report.length == 0; ++i) {\\n            uint256 iSupport = _reportVariants[i].support;\\n            if (iSupport >= quorum) {\\n                variantIndex = int256(i);\\n                report = _reportVariants[i].hashArr;\\n                support = iSupport;\\n            }\\n        }\\n\\n        return (report, variantIndex, support);\\n    }\\n\\n    function _submitReportForProcessing(ConsensusFrame memory frame, bytes32[] memory report) internal {\\n        for (uint256 i = 0; i < reportProcessors.length; ++i) {\\n            IReportAsyncProcessor(reportProcessors[i].processor).submitConsensusReport(\\n                report[i], frame.refSlot, _computeTimestampAtSlot(frame.reportProcessingDeadlineSlot), i + 1\\n            );\\n        }\\n    }\\n\\n    function _getLastProcessingRefSlot(address _reportProcessor) internal view returns (uint256) {\\n        return IReportAsyncProcessor(_reportProcessor).getLastProcessingRefSlot();\\n    }\\n\\n    function _getConsensusVersion(address _reportProcessor) internal view returns (uint256) {\\n        return IReportAsyncProcessor(_reportProcessor).getConsensusVersion();\\n    }\\n\\n    function _authorizeUpgrade(address) internal override onlyOwner {}\\n}\\n\"\r\n    },\r\n    \"src/utils/Array.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.8;\\n\\nlibrary Array {\\n    // @notice compareBytes32Arrays gas < compareBytes32ArraysByLoop gas\\n    // ----------------------------------------------------------------\\n    // gas test\\n    // arrCount   compareBytes32Arrays    compareBytes32ArraysByLoop\\n    // 10         4777                    4986\\n    // 100        34619                   40438\\n    // 1000       360883                  401922\\n    function compareBytes32Arrays(bytes32[] memory arr1, bytes32[] memory arr2) public pure returns (bool) {\\n        if (arr1.length != arr2.length) {\\n            return false;\\n        }\\n\\n        bytes32 hash1 = keccak256(abi.encodePacked(arr1));\\n        bytes32 hash2 = keccak256(abi.encodePacked(arr2));\\n\\n        return hash1 == hash2;\\n    }\\n\\n    function compareBytes32ArraysByLoop(bytes32[] memory arr1, bytes32[] memory arr2) public pure returns (bool) {\\n        if (arr1.length != arr2.length) {\\n            return false;\\n        }\\n\\n        for (uint256 i = 0; i < arr1.length; i++) {\\n            if (arr1[i] != arr2[i]) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/utils/Dao.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.8;\\n\\nabstract contract Dao {\\n    event DaoAddressChanged(address _oldDao, address _dao);\\n\\n    error DaoCannotBeZero();\\n\\n    // dao address\\n    address public dao;\\n\\n    constructor() {}\\n\\n    modifier onlyDao() {\\n        require(msg.sender == dao, \\\"PERMISSION_DENIED\\\");\\n        _;\\n    }\\n\\n    // set dao vault address\\n    // You need to implement contracts to do that\\n    function setDaoAddress(address _dao) external virtual;\\n}\\n\"\r\n    },\r\n    \"src/utils/Versioned.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.8;\\n\\ncontract Versioned {\\n    event ContractVersionSet(uint256 version);\\n\\n    error NonZeroContractVersionOnInit();\\n    error InvalidContractVersionIncrement();\\n    error UnexpectedContractVersion(uint256 expected, uint256 received);\\n\\n    uint256 internal contractVersion;\\n\\n    //    uint256 internal constant PETRIFIED_VERSION_MARK = type(uint256).max;\\n\\n    constructor() {\\n        // lock version in the implementation's storage to prevent initialization\\n        contractVersion = 0;\\n    }\\n\\n    /// @notice Returns the current contract version.\\n    function getContractVersion() public view returns (uint256) {\\n        return contractVersion;\\n    }\\n\\n    function _checkContractVersion(uint256 version) internal view {\\n        uint256 expectedVersion = getContractVersion();\\n        if (version != expectedVersion) {\\n            revert UnexpectedContractVersion(expectedVersion, version);\\n        }\\n    }\\n\\n    /// @dev Sets the contract version to N. Should be called from the initialize() function.\\n    function _initializeContractVersionTo(uint256 version) internal {\\n        if (getContractVersion() != 0) revert NonZeroContractVersionOnInit();\\n        _setContractVersion(version);\\n    }\\n\\n    /// @dev Updates the contract version. Should be called from a finalizeUpgrade_vN() function.\\n    function _updateContractVersion(uint256 newVersion) internal {\\n        if (newVersion != getContractVersion() + 1) revert InvalidContractVersionIncrement();\\n        _setContractVersion(newVersion);\\n    }\\n\\n    function _setContractVersion(uint256 version) private {\\n        contractVersion = version;\\n        emit ContractVersionSet(version);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ERC721A-Upgradeable/=lib/ERC721A-Upgradeable/contracts/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/contracts/\",\r\n      \"openzeppelin-upgrades/=lib/openzeppelin-upgrades/\",\r\n      \"solmate/=lib/solmate/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"name\":\"AddressCannotBeSame\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AddressCannotBeZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DaoCannotBeZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ExitLimitNotZero\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"initialRefSlot\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"processingRefSlot\",\"type\":\"uint256\"}],\"name\":\"InitialRefSlotCannotBeLessThanProcessingOne\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidAddr\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidContractVersionIncrement\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ModuleIdIsZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ModuleIdNotEqual\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NonZeroContractVersionOnInit\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyConsensusContractCanSubmitReport\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OverExitLimit\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PermissionDenied\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"ProcessingDeadlineMissed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RefSlotAlreadyProcessing\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"refSlot\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"prevRefSlot\",\"type\":\"uint256\"}],\"name\":\"RefSlotCannotDecrease\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"refSlot\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"processingRefSlot\",\"type\":\"uint256\"}],\"name\":\"RefSlotMustBeGreaterThanProcessingOne\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ReportDataIsEmpty\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SenderNotAllowed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnexpectedChainConfig\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"expectedVersion\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"receivedVersion\",\"type\":\"uint256\"}],\"name\":\"UnexpectedConsensusVersion\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"expected\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"received\",\"type\":\"uint256\"}],\"name\":\"UnexpectedContractVersion\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"consensusHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"receivedHash\",\"type\":\"bytes32\"}],\"name\":\"UnexpectedDataHash\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"consensusRefSlot\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dataRefSlot\",\"type\":\"uint256\"}],\"name\":\"UnexpectedRefSlot\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"VersionCannotBeSame\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"AdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"beacon\",\"type\":\"address\"}],\"name\":\"BeaconUpgraded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"prevAddr\",\"type\":\"address\"}],\"name\":\"ConsensusHashContractSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"version\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"prevVersion\",\"type\":\"uint256\"}],\"name\":\"ConsensusVersionSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"version\",\"type\":\"uint256\"}],\"name\":\"ContractVersionSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_oldDao\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_dao\",\"type\":\"address\"}],\"name\":\"DaoAddressChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldLargeStake\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newLargeStake\",\"type\":\"address\"}],\"name\":\"LargeStakeContractChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"refSlot\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"consensusVersion\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint128\",\"name\":\"stakingId\",\"type\":\"uint128\"},{\"internalType\":\"bytes[]\",\"name\":\"pubkeys\",\"type\":\"bytes[]\"}],\"indexed\":false,\"internalType\":\"struct CLStakingExitInfo[]\",\"name\":\"cLStakingExitInfos\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint128\",\"name\":\"stakingId\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"slashAmount\",\"type\":\"uint128\"},{\"internalType\":\"bytes\",\"name\":\"pubkey\",\"type\":\"bytes\"}],\"indexed\":false,\"internalType\":\"struct CLStakingSlashInfo[]\",\"name\":\"cLStakingSlashInfos\",\"type\":\"tuple[]\"}],\"name\":\"ReportSuccess\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldExitLimit\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newExitLimit\",\"type\":\"uint256\"}],\"name\":\"UpdateExitLimit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"Upgraded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"refSlot\",\"type\":\"uint256\"}],\"name\":\"WarnProcessingMissed\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"GENESIS_TIME\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SECONDS_PER_SLOT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dao\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exitLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getConsensusContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getConsensusReport\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"refSlot\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"processingDeadlineTime\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"processingStarted\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getConsensusVersion\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getContractVersion\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLastProcessingRefSlot\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getProcessingState\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"currentFrameRefSlot\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"processingDeadlineTime\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"},{\"internalType\":\"bool\",\"name\":\"dataSubmitted\",\"type\":\"bool\"}],\"internalType\":\"struct LargeStakeOracle.ProcessingState\",\"name\":\"result\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"secondsPerSlot\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"genesisTime\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"consensusContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"consensusVersion\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastProcessingRefSlot\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_dao\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_largeStakeContract\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"largeStakeContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proxiableUUID\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setConsensusContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"version\",\"type\":\"uint256\"}],\"name\":\"setConsensusVersion\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_dao\",\"type\":\"address\"}],\"name\":\"setDaoAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_exitLimit\",\"type\":\"uint256\"}],\"name\":\"setExitLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_largeStakeContractAddress\",\"type\":\"address\"}],\"name\":\"setLargeStakeContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"reportHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"refSlot\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_moduleId\",\"type\":\"uint256\"}],\"name\":\"submitConsensusReport\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"consensusVersion\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"refSlot\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint128\",\"name\":\"stakingId\",\"type\":\"uint128\"},{\"internalType\":\"bytes[]\",\"name\":\"pubkeys\",\"type\":\"bytes[]\"}],\"internalType\":\"struct CLStakingExitInfo[]\",\"name\":\"clStakingExitInfos\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint128\",\"name\":\"stakingId\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"slashAmount\",\"type\":\"uint128\"},{\"internalType\":\"bytes\",\"name\":\"pubkey\",\"type\":\"bytes\"}],\"internalType\":\"struct CLStakingSlashInfo[]\",\"name\":\"clStakingSlashInfos\",\"type\":\"tuple[]\"}],\"internalType\":\"struct LargeStakeOracle.ReportData\",\"name\":\"data\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"_contractVersion\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_moduleId\",\"type\":\"uint256\"}],\"name\":\"submitReportData\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"version\",\"type\":\"uint256\"}],\"name\":\"updateContractVersion\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"}],\"name\":\"upgradeTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"upgradeToAndCall\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}]", "ContractName": "LargeStakeOracle", "CompilerVersion": "v0.8.8+commit.dddeac2f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "london", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}