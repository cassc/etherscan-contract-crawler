{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"AllowedRecipientsFactory.sol\": {\r\n      \"content\": \"// SPDX-FileCopyrightText: 2022 Lido <info@lido.fi>\\n// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity ^0.8.4;\\n\\nimport \\\"AddAllowedRecipient.sol\\\";\\nimport \\\"RemoveAllowedRecipient.sol\\\";\\nimport \\\"TopUpAllowedRecipients.sol\\\";\\nimport \\\"AllowedRecipientsRegistry.sol\\\";\\nimport \\\"AllowedTokensRegistry.sol\\\";\\n\\n/// @author bulbozaur\\n/// @notice Factory for Allowed Recipient Easy Track contracts\\ncontract AllowedRecipientsFactory {\\n    event AllowedRecipientsRegistryDeployed(\\n        address indexed creator,\\n        address indexed allowedRecipientsRegistry,\\n        address _defaultAdmin,\\n        address[] addRecipientToAllowedListRoleHolders,\\n        address[] removeRecipientFromAllowedListRoleHolders,\\n        address[] setLimitParametersRoleHolders,\\n        address[] updateSpentAmountRoleHolders,\\n        IBokkyPooBahsDateTimeContract bokkyPooBahsDateTimeContract\\n    );\\n\\n    event AllowedTokensRegistryDeployed(\\n        address indexed creator,\\n        address indexed allowedTokensRegistry,\\n        address _defaultAdmin,\\n        address[] addTokenToAllowedListRoleHolders,\\n        address[] removeTokenFromAllowedListRoleHolders\\n    );\\n\\n    event TopUpAllowedRecipientsDeployed(\\n        address indexed creator,\\n        address indexed topUpAllowedRecipients,\\n        address trustedCaller,\\n        address allowedRecipientsRegistry,\\n        address allowedTokenssRegistry,\\n        address finance,\\n        address easyTrack\\n    );\\n\\n    event AddAllowedRecipientDeployed(\\n        address indexed creator,\\n        address indexed addAllowedRecipient,\\n        address trustedCaller,\\n        address allowedRecipientsRegistry\\n    );\\n\\n    event RemoveAllowedRecipientDeployed(\\n        address indexed creator,\\n        address indexed removeAllowedRecipient,\\n        address trustedCaller,\\n        address allowedRecipientsRegistry\\n    );\\n\\n    function deployAllowedRecipientsRegistry(\\n        address _defaultAdmin,\\n        address[] calldata _addRecipientToAllowedListRoleHolders,\\n        address[] calldata _removeRecipientFromAllowedListRoleHolders,\\n        address[] calldata _setLimitParametersRoleHolders,\\n        address[] calldata _updateSpentAmountRoleHolders,\\n        IBokkyPooBahsDateTimeContract _bokkyPooBahsDateTimeContract\\n    ) external returns (AllowedRecipientsRegistry registry) {\\n        registry = new AllowedRecipientsRegistry(\\n            _defaultAdmin,\\n            _addRecipientToAllowedListRoleHolders,\\n            _removeRecipientFromAllowedListRoleHolders,\\n            _setLimitParametersRoleHolders,\\n            _updateSpentAmountRoleHolders,\\n            _bokkyPooBahsDateTimeContract\\n        );\\n\\n        emit AllowedRecipientsRegistryDeployed(\\n            msg.sender,\\n            address(registry),\\n            _defaultAdmin,\\n            _addRecipientToAllowedListRoleHolders,\\n            _removeRecipientFromAllowedListRoleHolders,\\n            _setLimitParametersRoleHolders,\\n            _updateSpentAmountRoleHolders,\\n            _bokkyPooBahsDateTimeContract\\n        );\\n    }\\n\\n    function deployAllowedTokensRegistry(\\n        address _defaultAdmin,\\n        address[] calldata _addTokensToAllowedListRoleHolders,\\n        address[] calldata _removeTokensFromAllowedListRoleHolders\\n    ) external returns (AllowedTokensRegistry registry) {\\n        registry = new AllowedTokensRegistry(\\n            _defaultAdmin,\\n            _addTokensToAllowedListRoleHolders,\\n            _removeTokensFromAllowedListRoleHolders\\n        );\\n\\n        emit AllowedTokensRegistryDeployed(\\n            msg.sender,\\n            address(registry),\\n            _defaultAdmin,\\n            _addTokensToAllowedListRoleHolders,\\n            _removeTokensFromAllowedListRoleHolders\\n        );\\n    }\\n\\n    function deployTopUpAllowedRecipients(\\n        address _trustedCaller,\\n        address _allowedRecipientsRegistry,\\n        address _allowedTokensRegistry,\\n        address _finance,\\n        address _easyTrack\\n    ) external returns (TopUpAllowedRecipients topUpAllowedRecipients) {\\n        topUpAllowedRecipients = new TopUpAllowedRecipients(\\n            _trustedCaller,\\n            _allowedRecipientsRegistry,\\n            _allowedTokensRegistry,\\n            _finance,\\n            _easyTrack\\n        );\\n\\n        emit TopUpAllowedRecipientsDeployed(\\n            msg.sender,\\n            address(topUpAllowedRecipients),\\n            _trustedCaller,\\n            _allowedRecipientsRegistry,\\n            _allowedTokensRegistry,\\n            _finance,\\n            _easyTrack\\n        );\\n\\n        return topUpAllowedRecipients;\\n    }\\n\\n    function deployAddAllowedRecipient(address _trustedCaller, address _allowedRecipientsRegistry)\\n        external\\n        returns (AddAllowedRecipient addAllowedRecipient)\\n    {\\n        addAllowedRecipient = new AddAllowedRecipient(_trustedCaller, _allowedRecipientsRegistry);\\n\\n        emit AddAllowedRecipientDeployed(\\n            msg.sender,\\n            address(addAllowedRecipient),\\n            _trustedCaller,\\n            _allowedRecipientsRegistry\\n        );\\n    }\\n\\n    function deployRemoveAllowedRecipient(\\n        address _trustedCaller,\\n        address _allowedRecipientsRegistry\\n    ) external returns (RemoveAllowedRecipient removeAllowedRecipient) {\\n        removeAllowedRecipient = new RemoveAllowedRecipient(\\n            _trustedCaller,\\n            _allowedRecipientsRegistry\\n        );\\n\\n        emit RemoveAllowedRecipientDeployed(\\n            msg.sender,\\n            address(removeAllowedRecipient),\\n            _trustedCaller,\\n            _allowedRecipientsRegistry\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"AddAllowedRecipient.sol\": {\r\n      \"content\": \"// SPDX-FileCopyrightText: 2022 Lido <info@lido.fi>\\n// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity ^0.8.4;\\n\\nimport \\\"TrustedCaller.sol\\\";\\nimport \\\"AllowedRecipientsRegistry.sol\\\";\\nimport \\\"EVMScriptCreator.sol\\\";\\nimport \\\"IEVMScriptFactory.sol\\\";\\n\\n/// @author psirex, zuzueeka\\n/// @notice Creates EVMScript to add new allowed recipient address to AllowedRecipientsRegistry\\ncontract AddAllowedRecipient is TrustedCaller, IEVMScriptFactory {\\n    // -------------\\n    // ERRORS\\n    // -------------\\n\\n    string private constant ERROR_RECIPIENT_ADDRESS_IS_ZERO_ADDRESS =\\n        \\\"RECIPIENT_ADDRESS_IS_ZERO_ADDRESS\\\";\\n    string private constant ERROR_ALLOWED_RECIPIENT_ALREADY_ADDED =\\n        \\\"ALLOWED_RECIPIENT_ALREADY_ADDED\\\";\\n\\n    // -------------\\n    // VARIABLES\\n    // -------------\\n\\n    /// @notice Address of AllowedRecipientsRegistry\\n    AllowedRecipientsRegistry public allowedRecipientsRegistry;\\n\\n    // -------------\\n    // CONSTRUCTOR\\n    // -------------\\n\\n    constructor(address _trustedCaller, address _allowedRecipientsRegistry)\\n        TrustedCaller(_trustedCaller)\\n    {\\n        allowedRecipientsRegistry = AllowedRecipientsRegistry(_allowedRecipientsRegistry);\\n    }\\n\\n    // -------------\\n    // EXTERNAL METHODS\\n    // -------------\\n\\n    /// @notice Creates EVMScript to add new allowed recipient address to allowedRecipientsRegistry\\n    /// @param _creator Address who creates EVMScript\\n    /// @param _evmScriptCallData Encoded tuple: (address recipientAddress, string memory title)\\n    function createEVMScript(address _creator, bytes memory _evmScriptCallData)\\n        external\\n        view\\n        override\\n        onlyTrustedCaller(_creator)\\n        returns (bytes memory)\\n    {\\n        (address recipientAddress, ) = _decodeEVMScriptCallData(_evmScriptCallData);\\n        require(recipientAddress != address(0), ERROR_RECIPIENT_ADDRESS_IS_ZERO_ADDRESS);\\n        require(\\n            !allowedRecipientsRegistry.isRecipientAllowed(recipientAddress),\\n            ERROR_ALLOWED_RECIPIENT_ALREADY_ADDED\\n        );\\n\\n        return\\n            EVMScriptCreator.createEVMScript(\\n                address(allowedRecipientsRegistry),\\n                allowedRecipientsRegistry.addRecipient.selector,\\n                _evmScriptCallData\\n            );\\n    }\\n\\n    /// @notice Decodes call data used by createEVMScript method\\n    /// @param _evmScriptCallData Encoded tuple: (address recipientAddress, string title)\\n    /// @return Address of recipient to add\\n    /// @return Title of  the recipient\\n    function decodeEVMScriptCallData(bytes memory _evmScriptCallData)\\n        external\\n        pure\\n        returns (address, string memory)\\n    {\\n        return _decodeEVMScriptCallData(_evmScriptCallData);\\n    }\\n\\n    // ------------------\\n    // PRIVATE METHODS\\n    // ------------------\\n\\n    function _decodeEVMScriptCallData(bytes memory _evmScriptCallData)\\n        private\\n        pure\\n        returns (address, string memory)\\n    {\\n        return abi.decode(_evmScriptCallData, (address, string));\\n    }\\n}\\n\"\r\n    },\r\n    \"TrustedCaller.sol\": {\r\n      \"content\": \"// SPDX-FileCopyrightText: 2021 Lido <info@lido.fi>\\n// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity ^0.8.4;\\n\\n/// @author psirex\\n/// @notice A helper contract contains logic to validate that only a trusted caller has access to certain methods.\\n/// @dev Trusted caller set once on deployment and can't be changed.\\ncontract TrustedCaller {\\n    string private constant ERROR_TRUSTED_CALLER_IS_ZERO_ADDRESS = \\\"TRUSTED_CALLER_IS_ZERO_ADDRESS\\\";\\n    string private constant ERROR_CALLER_IS_FORBIDDEN = \\\"CALLER_IS_FORBIDDEN\\\";\\n\\n    address public immutable trustedCaller;\\n\\n    constructor(address _trustedCaller) {\\n        require(_trustedCaller != address(0), ERROR_TRUSTED_CALLER_IS_ZERO_ADDRESS);\\n        trustedCaller = _trustedCaller;\\n    }\\n\\n    modifier onlyTrustedCaller(address _caller) {\\n        require(_caller == trustedCaller, ERROR_CALLER_IS_FORBIDDEN);\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"AllowedRecipientsRegistry.sol\": {\r\n      \"content\": \"// SPDX-FileCopyrightText: 2022 Lido <info@lido.fi>\\n// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity ^0.8.4;\\n\\nimport \\\"LimitsChecker.sol\\\";\\n\\n/// @author psirex, zuzueeka\\n/// @title Registry of allowed addresses for payouts\\n/// @notice Stores list of allowed addresses\\ncontract AllowedRecipientsRegistry is LimitsChecker {\\n    // -------------\\n    // EVENTS\\n    // -------------\\n    event RecipientAdded(address indexed _recipient, string _title);\\n    event RecipientRemoved(address indexed _recipient);\\n\\n    // -------------\\n    // ROLES\\n    // -------------\\n    bytes32 public constant ADD_RECIPIENT_TO_ALLOWED_LIST_ROLE =\\n        keccak256(\\\"ADD_RECIPIENT_TO_ALLOWED_LIST_ROLE\\\");\\n    bytes32 public constant REMOVE_RECIPIENT_FROM_ALLOWED_LIST_ROLE =\\n        keccak256(\\\"REMOVE_RECIPIENT_FROM_ALLOWED_LIST_ROLE\\\");\\n\\n    // -------------\\n    // ERRORS\\n    // -------------\\n    string private constant ERROR_RECIPIENT_ALREADY_ADDED_TO_ALLOWED_LIST =\\n        \\\"RECIPIENT_ALREADY_ADDED_TO_ALLOWED_LIST\\\";\\n    string private constant ERROR_RECIPIENT_NOT_FOUND_IN_ALLOWED_LIST =\\n        \\\"RECIPIENT_NOT_FOUND_IN_ALLOWED_LIST\\\";\\n\\n    // -------------\\n    // VARIABLES\\n    // -------------\\n\\n    /// @dev List of allowed addresses for payouts\\n    address[] public allowedRecipients;\\n\\n    // Position of the address in the `allowedRecipients` array,\\n    // plus 1 because index 0 means a value is not in the set.\\n    mapping(address => uint256) private allowedRecipientIndices;\\n\\n    // -------------\\n    // CONSTRUCTOR\\n    // -------------\\n\\n    /// @param _admin Address which will be granted with role DEFAULT_ADMIN_ROLE\\n    /// @param _addRecipientToAllowedListRoleHolders List of addresses which will be\\n    ///     granted with role ADD_RECIPIENT_TO_ALLOWED_LIST_ROLE\\n    /// @param _removeRecipientFromAllowedListRoleHolders List of addresses which will\\n    ///     be granted with role REMOVE_RECIPIENT_FROM_ALLOWED_LIST_ROLE\\n    /// @param _setParametersRoleHolders List of addresses which will\\n    ///     be granted with role SET_PARAMETERS_ROLE\\n    /// @param _updateSpentAmountRoleHolders List of addresses which will\\n    ///     be granted with role UPDATE_SPENT_AMOUNT_ROLE\\n    /// @param _bokkyPooBahsDateTimeContract Address of bokkyPooBahs DateTime Contract\\n    constructor(\\n        address _admin,\\n        address[] memory _addRecipientToAllowedListRoleHolders,\\n        address[] memory _removeRecipientFromAllowedListRoleHolders,\\n        address[] memory _setParametersRoleHolders,\\n        address[] memory _updateSpentAmountRoleHolders,\\n        IBokkyPooBahsDateTimeContract _bokkyPooBahsDateTimeContract\\n    )\\n        LimitsChecker(\\n            _setParametersRoleHolders,\\n            _updateSpentAmountRoleHolders,\\n            _bokkyPooBahsDateTimeContract\\n        )\\n    {\\n        _setupRole(DEFAULT_ADMIN_ROLE, _admin);\\n        for (uint256 i = 0; i < _addRecipientToAllowedListRoleHolders.length; i++) {\\n            _setupRole(\\n                ADD_RECIPIENT_TO_ALLOWED_LIST_ROLE,\\n                _addRecipientToAllowedListRoleHolders[i]\\n            );\\n        }\\n        for (uint256 i = 0; i < _removeRecipientFromAllowedListRoleHolders.length; i++) {\\n            _setupRole(\\n                REMOVE_RECIPIENT_FROM_ALLOWED_LIST_ROLE,\\n                _removeRecipientFromAllowedListRoleHolders[i]\\n            );\\n        }\\n    }\\n\\n    // -------------\\n    // EXTERNAL METHODS\\n    // -------------\\n\\n    /// @notice Adds address to list of allowed addresses for payouts\\n    function addRecipient(address _recipient, string memory _title)\\n        external\\n        onlyRole(ADD_RECIPIENT_TO_ALLOWED_LIST_ROLE)\\n    {\\n        require(\\n            allowedRecipientIndices[_recipient] == 0,\\n            ERROR_RECIPIENT_ALREADY_ADDED_TO_ALLOWED_LIST\\n        );\\n\\n        allowedRecipients.push(_recipient);\\n        allowedRecipientIndices[_recipient] = allowedRecipients.length;\\n        emit RecipientAdded(_recipient, _title);\\n    }\\n\\n    /// @notice Removes address from list of allowed addresses for payouts\\n    /// @dev To delete an allowed address from the allowedRecipients array in O(1),\\n    /// we swap the element to delete with the last one in the array,\\n    /// and then remove the last element (sometimes called as 'swap and pop').\\n    function removeRecipient(address _recipient)\\n        external\\n        onlyRole(REMOVE_RECIPIENT_FROM_ALLOWED_LIST_ROLE)\\n    {\\n        uint256 index = _getAllowedRecipientIndex(_recipient);\\n        uint256 lastIndex = allowedRecipients.length - 1;\\n\\n        if (index != lastIndex) {\\n            address lastAllowedRecipient = allowedRecipients[lastIndex];\\n            allowedRecipients[index] = lastAllowedRecipient;\\n            allowedRecipientIndices[lastAllowedRecipient] = index + 1;\\n        }\\n\\n        allowedRecipients.pop();\\n        delete allowedRecipientIndices[_recipient];\\n        emit RecipientRemoved(_recipient);\\n    }\\n\\n    /// @notice Returns if passed address is listed as allowed recipient in the registry\\n    function isRecipientAllowed(address _recipient) external view returns (bool) {\\n        return allowedRecipientIndices[_recipient] > 0;\\n    }\\n\\n    /// @notice Returns current list of allowed recipients\\n    function getAllowedRecipients() external view returns (address[] memory) {\\n        return allowedRecipients;\\n    }\\n\\n    // ------------------\\n    // PRIVATE METHODS\\n    // ------------------\\n\\n    function _getAllowedRecipientIndex(address _recipient) private view returns (uint256 _index) {\\n        _index = allowedRecipientIndices[_recipient];\\n        require(_index > 0, ERROR_RECIPIENT_NOT_FOUND_IN_ALLOWED_LIST);\\n        _index -= 1;\\n    }\\n}\\n\"\r\n    },\r\n    \"LimitsChecker.sol\": {\r\n      \"content\": \"// SPDX-FileCopyrightText: 2022 Lido <info@lido.fi>\\n// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity ^0.8.4;\\n\\nimport \\\"EVMScriptCreator.sol\\\";\\nimport \\\"IBokkyPooBahsDateTimeContract.sol\\\";\\n\\nimport \\\"AccessControl.sol\\\";\\n\\n/// @author zuzueeka\\n/// @notice Stores limits params and provides limit-enforcement logic\\n///\\n/// \u25b2 spendableBalance = limit-spentAmount\\n/// |\\n/// \u2502             |................              |..               limit-spentAmount = limit-0 = limit\\n/// \u2502.....        |                ...           |\\n/// \u2502     ........|                   ......     |  ..............\\n///               |                         .....|\\n/// \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500> Time\\n/// |     ^       |                ^  ^     ^    |  ^              (^ - Motion enactment)\\n/// \u2502             |currentPeriodEndTimestamp     |currentPeriodEndTimestamp\\n/// |             |spentAmount=0                 |spentAmount=0\\n///\\n/// currentPeriodEndTimestamp is calculated as a calendar date of the beginning of\\n/// a next month, bi-months, quarter, half year, or year period.\\n/// If, for example, periodDurationMonths = 3, then it is considered that the date changes once a quarter.\\n/// And currentPeriodEndTimestamp can take values 1 Apr, 1 Jul, 1 Oct, 1 Jan.\\n/// If periodDurationMonths = 1, then shift of currentPeriodEndTimestamp occurs once a month\\n/// and currentPeriodEndTimestamp can take values 1 Feb, 1 Mar, 1 Apr, etc\\n///\\ncontract LimitsChecker is AccessControl {\\n    // -------------\\n    // EVENTS\\n    // -------------\\n    event LimitsParametersChanged(uint256 _limit, uint256 _periodDurationMonths);\\n    event SpendableAmountChanged(\\n        uint256 _alreadySpentAmount,\\n        uint256 _spendableBalance,\\n        uint256 indexed _periodStartTimestamp,\\n        uint256 _periodEndTimestamp\\n    );\\n    event CurrentPeriodAdvanced(uint256 indexed _periodStartTimestamp);\\n    event BokkyPooBahsDateTimeContractChanged(address indexed _newAddress);\\n    event SpentAmountChanged(uint256 _newSpentAmount);\\n\\n    // -------------\\n    // ERRORS\\n    // -------------\\n    string private constant ERROR_INVALID_PERIOD_DURATION = \\\"INVALID_PERIOD_DURATION\\\";\\n    string private constant ERROR_SUM_EXCEEDS_SPENDABLE_BALANCE = \\\"SUM_EXCEEDS_SPENDABLE_BALANCE\\\";\\n    string private constant ERROR_TOO_LARGE_LIMIT = \\\"TOO_LARGE_LIMIT\\\";\\n    string private constant ERROR_SAME_DATE_TIME_CONTRACT_ADDRESS =\\n        \\\"SAME_DATE_TIME_CONTRACT_ADDRESS\\\";\\n    string private constant ERROR_SPENT_AMOUNT_EXCEEDS_LIMIT = \\\"ERROR_SPENT_AMOUNT_EXCEEDS_LIMIT\\\";\\n\\n    // -------------\\n    // ROLES\\n    // -------------\\n    bytes32 public constant SET_PARAMETERS_ROLE = keccak256(\\\"SET_PARAMETERS_ROLE\\\");\\n    bytes32 public constant UPDATE_SPENT_AMOUNT_ROLE = keccak256(\\\"UPDATE_SPENT_AMOUNT_ROLE\\\");\\n\\n    // -------------\\n    // CONSTANTS\\n    // -------------\\n\\n    // ------------\\n    // STORAGE VARIABLES\\n    // ------------\\n\\n    /// @notice Address of BokkyPooBahsDateTimeContract\\n    IBokkyPooBahsDateTimeContract public bokkyPooBahsDateTimeContract;\\n\\n    /// @notice Length of period in months\\n    uint64 internal periodDurationMonths;\\n\\n    /// @notice End of the current period\\n    uint128 internal currentPeriodEndTimestamp;\\n\\n    /// @notice The maximum that can be spent in a period\\n    uint128 internal limit;\\n\\n    /// @notice Amount already spent in the period\\n    uint128 internal spentAmount;\\n\\n    // ------------\\n    // CONSTRUCTOR\\n    // ------------\\n    /// @param _setParametersRoleHolders List of addresses which will\\n    ///     be granted with role SET_PARAMETERS_ROLE\\n    /// @param _updateSpentAmountRoleHolders List of addresses which will\\n    ///     be granted with role UPDATE_SPENT_AMOUNT_ROLE\\n    /// @param _bokkyPooBahsDateTimeContract Address of bokkyPooBahs DateTime Contract\\n    constructor(\\n        address[] memory _setParametersRoleHolders,\\n        address[] memory _updateSpentAmountRoleHolders,\\n        IBokkyPooBahsDateTimeContract _bokkyPooBahsDateTimeContract\\n    ) {\\n        for (uint256 i = 0; i < _setParametersRoleHolders.length; i++) {\\n            _setupRole(SET_PARAMETERS_ROLE, _setParametersRoleHolders[i]);\\n        }\\n        for (uint256 i = 0; i < _updateSpentAmountRoleHolders.length; i++) {\\n            _setupRole(UPDATE_SPENT_AMOUNT_ROLE, _updateSpentAmountRoleHolders[i]);\\n        }\\n        bokkyPooBahsDateTimeContract = _bokkyPooBahsDateTimeContract;\\n    }\\n\\n    // -------------\\n    // EXTERNAL METHODS\\n    // -------------\\n\\n    /// @notice Checks if _payoutAmount is less or equal than the may be spent\\n    /// @param _payoutAmount Motion total amount\\n    /// @param _motionDuration Motion duration - minimal time required to pass before enacting of motion\\n    /// @return True if _payoutAmount is less or equal than may be spent\\n    /// @dev note that upfront check is used to compare _paymentSum with total limit in case\\n    /// when motion is started in one period and will be probably enacted in the next.\\n    function isUnderSpendableBalance(uint256 _payoutAmount, uint256 _motionDuration)\\n        external\\n        view\\n        returns (bool)\\n    {\\n        if (block.timestamp + _motionDuration >= currentPeriodEndTimestamp) {\\n            return _payoutAmount <= limit;\\n        } else {\\n            return _payoutAmount <= _spendableBalance(limit, spentAmount);\\n        }\\n    }\\n\\n    /// @notice Checks if _payoutAmount may be spent and increases spentAmount by _payoutAmount.\\n    /// @notice Also updates the period boundaries if necessary.\\n    function updateSpentAmount(uint256 _payoutAmount) external onlyRole(UPDATE_SPENT_AMOUNT_ROLE) {\\n        uint256 spentAmountLocal = spentAmount;\\n        uint256 limitLocal = limit;\\n        uint256 currentPeriodEndTimestampLocal = currentPeriodEndTimestamp;\\n\\n        /// When it is necessary to shift the currentPeriodEndTimestamp it takes on a new value.\\n        /// And also spent is set to zero. Thus begins a new period.\\n        if (block.timestamp >= currentPeriodEndTimestampLocal) {\\n            currentPeriodEndTimestampLocal = _getPeriodEndFromTimestamp(block.timestamp);\\n            spentAmountLocal = 0;\\n            emit CurrentPeriodAdvanced(\\n                _getPeriodStartFromTimestamp(currentPeriodEndTimestampLocal - 1)\\n            );\\n            currentPeriodEndTimestamp = uint128(currentPeriodEndTimestampLocal);\\n        }\\n\\n        require(\\n            _payoutAmount <= _spendableBalance(limitLocal, spentAmountLocal),\\n            ERROR_SUM_EXCEEDS_SPENDABLE_BALANCE\\n        );\\n        spentAmountLocal += _payoutAmount;\\n        spentAmount = uint128(spentAmountLocal);\\n\\n        (\\n            uint256 alreadySpentAmount,\\n            uint256 spendableBalanceInPeriod,\\n            uint256 periodStartTimestamp,\\n            uint256 periodEndTimestamp\\n        ) = _getCurrentPeriodState(limitLocal, spentAmountLocal, currentPeriodEndTimestampLocal);\\n\\n        emit SpendableAmountChanged(\\n            alreadySpentAmount,\\n            spendableBalanceInPeriod,\\n            periodStartTimestamp,\\n            periodEndTimestamp\\n        );\\n    }\\n\\n    /// @notice Returns balance that can be spent in the current period\\n    /// @notice If period advanced and no call to updateSpentAmount or setLimitParameters made,\\n    /// @notice then the method will return spendable balance corresponding to the previous period.\\n    /// @return Balance that can be spent in the current period\\n    function spendableBalance() external view returns (uint256) {\\n        return _spendableBalance(limit, spentAmount);\\n    }\\n\\n    /// @notice Sets periodDurationMonths and limit\\n    /// @notice Calculates currentPeriodEndTimestamp as a calendar date of the beginning of next period.\\n    /// @param _limit Limit to set\\n    /// @param _periodDurationMonths Length of period in months. Must be 1, 2, 3, 6 or 12.\\n    function setLimitParameters(uint256 _limit, uint256 _periodDurationMonths)\\n        external\\n        onlyRole(SET_PARAMETERS_ROLE)\\n    {\\n        require(_limit <= type(uint128).max, ERROR_TOO_LARGE_LIMIT);\\n\\n        _validatePeriodDurationMonths(_periodDurationMonths);\\n        periodDurationMonths = uint64(_periodDurationMonths);\\n        uint256 currentPeriodEndTimestampLocal = _getPeriodEndFromTimestamp(block.timestamp);\\n        emit CurrentPeriodAdvanced(\\n            _getPeriodStartFromTimestamp(currentPeriodEndTimestampLocal - 1)\\n        );\\n        currentPeriodEndTimestamp = uint128(currentPeriodEndTimestampLocal);\\n        limit = uint128(_limit);\\n\\n        emit LimitsParametersChanged(_limit, _periodDurationMonths);\\n    }\\n\\n    /// @notice Returns limit and periodDurationMonths\\n    /// @return limit - the maximum that can be spent in a period\\n    /// @return periodDurationMonths - length of period in months\\n    function getLimitParameters() external view returns (uint256, uint256) {\\n        return (limit, periodDurationMonths);\\n    }\\n\\n    /// @notice Returns state of the current period: amount spent, balance available for spending,\\n    /// @notice start date of the current period and end date of the current period\\n    /// @notice If period advanced and the period was not shifted,\\n    /// @notice then the method will return spendable balance corresponding to the previous period.\\n    /// @return _alreadySpentAmount - amount already spent in the current period\\n    /// @return _spendableBalanceInPeriod - balance available for spending in the current period\\n    /// @return _periodStartTimestamp - start date of the current period\\n    /// @return _periodEndTimestamp - end date of the current period\\n    function getPeriodState()\\n        external\\n        view\\n        returns (\\n            uint256 _alreadySpentAmount,\\n            uint256 _spendableBalanceInPeriod,\\n            uint256 _periodStartTimestamp,\\n            uint256 _periodEndTimestamp\\n        )\\n    {\\n        return _getCurrentPeriodState(limit, spentAmount, currentPeriodEndTimestamp);\\n    }\\n\\n    /// @notice Sets address of BokkyPooBahsDateTime contract\\n    /// @dev Need this to be able to replace the contract in case of a bug in it\\n    /// @param _bokkyPooBahsDateTimeContract New address of the BokkyPooBahsDateTime library\\n    function setBokkyPooBahsDateTimeContract(address _bokkyPooBahsDateTimeContract)\\n        external\\n        onlyRole(SET_PARAMETERS_ROLE)\\n    {\\n        require(\\n            _bokkyPooBahsDateTimeContract != address(bokkyPooBahsDateTimeContract),\\n            ERROR_SAME_DATE_TIME_CONTRACT_ADDRESS\\n        );\\n\\n        bokkyPooBahsDateTimeContract = IBokkyPooBahsDateTimeContract(_bokkyPooBahsDateTimeContract);\\n        emit BokkyPooBahsDateTimeContractChanged(_bokkyPooBahsDateTimeContract);\\n    }\\n\\n    /// @notice Allows setting the amount of spent tokens in the current period manually\\n    /// @param _newSpentAmount New value for the amount of spent tokens in the current period\\n    function unsafeSetSpentAmount(uint256 _newSpentAmount) external onlyRole(SET_PARAMETERS_ROLE) {\\n        require(_newSpentAmount <= limit, ERROR_SPENT_AMOUNT_EXCEEDS_LIMIT);\\n\\n        if (spentAmount != _newSpentAmount) {\\n            spentAmount = uint128(_newSpentAmount);\\n            emit SpentAmountChanged(_newSpentAmount);\\n        }\\n    }\\n\\n    // ------------------\\n    // PRIVATE METHODS\\n    // ------------------\\n    function _getCurrentPeriodState(\\n        uint256 _limit,\\n        uint256 _spentAmount,\\n        uint256 _currentPeriodEndTimestamp\\n    )\\n        internal\\n        view\\n        returns (\\n            uint256 _alreadySpentAmount,\\n            uint256 _spendableBalanceInPeriod,\\n            uint256 _periodStartTimestamp,\\n            uint256 _periodEndTimestamp\\n        )\\n    {\\n        return (\\n            _spentAmount,\\n            _spendableBalance(_limit, _spentAmount),\\n            _getPeriodStartFromTimestamp(_currentPeriodEndTimestamp - 1),\\n            _currentPeriodEndTimestamp\\n        );\\n    }\\n\\n    function _spendableBalance(uint256 _limit, uint256 _spentAmount)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return _spentAmount < _limit ? _limit - _spentAmount : 0;\\n    }\\n\\n    function _validatePeriodDurationMonths(uint256 _periodDurationMonths) internal pure {\\n        require(\\n            _periodDurationMonths == 1 ||\\n                _periodDurationMonths == 2 ||\\n                _periodDurationMonths == 3 ||\\n                _periodDurationMonths == 6 ||\\n                _periodDurationMonths == 12,\\n            ERROR_INVALID_PERIOD_DURATION\\n        );\\n    }\\n\\n    function _getPeriodStartFromTimestamp(uint256 _timestamp) internal view returns (uint256) {\\n        // Get year and number of month of the timestamp:\\n        (uint256 year, uint256 month, ) = bokkyPooBahsDateTimeContract.timestampToDate(_timestamp);\\n        // We assume that the year will remain the same,\\n        // because the beginning of the current calendar period will necessarily be in the same year.\\n        uint256 periodStartYear = year;\\n        // Get the number of the start date month:\\n        uint256 periodStartMonth = _getFirstMonthInPeriodFromMonth(month, periodDurationMonths);\\n        // The beginning of the period always matches the calendar date of the beginning of the month.\\n        uint256 periodStartDay = 1;\\n        return\\n            bokkyPooBahsDateTimeContract.timestampFromDate(\\n                periodStartYear,\\n                periodStartMonth,\\n                periodStartDay\\n            );\\n    }\\n\\n    function _getFirstMonthInPeriodFromMonth(uint256 _month, uint256 _periodDurationMonths)\\n        internal\\n        pure\\n        returns (uint256 _firstMonthInPeriod)\\n    {\\n        require(_periodDurationMonths != 0, ERROR_INVALID_PERIOD_DURATION);\\n\\n        // To get the number of the first month in the period:\\n        //   1. get the number of the period within the current year, starting from its beginning:\\n        uint256 periodNumber = (_month - 1) / _periodDurationMonths;\\n        //   2. and then the number of the first month in this period:\\n        _firstMonthInPeriod = periodNumber * _periodDurationMonths + 1;\\n        // The shift by - 1 and then by + 1 happens because the months in the calendar start from 1 and not from 0.\\n    }\\n\\n    function _getPeriodEndFromTimestamp(uint256 _timestamp) internal view returns (uint256) {\\n        uint256 periodStart = _getPeriodStartFromTimestamp(_timestamp);\\n        return bokkyPooBahsDateTimeContract.addMonths(periodStart, periodDurationMonths);\\n    }\\n}\\n\"\r\n    },\r\n    \"EVMScriptCreator.sol\": {\r\n      \"content\": \"// SPDX-FileCopyrightText: 2021 Lido <info@lido.fi>\\n// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity ^0.8.4;\\n\\n/// @author psirex\\n/// @notice Contains methods for convenient creation\\n/// of EVMScripts in EVMScript factories contracts\\nlibrary EVMScriptCreator {\\n    // Id of default CallsScript Aragon's executor.\\n    bytes4 private constant SPEC_ID = hex\\\"00000001\\\";\\n\\n    /// @notice Encodes one method call as EVMScript\\n    function createEVMScript(\\n        address _to,\\n        bytes4 _methodId,\\n        bytes memory _evmScriptCallData\\n    ) internal pure returns (bytes memory _commands) {\\n        return\\n            abi.encodePacked(\\n                SPEC_ID,\\n                _to,\\n                uint32(_evmScriptCallData.length) + 4,\\n                _methodId,\\n                _evmScriptCallData\\n            );\\n    }\\n\\n    /// @notice Encodes multiple calls of the same method on one contract as EVMScript\\n    function createEVMScript(\\n        address _to,\\n        bytes4 _methodId,\\n        bytes[] memory _evmScriptCallData\\n    ) internal pure returns (bytes memory _evmScript) {\\n        for (uint256 i = 0; i < _evmScriptCallData.length; ++i) {\\n            _evmScript = bytes.concat(\\n                _evmScript,\\n                abi.encodePacked(\\n                    _to,\\n                    uint32(_evmScriptCallData[i].length) + 4,\\n                    _methodId,\\n                    _evmScriptCallData[i]\\n                )\\n            );\\n        }\\n        _evmScript = bytes.concat(SPEC_ID, _evmScript);\\n    }\\n\\n    /// @notice Encodes multiple calls to different methods within the same contract as EVMScript\\n    function createEVMScript(\\n        address _to,\\n        bytes4[] memory _methodIds,\\n        bytes[] memory _evmScriptCallData\\n    ) internal pure returns (bytes memory _evmScript) {\\n        require(_methodIds.length == _evmScriptCallData.length, \\\"LENGTH_MISMATCH\\\");\\n\\n        for (uint256 i = 0; i < _methodIds.length; ++i) {\\n            _evmScript = bytes.concat(\\n                _evmScript,\\n                abi.encodePacked(\\n                    _to,\\n                    uint32(_evmScriptCallData[i].length) + 4,\\n                    _methodIds[i],\\n                    _evmScriptCallData[i]\\n                )\\n            );\\n        }\\n        _evmScript = bytes.concat(SPEC_ID, _evmScript);\\n    }\\n\\n    /// @notice Encodes multiple calls to different contracts as EVMScript\\n    function createEVMScript(\\n        address[] memory _to,\\n        bytes4[] memory _methodIds,\\n        bytes[] memory _evmScriptCallData\\n    ) internal pure returns (bytes memory _evmScript) {\\n        require(_to.length == _methodIds.length, \\\"LENGTH_MISMATCH\\\");\\n        require(_to.length == _evmScriptCallData.length, \\\"LENGTH_MISMATCH\\\");\\n\\n        for (uint256 i = 0; i < _to.length; ++i) {\\n            _evmScript = bytes.concat(\\n                _evmScript,\\n                abi.encodePacked(\\n                    _to[i],\\n                    uint32(_evmScriptCallData[i].length) + 4,\\n                    _methodIds[i],\\n                    _evmScriptCallData[i]\\n                )\\n            );\\n        }\\n        _evmScript = bytes.concat(SPEC_ID, _evmScript);\\n    }\\n}\\n\"\r\n    },\r\n    \"IBokkyPooBahsDateTimeContract.sol\": {\r\n      \"content\": \"// SPDX-FileCopyrightText: 2022 Lido <info@lido.fi>\\n// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity ^0.8.4;\\n\\n/// @author zuzueeka\\n/// @notice Interface of methods from BokkyPooBahsDateTimeContract to deal with dates\\ninterface IBokkyPooBahsDateTimeContract {\\n    function timestampToDate(uint256 timestamp)\\n        external\\n        pure\\n        returns (\\n            uint256 year,\\n            uint256 month,\\n            uint256 day\\n        );\\n\\n    function timestampFromDate(\\n        uint256 year,\\n        uint256 month,\\n        uint256 day\\n    ) external pure returns (uint256 timestamp);\\n\\n    function addMonths(uint256 timestamp, uint256 _months)\\n        external\\n        pure\\n        returns (uint256 newTimestamp);\\n}\\n\"\r\n    },\r\n    \"AccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"IAccessControl.sol\\\";\\nimport \\\"Context.sol\\\";\\nimport \\\"Strings.sol\\\";\\nimport \\\"ERC165.sol\\\";\\n\\n/**\\n * @dev Contract module that allows children to implement role-based access\\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\\n * members except through off-chain means by accessing the contract event logs. Some\\n * applications may benefit from on-chain enumerability, for those cases see\\n * {AccessControlEnumerable}.\\n *\\n * Roles are referred to by their `bytes32` identifier. These should be exposed\\n * in the external API and be unique. The best way to achieve this is by\\n * using `public constant` hash digests:\\n *\\n * ```\\n * bytes32 public constant MY_ROLE = keccak256(\\\"MY_ROLE\\\");\\n * ```\\n *\\n * Roles can be used to represent a set of permissions. To restrict access to a\\n * function call, use {hasRole}:\\n *\\n * ```\\n * function foo() public {\\n *     require(hasRole(MY_ROLE, msg.sender));\\n *     ...\\n * }\\n * ```\\n *\\n * Roles can be granted and revoked dynamically via the {grantRole} and\\n * {revokeRole} functions. Each role has an associated admin role, and only\\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\\n *\\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\\n * that only accounts with this role will be able to grant or revoke other\\n * roles. More complex role relationships can be created by using\\n * {_setRoleAdmin}.\\n *\\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\\n * grant and revoke this role. Extra precautions should be taken to secure\\n * accounts that have been granted it.\\n */\\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\\n    struct RoleData {\\n        mapping(address => bool) members;\\n        bytes32 adminRole;\\n    }\\n\\n    mapping(bytes32 => RoleData) private _roles;\\n\\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n    /**\\n     * @dev Modifier that checks that an account has a specific role. Reverts\\n     * with a standardized message including the required role.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\\n     *\\n     * _Available since v4.1._\\n     */\\n    modifier onlyRole(bytes32 role) {\\n        _checkRole(role, _msgSender());\\n        _;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) public view override returns (bool) {\\n        return _roles[role].members[account];\\n    }\\n\\n    /**\\n     * @dev Revert with a standard message if `account` is missing `role`.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\\n     */\\n    function _checkRole(bytes32 role, address account) internal view {\\n        if (!hasRole(role, account)) {\\n            revert(\\n                string(\\n                    abi.encodePacked(\\n                        \\\"AccessControl: account \\\",\\n                        Strings.toHexString(uint160(account), 20),\\n                        \\\" is missing role \\\",\\n                        Strings.toHexString(uint256(role), 32)\\n                    )\\n                )\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\\n        return _roles[role].adminRole;\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) public virtual override {\\n        require(account == _msgSender(), \\\"AccessControl: can only renounce roles for self\\\");\\n\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event. Note that unlike {grantRole}, this function doesn't perform any\\n     * checks on the calling account.\\n     *\\n     * [WARNING]\\n     * ====\\n     * This function should only be called from the constructor when setting\\n     * up the initial roles for the system.\\n     *\\n     * Using this function in any other way is effectively circumventing the admin\\n     * system imposed by {AccessControl}.\\n     * ====\\n     */\\n    function _setupRole(bytes32 role, address account) internal virtual {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Sets `adminRole` as ``role``'s admin role.\\n     *\\n     * Emits a {RoleAdminChanged} event.\\n     */\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\n        bytes32 previousAdminRole = getRoleAdmin(role);\\n        _roles[role].adminRole = adminRole;\\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\\n    }\\n\\n    function _grantRole(bytes32 role, address account) private {\\n        if (!hasRole(role, account)) {\\n            _roles[role].members[account] = true;\\n            emit RoleGranted(role, account, _msgSender());\\n        }\\n    }\\n\\n    function _revokeRole(bytes32 role, address account) private {\\n        if (hasRole(role, account)) {\\n            _roles[role].members[account] = false;\\n            emit RoleRevoked(role, account, _msgSender());\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"IAccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC165 detection.\\n */\\ninterface IAccessControl {\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {AccessControl-_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) external;\\n}\\n\"\r\n    },\r\n    \"Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"IEVMScriptFactory.sol\": {\r\n      \"content\": \"// SPDX-FileCopyrightText: 2021 Lido <info@lido.fi>\\n// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity ^0.8.4;\\n\\n/// @author psirex\\n/// @notice Interface which every EVMScript factory used in EasyTrack contract has to implement\\ninterface IEVMScriptFactory {\\n    function createEVMScript(address _creator, bytes memory _evmScriptCallData)\\n        external\\n        returns (bytes memory);\\n}\\n\"\r\n    },\r\n    \"RemoveAllowedRecipient.sol\": {\r\n      \"content\": \"// SPDX-FileCopyrightText: 2022 Lido <info@lido.fi>\\n// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity ^0.8.4;\\n\\nimport \\\"TrustedCaller.sol\\\";\\nimport \\\"AllowedRecipientsRegistry.sol\\\";\\nimport \\\"EVMScriptCreator.sol\\\";\\nimport \\\"IEVMScriptFactory.sol\\\";\\n\\n/// @author psirex, zuzueeka\\n/// @notice Creates EVMScript to remove allowed recipient address from AllowedRecipientsRegistry\\ncontract RemoveAllowedRecipient is TrustedCaller, IEVMScriptFactory {\\n    // -------------\\n    // ERRORS\\n    // -------------\\n    string private constant ERROR_ALLOWED_RECIPIENT_NOT_FOUND = \\\"ALLOWED_RECIPIENT_NOT_FOUND\\\";\\n\\n    // -------------\\n    // VARIABLES\\n    // -------------\\n\\n    /// @notice Address of AllowedRecipientsRegistry\\n    AllowedRecipientsRegistry public allowedRecipientsRegistry;\\n\\n    // -------------\\n    // CONSTRUCTOR\\n    // -------------\\n\\n    constructor(address _trustedCaller, address _allowedRecipientsRegistry)\\n        TrustedCaller(_trustedCaller)\\n    {\\n        allowedRecipientsRegistry = AllowedRecipientsRegistry(_allowedRecipientsRegistry);\\n    }\\n\\n    // -------------\\n    // EXTERNAL METHODS\\n    // -------------\\n\\n    /// @notice Creates EVMScript to remove allowed recipient address from allowedRecipientsRegistry\\n    /// @param _creator Address who creates EVMScript\\n    /// @param _evmScriptCallData Encoded tuple: (address recipientAddress)\\n    function createEVMScript(address _creator, bytes memory _evmScriptCallData)\\n        external\\n        view\\n        override\\n        onlyTrustedCaller(_creator)\\n        returns (bytes memory)\\n    {\\n        require(\\n            allowedRecipientsRegistry.isRecipientAllowed(\\n                _decodeEVMScriptCallData(_evmScriptCallData)\\n            ),\\n            ERROR_ALLOWED_RECIPIENT_NOT_FOUND\\n        );\\n        return\\n            EVMScriptCreator.createEVMScript(\\n                address(allowedRecipientsRegistry),\\n                allowedRecipientsRegistry.removeRecipient.selector,\\n                _evmScriptCallData\\n            );\\n    }\\n\\n    /// @notice Decodes call data used by createEVMScript method\\n    /// @param _evmScriptCallData Encoded tuple: (address recipientAddress)\\n    /// @return recipientAddress Address to remove\\n    function decodeEVMScriptCallData(bytes memory _evmScriptCallData)\\n        external\\n        pure\\n        returns (address recipientAddress)\\n    {\\n        return _decodeEVMScriptCallData(_evmScriptCallData);\\n    }\\n\\n    // ------------------\\n    // PRIVATE METHODS\\n    // ------------------\\n\\n    function _decodeEVMScriptCallData(bytes memory _evmScriptCallData)\\n        private\\n        pure\\n        returns (address)\\n    {\\n        return abi.decode(_evmScriptCallData, (address));\\n    }\\n}\\n\"\r\n    },\r\n    \"TopUpAllowedRecipients.sol\": {\r\n      \"content\": \"// SPDX-FileCopyrightText: 2022 Lido <info@lido.fi>\\n// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity ^0.8.4;\\n\\nimport \\\"TrustedCaller.sol\\\";\\nimport \\\"IAllowedRecipientsRegistry.sol\\\";\\nimport \\\"IAllowedTokensRegistry.sol\\\";\\nimport \\\"IFinance.sol\\\";\\nimport \\\"EVMScriptCreator.sol\\\";\\nimport \\\"IEVMScriptFactory.sol\\\";\\nimport \\\"IEasyTrack.sol\\\";\\n\\n/// @notice Creates EVMScript to top up allowed recipients addresses within the current spendable balance\\ncontract TopUpAllowedRecipients is TrustedCaller, IEVMScriptFactory {\\n    // -------------\\n    // ERRORS\\n    // -------------\\n    string private constant ERROR_LENGTH_MISMATCH = \\\"LENGTH_MISMATCH\\\";\\n    string private constant ERROR_EMPTY_DATA = \\\"EMPTY_DATA\\\";\\n    string private constant ERROR_ZERO_AMOUNT = \\\"ZERO_AMOUNT\\\";\\n    string private constant ERROR_TOKEN_NOT_ALLOWED = \\\"TOKEN_NOT_ALLOWED\\\";\\n    string private constant ERROR_RECIPIENT_NOT_ALLOWED = \\\"RECIPIENT_NOT_ALLOWED\\\";\\n    string private constant ERROR_ZERO_RECIPIENT = \\\"ZERO_RECIPIENT\\\";\\n    string private constant ERROR_SUM_EXCEEDS_SPENDABLE_BALANCE = \\\"SUM_EXCEEDS_SPENDABLE_BALANCE\\\";\\n\\n    // -------------\\n    // VARIABLES\\n    // -------------\\n\\n    /// @notice Address of EasyTrack contract\\n    IEasyTrack public immutable easyTrack;\\n\\n    /// @notice Address of Aragon's Finance contract\\n    IFinance public immutable finance;\\n\\n    /// @notice Address of AllowedRecipientsRegistry contract\\n    IAllowedRecipientsRegistry public immutable allowedRecipientsRegistry;\\n\\n    /// @notice Address of AllowedTokensRegistry contract\\n    IAllowedTokensRegistry public immutable allowedTokensRegistry;\\n\\n    // -------------\\n    // CONSTRUCTOR\\n    // -------------\\n\\n    /// @param _trustedCaller Address that has access to certain methods.\\n    ///     Set once on deployment and can't be changed.\\n    /// @param _allowedRecipientsRegistry Address of AllowedRecipientsRegistry contract\\n    /// @param _allowedTokensRegistry Address of AllowedTokensRegistry contract\\n    /// @param _finance Address of Aragon's Finance contract\\n    /// @param _easyTrack Address of EasyTrack contract\\n    constructor(\\n        address _trustedCaller,\\n        address _allowedRecipientsRegistry,\\n        address _allowedTokensRegistry,\\n        address _finance,\\n        address _easyTrack\\n    ) TrustedCaller(_trustedCaller) {\\n        finance = IFinance(_finance);\\n        allowedRecipientsRegistry = IAllowedRecipientsRegistry(_allowedRecipientsRegistry);\\n        allowedTokensRegistry = IAllowedTokensRegistry(_allowedTokensRegistry);\\n        easyTrack = IEasyTrack(_easyTrack);\\n    }\\n\\n    // -------------\\n    // EXTERNAL METHODS\\n    // -------------\\n\\n    /// @notice Creates EVMScript to top up allowed recipients addresses\\n    /// @param _creator Address who creates EVMScript\\n    /// @param _evmScriptCallData Encoded tuple: (address token, address[] recipients, uint256[] amounts) where\\n    /// token - address of token to top up\\n    /// recipients - addresses of recipients to top up\\n    /// amounts - corresponding amounts of token to transfer\\n    /// @dev note that the arrays below has one extra element to store limit enforcement calls\\n    function createEVMScript(address _creator, bytes calldata _evmScriptCallData)\\n        external\\n        view\\n        override\\n        onlyTrustedCaller(_creator)\\n        returns (bytes memory)\\n    {\\n        (address token, address[] memory recipients, uint256[] memory amounts) =\\n            _decodeEVMScriptCallData(_evmScriptCallData);\\n        uint256 normalizedAmount = _validateEVMScriptCallData(token, recipients, amounts);\\n\\n        address[] memory to = new address[](recipients.length + 1);\\n        bytes4[] memory methodIds = new bytes4[](recipients.length + 1);\\n        bytes[] memory evmScriptsCalldata = new bytes[](recipients.length + 1);\\n\\n        to[0] = address(allowedRecipientsRegistry);\\n        methodIds[0] = allowedRecipientsRegistry.updateSpentAmount.selector;\\n        evmScriptsCalldata[0] = abi.encode(normalizedAmount);\\n\\n        for (uint256 i = 0; i < recipients.length; ++i) {\\n            to[i + 1] = address(finance);\\n            methodIds[i + 1] = finance.newImmediatePayment.selector;\\n            evmScriptsCalldata[i + 1] = abi.encode(token, recipients[i], amounts[i], \\\"Easy Track: top up recipient\\\");\\n        }\\n\\n        return EVMScriptCreator.createEVMScript(to, methodIds, evmScriptsCalldata);\\n    }\\n\\n    /// @notice Decodes call data used by createEVMScript method\\n    /// @param _evmScriptCallData Encoded tuple: (address[] recipients, uint256[] amounts) where\\n    /// recipients - addresses of recipients to top up\\n    /// amounts - corresponding amounts of token to transfer\\n    /// @return token Address of payout token\\n    /// @return recipients Addresses of recipients to top up\\n    /// @return amounts Amounts of token to transfer\\n    function decodeEVMScriptCallData(bytes calldata _evmScriptCallData)\\n        external\\n        pure\\n        returns (address token, address[] memory recipients, uint256[] memory amounts)\\n    {\\n        return _decodeEVMScriptCallData(_evmScriptCallData);\\n    }\\n\\n    // ------------------\\n    // PRIVATE METHODS\\n    // ------------------\\n\\n    function _validateEVMScriptCallData(address token, address[] memory _recipients, uint256[] memory _amounts)\\n        private\\n        view\\n        returns (uint256 normalizedAmount)\\n    {\\n        require(_amounts.length == _recipients.length, ERROR_LENGTH_MISMATCH);\\n        require(_recipients.length > 0, ERROR_EMPTY_DATA);\\n        require(allowedTokensRegistry.isTokenAllowed(token), ERROR_TOKEN_NOT_ALLOWED);\\n\\n        uint256 totalAmount;\\n\\n        for (uint256 i = 0; i < _recipients.length; ++i) {\\n            require(_amounts[i] > 0, ERROR_ZERO_AMOUNT);\\n            require(_recipients[i] != address(0), ERROR_ZERO_RECIPIENT);\\n            require(allowedRecipientsRegistry.isRecipientAllowed(_recipients[i]), ERROR_RECIPIENT_NOT_ALLOWED);\\n            totalAmount += _amounts[i];\\n        }\\n\\n        normalizedAmount = allowedTokensRegistry.normalizeAmount(totalAmount, token);\\n\\n        _validateSpendableBalance(normalizedAmount);\\n    }\\n\\n    function _decodeEVMScriptCallData(bytes calldata _evmScriptCallData)\\n        private\\n        pure\\n        returns (address token, address[] memory recipients, uint256[] memory amounts)\\n    {\\n        return abi.decode(_evmScriptCallData, (address, address[], uint256[]));\\n    }\\n\\n    function _validateSpendableBalance(uint256 _amount) private view {\\n        require(\\n            allowedRecipientsRegistry.isUnderSpendableBalance(_amount, easyTrack.motionDuration()),\\n            ERROR_SUM_EXCEEDS_SPENDABLE_BALANCE\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"IAllowedRecipientsRegistry.sol\": {\r\n      \"content\": \"// SPDX-FileCopyrightText: 2022 Lido <info@lido.fi>\\n// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity ^0.8.4;\\n\\ninterface IAllowedRecipientsRegistry {\\n    function addRecipient(address _recipient, string memory _title) external;\\n\\n    function renounceRole(bytes32 role, address account) external;\\n\\n    function isRecipientAllowed(address _recipient) external view returns (bool);\\n\\n    function setLimitParameters(uint256 _limit, uint256 _periodDurationMonths) external;\\n\\n    function getLimitParameters() external view returns (uint256, uint256);\\n\\n    function updateSpentAmount(uint256 _payoutAmount) external;\\n\\n    function spendableBalance() external view returns (uint256);\\n\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    function getAllowedRecipients() external view returns (address[] memory);\\n\\n    function bokkyPooBahsDateTimeContract() external view returns (address);\\n\\n    function isUnderSpendableBalance(uint256 _amount, uint256 _motionDuration) external view returns (bool);\\n}\"\r\n    },\r\n    \"IAllowedTokensRegistry.sol\": {\r\n      \"content\": \"// SPDX-FileCopyrightText: 2022 Lido <info@lido.fi>\\n// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity ^0.8.4;\\n\\ninterface IAllowedTokensRegistry {\\n    function addToken(address _token) external;\\n    \\n    function removeToken(address _token) external;\\n\\n    function renounceRole(bytes32 role, address account) external;\\n\\n    function isTokenAllowed(address _token) external view returns (bool);\\n\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    function getAllowedTokens() external view returns (address[] memory);\\n\\n    function decimals() external view returns (uint8);\\n\\n    function normalizeAmount(uint256 _amount, address _token) external view returns (uint256);\\n}\"\r\n    },\r\n    \"IFinance.sol\": {\r\n      \"content\": \"// SPDX-FileCopyrightText: 2021 Lido <info@lido.fi>\\n// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity ^0.8.4;\\n\\n/// @author psirex\\n/// @notice Interface of method from Aragon's Finance contract to create a new payment\\ninterface IFinance {\\n    function newImmediatePayment(\\n        address _token,\\n        address _receiver,\\n        uint256 _amount,\\n        string memory _reference\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"IEasyTrack.sol\": {\r\n      \"content\": \"// SPDX-FileCopyrightText: 2022 Lido <info@lido.fi>\\n// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity ^0.8.4;\\n\\ninterface IEasyTrack {\\n    function motionDuration() external view returns (uint256);\\n    function evmScriptExecutor() external view returns (address);\\n}\"\r\n    },\r\n    \"AllowedTokensRegistry.sol\": {\r\n      \"content\": \"// SPDX-FileCopyrightText: 2022 Lido <info@lido.fi>\\n// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.4;\\n\\nimport \\\"AccessControl.sol\\\";\\nimport \\\"IERC20Metadata.sol\\\";\\n\\ncontract AllowedTokensRegistry is AccessControl {\\n    // -------------\\n    // EVENTS\\n    // -------------\\n    event TokenAdded(address indexed _token);\\n    event TokenRemoved(address indexed _token);\\n\\n    // -------------\\n    // ROLES\\n    // -------------\\n\\n    bytes32 public constant ADD_TOKEN_TO_ALLOWED_LIST_ROLE = keccak256(\\\"ADD_TOKEN_TO_ALLOWED_LIST_ROLE\\\");\\n    bytes32 public constant REMOVE_TOKEN_FROM_ALLOWED_LIST_ROLE = keccak256(\\\"REMOVE_TOKEN_FROM_ALLOWED_LIST_ROLE\\\");\\n\\n    // -------------\\n    // ERRORS\\n    // -------------\\n    string private constant ERROR_TOKEN_ALREADY_ADDED_TO_ALLOWED_LIST = \\\"TOKEN_ALREADY_ADDED_TO_ALLOWED_LIST\\\";\\n    string private constant ERROR_TOKEN_NOT_FOUND_IN_ALLOWED_LIST = \\\"TOKEN_NOT_FOUND_IN_ALLOWED_LIST\\\";\\n    string private constant ERROR_TOKEN_ADDRESS_IS_ZERO = \\\"TOKEN_ADDRESS_IS_ZERO\\\";\\n\\n    // -------------\\n    // VARIABLES\\n    // -------------\\n    /// @dev List of allowed tokens for payouts\\n    address[] public allowedTokens;\\n \\n    // Position of the address in the `allowedTokens` array,\\n    // plus 1 because index 0 means a value is not in the set.\\n    mapping(address => uint256) private allowedTokenIndices;\\n\\n    /// @notice Precise number of tokens in the system\\n    uint8 internal constant DECIMALS = 18;\\n\\n    constructor(\\n        address _admin,\\n        address[] memory _addTokenToAllowedListRoleHolders,\\n        address[] memory _removeTokenFromAllowedListRoleHolders\\n    ) {\\n        _setupRole(DEFAULT_ADMIN_ROLE, _admin);\\n        for (uint256 i = 0; i < _addTokenToAllowedListRoleHolders.length; i++) {\\n            _setupRole(ADD_TOKEN_TO_ALLOWED_LIST_ROLE, _addTokenToAllowedListRoleHolders[i]);\\n        }\\n        for (uint256 i = 0; i < _removeTokenFromAllowedListRoleHolders.length; i++) {\\n            _setupRole(REMOVE_TOKEN_FROM_ALLOWED_LIST_ROLE, _removeTokenFromAllowedListRoleHolders[i]);\\n        }\\n    }\\n\\n    // -------------\\n    // EXTERNAL METHODS\\n    // -------------\\n\\n    /// @notice Adds address to list of allowed tokens for payouts\\n    function addToken(address _token) external onlyRole(ADD_TOKEN_TO_ALLOWED_LIST_ROLE) {\\n        require(_token != address(0), ERROR_TOKEN_ADDRESS_IS_ZERO);\\n        require(allowedTokenIndices[_token] == 0, ERROR_TOKEN_ALREADY_ADDED_TO_ALLOWED_LIST);\\n\\n        allowedTokens.push(_token);\\n        allowedTokenIndices[_token] = allowedTokens.length;\\n        emit TokenAdded(_token);\\n    }\\n\\n    /// @notice Removes address from list of allowed tokens for payouts\\n    /// @dev To delete an allowed token from the allowedTokens array in O(1),\\n    /// we swap the element to delete with the last one in the array,\\n    /// and then remove the last element (sometimes called as 'swap and pop').\\n    function removeToken(address _token) external onlyRole(REMOVE_TOKEN_FROM_ALLOWED_LIST_ROLE) {\\n        uint256 index = _getAllowedTokenIndex(_token);\\n        uint256 lastIndex = allowedTokens.length - 1;\\n\\n        if (index != lastIndex) {\\n            address lastAllowedToken = allowedTokens[lastIndex];\\n            allowedTokens[index] = lastAllowedToken;\\n            allowedTokenIndices[lastAllowedToken] = index + 1;\\n        }\\n\\n        allowedTokens.pop();\\n        delete allowedTokenIndices[_token];\\n        emit TokenRemoved(_token);\\n    }\\n\\n    /// @notice Returns if passed address is listed as allowed token in the registry\\n    function isTokenAllowed(address _token) external view returns (bool) {\\n        return allowedTokenIndices[_token] > 0;\\n    }\\n\\n    /// @notice Returns current list of allowed tokens\\n    function getAllowedTokens() external view returns (address[] memory) {\\n        return allowedTokens;\\n    }\\n\\n    /// @notice Transforms amout from token format to precise format\\n    function normalizeAmount(uint256 _tokenAmount, address _token) external view returns (uint256) {\\n        require(_token != address(0), ERROR_TOKEN_ADDRESS_IS_ZERO);\\n\\n        if (_tokenAmount == 0) return 0;\\n\\n        uint8 tokenDecimals = IERC20Metadata(_token).decimals();\\n\\n        if (tokenDecimals == DECIMALS) return _tokenAmount;\\n        if (tokenDecimals > DECIMALS) {\\n            // It's rounded up to fit into limits\\n            // https://github.com/OpenZeppelin/openzeppelin-contracts/blob/3e6c86392c97fbc30d3d20a378a6f58beba08eba/contracts/utils/math/Math.sol#L107\\n            return (_tokenAmount - 1) / 10 ** (tokenDecimals - DECIMALS) + 1;\\n        }\\n        return _tokenAmount * 10 ** (DECIMALS - tokenDecimals);\\n    }\\n\\n    /// @notice Returns precision of the token\\n    function decimals() pure external returns (uint8) {\\n        return DECIMALS;\\n    }\\n\\n    // ------------------\\n    // PRIVATE METHODS\\n    // ------------------\\n\\n    function _getAllowedTokenIndex(address _token) private view returns (uint256 _index) {\\n        _index = allowedTokenIndices[_token];\\n        require(_index > 0, ERROR_TOKEN_NOT_FOUND_IN_ALLOWED_LIST);\\n        _index -= 1;\\n    }\\n}\\n\"\r\n    },\r\n    \"IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\"\r\n    },\r\n    \"IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"libraries\": {\r\n      \"AllowedRecipientsFactory.sol\": {}\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addAllowedRecipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"trustedCaller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"allowedRecipientsRegistry\",\"type\":\"address\"}],\"name\":\"AddAllowedRecipientDeployed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"allowedRecipientsRegistry\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_defaultAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"addRecipientToAllowedListRoleHolders\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"removeRecipientFromAllowedListRoleHolders\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"setLimitParametersRoleHolders\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"updateSpentAmountRoleHolders\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"contract IBokkyPooBahsDateTimeContract\",\"name\":\"bokkyPooBahsDateTimeContract\",\"type\":\"address\"}],\"name\":\"AllowedRecipientsRegistryDeployed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"allowedTokensRegistry\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_defaultAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"addTokenToAllowedListRoleHolders\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"removeTokenFromAllowedListRoleHolders\",\"type\":\"address[]\"}],\"name\":\"AllowedTokensRegistryDeployed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"removeAllowedRecipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"trustedCaller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"allowedRecipientsRegistry\",\"type\":\"address\"}],\"name\":\"RemoveAllowedRecipientDeployed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"topUpAllowedRecipients\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"trustedCaller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"allowedRecipientsRegistry\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"allowedTokenssRegistry\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"finance\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"easyTrack\",\"type\":\"address\"}],\"name\":\"TopUpAllowedRecipientsDeployed\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_trustedCaller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_allowedRecipientsRegistry\",\"type\":\"address\"}],\"name\":\"deployAddAllowedRecipient\",\"outputs\":[{\"internalType\":\"contract AddAllowedRecipient\",\"name\":\"addAllowedRecipient\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_defaultAdmin\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_addRecipientToAllowedListRoleHolders\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"_removeRecipientFromAllowedListRoleHolders\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"_setLimitParametersRoleHolders\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"_updateSpentAmountRoleHolders\",\"type\":\"address[]\"},{\"internalType\":\"contract IBokkyPooBahsDateTimeContract\",\"name\":\"_bokkyPooBahsDateTimeContract\",\"type\":\"address\"}],\"name\":\"deployAllowedRecipientsRegistry\",\"outputs\":[{\"internalType\":\"contract AllowedRecipientsRegistry\",\"name\":\"registry\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_defaultAdmin\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_addTokensToAllowedListRoleHolders\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"_removeTokensFromAllowedListRoleHolders\",\"type\":\"address[]\"}],\"name\":\"deployAllowedTokensRegistry\",\"outputs\":[{\"internalType\":\"contract AllowedTokensRegistry\",\"name\":\"registry\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_trustedCaller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_allowedRecipientsRegistry\",\"type\":\"address\"}],\"name\":\"deployRemoveAllowedRecipient\",\"outputs\":[{\"internalType\":\"contract RemoveAllowedRecipient\",\"name\":\"removeAllowedRecipient\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_trustedCaller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_allowedRecipientsRegistry\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_allowedTokensRegistry\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_finance\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_easyTrack\",\"type\":\"address\"}],\"name\":\"deployTopUpAllowedRecipients\",\"outputs\":[{\"internalType\":\"contract TopUpAllowedRecipients\",\"name\":\"topUpAllowedRecipients\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "AllowedRecipientsFactory", "CompilerVersion": "v0.8.6+commit.11564f7e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "istanbul", "Library": "", "LicenseType": "GNU GPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": ""}