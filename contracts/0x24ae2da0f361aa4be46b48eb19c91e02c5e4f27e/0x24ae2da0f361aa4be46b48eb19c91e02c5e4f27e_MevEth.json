{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/MevEth.sol\": {\r\n      \"content\": \"/// SPDX-License-Identifier: SSPL-1.-0\\n\\npragma solidity ^0.8.19;\\n\\n/*///////////// Mev Protocol ///////////////////////\\n\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28f7\u28e6\u28c4\u2840\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28c0\u2800\u2800\u2800\u2800\\n\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28fc\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28f7\u28e4\u28c0\u2800\u2800\u2800\u2800\u2800\u2809\u2811\u28f6\u28e4\u28c4\u28c0\u28e0\u28e4\u28f6\u28f6\u28ff\u28ff\u28ff\u28ff\u2847\u2800\u2800\u2800\\n\u2800\u2800\u2800\u2800\u28c0\u28f4\u28f6\u28ff\u28f7\u2844\u2800\u2800\u2800\u2800\u28b9\u28ff\u28ff\u28ff\u28ff\u280f\u2801\u2800\u2880\u2804\u2800\u2800\u2808\u2880\u2804\u2800\u2880\u2856\u2801\u2800\u2880\u2800\u2808\u283b\u28ff\u28ff\u28ff\u28ff\u284f\u2800\u2800\u2800\u2800\\n\u2800\u2800\u28a0\u28fe\u28ff\u28ff\u28ff\u28ff\u287f\u2801\u2800\u2800\u2800\u2800\u28b8\u28ff\u28ff\u280f\u2800\u2800\u2880\u2874\u2801\u2800\u2800\u28e0\u2816\u2801\u2880\u281e\u280b\u2800\u28a0\u2847\u28b8\u2844\u2800\u2800\u2808\u28bb\u28ff\u28ff\u2801\u2800\u2800\u2800\u2800\\n\u2800\u28e0\u28ff\u28ff\u28ff\u28ff\u28ff\u281f\u2801\u2800\u2800\u2800\u2800\u2800\u28b8\u287f\u2801\u2800\u2800\u2880\u285e\u2800\u2800\u2880\u2874\u2803\u2800\u28f0\u280b\u2800\u2800\u28f0\u287f\u2800\u285c\u28b3\u2840\u2818\u28e6\u2800\u28bf\u2847\u2800\u2800\u2800\u2800\u2800\\n\u28a0\u28ff\u28ff\u28ff\u28ff\u287f\u2803\u2800\u2800\u2800\u2800\u2800\u2800\u28b0\u28ff\u2803\u2800\u2880\u2806\u285e\u2844\u2800\u28e0\u285e\u2801\u28c0\u28be\u2803\u2800\u28c0\u285c\u28b1\u2807\u28f0\u2801\u2808\u28f7\u2802\u28b8\u2847\u2838\u28f5\u2800\u2800\u2800\u2800\u2800\\n\u28ff\u28ff\u28ff\u28ff\u287f\u2801\u2800\u2800\u2800\u2800\u2800\u2800\u28a0\u28ff\u2807\u2800\u2800\u285c\u28f8\u285f\u2880\u28f4\u284f\u28a0\u28fe\u280b\u284e\u2880\u28fc\u280b\u2880\u284e\u2870\u2803\u2800\u2800\u28ff\u28d3\u2892\u2847\u2800\u28ff\u2800\u2800\u2800\u2800\u2800\\n\u28ff\u28ff\u28ff\u28ff\u2807\u2800\u2800\u2800\u2800\u2800\u2800\u2834\u28bb\u28df\u2880\u28c0\u2880\u28e7\u2847\u28a8\u281f\u28be\u28d4\u287f\u2803\u28b8\u2880\u281e\u2803\u2880\u28fe\u285c\u2801\u2800\u2800\u2800\u284f\u2801\u28a0\u2803\u2800\u28b9\u2800\u2800\u2800\u2800\u2800\\n\u28ff\u28ff\u28ff\u28ff\u2844\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28b8\u28fc\u28b8\u28ff\u285f\u28bb\u28ff\u283f\u28f6\u28ff\u28ff\u28ff\u28f6\u28fe\u28cf\u28c0\u28e0\u28fe\u28ff\u2814\u2812\u2809\u2809\u28a0\u2801\u2846\u2878\u2800\u2848\u28f8\u2800\u2800\u2800\u2800\u2800\\n\u28ff\u28ff\u28ff\u28ff\u28c7\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28f8\u28ff\u28f8\u28ff\u28c7\u28b8\u2803\u2844\u28bb\u2803\u28fe\u28ff\u288b\u2818\u28ff\u28ff\u280f\u28ff\u285f\u28db\u285b\u28bb\u28ff\u28bf\u28f6\u28f7\u28ff\u28f6\u2883\u28ff\u2800\u2800\u2800\u2800\u2800\\n\u28b8\u28ff\u28ff\u28ff\u28ff\u28c6\u2800\u2800\u2800\u2800\u2800\u28f0\u2803\u28ff\u28ff\u28ff\u28ff\u2800\u28f8\u28e7\u2808\u28f8\u28ff\u2803\u2818\u2803\u28b9\u28ff\u2800\u28ff\u2803\u281b\u281b\u28ff\u2847\u28b8\u28ff\u2847\u28b8\u28ff\u287f\u28ff\u2840\u2800\u2800\u2800\u2800\\n\u2800\u283b\u28ff\u28ff\u28ff\u28ff\u28e6\u2840\u2800\u2880\u2854\u28f9\u28fc\u285f\u285f\u28ff\u28ff\u28ff\u281b\u283b\u2836\u283f\u2837\u28fe\u28ff\u28ff\u28ec\u28ff\u28e0\u28ff\u28c0\u28ff\u28ff\u28ff\u2847\u2838\u287f\u2800\u28fe\u284f\u28a0\u28ff\u28c7\u2800\u2800\u2800\u2800\\n\u2800\u2800\u2819\u28bf\u28ff\u28ff\u28ff\u28ff\u28f7\u285e\u28a0\u28ff\u28bf\u2847\u28ff\u2879\u285d\u28bf\u2877\u28c4\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2809\u2809\u2809\u2819\u281b\u281b\u283b\u283f\u28f6\u28f6\u28fe\u28ff\u28c7\u28fe\u2809\u28af\u2803\u2800\u2800\u2800\\n\u2800\u2800\u2800\u2800\u2819\u283f\u28ff\u28ff\u28ff\u2807\u28b8\u2807\u2818\u28c7\u2838\u2847\u28ff\u28ee\u28f3\u2840\u2809\u2802\u2800\u2800\u28c0\u28e4\u2864\u28a4\u28c0\u2800\u2800\u2800\u2800\u2800\u2888\u28ff\u281f\u28e0\u28fe\u283f\u28ff\u2846\u2844\u28e7\u2840\u2800\u2800\\n\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2819\u283b\u2858\u283e\u28c4\u2800\u2818\u28a6\u28ff\u2803\u2839\u28ff\u28ff\u28f6\u2824\u2800\u2800\u28ff\u280b\u2809\u283b\u28ff\u2801\u2800\u2820\u28c0\u28e4\u28fe\u28f5\u28fe\u287f\u2803\u28fe\u280f\u28ff\u28e7\u280b\u2847\u2800\u2800\\n\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28e0\u2816\u2833\u28c4\u2848\u2803\u2800\u283c\u280b\u2819\u28b7\u28de\u28bb\u28ff\u28ff\u28c0\u2840\u2808\u2824\u28c0\u282c\u281f\u2800\u2880\u28e0\u28f6\u283f\u289b\u287d\u280b\u28e0\u28fe\u28cf\u28e0\u287f\u28c3\u28de\u2800\u2800\u2800\\n\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28e7\u2800\u2800\u2800\u2809\u281b\u2813\u2822\u2836\u28f6\u2864\u283a\u285f\u28ba\u28ff\u283f\u28ff\u28f6\u28e4\u28c0\u28e0\u28f4\u28fe\u287f\u283f\u28b5\u280b\u2819\u2832\u28cf\u285d\u2801\u2800\u28f9\u28bf\u2863\u28cc\u2812\u2804\u2800\\n\u2800\u2800\u2800\u2800\u2800\u2800\u28b8\u2808\u2844\u2800\u2807\u2800\u2800\u2856\u2801\u28a2\u285e\u2800\u28b0\u283b\u28c6\u284f\u28c7\u2819\u283b\u28ff\u28ff\u28ff\u28ff\u280b\u2880\u2874\u28ea\u28b7\u2840\u2800\u2858\u2800\u2880\u281c\u2801\u2880\u281f\u2886\u2811\u2884\u2800\\n\u2800\u2800\u2800\u2800\u2800\u2800\u2818\u2844\u2831\u2800\u2838\u2840\u2804\u2833\u2840\u2800\u28b3\u2840\u28b0\u2800\u28b8\u2887\u285f\u2811\u2826\u2888\u2849\u2801\u28bc\u28a0\u284f\u28f4\u281f\u2899\u2807\u2800\u2847\u28a0\u2803\u2880\u2874\u2801\u2800\u2818\u2800\u2808\u2846\\n\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2807\u2800\u2823\u2800\u2857\u28a3\u2840\u2818\u2884\u2800\u28a7\u2800\u28b3\u285f\u281b\u2819\u28e7\u28e7\u28e0\u28c4\u28c0\u28e0\u28bf\u28f6\u2801\u2800\u2838\u2840\u2800\u2813\u281a\u28b4\u28cb\u28e0\u2814\u2800\u2800\u2800\u2800\u2801\\n\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2827\u2864\u2819\u28a4\u2848\u28e6\u287c\u2800\u2800\u2827\u28b6\u281a\u2847\u2808\u2801\u2808\u2803\u2800\u2870\u28bf\u28c4\u2800\u2800\u2811\u28a4\u28c0\u2800\u2800\u2800\u2808\u2801\u2800\u2800\u2800\u2800\u2800\\n\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2880\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\\n///////////////////////////////////////////////////*/\\n\\nimport { Auth } from \\\"./libraries/Auth.sol\\\";\\nimport { SafeTransferLib } from \\\"solmate/utils/SafeTransferLib.sol\\\";\\nimport { FixedPointMathLib } from \\\"solmate/utils/FixedPointMathLib.sol\\\";\\nimport { ERC20 } from \\\"solmate/tokens/ERC20.sol\\\";\\nimport { IERC4626 } from \\\"./interfaces/IERC4626.sol\\\";\\nimport { WETH } from \\\"solmate/tokens/WETH.sol\\\";\\nimport { MevEthErrors } from \\\"./interfaces/Errors.sol\\\";\\nimport { IStakingModule } from \\\"./interfaces/IStakingModule.sol\\\";\\nimport { IERC20Burnable } from \\\"./interfaces/IERC20Burnable.sol\\\";\\nimport { ITinyMevEth } from \\\"./interfaces/ITinyMevEth.sol\\\";\\n\\n/// @title MevEth\\n/// @author CommodityStream, Inc.\\n/// @dev Contract that allows deposit of ETH, for a Liquid Staking Receipt (LSR) in return.\\n/// @dev LSR is represented through an ERC4626 token and interface.\\ncontract MevEth is Auth, ERC20, IERC4626, ITinyMevEth {\\n    using SafeTransferLib for WETH;\\n    using FixedPointMathLib for uint256;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            Configuration Variables\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Inidicates if staking is paused.\\n    bool public stakingPaused;\\n    /// @notice Indicates if contract is initialized.\\n    bool public initialized;\\n    /// @notice withdraw fee denominator\\n    uint16 internal constant feeDenominator = 10_000;\\n    /// @notice Timestamp when pending staking module update can be finalized.\\n    uint64 public pendingStakingModuleCommittedTimestamp;\\n    /// @notice Timestamp when pending mevEthShareVault update can be finalized.\\n    uint64 public pendingMevEthShareVaultCommittedTimestamp;\\n    /// @notice Time delay before staking module or share vault can be finalized.\\n    uint64 internal constant MODULE_UPDATE_TIME_DELAY = 7 days;\\n    /// @notice Max amount of ETH that can be deposited.\\n    uint128 internal constant MAX_DEPOSIT = type(uint128).max;\\n    /// @notice Min amount of ETH that can be deposited.\\n    uint128 public constant MIN_DEPOSIT = 0.01 ether;\\n    /// @notice Min amount of ETH that can be withdrawn via the queue.\\n    uint128 public MIN_WITHDRAWAL;\\n    /// @notice The address of the MevEthShareVault.\\n    address public mevEthShareVault;\\n    /// @notice The address of the pending MevEthShareVault when a new vault has been committed but not finalized.\\n    address public pendingMevEthShareVault;\\n    /// @notice The staking module used to stake Ether.\\n    IStakingModule public stakingModule;\\n    /// @notice The pending staking module when a new module has been committed but not finalized.\\n    IStakingModule public pendingStakingModule;\\n    /// @notice WETH Implementation used by MevEth.\\n    WETH public immutable WETH9;\\n    /// @notice Last rewards payment by block number\\n    uint256 internal lastRewards;\\n    /// @notice Struct used to accounting the ETH staked within MevEth.\\n    Fraction public fraction;\\n    /// @notice The percent out of 1000 crETH2 can be redeemed for as mevEth\\n    uint256 public constant CREAM_TO_MEV_ETH_PERCENT = 1130;\\n    /// @notice The canonical address of the crETH2 address\\n    address public constant creamToken = 0x49D72e3973900A195A155a46441F0C08179FdB64;\\n    /// @notice Sandwich protection mapping of last user deposits by block number\\n    mapping(address => uint256) lastDeposit;\\n    /// @notice Deposited validators mapping to prevent double deposits\\n    mapping(bytes => bool) depositedValidators;\\n\\n    /// @notice Central struct used for share accounting + math.\\n    /// @custom:field elastic   Represents total amount of staked ether, including rewards accrued / slashed.\\n    /// @custom:field base      Represents claims to ownership of the staked ether.\\n    struct Fraction {\\n        uint128 elastic;\\n        uint128 base;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                                Setup\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Construction creates mevETH token, sets authority and weth address.\\n    /// @dev Pending staking module and committed timestamp will both be zero on deployment.\\n    /// @param authority Address of the controlling admin authority.\\n    /// @param weth Address of the WETH contract to use for deposits.\\n    constructor(address authority, address weth) Auth(authority) ERC20(\\\"Mev Liquid Staking Receipt\\\", \\\"mevETH\\\", 18) {\\n        WETH9 = WETH(payable(weth));\\n        MIN_WITHDRAWAL = MIN_DEPOSIT;\\n    }\\n\\n    /// @notice Calculate the needed Ether buffer required when creating a new validator.\\n    /// @return uint256 The required Ether buffer.\\n    function calculateNeededEtherBuffer() public view returns (uint256) {\\n        unchecked {\\n            return max(withdrawalAmountQueued, (stakingModule.VALIDATOR_DEPOSIT_SIZE() / 100) * 90);\\n        }\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            Admin Control Panel\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Event emitted when the MevEth is successfully initialized.\\n    event MevEthInitialized(address indexed mevEthShareVault, address indexed stakingModule);\\n\\n    /// @notice Initializes the MevEth contract, setting the staking module and share vault addresses.\\n    /// @param initialShareVault The initial share vault set during initialization.\\n    /// @param initialStakingModule The initial staking module set during initialization.\\n    /// @dev This function can only be called once and is protected by the onlyAdmin modifier.\\n    function init(address initialShareVault, address initialStakingModule) external onlyAdmin {\\n        // Revert if the initial share vault or staking module is the zero address.\\n        if (initialShareVault == address(0)) {\\n            revert MevEthErrors.ZeroAddress();\\n        }\\n\\n        if (initialStakingModule == address(0)) {\\n            revert MevEthErrors.ZeroAddress();\\n        }\\n\\n        // Revert if the contract has already been initialized.\\n        if (initialized) {\\n            revert MevEthErrors.AlreadyInitialized();\\n        }\\n\\n        // Update state variables and emit event to notify offchain listeners that the contract has been initialized.\\n        initialized = true;\\n        mevEthShareVault = initialShareVault;\\n        stakingModule = IStakingModule(initialStakingModule);\\n        emit MevEthInitialized(initialShareVault, initialStakingModule);\\n    }\\n\\n    /// @notice Emitted when staking is paused.\\n    event StakingPaused();\\n    /// @notice Emitted when staking is unpaused.\\n    event StakingUnpaused();\\n\\n    /// @notice Ensures that staking is not paused when invoking a specific function.\\n    /// @dev This check is used on the createValidator, deposit and mint functions.\\n    function _stakingUnpaused() internal view {\\n        if (stakingPaused) revert MevEthErrors.StakingPaused();\\n    }\\n\\n    /// @notice Pauses staking on the MevEth contract.\\n    /// @dev This function is only callable by addresses with the admin role.\\n    function pauseStaking() external onlyAdmin {\\n        stakingPaused = true;\\n        emit StakingPaused();\\n    }\\n\\n    /// @notice Unauses staking on the MevEth contract.\\n    /// @dev This function is only callable by addresses with the admin role.\\n    function unpauseStaking() external onlyAdmin {\\n        stakingPaused = false;\\n        emit StakingUnpaused();\\n    }\\n\\n    /// @notice Event emitted when a new staking module is committed.\\n    ///   The MODULE_UPDATE_TIME_DELAY must elapse before the staking module update can be finalized.\\n    event StakingModuleUpdateCommitted(address indexed oldModule, address indexed pendingModule, uint64 indexed eligibleForFinalization);\\n\\n    /// @notice Event emitted when a new staking module is finalized.\\n    event StakingModuleUpdateFinalized(address indexed oldModule, address indexed newModule);\\n\\n    /// @notice Event emitted when a new pending module update is canceled.\\n    event StakingModuleUpdateCanceled(address indexed oldModule, address indexed pendingModule);\\n\\n    /// @notice Starts the process to update the staking module.\\n    ///   To finalize the update, the MODULE_UPDATE_TIME_DELAY must elapse\\n    ///   and thefinalizeUpdateStakingModule function must be called.\\n    /// @param newModule The new staking module.\\n    /// @dev This function is only callable by addresses with the admin role.\\n    function commitUpdateStakingModule(IStakingModule newModule) external onlyAdmin {\\n        if (address(newModule) == address(0)) {\\n            revert MevEthErrors.InvalidPendingStakingModule();\\n        }\\n\\n        pendingStakingModule = newModule;\\n        pendingStakingModuleCommittedTimestamp = uint64(block.timestamp);\\n        emit StakingModuleUpdateCommitted(address(stakingModule), address(newModule), uint64(block.timestamp + MODULE_UPDATE_TIME_DELAY));\\n    }\\n\\n    /// @notice Finalizes the staking module update if a pending staking module exists.\\n    /// @dev This function is only callable by addresses with the admin role.\\n    function finalizeUpdateStakingModule() external onlyAdmin {\\n        // Revert if there is no pending staking module or if the the staking module finalization is premature.\\n        uint64 committedTimestamp = pendingStakingModuleCommittedTimestamp;\\n        if (address(pendingStakingModule) == address(0) || committedTimestamp == 0) {\\n            revert MevEthErrors.InvalidPendingStakingModule();\\n        }\\n\\n        if (uint64(block.timestamp) < committedTimestamp + MODULE_UPDATE_TIME_DELAY) {\\n            revert MevEthErrors.PrematureStakingModuleUpdateFinalization();\\n        }\\n\\n        // Emit an event to notify offchain listeners that the staking module has been finalized.\\n        emit StakingModuleUpdateFinalized(address(stakingModule), address(pendingStakingModule));\\n\\n        // Update the staking module\\n        stakingModule = pendingStakingModule;\\n\\n        // Set the pending staking module variables to zero.\\n        pendingStakingModule = IStakingModule(address(0));\\n        pendingStakingModuleCommittedTimestamp = 0;\\n    }\\n\\n    /// @notice Cancels a pending staking module update.\\n    /// @dev This function is only callable by addresses with the admin role.\\n    function cancelUpdateStakingModule() external onlyAdmin {\\n        // Revert if there is no pending staking module.\\n        if (address(pendingStakingModule) == address(0) || pendingStakingModuleCommittedTimestamp == 0) {\\n            revert MevEthErrors.InvalidPendingStakingModule();\\n        }\\n\\n        // Emit an event to notify offchain listeners that the staking module has been canceled.\\n        emit StakingModuleUpdateCanceled(address(stakingModule), address(pendingStakingModule));\\n\\n        // Set the pending staking module variables to zero.\\n        pendingStakingModule = IStakingModule(address(0));\\n        pendingStakingModuleCommittedTimestamp = 0;\\n    }\\n\\n    /// @notice Event emitted when a new share vault is committed. To finalize the update, the MODULE_UPDATE_TIME_DELAY must elapse and the\\n    ///         finalizeUpdateMevEthShareVault function must be called.\\n    event MevEthShareVaultUpdateCommitted(address indexed oldVault, address indexed pendingVault, uint64 indexed eligibleForFinalization);\\n    /// @notice Event emitted when a new share vault is finalized.\\n    event MevEthShareVaultUpdateFinalized(address indexed oldVault, address indexed newVault);\\n    /// @notice Event emitted when a new pending share vault update is canceled.\\n    event MevEthShareVaultUpdateCanceled(address indexed oldVault, address indexed newVault);\\n\\n    /// @notice Starts the process to update the share vault. To finalize the update, the MODULE_UPDATE_TIME_DELAY must elapse and the\\n    ///         finalizeUpdateStakingModule function must be called.\\n    /// @param newMevEthShareVault The new share vault\\n    /// @dev This function is only callable by addresses with the admin role\\n    function commitUpdateMevEthShareVault(address newMevEthShareVault) external onlyAdmin {\\n        if (newMevEthShareVault == address(0)) {\\n            revert MevEthErrors.ZeroAddress();\\n        }\\n        pendingMevEthShareVault = newMevEthShareVault;\\n        pendingMevEthShareVaultCommittedTimestamp = uint64(block.timestamp);\\n        emit MevEthShareVaultUpdateCommitted(mevEthShareVault, newMevEthShareVault, uint64(block.timestamp + MODULE_UPDATE_TIME_DELAY));\\n    }\\n\\n    /// @notice Finalizes the share vault update if a pending share vault exists.\\n    /// @dev This function is only callable by addresses with the admin role.\\n    function finalizeUpdateMevEthShareVault() external onlyAdmin {\\n        // Revert if there is no pending share vault or if the the share vault finalization is premature.\\n        uint64 committedTimestamp = pendingMevEthShareVaultCommittedTimestamp;\\n        if (pendingMevEthShareVault == address(0) || committedTimestamp == 0) {\\n            revert MevEthErrors.InvalidPendingMevEthShareVault();\\n        }\\n\\n        if (uint64(block.timestamp) < committedTimestamp + MODULE_UPDATE_TIME_DELAY) {\\n            revert MevEthErrors.PrematureMevEthShareVaultUpdateFinalization();\\n        }\\n\\n        /// @custom:: When finalizing the update to the MevEthShareVault, make sure to grant any remaining rewards from the existing share vault.\\n        // Emit an event to notify offchain listeners that the share vault has been finalized.\\n        emit MevEthShareVaultUpdateFinalized(mevEthShareVault, address(pendingMevEthShareVault));\\n\\n        // Update the mev share vault\\n        mevEthShareVault = pendingMevEthShareVault;\\n\\n        // Set the pending vault variables to zero\\n        pendingMevEthShareVault = address(0);\\n        pendingMevEthShareVaultCommittedTimestamp = 0;\\n    }\\n\\n    /// @notice Cancels a pending share vault update.\\n    /// @dev This function is only callable by addresses with the admin role.\\n    function cancelUpdateMevEthShareVault() external onlyAdmin {\\n        // Revert if there is no pending share vault.\\n        if (pendingMevEthShareVault == address(0) || pendingMevEthShareVaultCommittedTimestamp == 0) {\\n            revert MevEthErrors.InvalidPendingMevEthShareVault();\\n        }\\n        // Emit an event to notify offchain listeners that the share vault has been canceled.\\n        emit MevEthShareVaultUpdateCanceled(mevEthShareVault, pendingMevEthShareVault);\\n\\n        //Set the pending vault variables to zero\\n        pendingMevEthShareVault = address(0);\\n        pendingMevEthShareVaultCommittedTimestamp = 0;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            Registry For Validators\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Event emitted when a new validator is created\\n    event ValidatorCreated(address indexed stakingModule, IStakingModule.ValidatorData newValidator);\\n\\n    /// @notice This function passes through the needed Ether to the Staking module, and the assosiated credentials with it\\n    /// @param newData The data needed to create a new validator\\n    /// @dev This function is only callable by addresses with the operator role and if staking is unpaused\\n    function createValidator(IStakingModule.ValidatorData calldata newData, bytes32 latestDepositRoot) external onlyOperator {\\n        // check if staking is paused\\n        _stakingUnpaused();\\n        // check validator does not already exist\\n        if (depositedValidators[newData.pubkey]) revert MevEthErrors.AlreadyDeposited();\\n        // set validator deposited to true\\n        depositedValidators[newData.pubkey] = true;\\n        IStakingModule _stakingModule = stakingModule;\\n        // check withdrawal address is correct\\n        if (address(_stakingModule) != address(uint160(uint256(newData.withdrawal_credentials)))) revert MevEthErrors.IncorrectWithdrawalCredentials();\\n        // Determine how big deposit is for the validator\\n        uint256 depositSize = _stakingModule.VALIDATOR_DEPOSIT_SIZE();\\n\\n        if (address(this).balance < depositSize + calculateNeededEtherBuffer()) {\\n            revert MevEthErrors.NotEnoughEth();\\n        }\\n\\n        // Deposit the Ether into the staking contract\\n        _stakingModule.deposit{ value: depositSize }(newData, latestDepositRoot);\\n\\n        emit ValidatorCreated(address(_stakingModule), newData);\\n    }\\n\\n    /// @notice Event emitted when rewards are granted.\\n    event Rewards(address sender, uint256 amount);\\n\\n    /// @notice Grants rewards updating the fraction.elastic.\\n    /// @dev called from validator rewards updates\\n    function grantRewards() external payable {\\n        if (!(msg.sender == address(stakingModule) || msg.sender == mevEthShareVault)) revert MevEthErrors.UnAuthorizedCaller();\\n        if (msg.value == 0) revert MevEthErrors.ZeroValue();\\n\\n        fraction.elastic += uint128(msg.value);\\n        lastRewards = block.number;\\n        emit Rewards(msg.sender, msg.value);\\n    }\\n\\n    /// @notice  Emitted when validator withdraw funds are received.\\n    event ValidatorWithdraw(address sender, uint256 amount);\\n\\n    /// @notice Allows the MevEthShareVault or the staking module to withdraw validator funds from the contract.\\n    /// @dev Before updating the fraction, the withdrawal queue is processed, which pays out any pending withdrawals.\\n    /// @dev This function is only callable by the MevEthShareVault or the staking module.\\n    function grantValidatorWithdraw() external payable {\\n        // Check that the sender is the staking module or the MevEthShareVault.\\n        if (!(msg.sender == address(stakingModule) || msg.sender == mevEthShareVault)) revert MevEthErrors.InvalidSender();\\n\\n        // Check that the value is not zero\\n        if (msg.value != 32 ether) {\\n            revert MevEthErrors.WrongWithdrawAmount();\\n        }\\n\\n        // Emit an event to notify offchain listeners that a validator has withdrawn funds.\\n        emit ValidatorWithdraw(msg.sender, msg.value);\\n\\n        // Register our exit with the staking module\\n        stakingModule.registerExit();\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            WITHDRAWAL QUEUE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Struct representing a withdrawal ticket which is added to the withdrawal queue.\\n    /// @custom:field claimed               True if this receiver has received ticket funds.\\n    /// @custom:field receiver              The receiever of the ETH specified in the WithdrawalTicket.\\n    /// @custom:field amount                The amount of ETH to send to the receiver when the ticket is processed.\\n    /// @custom:field accumulatedAmount     Keep a running sum of all requested ETH\\n    struct WithdrawalTicket {\\n        bool claimed;\\n        address receiver;\\n        uint128 amount;\\n        uint128 accumulatedAmount;\\n    }\\n\\n    /// @notice Event emitted when a withdrawal ticket is added to the queue.\\n    event WithdrawalQueueOpened(address indexed recipient, uint256 indexed withdrawalId, uint256 assets);\\n    event WithdrawalQueueClosed(address indexed recipient, uint256 indexed withdrawalId, uint256 assets);\\n\\n    /// @notice The length of the withdrawal queue.\\n    uint256 public queueLength;\\n\\n    /// @notice  mark the latest withdrawal request that was finalised\\n    uint256 public requestsFinalisedUntil;\\n\\n    /// @notice Withdrawal amount queued\\n    uint256 public withdrawalAmountQueued;\\n\\n    /// @notice The mapping representing the withdrawal queue.\\n    /// @dev The index in the queue is the key, and the value is the WithdrawalTicket.\\n    mapping(uint256 ticketNumber => WithdrawalTicket ticket) public withdrawalQueue;\\n\\n    /// @notice Claim Finalised Withdrawal Ticket\\n    /// @param withdrawalId Unique ID of the withdrawal ticket\\n    function claim(uint256 withdrawalId) external {\\n        if (withdrawalId > requestsFinalisedUntil) revert MevEthErrors.NotFinalised();\\n        WithdrawalTicket storage ticket = withdrawalQueue[withdrawalId];\\n        if (ticket.claimed) revert MevEthErrors.AlreadyClaimed();\\n        withdrawalQueue[withdrawalId].claimed = true;\\n        withdrawalAmountQueued -= uint256(ticket.amount);\\n        emit WithdrawalQueueClosed(ticket.receiver, withdrawalId, uint256(ticket.amount));\\n        WETH9.deposit{ value: uint256(ticket.amount) }();\\n        WETH9.safeTransfer(ticket.receiver, uint256(ticket.amount));\\n    }\\n\\n    /// @notice Processes the withdrawal queue, reserving any pending withdrawals with the contract's available balance.\\n    function processWithdrawalQueue(uint256 newRequestsFinalisedUntil) external onlyOperator {\\n        if (newRequestsFinalisedUntil > queueLength) revert MevEthErrors.IndexExceedsQueueLength();\\n        uint256 balance = address(this).balance;\\n        if (withdrawalAmountQueued >= balance) revert MevEthErrors.NotEnoughEth();\\n        uint256 available = balance - withdrawalAmountQueued;\\n\\n        uint256 finalised = requestsFinalisedUntil;\\n        if (newRequestsFinalisedUntil < finalised) revert MevEthErrors.AlreadyFinalised();\\n\\n        uint256 delta = uint256(withdrawalQueue[newRequestsFinalisedUntil].accumulatedAmount - withdrawalQueue[finalised].accumulatedAmount);\\n        if (available < delta) revert MevEthErrors.NotEnoughEth();\\n\\n        requestsFinalisedUntil = newRequestsFinalisedUntil;\\n        withdrawalAmountQueued += delta;\\n    }\\n\\n    function setMinWithdrawal(uint128 newMinimum) public onlyAdmin {\\n        MIN_WITHDRAWAL = newMinimum;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            ERC4626 Support\\n    //////////////////////////////////////////////////////////////*/\\n    /// @notice The underlying asset of the mevEth contract\\n    /// @return assetTokenAddress The address of the asset token\\n    function asset() external view returns (address assetTokenAddress) {\\n        assetTokenAddress = address(WETH9);\\n    }\\n\\n    /// @notice The total amount of assets controlled by the mevEth contract\\n    /// @return totalManagedAssets The amount of eth controlled by the mevEth contract\\n    function totalAssets() external view returns (uint256 totalManagedAssets) {\\n        // Should return the total amount of Ether managed by the contract\\n        totalManagedAssets = uint256(fraction.elastic);\\n    }\\n\\n    /// @notice Function to convert a specified amount of assets to shares based on the elastic and base.\\n    /// @param assets The amount of assets to convert to shares\\n    /// @return shares The value of the given assets in shares\\n    function convertToShares(uint256 assets) public view returns (uint256 shares) {\\n        // So if there are no shares, then they will mint 1:1 with assets\\n        // Otherwise, shares will mint proportional to the amount of assets\\n        if ((uint256(fraction.elastic) == 0) || (uint256(fraction.base) == 0)) {\\n            shares = assets;\\n        } else {\\n            shares = (assets * uint256(fraction.base)) / uint256(fraction.elastic);\\n        }\\n    }\\n\\n    /// @notice Function to convert a specified amount of shares to assets based on the elastic and base.\\n    /// @param shares The amount of shares to convert to assets\\n    /// @return assets The value of the given shares in assets\\n    function convertToAssets(uint256 shares) public view returns (uint256 assets) {\\n        // So if there are no shares, then they will mint 1:1 with assets\\n        // Otherwise, shares will mint proportional to the amount of assets\\n        if (uint256(fraction.elastic) == 0 || uint256(fraction.base) == 0) {\\n            assets = shares;\\n        } else {\\n            assets = (shares * uint256(fraction.elastic)) / uint256(fraction.base);\\n        }\\n    }\\n\\n    /// @notice Function to indicate the maximum deposit possible.\\n    /// @return maxAssets The maximum amount of assets that can be deposited.\\n    function maxDeposit(address) external view returns (uint256 maxAssets) {\\n        // If staking is paused, then no deposits can be made\\n        if (stakingPaused) {\\n            return 0;\\n        }\\n        // No practical limit on deposit for Ether\\n        maxAssets = uint256(MAX_DEPOSIT);\\n    }\\n\\n    /// @notice Function to simulate the amount of shares that would be minted for a given deposit at the current ratio.\\n    /// @param assets The amount of assets that would be deposited\\n    /// @return shares The amount of shares that would be minted, *under ideal conditions* only\\n    function previewDeposit(uint256 assets) external view returns (uint256 shares) {\\n        return convertToShares(assets);\\n    }\\n\\n    /// @notice internal deposit function to process Weth or Eth deposits\\n    /// @param receiver The address user whom should receive the mevEth out\\n    /// @param assets The amount of assets to deposit\\n    /// @param shares The amount of shares that should be minted\\n    function _deposit(address receiver, uint256 assets, uint256 shares) internal {\\n        // If the deposit is less than the minimum deposit, revert\\n        if (assets < MIN_DEPOSIT) revert MevEthErrors.DepositTooSmall();\\n\\n        fraction.elastic += uint128(assets);\\n        fraction.base += uint128(shares);\\n\\n        // Update last deposit block for the user recorded for sandwich protection\\n        lastDeposit[msg.sender] = block.number;\\n        lastDeposit[receiver] = block.number;\\n\\n        if (msg.value == 0) {\\n            WETH9.safeTransferFrom(msg.sender, address(this), assets);\\n            WETH9.withdraw(assets);\\n        } else {\\n            if (msg.value != assets) revert MevEthErrors.WrongDepositAmount();\\n        }\\n\\n        // Mint MevEth shares to the receiver\\n        _mint(receiver, shares);\\n\\n        // Emit the deposit event to notify offchain listeners that a deposit has occured\\n        emit Deposit(msg.sender, receiver, assets, shares);\\n    }\\n\\n    /// @notice Function to deposit assets into the mevEth contract\\n    /// @param assets The amount of WETH which should be deposited\\n    /// @param receiver The address user whom should receive the mevEth out\\n    /// @return shares The amount of shares minted\\n    function deposit(uint256 assets, address receiver) external payable returns (uint256 shares) {\\n        _stakingUnpaused();\\n\\n        // Convert the assets to shares and update the fraction elastic and base\\n        shares = convertToShares(assets);\\n\\n        // Deposit the assets\\n        _deposit(receiver, assets, shares);\\n    }\\n\\n    /// @notice Function to indicate the maximum amount of shares that can be minted at the current ratio.\\n    /// @return maxShares The maximum amount of shares that can be minted\\n    function maxMint(address) external view returns (uint256 maxShares) {\\n        // If staking is paused, no shares can be minted\\n        if (stakingPaused) {\\n            return 0;\\n        }\\n        // No practical limit on mint for Ether\\n        return MAX_DEPOSIT;\\n    }\\n\\n    /// @notice Function to simulate the amount of assets that would be required to mint a given amount of shares at the current ratio.\\n    /// @param shares The amount of shares that would be minted\\n    /// @return assets The amount of assets that would be required, *under ideal conditions* only\\n    function previewMint(uint256 shares) external view returns (uint256 assets) {\\n        return convertToAssets(shares);\\n    }\\n\\n    /// @notice Function to mint shares of the mevEth contract\\n    /// @param shares The amount of shares that should be minted\\n    /// @param receiver The address user whom should receive the mevEth out\\n    /// @return assets The amount of assets deposited\\n    function mint(uint256 shares, address receiver) external payable returns (uint256 assets) {\\n        _stakingUnpaused();\\n\\n        // Convert the shares to assets and update the fraction elastic and base\\n        assets = convertToAssets(shares);\\n\\n        // Deposit the assets\\n        _deposit(receiver, assets, shares);\\n    }\\n\\n    /// @notice Function to indicate the maximum amount of assets that can be withdrawn at the current state.\\n    /// @param owner The address in question of who would be withdrawing\\n    /// @return maxAssets The maximum amount of assets that can be withdrawn\\n    function maxWithdraw(address owner) external view returns (uint256 maxAssets) {\\n        // Withdrawal is either their maximum balance, or the internal buffer\\n        maxAssets = min(address(this).balance, convertToAssets(balanceOf[owner]));\\n    }\\n\\n    /// @notice Function to simulate the amount of shares that would be allocated for a specified amount of assets.\\n    /// @param assets The amount of assets that would be withdrawn\\n    /// @return shares The amount of shares that would be burned, *under ideal conditions* only\\n    function previewWithdraw(uint256 assets) external view returns (uint256 shares) {\\n        // withdraw fee fixed at 0.01%\\n        uint256 fee = assets / uint256(feeDenominator);\\n        shares = convertToShares(assets + fee);\\n    }\\n\\n    ///@notice Function to withdraw assets from the mevEth contract\\n    /// @param useQueue Flag whether to use the withdrawal queue\\n    /// @param receiver The address user whom should receive the mevEth out\\n    /// @param owner The address of the owner of the mevEth\\n    /// @param assets The amount of assets that should be withdrawn\\n    /// @param shares shares that will be burned\\n    function _withdraw(bool useQueue, address receiver, address owner, uint256 assets, uint256 shares) internal {\\n        // If withdraw is less than the minimum deposit / withdraw amount, revert\\n        if (assets < MIN_WITHDRAWAL) revert MevEthErrors.WithdrawTooSmall();\\n        // Sandwich protection\\n        uint256 blockNumber = block.number;\\n\\n        if (((blockNumber - lastDeposit[msg.sender]) == 0 || (blockNumber - lastDeposit[owner] == 0)) && (blockNumber - lastRewards) == 0) {\\n            revert MevEthErrors.SandwichProtection();\\n        }\\n\\n        _updateAllowance(owner, shares);\\n\\n        // Update the elastic and base\\n        fraction.elastic -= uint128(assets);\\n        fraction.base -= uint128(shares);\\n\\n        // Burn the shares and emit a withdraw event for offchain listeners to know that a withdraw has occured\\n        _burn(owner, shares);\\n\\n        uint256 availableBalance = address(this).balance - withdrawalAmountQueued; // available balance will be adjusted\\n        uint256 amountToSend = assets;\\n        if (availableBalance < assets) {\\n            if (!useQueue) revert MevEthErrors.NotEnoughEth();\\n            // Available balance is sent, and the remainder must be withdrawn via the queue\\n            uint256 amountOwed = assets - availableBalance;\\n            ++queueLength;\\n            withdrawalQueue[queueLength] = WithdrawalTicket({\\n                claimed: false,\\n                receiver: receiver,\\n                amount: uint128(amountOwed),\\n                accumulatedAmount: withdrawalQueue[queueLength - 1].accumulatedAmount + uint128(amountOwed)\\n            });\\n            emit WithdrawalQueueOpened(receiver, queueLength, amountOwed);\\n            amountToSend = availableBalance;\\n        }\\n        if (amountToSend != 0) {\\n            // As with ERC4626, we log assets and shares as if there is no queue, and everything has been withdrawn\\n            // as this most closely resembles what is happened\\n            emit Withdraw(msg.sender, owner, receiver, assets, shares);\\n\\n            WETH9.deposit{ value: amountToSend }();\\n            WETH9.safeTransfer(receiver, amountToSend);\\n        }\\n    }\\n\\n    /// @dev internal function to update allowance for withdraws if necessary\\n    /// @param owner owner of tokens\\n    /// @param shares amount of shares to update\\n    function _updateAllowance(address owner, uint256 shares) internal {\\n        uint256 allowed = allowance[owner][msg.sender];\\n        if (owner != msg.sender) {\\n            if (allowed < shares) revert MevEthErrors.TransferExceedsAllowance();\\n            if (allowed != type(uint256).max) {\\n                unchecked {\\n                    allowance[owner][msg.sender] -= shares;\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @notice Withdraw assets if balance is available\\n    /// @param assets The amount of assets that should be withdrawn\\n    /// @param receiver The address user whom should receive the mevEth out\\n    /// @param owner The address of the owner of the mevEth\\n    /// @return shares The amount of shares burned\\n    function withdraw(uint256 assets, address receiver, address owner) external returns (uint256 shares) {\\n        // withdraw fee fixed at 0.01%\\n        uint256 fee = assets / uint256(feeDenominator);\\n        // Convert the assets to shares and check if the owner has the allowance to withdraw the shares.\\n        shares = convertToShares(assets + fee);\\n\\n        // Withdraw the assets from the MevEth contract\\n        _withdraw(false, receiver, owner, assets, shares);\\n    }\\n\\n    /// @notice Withdraw assets or open queue ticket for claim depending on balance available\\n    /// @param assets The amount of assets that should be withdrawn\\n    /// @param receiver The address user whom should receive the mevEth out\\n    /// @param owner The address of the owner of the mevEth\\n    /// @return shares The amount of shares burned\\n    function withdrawQueue(uint256 assets, address receiver, address owner) external returns (uint256 shares) {\\n        // withdraw fee fixed at 0.01%\\n        uint256 fee = assets / uint256(feeDenominator);\\n        // last shareholder has no fee\\n        if ((fraction.elastic - assets) == 0) fee = 0;\\n        // Convert the assets to shares and check if the owner has the allowance to withdraw the shares.\\n        shares = convertToShares(assets + fee);\\n\\n        // Withdraw the assets from the MevEth contract\\n        _withdraw(true, receiver, owner, assets, shares);\\n    }\\n\\n    ///@notice Function to simulate the maximum amount of shares that can be redeemed by the owner.\\n    /// @param owner The address in question of who would be redeeming their shares\\n    /// @return maxShares The maximum amount of shares they could redeem\\n    function maxRedeem(address owner) external view returns (uint256 maxShares) {\\n        maxShares = min(convertToShares(address(this).balance), balanceOf[owner]);\\n    }\\n\\n    /// @notice Function to simulate the amount of assets that would be withdrawn for a specified amount of shares.\\n    /// @param shares The amount of shares that would be burned\\n    /// @return assets The amount of assets that would be withdrawn, *under ideal conditions* only\\n    function previewRedeem(uint256 shares) external view returns (uint256 assets) {\\n        // withdraw fee fixed at 0.01%\\n        uint256 fee = shares / uint256(feeDenominator);\\n        assets = convertToAssets(shares - fee);\\n    }\\n\\n    /// @notice Function to redeem shares from the mevEth contract\\n    /// @param shares The amount of shares that should be burned\\n    /// @param receiver The address user whom should receive the wETH out\\n    /// @param owner The address of the owner of the mevEth\\n    /// @return assets The amount of assets withdrawn\\n    function redeem(uint256 shares, address receiver, address owner) external returns (uint256 assets) {\\n        // withdraw fee fixed at 0.01%\\n        uint256 fee = shares / uint256(feeDenominator);\\n        // last shareholder has no fee\\n        if ((totalSupply - shares) == 0) fee = 0;\\n        // Convert the shares to assets and check if the owner has the allowance to withdraw the shares.\\n        assets = convertToAssets(shares - fee);\\n\\n        // Withdraw the assets from the MevEth contract\\n        _withdraw(false, receiver, owner, assets, shares);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            Utility Functions\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @dev Returns the largest of two numbers.\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /// @dev Returns the smallest of two numbers.\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n             Special CreamEth2 redeem (from initial migration)\\n     //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Redeem Cream staked eth tokens for mevETH at a fixed ratio\\n    /// @param creamAmount The amount of Cream tokens to redeem\\n    function redeemCream(uint256 creamAmount) external {\\n        _stakingUnpaused();\\n        if (creamAmount == 0) revert MevEthErrors.ZeroValue();\\n\\n        // Calculate the equivalent mevETH to be redeemed based on the ratio\\n        uint256 assets = creamAmount * uint256(CREAM_TO_MEV_ETH_PERCENT) / 1000;\\n        if (assets < MIN_DEPOSIT) revert MevEthErrors.DepositTooSmall();\\n\\n        // Convert the shares to assets and update the fraction elastic and base\\n        uint256 shares = convertToShares(assets);\\n\\n        fraction.elastic += uint128(assets);\\n        fraction.base += uint128(shares);\\n\\n        // Burn CreamEth2 tokens\\n        IERC20Burnable(creamToken).burnFrom(msg.sender, creamAmount);\\n\\n        // Mint the equivalent mevETH\\n        _mint(msg.sender, shares);\\n\\n        // Emit event\\n        emit CreamRedeemed(msg.sender, creamAmount, shares);\\n    }\\n\\n    // Event emitted when Cream tokens are redeemed for mevETH\\n    event CreamRedeemed(address indexed redeemer, uint256 creamAmount, uint256 mevEthAmount);\\n\\n    /// @dev Only Weth withdraw is defined for the behaviour. Deposits should be directed to deposit / mint. Rewards via grantRewards and validator withdraws\\n    /// via grantValidatorWithdraw.\\n    receive() external payable {\\n        if (msg.sender != address(WETH9)) revert MevEthErrors.InvalidSender();\\n    }\\n\\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\\n        uint256 lastDepositFrom = lastDeposit[msg.sender];\\n        if (lastDepositFrom > lastDeposit[to]) {\\n            lastDeposit[to] = lastDepositFrom;\\n        }\\n\\n        return super.transfer(to, amount);\\n    }\\n\\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\\n        uint256 lastDepositFrom = lastDeposit[from];\\n        if (lastDepositFrom > lastDeposit[to]) {\\n            lastDeposit[to] = lastDepositFrom;\\n        }\\n\\n        return super.transferFrom(from, to, amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libraries/Auth.sol\": {\r\n      \"content\": \"/// SPDX-License-Identifier: SSPL-1.-0\\n\\n/**\\n * @custom:org.protocol='mevETH LST Protocol'\\n * @custom:org.security='mailto:security@manifoldfinance.com'\\n * @custom:org.vcs-commit=$GIT_COMMIT_SHA\\n * @custom:org.vendor='CommodityStream, Inc'\\n * @custom:org.schema-version=\\\"1.0\\\"\\n * @custom.org.encryption=\\\"manifoldfinance.com/.well-known/pgp-key.asc\\\"\\n * @custom:org.preferred-languages=\\\"en\\\"\\n */\\n\\npragma solidity ^0.8.19;\\n\\ncontract Auth {\\n    error Unauthorized();\\n    error AlreadySet();\\n    error NoAdmin();\\n\\n    event AdminAdded(address indexed newAdmin);\\n    event AdminDeleted(address indexed oldAdmin);\\n    event OperatorAdded(address indexed newOperator);\\n    event OperatorDeleted(address indexed oldOperator);\\n\\n    // admin counter (assuming 255 admins to be max)\\n    uint8 adminsCounter;\\n\\n    // Keeps track of all operators\\n    mapping(address => bool) public operators;\\n\\n    // Keeps track of all admins\\n    mapping(address => bool) public admins;\\n\\n    /**\\n     * @notice This constructor sets the initialAdmin address as an admin and operator.\\n     * @dev The adminsCounter is incremented unchecked.\\n     */\\n    constructor(address initialAdmin) {\\n        admins[initialAdmin] = true;\\n        unchecked {\\n            ++adminsCounter;\\n        }\\n        operators[initialAdmin] = true;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                           Access Control Modifiers\\n    //////////////////////////////////////////////////////////////*/\\n\\n    modifier onlyAdmin() {\\n        if (!admins[msg.sender]) {\\n            revert Unauthorized();\\n        }\\n        _;\\n    }\\n\\n    modifier onlyOperator() {\\n        if (!operators[msg.sender]) {\\n            revert Unauthorized();\\n        }\\n        _;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                           Maintenance Functions\\n    //////////////////////////////////////////////////////////////*/\\n    /**\\n     * @notice addAdmin() function allows an admin to add a new admin to the contract.\\n     * @dev This function is only accessible to the existing admins and requires the address of the new admin.\\n     * If the new admin is already set, the function will revert. Otherwise, the adminsCounter will be incremented and the new admin will be added to the admins\\n     * mapping. An AdminAdded event will be emitted.\\n     */\\n    function addAdmin(address newAdmin) external onlyAdmin {\\n        if (admins[newAdmin]) revert AlreadySet();\\n        ++adminsCounter;\\n        admins[newAdmin] = true;\\n        emit AdminAdded(newAdmin);\\n    }\\n\\n    /**\\n     * @notice Deletes an admin from the list of admins.\\n     * @dev Only admins can delete other admins. If the adminsCounter is 0, the transaction will revert.\\n     */\\n    function deleteAdmin(address oldAdmin) external onlyAdmin {\\n        if (!admins[oldAdmin]) revert AlreadySet();\\n        --adminsCounter;\\n        if (adminsCounter == 0) revert NoAdmin();\\n        admins[oldAdmin] = false;\\n        emit AdminDeleted(oldAdmin);\\n    }\\n\\n    /**\\n     * @notice Adds a new operator to the list of operators\\n     * @dev Only the admin can add a new operator\\n     * @param newOperator The address of the new operator\\n     */\\n    function addOperator(address newOperator) external onlyAdmin {\\n        if (operators[newOperator]) revert AlreadySet();\\n        operators[newOperator] = true;\\n        emit OperatorAdded(newOperator);\\n    }\\n\\n    function deleteOperator(address oldOperator) external onlyAdmin {\\n        if (!operators[oldOperator]) revert AlreadySet();\\n        operators[oldOperator] = false;\\n        emit OperatorDeleted(oldOperator);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/utils/SafeTransferLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"../tokens/ERC20.sol\\\";\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n/// @dev Caution! This library won't check that a token has code, responsibility is delegated to the caller.\\nlibrary SafeTransferLib {\\n    /*//////////////////////////////////////////////////////////////\\n                             ETH OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        bool success;\\n\\n        assembly {\\n            // Transfer the ETH and store if it succeeded or not.\\n            success := call(gas(), to, amount, 0, 0, 0, 0)\\n        }\\n\\n        require(success, \\\"ETH_TRANSFER_FAILED\\\");\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            ERC20 OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferFrom(\\n        ERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        assembly {\\n            // We'll write our calldata to this slot below, but restore it later.\\n            let memPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(0, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\\n            mstore(4, from) // Append the \\\"from\\\" argument.\\n            mstore(36, to) // Append the \\\"to\\\" argument.\\n            mstore(68, amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 100 because that's the total length of our calldata (4 + 32 * 3)\\n                // Counterintuitively, this call() must be positioned after the or() in the\\n                // surrounding and() because and() evaluates its arguments from right to left.\\n                call(gas(), token, 0, 0, 100, 0, 32)\\n            )\\n\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, memPointer) // Restore the memPointer.\\n        }\\n\\n        require(success, \\\"TRANSFER_FROM_FAILED\\\");\\n    }\\n\\n    function safeTransfer(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        assembly {\\n            // We'll write our calldata to this slot below, but restore it later.\\n            let memPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(0, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\\n            mstore(4, to) // Append the \\\"to\\\" argument.\\n            mstore(36, amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because that's the total length of our calldata (4 + 32 * 2)\\n                // Counterintuitively, this call() must be positioned after the or() in the\\n                // surrounding and() because and() evaluates its arguments from right to left.\\n                call(gas(), token, 0, 0, 68, 0, 32)\\n            )\\n\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, memPointer) // Restore the memPointer.\\n        }\\n\\n        require(success, \\\"TRANSFER_FAILED\\\");\\n    }\\n\\n    function safeApprove(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        assembly {\\n            // We'll write our calldata to this slot below, but restore it later.\\n            let memPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(0, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\\n            mstore(4, to) // Append the \\\"to\\\" argument.\\n            mstore(36, amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because that's the total length of our calldata (4 + 32 * 2)\\n                // Counterintuitively, this call() must be positioned after the or() in the\\n                // surrounding and() because and() evaluates its arguments from right to left.\\n                call(gas(), token, 0, 0, 68, 0, 32)\\n            )\\n\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, memPointer) // Restore the memPointer.\\n        }\\n\\n        require(success, \\\"APPROVE_FAILED\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/utils/FixedPointMathLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\n/// @notice Arithmetic library with operations for fixed-point numbers.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/FixedPointMathLib.sol)\\nlibrary FixedPointMathLib {\\n    /*//////////////////////////////////////////////////////////////\\n                    SIMPLIFIED FIXED POINT OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\\n\\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\\n    }\\n\\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\\n    }\\n\\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\\n    }\\n\\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\\n    }\\n\\n    function powWad(int256 x, int256 y) internal pure returns (int256) {\\n        // Equivalent to x to the power of y because x ** y = (e ** ln(x)) ** y = e ** (ln(x) * y)\\n        return expWad((lnWad(x) * y) / int256(WAD)); // Using ln(x) means x must be greater than 0.\\n    }\\n\\n    function expWad(int256 x) internal pure returns (int256 r) {\\n        unchecked {\\n            // When the result is < 0.5 we return zero. This happens when\\n            // x <= floor(log(0.5e18) * 1e18) ~ -42e18\\n            if (x <= -42139678854452767551) return 0;\\n\\n            // When the result is > (2**255 - 1) / 1e18 we can not represent it as an\\n            // int. This happens when x >= floor(log((2**255 - 1) / 1e18) * 1e18) ~ 135.\\n            if (x >= 135305999368893231589) revert(\\\"EXP_OVERFLOW\\\");\\n\\n            // x is now in the range (-42, 136) * 1e18. Convert to (-42, 136) * 2**96\\n            // for more intermediate precision and a binary basis. This base conversion\\n            // is a multiplication by 1e18 / 2**96 = 5**18 / 2**78.\\n            x = (x << 78) / 5**18;\\n\\n            // Reduce range of x to (-\u00bd ln 2, \u00bd ln 2) * 2**96 by factoring out powers\\n            // of two such that exp(x) = exp(x') * 2**k, where k is an integer.\\n            // Solving this gives k = round(x / log(2)) and x' = x - k * log(2).\\n            int256 k = ((x << 96) / 54916777467707473351141471128 + 2**95) >> 96;\\n            x = x - k * 54916777467707473351141471128;\\n\\n            // k is in the range [-61, 195].\\n\\n            // Evaluate using a (6, 7)-term rational approximation.\\n            // p is made monic, we'll multiply by a scale factor later.\\n            int256 y = x + 1346386616545796478920950773328;\\n            y = ((y * x) >> 96) + 57155421227552351082224309758442;\\n            int256 p = y + x - 94201549194550492254356042504812;\\n            p = ((p * y) >> 96) + 28719021644029726153956944680412240;\\n            p = p * x + (4385272521454847904659076985693276 << 96);\\n\\n            // We leave p in 2**192 basis so we don't need to scale it back up for the division.\\n            int256 q = x - 2855989394907223263936484059900;\\n            q = ((q * x) >> 96) + 50020603652535783019961831881945;\\n            q = ((q * x) >> 96) - 533845033583426703283633433725380;\\n            q = ((q * x) >> 96) + 3604857256930695427073651918091429;\\n            q = ((q * x) >> 96) - 14423608567350463180887372962807573;\\n            q = ((q * x) >> 96) + 26449188498355588339934803723976023;\\n\\n            assembly {\\n                // Div in assembly because solidity adds a zero check despite the unchecked.\\n                // The q polynomial won't have zeros in the domain as all its roots are complex.\\n                // No scaling is necessary because p is already 2**96 too large.\\n                r := sdiv(p, q)\\n            }\\n\\n            // r should be in the range (0.09, 0.25) * 2**96.\\n\\n            // We now need to multiply r by:\\n            // * the scale factor s = ~6.031367120.\\n            // * the 2**k factor from the range reduction.\\n            // * the 1e18 / 2**96 factor for base conversion.\\n            // We do this all at once, with an intermediate result in 2**213\\n            // basis, so the final right shift is always by a positive amount.\\n            r = int256((uint256(r) * 3822833074963236453042738258902158003155416615667) >> uint256(195 - k));\\n        }\\n    }\\n\\n    function lnWad(int256 x) internal pure returns (int256 r) {\\n        unchecked {\\n            require(x > 0, \\\"UNDEFINED\\\");\\n\\n            // We want to convert x from 10**18 fixed point to 2**96 fixed point.\\n            // We do this by multiplying by 2**96 / 10**18. But since\\n            // ln(x * C) = ln(x) + ln(C), we can simply do nothing here\\n            // and add ln(2**96 / 10**18) at the end.\\n\\n            // Reduce range of x to (1, 2) * 2**96\\n            // ln(2^k * x) = k * ln(2) + ln(x)\\n            int256 k = int256(log2(uint256(x))) - 96;\\n            x <<= uint256(159 - k);\\n            x = int256(uint256(x) >> 159);\\n\\n            // Evaluate using a (8, 8)-term rational approximation.\\n            // p is made monic, we will multiply by a scale factor later.\\n            int256 p = x + 3273285459638523848632254066296;\\n            p = ((p * x) >> 96) + 24828157081833163892658089445524;\\n            p = ((p * x) >> 96) + 43456485725739037958740375743393;\\n            p = ((p * x) >> 96) - 11111509109440967052023855526967;\\n            p = ((p * x) >> 96) - 45023709667254063763336534515857;\\n            p = ((p * x) >> 96) - 14706773417378608786704636184526;\\n            p = p * x - (795164235651350426258249787498 << 96);\\n\\n            // We leave p in 2**192 basis so we don't need to scale it back up for the division.\\n            // q is monic by convention.\\n            int256 q = x + 5573035233440673466300451813936;\\n            q = ((q * x) >> 96) + 71694874799317883764090561454958;\\n            q = ((q * x) >> 96) + 283447036172924575727196451306956;\\n            q = ((q * x) >> 96) + 401686690394027663651624208769553;\\n            q = ((q * x) >> 96) + 204048457590392012362485061816622;\\n            q = ((q * x) >> 96) + 31853899698501571402653359427138;\\n            q = ((q * x) >> 96) + 909429971244387300277376558375;\\n            assembly {\\n                // Div in assembly because solidity adds a zero check despite the unchecked.\\n                // The q polynomial is known not to have zeros in the domain.\\n                // No scaling required because p is already 2**96 too large.\\n                r := sdiv(p, q)\\n            }\\n\\n            // r is in the range (0, 0.125) * 2**96\\n\\n            // Finalization, we need to:\\n            // * multiply by the scale factor s = 5.549\u2026\\n            // * add ln(2**96 / 10**18)\\n            // * add k * ln(2)\\n            // * multiply by 10**18 / 2**96 = 5**18 >> 78\\n\\n            // mul s * 5e18 * 2**96, base is now 5**18 * 2**192\\n            r *= 1677202110996718588342820967067443963516166;\\n            // add ln(2) * k * 5e18 * 2**192\\n            r += 16597577552685614221487285958193947469193820559219878177908093499208371 * k;\\n            // add ln(2**96 / 10**18) * 5e18 * 2**192\\n            r += 600920179829731861736702779321621459595472258049074101567377883020018308;\\n            // base conversion: mul 2**18 / 2**192\\n            r >>= 174;\\n        }\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                    LOW LEVEL FIXED POINT OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function mulDivDown(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            // Store x * y in z for now.\\n            z := mul(x, y)\\n\\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\\n                revert(0, 0)\\n            }\\n\\n            // Divide z by the denominator.\\n            z := div(z, denominator)\\n        }\\n    }\\n\\n    function mulDivUp(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            // Store x * y in z for now.\\n            z := mul(x, y)\\n\\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\\n                revert(0, 0)\\n            }\\n\\n            // First, divide z - 1 by the denominator and add 1.\\n            // We allow z - 1 to underflow if z is 0, because we multiply the\\n            // end result by 0 if z is zero, ensuring we return 0 if z is zero.\\n            z := mul(iszero(iszero(z)), add(div(sub(z, 1), denominator), 1))\\n        }\\n    }\\n\\n    function rpow(\\n        uint256 x,\\n        uint256 n,\\n        uint256 scalar\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            switch x\\n            case 0 {\\n                switch n\\n                case 0 {\\n                    // 0 ** 0 = 1\\n                    z := scalar\\n                }\\n                default {\\n                    // 0 ** n = 0\\n                    z := 0\\n                }\\n            }\\n            default {\\n                switch mod(n, 2)\\n                case 0 {\\n                    // If n is even, store scalar in z for now.\\n                    z := scalar\\n                }\\n                default {\\n                    // If n is odd, store x in z for now.\\n                    z := x\\n                }\\n\\n                // Shifting right by 1 is like dividing by 2.\\n                let half := shr(1, scalar)\\n\\n                for {\\n                    // Shift n right by 1 before looping to halve it.\\n                    n := shr(1, n)\\n                } n {\\n                    // Shift n right by 1 each iteration to halve it.\\n                    n := shr(1, n)\\n                } {\\n                    // Revert immediately if x ** 2 would overflow.\\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\\n                    if shr(128, x) {\\n                        revert(0, 0)\\n                    }\\n\\n                    // Store x squared.\\n                    let xx := mul(x, x)\\n\\n                    // Round to the nearest number.\\n                    let xxRound := add(xx, half)\\n\\n                    // Revert if xx + half overflowed.\\n                    if lt(xxRound, xx) {\\n                        revert(0, 0)\\n                    }\\n\\n                    // Set x to scaled xxRound.\\n                    x := div(xxRound, scalar)\\n\\n                    // If n is even:\\n                    if mod(n, 2) {\\n                        // Compute z * x.\\n                        let zx := mul(z, x)\\n\\n                        // If z * x overflowed:\\n                        if iszero(eq(div(zx, x), z)) {\\n                            // Revert if x is non-zero.\\n                            if iszero(iszero(x)) {\\n                                revert(0, 0)\\n                            }\\n                        }\\n\\n                        // Round to the nearest number.\\n                        let zxRound := add(zx, half)\\n\\n                        // Revert if zx + half overflowed.\\n                        if lt(zxRound, zx) {\\n                            revert(0, 0)\\n                        }\\n\\n                        // Return properly scaled zxRound.\\n                        z := div(zxRound, scalar)\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        GENERAL NUMBER UTILITIES\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\\n        assembly {\\n            let y := x // We start y at x, which will help us make our initial estimate.\\n\\n            z := 181 // The \\\"correct\\\" value is 1, but this saves a multiplication later.\\n\\n            // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad\\n            // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.\\n\\n            // We check y >= 2^(k + 8) but shift right by k bits\\n            // each branch to ensure that if x >= 256, then y >= 256.\\n            if iszero(lt(y, 0x10000000000000000000000000000000000)) {\\n                y := shr(128, y)\\n                z := shl(64, z)\\n            }\\n            if iszero(lt(y, 0x1000000000000000000)) {\\n                y := shr(64, y)\\n                z := shl(32, z)\\n            }\\n            if iszero(lt(y, 0x10000000000)) {\\n                y := shr(32, y)\\n                z := shl(16, z)\\n            }\\n            if iszero(lt(y, 0x1000000)) {\\n                y := shr(16, y)\\n                z := shl(8, z)\\n            }\\n\\n            // Goal was to get z*z*y within a small factor of x. More iterations could\\n            // get y in a tighter range. Currently, we will have y in [256, 256*2^16).\\n            // We ensured y >= 256 so that the relative difference between y and y+1 is small.\\n            // That's not possible if x < 256 but we can just verify those cases exhaustively.\\n\\n            // Now, z*z*y <= x < z*z*(y+1), and y <= 2^(16+8), and either y >= 256, or x < 256.\\n            // Correctness can be checked exhaustively for x < 256, so we assume y >= 256.\\n            // Then z*sqrt(y) is within sqrt(257)/sqrt(256) of sqrt(x), or about 20bps.\\n\\n            // For s in the range [1/256, 256], the estimate f(s) = (181/1024) * (s+1) is in the range\\n            // (1/2.84 * sqrt(s), 2.84 * sqrt(s)), with largest error when s = 1 and when s = 256 or 1/256.\\n\\n            // Since y is in [256, 256*2^16), let a = y/65536, so that a is in [1/256, 256). Then we can estimate\\n            // sqrt(y) using sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2^18.\\n\\n            // There is no overflow risk here since y < 2^136 after the first branch above.\\n            z := shr(18, mul(z, add(y, 65536))) // A mul() is saved from starting z at 181.\\n\\n            // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n\\n            // If x+1 is a perfect square, the Babylonian method cycles between\\n            // floor(sqrt(x)) and ceil(sqrt(x)). This statement ensures we return floor.\\n            // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division\\n            // Since the ceil is rare, we save gas on the assignment and repeat division in the rare case.\\n            // If you don't care whether the floor or ceil square root is returned, you can remove this statement.\\n            z := sub(z, lt(div(x, z), z))\\n        }\\n    }\\n\\n    function log2(uint256 x) internal pure returns (uint256 r) {\\n        require(x > 0, \\\"UNDEFINED\\\");\\n\\n        assembly {\\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\\n            r := or(r, shl(2, lt(0xf, shr(r, x))))\\n            r := or(r, shl(1, lt(0x3, shr(r, x))))\\n            r := or(r, lt(0x1, shr(r, x)))\\n        }\\n    }\\n\\n    function unsafeMod(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        assembly {\\n            // z will equal 0 if y is 0, unlike in Solidity where it will revert.\\n            z := mod(x, y)\\n        }\\n    }\\n\\n    function unsafeDiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        assembly {\\n            // z will equal 0 if y is 0, unlike in Solidity where it will revert.\\n            z := div(x, y)\\n        }\\n    }\\n\\n    /// @dev Will return 0 instead of reverting if y is zero.\\n    function unsafeDivUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        assembly {\\n            // Add 1 to x * y if x % y > 0.\\n            z := add(gt(mod(x, y), 0), div(x, y))\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/tokens/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\\nabstract contract ERC20 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    uint8 public immutable decimals;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            EIP-2612 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\n\\n    mapping(address => uint256) public nonces;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n\\n        INITIAL_CHAIN_ID = block.chainid;\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        balanceOf[msg.sender] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\n\\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\\n\\n        balanceOf[from] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             EIP-2612 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        require(deadline >= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\n\\n        // Unchecked because the only math done is incrementing\\n        // the owner's nonce which cannot realistically overflow.\\n        unchecked {\\n            address recoveredAddress = ecrecover(\\n                keccak256(\\n                    abi.encodePacked(\\n                        \\\"\\\\x19\\\\x01\\\",\\n                        DOMAIN_SEPARATOR(),\\n                        keccak256(\\n                            abi.encode(\\n                                keccak256(\\n                                    \\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\"\\n                                ),\\n                                owner,\\n                                spender,\\n                                value,\\n                                nonces[owner]++,\\n                                deadline\\n                            )\\n                        )\\n                    )\\n                ),\\n                v,\\n                r,\\n                s\\n            );\\n\\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"INVALID_SIGNER\\\");\\n\\n            allowance[recoveredAddress][spender] = value;\\n        }\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\n    }\\n\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                    keccak256(bytes(name)),\\n                    keccak256(\\\"1\\\"),\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        totalSupply += amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        balanceOf[from] -= amount;\\n\\n        // Cannot underflow because a user's balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply -= amount;\\n        }\\n\\n        emit Transfer(from, address(0), amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IERC4626.sol\": {\r\n      \"content\": \"/// SPDX-License-Identifier: SSPL-1.-0\\n\\n/**\\n * @custom:org.protocol='mevETH LST Protocol'\\n * @custom:org.security='mailto:security@manifoldfinance.com'\\n * @custom:org.vcs-commit=$GIT_COMMIT_SHA\\n * @custom:org.vendor='CommodityStream, Inc'\\n * @custom:org.schema-version=\\\"1.0\\\"\\n * @custom.org.encryption=\\\"manifoldfinance.com/.well-known/pgp-key.asc\\\"\\n * @custom:org.preferred-languages=\\\"en\\\"\\n */\\n\\npragma solidity ^0.8.19;\\n\\n// Also a superset of ERC20 but due to some solmate <-> OZ IERC20 nastiness this interface doesn't include it\\ninterface IERC4626 {\\n    /// @return assetTokenAddress The address of the asset token\\n    function asset() external view returns (address assetTokenAddress);\\n\\n    /// @return totalManagedAssets The amount of eth controlled by the vault\\n    function totalAssets() external view returns (uint256 totalManagedAssets);\\n\\n    /// @param assets The amount of assets to convert to shares\\n    /// @return shares The value of the given assets in shares\\n    function convertToShares(uint256 assets) external view returns (uint256 shares);\\n\\n    /// @param shares The amount of shares to convert to assets\\n    /// @return assets The value of the given shares in assets\\n    function convertToAssets(uint256 shares) external view returns (uint256 assets);\\n\\n    /// @param reciever The address in question of who would be depositing, doesn't matter in this case\\n    /// @return maxAssets The maximum amount of assets that can be deposited\\n    function maxDeposit(address reciever) external view returns (uint256 maxAssets);\\n\\n    /// @param assets The amount of assets that would be deposited\\n    /// @return shares The amount of shares that would be minted, *under ideal conditions* only\\n    function previewDeposit(uint256 assets) external view returns (uint256 shares);\\n\\n    /// @param assets The amount of WETH which should be deposited\\n    /// @param receiver The address user whom should recieve the mevEth out\\n    /// @return shares The amount of shares minted\\n    function deposit(uint256 assets, address receiver) external payable returns (uint256 shares);\\n\\n    /// @param reciever The address in question of who would be minting, doesn't matter in this case\\n    /// @return maxShares The maximum amount of shares that can be minted\\n    function maxMint(address reciever) external view returns (uint256 maxShares);\\n\\n    /// @param shares The amount of shares that would be minted\\n    /// @return assets The amount of assets that would be required, *under ideal conditions* only\\n    function previewMint(uint256 shares) external view returns (uint256 assets);\\n\\n    /// @param shares The amount of shares that should be minted\\n    /// @param receiver The address user whom should recieve the mevEth out\\n    /// @return assets The amount of assets deposited\\n    function mint(uint256 shares, address receiver) external payable returns (uint256 assets);\\n\\n    /// @param owner The address in question of who would be withdrawing\\n    /// @return maxAssets The maximum amount of assets that can be withdrawn\\n    function maxWithdraw(address owner) external view returns (uint256 maxAssets);\\n\\n    /// @param assets The amount of assets that would be withdrawn\\n    /// @return shares The amount of shares that would be burned, *under ideal conditions* only\\n    function previewWithdraw(uint256 assets) external view returns (uint256 shares);\\n\\n    /// @param assets The amount of assets that should be withdrawn\\n    /// @param receiver The address user whom should recieve the mevEth out\\n    /// @param owner The address of the owner of the mevEth\\n    /// @return shares The amount of shares burned\\n    function withdraw(uint256 assets, address receiver, address owner) external returns (uint256 shares);\\n\\n    /// @param owner The address in question of who would be redeeming their shares\\n    /// @return maxShares The maximum amount of shares they could redeem\\n    function maxRedeem(address owner) external view returns (uint256 maxShares);\\n\\n    /// @param shares The amount of shares that would be burned\\n    /// @return assets The amount of assets that would be withdrawn, *under ideal conditions* only\\n    function previewRedeem(uint256 shares) external view returns (uint256 assets);\\n\\n    /// @param shares The amount of shares that should be burned\\n    /// @param receiver The address user whom should recieve the wETH out\\n    /// @param owner The address of the owner of the mevEth\\n    /// @return assets The amount of assets withdrawn\\n    function redeem(uint256 shares, address receiver, address owner) external returns (uint256 assets);\\n\\n    /**\\n     * @dev Emitted when a deposit is made, either through mint or deposit\\n     */\\n    event Deposit(address indexed caller, address indexed owner, uint256 assets, uint256 shares);\\n\\n    /**\\n     * @dev Emitted when a withdrawal is made, either through redeem or withdraw\\n     */\\n    event Withdraw(address indexed caller, address indexed receiver, address indexed owner, uint256 assets, uint256 shares);\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/tokens/WETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"./ERC20.sol\\\";\\n\\nimport {SafeTransferLib} from \\\"../utils/SafeTransferLib.sol\\\";\\n\\n/// @notice Minimalist and modern Wrapped Ether implementation.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/WETH.sol)\\n/// @author Inspired by WETH9 (https://github.com/dapphub/ds-weth/blob/master/src/weth9.sol)\\ncontract WETH is ERC20(\\\"Wrapped Ether\\\", \\\"WETH\\\", 18) {\\n    using SafeTransferLib for address;\\n\\n    event Deposit(address indexed from, uint256 amount);\\n\\n    event Withdrawal(address indexed to, uint256 amount);\\n\\n    function deposit() public payable virtual {\\n        _mint(msg.sender, msg.value);\\n\\n        emit Deposit(msg.sender, msg.value);\\n    }\\n\\n    function withdraw(uint256 amount) public virtual {\\n        _burn(msg.sender, amount);\\n\\n        emit Withdrawal(msg.sender, amount);\\n\\n        msg.sender.safeTransferETH(amount);\\n    }\\n\\n    receive() external payable virtual {\\n        deposit();\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/Errors.sol\": {\r\n      \"content\": \"/// SPDX-License-Identifier: SSPL-1.-0\\n\\n/**\\n * @custom:org.protocol='mevETH LST Protocol'\\n * @custom:org.security='mailto:security@manifoldfinance.com'\\n * @custom:org.vcs-commit=$GIT_COMMIT_SHA\\n * @custom:org.vendor='CommodityStream, Inc'\\n * @custom:org.schema-version=\\\"1.0\\\"\\n * @custom.org.encryption=\\\"manifoldfinance.com/.well-known/pgp-key.asc\\\"\\n * @custom:org.preferred-languages=\\\"en\\\"\\n */\\n\\npragma solidity ^0.8.19;\\n\\ninterface MevEthErrors {\\n    /// Errors\\n    error StakingPaused();\\n    error NotEnoughEth();\\n    error ZeroValue();\\n    error InvalidOperator();\\n    error DepositTooSmall();\\n    error InvalidSender();\\n    error PrematureStakingModuleUpdateFinalization();\\n    error PrematureMevEthShareVaultUpdateFinalization();\\n    error InvalidPendingStakingModule();\\n    error InvalidPendingMevEthShareVault();\\n    error TransferExceedsAllowance();\\n    error TransferFailed();\\n    error ZeroAddress();\\n    error AlreadyInitialized();\\n    error SendError();\\n    error FeesTooHigh();\\n    error WrongDepositAmount();\\n    error WrongWithdrawAmount();\\n    error UnAuthorizedCaller();\\n    error WithdrawTooSmall();\\n    error NotFinalised();\\n    error AlreadyClaimed();\\n    error AlreadyFinalised();\\n    error IndexExceedsQueueLength();\\n    error DepositWasFrontrun();\\n    error SandwichProtection();\\n    error NonZeroVaultBalance();\\n    error AlreadyDeposited();\\n    error IncorrectWithdrawalCredentials();\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IStakingModule.sol\": {\r\n      \"content\": \"/// SPDX-License-Identifier: SSPL-1.-0\\n\\n/**\\n * @custom:org.protocol='mevETH LST Protocol'\\n * @custom:org.security='mailto:security@manifoldfinance.com'\\n * @custom:org.vcs-commit=$GIT_COMMIT_SHA\\n * @custom:org.vendor='CommodityStream, Inc'\\n * @custom:org.schema-version=\\\"1.0\\\"\\n * @custom.org.encryption=\\\"manifoldfinance.com/.well-known/pgp-key.asc\\\"\\n * @custom:org.preferred-languages=\\\"en\\\"\\n */\\n\\npragma solidity ^0.8.19;\\n\\ninterface IStakingModule {\\n    /**\\n     * @dev Structure for passing information about the validator deposit data.\\n     * @param operator - address of the operator.\\n     * @param pubkey - BLS public key of the validator, generated by the operator.\\n     * @param withdrawal_credentials - withdrawal credentials used for generating the deposit data.\\n     * @param signature - BLS signature of the validator, generated by the operator.\\n     * @param deposit_data_root - hash tree root of the deposit data, generated by the operator.\\n     */\\n    struct ValidatorData {\\n        address operator;\\n        bytes pubkey;\\n        bytes32 withdrawal_credentials;\\n        bytes signature;\\n        bytes32 deposit_data_root; // more efficient to be calculated off-chain\\n    }\\n\\n    /**\\n     * @dev Allows users to deposit funds into the contract.\\n     * @param data ValidatorData calldata containing the validator's public key, withdrawal credentials, and amount of tokens to be deposited.\\n     * @param latestDepositRoot bytes32 containing the latest deposit root.\\n     */\\n    function deposit(ValidatorData calldata data, bytes32 latestDepositRoot) external payable;\\n\\n    function validators() external view returns (uint256);\\n\\n    function mevEth() external view returns (address);\\n\\n    /**\\n     * @notice VALIDATOR_DEPOSIT_SIZE()\\n     *\\n     * This function returns the size of the validator deposit.\\n     *\\n     * @dev This function is used to determine the size of the validator deposit. It is used to ensure that validators have the correct amount of funds in order\\n     * to participate in the network.\\n     */\\n    function VALIDATOR_DEPOSIT_SIZE() external view returns (uint256);\\n\\n    // onlyAdmin Functions\\n    /**\\n     * @notice This function is used to pay rewards to the users.\\n     * @dev This function is used to pay rewards to the users. It takes in a uint256 rewards parameter which is the amount of rewards to be paid.\\n     */\\n    function payRewards(uint256 rewards) external;\\n    /**\\n     * @notice This function allows a validator to withdraw their rewards from the contract.\\n     * @dev This function is called by a validator to withdraw their rewards from the contract. It will transfer the rewards to the validator's address.\\n     */\\n    function payValidatorWithdraw() external;\\n    function recoverToken(address token, address recipient, uint256 amount) external;\\n    /**\\n     * @notice record() function is used to record the data in the smart contract.\\n     * @dev record() function takes no parameters and returns four uint128 values.\\n     */\\n    function record() external returns (uint128, uint128, uint128, uint128);\\n    /**\\n     * @notice registerExit() allows users to exit the system.\\n     * @dev registerExit() is a function that allows users to exit the system. It is triggered by an external call.\\n     */\\n    function registerExit() external;\\n\\n    function batchMigrate(IStakingModule.ValidatorData[] calldata batchData) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IERC20Burnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\ninterface IERC20Burnable {\\n    function burnFrom(address account, uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ITinyMevEth.sol\": {\r\n      \"content\": \"/// SPDX-License-Identifier: SSPL-1.-0\\n\\n/**\\n * @custom:org.protocol='mevETH LST Protocol'\\n * @custom:org.security='mailto:security@manifoldfinance.com'\\n * @custom:org.vcs-commit=$GIT_COMMIT_SHA\\n * @custom:org.vendor='CommodityStream, Inc'\\n * @custom:org.schema-version=\\\"1.0\\\"\\n * @custom.org.encryption=\\\"manifoldfinance.com/.well-known/pgp-key.asc\\\"\\n * @custom:org.preferred-languages=\\\"en\\\"\\n */\\n\\npragma solidity ^0.8.19;\\n\\n/// @title TinyMevEth\\n/// @notice smol interface for interacting with MevEth\\ninterface ITinyMevEth {\\n    /**\\n     * @dev Function to grant rewards to other users.\\n     * @notice This function is payable and should be called with the amount of rewards to be granted.\\n     */\\n    function grantRewards() external payable;\\n    /**\\n     * @dev Function to allow a validator to withdraw funds from the contract.\\n     * @notice This function must be called with a validator address and a payable amount.\\n     */\\n    function grantValidatorWithdraw() external payable;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"solmate/=lib/solmate/src/\",\r\n      \"@openzeppelin/=lib/openzeppelin-contracts/\",\r\n      \"safe-contracts/=lib/safe-tools/lib/safe-contracts/contracts/\",\r\n      \"safe-tools/=lib/safe-tools/src/\",\r\n      \"properties/=lib/properties/contracts/\",\r\n      \"solady/utils/=lib/solady/src/utils/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 512,\r\n      \"details\": {\r\n        \"constantOptimizer\": true,\r\n        \"yul\": true,\r\n        \"yulDetails\": {\r\n          \"stackAllocation\": true\r\n        }\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"none\",\r\n      \"appendCBOR\": false\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"viaIR\": true,\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"authority\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"weth\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AlreadyClaimed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AlreadyDeposited\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AlreadyFinalised\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AlreadyInitialized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AlreadySet\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DepositTooSmall\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"IncorrectWithdrawalCredentials\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"IndexExceedsQueueLength\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidPendingMevEthShareVault\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidPendingStakingModule\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSender\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoAdmin\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotEnoughEth\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotFinalised\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PrematureMevEthShareVaultUpdateFinalization\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PrematureStakingModuleUpdateFinalization\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SandwichProtection\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"StakingPaused\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferExceedsAllowance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnAuthorizedCaller\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Unauthorized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WithdrawTooSmall\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WrongDepositAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WrongWithdrawAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroValue\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"AdminAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldAdmin\",\"type\":\"address\"}],\"name\":\"AdminDeleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"redeemer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"creamAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mevEthAmount\",\"type\":\"uint256\"}],\"name\":\"CreamRedeemed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"mevEthShareVault\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"stakingModule\",\"type\":\"address\"}],\"name\":\"MevEthInitialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldVault\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newVault\",\"type\":\"address\"}],\"name\":\"MevEthShareVaultUpdateCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldVault\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pendingVault\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"eligibleForFinalization\",\"type\":\"uint64\"}],\"name\":\"MevEthShareVaultUpdateCommitted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldVault\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newVault\",\"type\":\"address\"}],\"name\":\"MevEthShareVaultUpdateFinalized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOperator\",\"type\":\"address\"}],\"name\":\"OperatorAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldOperator\",\"type\":\"address\"}],\"name\":\"OperatorDeleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Rewards\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldModule\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pendingModule\",\"type\":\"address\"}],\"name\":\"StakingModuleUpdateCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldModule\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pendingModule\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"eligibleForFinalization\",\"type\":\"uint64\"}],\"name\":\"StakingModuleUpdateCommitted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldModule\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newModule\",\"type\":\"address\"}],\"name\":\"StakingModuleUpdateFinalized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"StakingPaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"StakingUnpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"stakingModule\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"pubkey\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"withdrawal_credentials\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"deposit_data_root\",\"type\":\"bytes32\"}],\"indexed\":false,\"internalType\":\"struct IStakingModule.ValidatorData\",\"name\":\"newValidator\",\"type\":\"tuple\"}],\"name\":\"ValidatorCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ValidatorWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"withdrawalId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"}],\"name\":\"WithdrawalQueueClosed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"withdrawalId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"}],\"name\":\"WithdrawalQueueOpened\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CREAM_TO_MEV_ETH_PERCENT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_DEPOSIT\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_WITHDRAWAL\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WETH9\",\"outputs\":[{\"internalType\":\"contract WETH\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"addAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOperator\",\"type\":\"address\"}],\"name\":\"addOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"admins\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"asset\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"assetTokenAddress\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"calculateNeededEtherBuffer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cancelUpdateMevEthShareVault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cancelUpdateStakingModule\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"withdrawalId\",\"type\":\"uint256\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newMevEthShareVault\",\"type\":\"address\"}],\"name\":\"commitUpdateMevEthShareVault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IStakingModule\",\"name\":\"newModule\",\"type\":\"address\"}],\"name\":\"commitUpdateStakingModule\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"name\":\"convertToAssets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"}],\"name\":\"convertToShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"creamToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"pubkey\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"withdrawal_credentials\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"deposit_data_root\",\"type\":\"bytes32\"}],\"internalType\":\"struct IStakingModule.ValidatorData\",\"name\":\"newData\",\"type\":\"tuple\"},{\"internalType\":\"bytes32\",\"name\":\"latestDepositRoot\",\"type\":\"bytes32\"}],\"name\":\"createValidator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"oldAdmin\",\"type\":\"address\"}],\"name\":\"deleteAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"oldOperator\",\"type\":\"address\"}],\"name\":\"deleteOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"deposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"finalizeUpdateMevEthShareVault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"finalizeUpdateStakingModule\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fraction\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"elastic\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"base\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"grantRewards\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"grantValidatorWithdraw\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"initialShareVault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"initialStakingModule\",\"type\":\"address\"}],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"maxDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"maxAssets\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"maxMint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"maxShares\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"maxRedeem\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"maxShares\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"maxWithdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"maxAssets\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mevEthShareVault\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"operators\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pauseStaking\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingMevEthShareVault\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingMevEthShareVaultCommittedTimestamp\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingStakingModule\",\"outputs\":[{\"internalType\":\"contract IStakingModule\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingStakingModuleCommittedTimestamp\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"}],\"name\":\"previewDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"name\":\"previewMint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"name\":\"previewRedeem\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"}],\"name\":\"previewWithdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newRequestsFinalisedUntil\",\"type\":\"uint256\"}],\"name\":\"processWithdrawalQueue\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"queueLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"redeem\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"creamAmount\",\"type\":\"uint256\"}],\"name\":\"redeemCream\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"requestsFinalisedUntil\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"newMinimum\",\"type\":\"uint128\"}],\"name\":\"setMinWithdrawal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingModule\",\"outputs\":[{\"internalType\":\"contract IStakingModule\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalAssets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalManagedAssets\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpauseStaking\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"withdrawQueue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawalAmountQueued\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ticketNumber\",\"type\":\"uint256\"}],\"name\":\"withdrawalQueue\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"claimed\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint128\",\"name\":\"amount\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"accumulatedAmount\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "MevEth", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "512", "ConstructorArguments": "00000000000000000000000018f3e9ab3dcd396c2d3e6e598a9f77621ea50fc3000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}