{"SourceCode": "pragma solidity ^0.4.15;\r\n\r\n/**\r\n  * Math operations with safety checks\r\n  */\r\nlibrary SafeMath {\r\n    function safeMul(uint a, uint b) internal returns (uint) {\r\n        uint c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function safeDiv(uint a, uint b) internal returns (uint) {\r\n        assert(b > 0);\r\n        uint c = a / b;\r\n        assert(a == b * c + a % b);\r\n        return c;\r\n    }\r\n\r\n    function safeSub(uint a, uint b) internal returns (uint) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function safeAdd(uint a, uint b) internal returns (uint) {\r\n        uint c = a + b;\r\n        assert(c>=a && c>=b);\r\n        return c;\r\n    }\r\n\r\n    function max64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    function min64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    function max256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    function min256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n}\r\n\r\n\r\n/*\r\n  * ERC20 interface\r\n  * see https://github.com/ethereum/EIPs/issues/20\r\n  */\r\ncontract ERC20 {\r\n    uint public totalSupply;\r\n    function balanceOf(address who) constant returns (uint);\r\n    function allowance(address owner, address spender) constant returns (uint);\r\n\r\n    function transfer(address to, uint value) returns (bool ok);\r\n    function transferFrom(address from, address to, uint value) returns (bool ok);\r\n    function approve(address spender, uint value) returns (bool ok);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\n\r\n\r\n/**\r\n  * Standard ERC20 token with Short Hand Attack and approve() race condition mitigation.\r\n  *\r\n  * Based on code by FirstBlood:\r\n  * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n  */\r\ncontract StandardToken is ERC20\r\n{\r\n    using SafeMath for uint;\r\n\r\n    mapping(address => uint) balances;\r\n    mapping(address => mapping (address => uint)) allowed;\r\n\r\n    // Interface marker\r\n    bool public constant isToken = true;\r\n\r\n    /**\r\n      * Fix for the ERC20 short address attack\r\n      *\r\n      * http://vessenes.com/the-erc20-short-address-attack-explained/\r\n      */\r\n    modifier onlyPayloadSize(uint size) {\r\n        require(msg.data.length == size + 4);\r\n        _;\r\n    }\r\n\r\n    function transfer(address _to, uint _value)\r\n        onlyPayloadSize(2 * 32)\r\n        returns (bool success)\r\n    {\r\n        balances[msg.sender] = balances[msg.sender].safeSub(_value);\r\n        balances[_to] = balances[_to].safeAdd(_value);\r\n\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address from, address to, uint value)\r\n        returns (bool success)\r\n    {\r\n        uint _allowance = allowed[from][msg.sender];\r\n\r\n        // Check is not needed because _allowance.safeSub(value) will throw if this condition is not met\r\n        // if (value > _allowance) throw;\r\n\r\n        balances[to] = balances[to].safeAdd(value);\r\n        balances[from] = balances[from].safeSub(value);\r\n        allowed[from][msg.sender] = _allowance.safeSub(value);\r\n\r\n        Transfer(from, to, value);\r\n        return true;\r\n    }\r\n\r\n    function balanceOf(address account)\r\n        constant\r\n        returns (uint balance)\r\n    {\r\n        return balances[account];\r\n    }\r\n\r\n    function approve(address spender, uint value)\r\n        returns (bool success)\r\n    {\r\n        // To change the approve amount you first have to reduce the addresses`\r\n        //  allowance to zero by calling `approve(spender, 0)` if it is not\r\n        //  already 0 to mitigate the race condition described here:\r\n        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n        if ((value != 0) && (allowed[msg.sender][spender] != 0)) throw;\r\n\r\n        allowed[msg.sender][spender] = value;\r\n\r\n        Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address account, address spender)\r\n        constant\r\n        returns (uint remaining)\r\n    {\r\n        return allowed[account][spender];\r\n    }\r\n}\r\n\r\n\r\n\r\n/**\r\n  * Upgrade target interface inspired by Lunyr.\r\n  *\r\n  * Upgrade agent transfers tokens to a new contract.\r\n  * Upgrade agent itself can be the token contract, or just a middle man contract doing the heavy lifting.\r\n  */\r\ncontract UpgradeTarget\r\n{\r\n    uint public originalSupply;\r\n\r\n    /** Interface marker */\r\n    function isUpgradeTarget() public constant returns (bool) {\r\n        return true;\r\n    }\r\n\r\n    function upgradeFrom(address _from, uint256 _value) public;\r\n}\r\n\r\n\r\n/**\r\n  * A token upgrade mechanism where users can opt-in amount of tokens to the next smart contract revision.\r\n  *\r\n  * First envisioned by Golem and Lunyr projects.\r\n  */\r\ncontract UpgradeableToken is StandardToken\r\n{\r\n    /** Contract / person who can set the upgrade path. This can be the same as team multisig wallet, as what it is with its default value. */\r\n    address public upgradeMaster;\r\n\r\n    /** The next contract where the tokens will be migrated. */\r\n    UpgradeTarget public upgradeTarget;\r\n\r\n    /** How many tokens we have upgraded by now. */\r\n    uint256 public totalUpgraded;\r\n\r\n    /**\r\n      * Upgrade states.\r\n      *\r\n      * - NotAllowed: The child contract has not reached a condition where the upgrade can bgun\r\n      * - WaitingForAgent: Token allows upgrade, but we don't have a new agent yet\r\n      * - ReadyToUpgrade: The agent is set, but not a single token has been upgraded yet\r\n      * - Upgrading: Upgrade agent is set and the balance holders can upgrade their tokens\r\n      *\r\n      */\r\n    enum UpgradeState {Unknown, NotAllowed, WaitingForAgent, ReadyToUpgrade, Upgrading}\r\n\r\n    /**\r\n      * Somebody has upgraded some of his tokens.\r\n      */\r\n    event LogUpgrade(address indexed _from, address indexed _to, uint256 _value);\r\n\r\n    /**\r\n      * New upgrade agent available.\r\n      */\r\n    event LogSetUpgradeTarget(address agent);\r\n\r\n    /**\r\n      * Do not allow construction without upgrade master set.\r\n      */\r\n    function UpgradeableToken(address _upgradeMaster) {\r\n        upgradeMaster = _upgradeMaster;\r\n    }\r\n\r\n    /**\r\n      * Allow the token holder to upgrade some of their tokens to a new contract.\r\n      */\r\n    function upgrade(uint256 value) public {\r\n        UpgradeState state = getUpgradeState();\r\n        require(state == UpgradeState.ReadyToUpgrade || state == UpgradeState.Upgrading);\r\n\r\n        // Validate input value.\r\n        require(value > 0);\r\n\r\n        balances[msg.sender] = balances[msg.sender].safeSub(value);\r\n\r\n        // Take tokens out from circulation\r\n        totalSupply   = totalSupply.safeSub(value);\r\n        totalUpgraded = totalUpgraded.safeAdd(value);\r\n\r\n        // Upgrade agent reissues the tokens\r\n        upgradeTarget.upgradeFrom(msg.sender, value);\r\n        LogUpgrade(msg.sender, upgradeTarget, value);\r\n    }\r\n\r\n    /**\r\n      * Set an upgrade targget that handles the process of letting users opt-in to the new token contract.\r\n      */\r\n    function setUpgradeTarget(address target) external {\r\n        require(canUpgrade());\r\n        require(target != 0x0);\r\n        require(msg.sender == upgradeMaster); // Only a master can designate the next target\r\n        require(getUpgradeState() != UpgradeState.Upgrading); // Upgrade has already begun\r\n\r\n        upgradeTarget = UpgradeTarget(target);\r\n\r\n        require(upgradeTarget.isUpgradeTarget()); // Bad interface\r\n        require(upgradeTarget.originalSupply() == totalSupply); // Make sure that token supplies match in source and target\r\n\r\n        LogSetUpgradeTarget(upgradeTarget);\r\n    }\r\n\r\n    /**\r\n      * Get the state of the token upgrade.\r\n      */\r\n    function getUpgradeState() public constant returns (UpgradeState) {\r\n        if (!canUpgrade()) return UpgradeState.NotAllowed;\r\n        else if (address(upgradeTarget) == 0x00) return UpgradeState.WaitingForAgent;\r\n        else if (totalUpgraded == 0) return UpgradeState.ReadyToUpgrade;\r\n        else return UpgradeState.Upgrading;\r\n    }\r\n\r\n    /**\r\n      * Change the upgrade master.\r\n      *\r\n      * This allows us to set a new owner for the upgrade mechanism.\r\n      */\r\n    function setUpgradeMaster(address master) public {\r\n        require(master != 0x0);\r\n        require(msg.sender == upgradeMaster);\r\n\r\n        upgradeMaster = master;\r\n    }\r\n\r\n    /**\r\n      * Child contract can enable to provide the condition when the upgrade can begun.\r\n      */\r\n    function canUpgrade() public constant returns (bool) {\r\n        return true;\r\n    }\r\n}\r\n\r\ncontract MintableToken is StandardToken\r\n{\r\n    address public mintMaster;\r\n\r\n    event LogMintTokens(address recipient, uint amount, uint newBalance, uint totalSupply);\r\n    event LogUnmintTokens(address hodler, uint amount, uint newBalance, uint totalSupply);\r\n    event LogSetMintMaster(address oldMintMaster, address newMintMaster);\r\n\r\n    function MintableToken(address _mintMaster) {\r\n        mintMaster = _mintMaster;\r\n    }\r\n\r\n    function setMintMaster(address newMintMaster)\r\n        returns (bool ok)\r\n    {\r\n        require(msg.sender == mintMaster);\r\n\r\n        address oldMintMaster = mintMaster;\r\n        mintMaster = newMintMaster;\r\n\r\n        LogSetMintMaster(oldMintMaster, mintMaster);\r\n        return true;\r\n    }\r\n\r\n    function mintTokens(address recipient, uint amount)\r\n        returns (bool ok)\r\n    {\r\n        require(msg.sender == mintMaster);\r\n        require(amount > 0);\r\n\r\n        balances[recipient] = balances[recipient].safeAdd(amount);\r\n        totalSupply = totalSupply.safeAdd(amount);\r\n\r\n        LogMintTokens(recipient, amount, balances[recipient], totalSupply);\r\n        Transfer(address(0), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function unmintTokens(address hodler, uint amount)\r\n        returns (bool ok)\r\n    {\r\n        require(msg.sender == mintMaster);\r\n        require(amount > 0);\r\n        require(balances[hodler] >= amount);\r\n\r\n        balances[hodler] = balances[hodler].safeSub(amount);\r\n        totalSupply = totalSupply.safeSub(amount);\r\n\r\n        LogUnmintTokens(hodler, amount, balances[hodler], totalSupply);\r\n        Transfer(hodler, address(0), amount);\r\n        return true;\r\n    }\r\n}\r\n\r\n\r\ncontract SigToken is UpgradeableToken, MintableToken\r\n{\r\n    string public name = \"Signals\";\r\n    string public symbol = \"SIG\";\r\n    uint8 public decimals = 18;\r\n\r\n    address public crowdsaleContract;\r\n    bool public crowdsaleCompleted;\r\n\r\n    function SigToken()\r\n        UpgradeableToken(msg.sender)\r\n        MintableToken(msg.sender)\r\n    {\r\n        crowdsaleContract = msg.sender;\r\n        totalSupply = 0; // we mint during the crowdsale, so totalSupply must start at 0\r\n    }\r\n\r\n    function transfer(address _to, uint _value)\r\n        returns (bool success)\r\n    {\r\n        require(crowdsaleCompleted);\r\n        return StandardToken.transfer(_to, _value);\r\n    }\r\n\r\n    function transferFrom(address from, address to, uint value)\r\n        returns (bool success)\r\n    {\r\n        require(crowdsaleCompleted);\r\n        return StandardToken.transferFrom(from, to, value);\r\n    }\r\n\r\n    function approve(address spender, uint value)\r\n        returns (bool success)\r\n    {\r\n        require(crowdsaleCompleted);\r\n        return StandardToken.approve(spender, value);\r\n    }\r\n\r\n    // This is called to unlock tokens once the crowdsale (and subsequent audit + legal process) are\r\n    // completed.  We don't want people buying tokens during the sale and then immediately starting\r\n    // to trade them.  See Crowdsale::finalizeCrowdsale().\r\n    function setCrowdsaleCompleted() {\r\n        require(msg.sender == crowdsaleContract);\r\n        require(crowdsaleCompleted == false);\r\n\r\n        crowdsaleCompleted = true;\r\n    }\r\n\r\n    /**\r\n     * ERC20 approveAndCall extension\r\n     *\r\n     * Approves and then calls the receiving contract\r\n     */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\r\n        public\r\n        returns (bool success)\r\n    {\r\n        require(crowdsaleCompleted);\r\n\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\r\n        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\r\n        //it is assumed when one does this that the call *should* succeed, otherwise one would use vanilla approve instead.\r\n        require(_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\r\n        return true;\r\n    }\r\n}", "ABI": "[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crowdsaleCompleted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crowdsaleContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"upgrade\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"setCrowdsaleCompleted\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"upgradeMaster\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getUpgradeState\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"canUpgrade\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"hodler\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"unmintTokens\",\"outputs\":[{\"name\":\"ok\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalUpgraded\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"approveAndCall\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"target\",\"type\":\"address\"}],\"name\":\"setUpgradeTarget\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newMintMaster\",\"type\":\"address\"}],\"name\":\"setMintMaster\",\"outputs\":[{\"name\":\"ok\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mintMaster\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isToken\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"recipient\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mintTokens\",\"outputs\":[{\"name\":\"ok\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"upgradeTarget\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"master\",\"type\":\"address\"}],\"name\":\"setUpgradeMaster\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"totalSupply\",\"type\":\"uint256\"}],\"name\":\"LogMintTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"hodler\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"totalSupply\",\"type\":\"uint256\"}],\"name\":\"LogUnmintTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldMintMaster\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newMintMaster\",\"type\":\"address\"}],\"name\":\"LogSetMintMaster\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"LogUpgrade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"agent\",\"type\":\"address\"}],\"name\":\"LogSetUpgradeTarget\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]", "ContractName": "SigToken", "CompilerVersion": "v0.4.15+commit.bbb8e64f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://9274d12d9b0929dc0a25eeacfea489154f63da31679a78aa71d557aa42fee388"}