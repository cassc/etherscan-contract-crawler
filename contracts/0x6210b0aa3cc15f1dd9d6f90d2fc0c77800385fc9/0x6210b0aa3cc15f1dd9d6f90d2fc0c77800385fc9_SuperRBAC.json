{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/settings/SuperRBAC.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.23;\\n\\nimport { ISuperRBAC } from \\\"src/interfaces/ISuperRBAC.sol\\\";\\nimport { Broadcastable } from \\\"src/crosschain-data/utils/Broadcastable.sol\\\";\\nimport { ISuperRegistry } from \\\"src/interfaces/ISuperRegistry.sol\\\";\\nimport { Error } from \\\"src/libraries/Error.sol\\\";\\nimport { BroadcastMessage } from \\\"src/types/DataTypes.sol\\\";\\nimport { AccessControlEnumerable } from \\\"openzeppelin-contracts/contracts/access/extensions/AccessControlEnumerable.sol\\\";\\n\\n/// @title SuperRBAC\\n/// @dev Contract to manage roles in the Superform protocol\\n/// @author Zeropoint Labs\\ncontract SuperRBAC is ISuperRBAC, AccessControlEnumerable, Broadcastable {\\n    //////////////////////////////////////////////////////////////\\n    //                         CONSTANTS                        //\\n    //////////////////////////////////////////////////////////////\\n\\n    bytes32 public constant SYNC_REVOKE = keccak256(\\\"SYNC_REVOKE\\\");\\n\\n    /// @dev used in many areas of the codebase to perform config operations\\n    /// @notice at least one address must be assigned this role\\n    bytes32 public constant override PROTOCOL_ADMIN_ROLE = keccak256(\\\"PROTOCOL_ADMIN_ROLE\\\");\\n\\n    /// @dev used in a few areas of the code\\n    /// @notice at least one address must be assigned this role\\n    bytes32 public constant override EMERGENCY_ADMIN_ROLE = keccak256(\\\"EMERGENCY_ADMIN_ROLE\\\");\\n\\n    /// @dev used to extract funds from PayMaster\\n    /// @dev could be allowed to be changed\\n    bytes32 public constant override PAYMENT_ADMIN_ROLE = keccak256(\\\"PAYMENT_ADMIN_ROLE\\\");\\n\\n    /// @dev used so that certain contracts can broadcast state changes to all connected remote chains\\n    /// @dev currently SUPERFORM_FACTORY, SUPERTRANSMUTER and SUPER_RBAC have this role. SUPER_RBAC doesn't need it\\n    /// @dev multi address (revoke broadcast should be restricted)\\n    bytes32 public constant override BROADCASTER_ROLE = keccak256(\\\"BROADCASTER_ROLE\\\");\\n\\n    /// @dev keeper role, should be allowed to be changed\\n    /// @dev single address\\n    bytes32 public constant override CORE_STATE_REGISTRY_PROCESSOR_ROLE =\\n        keccak256(\\\"CORE_STATE_REGISTRY_PROCESSOR_ROLE\\\");\\n\\n    /// @dev keeper role, should be allowed to be changed\\n    /// @dev single address\\n    bytes32 public constant override TIMELOCK_STATE_REGISTRY_PROCESSOR_ROLE =\\n        keccak256(\\\"TIMELOCK_STATE_REGISTRY_PROCESSOR_ROLE\\\");\\n\\n    /// @dev keeper role, should be allowed to be changed\\n    /// @dev single address\\n    bytes32 public constant override BROADCAST_STATE_REGISTRY_PROCESSOR_ROLE =\\n        keccak256(\\\"BROADCAST_STATE_REGISTRY_PROCESSOR_ROLE\\\");\\n\\n    /// @dev keeper role, should be allowed to be changed\\n    /// @dev single address\\n    bytes32 public constant override CORE_STATE_REGISTRY_UPDATER_ROLE = keccak256(\\\"CORE_STATE_REGISTRY_UPDATER_ROLE\\\");\\n\\n    /// @dev keeper role, should be allowed to be changed\\n    /// @dev single address\\n    bytes32 public constant override CORE_STATE_REGISTRY_RESCUER_ROLE = keccak256(\\\"CORE_STATE_REGISTRY_RESCUER_ROLE\\\");\\n\\n    /// @dev keeper role, should be allowed to be changed\\n    /// @dev single address\\n    bytes32 public constant override CORE_STATE_REGISTRY_DISPUTER_ROLE = keccak256(\\\"CORE_STATE_REGISTRY_DISPUTER_ROLE\\\");\\n\\n    /// @dev keeper role, should be allowed to be changed\\n    /// @dev single address\\n    bytes32 public constant override DST_SWAPPER_ROLE = keccak256(\\\"DST_SWAPPER_ROLE\\\");\\n\\n    /// @dev this is a role so that we could run multiple relayers\\n    /// @dev should be allowed to be changed\\n    /// @dev multi address (revoke broadcast should be restricted)\\n    bytes32 public constant override WORMHOLE_VAA_RELAYER_ROLE = keccak256(\\\"WORMHOLE_VAA_RELAYER_ROLE\\\");\\n\\n    //////////////////////////////////////////////////////////////\\n    //                     STATE VARIABLES                      //\\n    //////////////////////////////////////////////////////////////\\n\\n    ISuperRegistry public superRegistry;\\n    uint256 public xChainPayloadCounter;\\n\\n    //////////////////////////////////////////////////////////////\\n    //                       MODIFIERS                          //\\n    //////////////////////////////////////////////////////////////\\n\\n    modifier onlyBroadcastRegistry() {\\n        if (msg.sender != superRegistry.getAddress(keccak256(\\\"BROADCAST_REGISTRY\\\"))) {\\n            revert Error.NOT_BROADCAST_REGISTRY();\\n        }\\n        _;\\n    }\\n\\n    //////////////////////////////////////////////////////////////\\n    //                      CONSTRUCTOR                         //\\n    //////////////////////////////////////////////////////////////\\n\\n    constructor(InitialRoleSetup memory roles) {\\n        _grantRole(PROTOCOL_ADMIN_ROLE, roles.admin);\\n        _grantRole(EMERGENCY_ADMIN_ROLE, roles.emergencyAdmin);\\n        _grantRole(PAYMENT_ADMIN_ROLE, roles.paymentAdmin);\\n        _grantRole(BROADCASTER_ROLE, address(this));\\n        _grantRole(CORE_STATE_REGISTRY_PROCESSOR_ROLE, roles.csrProcessor);\\n        _grantRole(TIMELOCK_STATE_REGISTRY_PROCESSOR_ROLE, roles.tlProcessor);\\n        _grantRole(BROADCAST_STATE_REGISTRY_PROCESSOR_ROLE, roles.brProcessor);\\n        _grantRole(CORE_STATE_REGISTRY_UPDATER_ROLE, roles.csrUpdater);\\n        _grantRole(DST_SWAPPER_ROLE, roles.dstSwapper);\\n        _grantRole(CORE_STATE_REGISTRY_RESCUER_ROLE, roles.csrRescuer);\\n        _grantRole(CORE_STATE_REGISTRY_DISPUTER_ROLE, roles.csrDisputer);\\n        _grantRole(WORMHOLE_VAA_RELAYER_ROLE, roles.srcVaaRelayer);\\n\\n        /// @dev manually set role admin to PROTOCOL_ADMIN_ROLE on all roles\\n        _setRoleAdmin(PROTOCOL_ADMIN_ROLE, PROTOCOL_ADMIN_ROLE);\\n        _setRoleAdmin(EMERGENCY_ADMIN_ROLE, PROTOCOL_ADMIN_ROLE);\\n        _setRoleAdmin(PAYMENT_ADMIN_ROLE, PROTOCOL_ADMIN_ROLE);\\n        _setRoleAdmin(BROADCAST_STATE_REGISTRY_PROCESSOR_ROLE, PROTOCOL_ADMIN_ROLE);\\n        _setRoleAdmin(CORE_STATE_REGISTRY_PROCESSOR_ROLE, PROTOCOL_ADMIN_ROLE);\\n        _setRoleAdmin(TIMELOCK_STATE_REGISTRY_PROCESSOR_ROLE, PROTOCOL_ADMIN_ROLE);\\n        _setRoleAdmin(BROADCASTER_ROLE, PROTOCOL_ADMIN_ROLE);\\n        _setRoleAdmin(CORE_STATE_REGISTRY_UPDATER_ROLE, PROTOCOL_ADMIN_ROLE);\\n        _setRoleAdmin(DST_SWAPPER_ROLE, PROTOCOL_ADMIN_ROLE);\\n        _setRoleAdmin(CORE_STATE_REGISTRY_RESCUER_ROLE, PROTOCOL_ADMIN_ROLE);\\n        _setRoleAdmin(CORE_STATE_REGISTRY_DISPUTER_ROLE, PROTOCOL_ADMIN_ROLE);\\n        _setRoleAdmin(WORMHOLE_VAA_RELAYER_ROLE, PROTOCOL_ADMIN_ROLE);\\n    }\\n\\n    //////////////////////////////////////////////////////////////\\n    //              EXTERNAL VIEW FUNCTIONS                     //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @inheritdoc ISuperRBAC\\n    function hasProtocolAdminRole(address admin_) external view override returns (bool) {\\n        return hasRole(PROTOCOL_ADMIN_ROLE, admin_);\\n    }\\n\\n    /// @inheritdoc ISuperRBAC\\n    function hasEmergencyAdminRole(address emergencyAdmin_) external view override returns (bool) {\\n        return hasRole(EMERGENCY_ADMIN_ROLE, emergencyAdmin_);\\n    }\\n\\n    //////////////////////////////////////////////////////////////\\n    //              EXTERNAL WRITE FUNCTIONS                    //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @inheritdoc ISuperRBAC\\n    function setSuperRegistry(address superRegistry_) external override onlyRole(PROTOCOL_ADMIN_ROLE) {\\n        if (address(superRegistry) != address(0)) revert Error.DISABLED();\\n\\n        if (superRegistry_ == address(0)) revert Error.ZERO_ADDRESS();\\n\\n        superRegistry = ISuperRegistry(superRegistry_);\\n\\n        emit SuperRegistrySet(superRegistry_);\\n    }\\n\\n    /// @inheritdoc ISuperRBAC\\n    function setRoleAdmin(bytes32 role_, bytes32 adminRole_) external override onlyRole(PROTOCOL_ADMIN_ROLE) {\\n        _setRoleAdmin(role_, adminRole_);\\n\\n        emit RoleAdminSet(role_, adminRole_);\\n    }\\n\\n    /// @inheritdoc ISuperRBAC\\n    function revokeRoleSuperBroadcast(\\n        bytes32 role_,\\n        bytes memory extraData_,\\n        bytes32 superRegistryAddressId_\\n    )\\n        external\\n        payable\\n        override\\n        onlyRole(PROTOCOL_ADMIN_ROLE)\\n    {\\n        /// @dev revokeRoleSuperBroadcast cannot update the PROTOCOL_ADMIN_ROLE, EMERGENCY_ADMIN_ROLE, BROADCASTER_ROLE\\n        /// and WORMHOLE_VAA_RELAYER_ROLE\\n        if (\\n            role_ == PROTOCOL_ADMIN_ROLE || role_ == EMERGENCY_ADMIN_ROLE || role_ == BROADCASTER_ROLE\\n                || role_ == WORMHOLE_VAA_RELAYER_ROLE\\n        ) revert Error.CANNOT_REVOKE_NON_BROADCASTABLE_ROLES();\\n        if (_revokeRole(role_, superRegistry.getAddress(superRegistryAddressId_))) {\\n            if (extraData_.length != 0) {\\n                BroadcastMessage memory rolesPayload = BroadcastMessage(\\n                    \\\"SUPER_RBAC\\\", SYNC_REVOKE, abi.encode(++xChainPayloadCounter, role_, superRegistryAddressId_)\\n                );\\n                _broadcast(\\n                    superRegistry.getAddress(keccak256(\\\"BROADCAST_REGISTRY\\\")),\\n                    superRegistry.getAddress(keccak256(\\\"PAYMASTER\\\")),\\n                    abi.encode(rolesPayload),\\n                    extraData_\\n                );\\n            }\\n        } else {\\n            revert Error.ROLE_NOT_ASSIGNED();\\n        }\\n    }\\n\\n    /// @inheritdoc ISuperRBAC\\n    function stateSyncBroadcast(bytes memory data_) external override onlyBroadcastRegistry {\\n        BroadcastMessage memory rolesPayload = abi.decode(data_, (BroadcastMessage));\\n        if (rolesPayload.messageType != SYNC_REVOKE) {\\n            revert Error.INVALID_MESSAGE_TYPE();\\n        }\\n        (, bytes32 role, bytes32 superRegistryAddressId) = abi.decode(rolesPayload.message, (uint256, bytes32, bytes32));\\n        /// @dev broadcasting cannot update the PROTOCOL_ADMIN_ROLE, EMERGENCY_ADMIN_ROLE, BROADCASTER_ROLE\\n        /// and WORMHOLE_VAA_RELAYER_ROLE\\n        if (\\n            !(\\n                role == PROTOCOL_ADMIN_ROLE || role == EMERGENCY_ADMIN_ROLE || role == BROADCASTER_ROLE\\n                    || role == WORMHOLE_VAA_RELAYER_ROLE\\n            )\\n        ) {\\n            if (!_revokeRole(role, superRegistry.getAddress(superRegistryAddressId))) {\\n                revert Error.ROLE_NOT_ASSIGNED();\\n            }\\n        }\\n    }\\n\\n    //////////////////////////////////////////////////////////////\\n    //                  INTERNAL FUNCTIONS                      //\\n    //////////////////////////////////////////////////////////////\\n\\n    /**\\n     * @dev Overload {_revokeRole} to track enumerable memberships\\n     */\\n    function _revokeRole(bytes32 role_, address account_) internal override returns (bool) {\\n        if (role_ == PROTOCOL_ADMIN_ROLE || role_ == EMERGENCY_ADMIN_ROLE) {\\n            if (getRoleMemberCount(role_) == 1) revert Error.CANNOT_REVOKE_LAST_ADMIN();\\n        }\\n        return super._revokeRole(role_, account_);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ISuperRBAC.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.23;\\n\\nimport { IAccessControl } from \\\"openzeppelin-contracts/contracts/access/IAccessControl.sol\\\";\\n\\n/// @title ISuperRBAC\\n/// @dev Interface for SuperRBAC\\n/// @author Zeropoint Labs\\ninterface ISuperRBAC is IAccessControl {\\n\\n    //////////////////////////////////////////////////////////////\\n    //                           STRUCTS                         //\\n    //////////////////////////////////////////////////////////////\\n\\n    struct InitialRoleSetup {\\n        address admin;\\n        address emergencyAdmin;\\n        address paymentAdmin;\\n        address csrProcessor;\\n        address tlProcessor;\\n        address brProcessor;\\n        address csrUpdater;\\n        address srcVaaRelayer;\\n        address dstSwapper;\\n        address csrRescuer;\\n        address csrDisputer;\\n    }\\n\\n    //////////////////////////////////////////////////////////////\\n    //                          EVENTS                          //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @dev is emitted when superRegistry is set\\n    event SuperRegistrySet(address indexed superRegistry);\\n\\n    /// @dev is emitted when an admin is set for a role\\n    event RoleAdminSet(bytes32 role, bytes32 adminRole);\\n\\n    //////////////////////////////////////////////////////////////\\n    //              EXTERNAL VIEW FUNCTIONS                     //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @dev returns the id of the protocol admin role\\n    function PROTOCOL_ADMIN_ROLE() external view returns (bytes32);\\n\\n    /// @dev returns the id of the emergency admin role\\n    function EMERGENCY_ADMIN_ROLE() external view returns (bytes32);\\n\\n    /// @dev returns the id of the payment admin role\\n    function PAYMENT_ADMIN_ROLE() external view returns (bytes32);\\n\\n    /// @dev returns the id of the broadcaster role\\n    function BROADCASTER_ROLE() external view returns (bytes32);\\n\\n    /// @dev returns the id of the core state registry processor role\\n    function CORE_STATE_REGISTRY_PROCESSOR_ROLE() external view returns (bytes32);\\n\\n    /// @dev returns the id of the timelock state registry processor role\\n    function TIMELOCK_STATE_REGISTRY_PROCESSOR_ROLE() external view returns (bytes32);\\n\\n    /// @dev returns the id of the broadcast state registry processor role\\n    function BROADCAST_STATE_REGISTRY_PROCESSOR_ROLE() external view returns (bytes32);\\n\\n    /// @dev returns the id of the core state registry updater role\\n    function CORE_STATE_REGISTRY_UPDATER_ROLE() external view returns (bytes32);\\n\\n    /// @dev returns the id of the dst swapper role\\n    function DST_SWAPPER_ROLE() external view returns (bytes32);\\n\\n    /// @dev returns the id of the core state registry rescuer role\\n    function CORE_STATE_REGISTRY_RESCUER_ROLE() external view returns (bytes32);\\n\\n    /// @dev returns the id of the core state registry rescue disputer role\\n    function CORE_STATE_REGISTRY_DISPUTER_ROLE() external view returns (bytes32);\\n\\n    /// @dev returns the id of wormhole vaa relayer role\\n    function WORMHOLE_VAA_RELAYER_ROLE() external view returns (bytes32);\\n\\n    /// @dev returns whether the given address has the protocol admin role\\n    /// @param admin_ the address to check\\n    function hasProtocolAdminRole(address admin_) external view returns (bool);\\n\\n    /// @dev returns whether the given address has the emergency admin role\\n    /// @param admin_ the address to check\\n    function hasEmergencyAdminRole(address admin_) external view returns (bool);\\n\\n    //////////////////////////////////////////////////////////////\\n    //              EXTERNAL WRITE FUNCTIONS                    //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @dev updates the super registry address\\n    function setSuperRegistry(address superRegistry_) external;\\n\\n    /// @dev configures a new role in superForm\\n    /// @param role_ the role to set\\n    /// @param adminRole_ the admin role to set as admin\\n    function setRoleAdmin(bytes32 role_, bytes32 adminRole_) external;\\n\\n    /// @dev revokes the role_ from superRegistryAddressId_ on all chains\\n    /// @param role_ the role to revoke\\n    /// @param extraData_ amb config if broadcasting is required\\n    /// @param superRegistryAddressId_ the super registry address id\\n    function revokeRoleSuperBroadcast(\\n        bytes32 role_,\\n        bytes memory extraData_,\\n        bytes32 superRegistryAddressId_\\n    )\\n        external\\n        payable;\\n\\n    /// @dev allows sync of global roles from different chains using broadcast registry\\n    /// @notice may not work for all roles\\n    function stateSyncBroadcast(bytes memory data_) external;\\n}\\n\"\r\n    },\r\n    \"src/crosschain-data/utils/Broadcastable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.23;\\n\\nimport { IBroadcastRegistry } from \\\"src/interfaces/IBroadcastRegistry.sol\\\";\\nimport { Error } from \\\"src/libraries/Error.sol\\\";\\n\\n/// @title Broadcastable\\n/// @dev Can be inherited in contracts that wish to support broadcasting\\n/// @author ZeroPoint Labs\\nabstract contract Broadcastable {\\n    //////////////////////////////////////////////////////////////\\n    //                  INTERNAL FUNCTIONS                      //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @dev broadcasts state changes to all connected remote chains\\n    /// @param broadcastRegistry_ is the address of the broadcast registry contract.\\n    /// @param payMaster_ is the address of the paymaster contract.\\n    /// @param message_ is the crosschain message to be sent.\\n    /// @param extraData_ is the amb override information.\\n    function _broadcast(\\n        address broadcastRegistry_,\\n        address payMaster_,\\n        bytes memory message_,\\n        bytes memory extraData_\\n    )\\n        internal\\n    {\\n        (uint8 ambId, bytes memory broadcastParams) = abi.decode(extraData_, (uint8, bytes));\\n\\n        /// @dev if the broadcastParams are wrong this will revert\\n        (uint256 gasFee, bytes memory extraData) = abi.decode(broadcastParams, (uint256, bytes));\\n\\n        if (msg.value < gasFee) {\\n            revert Error.INVALID_BROADCAST_FEE();\\n        }\\n\\n        /// @dev ambIds are validated inside the broadcast state registry\\n        IBroadcastRegistry(broadcastRegistry_).broadcastPayload{ value: gasFee }(\\n            msg.sender, ambId, gasFee, message_, extraData\\n        );\\n\\n        if (msg.value > gasFee) {\\n            /// @dev forwards the rest to paymaster\\n            (bool success,) = payable(payMaster_).call{ value: msg.value - gasFee }(\\\"\\\");\\n\\n            if (!success) {\\n                revert Error.FAILED_TO_SEND_NATIVE();\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ISuperRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.23;\\n\\n/// @title ISuperRegistry\\n/// @dev Interface for SuperRegistry\\n/// @author Zeropoint Labs\\ninterface ISuperRegistry {\\n    //////////////////////////////////////////////////////////////\\n    //                          EVENTS                          //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @dev emitted when permit2 is set.\\n    event SetPermit2(address indexed permit2);\\n\\n    /// @dev is emitted when an address is set.\\n    event AddressUpdated(\\n        bytes32 indexed protocolAddressId, uint64 indexed chainId, address indexed oldAddress, address newAddress\\n    );\\n\\n    /// @dev is emitted when a new token bridge is configured.\\n    event SetBridgeAddress(uint256 indexed bridgeId, address indexed bridgeAddress);\\n\\n    /// @dev is emitted when a new bridge validator is configured.\\n    event SetBridgeValidator(uint256 indexed bridgeId, address indexed bridgeValidator);\\n\\n    /// @dev is emitted when a new amb is configured.\\n    event SetAmbAddress(uint8 indexed ambId_, address indexed ambAddress_, bool indexed isBroadcastAMB_);\\n\\n    /// @dev is emitted when a new state registry is configured.\\n    event SetStateRegistryAddress(uint8 indexed registryId_, address indexed registryAddress_);\\n\\n    /// @dev is emitted when a new delay is configured.\\n    event SetDelay(uint256 indexed oldDelay_, uint256 indexed newDelay_);\\n\\n    /// @dev is emitted when a new vault limit is configured\\n    event SetVaultLimitPerDestination(uint64 indexed chainId_, uint256 indexed vaultLimit_);\\n\\n    //////////////////////////////////////////////////////////////\\n    //              EXTERNAL VIEW FUNCTIONS                     //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @dev gets the deposit rescue delay\\n    function delay() external view returns (uint256);\\n\\n    /// @dev returns the permit2 address\\n    function PERMIT2() external view returns (address);\\n\\n    /// @dev returns the id of the superform router module\\n    function SUPERFORM_ROUTER() external view returns (bytes32);\\n\\n    /// @dev returns the id of the superform factory module\\n    function SUPERFORM_FACTORY() external view returns (bytes32);\\n\\n    /// @dev returns the id of the superform paymaster contract\\n    function PAYMASTER() external view returns (bytes32);\\n\\n    /// @dev returns the id of the superform payload helper contract\\n    function PAYMENT_HELPER() external view returns (bytes32);\\n\\n    /// @dev returns the id of the core state registry module\\n    function CORE_STATE_REGISTRY() external view returns (bytes32);\\n\\n    /// @dev returns the id of the timelock form state registry module\\n    function TIMELOCK_STATE_REGISTRY() external view returns (bytes32);\\n\\n    /// @dev returns the id of the broadcast state registry module\\n    function BROADCAST_REGISTRY() external view returns (bytes32);\\n\\n    /// @dev returns the id of the super positions module\\n    function SUPER_POSITIONS() external view returns (bytes32);\\n\\n    /// @dev returns the id of the super rbac module\\n    function SUPER_RBAC() external view returns (bytes32);\\n\\n    /// @dev returns the id of the payload helper module\\n    function PAYLOAD_HELPER() external view returns (bytes32);\\n\\n    /// @dev returns the id of the dst swapper keeper\\n    function DST_SWAPPER() external view returns (bytes32);\\n\\n    /// @dev returns the id of the emergency queue\\n    function EMERGENCY_QUEUE() external view returns (bytes32);\\n\\n    /// @dev returns the id of the superform receiver\\n    function SUPERFORM_RECEIVER() external view returns (bytes32);\\n\\n    /// @dev returns the id of the payment admin keeper\\n    function PAYMENT_ADMIN() external view returns (bytes32);\\n\\n    /// @dev returns the id of the core state registry processor keeper\\n    function CORE_REGISTRY_PROCESSOR() external view returns (bytes32);\\n\\n    /// @dev returns the id of the broadcast registry processor keeper\\n    function BROADCAST_REGISTRY_PROCESSOR() external view returns (bytes32);\\n\\n    /// @dev returns the id of the timelock form state registry processor keeper\\n    function TIMELOCK_REGISTRY_PROCESSOR() external view returns (bytes32);\\n\\n    /// @dev returns the id of the core state registry updater keeper\\n    function CORE_REGISTRY_UPDATER() external view returns (bytes32);\\n\\n    /// @dev returns the id of the core state registry updater keeper\\n    function CORE_REGISTRY_RESCUER() external view returns (bytes32);\\n\\n    /// @dev returns the id of the core state registry updater keeper\\n    function CORE_REGISTRY_DISPUTER() external view returns (bytes32);\\n\\n    /// @dev returns the id of the core state registry updater keeper\\n    function DST_SWAPPER_PROCESSOR() external view returns (bytes32);\\n\\n    /// @dev gets the address of a contract on current chain\\n    /// @param id_ is the id of the contract\\n    function getAddress(bytes32 id_) external view returns (address);\\n\\n    /// @dev gets the address of a contract on a target chain\\n    /// @param id_ is the id of the contract\\n    /// @param chainId_ is the chain id of that chain\\n    function getAddressByChainId(bytes32 id_, uint64 chainId_) external view returns (address);\\n\\n    /// @dev gets the address of a bridge\\n    /// @param bridgeId_ is the id of a bridge\\n    /// @return bridgeAddress_ is the address of the form\\n    function getBridgeAddress(uint8 bridgeId_) external view returns (address bridgeAddress_);\\n\\n    /// @dev gets the address of a bridge validator\\n    /// @param bridgeId_ is the id of a bridge\\n    /// @return bridgeValidator_ is the address of the form\\n    function getBridgeValidator(uint8 bridgeId_) external view returns (address bridgeValidator_);\\n\\n    /// @dev gets the address of a amb\\n    /// @param ambId_ is the id of a bridge\\n    /// @return ambAddress_ is the address of the form\\n    function getAmbAddress(uint8 ambId_) external view returns (address ambAddress_);\\n\\n    /// @dev gets the id of the amb\\n    /// @param ambAddress_ is the address of an amb\\n    /// @return ambId_ is the identifier of an amb\\n    function getAmbId(address ambAddress_) external view returns (uint8 ambId_);\\n\\n    /// @dev gets the address of the registry\\n    /// @param registryId_ is the id of the state registry\\n    /// @return registryAddress_ is the address of the state registry\\n    function getStateRegistry(uint8 registryId_) external view returns (address registryAddress_);\\n\\n    /// @dev gets the id of the registry\\n    /// @notice reverts if the id is not found\\n    /// @param registryAddress_ is the address of the state registry\\n    /// @return registryId_ is the id of the state registry\\n    function getStateRegistryId(address registryAddress_) external view returns (uint8 registryId_);\\n\\n    /// @dev gets the safe vault limit\\n    /// @param chainId_ is the id of the remote chain\\n    /// @return vaultLimitPerDestination_ is the safe number of vaults to deposit\\n    /// without hitting out of gas error\\n    function getVaultLimitPerDestination(uint64 chainId_) external view returns (uint256 vaultLimitPerDestination_);\\n\\n    /// @dev helps validate if an address is a valid state registry\\n    /// @param registryAddress_ is the address of the state registry\\n    /// @return valid_ a flag indicating if its valid.\\n    function isValidStateRegistry(address registryAddress_) external view returns (bool valid_);\\n\\n    /// @dev helps validate if an address is a valid amb implementation\\n    /// @param ambAddress_ is the address of the amb implementation\\n    /// @return valid_ a flag indicating if its valid.\\n    function isValidAmbImpl(address ambAddress_) external view returns (bool valid_);\\n\\n    /// @dev helps validate if an address is a valid broadcast amb implementation\\n    /// @param ambAddress_ is the address of the broadcast amb implementation\\n    /// @return valid_ a flag indicating if its valid.\\n    function isValidBroadcastAmbImpl(address ambAddress_) external view returns (bool valid_);\\n\\n    //////////////////////////////////////////////////////////////\\n    //              EXTERNAL WRITE FUNCTIONS                    //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @dev sets the deposit rescue delay\\n    /// @param delay_ the delay in seconds before the deposit rescue can be finalized\\n    function setDelay(uint256 delay_) external;\\n\\n    /// @dev sets the permit2 address\\n    /// @param permit2_ the address of the permit2 contract\\n    function setPermit2(address permit2_) external;\\n\\n    /// @dev sets the safe vault limit\\n    /// @param chainId_ is the remote chain identifier\\n    /// @param vaultLimit_ is the max limit of vaults per transaction\\n    function setVaultLimitPerDestination(uint64 chainId_, uint256 vaultLimit_) external;\\n\\n    /// @dev sets new addresses on specific chains.\\n    /// @param ids_ are the identifiers of the address on that chain\\n    /// @param newAddresses_  are the new addresses on that chain\\n    /// @param chainIds_ are the chain ids of that chain\\n    function batchSetAddress(\\n        bytes32[] calldata ids_,\\n        address[] calldata newAddresses_,\\n        uint64[] calldata chainIds_\\n    )\\n        external;\\n\\n    /// @dev sets a new address on a specific chain.\\n    /// @param id_ the identifier of the address on that chain\\n    /// @param newAddress_ the new address on that chain\\n    /// @param chainId_ the chain id of that chain\\n    function setAddress(bytes32 id_, address newAddress_, uint64 chainId_) external;\\n\\n    /// @dev allows admin to set the bridge address for an bridge id.\\n    /// @notice this function operates in an APPEND-ONLY fashion.\\n    /// @param bridgeId_         represents the bridge unique identifier.\\n    /// @param bridgeAddress_    represents the bridge address.\\n    /// @param bridgeValidator_  represents the bridge validator address.\\n    function setBridgeAddresses(\\n        uint8[] memory bridgeId_,\\n        address[] memory bridgeAddress_,\\n        address[] memory bridgeValidator_\\n    )\\n        external;\\n\\n    /// @dev allows admin to set the amb address for an amb id.\\n    /// @notice this function operates in an APPEND-ONLY fashion.\\n    /// @param ambId_         represents the bridge unique identifier.\\n    /// @param ambAddress_    represents the bridge address.\\n    /// @param isBroadcastAMB_ represents whether the amb implementation supports broadcasting\\n    function setAmbAddress(\\n        uint8[] memory ambId_,\\n        address[] memory ambAddress_,\\n        bool[] memory isBroadcastAMB_\\n    )\\n        external;\\n\\n    /// @dev allows admin to set the state registry address for an state registry id.\\n    /// @notice this function operates in an APPEND-ONLY fashion.\\n    /// @param registryId_    represents the state registry's unique identifier.\\n    /// @param registryAddress_    represents the state registry's address.\\n    function setStateRegistryAddress(uint8[] memory registryId_, address[] memory registryAddress_) external;\\n}\\n\"\r\n    },\r\n    \"src/libraries/Error.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.23;\\n\\nlibrary Error {\\n    //////////////////////////////////////////////////////////////\\n    //                  CONFIGURATION ERRORS                    //\\n    //////////////////////////////////////////////////////////////\\n    ///@notice errors thrown in protocol setup\\n\\n    /// @dev thrown if chain id exceeds max(uint64)\\n    error BLOCK_CHAIN_ID_OUT_OF_BOUNDS();\\n\\n    /// @dev thrown if not possible to revoke a role in broadcasting\\n    error CANNOT_REVOKE_NON_BROADCASTABLE_ROLES();\\n\\n    /// @dev thrown if not possible to revoke last admin\\n    error CANNOT_REVOKE_LAST_ADMIN();\\n\\n    /// @dev thrown if trying to set again pseudo immutables in super registry\\n    error DISABLED();\\n\\n    /// @dev thrown if rescue delay is not yet set for a chain\\n    error DELAY_NOT_SET();\\n\\n    /// @dev thrown if get native token price estimate in paymentHelper is 0\\n    error INVALID_NATIVE_TOKEN_PRICE();\\n\\n    /// @dev thrown if wormhole refund chain id is not set\\n    error REFUND_CHAIN_ID_NOT_SET();\\n\\n    /// @dev thrown if wormhole relayer is not set\\n    error RELAYER_NOT_SET();\\n\\n    /// @dev thrown if a role to be revoked is not assigned\\n    error ROLE_NOT_ASSIGNED();\\n\\n    //////////////////////////////////////////////////////////////\\n    //                  AUTHORIZATION ERRORS                    //\\n    //////////////////////////////////////////////////////////////\\n    ///@notice errors thrown if functions cannot be called\\n\\n    /// COMMON AUTHORIZATION ERRORS\\n    /// ---------------------------------------------------------\\n\\n    /// @dev thrown if caller is not address(this), internal call\\n    error INVALID_INTERNAL_CALL();\\n\\n    /// @dev thrown if msg.sender is not a valid amb implementation\\n    error NOT_AMB_IMPLEMENTATION();\\n\\n    /// @dev thrown if msg.sender is not an allowed broadcaster\\n    error NOT_ALLOWED_BROADCASTER();\\n\\n    /// @dev thrown if msg.sender is not broadcast amb implementation\\n    error NOT_BROADCAST_AMB_IMPLEMENTATION();\\n\\n    /// @dev thrown if msg.sender is not broadcast state registry\\n    error NOT_BROADCAST_REGISTRY();\\n\\n    /// @dev thrown if msg.sender is not core state registry\\n    error NOT_CORE_STATE_REGISTRY();\\n\\n    /// @dev thrown if msg.sender is not emergency admin\\n    error NOT_EMERGENCY_ADMIN();\\n\\n    /// @dev thrown if msg.sender is not emergency queue\\n    error NOT_EMERGENCY_QUEUE();\\n\\n    /// @dev thrown if msg.sender is not minter\\n    error NOT_MINTER();\\n\\n    /// @dev thrown if msg.sender is not minter state registry\\n    error NOT_MINTER_STATE_REGISTRY_ROLE();\\n\\n    /// @dev thrown if msg.sender is not paymaster\\n    error NOT_PAYMASTER();\\n\\n    /// @dev thrown if msg.sender is not payment admin\\n    error NOT_PAYMENT_ADMIN();\\n\\n    /// @dev thrown if msg.sender is not protocol admin\\n    error NOT_PROTOCOL_ADMIN();\\n\\n    /// @dev thrown if msg.sender is not state registry\\n    error NOT_STATE_REGISTRY();\\n\\n    /// @dev thrown if msg.sender is not super registry\\n    error NOT_SUPER_REGISTRY();\\n\\n    /// @dev thrown if msg.sender is not superform router\\n    error NOT_SUPERFORM_ROUTER();\\n\\n    /// @dev thrown if msg.sender is not a superform\\n    error NOT_SUPERFORM();\\n\\n    /// @dev thrown if msg.sender is not superform factory\\n    error NOT_SUPERFORM_FACTORY();\\n\\n    /// @dev thrown if msg.sender is not timelock form\\n    error NOT_TIMELOCK_SUPERFORM();\\n\\n    /// @dev thrown if msg.sender is not timelock state registry\\n    error NOT_TIMELOCK_STATE_REGISTRY();\\n\\n    /// @dev thrown if msg.sender is not user or disputer\\n    error NOT_VALID_DISPUTER();\\n\\n    /// @dev thrown if the msg.sender is not privileged caller\\n    error NOT_PRIVILEGED_CALLER(bytes32 role);\\n\\n    /// STATE REGISTRY AUTHORIZATION ERRORS\\n    /// ---------------------------------------------------------\\n\\n    /// @dev layerzero adapter specific error, thrown if caller not layerzero endpoint\\n    error CALLER_NOT_ENDPOINT();\\n\\n    /// @dev hyperlane adapter specific error, thrown if caller not hyperlane mailbox\\n    error CALLER_NOT_MAILBOX();\\n\\n    /// @dev wormhole relayer specific error, thrown if caller not wormhole relayer\\n    error CALLER_NOT_RELAYER();\\n\\n    /// @dev thrown if src chain sender is not valid\\n    error INVALID_SRC_SENDER();\\n\\n    //////////////////////////////////////////////////////////////\\n    //                  INPUT VALIDATION ERRORS                 //\\n    //////////////////////////////////////////////////////////////\\n    ///@notice errors thrown if input variables are not valid\\n\\n    /// COMMON INPUT VALIDATION ERRORS\\n    /// ---------------------------------------------------------\\n\\n    /// @dev thrown if there is an array length mismatch\\n    error ARRAY_LENGTH_MISMATCH();\\n\\n    /// @dev thrown if payload id does not exist\\n    error INVALID_PAYLOAD_ID();\\n\\n    /// @dev error thrown when msg value should be zero in certain payable functions\\n    error MSG_VALUE_NOT_ZERO();\\n\\n    /// @dev thrown if amb ids length is 0\\n    error ZERO_AMB_ID_LENGTH();\\n\\n    /// @dev thrown if address input is address 0\\n    error ZERO_ADDRESS();\\n\\n    /// @dev thrown if amount input is 0\\n    error ZERO_AMOUNT();\\n\\n    /// @dev thrown if final token is address 0\\n    error ZERO_FINAL_TOKEN();\\n\\n    /// @dev thrown if value input is 0\\n    error ZERO_INPUT_VALUE();\\n\\n    /// SUPERFORM ROUTER INPUT VALIDATION ERRORS\\n    /// ---------------------------------------------------------\\n\\n    /// @dev thrown if the vaults data is invalid\\n    error INVALID_SUPERFORMS_DATA();\\n\\n    /// @dev thrown if receiver address is not set\\n    error RECEIVER_ADDRESS_NOT_SET();\\n\\n    /// SUPERFORM FACTORY INPUT VALIDATION ERRORS\\n    /// ---------------------------------------------------------\\n\\n    /// @dev thrown if a form is not ERC165 compatible\\n    error ERC165_UNSUPPORTED();\\n\\n    /// @dev thrown if a form is not form interface compatible\\n    error FORM_INTERFACE_UNSUPPORTED();\\n\\n    /// @dev error thrown if form implementation address already exists\\n    error FORM_IMPLEMENTATION_ALREADY_EXISTS();\\n\\n    /// @dev error thrown if form implementation id already exists\\n    error FORM_IMPLEMENTATION_ID_ALREADY_EXISTS();\\n\\n    /// @dev thrown if a form does not exist\\n    error FORM_DOES_NOT_EXIST();\\n\\n    /// @dev thrown if form id is larger than max uint16\\n    error INVALID_FORM_ID();\\n\\n    /// @dev thrown if superform not on factory\\n    error SUPERFORM_ID_NONEXISTENT();\\n\\n    /// @dev thrown if same vault and form implementation is used to create new superform\\n    error VAULT_FORM_IMPLEMENTATION_COMBINATION_EXISTS();\\n\\n    /// FORM INPUT VALIDATION ERRORS\\n    /// ---------------------------------------------------------\\n\\n    /// @dev thrown if in case of no txData, if liqData.token != vault.asset()\\n    /// in case of txData, if token output of swap != vault.asset()\\n    error DIFFERENT_TOKENS();\\n\\n    /// @dev thrown if the amount in direct withdraw is not correct\\n    error DIRECT_WITHDRAW_INVALID_LIQ_REQUEST();\\n\\n    /// @dev thrown if the amount in xchain withdraw is not correct\\n    error XCHAIN_WITHDRAW_INVALID_LIQ_REQUEST();\\n\\n    /// LIQUIDITY BRIDGE INPUT VALIDATION ERRORS\\n    /// ---------------------------------------------------------\\n\\n    /// @dev thrown if route id is blacklisted in socket\\n    error BLACKLISTED_ROUTE_ID();\\n\\n    /// @dev thrown if route id is not blacklisted in socket\\n    error NOT_BLACKLISTED_ROUTE_ID();\\n\\n    /// @dev error thrown when txData selector of lifi bridge is a blacklisted selector\\n    error BLACKLISTED_SELECTOR();\\n\\n    /// @dev error thrown when txData selector of lifi bridge is not a blacklisted selector\\n    error NOT_BLACKLISTED_SELECTOR();\\n\\n    /// @dev thrown if a certain action of the user is not allowed given the txData provided\\n    error INVALID_ACTION();\\n\\n    /// @dev thrown if in deposits, the liqDstChainId doesn't match the stateReq dstChainId\\n    error INVALID_DEPOSIT_LIQ_DST_CHAIN_ID();\\n\\n    /// @dev thrown if index is invalid\\n    error INVALID_INDEX();\\n\\n    /// @dev thrown if the chain id in the txdata is invalid\\n    error INVALID_TXDATA_CHAIN_ID();\\n\\n    /// @dev thrown if the validation of bridge txData fails due to a destination call present\\n    error INVALID_TXDATA_NO_DESTINATIONCALL_ALLOWED();\\n\\n    /// @dev thrown if the validation of bridge txData fails due to wrong receiver\\n    error INVALID_TXDATA_RECEIVER();\\n\\n    /// @dev thrown if the validation of bridge txData fails due to wrong token\\n    error INVALID_TXDATA_TOKEN();\\n\\n    /// @dev thrown if txData is not present (in case of xChain actions)\\n    error NO_TXDATA_PRESENT();\\n\\n    /// STATE REGISTRY INPUT VALIDATION ERRORS\\n    /// ---------------------------------------------------------\\n\\n    /// @dev thrown if payload is being updated with final amounts length different than amounts length\\n    error DIFFERENT_PAYLOAD_UPDATE_AMOUNTS_LENGTH();\\n\\n    /// @dev thrown if payload is being updated with tx data length different than liq data length\\n    error DIFFERENT_PAYLOAD_UPDATE_TX_DATA_LENGTH();\\n\\n    /// @dev thrown if keeper update final token is different than the vault underlying\\n    error INVALID_UPDATE_FINAL_TOKEN();\\n\\n    /// @dev thrown if broadcast finality for wormhole is invalid\\n    error INVALID_BROADCAST_FINALITY();\\n\\n    /// @dev thrown if amb id is not valid leading to an address 0 of the implementation\\n    error INVALID_BRIDGE_ID();\\n\\n    /// @dev thrown if chain id involved in xchain message is invalid\\n    error INVALID_CHAIN_ID();\\n\\n    /// @dev thrown if payload update amount isn't equal to dst swapper amount\\n    error INVALID_DST_SWAP_AMOUNT();\\n\\n    /// @dev thrown if message amb and proof amb are the same\\n    error INVALID_PROOF_BRIDGE_ID();\\n\\n    /// @dev thrown if order of proof AMBs is incorrect, either duplicated or not incrementing\\n    error INVALID_PROOF_BRIDGE_IDS();\\n\\n    /// @dev thrown if rescue data lengths are invalid\\n    error INVALID_RESCUE_DATA();\\n\\n    /// @dev thrown if delay is invalid\\n    error INVALID_TIMELOCK_DELAY();\\n\\n    /// @dev thrown if amounts being sent in update payload mean a negative slippage\\n    error NEGATIVE_SLIPPAGE();\\n\\n    /// @dev thrown if slippage is outside of bounds\\n    error SLIPPAGE_OUT_OF_BOUNDS();\\n\\n    /// SUPERPOSITION INPUT VALIDATION ERRORS\\n    /// ---------------------------------------------------------\\n\\n    /// @dev thrown if src senders mismatch in state sync\\n    error SRC_SENDER_MISMATCH();\\n\\n    /// @dev thrown if src tx types mismatch in state sync\\n    error SRC_TX_TYPE_MISMATCH();\\n\\n    //////////////////////////////////////////////////////////////\\n    //                  EXECUTION ERRORS                        //\\n    //////////////////////////////////////////////////////////////\\n    ///@notice errors thrown due to function execution logic\\n\\n    /// COMMON EXECUTION ERRORS\\n    /// ---------------------------------------------------------\\n\\n    /// @dev thrown if the swap in a direct deposit resulted in insufficient tokens\\n    error DIRECT_DEPOSIT_SWAP_FAILED();\\n\\n    /// @dev thrown if payload is not unique\\n    error DUPLICATE_PAYLOAD();\\n\\n    /// @dev thrown if native tokens fail to be sent to superform contracts\\n    error FAILED_TO_SEND_NATIVE();\\n\\n    /// @dev thrown if allowance is not correct to deposit\\n    error INSUFFICIENT_ALLOWANCE_FOR_DEPOSIT();\\n\\n    /// @dev thrown if contract has insufficient balance for operations\\n    error INSUFFICIENT_BALANCE();\\n\\n    /// @dev thrown if native amount is not at least equal to the amount in the request\\n    error INSUFFICIENT_NATIVE_AMOUNT();\\n\\n    /// @dev thrown if payload cannot be decoded\\n    error INVALID_PAYLOAD();\\n\\n    /// @dev thrown if payload status is invalid\\n    error INVALID_PAYLOAD_STATUS();\\n\\n    /// @dev thrown if payload type is invalid\\n    error INVALID_PAYLOAD_TYPE();\\n\\n    /// LIQUIDITY BRIDGE EXECUTION ERRORS\\n    /// ---------------------------------------------------------\\n\\n    /// @dev thrown if we try to decode the final swap output token in a xChain liquidity bridging action\\n    error CANNOT_DECODE_FINAL_SWAP_OUTPUT_TOKEN();\\n\\n    /// @dev thrown if liquidity bridge fails for erc20 or native tokens\\n    error FAILED_TO_EXECUTE_TXDATA(address token);\\n\\n    /// @dev thrown if asset being used for deposit mismatches in multivault deposits\\n    error INVALID_DEPOSIT_TOKEN();\\n\\n    /// STATE REGISTRY EXECUTION ERRORS\\n    /// ---------------------------------------------------------\\n\\n    /// @dev thrown if bridge tokens haven't arrived to destination\\n    error BRIDGE_TOKENS_PENDING();\\n\\n    /// @dev thrown if withdrawal tx data cannot be updated\\n    error CANNOT_UPDATE_WITHDRAW_TX_DATA();\\n\\n    /// @dev thrown if rescue passed dispute deadline\\n    error DISPUTE_TIME_ELAPSED();\\n\\n    /// @dev thrown if message failed to reach the specified level of quorum needed\\n    error INSUFFICIENT_QUORUM();\\n\\n    /// @dev thrown if broadcast payload is invalid\\n    error INVALID_BROADCAST_PAYLOAD();\\n\\n    /// @dev thrown if broadcast fee is invalid\\n    error INVALID_BROADCAST_FEE();\\n\\n    /// @dev thrown if retry fees is less than required\\n    error INVALID_RETRY_FEE();\\n\\n    /// @dev thrown if broadcast message type is wrong\\n    error INVALID_MESSAGE_TYPE();\\n\\n    /// @dev thrown if payload hash is invalid during `retryMessage` on Layezero implementation\\n    error INVALID_PAYLOAD_HASH();\\n\\n    /// @dev thrown if update payload function was called on a wrong payload\\n    error INVALID_PAYLOAD_UPDATE_REQUEST();\\n\\n    /// @dev thrown if a state registry id is 0\\n    error INVALID_REGISTRY_ID();\\n\\n    /// @dev thrown if a form state registry id is 0\\n    error INVALID_FORM_REGISTRY_ID();\\n\\n    /// @dev thrown if trying to finalize the payload but the withdraw is still locked\\n    error LOCKED();\\n\\n    /// @dev thrown if payload is already updated (during xChain deposits)\\n    error PAYLOAD_ALREADY_UPDATED();\\n\\n    /// @dev thrown if payload is already processed\\n    error PAYLOAD_ALREADY_PROCESSED();\\n\\n    /// @dev thrown if payload is not in UPDATED state\\n    error PAYLOAD_NOT_UPDATED();\\n\\n    /// @dev thrown if rescue is still in timelocked state\\n    error RESCUE_LOCKED();\\n\\n    /// @dev thrown if rescue is already proposed\\n    error RESCUE_ALREADY_PROPOSED();\\n\\n    /// @dev thrown if payload hash is zero during `retryMessage` on Layezero implementation\\n    error ZERO_PAYLOAD_HASH();\\n\\n    /// DST SWAPPER EXECUTION ERRORS\\n    /// ---------------------------------------------------------\\n\\n    /// @dev thrown if process dst swap is tried for processed payload id\\n    error DST_SWAP_ALREADY_PROCESSED();\\n\\n    /// @dev thrown if indices have duplicates\\n    error DUPLICATE_INDEX();\\n\\n    /// @dev thrown if failed dst swap is already updated\\n    error FAILED_DST_SWAP_ALREADY_UPDATED();\\n\\n    /// @dev thrown if indices are out of bounds\\n    error INDEX_OUT_OF_BOUNDS();\\n\\n    /// @dev thrown if failed swap token amount is 0\\n    error INVALID_DST_SWAPPER_FAILED_SWAP();\\n\\n    /// @dev thrown if failed swap token amount is not 0 and if token balance is less than amount (non zero)\\n    error INVALID_DST_SWAPPER_FAILED_SWAP_NO_TOKEN_BALANCE();\\n\\n    /// @dev thrown if failed swap token amount is not 0 and if native amount is less than amount (non zero)\\n    error INVALID_DST_SWAPPER_FAILED_SWAP_NO_NATIVE_BALANCE();\\n\\n    /// @dev forbid xChain deposits with destination swaps without interim token set (for user protection)\\n    error INVALID_INTERIM_TOKEN();\\n\\n    /// @dev thrown if dst swap output is less than minimum expected\\n    error INVALID_SWAP_OUTPUT();\\n\\n    /// FORM EXECUTION ERRORS\\n    /// ---------------------------------------------------------\\n\\n    /// @dev thrown if try to forward 4626 share from the superform\\n    error CANNOT_FORWARD_4646_TOKEN();\\n\\n    /// @dev thrown in KYCDAO form if no KYC token is present\\n    error NO_VALID_KYC_TOKEN();\\n\\n    /// @dev thrown in forms where a certain functionality is not allowed or implemented\\n    error NOT_IMPLEMENTED();\\n\\n    /// @dev thrown if form implementation is PAUSED, users cannot perform any action\\n    error PAUSED();\\n\\n    /// @dev thrown if shares != deposit output or assets != redeem output when minting SuperPositions\\n    error VAULT_IMPLEMENTATION_FAILED();\\n\\n    /// @dev thrown if withdrawal tx data is not updated\\n    error WITHDRAW_TOKEN_NOT_UPDATED();\\n\\n    /// @dev thrown if withdrawal tx data is not updated\\n    error WITHDRAW_TX_DATA_NOT_UPDATED();\\n\\n    /// @dev thrown when redeeming from vault yields zero collateral\\n    error WITHDRAW_ZERO_COLLATERAL();\\n\\n    /// PAYMENT HELPER EXECUTION ERRORS\\n    /// ---------------------------------------------------------\\n\\n    /// @dev thrown if chainlink is reporting an improper price\\n    error CHAINLINK_MALFUNCTION();\\n\\n    /// @dev thrown if chainlink is reporting an incomplete round\\n    error CHAINLINK_INCOMPLETE_ROUND();\\n\\n    /// @dev thrown if feed decimals is not 8\\n    error CHAINLINK_UNSUPPORTED_DECIMAL();\\n\\n    /// EMERGENCY QUEUE EXECUTION ERRORS\\n    /// ---------------------------------------------------------\\n\\n    /// @dev thrown if emergency withdraw is not queued\\n    error EMERGENCY_WITHDRAW_NOT_QUEUED();\\n\\n    /// @dev thrown if emergency withdraw is already processed\\n    error EMERGENCY_WITHDRAW_PROCESSED_ALREADY();\\n\\n    /// SUPERPOSITION EXECUTION ERRORS\\n    /// ---------------------------------------------------------\\n\\n    /// @dev thrown if uri cannot be updated\\n    error DYNAMIC_URI_FROZEN();\\n\\n    /// @dev thrown if tx history is not found while state sync\\n    error TX_HISTORY_NOT_FOUND();\\n}\\n\"\r\n    },\r\n    \"src/types/DataTypes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.23;\\n\\n/// @dev contains all the common struct and enums used for data communication between chains.\\n\\n/// @dev There are two transaction types in Superform Protocol\\nenum TransactionType {\\n    DEPOSIT,\\n    WITHDRAW\\n}\\n\\n/// @dev Message types can be INIT, RETURN (for successful Deposits) and FAIL (for failed withdraws)\\nenum CallbackType {\\n    INIT,\\n    RETURN,\\n    FAIL\\n}\\n\\n/// @dev Payloads are stored, updated (deposits) or processed (finalized)\\nenum PayloadState {\\n    STORED,\\n    UPDATED,\\n    PROCESSED\\n}\\n\\n/// @dev contains all the common struct used for interchain token transfers.\\nstruct LiqRequest {\\n    /// @dev generated data\\n    bytes txData;\\n    /// @dev input token for deposits, desired output token on target liqDstChainId for withdraws. Must be set for\\n    /// txData to be updated on destination for withdraws\\n    address token;\\n    /// @dev intermediary token on destination. Relevant for xChain deposits where a destination swap is needed for\\n    /// validation purposes\\n    address interimToken;\\n    /// @dev what bridge to use to move tokens\\n    uint8 bridgeId;\\n    /// @dev dstChainId = liqDstchainId for deposits. For withdraws it is the target chain id for where the underlying\\n    /// is to be delivered\\n    uint64 liqDstChainId;\\n    /// @dev currently this amount is used as msg.value in the txData call.\\n    uint256 nativeAmount;\\n}\\n\\n/// @dev main struct that holds required multi vault data for an action\\nstruct MultiVaultSFData {\\n    // superformids must have same destination. Can have different underlyings\\n    uint256[] superformIds;\\n    uint256[] amounts; // on deposits, amount of token to deposit on dst, on withdrawals, superpositions to burn\\n    uint256[] outputAmounts; // on deposits, amount of shares to receive, on withdrawals, amount of assets to receive\\n    uint256[] maxSlippages;\\n    LiqRequest[] liqRequests; // if length = 1; amount = sum(amounts) | else  amounts must match the amounts being sent\\n    bytes permit2data;\\n    bool[] hasDstSwaps;\\n    bool[] retain4626s; // if true, we don't mint SuperPositions, and send the 4626 back to the user instead\\n    address receiverAddress;\\n    /// this address must always be an EOA otherwise funds may be lost\\n    address receiverAddressSP;\\n    /// this address can be a EOA or a contract that implements onERC1155Receiver. must always be set for deposits\\n    bytes extraFormData; // extraFormData\\n}\\n\\n/// @dev main struct that holds required single vault data for an action\\nstruct SingleVaultSFData {\\n    // superformids must have same destination. Can have different underlyings\\n    uint256 superformId;\\n    uint256 amount;\\n    uint256 outputAmount; // on deposits, amount of shares to receive, on withdrawals, amount of assets to receive\\n    uint256 maxSlippage;\\n    LiqRequest liqRequest; // if length = 1; amount = sum(amounts)| else  amounts must match the amounts being sent\\n    bytes permit2data;\\n    bool hasDstSwap;\\n    bool retain4626; // if true, we don't mint SuperPositions, and send the 4626 back to the user instead\\n    address receiverAddress;\\n    /// this address must always be an EOA otherwise funds may be lost\\n    address receiverAddressSP;\\n    /// this address can be a EOA or a contract that implements onERC1155Receiver. must always be set for deposits\\n    bytes extraFormData; // extraFormData\\n}\\n\\n/// @dev overarching struct for multiDst requests with multi vaults\\nstruct MultiDstMultiVaultStateReq {\\n    uint8[][] ambIds;\\n    uint64[] dstChainIds;\\n    MultiVaultSFData[] superformsData;\\n}\\n\\n/// @dev overarching struct for single cross chain requests with multi vaults\\nstruct SingleXChainMultiVaultStateReq {\\n    uint8[] ambIds;\\n    uint64 dstChainId;\\n    MultiVaultSFData superformsData;\\n}\\n\\n/// @dev overarching struct for multiDst requests with single vaults\\nstruct MultiDstSingleVaultStateReq {\\n    uint8[][] ambIds;\\n    uint64[] dstChainIds;\\n    SingleVaultSFData[] superformsData;\\n}\\n\\n/// @dev overarching struct for single cross chain requests with single vaults\\nstruct SingleXChainSingleVaultStateReq {\\n    uint8[] ambIds;\\n    uint64 dstChainId;\\n    SingleVaultSFData superformData;\\n}\\n\\n/// @dev overarching struct for single direct chain requests with single vaults\\nstruct SingleDirectSingleVaultStateReq {\\n    SingleVaultSFData superformData;\\n}\\n\\n/// @dev overarching struct for single direct chain requests with multi vaults\\nstruct SingleDirectMultiVaultStateReq {\\n    MultiVaultSFData superformData;\\n}\\n\\n/// @dev struct for SuperRouter with re-arranged data for the message (contains the payloadId)\\n/// @dev realize that receiverAddressSP is not passed, only needed on source chain to mint\\nstruct InitMultiVaultData {\\n    uint256 payloadId;\\n    uint256[] superformIds;\\n    uint256[] amounts;\\n    uint256[] outputAmounts;\\n    uint256[] maxSlippages;\\n    LiqRequest[] liqData;\\n    bool[] hasDstSwaps;\\n    bool[] retain4626s;\\n    address receiverAddress;\\n    bytes extraFormData;\\n}\\n\\n/// @dev struct for SuperRouter with re-arranged data for the message (contains the payloadId)\\nstruct InitSingleVaultData {\\n    uint256 payloadId;\\n    uint256 superformId;\\n    uint256 amount;\\n    uint256 outputAmount;\\n    uint256 maxSlippage;\\n    LiqRequest liqData;\\n    bool hasDstSwap;\\n    bool retain4626;\\n    address receiverAddress;\\n    bytes extraFormData;\\n}\\n\\n/// @dev struct for Emergency Queue\\nstruct QueuedWithdrawal {\\n    address receiverAddress;\\n    uint256 superformId;\\n    uint256 amount;\\n    uint256 srcPayloadId;\\n    bool isProcessed;\\n}\\n\\n/// @dev all statuses of the timelock payload\\nenum TimelockStatus {\\n    UNAVAILABLE,\\n    PENDING,\\n    PROCESSED\\n}\\n\\n/// @dev holds information about the timelock payload\\nstruct TimelockPayload {\\n    uint8 isXChain;\\n    uint64 srcChainId;\\n    uint256 lockedTill;\\n    InitSingleVaultData data;\\n    TimelockStatus status;\\n}\\n\\n/// @dev struct that contains the type of transaction, callback flags and other identification, as well as the vaults\\n/// data in params\\nstruct AMBMessage {\\n    uint256 txInfo; // tight packing of  TransactionType txType,  CallbackType flag  if multi/single vault, registry id,\\n        // srcSender and srcChainId\\n    bytes params; // decoding txInfo will point to the right datatype of params. Refer PayloadHelper.sol\\n}\\n\\n/// @dev struct that contains the information required for broadcasting changes\\nstruct BroadcastMessage {\\n    bytes target;\\n    bytes32 messageType;\\n    bytes message;\\n}\\n\\n/// @dev struct that contains info on returned data from destination\\nstruct ReturnMultiData {\\n    uint256 payloadId;\\n    uint256[] superformIds;\\n    uint256[] amounts;\\n}\\n\\n/// @dev struct that contains info on returned data from destination\\nstruct ReturnSingleData {\\n    uint256 payloadId;\\n    uint256 superformId;\\n    uint256 amount;\\n}\\n\\n/// @dev struct that contains the data on the fees to pay to the AMBs\\nstruct AMBExtraData {\\n    uint256[] gasPerAMB;\\n    bytes[] extraDataPerAMB;\\n}\\n\\n/// @dev struct that contains the data on the fees to pay to the AMBs on broadcasts\\nstruct BroadCastAMBExtraData {\\n    uint256[] gasPerDst;\\n    bytes[] extraDataPerDst;\\n}\\n\"\r\n    },\r\n    \"lib/ERC1155A/lib/openzeppelin-contracts/contracts/access/extensions/AccessControlEnumerable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/extensions/AccessControlEnumerable.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IAccessControlEnumerable} from \\\"./IAccessControlEnumerable.sol\\\";\\nimport {AccessControl} from \\\"../AccessControl.sol\\\";\\nimport {EnumerableSet} from \\\"../../utils/structs/EnumerableSet.sol\\\";\\n\\n/**\\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\\n */\\nabstract contract AccessControlEnumerable is IAccessControlEnumerable, AccessControl {\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n\\n    mapping(bytes32 role => EnumerableSet.AddressSet) private _roleMembers;\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IAccessControlEnumerable).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns one of the accounts that have `role`. `index` must be a\\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\\n     *\\n     * Role bearers are not sorted in any particular way, and their ordering may\\n     * change at any point.\\n     *\\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\\n     * you perform all queries on the same block. See the following\\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\\n     * for more information.\\n     */\\n    function getRoleMember(bytes32 role, uint256 index) public view virtual returns (address) {\\n        return _roleMembers[role].at(index);\\n    }\\n\\n    /**\\n     * @dev Returns the number of accounts that have `role`. Can be used\\n     * together with {getRoleMember} to enumerate all bearers of a role.\\n     */\\n    function getRoleMemberCount(bytes32 role) public view virtual returns (uint256) {\\n        return _roleMembers[role].length();\\n    }\\n\\n    /**\\n     * @dev Overload {AccessControl-_grantRole} to track enumerable memberships\\n     */\\n    function _grantRole(bytes32 role, address account) internal virtual override returns (bool) {\\n        bool granted = super._grantRole(role, account);\\n        if (granted) {\\n            _roleMembers[role].add(account);\\n        }\\n        return granted;\\n    }\\n\\n    /**\\n     * @dev Overload {AccessControl-_revokeRole} to track enumerable memberships\\n     */\\n    function _revokeRole(bytes32 role, address account) internal virtual override returns (bool) {\\n        bool revoked = super._revokeRole(role, account);\\n        if (revoked) {\\n            _roleMembers[role].remove(account);\\n        }\\n        return revoked;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/ERC1155A/lib/openzeppelin-contracts/contracts/access/IAccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/IAccessControl.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC-165 detection.\\n */\\ninterface IAccessControl {\\n    /**\\n     * @dev The `account` is missing a role.\\n     */\\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\\n\\n    /**\\n     * @dev The caller of a function is not the expected one.\\n     *\\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\\n     */\\n    error AccessControlBadConfirmation();\\n\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {AccessControl-_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `callerConfirmation`.\\n     */\\n    function renounceRole(bytes32 role, address callerConfirmation) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IBroadcastRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.23;\\n\\n/// @title IBroadcastRegistry\\n/// @dev Interface for BroadcastRegistry\\n/// @author ZeroPoint Labs\\ninterface IBroadcastRegistry {\\n\\n    //////////////////////////////////////////////////////////////\\n    //              EXTERNAL WRITE FUNCTIONS                    //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @dev allows core contracts to send payload to all configured destination chain.\\n    /// @param srcSender_ is the caller of the function (used for gas refunds).\\n    /// @param ambId_ is the identifier of the arbitrary message bridge to be used\\n    /// @param gasFee_ is the gas fee to be used for broadcasting\\n    /// @param message_ is the crosschain payload to be broadcasted\\n    /// @param extraData_ defines all the message bridge related overrides\\n    function broadcastPayload(\\n        address srcSender_,\\n        uint8 ambId_,\\n        uint256 gasFee_,\\n        bytes memory message_,\\n        bytes memory extraData_\\n    )\\n        external\\n        payable;\\n\\n    /// @dev allows ambs to write broadcasted payloads\\n    function receiveBroadcastPayload(uint64 srcChainId_, bytes memory message_) external;\\n\\n    /// @dev allows privileged actors to process broadcasted payloads\\n    /// @param payloadId_ is the identifier of the cross-chain payload\\n    function processPayload(uint256 payloadId_) external;\\n}\\n\"\r\n    },\r\n    \"lib/ERC1155A/lib/openzeppelin-contracts/contracts/access/extensions/IAccessControlEnumerable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/extensions/IAccessControlEnumerable.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IAccessControl} from \\\"../IAccessControl.sol\\\";\\n\\n/**\\n * @dev External interface of AccessControlEnumerable declared to support ERC-165 detection.\\n */\\ninterface IAccessControlEnumerable is IAccessControl {\\n    /**\\n     * @dev Returns one of the accounts that have `role`. `index` must be a\\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\\n     *\\n     * Role bearers are not sorted in any particular way, and their ordering may\\n     * change at any point.\\n     *\\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\\n     * you perform all queries on the same block. See the following\\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\\n     * for more information.\\n     */\\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\\n\\n    /**\\n     * @dev Returns the number of accounts that have `role`. Can be used\\n     * together with {getRoleMember} to enumerate all bearers of a role.\\n     */\\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"lib/ERC1155A/lib/openzeppelin-contracts/contracts/access/AccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/AccessControl.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IAccessControl} from \\\"./IAccessControl.sol\\\";\\nimport {Context} from \\\"../utils/Context.sol\\\";\\nimport {ERC165} from \\\"../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev Contract module that allows children to implement role-based access\\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\\n * members except through off-chain means by accessing the contract event logs. Some\\n * applications may benefit from on-chain enumerability, for those cases see\\n * {AccessControlEnumerable}.\\n *\\n * Roles are referred to by their `bytes32` identifier. These should be exposed\\n * in the external API and be unique. The best way to achieve this is by\\n * using `public constant` hash digests:\\n *\\n * ```solidity\\n * bytes32 public constant MY_ROLE = keccak256(\\\"MY_ROLE\\\");\\n * ```\\n *\\n * Roles can be used to represent a set of permissions. To restrict access to a\\n * function call, use {hasRole}:\\n *\\n * ```solidity\\n * function foo() public {\\n *     require(hasRole(MY_ROLE, msg.sender));\\n *     ...\\n * }\\n * ```\\n *\\n * Roles can be granted and revoked dynamically via the {grantRole} and\\n * {revokeRole} functions. Each role has an associated admin role, and only\\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\\n *\\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\\n * that only accounts with this role will be able to grant or revoke other\\n * roles. More complex role relationships can be created by using\\n * {_setRoleAdmin}.\\n *\\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\\n * grant and revoke this role. Extra precautions should be taken to secure\\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\\n * to enforce additional security measures for this role.\\n */\\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\\n    struct RoleData {\\n        mapping(address account => bool) hasRole;\\n        bytes32 adminRole;\\n    }\\n\\n    mapping(bytes32 role => RoleData) private _roles;\\n\\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n    /**\\n     * @dev Modifier that checks that an account has a specific role. Reverts\\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\\n     */\\n    modifier onlyRole(bytes32 role) {\\n        _checkRole(role);\\n        _;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\\n        return _roles[role].hasRole[account];\\n    }\\n\\n    /**\\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\\n     */\\n    function _checkRole(bytes32 role) internal view virtual {\\n        _checkRole(role, _msgSender());\\n    }\\n\\n    /**\\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\\n     * is missing `role`.\\n     */\\n    function _checkRole(bytes32 role, address account) internal view virtual {\\n        if (!hasRole(role, account)) {\\n            revert AccessControlUnauthorizedAccount(account, role);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\\n        return _roles[role].adminRole;\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     *\\n     * May emit a {RoleGranted} event.\\n     */\\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `callerConfirmation`.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\\n        if (callerConfirmation != _msgSender()) {\\n            revert AccessControlBadConfirmation();\\n        }\\n\\n        _revokeRole(role, callerConfirmation);\\n    }\\n\\n    /**\\n     * @dev Sets `adminRole` as ``role``'s admin role.\\n     *\\n     * Emits a {RoleAdminChanged} event.\\n     */\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\n        bytes32 previousAdminRole = getRoleAdmin(role);\\n        _roles[role].adminRole = adminRole;\\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\\n    }\\n\\n    /**\\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\\n     *\\n     * Internal function without access restriction.\\n     *\\n     * May emit a {RoleGranted} event.\\n     */\\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\\n        if (!hasRole(role, account)) {\\n            _roles[role].hasRole[account] = true;\\n            emit RoleGranted(role, account, _msgSender());\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\\n     *\\n     * Internal function without access restriction.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\\n        if (hasRole(role, account)) {\\n            _roles[role].hasRole[account] = false;\\n            emit RoleRevoked(role, account, _msgSender());\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/ERC1155A/lib/openzeppelin-contracts/contracts/utils/structs/EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```solidity\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n *\\n * [WARNING]\\n * ====\\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\\n * unusable.\\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\\n *\\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\\n * array of EnumerableSet.\\n * ====\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n        // Position is the index of the value in the `values` array plus 1.\\n        // Position 0 is used to mean a value is not in the set.\\n        mapping(bytes32 value => uint256) _positions;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._positions[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We cache the value's position to prevent multiple reads from the same storage slot\\n        uint256 position = set._positions[value];\\n\\n        if (position != 0) {\\n            // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 valueIndex = position - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            if (valueIndex != lastIndex) {\\n                bytes32 lastValue = set._values[lastIndex];\\n\\n                // Move the lastValue to the index where the value to delete is\\n                set._values[valueIndex] = lastValue;\\n                // Update the tracked position of the lastValue (that was just moved)\\n                set._positions[lastValue] = position;\\n            }\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the tracked position for the deleted slot\\n            delete set._positions[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._positions[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        return set._values[index];\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function _values(Set storage set) private view returns (bytes32[] memory) {\\n        return set._values;\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        bytes32[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(AddressSet storage set) internal view returns (address[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        address[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        uint256[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/ERC1155A/lib/openzeppelin-contracts/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Context.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/ERC1155A/lib/openzeppelin-contracts/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC165} from \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC-165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/ERC1155A/lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC-165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"solmate/=lib/ERC1155A/lib/solmate/src/\",\r\n      \"@openzeppelin/contracts/=lib/ERC1155A/lib/openzeppelin-contracts/contracts/\",\r\n      \"ERC1155A/=lib/ERC1155A/src/\",\r\n      \"ds-test/=lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/ERC1155A/lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-contracts/=lib/ERC1155A/lib/openzeppelin-contracts/\",\r\n      \"pigeon/=lib/pigeon/src/\",\r\n      \"solady/=lib/pigeon/lib/solady/\",\r\n      \"super-vaults/=lib/super-vaults/src/\",\r\n      \"v2-core/=lib/super-vaults/lib/v2-core/contracts/\",\r\n      \"v2-periphery/=lib/super-vaults/lib/v2-periphery/contracts/\",\r\n      \"v3-core/=lib/super-vaults/lib/v3-core/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"emergencyAdmin\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"paymentAdmin\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"csrProcessor\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tlProcessor\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"brProcessor\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"csrUpdater\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"srcVaaRelayer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dstSwapper\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"csrRescuer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"csrDisputer\",\"type\":\"address\"}],\"internalType\":\"struct ISuperRBAC.InitialRoleSetup\",\"name\":\"roles\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AccessControlBadConfirmation\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"neededRole\",\"type\":\"bytes32\"}],\"name\":\"AccessControlUnauthorizedAccount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CANNOT_REVOKE_LAST_ADMIN\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CANNOT_REVOKE_NON_BROADCASTABLE_ROLES\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DISABLED\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FAILED_TO_SEND_NATIVE\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INVALID_BROADCAST_FEE\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INVALID_MESSAGE_TYPE\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NOT_BROADCAST_REGISTRY\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ROLE_NOT_ASSIGNED\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZERO_ADDRESS\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"adminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"superRegistry\",\"type\":\"address\"}],\"name\":\"SuperRegistrySet\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BROADCASTER_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BROADCAST_STATE_REGISTRY_PROCESSOR_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CORE_STATE_REGISTRY_DISPUTER_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CORE_STATE_REGISTRY_PROCESSOR_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CORE_STATE_REGISTRY_RESCUER_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CORE_STATE_REGISTRY_UPDATER_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DEFAULT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DST_SWAPPER_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"EMERGENCY_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PAYMENT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PROTOCOL_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SYNC_REVOKE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TIMELOCK_STATE_REGISTRY_PROCESSOR_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WORMHOLE_VAA_RELAYER_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getRoleMember\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleMemberCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"emergencyAdmin_\",\"type\":\"address\"}],\"name\":\"hasEmergencyAdminRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"admin_\",\"type\":\"address\"}],\"name\":\"hasProtocolAdminRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"callerConfirmation\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role_\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"extraData_\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"superRegistryAddressId_\",\"type\":\"bytes32\"}],\"name\":\"revokeRoleSuperBroadcast\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role_\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"adminRole_\",\"type\":\"bytes32\"}],\"name\":\"setRoleAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"superRegistry_\",\"type\":\"address\"}],\"name\":\"setSuperRegistry\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data_\",\"type\":\"bytes\"}],\"name\":\"stateSyncBroadcast\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"superRegistry\",\"outputs\":[{\"internalType\":\"contract ISuperRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"xChainPayloadCounter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "SuperRBAC", "CompilerVersion": "v0.8.23+commit.f704f362", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000048ab8adf869ba9902ad483fb1ca2efdab6eabe9200000000000000000000000048ab8adf869ba9902ad483fb1ca2efdab6eabe92000000000000000000000000d911673eaf0d3e15fe662d58de15511c5509babb00000000000000000000000023c658fe050b4eaeb9401768bf5911d11621629c00000000000000000000000073009ce7cffc6c4c5363734d1b429f0b848e049000000000000000000000000073009ce7cffc6c4c5363734d1b429f0b848e0490000000000000000000000000aebb4b9f7e16bee2a0963569a5e33ee10e478a5f00000000000000000000000073009ce7cffc6c4c5363734d1b429f0b848e04900000000000000000000000001666660d2f506e754cb5c8e21bdedc7ddec6be1c00000000000000000000000090ed07a867bdb6a73565d7abbc7434dd810fafc50000000000000000000000007c9c8c0a9aa5d8a2c2e6c746641117cc9591296a", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}