{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"lib/solmate/src/tokens/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\\nabstract contract ERC20 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    uint8 public immutable decimals;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            EIP-2612 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\n\\n    mapping(address => uint256) public nonces;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n\\n        INITIAL_CHAIN_ID = block.chainid;\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        balanceOf[msg.sender] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\n\\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\\n\\n        balanceOf[from] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             EIP-2612 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        require(deadline >= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\n\\n        // Unchecked because the only math done is incrementing\\n        // the owner's nonce which cannot realistically overflow.\\n        unchecked {\\n            address recoveredAddress = ecrecover(\\n                keccak256(\\n                    abi.encodePacked(\\n                        \\\"\\\\x19\\\\x01\\\",\\n                        DOMAIN_SEPARATOR(),\\n                        keccak256(\\n                            abi.encode(\\n                                keccak256(\\n                                    \\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\"\\n                                ),\\n                                owner,\\n                                spender,\\n                                value,\\n                                nonces[owner]++,\\n                                deadline\\n                            )\\n                        )\\n                    )\\n                ),\\n                v,\\n                r,\\n                s\\n            );\\n\\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"INVALID_SIGNER\\\");\\n\\n            allowance[recoveredAddress][spender] = value;\\n        }\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\n    }\\n\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                    keccak256(bytes(name)),\\n                    keccak256(\\\"1\\\"),\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        totalSupply += amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        balanceOf[from] -= amount;\\n\\n        // Cannot underflow because a user's balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply -= amount;\\n        }\\n\\n        emit Transfer(from, address(0), amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/utils/SafeTransferLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"../tokens/ERC20.sol\\\";\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\\nlibrary SafeTransferLib {\\n    /*//////////////////////////////////////////////////////////////\\n                             ETH OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Transfer the ETH and store if it succeeded or not.\\n            success := call(gas(), to, amount, 0, 0, 0, 0)\\n        }\\n\\n        require(success, \\\"ETH_TRANSFER_FAILED\\\");\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            ERC20 OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferFrom(\\n        ERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), from) // Append the \\\"from\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), to) // Append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"TRANSFER_FROM_FAILED\\\");\\n    }\\n\\n    function safeTransfer(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), to) // Append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"TRANSFER_FAILED\\\");\\n    }\\n\\n    function safeApprove(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), to) // Append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"APPROVE_FAILED\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"src/FlashMEV.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity >=0.8.17 <0.9.0;\\n\\n/// ============ Imports ============\\n\\nimport {ERC20} from \\\"solmate/tokens/ERC20.sol\\\";\\nimport {IFlashBorrower} from \\\"./interfaces/IFlashBorrower.sol\\\";\\nimport {IFlashLoanReceiver} from \\\"./interfaces/IFlashLoanReceiver.sol\\\";\\nimport {IFlashLoanRecipient} from \\\"./interfaces/IFlashLoanRecipient.sol\\\";\\nimport {IVault} from \\\"./interfaces/IVault.sol\\\";\\nimport {ILendingPool} from \\\"./interfaces/ILendingPool.sol\\\";\\nimport {IBentoBoxV1} from \\\"./interfaces/IBentoBoxV1.sol\\\";\\nimport {SafeTransferLib} from \\\"solmate/utils/SafeTransferLib.sol\\\";\\nimport {IProtocolDataProvider} from \\\"./interfaces/IProtocolDataProvider.sol\\\";\\nimport {IUniswapV2Router02} from \\\"./interfaces/IUniswapV2Router02.sol\\\";\\n\\n/// @title FlashMEV\\n/// @author Sandy Bradley <@sandybradley>\\n/// @notice Generic flash loan for MEV execution (loans from Balancer (0% fee), BentoBox (0.05%), Aave (0.09%))\\ncontract FlashMEV is IFlashLoanRecipient, IFlashBorrower, IFlashLoanReceiver {\\n    using SafeTransferLib for ERC20;\\n\\n    error ZeroAddress();\\n    error Unauthorized();\\n    error UnsupportedToken();\\n    error InsufficientOutputAmount();\\n\\n    event MEV(address indexed token, uint256 value);\\n\\n    uint8 internal GOV_FEE;\\n    address internal GOV;\\n    address internal mevETH;\\n    address internal ORACLE_ROUTER;\\n    address internal constant WETH09 =\\n        0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\n    address internal constant BENTO =\\n        0xF5BCE5077908a1b7370B9ae04AdC565EBd643966; // bentobox vault\\n    address internal constant LENDING_POOL_ADDRESS =\\n        0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9; // aave lending pool address\\n    address internal constant AAVE_DATA_PROVIDER =\\n        0x057835Ad21a177dbdd3090bB1CAE03EaCF78Fc6d; // aave data provider\\n    address internal constant VAULT =\\n        0xBA12222222228d8Ba445958a75a0704d566BF2C8; // balancer vault\\n    mapping(address => bool) internal FLASH_FRIEND; // flashloan execute user access\\n\\n    // address internal constant SPLIT_SWAP =\\n    //     0x77337dEEA78720542f0A1325394Def165918D562;  // Manifold split swap router\\n\\n    /// @dev setup contract with governance fee and mevETH address\\n    /// @param _govFee governance fee on mev profit as 1/100 th of a decimal i.e. 1 == 0.01%\\n    /// @param _mevETH mevETH address\\n    /// @param _oracleRouter uni V2 style router for eth value lookup\\n    constructor(uint8 _govFee, address _mevETH, address _oracleRouter) {\\n        GOV = tx.origin; // tx.origin used over msg.sender for create2 deployment\\n        mevETH = _mevETH;\\n        GOV_FEE = _govFee;\\n        ORACLE_ROUTER = _oracleRouter;\\n        FLASH_FRIEND[GOV] = true;\\n    }\\n\\n    /// @notice Admin can change ownership\\n    /// @param newGov Address of new owner\\n    function updateGov(address newGov) external {\\n        if (msg.sender != GOV) revert Unauthorized();\\n        if (newGov == address(0)) revert ZeroAddress();\\n        GOV = newGov;\\n    }\\n\\n    /// @notice Admin can change fee\\n    /// @param _newFee New fee (1 == 0.01%)\\n    function updateFee(uint8 _newFee) external {\\n        if (msg.sender != GOV) revert Unauthorized();\\n        GOV_FEE = _newFee;\\n    }\\n\\n    /// @notice Admin can change oracle router\\n    /// @param _oracleRouter uni V2 style router\\n    function updateOracle(address _oracleRouter) external {\\n        if (msg.sender != GOV) revert Unauthorized();\\n        ORACLE_ROUTER = _oracleRouter;\\n    }\\n\\n    /// @notice Update internal Flash friend list\\n    /// @param flashAllowed Boolean flagging if user is allowed to execute\\n    /// @param friend Address of friend\\n    function updateFriend(bool flashAllowed, address friend) external {\\n        if (msg.sender != GOV) revert Unauthorized();\\n        FLASH_FRIEND[friend] = flashAllowed;\\n    }\\n\\n    /// @notice Admin can change mevETH address\\n    /// @param newMevEth Address of new mevETH\\n    function updateMevETH(address newMevEth) external {\\n        if (msg.sender != GOV) revert Unauthorized();\\n        if (newMevEth == address(0)) revert ZeroAddress();\\n        mevETH = newMevEth;\\n    }\\n\\n    /// @notice returns flash freind mapping for given address\\n    /// @param friend user address to query\\n    function isFriend(address friend) external view returns (bool) {\\n        return FLASH_FRIEND[friend];\\n    }\\n\\n    /// @notice returns governance address\\n    function gov() external view returns (address) {\\n        return GOV;\\n    }\\n\\n    /// @notice Main Flash loan call to execute MEV\\n    /// @param useBalancer true if its okay to use balancer flashloan (reentrancy protection makes it impossible to use balancer flashloan with balancer swaps)\\n    /// @param token token to loan\\n    /// @param amount Amount to loan of token\\n    /// @param transactions packed list of transaction data (value(256),contract(160),data_len(16),data(data_len*8))\\n    function flash(\\n        bool useBalancer,\\n        address token,\\n        uint256 amount,\\n        bytes calldata transactions\\n    ) external {\\n        if (!FLASH_FRIEND[msg.sender]) revert Unauthorized();\\n        address me = address(this);\\n        address sender = msg.sender;\\n        uint256 startGas = gasleft();\\n        uint256 balBefore = ERC20(token).balanceOf(me);\\n\\n        // loan preference\\n        // 1) balancer\\n        // 2) bentobox\\n        // 3) aave\\n        if (useBalancer && ERC20(token).balanceOf(VAULT) >= amount) {\\n            // addresses of the reserves to flashloan\\n            address[] memory assets = new address[](1);\\n            assets[0] = token;\\n            // amounts of assets to flashloan.\\n            uint256[] memory amounts = new uint256[](1);\\n            amounts[0] = amount;\\n            IVault(VAULT).flashLoan(\\n                IFlashLoanRecipient(me),\\n                assets,\\n                amounts,\\n                transactions\\n            );\\n        } else if (ERC20(token).balanceOf(BENTO) >= amount) {\\n            IBentoBoxV1(BENTO).flashLoan(\\n                IFlashBorrower(me),\\n                me,\\n                token,\\n                amount,\\n                transactions\\n            );\\n        } else if (\\n            IProtocolDataProvider(AAVE_DATA_PROVIDER).getReserveData(token) >=\\n            amount\\n        ) {\\n            {\\n                // addresses of the reserves to flashloan\\n                address[] memory assets = new address[](1);\\n                assets[0] = token;\\n                // amounts of assets to flashloan.\\n                uint256[] memory amounts = new uint256[](1);\\n                amounts[0] = amount;\\n                // 0 = no debt (just revert), 1 = stable, 2 = variable\\n                uint256[] memory modes = new uint256[](1);\\n                modes[0] = 0;\\n                ILendingPool(LENDING_POOL_ADDRESS).flashLoan(\\n                    me,\\n                    assets,\\n                    amounts,\\n                    modes,\\n                    me,\\n                    transactions,\\n                    uint16(0)\\n                );\\n            }\\n        } else {\\n            revert UnsupportedToken();\\n        }\\n        // check profit exceeds gas cost\\n        uint256 profit = ((ERC20(token).balanceOf(me) - balBefore) *\\n            (10000 - uint256(GOV_FEE))) / 10000;\\n        if ((startGas - gasleft()) * block.basefee > _ethValue(token, profit))\\n            revert InsufficientOutputAmount();\\n        ERC20(token).safeTransfer(sender, profit);\\n        emit MEV(token, profit); // emit MEV event\\n    }\\n\\n    /// @notice Sweep tokens and eth to recipient\\n    /// @param tokens Array of token addresses\\n    /// @param recipient Address of recipient\\n    function sweep(address[] calldata tokens, address recipient) external {\\n        if (msg.sender != GOV) revert Unauthorized();\\n        for (uint256 i; i < tokens.length; i++) {\\n            address token = tokens[i];\\n            ERC20(token).safeTransfer(\\n                recipient,\\n                ERC20(token).balanceOf(address(this))\\n            );\\n        }\\n        SafeTransferLib.safeTransferETH(recipient, address(this).balance);\\n    }\\n\\n    /// @notice Admin function to remove code from blockchain and receive rebate\\n    /// @param recipient Address of rebate recipient\\n    function destroy(address payable recipient) external {\\n        if (msg.sender != GOV) revert Unauthorized();\\n        selfdestruct(recipient);\\n    }\\n\\n    /// @notice Called from BentoBox Lending pool after contract has received the flash loaned amount\\n    /// @dev Reverts if not profitable.\\n    /// @param sender Address of flashloan initiator\\n    /// @param token Token to loan\\n    /// @param amount Amount to loan\\n    /// @param fee Fee to repay on loan amount\\n    /// @param data Encoded factories and tokens\\n    function onFlashLoan(\\n        address sender,\\n        address token,\\n        uint256 amount,\\n        uint256 fee,\\n        bytes calldata data\\n    ) external {\\n        if (msg.sender != BENTO) revert Unauthorized();\\n        _executeTransactions(data);\\n        ERC20(token).safeTransfer(BENTO, amount + fee);\\n    }\\n\\n    /// @notice Called from Aave Lending pool after contract has received the flash loaned amount (https://docs.aave.com/developers/v/2.0/guides/flash-loans)\\n    /// @dev Reverts if not profitable.\\n    /// @param assets Array of tokens to loan\\n    /// @param amounts Array of amounts to loan\\n    /// @param premiums Array of premiums to repay on loan amounts\\n    /// @param initiator Address of flashloan initiator\\n    /// @param params Encoded factories and tokens\\n    /// @return success indicating success\\n    function executeOperation(\\n        address[] calldata assets,\\n        uint256[] calldata amounts,\\n        uint256[] calldata premiums,\\n        address initiator,\\n        bytes calldata params\\n    ) external returns (bool) {\\n        if (msg.sender != LENDING_POOL_ADDRESS) revert Unauthorized();\\n        _executeTransactions(params);\\n        ERC20(assets[0]).safeApprove(\\n            LENDING_POOL_ADDRESS,\\n            amounts[0] + premiums[0]\\n        );\\n        return true;\\n    }\\n\\n    /// @notice Called from Balancer vault after contract has received flashloan\\n    /// @param tokens Array of tokens to loan\\n    /// @param amounts Array of amounts to loan\\n    /// @param feeAmounts Array of fees to repay on loan amounts\\n    function receiveFlashLoan(\\n        address[] memory tokens,\\n        uint256[] memory amounts,\\n        uint256[] memory feeAmounts,\\n        bytes memory userData\\n    ) external override {\\n        if (msg.sender != VAULT) revert Unauthorized();\\n        _executeTransactions(userData);\\n        ERC20(tokens[0]).safeTransfer(VAULT, amounts[0] + feeAmounts[0]);\\n    }\\n\\n    /// @notice Calculate eth value of a token amount\\n    /// @param token Address of token\\n    /// @param amount Amount of token\\n    /// @return eth value\\n    function _ethValue(\\n        address token,\\n        uint256 amount\\n    ) internal view returns (uint256) {\\n        if (token == WETH09) return amount;\\n        if (token == mevETH) return amount;\\n        address[] memory path = new address[](2);\\n        path[0] = token;\\n        path[1] = WETH09;\\n        uint256[] memory amounts = IUniswapV2Router02(ORACLE_ROUTER)\\n            .getAmountsOut(amount, path);\\n        if (amounts.length < 2) return 0;\\n        return amounts[1];\\n    }\\n\\n    /// @dev Sends multiple transactions\\n    /// @param transactions Encoded transactions. Each transaction is encoded as a packed bytes of\\n    ///                     value as a uint256 (=> 32 bytes),\\n    ///                     contract address (20 bytes)\\n    ///                     data length as a uint16 (=> 2 bytes),\\n    ///                     data as bytes.\\n    ///                     see abi.encodePacked for more information on packed encoding\\n    function _executeTransactions(bytes memory transactions) internal {\\n        assembly (\\\"memory-safe\\\") {\\n            let length := mload(transactions)\\n            let i := 0x20\\n            for {\\n                // Pre block is not used in \\\"while mode\\\"\\n            } lt(i, length) {\\n                // Post block is not used in \\\"while mode\\\"\\n            } {\\n                // let value = mload(add(transactions, i))\\n                let to := and(\\n                    shr(96, mload(add(transactions, add(i, 0x20)))),\\n                    0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\\n                )\\n                let dataLength := and(\\n                    shr(240, mload(add(transactions, add(i, 0x34)))),\\n                    0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\\n                )\\n                let success := call(\\n                    gas(), // gas left\\n                    to, // router\\n                    mload(add(transactions, i)), // value\\n                    add(transactions, add(i, 0x36)), // input data (0x(4 byte func sig hash)(abi encoded args))\\n                    dataLength, // input data byte length\\n                    0, // output\\n                    0 // output byte length\\n                )\\n                if iszero(success) {\\n                    revert(0, 0)\\n                }\\n                // Next entry starts at 0x35 byte + data length\\n                i := add(i, add(0x36, dataLength))\\n            }\\n        }\\n    }\\n\\n    /// @notice Function to receive Ether. msg.data must be empty\\n    receive() external payable {}\\n\\n    /// @notice Fallback function is called when msg.data is not empty\\n    fallback() external payable {}\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IBentoBoxV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.8.17 <0.9.0;\\n\\nimport \\\"./IFlashBorrower.sol\\\";\\n\\n/// @notice Minimal interface for BentoBox token vault (V1) interactions\\ninterface IBentoBoxV1 {\\n    function flashLoan(\\n        IFlashBorrower borrower,\\n        address receiver,\\n        address token,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IFlashBorrower.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.8.17 <0.9.0;\\n\\ninterface IFlashBorrower {\\n    /// @notice The flashloan callback. `amount` + `fee` needs to repayed to msg.sender before this call returns.\\n    /// @param sender The address of the invoker of this flashloan.\\n    /// @param token The address of the token that is loaned.\\n    /// @param amount of the `token` that is loaned.\\n    /// @param fee The fee that needs to be paid on top for this loan. Needs to be the same as `token`.\\n    /// @param data Additional data that was passed to the flashloan function.\\n    function onFlashLoan(\\n        address sender,\\n        address token,\\n        uint256 amount,\\n        uint256 fee,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IFlashLoanReceiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity >=0.8.17 <0.9.0;\\n\\n/**\\n * @title IFlashLoanReceiver interface\\n * @notice Interface for the Aave fee IFlashLoanReceiver.\\n * @author Aave\\n * @dev implement this interface to develop a flashloan-compatible flashLoanReceiver contract\\n **/\\ninterface IFlashLoanReceiver {\\n    function executeOperation(\\n        address[] calldata assets,\\n        uint256[] calldata amounts,\\n        uint256[] calldata premiums,\\n        address initiator,\\n        bytes calldata params\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IFlashLoanRecipient.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity >=0.7.0 <0.9.0;\\n\\n// Inspired by Aave Protocol's IFlashLoanReceiver.\\n\\ninterface IFlashLoanRecipient {\\n    /**\\n     * @dev When `flashLoan` is called on the Vault, it invokes the `receiveFlashLoan` hook on the recipient.\\n     *\\n     * At the time of the call, the Vault will have transferred `amounts` for `tokens` to the recipient. Before this\\n     * call returns, the recipient must have transferred `amounts` plus `feeAmounts` for each token back to the\\n     * Vault, or else the entire flash loan will revert.\\n     *\\n     * `userData` is the same value passed in the `IVault.flashLoan` call.\\n     */\\n    function receiveFlashLoan(\\n        address[] memory tokens,\\n        uint256[] memory amounts,\\n        uint256[] memory feeAmounts,\\n        bytes memory userData\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ILendingPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\n\\npragma solidity >=0.8.17 <0.9.0;\\n\\ninterface ILendingPool {\\n    /**\\n     * @dev Allows smartcontracts to access the liquidity of the pool within one transaction,\\n     * as long as the amount taken plus a fee is returned.\\n     * IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept into consideration.\\n     * For further details please visit https://developers.aave.com\\n     * @param receiverAddress The address of the contract receiving the funds, implementing the IFlashLoanReceiver interface\\n     * @param assets The addresses of the assets being flash-borrowed\\n     * @param amounts The amounts amounts being flash-borrowed\\n     * @param modes Types of the debt to open if the flash loan is not returned:\\n     *   0 -> Don't open any debt, just revert if funds can't be transferred from the receiver\\n     *   1 -> Open debt at stable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\\n     *   2 -> Open debt at variable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\\n     * @param onBehalfOf The address  that will receive the debt in the case of using on `modes` 1 or 2\\n     * @param params Variadic packed params to pass to the receiver as extra information\\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\\n     *   0 if the action is executed directly by the user, without any middle-man\\n     **/\\n    function flashLoan(\\n        address receiverAddress,\\n        address[] calldata assets,\\n        uint256[] calldata amounts,\\n        uint256[] calldata modes,\\n        address onBehalfOf,\\n        bytes calldata params,\\n        uint16 referralCode\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IProtocolDataProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity >=0.8.17 <0.9.0;\\n\\ninterface IProtocolDataProvider {\\n    /**\\n     * @notice getReserveData() allows users to get the available liquidity of a given asset.\\n     * @dev getReserveData() takes an address of an asset as an argument and returns the available liquidity of that asset.\\n     */\\n    function getReserveData(\\n        address asset\\n    ) external view returns (uint256 availableLiquidity);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IUniswapV2Router02.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity >=0.8.13 <0.9.0;\\n\\ninterface IUniswapV2Router02 {\\n    function getAmountsOut(\\n        uint256 amountIn,\\n        address[] calldata path\\n    ) external view returns (uint256[] memory amounts);\\n\\n    function swapExactETHForTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint[] memory amounts);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity >=0.8.17 <0.9.0;\\n\\nimport \\\"./IFlashLoanRecipient.sol\\\";\\n\\n/**\\n * @dev Full external interface for the Vault core contract - no external or public methods exist in the contract that\\n * don't override one of these declarations.\\n */\\ninterface IVault {\\n    // Flash Loans\\n\\n    /**\\n     * @dev Performs a 'flash loan', sending tokens to `recipient`, executing the `receiveFlashLoan` hook on it,\\n     * and then reverting unless the tokens plus a proportional protocol fee have been returned.\\n     *\\n     * The `tokens` and `amounts` arrays must have the same length, and each entry in these indicates the loan amount\\n     * for each token contract. `tokens` must be sorted in ascending order.\\n     *\\n     * The 'userData' field is ignored by the Vault, and forwarded as-is to `recipient` as part of the\\n     * `receiveFlashLoan` call.\\n     *\\n     * Emits `FlashLoan` events.\\n     */\\n    function flashLoan(\\n        IFlashLoanRecipient recipient,\\n        address[] memory tokens,\\n        uint256[] memory amounts,\\n        bytes memory userData\\n    ) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/solmate/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"solmate/=lib/solmate/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 2000,\r\n      \"details\": {\r\n        \"constantOptimizer\": true,\r\n        \"yul\": true,\r\n        \"yulDetails\": {\r\n          \"stackAllocation\": true\r\n        }\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"viaIR\": true,\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_govFee\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"_mevETH\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_oracleRouter\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"InsufficientOutputAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Unauthorized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnsupportedToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroAddress\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"MEV\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"destroy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"assets\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"premiums\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"initiator\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"params\",\"type\":\"bytes\"}],\"name\":\"executeOperation\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"useBalancer\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"transactions\",\"type\":\"bytes\"}],\"name\":\"flash\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gov\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"friend\",\"type\":\"address\"}],\"name\":\"isFriend\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"onFlashLoan\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"feeAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"userData\",\"type\":\"bytes\"}],\"name\":\"receiveFlashLoan\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"sweep\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_newFee\",\"type\":\"uint8\"}],\"name\":\"updateFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"flashAllowed\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"friend\",\"type\":\"address\"}],\"name\":\"updateFriend\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newGov\",\"type\":\"address\"}],\"name\":\"updateGov\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newMevEth\",\"type\":\"address\"}],\"name\":\"updateMevETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_oracleRouter\",\"type\":\"address\"}],\"name\":\"updateOracle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "FlashMEV", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "2000", "ConstructorArguments": "00000000000000000000000000000000000000000000000000000000000000010000000000000000000000007f39c581f595b53c5cb19bd0b3f8da6c935e2ca000000000000000000000000077337deea78720542f0a1325394def165918d562", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}