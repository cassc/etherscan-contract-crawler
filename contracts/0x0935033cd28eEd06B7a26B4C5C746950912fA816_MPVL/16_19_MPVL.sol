//SPDX-License-Identifier: MIT
/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@          @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*/
/**
 * @dev: @brougkr
 */
pragma solidity 0.8.17;
import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";
import {ReentrancyGuard} from "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import {MerkleProof} from "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol";
import {IERC721} from "@openzeppelin/contracts/token/ERC721/IERC721.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {DefaultOperatorFilterer} from "operator-filter-registry/src/DefaultOperatorFilterer.sol";
import {ERC721AO} from "./ERC721AO.sol";
contract MPVL is ERC721AO, Ownable, ReentrancyGuard, DefaultOperatorFilterer
{    
    struct MintPass
    {
        uint _PriceStart;                 // [0] -> _PriceStart
        uint _PriceEnd;                   // [1] -> _PriceEnd
        uint _MaximumAvailableForSale;    // [2] -> _MaximumAvailableForSale
        uint _UnixTimestampStartingBlock; // [3] -> _UnixTimestampStartingBlock
        uint _SecondsBetweenPriceDecay;   // [5] -> _SecondsBetweenPriceDecay
        bool _Active;                     // [6] -> _Active
    }
    struct InternalSale
    {
        uint _AmountSold;         // [0] -> _AmountSold
        uint _FinalClearingPrice; // [1] -> _FinalClearingPrice
        uint _UniqueSales;        // [2] -> _UniqueSales
    }
    struct UserSaleInformation
    {
        uint _UserCurrentPrice;       // [0] -> _UserCurrentPrice
        uint _UserAmountPurchased;    // [1] -> _UserAmountPurchased
        uint _UserFullSetAllocation;  // [2] -> _UserFullSetAllocation
        uint _UserAmountRemaining;    // [3] -> _UserAmountRemaining
        bool _UserBrightListEligible; // [4] -> _UserBrightListEligible
        bool _UserSalePaused;         // [5] -> _UserSalePaused
    }
    struct SaleInformation
    {
        uint _UserCurrentPrice;  // [0] -> _UserCurrentPrice
        uint _UserRemaining;     // [1] -> _UserRemaining
        uint _UserSaleStartTime; // [2] -> _UserSaleStartTime
        uint _UserStartingPrice; // [3] -> _UserStartingPrice
        uint _UserEndingPrice;   // [4] -> _UserEndingPrice
    }
    MintPass public MintPassSale = MintPass(
        10 ether,   // [0] -> _PriceStart    
        1 ether,    // [1] -> _PriceEnd 
        95,         // [2] -> _MaximumAvailableForSale
        1672941600, // [3] -> _UnixTimestampStartingBlock
        1084,       // [4] -> _SecondsBetweenPriceDecay
        true        // [5] -> _Active
    ); 
    InternalSale public MintPassInternalSale = InternalSale(
        0,   // [0] -> _AmountSold
        0,   // [1] -> _FinalClearingPrice
        0    // [2] -> _UniqueSales
    );

    mapping(uint=>address) public UniqueSaleIndexToAddress; // `OrderID` => `Recipient`
    mapping(uint=>uint) public UniqueSalePurchaseAmount;    // `OrderID` => `Order Amount`
    mapping(uint=>uint) public UniqueSaleToOrderValue;      // `OrderID` => `Order Value`
    mapping(uint=>bool) public UniqueSaleBrightListStatus;  // `OrderID` => `BrightListed`
    mapping(uint=>uint) public UniqueSalePriorityStatus;    // `OrderID` => `Priority`
    mapping(uint=>uint) public _PriorityDiscount;           // `PriorityIndex` => `Discount` note: True Discount = 100 - `Discount`
    mapping(address=>uint) public _UserPurchasedAmt;        // `Wallet` => `Total Purchased Amount`
    mapping(address=>uint) public _FullSetAllocation;       // `Wallet` => `Purchasable Amount`

    uint private constant MAXIMUM_PURCHASE_AMOUNT = 3;
    uint public CurrentOrderRefundIndex;
    bytes32 public _Root = 0x78d93569ac75572abf80be2c47cb072b145b85163d0e7fd48c598ded5b082115;
    address public _LiveMint = 0xf441aAF6a47c8A0e2d6317de6cB20a8f43481544;   
    string public baseURI = "ipfs://QmYeQYssyZApy64V7ewiiVz1eLhFPTA6hGQ3AzXSPoN7pd/";
    
    event Purchased(address Recipient, uint Amount, uint MessageValue, uint PurchaseValue, uint AmountSold);
    event RefundReverted(uint OrderIndex);
    event NewTimestamp(uint Timestamp);
    event Refunded(uint RefundAmount);

    constructor() ERC721AO("Mint Pass Velum | Harvey Rayner | MPVL", "MPVL")
    {
        _PriorityDiscount[0] = 80; // 100 - 80 = 20% Discount => Full Set                       
        _PriorityDiscount[1] = 90; // 100 - 90 = 10% Discount => Citizen || Fontana || 3+ Photon
        _PriorityDiscount[0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff] = 100; // 0% Discount
        _mint(0xB96E81f80b3AEEf65CB6d0E280b15FD5DBE71937, 5);
    }

    /*---------------------
     * EXTERNAL FUNCTIONS *
    ----------------------*/

    /**
     * @dev Purchases NFTs
     */
    function PurchasePass(uint Amount, bytes32[] calldata Proof) external payable nonReentrant
    { 
        require(block.timestamp >= MintPassSale._UnixTimestampStartingBlock, "MP: Sale Not Started Yet");
        require(tx.origin == msg.sender, "MP: EOA Only");
        require(MintPassSale._Active, "MP: Sale Ended");
        (bool BrightListEligible, uint Priority) = VerifyBrightList(msg.sender, Proof);
        if(BrightListEligible)
        {
            if(_FullSetAllocation[msg.sender] > 0) 
            { 
                if(Amount > _FullSetAllocation[msg.sender])
                {
                    Amount = _FullSetAllocation[msg.sender];
                    if(Amount > MAXIMUM_PURCHASE_AMOUNT) { Amount = MAXIMUM_PURCHASE_AMOUNT; } // Only Allows Up To Maximum Purchase
                }
                _FullSetAllocation[msg.sender] -= Amount;
                Priority = 0; // Highest Priority (Full Set)
            }
            else { Priority = 1; } // Second Highest Priority (Citizen || Fontana || 3+ Photon)
        }
        if(MintPassInternalSale._AmountSold + Amount > MintPassSale._MaximumAvailableForSale)
        {
            Amount = MintPassSale._MaximumAvailableForSale - MintPassInternalSale._AmountSold;
        }
        uint NewAmountSold = MintPassInternalSale._AmountSold + Amount;
        require(NewAmountSold <= MintPassSale._MaximumAvailableForSale, "MP: Sold Out");
        uint NewUserPurchasedAmount = _UserPurchasedAmt[msg.sender] + Amount;
        require(Amount > 0 && Amount <= MAXIMUM_PURCHASE_AMOUNT, "MP: Incorrect Amount");
        uint CurrentPrice = ViewCurrentPriceMintPass();
        uint CurrentPurchaseValue = CurrentPrice * Amount;
        require(msg.value >= CurrentPurchaseValue, "MP: Incorrect ETH Amount Sent");
        if(msg.value > CurrentPurchaseValue) { __Refund(msg.sender, (msg.value - CurrentPurchaseValue)); } // Refunds The Intra-Transaction Difference
        UniqueSaleToOrderValue[MintPassInternalSale._UniqueSales] = CurrentPurchaseValue;
        UniqueSaleIndexToAddress[MintPassInternalSale._UniqueSales] = msg.sender; 
        UniqueSalePurchaseAmount[MintPassInternalSale._UniqueSales] = Amount;
        UniqueSaleBrightListStatus[MintPassInternalSale._UniqueSales] = BrightListEligible;
        UniqueSalePriorityStatus[MintPassInternalSale._UniqueSales] = Priority;
        MintPassInternalSale._UniqueSales = MintPassInternalSale._UniqueSales + 1;
        MintPassInternalSale._AmountSold = NewAmountSold;
        _UserPurchasedAmt[msg.sender] = NewUserPurchasedAmount;
        require(MintPassInternalSale._AmountSold <= MintPassSale._MaximumAvailableForSale, "MP: Overflow");
        if(MintPassInternalSale._AmountSold == MintPassSale._MaximumAvailableForSale) // End Sales
        { 
            MintPassInternalSale._FinalClearingPrice = CurrentPrice; 
            ___EndMintPassSale();
        }
        _mint(msg.sender, Amount);
        emit Purchased(msg.sender, Amount, msg.value, CurrentPurchaseValue, NewAmountSold);
    }
    
    /*------------------
     * ADMIN FUNCTIONS *
    -------------------*/

    /**
     * @dev Seeds Full Set Allocations
     * note: This Is In-Lieu Of A Merkle Proof uint Validation, Which Is The Better Approach 
     */
    function __SeedFullSetAllocations(address[] calldata Wallets, uint[] calldata Amounts) external onlyOwner
    {
        for(uint x; x < Wallets.length; x++) { _FullSetAllocation[Wallets[x]] = Amounts[x]; }
    }

    /**
     * @dev Changes The Operator Filter State
     */
    function __ChangeOperatorFilterState(bool State) external onlyOwner { OPERATOR_FILTER_ENABLED = State; }

    /**
     * @dev Overrides Clearing Price
     */
    function __OverrideClearingPrice(uint Price) external onlyOwner { MintPassInternalSale._FinalClearingPrice = Price; }

    /**
     * @dev Initiates Withdraw Of Refunds & Sale Proceeds
     */
    function __InitiateRefundsAndProceeds() external onlyOwner
    {
        require(MintPassInternalSale._FinalClearingPrice > 0, "Final Clearing Price Not Seeded");
        for(uint OrderIndex = CurrentOrderRefundIndex; OrderIndex < MintPassInternalSale._UniqueSales; OrderIndex++)
        {
            if(!UniqueSaleBrightListStatus[OrderIndex]) // No Discount
            {
                (bool ConfirmedRefund,) = UniqueSaleIndexToAddress[OrderIndex].call{
                    value: UniqueSaleToOrderValue[OrderIndex] - (MintPassInternalSale._FinalClearingPrice * UniqueSalePurchaseAmount[OrderIndex])
                } ("");
                if(!ConfirmedRefund) { emit RefundReverted(OrderIndex); }
            }
            else // BrightList Discount
            {
                (bool ConfirmedRefund,) = UniqueSaleIndexToAddress[OrderIndex].call{
                    value: UniqueSaleToOrderValue[OrderIndex] - (
                        (
                            (MintPassInternalSale._FinalClearingPrice * _PriorityDiscount[UniqueSalePriorityStatus[OrderIndex]]) 
                            / 
                            100
                        )
                        * 
                        UniqueSalePurchaseAmount[OrderIndex]
                    )
                } ("");
                if(!ConfirmedRefund) { emit RefundReverted(OrderIndex); }
            }
        }
        (bool ConfirmedWithdraw,) = msg.sender.call{ value: address(this).balance }(""); 
        require(ConfirmedWithdraw, "MP: Multisig Refund Failed, Use Other Withdraw Function");
        CurrentOrderRefundIndex = MintPassInternalSale._UniqueSales;
    }

    /**
     * @dev Changes Sale Start Block
     */
    function __NewBlockTimestampStart(uint Timestamp) external onlyOwner
    {
        MintPassSale._UnixTimestampStartingBlock = Timestamp;
        emit NewTimestamp(Timestamp);
    }

    /**
     * @dev Changes Merkle Root
     */
    function __NewRoot(bytes32 Root) external onlyOwner { _Root = Root; }

    /**
     * @dev Changes Ending Price For Mint Pass *** DENOTED IN WEI ***
     */
    function __NewEndingPrice(uint PriceEnd) external onlyOwner 
    { 
        MintPassSale._PriceEnd = PriceEnd; 
    }

    /**
     * @dev Instantiates New LiveMint Address
     */
    function __NewLiveMintAddress(address NewAddress) external onlyOwner { _LiveMint = NewAddress; }

    /**
     * @dev Changes The BaseURI For JSON Metadata 
     */
    function __NewBaseURI(string calldata NewURI) external onlyOwner { baseURI = NewURI; }

    /**
     * @dev Withdraws All Ether From The Contract
     */
    function ___WithdrawEther() external onlyOwner { payable(msg.sender).transfer(address(this).balance); }

    /**
     * @dev Withdraws Ether From Contract To Address With An Amount
     */
    function ___WithdrawEtherToAddress(address payable Recipient, uint Amount) external onlyOwner
    {
        require(Amount > 0 && Amount <= address(this).balance, "Invalid Amount");
        (bool Success, ) = Recipient.call{value: Amount}("");
        require(Success, "Unable to Withdraw, Recipient May Have Reverted");
    }

    /**
     * @dev Withdraws ERC721s From Contract
     */
    function ___WithdrawERC721(address Contract, address Recipient, uint[] calldata TokenIDs) external onlyOwner 
    { 
        for(uint TokenID; TokenID < TokenIDs.length; TokenID++)
        {
            IERC721(Contract).transferFrom(address(this), Recipient, TokenIDs[TokenID]);
        }
    }

    /*-----------------
     * VIEW FUNCTIONS *
    ------------------*/

    /**
     * @dev Returns MP Sale Information
     */
    function ViewAllMPSaleInformation() public view returns (MintPass memory, SaleInformation memory) 
    {
        return(
            MintPassSale,
            SaleInformation(
                ViewCurrentPriceMintPass(),
                MintPassSale._MaximumAvailableForSale - MintPassInternalSale._AmountSold,
                MintPassSale._UnixTimestampStartingBlock,
                MintPassSale._PriceStart,
                MintPassSale._PriceEnd
            )
        );
    }

    /**
     * @dev Returns MP Sale Information For A Given Wallet
     */
    function ViewWalletSaleInformation(
        address Wallet,
        bytes32[] calldata Proof
    ) external view returns (UserSaleInformation memory) {
        bool MintPassSalePaused;
        (bool BrightList, uint Priority) = VerifyBrightList(Wallet, Proof);
        if(
            !(MintPassSale._Active)
            &&
            (MintPassSale._MaximumAvailableForSale - MintPassInternalSale._AmountSold > 0)
        ) { MintPassSalePaused = true; }      
        return(
            UserSaleInformation(
                ViewCurrentPriceMintPass(),
                _UserPurchasedAmt[Wallet],
                _FullSetAllocation[Wallet],
                MintPassSale._MaximumAvailableForSale - MintPassInternalSale._AmountSold,
                BrightList,
                MintPassSalePaused
            )
        );
    }

    /**
     * @dev Returns The Total Refund Total
     */
    function ViewRefundTotalForWallet(address Wallet) public view returns(uint, uint[] memory)
    {
        uint[] memory _OrderIndexes = new uint[](MintPassInternalSale._UniqueSales);
        uint _UniqueIndexes;
        uint _RefundTotal;
        uint _RefundTx;
        uint _Price = ViewCurrentPriceMintPass();
        for(uint OrderIndex; OrderIndex < MintPassInternalSale._UniqueSales; OrderIndex++)
        {
            if(UniqueSaleIndexToAddress[OrderIndex] == Wallet)
            {
                if(!UniqueSaleBrightListStatus[OrderIndex]) // No Discount
                {
                    _RefundTx = UniqueSaleToOrderValue[OrderIndex] - (
                        _Price * UniqueSalePurchaseAmount[OrderIndex]
                    );
                    _RefundTotal += _RefundTx;
                }
                else // BrightList Discount
                {
                    _RefundTx = UniqueSaleToOrderValue[OrderIndex] - (
                            (
                                (_Price * _PriorityDiscount[UniqueSalePriorityStatus[OrderIndex]]) 
                                / 
                                100
                            )
                            * 
                            UniqueSalePurchaseAmount[OrderIndex]
                    );
                    _RefundTotal += _RefundTx; 
                }
                _OrderIndexes[_UniqueIndexes] = OrderIndex;
                _UniqueIndexes += 1;
            }
        }
        uint[] memory _FormattedIndexes = new uint[](_UniqueIndexes);
        for(uint x; x < _UniqueIndexes; x++) { _FormattedIndexes[x] = _OrderIndexes[x]; }
        return (_RefundTotal, _FormattedIndexes);
    }

    /**
     * @dev Returns The Total Refund Total
     */
    function ViewRefundTotal() public view returns(uint)
    {
        uint _RefundTotal;
        uint _RefundTx;
        uint _Price = ViewCurrentPriceMintPass();
        for(uint OrderIndex; OrderIndex < MintPassInternalSale._UniqueSales; OrderIndex++)
        {
            if(!UniqueSaleBrightListStatus[OrderIndex]) // No Discount
            {
                _RefundTx = UniqueSaleToOrderValue[OrderIndex] - (
                    _Price * UniqueSalePurchaseAmount[OrderIndex]
                );
                _RefundTotal += _RefundTx;
            }
            else // BrightList Discount
            {
                _RefundTx = UniqueSaleToOrderValue[OrderIndex] - (
                        (
                            (_Price * _PriorityDiscount[UniqueSalePriorityStatus[OrderIndex]]) 
                            / 
                            100
                        )
                        * 
                        UniqueSalePurchaseAmount[OrderIndex]
                );
                _RefundTotal += _RefundTx; 
            }
        }
        return _RefundTotal;
    }

    /**
     * @dev Returns Net Profits In WEI
     */
    function ViewProfitsMinusRefunds() public view returns(uint) { return (address(this).balance - ViewRefundTotal()); }

    /*---------------------
     * INTERNAL FUNCTIONS *
    ----------------------*/

    /**
     * @dev Returns Current Dutch Price For Mint Pass
     */
    function ViewCurrentPriceMintPass() internal view returns (uint Price) 
    {
        if(block.timestamp <= MintPassSale._UnixTimestampStartingBlock) { return MintPassSale._PriceStart; }  // Sale Not Started
        if(MintPassInternalSale._FinalClearingPrice > 0) { return MintPassInternalSale._FinalClearingPrice; } // Sale Finished
        uint CurrentPrice = MintPassSale._PriceStart;
        uint SecondsElapsed = block.timestamp - MintPassSale._UnixTimestampStartingBlock;
        CurrentPrice >>= SecondsElapsed / MintPassSale._SecondsBetweenPriceDecay; // Div/2 For Each Half Life Iterated Upon
        CurrentPrice -= (CurrentPrice * (SecondsElapsed % MintPassSale._SecondsBetweenPriceDecay)) / MintPassSale._SecondsBetweenPriceDecay / 2;
        if(CurrentPrice <= MintPassSale._PriceEnd) { return MintPassSale._PriceEnd; } // Sale Ended At Resting Band
        return CurrentPrice; // Sale Currently Active
    }

    /**
     * @dev Returns Base URI
     */
    function _baseURI() internal view virtual override returns (string memory) { return baseURI; }

    /**
     * @dev Returns If User Is On BrightList
     */
    function VerifyBrightList(address Recipient, bytes32[] calldata Proof) public view returns (bool, uint)
    {
        bytes32 Leaf = keccak256(abi.encodePacked(Recipient));
        bool Eligible = MerkleProof.verify(Proof, _Root, Leaf); 
        if(Eligible) { return(true, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff); } // Eligible
        else { return(false, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff); } // Not Eligible
    }

    /**
     * @dev Ends Mint Pass Sale On Sellout
     */
    function ___EndMintPassSale() internal { MintPassSale._Active = false; }

    /**
     * @dev Refunds `Recipient` ETH Amount `Value`
     */
    function __Refund(address Recipient, uint Value) internal
    {
        (bool Confirmed,) = Recipient.call{value: Value}(""); 
        require(Confirmed, "MP: Refund failed");
        emit Refunded(Value);
    }

    /*---------------------
     * OVERRIDE FUNCTIONS *
    ----------------------*/

    function setApprovalForAll(
        address operator, 
        bool approved
    ) public override onlyAllowedOperatorApproval(operator) { super.setApprovalForAll(operator, approved); }

    function approve(
        address operator, 
        uint256 tokenId
    ) public override onlyAllowedOperatorApproval(operator) { super.approve(operator, tokenId); }

    function transferFrom(
        address from, 
        address to, 
        uint256 tokenId
    ) public override onlyAllowedOperator(from) { super.transferFrom(from, to, tokenId); }

    function safeTransferFrom(
        address from, 
        address to, 
        uint256 tokenId
    ) public override onlyAllowedOperator(from) { super.safeTransferFrom(from, to, tokenId); }

    function safeTransferFrom(
        address from, 
        address to, 
        uint256 tokenId, 
        bytes memory data
    ) public override onlyAllowedOperator(from) { super.safeTransferFrom(from, to, tokenId, data); }

    /*--------------------
     * LIVEMINT FUNCTION *
    ---------------------*/

    /**
     * @dev LiveMint Redeems Mint Pass If Not Already Burned & Sends Minted Work To Owner's Wallet
     */
    function _LiveMintBurn(uint TokenID) external returns (address _Recipient)
    {
        require(msg.sender == _LiveMint, "MP: Sender Is Not Live Mint");
        address Recipient = IERC721(address(this)).ownerOf(TokenID);
        require(Recipient != address(0), "MP: Invalid Recipient");
        _burn(TokenID, false);
        return (Recipient);
    }
}