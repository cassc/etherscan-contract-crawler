{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Metadata is IERC721 {\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     *\\n     * Furthermore, `isContract` will also return true if the target contract within\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\n     * which only has an effect at the end of a transaction.\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Base64.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Base64.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides a set of functions to operate with Base64 strings.\\n *\\n * _Available since v4.5._\\n */\\nlibrary Base64 {\\n    /**\\n     * @dev Base64 Encoding/Decoding Table\\n     */\\n    string internal constant _TABLE = \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\\\";\\n\\n    /**\\n     * @dev Converts a `bytes` to its Bytes64 `string` representation.\\n     */\\n    function encode(bytes memory data) internal pure returns (string memory) {\\n        /**\\n         * Inspired by Brecht Devos (Brechtpd) implementation - MIT licence\\n         * https://github.com/Brechtpd/base64/blob/e78d9fd951e7b0977ddca77d92dc85183770daf4/base64.sol\\n         */\\n        if (data.length == 0) return \\\"\\\";\\n\\n        // Loads the table into memory\\n        string memory table = _TABLE;\\n\\n        // Encoding takes 3 bytes chunks of binary data from `bytes` data parameter\\n        // and split into 4 numbers of 6 bits.\\n        // The final Base64 length should be `bytes` data length multiplied by 4/3 rounded up\\n        // - `data.length + 2`  -> Round up\\n        // - `/ 3`              -> Number of 3-bytes chunks\\n        // - `4 *`              -> 4 characters for each chunk\\n        string memory result = new string(4 * ((data.length + 2) / 3));\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Prepare the lookup table (skip the first \\\"length\\\" byte)\\n            let tablePtr := add(table, 1)\\n\\n            // Prepare result pointer, jump over length\\n            let resultPtr := add(result, 32)\\n\\n            // Run over the input, 3 bytes at a time\\n            for {\\n                let dataPtr := data\\n                let endPtr := add(data, mload(data))\\n            } lt(dataPtr, endPtr) {\\n\\n            } {\\n                // Advance 3 bytes\\n                dataPtr := add(dataPtr, 3)\\n                let input := mload(dataPtr)\\n\\n                // To write each character, shift the 3 bytes (18 bits) chunk\\n                // 4 times in blocks of 6 bits for each character (18, 12, 6, 0)\\n                // and apply logical AND with 0x3F which is the number of\\n                // the previous character in the ASCII table prior to the Base64 Table\\n                // The result is then added to the table to get the character to write,\\n                // and finally write it in the result pointer but with a left shift\\n                // of 256 (1 byte) - 8 (1 ASCII char) = 248 bits\\n\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1) // Advance\\n\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1) // Advance\\n\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(6, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1) // Advance\\n\\n                mstore8(resultPtr, mload(add(tablePtr, and(input, 0x3F))))\\n                resultPtr := add(resultPtr, 1) // Advance\\n            }\\n\\n            // When data `bytes` is not exactly 3 bytes long\\n            // it is padded with `=` characters at the end\\n            switch mod(mload(data), 3)\\n            case 1 {\\n                mstore8(sub(resultPtr, 1), 0x3d)\\n                mstore8(sub(resultPtr, 2), 0x3d)\\n            }\\n            case 2 {\\n                mstore8(sub(resultPtr, 1), 0x3d)\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1, \\\"Math: mulDiv overflow\\\");\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SignedMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard signed math utilities missing in the Solidity language.\\n */\\nlibrary SignedMath {\\n    /**\\n     * @dev Returns the largest of two signed numbers.\\n     */\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two signed numbers.\\n     */\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two signed numbers without overflow.\\n     * The result is rounded towards zero.\\n     */\\n    function average(int256 a, int256 b) internal pure returns (int256) {\\n        // Formula from the book \\\"Hacker's Delight\\\"\\n        int256 x = (a & b) + ((a ^ b) >> 1);\\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\\n    }\\n\\n    /**\\n     * @dev Returns the absolute unsigned value of a signed value.\\n     */\\n    function abs(int256 n) internal pure returns (uint256) {\\n        unchecked {\\n            // must be unchecked in order to support `n = type(int256).min`\\n            return uint256(n >= 0 ? n : -n);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/Math.sol\\\";\\nimport \\\"./math/SignedMath.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(int256 value) internal pure returns (string memory) {\\n        return string(abi.encodePacked(value < 0 ? \\\"-\\\" : \\\"\\\", toString(SignedMath.abs(value))));\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n\\n    /**\\n     * @dev Returns true if the two strings are equal.\\n     */\\n    function equal(string memory a, string memory b) internal pure returns (bool) {\\n        return keccak256(bytes(a)) == keccak256(bytes(b));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Honeycombs.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\nimport \\\"./interfaces/IHoneycombs.sol\\\";\\nimport \\\"./libraries/HoneycombsArt.sol\\\";\\nimport \\\"./libraries/HoneycombsMetadata.sol\\\";\\nimport \\\"./libraries/Utilities.sol\\\";\\nimport \\\"./standards/HONEYCOMBS721.sol\\\";\\n\\n/**\\n@title  Honeycombs\\n@author Gaurang Patel (adapted from checks.vv contracts)\\n@notice The only way you can conquer me is through love and there I am gladly conquered.\\n*/\\ncontract Honeycombs is IHoneycombs, HONEYCOMBS721, Ownable {\\n    /// @dev We use this database for persistent storage.\\n    Honeycombs honeycombs;\\n\\n    uint256 public constant MAX_SUPPLY = 10000; // Maximum supply of Honeycombs\\n    uint256 public constant MINT_PRICE = 0.1 ether; // Price to mint one Honeycomb\\n    uint256 public constant MAX_MINT_PER_ADDRESS = 5; // Maximum NFTs per wallet address\\n    uint256 public constant AUTO_RESERVE_FREQUENCY = 100; // Frequency of auto-reserve\\n    address public reserveAddress1; // First address to auto reserve Honeycombs for\\n    address public reserveAddress2; // Second address to auto reserve Honeycombs for\\n\\n    // Number of mints per address\\n    mapping(address => uint256) private _mintedCounts;\\n\\n    /// @dev Initializes the Honeycombs contract.\\n    constructor() {\\n        honeycombs.day0 = uint32(block.timestamp);\\n        honeycombs.epoch = 1;\\n        reserveAddress1 = 0x895e58968819E821465857CDbE33B82027527747; // artist\\n        reserveAddress2 = 0x1E29711abbc2E350e47D5963C5AC5470b59a1aa4; // fellowship\\n    }\\n\\n    /// @notice Mint honeycombs.\\n    /// @param numberOfTokens The number of tokens to mint.\\n    /// @param recipient The address to receive the tokens.\\n    function mint(uint256 numberOfTokens, address recipient) public payable {\\n        // Check whether mint is allowed.\\n        if (numberOfTokens < 1 || numberOfTokens > MAX_MINT_PER_ADDRESS) revert NotAllowed();\\n        if (honeycombs.minted + numberOfTokens > MAX_SUPPLY) revert MaxSupplyReached();\\n        if (msg.value != MINT_PRICE * numberOfTokens) revert NotExactEth();\\n        if (_mintedCounts[msg.sender] + numberOfTokens > MAX_MINT_PER_ADDRESS) revert MaxMintPerAddressReached();\\n\\n        // Calculate the total value to allocate to reserve address 2 (20%).\\n        uint256 reserve2Value = (msg.value * 20) / 100;\\n\\n        // Initialize new epoch / resolve previous epoch.\\n        resolveEpochIfNecessary();\\n\\n        // Loop through and mint each Honeycomb.\\n        for (uint256 i = 0; i < numberOfTokens; ) {\\n            // Check for auto reserving honeycombs (first and second out of every 100).\\n            if (honeycombs.minted % AUTO_RESERVE_FREQUENCY == 0 && honeycombs.minted != MAX_SUPPLY) {\\n                uint32 reserve1TokenId = ++honeycombs.minted;\\n                uint32 reserve2TokenId = ++honeycombs.minted;\\n\\n                // Initialize Honeycombs.\\n                StoredHoneycomb storage honeycomb1 = honeycombs.all[reserve1TokenId];\\n                honeycomb1.day = Utilities.day(honeycombs.day0, block.timestamp);\\n                honeycomb1.epoch = uint32(honeycombs.epoch);\\n                honeycomb1.seed = uint16(reserve1TokenId);\\n\\n                StoredHoneycomb storage honeycomb2 = honeycombs.all[reserve2TokenId];\\n                honeycomb2.day = Utilities.day(honeycombs.day0, block.timestamp);\\n                honeycomb2.epoch = uint32(honeycombs.epoch);\\n                honeycomb2.seed = uint16(reserve2TokenId);\\n\\n                // Mint to reserve addresses.\\n                _safeMint(reserveAddress1, reserve1TokenId);\\n                _safeMint(reserveAddress2, reserve2TokenId);\\n            }\\n\\n            // Increment minted counters.\\n            ++honeycombs.minted;\\n            ++_mintedCounts[msg.sender];\\n\\n            // Initialize our Honeycomb.\\n            StoredHoneycomb storage honeycomb = honeycombs.all[honeycombs.minted];\\n            honeycomb.day = Utilities.day(honeycombs.day0, block.timestamp);\\n            honeycomb.epoch = uint32(honeycombs.epoch);\\n            honeycomb.seed = uint16(honeycombs.minted);\\n\\n            // Mint the original.\\n            // If we're minting to a vault, transfer it there.\\n            if (msg.sender != recipient) {\\n                _safeMintVia(recipient, msg.sender, honeycombs.minted);\\n            } else {\\n                _safeMint(msg.sender, honeycombs.minted);\\n            }\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        // Transfer the reserve value to reserve address 2.\\n        payable(reserveAddress2).transfer(reserve2Value);\\n    }\\n\\n    /// @notice Burn a honeycomb.\\n    /// @param tokenId The token ID to burn.\\n    /// @dev A common purpose burn method.\\n    function burn(uint256 tokenId) public {\\n        if (!_isApprovedOrOwner(msg.sender, tokenId)) {\\n            revert NotAllowed();\\n        }\\n\\n        // Keep track of supply.\\n        unchecked {\\n            ++honeycombs.burned;\\n        }\\n\\n        // Perform the burn.\\n        _burn(tokenId);\\n    }\\n\\n    /// @notice Initializes and closes epochs.\\n    /// @dev Based on the commit-reveal scheme proposed by MouseDev.\\n    function resolveEpochIfNecessary() public {\\n        Epoch storage currentEpoch = honeycombs.epochs[honeycombs.epoch];\\n\\n        if (\\n            // If epoch has not been committed,\\n            currentEpoch.committed == false ||\\n            // Or the reveal commitment timed out.\\n            (currentEpoch.revealed == false && currentEpoch.revealBlock < block.number - 256)\\n        ) {\\n            // This means the epoch has not been committed, OR the epoch was committed but has expired.\\n            // Set committed to true, and record the reveal block:\\n            currentEpoch.revealBlock = uint64(block.number + 50);\\n            currentEpoch.committed = true;\\n        } else if (block.number > currentEpoch.revealBlock) {\\n            // Epoch has been committed and is within range to be revealed.\\n            // Set its randomness to the target block hash.\\n            currentEpoch.randomness = uint128(\\n                uint256(keccak256(abi.encodePacked(blockhash(currentEpoch.revealBlock), block.difficulty))) %\\n                    (2 ** 128 - 1)\\n            );\\n            currentEpoch.revealed = true;\\n\\n            // Notify DApps about the new epoch.\\n            emit NewEpoch(honeycombs.epoch, currentEpoch.revealBlock);\\n\\n            // Initialize the next epoch\\n            honeycombs.epoch++;\\n            resolveEpochIfNecessary();\\n        }\\n    }\\n\\n    /// @notice Withdraw funds (only callable by the owner).\\n    /// @param amount The amount to withdraw.\\n    function withdraw(uint256 amount) public onlyOwner {\\n        if (address(this).balance < amount) {\\n            revert NotAllowed();\\n        }\\n        payable(owner()).transfer(amount);\\n    }\\n\\n\\n    /// @notice The identifier of the current epoch\\n    function getEpoch() public view returns (uint256) {\\n        return honeycombs.epoch;\\n    }\\n\\n    /// @notice Get the data for a given epoch\\n    /// @param index The identifier of the epoch to fetch\\n    function getEpochData(uint256 index) public view returns (Epoch memory) {\\n        return honeycombs.epochs[index];\\n    }\\n\\n    /// @notice Get a specific honeycomb.\\n    /// @param tokenId The token ID to fetch.\\n    /// @dev Consider using the HoneycombsArt Library directly.\\n    function getHoneycomb(uint256 tokenId) external view returns (Honeycomb memory honeycomb) {\\n        return HoneycombsArt.generateHoneycomb(honeycombs, tokenId);\\n    }\\n\\n    /// @notice Render the SVG for a given token.\\n    /// @param tokenId The token to render.\\n    /// @dev Consider using the HoneycombsArt Library directly.\\n    function svg(uint256 tokenId) external view returns (string memory) {\\n        return string(HoneycombsArt.generateHoneycomb(honeycombs, tokenId).svg);\\n    }\\n\\n    /// @notice Get the metadata for a given token.\\n    /// @param tokenId The token to render.\\n    /// @dev Consider using the HoneycombsMetadata Library directly.\\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\\n        _requireMinted(tokenId);\\n\\n        return HoneycombsMetadata.tokenURI(honeycombs, tokenId);\\n    }\\n\\n    /// @notice Returns how many tokens this contract manages.\\n    function totalSupply() public view returns (uint256) {\\n        return honeycombs.minted - honeycombs.burned;\\n    }\\n\\n    /// @notice Returns how many tokens have been minted.\\n    function minted() public view returns (uint256) {\\n        return honeycombs.minted;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC4906.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/CHECKS721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\n\\n/// @title EIP-721 Metadata Update Extension\\ninterface IERC4906 is IERC165, IERC721 {\\n    /// @dev This event emits when the metadata of a token is changed.\\n    /// Third-party platforms such as NFT marketplaces can listen to\\n    /// the event and auto-update the tokens in their apps.\\n    event MetadataUpdate(uint256 _tokenId);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IHoneycombs.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\ninterface IHoneycombs {\\n    /// @dev The minimal honeycomb data stored on-chain, the rest is generated.\\n    struct StoredHoneycomb {\\n        uint32 epoch; // Each honeycomb is revealed in an epoch\\n        uint24 day; // The days since token was created\\n        uint16 seed; // A unique identifier (this is the token ID since it is pre-reveal)\\n    }\\n\\n    struct Honeycomb {\\n        StoredHoneycomb stored; // We carry over the honeycomb from storage\\n        bool isRevealed; // Whether the honeycomb is revealed\\n        uint256 seed; // The instantiated seed for pseudo-randomisation (post-reveal)\\n        bytes svg; // final svg for the honeycomb\\n        Canvas canvas; // all data relevant to the canvas\\n        BaseHexagon baseHexagon; // all data relevant to the base hexagon\\n        Grid grid; // all data relevant to the grid\\n        Gradients gradients; // all data relevant to the gradients\\n    }\\n\\n    struct Honeycombs {\\n        mapping(uint256 => StoredHoneycomb) all; // All honeycombs\\n        uint32 maxSupply; // The maximum number of honeycombs that can be minted\\n        uint32 minted; // The number of honeycombs that have been minted\\n        uint32 burned; // The number of honeycombs that have been burned\\n        uint32 day0; // Marks the start of this journey\\n        mapping(uint256 => Epoch) epochs; // All epochs\\n        uint256 epoch; // The current epoch index\\n    }\\n\\n    struct Canvas {\\n        string color; // background color of canvas\\n        uint16 size; // size or length of canvas in user units (pixels)\\n        uint16 hexagonSize; // size or length of hexagon in user units (pixels)\\n        uint16 maxHexagonsPerLine; // max number of hexagons per line\\n    }\\n\\n    struct BaseHexagon {\\n        string path; // path of base hexagon\\n        string fillColor; // fill color of base hexagon\\n        uint8 strokeWidth; // stroke width size in user units (pixels)\\n        uint8 hexagonType; // type of base hexagon, i.e. flat or pointy\\n    }\\n\\n    struct Grid {\\n        bytes hexagonsSvg; // final svg for all hexagons\\n        bytes svg; // final svg for the grid\\n        uint16 gridX; // x coordinate of the grid\\n        uint16 gridY; // y coordinate of the grid\\n        uint16 rowDistance; // distance between rows in user units (pixels)\\n        uint16 columnDistance; // distance between columns in user units (pixels)\\n        uint16 rotation; // rotation of entire shape in degrees\\n        uint8 shape; // shape of the grid, i.e. triangle, diamond, hexagon, random\\n        uint8 totalGradients; // number of gradients required based on the grid size and shape\\n        uint8 rows; // number of rows in the grid\\n        uint8 longestRowCount; // largest row size in the grid for centering purposes\\n    }\\n\\n    struct Gradients {\\n        bytes svg; // final svg for the gradients\\n        uint16 duration; // duration of animation in seconds\\n        uint8 direction; // direction of animation, i.e. forward or backward\\n        uint8 chrome; // max number of colors in all the gradients, aka chrome\\n    }\\n\\n    struct Epoch {\\n        uint128 randomness; // The source of randomness for tokens from this epoch\\n        uint64 revealBlock; // The block at which this epoch was / is revealed\\n        bool committed; // Whether the epoch has been instantiated\\n        bool revealed; // Whether the epoch has been revealed\\n    }\\n\\n    event NewEpoch(uint256 indexed epoch, uint64 indexed revealBlock);\\n\\n    error NotAllowed();\\n    error MaxSupplyReached();\\n    error NotExactEth();\\n    error MaxMintPerAddressReached();\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/Colors.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\n/**\\n@title  Colors\\n@notice The colors of honeycombs.\\n*/\\nlibrary Colors {\\n    /// @dev These are sorted in a gradient.\\n    function COLORS() public pure returns (string[46] memory) {\\n        return [\\n            \\\"FF005D\\\",\\n            \\\"FF0040\\\",\\n            \\\"FF0011\\\",\\n            \\\"FF0D00\\\",\\n            \\\"FF3300\\\",\\n            \\\"FF4C00\\\",\\n            \\\"FF6600\\\",\\n            \\\"FF7700\\\",\\n            \\\"FF8800\\\",\\n            \\\"FF9900\\\",\\n            \\\"FFB300\\\",\\n            \\\"FFCC00\\\",\\n            \\\"FFE600\\\",\\n            \\\"FFF700\\\",\\n            \\\"FFFF00\\\",\\n            \\\"F6FF00\\\",\\n            \\\"EEFF00\\\",\\n            \\\"D4FF00\\\",\\n            \\\"B3FF00\\\",\\n            \\\"99FF00\\\",\\n            \\\"80FF00\\\",\\n            \\\"62FF00\\\",\\n            \\\"00FF11\\\",\\n            \\\"00FF80\\\",\\n            \\\"00FFBF\\\",\\n            \\\"00FFEE\\\",\\n            \\\"00F7FF\\\",\\n            \\\"00E6FF\\\",\\n            \\\"00C3FF\\\",\\n            \\\"0099FF\\\",\\n            \\\"0077FF\\\",\\n            \\\"0055FF\\\",\\n            \\\"0033FF\\\",\\n            \\\"3300FF\\\",\\n            \\\"5500FF\\\",\\n            \\\"6600FF\\\",\\n            \\\"7B00FF\\\",\\n            \\\"9000FF\\\",\\n            \\\"AA00FF\\\",\\n            \\\"BB00FF\\\",\\n            \\\"D400FF\\\",\\n            \\\"EE00FF\\\",\\n            \\\"FB00FF\\\",\\n            \\\"FF00EA\\\",\\n            \\\"FF00CC\\\",\\n            \\\"FF00A2\\\"\\n        ];\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/GradientsArt.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport \\\"../interfaces/IHoneycombs.sol\\\";\\nimport \\\"./Utilities.sol\\\";\\nimport \\\"./Colors.sol\\\";\\n\\n/**\\n@title  GradientsArt\\n@notice Generates the gradients for a given Honeycomb.\\n*/\\nlibrary GradientsArt {\\n    enum HEXAGON_TYPE { FLAT, POINTY } // prettier-ignore\\n    enum SHAPE { TRIANGLE, DIAMOND, HEXAGON, RANDOM } // prettier-ignore\\n\\n        /// @dev Get from different chromes or max primary colors. Corresponds to chrome trait in HoneycombsMetadata.sol.\\n    function getChrome(uint8 index) public pure returns (uint8) {\\n        return uint8([1, 2, 3, 4, 5, 6, Colors.COLORS().length][index]);\\n    }\\n\\n    /// @dev Get from different animation durations in seconds. Corresponds to duration trait in HoneycombsMetadata.sol.\\n    function getDuration(uint16 index) public pure returns (uint16) {\\n        return uint16([10, 40, 80, 240][index]);\\n    }\\n\\n    /// @dev Get the linear gradient's svg.\\n    /// @param data The gradient data.\\n    function getLinearGradientSvg(GradientData memory data) public pure returns (bytes memory) {\\n        // prettier-ignore\\n        bytes memory svg = abi.encodePacked(\\n            '<linearGradient id=\\\"gradient', Utilities.uint2str(data.gradientId), '\\\" x1=\\\"0%\\\" x2=\\\"0%\\\" y1=\\\"', \\n                    Utilities.uint2str(data.y1), '%\\\" y2=\\\"', Utilities.uint2str(data.y2), '%\\\">',\\n                '<stop stop-color=\\\"', data.stop1.color, '\\\">',\\n                    '<animate attributeName=\\\"stop-color\\\" values=\\\"', data.stop1.animationColorValues, '\\\" dur=\\\"', \\n                        Utilities.uint2str(data.duration), 's\\\" begin=\\\"animation.begin\\\" repeatCount=\\\"indefinite\\\" />',\\n                '</stop>',\\n                '<stop offset=\\\"0.', Utilities.uint2str(data.offset), '\\\" stop-color=\\\"', data.stop2.color, '\\\">',\\n                    '<animate attributeName=\\\"stop-color\\\" values=\\\"', data.stop2.animationColorValues, '\\\" dur=\\\"', \\n                        Utilities.uint2str(data.duration), 's\\\" begin=\\\"animation.begin\\\" repeatCount=\\\"indefinite\\\" />',\\n                '</stop>',\\n            '</linearGradient>'\\n        );\\n\\n        return svg;\\n    }\\n\\n    /// @dev Get the stop for a linear gradient.\\n    /// @param honeycomb The honeycomb data used for rendering.\\n    /// @param stopCount The current stop count - used for seeding the random number generator.\\n    function getLinearGradientStopSvg(\\n        IHoneycombs.Honeycomb memory honeycomb,\\n        uint8 stopCount\\n    ) public pure returns (GradientStop memory) {\\n        GradientStop memory stop;\\n        string[46] memory allColors = Colors.COLORS();\\n\\n        // Get random stop color.\\n        uint256 currentIndex = Utilities.random(\\n            honeycomb.seed,\\n            abi.encodePacked(\\\"linearGradientStop\\\", Utilities.uint2str(stopCount)),\\n            allColors.length\\n        );\\n        stop.color = abi.encodePacked(\\\"#\\\", allColors[currentIndex]);\\n\\n        bytes memory values;\\n        // Add the initial color.\\n        values = abi.encodePacked(values, stop.color, \\\";\\\");\\n\\n        // Get all animation values based on the direction.\\n        bool forwardDirection = honeycomb.gradients.direction == 0;\\n\\n        // We pick 14 more different colors for the gradient.\\n        uint8 count = 14;\\n        for (uint256 i = 0; i <= (count * 2) - 2; ) {\\n            bool isFirstHalf = i < count;\\n\\n            // For the first half, follow the direction. For the second half, reverse the direction.\\n            if (isFirstHalf == forwardDirection) {\\n                currentIndex = (currentIndex + 2) % allColors.length;\\n            } else {\\n                currentIndex = (currentIndex + allColors.length - 2) % allColors.length;\\n            }\\n\\n            values = abi.encodePacked(values, \\\"#\\\", allColors[currentIndex], \\\";\\\");\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        // Add the last color.\\n        stop.animationColorValues = abi.encodePacked(values, stop.color);\\n        return stop;\\n    }\\n\\n    /// @dev Get all gradients data, particularly the svg.\\n    /// @param honeycomb The honeycomb data used for rendering.\\n    function generateGradientsSvg(IHoneycombs.Honeycomb memory honeycomb) public pure returns (bytes memory) {\\n        bytes memory svg;\\n\\n        // Initialize array of stops (id => svgString) for reuse once we reach the max color count.\\n        GradientStop[] memory stops = new GradientStop[](honeycomb.grid.totalGradients + 1);\\n\\n        uint8 stopCount;\\n        GradientStop memory prevStop = getLinearGradientStopSvg(honeycomb, stopCount);\\n        stops[stopCount] = prevStop;\\n        ++stopCount;\\n\\n        // Loop through all gradients and generate the svg.\\n        for (uint256 i; i < honeycomb.grid.totalGradients; ) {\\n            GradientStop memory stop;\\n\\n            // Get next stop.\\n            if (stopCount < honeycomb.gradients.chrome) {\\n                stop = getLinearGradientStopSvg(honeycomb, stopCount);\\n                stops[stopCount] = stop;\\n                unchecked {\\n                    ++stopCount;\\n                }\\n            } else {\\n                // Randomly select a stop from existing ones.\\n                stop = stops[\\n                    Utilities.random(honeycomb.seed, abi.encodePacked(\\\"stop\\\", Utilities.uint2str(i)), stopCount)\\n                ];\\n            }\\n\\n            // Get gradients svg based on the base hexagon type.\\n            if (honeycomb.baseHexagon.hexagonType == uint8(HEXAGON_TYPE.POINTY)) {\\n                GradientData memory gradientData;\\n                gradientData.stop1 = prevStop;\\n                gradientData.stop2 = stop;\\n                gradientData.duration = honeycomb.gradients.duration;\\n                gradientData.gradientId = uint8(i + 1);\\n                gradientData.y1 = 25;\\n                gradientData.y2 = 81;\\n                gradientData.offset = 72;\\n                bytes memory gradientSvg = getLinearGradientSvg(gradientData);\\n\\n                // Append gradient to svg, update previous stop, and increment index.\\n                svg = abi.encodePacked(svg, gradientSvg);\\n                prevStop = stop;\\n                unchecked {\\n                    ++i;\\n                }\\n            } else if (honeycomb.baseHexagon.hexagonType == uint8(HEXAGON_TYPE.FLAT)) {\\n                // Flat tops require two gradients.\\n                GradientData memory gradientData1;\\n                gradientData1.stop1 = prevStop;\\n                gradientData1.stop2 = stop;\\n                gradientData1.duration = honeycomb.gradients.duration;\\n                gradientData1.gradientId = uint8(i + 1);\\n                gradientData1.y1 = 50;\\n                gradientData1.y2 = 100;\\n                gradientData1.offset = 72;\\n                bytes memory gradient1Svg = getLinearGradientSvg(gradientData1);\\n\\n                if (i == honeycomb.grid.totalGradients - 1) {\\n                    // If this is the last gradient, we don't need to generate the second gradient.\\n                    svg = abi.encodePacked(svg, gradient1Svg);\\n                    break;\\n                }\\n\\n                GradientData memory gradientData2;\\n                gradientData2.stop1 = prevStop;\\n                gradientData2.stop2 = stop;\\n                gradientData2.duration = honeycomb.gradients.duration;\\n                gradientData2.gradientId = uint8(i + 2);\\n                gradientData2.y1 = 4;\\n                gradientData2.y2 = 100;\\n                gradientData2.offset = 30;\\n                bytes memory gradient2Svg = getLinearGradientSvg(gradientData2);\\n\\n                // Append both gradients to svg, update previous stop, and increment index.\\n                svg = abi.encodePacked(svg, gradient1Svg, gradient2Svg);\\n                prevStop = stop;\\n                unchecked {\\n                    i += 2;\\n                }\\n            }\\n        }\\n\\n        return svg;\\n    }\\n}\\n\\n/// @dev All internal data relevant to a gradient stop.\\nstruct GradientStop {\\n    bytes color; // color of the gradient stop\\n    bytes animationColorValues; // color values for the animation\\n}\\n\\n/// @dev All additional internal data for rendering a gradient svg string.\\nstruct GradientData {\\n    GradientStop stop1; // first gradient stop\\n    GradientStop stop2; // second gradient stop\\n    uint16 duration; // duration of the animation\\n    uint8 gradientId; // id of the gradient\\n    uint8 y1; // y1 of the gradient\\n    uint8 y2; // y2 of the gradient\\n    uint8 offset; // offset of the gradient\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/GridArt.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport \\\"../interfaces/IHoneycombs.sol\\\";\\nimport \\\"./Utilities.sol\\\";\\n\\n/**\\n@title  GridArt\\n@notice Generates the grid for a given Honeycomb.\\n*/\\nlibrary GridArt {\\n    enum HEXAGON_TYPE { FLAT, POINTY } // prettier-ignore\\n    enum SHAPE { TRIANGLE, DIAMOND, HEXAGON, RANDOM } // prettier-ignore\\n\\n    /// @dev The paths for a 72x72 px hexagon.\\n    function getHexagonPath(uint8 pathType) public pure returns (string memory path) {\\n        if (pathType == uint8(HEXAGON_TYPE.FLAT)) {\\n            return \\\"M22.2472 7.32309L4.82457 37.5C3.93141 39.047 3.93141 40.953 4.82457 42.5L22.2472 72.6769C23.1404 74.2239 24.791 75.1769 26.5774 75.1769H61.4226C63.209 75.1769 64.8596 74.2239 65.7528 72.6769L83.1754 42.5C84.0686 40.953 84.0686 39.047 83.1754 37.5L65.7528 7.32309C64.8596 5.77608 63.209 4.82309 61.4226 4.82309H26.5774C24.791 4.82309 23.1404 5.77608 22.2472 7.32309Z\\\"; // prettier-ignore\\n        } else if (pathType == uint8(HEXAGON_TYPE.POINTY)) {\\n            return \\\"M72.6769 22.2472L42.5 4.82457C40.953 3.93141 39.047 3.93141 37.5 4.82457L7.32309 22.2472C5.77608 23.1404 4.82309 24.791 4.82309 26.5774V61.4226C4.82309 63.209 5.77608 64.8596 7.32309 65.7528L37.5 83.1754C39.047 84.0686 40.953 84.0686 42.5 83.1754L72.6769 65.7528C74.2239 64.8596 75.1769 63.209 75.1769 61.4226V26.5774C75.1769 24.791 74.2239 23.1404 72.6769 22.2472Z\\\"; // prettier-ignore\\n        }\\n    }\\n\\n        /// @dev Get hexagon from given grid and hexagon properties.\\n    /// @param grid The grid metadata.\\n    /// @param xIndex The x index in the grid.\\n    /// @param yIndex The y index in the grid.\\n    /// @param gradientId The gradient id for the hexagon.\\n    function getUpdatedHexagonsSvg(\\n        IHoneycombs.Grid memory grid,\\n        uint16 xIndex,\\n        uint16 yIndex,\\n        uint16 gradientId\\n    ) public pure returns (bytes memory) {\\n        uint16 x = grid.gridX + xIndex * grid.columnDistance;\\n        uint16 y = grid.gridY + yIndex * grid.rowDistance;\\n\\n        // prettier-ignore\\n        return abi.encodePacked(grid.hexagonsSvg, abi.encodePacked(\\n            '<use href=\\\"#hexagon\\\" stroke=\\\"url(#gradient', Utilities.uint2str(gradientId), ')\\\" ',\\n                'x=\\\"', Utilities.uint2str(x), '\\\" y=\\\"', Utilities.uint2str(y), '\\\"',\\n            '/>'\\n        ));\\n    }\\n\\n    /// @dev Add positioning to the grid (for centering on canvas).\\n    /// @dev Note this function appends attributes to grid object, so returned object has original grid + positioning.\\n    /// @param honeycomb The honeycomb data used for rendering.\\n    /// @param grid The grid metadata.\\n    function addGridPositioning(\\n        IHoneycombs.Honeycomb memory honeycomb,\\n        IHoneycombs.Grid memory grid\\n    ) public pure returns (IHoneycombs.Grid memory) {\\n        // Compute grid properties.\\n        grid.rowDistance = ((3 * honeycomb.canvas.hexagonSize) / 4) + 7; // 7 is a relatively arbitrary buffer\\n        grid.columnDistance = honeycomb.canvas.hexagonSize / 2 - 1;\\n        uint16 gridHeight = honeycomb.canvas.hexagonSize + 7 + ((grid.rows - 1) * grid.rowDistance);\\n        uint16 gridWidth = grid.longestRowCount * (honeycomb.canvas.hexagonSize - 2);\\n\\n        /**\\n         * Swap variables if it is a flat top hexagon (this math assumes pointy top as default). Rotating a flat top\\n         * hexagon 90 degrees clockwise results in a pointy top hexagon. This effectively swaps the x and y axis.\\n         */\\n        if (honeycomb.baseHexagon.hexagonType == uint8(HEXAGON_TYPE.FLAT)) {\\n            (grid.rowDistance, grid.columnDistance) = Utilities.swap(grid.rowDistance, grid.columnDistance);\\n            (gridWidth, gridHeight) = Utilities.swap(gridWidth, gridHeight);\\n        }\\n\\n        // Compute grid positioning.\\n        grid.gridX = (honeycomb.canvas.size - gridWidth) / 2;\\n        grid.gridY = (honeycomb.canvas.size - gridHeight) / 2;\\n\\n        return grid;\\n    }\\n\\n    /// @dev Get the honeycomb grid for a random shape.\\n    /// @dev Note: can only be called for pointy tops (flat tops are not supported as they would be redundant).\\n    /// @param honeycomb The honeycomb data used for rendering.\\n    function getRandomGrid(IHoneycombs.Honeycomb memory honeycomb) public pure returns (IHoneycombs.Grid memory) {\\n        IHoneycombs.Grid memory grid;\\n\\n        // Get random rows from 1 to honeycomb.canvas.maxHexagonsPerline.\\n        grid.rows = uint8(Utilities.random(honeycomb.seed, \\\"rows\\\", honeycomb.canvas.maxHexagonsPerLine) + 1);\\n\\n        // Get random hexagons in each row from 1 to honeycomb.canvas.maxHexagonsPerLine - 1.\\n        uint8[] memory hexagonsInRow = new uint8[](grid.rows);\\n        for (uint8 i; i < grid.rows; ) {\\n            hexagonsInRow[i] =\\n                uint8(Utilities.random(\\n                    honeycomb.seed,\\n                    abi.encodePacked(\\\"hexagonsInRow\\\", Utilities.uint2str(i)),\\n                    honeycomb.canvas.maxHexagonsPerLine - 1\\n                ) + 1); // prettier-ignore\\n            grid.longestRowCount = Utilities.max(hexagonsInRow[i], grid.longestRowCount);\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        // Determine positioning of entire grid, which is based on the longest row.\\n        grid = addGridPositioning(honeycomb, grid); // appends to grid object\\n\\n        int8 lastRowEvenOdd = -1; // Helps avoid overlapping hexagons: -1 = unset, 0 = even, 1 = odd\\n        // Create random grid. Only working with pointy tops for simplicity.\\n        for (uint8 i; i < grid.rows; ) {\\n            uint8 firstX = grid.longestRowCount - hexagonsInRow[i];\\n\\n            // Increment firstX if last row's evenness/oddness is same as this rows and update with current.\\n            if (lastRowEvenOdd == int8(firstX % 2)) ++firstX;\\n            lastRowEvenOdd = int8(firstX % 2);\\n\\n            // Assign indexes for each hexagon.\\n            for (uint8 j; j < hexagonsInRow[i]; ) {\\n                uint8 xIndex = firstX + (j * 2);\\n                grid.hexagonsSvg = getUpdatedHexagonsSvg(grid, xIndex, i, i + 1);\\n                unchecked {\\n                    ++j;\\n                }\\n            }\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        grid.totalGradients = grid.rows;\\n        return grid;\\n    }\\n\\n    /// @dev Get the honeycomb grid for a hexagon shape.\\n    /// @param honeycomb The honeycomb data used for rendering.\\n    function getHexagonGrid(IHoneycombs.Honeycomb memory honeycomb) public pure returns (IHoneycombs.Grid memory) {\\n        IHoneycombs.Grid memory grid;\\n\\n        // Get random rows from 3 to honeycomb.canvas.maxHexagonsPerLine, only odd.\\n        grid.rows = uint8(\\n            Utilities.random(honeycomb.seed, \\\"rows\\\", (honeycomb.canvas.maxHexagonsPerLine / 2) - 1) * 2 + 3\\n        );\\n\\n        // Determine positioning of entire grid, which is based on the longest row.\\n        grid.longestRowCount = grid.rows;\\n        grid = addGridPositioning(honeycomb, grid); // appends to grid object\\n\\n        // Create grid based on hexagon base type.\\n        if (honeycomb.baseHexagon.hexagonType == uint8(HEXAGON_TYPE.POINTY)) {\\n            grid.totalGradients = grid.rows;\\n\\n            for (uint8 i; i < grid.rows; ) {\\n                // Compute hexagons in row.\\n                uint8 hexagonsInRow = grid.rows - Utilities.absDiff(grid.rows / 2, i);\\n\\n                // Assign indexes for each hexagon.\\n                for (uint8 j; j < hexagonsInRow; ) {\\n                    uint8 xIndex = (grid.rows - hexagonsInRow) + (j * 2);\\n                    grid.hexagonsSvg = getUpdatedHexagonsSvg(grid, xIndex, i, i + 1);\\n                    unchecked {\\n                        ++j;\\n                    }\\n                }\\n\\n                unchecked {\\n                    ++i;\\n                }\\n            }\\n        } else if (honeycomb.baseHexagon.hexagonType == uint8(HEXAGON_TYPE.FLAT)) {\\n            uint8 flatTopRows = grid.rows * 2 - 1;\\n            grid.totalGradients = flatTopRows;\\n            uint8 halfRows = grid.rows / 2;\\n\\n            for (uint8 i; i < flatTopRows; ) {\\n                // Determine hexagons in row.\\n                uint8 hexagonsInRow;\\n                if (i <= grid.rows / 2) {\\n                    // ascending, i.e. rows = 1 2 3 4 5 when rows = 5\\n                    hexagonsInRow = i + 1;\\n                } else if (i < flatTopRows - halfRows - 1) {\\n                    // alternate between rows / 2 + 1 and rows / 2 every other row\\n                    hexagonsInRow = (halfRows + i) % 2 == 0 ? halfRows + 1 : halfRows;\\n                } else {\\n                    // descending, i.e. rows = 5, 4, 3, 2, 1 when rows = 5\\n                    hexagonsInRow = flatTopRows - i;\\n                }\\n\\n                // Assign indexes for each hexagon.\\n                for (uint8 j; j < hexagonsInRow; ) {\\n                    uint8 xIndex = (grid.rows - hexagonsInRow) - halfRows + (j * 2);\\n                    grid.hexagonsSvg = getUpdatedHexagonsSvg(grid, xIndex, i, i + 1);\\n                    unchecked {\\n                        ++j;\\n                    }\\n                }\\n\\n                unchecked {\\n                    ++i;\\n                }\\n            }\\n        }\\n\\n        return grid;\\n    }\\n\\n    /// @dev Get the honeycomb grid for a diamond shape.\\n    /// @param honeycomb The honeycomb data used for rendering.\\n    function getDiamondGrid(IHoneycombs.Honeycomb memory honeycomb) public pure returns (IHoneycombs.Grid memory) {\\n        IHoneycombs.Grid memory grid;\\n\\n        // Get random rows from 3 to honeycomb.canvas.maxHexagonsPerLine, only odd.\\n        grid.rows = uint8(\\n            Utilities.random(honeycomb.seed, \\\"rows\\\", (honeycomb.canvas.maxHexagonsPerLine / 2) - 1) * 2 + 3\\n        );\\n\\n        // Determine positioning of entire grid, which is based on the longest row.\\n        grid.longestRowCount = grid.rows / 2 + 1;\\n        grid = addGridPositioning(honeycomb, grid); // appends to grid object\\n\\n        // Create diamond grid. Both flat top and pointy top result in the same grid, so no need to check hexagon type.\\n        for (uint8 i; i < grid.rows; ) {\\n            // Determine hexagons in row. Pattern is ascending/descending sequence, i.e 1 2 3 2 1 when rows = 5.\\n            uint8 hexagonsInRow = i < grid.rows / 2 ? i + 1 : grid.rows - i;\\n            uint8 firstXInRow = i < grid.rows / 2 ? grid.rows / 2 - i : i - grid.rows / 2;\\n\\n            // Assign indexes for each hexagon.\\n            for (uint8 j; j < hexagonsInRow; ) {\\n                uint8 xIndex = firstXInRow + (j * 2);\\n                grid.hexagonsSvg = getUpdatedHexagonsSvg(grid, xIndex, i, i + 1);\\n                unchecked {\\n                    ++j;\\n                }\\n            }\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        grid.totalGradients = grid.rows;\\n        return grid;\\n    }\\n\\n    /// @dev Get the honeycomb grid for a triangle shape.\\n    /// @param honeycomb The honeycomb data used for rendering.\\n    function getTriangleGrid(IHoneycombs.Honeycomb memory honeycomb) public pure returns (IHoneycombs.Grid memory) {\\n        IHoneycombs.Grid memory grid;\\n\\n        // Get random rows from 2 to honeycomb.canvas.maxHexagonsPerLine.\\n        grid.rows = uint8(Utilities.random(honeycomb.seed, \\\"rows\\\", honeycomb.canvas.maxHexagonsPerLine - 1) + 2);\\n\\n        // Determine positioning of entire grid, which is based on the longest row.\\n        grid.longestRowCount = grid.rows;\\n        grid = addGridPositioning(honeycomb, grid); // appends to grid object\\n\\n        // Create grid based on hexagon base type.\\n        if (honeycomb.baseHexagon.hexagonType == uint8(HEXAGON_TYPE.POINTY)) {\\n            grid.totalGradients = grid.rows;\\n\\n            // Iterate through rows - will only be north/south facing (design).\\n            for (uint8 i; i < grid.rows; ) {\\n                // Assign indexes for each hexagon. Each row has i + 1 hexagons.\\n                for (uint8 j; j < i + 1; ) {\\n                    uint8 xIndex = grid.rows - 1 - i + (j * 2);\\n                    grid.hexagonsSvg = getUpdatedHexagonsSvg(grid, xIndex, i, i + 1);\\n                    unchecked {\\n                        ++j;\\n                    }\\n                }\\n\\n                unchecked {\\n                    ++i;\\n                }\\n            }\\n        } else if (honeycomb.baseHexagon.hexagonType == uint8(HEXAGON_TYPE.FLAT)) {\\n            uint8 flatTopRows = grid.rows * 2 - 1;\\n            grid.totalGradients = flatTopRows;\\n\\n            // Iterate through rows - will only be west/east facing (design).\\n            for (uint8 i; i < flatTopRows; ) {\\n                // Determine hexagons in row. First half is ascending. Second half is descending.\\n                uint8 hexagonsInRow;\\n                if (i <= flatTopRows / 2) {\\n                    // ascending with peak, i.e. rows = 1 1 2 2 3 when rows = 5\\n                    hexagonsInRow = i / 2 + 1;\\n                } else {\\n                    // descending with peak, i.e. rows = 2 2 1 1 when rows = 5\\n                    hexagonsInRow = ((flatTopRows - i - 1) / 2) + 1;\\n                }\\n\\n                // Assign indexes for each hexagon. Each row has i + 1 hexagons.\\n                for (uint8 j; j < hexagonsInRow; ) {\\n                    uint8 xIndex = (i % 2) + (j * 2);\\n                    grid.hexagonsSvg = getUpdatedHexagonsSvg(grid, xIndex, i, i + 1);\\n                    unchecked {\\n                        ++j;\\n                    }\\n                }\\n\\n                unchecked {\\n                    ++i;\\n                }\\n            }\\n        }\\n\\n        return grid;\\n    }\\n\\n    /// @dev Generate the overall honeycomb grid, including the final svg.\\n    /// @dev Using double coordinates: https://www.redblobgames.com/grids/hexagons/#coordinates-doubled\\n    /// @param honeycomb The honeycomb data used for rendering.\\n    /// @return (bytes, uint8, uint8) The svg, totalGradients, and rows.\\n    function generateGrid(IHoneycombs.Honeycomb memory honeycomb) public pure returns (bytes memory, uint8, uint8) {\\n        // Partial grid object used to store supportive variables\\n        IHoneycombs.Grid memory gridData;\\n\\n        // Get grid data based on shape.\\n        if (honeycomb.grid.shape == uint8(SHAPE.TRIANGLE)) {\\n            gridData = getTriangleGrid(honeycomb);\\n        } else if (honeycomb.grid.shape == uint8(SHAPE.DIAMOND)) {\\n            gridData = getDiamondGrid(honeycomb);\\n        } else if (honeycomb.grid.shape == uint8(SHAPE.HEXAGON)) {\\n            gridData = getHexagonGrid(honeycomb);\\n        } else if (honeycomb.grid.shape == uint8(SHAPE.RANDOM)) {\\n            gridData = getRandomGrid(honeycomb);\\n        }\\n\\n        // Generate grid svg.\\n        // prettier-ignore\\n        bytes memory svg = abi.encodePacked(\\n            '<g transform=\\\"scale(1) rotate(', \\n                    Utilities.uint2str(honeycomb.grid.rotation) ,',', \\n                    Utilities.uint2str(honeycomb.canvas.size / 2) ,',', \\n                    Utilities.uint2str(honeycomb.canvas.size / 2), ')\\\">',\\n                gridData.hexagonsSvg,\\n            '</g>'\\n        );\\n\\n        return (svg, gridData.totalGradients, gridData.rows);\\n    }\\n}\"\r\n    },\r\n    \"contracts/libraries/HoneycombsArt.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport \\\"../interfaces/IHoneycombs.sol\\\";\\nimport \\\"./Utilities.sol\\\";\\nimport \\\"./GridArt.sol\\\";\\nimport \\\"./GradientsArt.sol\\\";\\n\\n/**\\n@title  HoneycombsArt\\n@notice Renders the Honeycombs visuals.\\n*/\\nlibrary HoneycombsArt {\\n    enum HEXAGON_TYPE { FLAT, POINTY } // prettier-ignore\\n    enum SHAPE { TRIANGLE, DIAMOND, HEXAGON, RANDOM } // prettier-ignore\\n\\n    /// @dev Generate relevant rendering data by loading honeycomb from storage and filling its attribute settings.\\n    /// @param honeycombs The DB containing all honeycombs.\\n    /// @param tokenId The tokenId of the honeycomb to render.\\n    function generateHoneycombRenderData(\\n        IHoneycombs.Honeycombs storage honeycombs,\\n        uint256 tokenId\\n    ) public view returns (IHoneycombs.Honeycomb memory honeycomb) {\\n        IHoneycombs.StoredHoneycomb memory stored = honeycombs.all[tokenId];\\n        honeycomb.stored = stored;\\n\\n        // Determine if the honeycomb is revealed via the epoch randomness.\\n        uint128 randomness = honeycombs.epochs[stored.epoch].randomness;\\n        honeycomb.isRevealed = randomness > 0;\\n\\n        // Exit early if the honeycomb is not revealed.\\n        if (!honeycomb.isRevealed) {\\n            return honeycomb;\\n        }\\n\\n        // Set the seed.\\n        honeycomb.seed = (uint256(keccak256(abi.encodePacked(randomness, stored.seed))) % type(uint128).max);\\n\\n        // Set the canvas properties.\\n        honeycomb.canvas.color = Utilities.random(honeycomb.seed, \\\"canvasColor\\\", 2) == 0 ? \\\"White\\\" : \\\"Black\\\";\\n        honeycomb.canvas.size = 810;\\n        honeycomb.canvas.hexagonSize = 72;\\n        honeycomb.canvas.maxHexagonsPerLine = 8; // (810 (canvasSize) - 90 (padding) / 72 (hexagon size)) - 1 = 8\\n\\n        // Get the base hexagon properties.\\n        honeycomb.baseHexagon.hexagonType = uint8(\\n            Utilities.random(honeycomb.seed, \\\"hexagonType\\\", 2) == 0 ? HEXAGON_TYPE.FLAT : HEXAGON_TYPE.POINTY\\n        );\\n        honeycomb.baseHexagon.path = GridArt.getHexagonPath(honeycomb.baseHexagon.hexagonType);\\n        honeycomb.baseHexagon.strokeWidth = uint8(Utilities.random(honeycomb.seed, \\\"strokeWidth\\\", 15) + 3);\\n        honeycomb.baseHexagon.fillColor = Utilities.random(honeycomb.seed, \\\"hexagonFillColor\\\", 2) == 0\\n            ? \\\"White\\\"\\n            : \\\"Black\\\";\\n\\n        /**\\n         * Get the grid properties, including the actual svg.\\n         * Note: Random shapes must only have pointy top hexagon bases (artist design choice).\\n         * Note: Triangles have unique rotation options (artist design choice).\\n         */\\n        honeycomb.grid.shape = uint8(Utilities.random(honeycomb.seed, \\\"gridShape\\\", 4));\\n        if (honeycomb.grid.shape == uint8(SHAPE.RANDOM)) {\\n            honeycomb.baseHexagon.hexagonType = uint8(HEXAGON_TYPE.POINTY);\\n            honeycomb.baseHexagon.path = GridArt.getHexagonPath(honeycomb.baseHexagon.hexagonType);\\n        }\\n\\n        honeycomb.grid.rotation = honeycomb.grid.shape == uint8(SHAPE.TRIANGLE)\\n            ? uint16(Utilities.random(honeycomb.seed, \\\"rotation\\\", 4) * 90)\\n            : uint16(Utilities.random(honeycomb.seed, \\\"rotation\\\", 12) * 30);\\n\\n        (honeycomb.grid.svg, honeycomb.grid.totalGradients, honeycomb.grid.rows) = GridArt.generateGrid(honeycomb);\\n\\n        // Get the gradients properties, including the actual svg.\\n        honeycomb.gradients.chrome = GradientsArt.getChrome(uint8(Utilities.random(honeycomb.seed, \\\"chrome\\\", 7)));\\n        honeycomb.gradients.duration = GradientsArt.getDuration(uint16(Utilities.random(honeycomb.seed, \\\"duration\\\", 4)));\\n        honeycomb.gradients.direction = uint8(Utilities.random(honeycomb.seed, \\\"direction\\\", 2));\\n        honeycomb.gradients.svg = GradientsArt.generateGradientsSvg(honeycomb);\\n    }\\n\\n    /// @dev Generate the complete SVG and its associated data for a honeycomb.\\n    /// @param honeycombs The DB containing all honeycombs.\\n    /// @param tokenId The tokenId of the honeycomb to render.\\n    function generateHoneycomb(\\n        IHoneycombs.Honeycombs storage honeycombs,\\n        uint256 tokenId\\n    ) public view returns (IHoneycombs.Honeycomb memory) {\\n        IHoneycombs.Honeycomb memory honeycomb = generateHoneycombRenderData(honeycombs, tokenId);\\n\\n        if (!honeycomb.isRevealed) {\\n            // prettier-ignore\\n            honeycomb.svg = abi.encodePacked(\\n                '<svg viewBox=\\\"0 0 810 810\\\" fill=\\\"#ffffff\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" style=\\\"width:100%;background:black;\\\">',\\n                    '<rect width=\\\"810\\\" height=\\\"810\\\" fill=\\\"black\\\" transform=\\\"translate(-37.98, -37.98)\\\" />',\\n                    '<g id=\\\"logo\\\" transform=\\\"translate(220, 220)\\\">',\\n                        '<g id=\\\"hexagon\\\" transform=\\\"translate(17.089965000000007,17.089965000000007), scale(0.91)\\\">',\\n                            '<path transform=\\\"translate(-37.98, -37.98), scale(28.48375)\\\" fill=\\\"#181818\\\" ',\\n                                'd=\\\"M9.166.33a2.25 2.25 0 00-2.332 0l-5.25 3.182A2.25 2.25 0 00.5 5.436v5.128a2.25 2.25 0 001.084 1.924l5.25 3.182a2.25 2.25 0 002.332 0l5.25-3.182a2.25 2.25 0 001.084-1.924V5.436a2.25 2.25 0 00-1.084-1.924L9.166.33z\\\">',\\n                            '</path>',\\n                        '</g>'\\n                        '<g id=\\\"hummingbird\\\" stroke-linecap=\\\"round\\\" stroke-linejoin=\\\"round\\\" stroke=\\\"#ffc107\\\" stroke-width=\\\"6\\\">',\\n                            '<path d=\\\"M366.314,97.749c-0.129-1.144-1.544-1.144-2.389-1.144c-6.758,0-37.499,4.942-62.82,13.081 c-1.638,0.527-2.923,0.783-3.928,0.783c-1.961,0-2.722-0.928-4.254-3.029c-1.848-2.533-4.379-6.001-11.174-8.914 c-2.804-1.202-6.057-1.812-9.667-1.812c-14.221,0-32.199,9.312-42.749,22.142c-0.066,0.08-0.103,0.096-0.107,0.096 c-0.913,0-4.089-3.564-9.577-17.062c-4.013-9.87-8.136-22.368-10.504-31.842c-3.553-14.212-13.878-34.195-20.71-47.417 c-2.915-5.642-5.218-10.098-5.797-11.836c-0.447-1.339-1.15-2.019-2.091-2.019c-0.604,0-1.184,0.3-1.773,0.917 c-6.658,6.983-20.269,65.253-19.417,83.132c0.699,14.682,12.291,24.61,17.861,29.381c0.659,0.564,1.363,1.167,1.911,1.67 c-2.964-1.06-9.171-6.137-17.406-12.873c-11.881-9.718-29.836-24.403-54.152-40.453c-34.064-22.484-55.885-44.77-68.922-58.084 C29.964,3.599,26.338,0,23.791,0c-0.605,0-1.707,0.227-2.278,1.75c-2.924,7.798,0.754,88.419,37.074,132.002 c20.279,24.335,46.136,36.829,63.246,45.097c9.859,4.764,17.647,8.527,18.851,12.058c0.273,0.803,0.203,1.573-0.223,2.425 c-1.619,3.238-4.439,7.193-8.011,12.202c-9.829,13.783-24.682,34.613-35.555,69.335c-4.886,15.601-55.963,70.253-69.247,83.537 c-0.648,0.648-15.847,15.917-14.06,20.229c0.142,0.344,0.613,1.143,1.908,1.143c3.176,0,11.554-5.442,24.902-16.195 c17.47-14.073,29.399-25.848,38.11-34.452c8.477-8.374,13.784-13.596,17.427-14.161c-0.333,1.784-1.385,6.367-4.576,17.926 c-0.077,0.279-0.238,0.938,0.127,1.418l0.355,0.576h0.495c0.001,0,0.002,0,0.003,0c0.773,0,1.172-0.618,4.53-4.786 c10.244-12.714,41.417-51.561,84.722-60.067c25.376-4.985,56.886-28.519,68.008-63.854c16.822-53.439,30.902-87.056,105.176-104.081 C366.502,99.413,366.428,98.751,366.314,97.749z\\\" />'\\n                        '</g>',\\n                    '</g>',\\n                '</svg>'\\n            );\\n        } else {\\n            // prettier-ignore\\n            honeycomb.svg = abi.encodePacked(\\n                // Note: Use 810 as hardcoded size to avoid stack too deep error.\\n                '<svg viewBox=\\\"0 0 810 810\\\" fill=\\\"none\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" ', \\n                        'style=\\\"width:100%;background:', honeycomb.canvas.color, ';\\\">',\\n                    '<defs>',\\n                        '<path id=\\\"hexagon\\\" fill=\\\"', honeycomb.baseHexagon.fillColor,\\n                            '\\\" stroke-width=\\\"', Utilities.uint2str(honeycomb.baseHexagon.strokeWidth),\\n                            '\\\" d=\\\"', honeycomb.baseHexagon.path ,'\\\" />',\\n                        honeycomb.gradients.svg,\\n                    '</defs>',\\n                    '<rect width=\\\"810\\\" height=\\\"810\\\" fill=\\\"', honeycomb.canvas.color, '\\\"/>',\\n                    honeycomb.grid.svg,\\n                    '<rect width=\\\"810\\\" height=\\\"810\\\" fill=\\\"transparent\\\">',\\n                        '<animate attributeName=\\\"width\\\" from=\\\"810\\\" to=\\\"0\\\" dur=\\\"0.2s\\\" fill=\\\"freeze\\\" ',\\n                            'begin=\\\"click\\\" id=\\\"animation\\\"/>',\\n                    '</rect>',\\n                '</svg>'\\n            );\\n        }\\n\\n        return honeycomb;\\n    }\\n}\"\r\n    },\r\n    \"contracts/libraries/HoneycombsMetadata.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport \\\"@openzeppelin/contracts/utils/Base64.sol\\\";\\n\\nimport \\\"./HoneycombsArt.sol\\\";\\nimport \\\"../interfaces/IHoneycombs.sol\\\";\\nimport \\\"./Utilities.sol\\\";\\n\\n/**\\n@title  HoneycombsMetadata\\n@notice Renders ERC721 compatible metadata for Honeycombs.\\n*/\\nlibrary HoneycombsMetadata {\\n    /// @dev Render the JSON Metadata for a given Honeycombs token.\\n    /// @param honeycombs The DB containing all honeycombs.\\n    /// @param tokenId The id of the token to render.\\n    function tokenURI(IHoneycombs.Honeycombs storage honeycombs, uint256 tokenId) public view returns (string memory) {\\n        IHoneycombs.Honeycomb memory honeycomb = HoneycombsArt.generateHoneycomb(honeycombs, tokenId);\\n\\n        // prettier-ignore\\n        bytes memory metadata = abi.encodePacked(\\n            '{',\\n                '\\\"name\\\": \\\"Honeycomb #', Utilities.uint2str(tokenId), '\\\",',\\n                '\\\"description\\\": \\\"You are searching the world for treasure, but the real treasure is yourself. - Rumi\\\",',\\n                '\\\"image\\\": ',\\n                    '\\\"data:image/svg+xml;base64,',\\n                    Base64.encode(honeycomb.svg),\\n                    '\\\",',\\n                '\\\"animation_url\\\": ',\\n                    '\\\"data:text/html;base64,',\\n                    Base64.encode(generateHTML(tokenId, honeycomb.svg)),\\n                    '\\\",',\\n                '\\\"attributes\\\": [', attributes(honeycomb), ']',\\n            '}'\\n        );\\n\\n        return string(abi.encodePacked(\\\"data:application/json;base64,\\\", Base64.encode(metadata)));\\n    }\\n\\n    /// @dev Render the JSON atributes for a given Honeycombs token.\\n    /// @param honeycomb The honeycomb to render.\\n    function attributes(IHoneycombs.Honeycomb memory honeycomb) public pure returns (bytes memory) {\\n        return\\n            abi.encodePacked(\\n                honeycomb.isRevealed ? trait(\\\"Canvas Color\\\", honeycomb.canvas.color, \\\",\\\") : \\\"\\\",\\n                honeycomb.isRevealed\\n                    ? trait(\\\"Base Hexagon\\\", honeycomb.baseHexagon.hexagonType == 0 ? \\\"Flat Top\\\" : \\\"Pointy Top\\\", \\\",\\\")\\n                    : \\\"\\\",\\n                honeycomb.isRevealed ? trait(\\\"Base Hexagon Fill Color\\\", honeycomb.baseHexagon.fillColor, \\\",\\\") : \\\"\\\",\\n                honeycomb.isRevealed\\n                    ? trait(\\\"Stroke Width\\\", Utilities.uint2str(honeycomb.baseHexagon.strokeWidth), \\\",\\\")\\n                    : \\\"\\\",\\n                honeycomb.isRevealed ? trait(\\\"Shape\\\", shapes(honeycomb.grid.shape), \\\",\\\") : \\\"\\\",\\n                honeycomb.isRevealed ? trait(\\\"Rows\\\", Utilities.uint2str(honeycomb.grid.rows), \\\",\\\") : \\\"\\\",\\n                honeycomb.isRevealed ? trait(\\\"Rotation\\\", Utilities.uint2str(honeycomb.grid.rotation), \\\",\\\") : \\\"\\\",\\n                honeycomb.isRevealed ? trait(\\\"Chrome\\\", chromes(honeycomb.gradients.chrome), \\\",\\\") : \\\"\\\",\\n                honeycomb.isRevealed ? trait(\\\"Duration\\\", durations(honeycomb.gradients.duration), \\\",\\\") : \\\"\\\",\\n                honeycomb.isRevealed\\n                    ? trait(\\\"Direction\\\", honeycomb.gradients.direction == 0 ? \\\"Forward\\\" : \\\"Reverse\\\", \\\",\\\")\\n                    : \\\"\\\",\\n                honeycomb.isRevealed == false ? trait(\\\"Revealed\\\", \\\"No\\\", \\\",\\\") : \\\"\\\",\\n                trait(\\\"Day\\\", Utilities.uint2str(honeycomb.stored.day), \\\"\\\")\\n            );\\n    }\\n\\n    /// @dev Get the names for different shapes. Compare HoneycombsArt.getShape().\\n    /// @param shapeIndex The index of the shape.\\n    function shapes(uint8 shapeIndex) public pure returns (string memory) {\\n        return [\\\"Triangle\\\", \\\"Diamond\\\", \\\"Hexagon\\\", \\\"Random\\\"][shapeIndex];\\n    }\\n\\n    /// @dev Get the names for different chromes (max colors). Compare HoneycombsArt.getChrome().\\n    /// @param chrome The chrome of the gradient, which is the number of max colors.\\n    function chromes(uint8 chrome) public pure returns (string memory) {\\n        if (chrome <= 6) {\\n            return [\\\"Monochrome\\\", \\\"Dichrome\\\", \\\"Trichrome\\\", \\\"Tetrachrome\\\", \\\"Pentachrome\\\", \\\"Hexachrome\\\"][chrome - 1];\\n        } else {\\n            return \\\"Many\\\";\\n        }\\n    }\\n\\n    /// @dev Get the names for different durations. Compare HoneycombsArt.getDuration().\\n    /// @param duration The duration in seconds.\\n    function durations(uint16 duration) public pure returns (string memory) {\\n        if (duration == 10) {\\n            return \\\"Rave\\\";\\n        } else if (duration == 40) {\\n            return \\\"Normal\\\";\\n        } else if (duration == 80) {\\n            return \\\"Soothing\\\";\\n        } else {\\n            return \\\"Meditative\\\";\\n        }\\n    }\\n\\n    /// @dev Generate the SVG snipped for a single attribute.\\n    /// @param traitType The `trait_type` for this trait.\\n    /// @param traitValue The `value` for this trait.\\n    /// @param append Helper to append a comma.\\n    function trait(\\n        string memory traitType,\\n        string memory traitValue,\\n        string memory append\\n    ) public pure returns (string memory) {\\n        // prettier-ignore\\n        return string(abi.encodePacked(\\n            '{',\\n                '\\\"trait_type\\\": \\\"', traitType, '\\\",'\\n                '\\\"value\\\": \\\"', traitValue, '\\\"'\\n            '}',\\n            append\\n        ));\\n    }\\n\\n    /// @dev Generate the HTML for the animation_url in the metadata.\\n    /// @param tokenId The id of the token to generate the embed for.\\n    /// @param svg The rendered SVG code to embed in the HTML.\\n    function generateHTML(uint256 tokenId, bytes memory svg) public pure returns (bytes memory) {\\n        // prettier-ignore\\n        return abi.encodePacked(\\n            '<!DOCTYPE html>',\\n            '<html lang=\\\"en\\\">',\\n            '<head>',\\n                '<meta charset=\\\"UTF-8\\\">',\\n                '<meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\">',\\n                '<meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\">',\\n                '<title>Honeycomb ', Utilities.uint2str(tokenId), '</title>',\\n                '<style>',\\n                    'html,',\\n                    'body {',\\n                        'margin: 0;',\\n                        'background: #EFEFEF;',\\n                        'overflow: hidden;',\\n                    '}',\\n                    'svg {',\\n                        'max-width: 100vw;',\\n                        'max-height: 100vh;',\\n                    '}',\\n                '</style>',\\n            '</head>',\\n            '<body>',\\n                svg,\\n            '</body>',\\n            '</html>'\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/Utilities.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nlibrary Utilities {\\n    /// @dev Zero-index based pseudorandom number based on one input and max bound\\n    function random(uint256 input, uint256 _max) internal pure returns (uint256) {\\n        return (uint256(keccak256(abi.encodePacked(input))) % _max);\\n    }\\n\\n    /// @dev Zero-index based salted pseudorandom number based on two inputs and max bound\\n    function random(uint256 input, bytes memory salt, uint256 _max) internal pure returns (uint256) {\\n        return (uint256(keccak256(abi.encodePacked(input, salt))) % _max);\\n    }\\n\\n    /// @dev Convert an integer to a string\\n    function uint2str(uint256 _i) internal pure returns (string memory _uintAsString) {\\n        if (_i == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 j = _i;\\n        uint256 len;\\n        while (j != 0) {\\n            ++len;\\n            j /= 10;\\n        }\\n        bytes memory bstr = new bytes(len);\\n        uint256 k = len;\\n        while (_i != 0) {\\n            k = k - 1;\\n            uint8 temp = (48 + uint8(_i - (_i / 10) * 10));\\n            bytes1 b1 = bytes1(temp);\\n            bstr[k] = b1;\\n            _i /= 10;\\n        }\\n        return string(bstr);\\n    }\\n\\n    /// @dev Get the larger number\\n    function max(uint8 one, uint8 two) internal pure returns (uint8) {\\n        return one > two ? one : two;\\n    }\\n\\n    /// @dev Get the absolute difference between two numbers\\n    function absDiff(uint8 one, uint8 two) internal pure returns (uint8) {\\n        return one > two ? one - two : two - one;\\n    }\\n\\n    /// @dev Swap two numbers\\n    function swap(uint16 one, uint16 two) internal pure returns (uint16, uint16) {\\n        return (two, one);\\n    }\\n\\n    /// @dev Get the days since another date (input is seconds)\\n    function day(uint256 from, uint256 to) internal pure returns (uint24) {\\n        return uint24((to - from) / 24 hours + 1);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/standards/HONEYCOMBS721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/introspection/ERC165.sol\\\";\\nimport \\\"../interfaces/IERC4906.sol\\\";\\n\\n/**\\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\\n * {ERC721Enumerable}.\\n */\\ncontract HONEYCOMBS721 is Context, ERC165, IERC721, IERC721Metadata, IERC4906 {\\n    error ERC721__InvalidApproval();\\n    error ERC721__InvalidOwner();\\n    error ERC721__InvalidToken();\\n    error ERC721__NotAllowed();\\n    error ERC721__TokenExists();\\n    error ERC721__TransferToNonReceiver();\\n    error ERC721__TransferToZero();\\n\\n    using Address for address;\\n    using Strings for uint256;\\n\\n    // Token name\\n    string private _name;\\n\\n    // Token symbol\\n    string private _symbol;\\n\\n    // Mapping from token ID to owner address\\n    mapping(uint256 => address) private _owners;\\n\\n    // Mapping owner address to token count\\n    mapping(address => uint256) private _balances;\\n\\n    // Mapping from token ID to approved address\\n    mapping(uint256 => address) private _tokenApprovals;\\n\\n    // Mapping from owner to operator approvals\\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\\n\\n    /**\\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\\n     */\\n    constructor() {\\n        _name = \\\"Honeycombs\\\";\\n        _symbol = \\\"HONEYCOMBS\\\";\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\\n        return\\n            interfaceId == type(IERC721).interfaceId ||\\n            interfaceId == type(IERC721Metadata).interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-balanceOf}.\\n     */\\n    function balanceOf(address owner) public view virtual override returns (uint256) {\\n        if (owner == address(0)) {\\n            revert ERC721__InvalidOwner();\\n        }\\n        return _balances[owner];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-ownerOf}.\\n     */\\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\\n        address owner = _ownerOf(tokenId);\\n        if (owner == address(0)) {\\n            revert ERC721__InvalidToken();\\n        }\\n        return owner;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-name}.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-symbol}.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-tokenURI}.\\n     */\\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\\n        _requireMinted(tokenId);\\n\\n        return \\\"\\\";\\n    }\\n\\n    /**\\n     * @dev See {IERC721-approve}.\\n     */\\n    function approve(address to, uint256 tokenId) public virtual override {\\n        address owner = HONEYCOMBS721.ownerOf(tokenId);\\n\\n        if (to == owner || (_msgSender() != owner && !isApprovedForAll(owner, _msgSender()))) {\\n            revert ERC721__InvalidApproval();\\n        }\\n\\n        _approve(to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-getApproved}.\\n     */\\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\\n        _requireMinted(tokenId);\\n\\n        return _tokenApprovals[tokenId];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\n        _setApprovalForAll(_msgSender(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\\n        return _operatorApprovals[owner][operator];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-transferFrom}.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\\n        if (!_isApprovedOrOwner(_msgSender(), tokenId)) {\\n            revert ERC721__NotAllowed();\\n        }\\n\\n        _transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\\n        safeTransferFrom(from, to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {\\n        if (!_isApprovedOrOwner(_msgSender(), tokenId)) {\\n            revert ERC721__NotAllowed();\\n        }\\n        _safeTransfer(from, to, tokenId, data);\\n    }\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\\n     *\\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\\n        _transfer(from, to, tokenId);\\n        if (!_checkOnERC721Received(from, to, tokenId, data)) {\\n            revert ERC721__TransferToNonReceiver();\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn't exist\\n     */\\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\\n        return _owners[tokenId];\\n    }\\n\\n    /**\\n     * @dev Returns whether `tokenId` exists.\\n     *\\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\\n     *\\n     * Tokens start existing when they are minted (`_mint`),\\n     * and stop existing when they are burned (`_burn`).\\n     */\\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\\n        return _ownerOf(tokenId) != address(0);\\n    }\\n\\n    /**\\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\\n        address owner = HONEYCOMBS721.ownerOf(tokenId);\\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\\n    }\\n\\n    /**\\n     * @dev Safely mints `tokenId` and transfers it to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeMint(address to, uint256 tokenId) internal virtual {\\n        _safeMint(to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\\n     */\\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\\n        _mint(to, tokenId);\\n        if (!_checkOnERC721Received(address(0), to, tokenId, data)) {\\n            revert ERC721__TransferToNonReceiver();\\n        }\\n    }\\n\\n    /**\\n     * @dev Safely mints `tokenId` and transfers it to `to` after an inital transfer to `via`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeMintVia(address to, address via, uint256 tokenId) internal virtual {\\n        _safeMintVia(to, via, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\\n     */\\n    function _safeMintVia(address to, address via, uint256 tokenId, bytes memory data) internal virtual {\\n        _mintVia(to, via, tokenId);\\n        if (!_checkOnERC721Received(address(0), to, tokenId, data)) {\\n            revert ERC721__TransferToNonReceiver();\\n        }\\n    }\\n\\n    /**\\n     * @dev Mints `tokenId` and transfers it to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - `to` cannot be the zero address.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _mint(address to, uint256 tokenId) internal virtual {\\n        _mintState(to, tokenId);\\n\\n        emit Transfer(address(0), to, tokenId);\\n\\n        _afterTokenTransfer(address(0), to, tokenId, 1);\\n    }\\n\\n    /**\\n     * @dev Mints `tokenId` and transfers it to `to` after a transfer to `via`\\n     *\\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - `to` cannot be the zero address.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _mintVia(address to, address via, uint256 tokenId) internal virtual {\\n        _mintState(to, tokenId);\\n\\n        emit Transfer(address(0), via, tokenId);\\n        emit Transfer(via, to, tokenId);\\n\\n        _afterTokenTransfer(address(0), to, tokenId, 1);\\n    }\\n\\n    /**\\n     * @dev Mints `tokenId` and transfers it to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - `to` cannot be the zero address.\\n     */\\n    function _mintState(address to, uint256 tokenId) internal virtual {\\n        if (to == address(0)) {\\n            revert ERC721__TransferToZero();\\n        }\\n        if (_exists(tokenId)) {\\n            revert ERC721__TokenExists();\\n        }\\n\\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\\n\\n        // Check that tokenId was not minted by `_beforeTokenTransfer` hook\\n        if (_exists(tokenId)) {\\n            revert ERC721__TokenExists();\\n        }\\n\\n        unchecked {\\n            // Will not overflow unless all 2**256 token ids are minted to the same owner.\\n            // Given that tokens are minted one by one, it is impossible in practice that\\n            // this ever happens. Might change if we allow batch minting.\\n            // The ERC fails to describe this case.\\n            _balances[to] += 1;\\n        }\\n\\n        _owners[tokenId] = to;\\n    }\\n\\n    /**\\n     * @dev Destroys `tokenId`.\\n     * The approval is cleared when the token is burned.\\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _burn(uint256 tokenId) internal virtual {\\n        address owner = HONEYCOMBS721.ownerOf(tokenId);\\n\\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\\n\\n        // Update ownership in case tokenId was transferred by `_beforeTokenTransfer` hook\\n        owner = HONEYCOMBS721.ownerOf(tokenId);\\n\\n        // Clear approvals\\n        delete _tokenApprovals[tokenId];\\n\\n        unchecked {\\n            // Cannot overflow, as that would require more tokens to be burned/transferred\\n            // out than the owner initially received through minting and transferring in.\\n            _balances[owner] -= 1;\\n        }\\n        delete _owners[tokenId];\\n\\n        emit Transfer(owner, address(0), tokenId);\\n\\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\\n    }\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\\n        if (HONEYCOMBS721.ownerOf(tokenId) != from) {\\n            revert ERC721__InvalidOwner();\\n        }\\n        if (to == address(0)) {\\n            revert ERC721__TransferToZero();\\n        }\\n\\n        _beforeTokenTransfer(from, to, tokenId, 1);\\n\\n        // Check that tokenId was not transferred by `_beforeTokenTransfer` hook\\n        if (HONEYCOMBS721.ownerOf(tokenId) != from) {\\n            revert ERC721__InvalidOwner();\\n        }\\n\\n        // Clear approvals from the previous owner\\n        delete _tokenApprovals[tokenId];\\n\\n        unchecked {\\n            // `_balances[from]` cannot overflow for the same reason as described in `_burn`:\\n            // `from`'s balance is the number of token held, which is at least one before the current\\n            // transfer.\\n            // `_balances[to]` could overflow in the conditions described in `_mint`. That would require\\n            // all 2**256 token ids to be minted, which in practice is impossible.\\n            _balances[from] -= 1;\\n            _balances[to] += 1;\\n        }\\n        _owners[tokenId] = to;\\n\\n        emit Transfer(from, to, tokenId);\\n\\n        _afterTokenTransfer(from, to, tokenId, 1);\\n    }\\n\\n    /**\\n     * @dev Approve `to` to operate on `tokenId`\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function _approve(address to, uint256 tokenId) internal virtual {\\n        _tokenApprovals[tokenId] = to;\\n        emit Approval(HONEYCOMBS721.ownerOf(tokenId), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Approve `operator` to operate on all of `owner` tokens\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\\n        if (owner == operator) {\\n            revert ERC721__InvalidApproval();\\n        }\\n        _operatorApprovals[owner][operator] = approved;\\n        emit ApprovalForAll(owner, operator, approved);\\n    }\\n\\n    /**\\n     * @dev Reverts if the `tokenId` has not been minted yet.\\n     */\\n    function _requireMinted(uint256 tokenId) internal view virtual {\\n        if (!_exists(tokenId)) {\\n            revert ERC721__InvalidToken();\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\\n     * The call is not executed if the target address is not a contract.\\n     *\\n     * @param from address representing the previous owner of the given token ID\\n     * @param to target address that will receive the tokens\\n     * @param tokenId uint256 ID of the token to be transferred\\n     * @param data bytes optional data to send along with the call\\n     * @return bool whether the call correctly returned the expected magic value\\n     */\\n    function _checkOnERC721Received(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) private returns (bool) {\\n        if (to.isContract()) {\\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\\n                return retval == IERC721Receiver.onERC721Received.selector;\\n            } catch (bytes memory reason) {\\n                if (reason.length == 0) {\\n                    revert ERC721__TransferToNonReceiver();\\n                } else {\\n                    /// @solidity memory-safe-assembly\\n                    assembly {\\n                        revert(add(32, reason), mload(reason))\\n                    }\\n                }\\n            }\\n        } else {\\n            return true;\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any token transfer. This includes minting and burning. If {ERC721Consecutive} is\\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, ``from``'s tokens will be transferred to `to`.\\n     * - When `from` is zero, the tokens will be minted for `to`.\\n     * - When `to` is zero, ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     * - `batchSize` is non-zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 /* firstTokenId */,\\n        uint256 batchSize\\n    ) internal virtual {\\n        if (batchSize > 1) {\\n            if (from != address(0)) {\\n                _balances[from] -= batchSize;\\n            }\\n            if (to != address(0)) {\\n                _balances[to] += batchSize;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called after any token transfer. This includes minting and burning. If {ERC721Consecutive} is\\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, ``from``'s tokens were transferred to `to`.\\n     * - When `from` is zero, the tokens were minted for `to`.\\n     * - When `to` is zero, ``from``'s tokens were burned.\\n     * - `from` and `to` are never both zero.\\n     * - `batchSize` is non-zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {\r\n      \"contracts/libraries/HoneycombsArt.sol\": {\r\n        \"HoneycombsArt\": \"0xb71751f16b0bb01fd55dc69535556d89396eb11c\"\r\n      },\r\n      \"contracts/libraries/HoneycombsMetadata.sol\": {\r\n        \"HoneycombsMetadata\": \"0xfc0ffee2b97cf8c327d706e2646838e107d58610\"\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ERC721__InvalidApproval\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC721__InvalidOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC721__InvalidToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC721__NotAllowed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC721__TokenExists\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC721__TransferToNonReceiver\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC721__TransferToZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MaxMintPerAddressReached\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MaxSupplyReached\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotAllowed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotExactEth\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"MetadataUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"revealBlock\",\"type\":\"uint64\"}],\"name\":\"NewEpoch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"AUTO_RESERVE_FREQUENCY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_MINT_PER_ADDRESS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_SUPPLY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MINT_PRICE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getEpoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getEpochData\",\"outputs\":[{\"components\":[{\"internalType\":\"uint128\",\"name\":\"randomness\",\"type\":\"uint128\"},{\"internalType\":\"uint64\",\"name\":\"revealBlock\",\"type\":\"uint64\"},{\"internalType\":\"bool\",\"name\":\"committed\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"revealed\",\"type\":\"bool\"}],\"internalType\":\"struct IHoneycombs.Epoch\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getHoneycomb\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"epoch\",\"type\":\"uint32\"},{\"internalType\":\"uint24\",\"name\":\"day\",\"type\":\"uint24\"},{\"internalType\":\"uint16\",\"name\":\"seed\",\"type\":\"uint16\"}],\"internalType\":\"struct IHoneycombs.StoredHoneycomb\",\"name\":\"stored\",\"type\":\"tuple\"},{\"internalType\":\"bool\",\"name\":\"isRevealed\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"seed\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"svg\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"color\",\"type\":\"string\"},{\"internalType\":\"uint16\",\"name\":\"size\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"hexagonSize\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"maxHexagonsPerLine\",\"type\":\"uint16\"}],\"internalType\":\"struct IHoneycombs.Canvas\",\"name\":\"canvas\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"path\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"fillColor\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"strokeWidth\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"hexagonType\",\"type\":\"uint8\"}],\"internalType\":\"struct IHoneycombs.BaseHexagon\",\"name\":\"baseHexagon\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes\",\"name\":\"hexagonsSvg\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"svg\",\"type\":\"bytes\"},{\"internalType\":\"uint16\",\"name\":\"gridX\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"gridY\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"rowDistance\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"columnDistance\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"rotation\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"shape\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"totalGradients\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"rows\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"longestRowCount\",\"type\":\"uint8\"}],\"internalType\":\"struct IHoneycombs.Grid\",\"name\":\"grid\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes\",\"name\":\"svg\",\"type\":\"bytes\"},{\"internalType\":\"uint16\",\"name\":\"duration\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"direction\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"chrome\",\"type\":\"uint8\"}],\"internalType\":\"struct IHoneycombs.Gradients\",\"name\":\"gradients\",\"type\":\"tuple\"}],\"internalType\":\"struct IHoneycombs.Honeycomb\",\"name\":\"honeycomb\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"numberOfTokens\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minted\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reserveAddress1\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reserveAddress2\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"resolveEpochIfNecessary\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"svg\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Honeycombs", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}