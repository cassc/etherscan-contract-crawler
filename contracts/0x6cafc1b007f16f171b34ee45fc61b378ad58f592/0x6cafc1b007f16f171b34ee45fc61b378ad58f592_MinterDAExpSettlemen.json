{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin-4.5/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin-4.7/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin-4.7/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1);\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator,\\n        Rounding rounding\\n    ) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. It the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`.\\n        // We also know that `k`, the position of the most significant bit, is such that `msb(a) = 2**k`.\\n        // This gives `2**k < a <= 2**(k+1)` \u2192 `2**(k/2) <= sqrt(a) < 2 ** (k/2+1)`.\\n        // Using an algorithm similar to the msb conmputation, we are able to compute `result = 2**(k/2)` which is a\\n        // good first aproximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1;\\n        uint256 x = a;\\n        if (x >> 128 > 0) {\\n            x >>= 128;\\n            result <<= 64;\\n        }\\n        if (x >> 64 > 0) {\\n            x >>= 64;\\n            result <<= 32;\\n        }\\n        if (x >> 32 > 0) {\\n            x >>= 32;\\n            result <<= 16;\\n        }\\n        if (x >> 16 > 0) {\\n            x >>= 16;\\n            result <<= 8;\\n        }\\n        if (x >> 8 > 0) {\\n            x >>= 8;\\n            result <<= 4;\\n        }\\n        if (x >> 4 > 0) {\\n            x >>= 4;\\n            result <<= 2;\\n        }\\n        if (x >> 2 > 0) {\\n            result <<= 1;\\n        }\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = sqrt(a);\\n        if (rounding == Rounding.Up && result * result < a) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin-4.7/contracts/utils/math/SafeCast.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/math/SafeCast.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n *\\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\\n * all math on `uint256` and `int256` and then downcasting.\\n */\\nlibrary SafeCast {\\n    /**\\n     * @dev Returns the downcasted uint248 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint248).\\n     *\\n     * Counterpart to Solidity's `uint248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint248(uint256 value) internal pure returns (uint248) {\\n        require(value <= type(uint248).max, \\\"SafeCast: value doesn't fit in 248 bits\\\");\\n        return uint248(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint240 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint240).\\n     *\\n     * Counterpart to Solidity's `uint240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint240(uint256 value) internal pure returns (uint240) {\\n        require(value <= type(uint240).max, \\\"SafeCast: value doesn't fit in 240 bits\\\");\\n        return uint240(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint232 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint232).\\n     *\\n     * Counterpart to Solidity's `uint232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint232(uint256 value) internal pure returns (uint232) {\\n        require(value <= type(uint232).max, \\\"SafeCast: value doesn't fit in 232 bits\\\");\\n        return uint232(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint224 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint224).\\n     *\\n     * Counterpart to Solidity's `uint224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     *\\n     * _Available since v4.2._\\n     */\\n    function toUint224(uint256 value) internal pure returns (uint224) {\\n        require(value <= type(uint224).max, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n        return uint224(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint216 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint216).\\n     *\\n     * Counterpart to Solidity's `uint216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint216(uint256 value) internal pure returns (uint216) {\\n        require(value <= type(uint216).max, \\\"SafeCast: value doesn't fit in 216 bits\\\");\\n        return uint216(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint208 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint208).\\n     *\\n     * Counterpart to Solidity's `uint208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint208(uint256 value) internal pure returns (uint208) {\\n        require(value <= type(uint208).max, \\\"SafeCast: value doesn't fit in 208 bits\\\");\\n        return uint208(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint200 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint200).\\n     *\\n     * Counterpart to Solidity's `uint200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint200(uint256 value) internal pure returns (uint200) {\\n        require(value <= type(uint200).max, \\\"SafeCast: value doesn't fit in 200 bits\\\");\\n        return uint200(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint192 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint192).\\n     *\\n     * Counterpart to Solidity's `uint192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint192(uint256 value) internal pure returns (uint192) {\\n        require(value <= type(uint192).max, \\\"SafeCast: value doesn't fit in 192 bits\\\");\\n        return uint192(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint184 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint184).\\n     *\\n     * Counterpart to Solidity's `uint184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint184(uint256 value) internal pure returns (uint184) {\\n        require(value <= type(uint184).max, \\\"SafeCast: value doesn't fit in 184 bits\\\");\\n        return uint184(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint176 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint176).\\n     *\\n     * Counterpart to Solidity's `uint176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint176(uint256 value) internal pure returns (uint176) {\\n        require(value <= type(uint176).max, \\\"SafeCast: value doesn't fit in 176 bits\\\");\\n        return uint176(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint168 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint168).\\n     *\\n     * Counterpart to Solidity's `uint168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint168(uint256 value) internal pure returns (uint168) {\\n        require(value <= type(uint168).max, \\\"SafeCast: value doesn't fit in 168 bits\\\");\\n        return uint168(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint160 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint160).\\n     *\\n     * Counterpart to Solidity's `uint160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint160(uint256 value) internal pure returns (uint160) {\\n        require(value <= type(uint160).max, \\\"SafeCast: value doesn't fit in 160 bits\\\");\\n        return uint160(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint152 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint152).\\n     *\\n     * Counterpart to Solidity's `uint152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint152(uint256 value) internal pure returns (uint152) {\\n        require(value <= type(uint152).max, \\\"SafeCast: value doesn't fit in 152 bits\\\");\\n        return uint152(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint144 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint144).\\n     *\\n     * Counterpart to Solidity's `uint144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint144(uint256 value) internal pure returns (uint144) {\\n        require(value <= type(uint144).max, \\\"SafeCast: value doesn't fit in 144 bits\\\");\\n        return uint144(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint136 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint136).\\n     *\\n     * Counterpart to Solidity's `uint136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint136(uint256 value) internal pure returns (uint136) {\\n        require(value <= type(uint136).max, \\\"SafeCast: value doesn't fit in 136 bits\\\");\\n        return uint136(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity's `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        require(value <= type(uint128).max, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n        return uint128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint120 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint120).\\n     *\\n     * Counterpart to Solidity's `uint120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint120(uint256 value) internal pure returns (uint120) {\\n        require(value <= type(uint120).max, \\\"SafeCast: value doesn't fit in 120 bits\\\");\\n        return uint120(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint112 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint112).\\n     *\\n     * Counterpart to Solidity's `uint112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint112(uint256 value) internal pure returns (uint112) {\\n        require(value <= type(uint112).max, \\\"SafeCast: value doesn't fit in 112 bits\\\");\\n        return uint112(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint104 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint104).\\n     *\\n     * Counterpart to Solidity's `uint104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint104(uint256 value) internal pure returns (uint104) {\\n        require(value <= type(uint104).max, \\\"SafeCast: value doesn't fit in 104 bits\\\");\\n        return uint104(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint96 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint96).\\n     *\\n     * Counterpart to Solidity's `uint96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     *\\n     * _Available since v4.2._\\n     */\\n    function toUint96(uint256 value) internal pure returns (uint96) {\\n        require(value <= type(uint96).max, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n        return uint96(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint88 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint88).\\n     *\\n     * Counterpart to Solidity's `uint88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint88(uint256 value) internal pure returns (uint88) {\\n        require(value <= type(uint88).max, \\\"SafeCast: value doesn't fit in 88 bits\\\");\\n        return uint88(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint80 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint80).\\n     *\\n     * Counterpart to Solidity's `uint80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint80(uint256 value) internal pure returns (uint80) {\\n        require(value <= type(uint80).max, \\\"SafeCast: value doesn't fit in 80 bits\\\");\\n        return uint80(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint72 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint72).\\n     *\\n     * Counterpart to Solidity's `uint72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint72(uint256 value) internal pure returns (uint72) {\\n        require(value <= type(uint72).max, \\\"SafeCast: value doesn't fit in 72 bits\\\");\\n        return uint72(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint64).\\n     *\\n     * Counterpart to Solidity's `uint64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        require(value <= type(uint64).max, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n        return uint64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint56 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint56).\\n     *\\n     * Counterpart to Solidity's `uint56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint56(uint256 value) internal pure returns (uint56) {\\n        require(value <= type(uint56).max, \\\"SafeCast: value doesn't fit in 56 bits\\\");\\n        return uint56(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint48 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint48).\\n     *\\n     * Counterpart to Solidity's `uint48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint48(uint256 value) internal pure returns (uint48) {\\n        require(value <= type(uint48).max, \\\"SafeCast: value doesn't fit in 48 bits\\\");\\n        return uint48(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint40 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint40).\\n     *\\n     * Counterpart to Solidity's `uint40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint40(uint256 value) internal pure returns (uint40) {\\n        require(value <= type(uint40).max, \\\"SafeCast: value doesn't fit in 40 bits\\\");\\n        return uint40(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint32).\\n     *\\n     * Counterpart to Solidity's `uint32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\n        require(value <= type(uint32).max, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n        return uint32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint24 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint24).\\n     *\\n     * Counterpart to Solidity's `uint24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint24(uint256 value) internal pure returns (uint24) {\\n        require(value <= type(uint24).max, \\\"SafeCast: value doesn't fit in 24 bits\\\");\\n        return uint24(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint16).\\n     *\\n     * Counterpart to Solidity's `uint16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\n        require(value <= type(uint16).max, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n        return uint16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint8).\\n     *\\n     * Counterpart to Solidity's `uint8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\n        require(value <= type(uint8).max, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n        return uint8(value);\\n    }\\n\\n    /**\\n     * @dev Converts a signed int256 into an unsigned uint256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be greater than or equal to 0.\\n     *\\n     * _Available since v3.0._\\n     */\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        require(value >= 0, \\\"SafeCast: value must be positive\\\");\\n        return uint256(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int248 from int256, reverting on\\n     * overflow (when the input is less than smallest int248 or\\n     * greater than largest int248).\\n     *\\n     * Counterpart to Solidity's `int248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt248(int256 value) internal pure returns (int248) {\\n        require(value >= type(int248).min && value <= type(int248).max, \\\"SafeCast: value doesn't fit in 248 bits\\\");\\n        return int248(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int240 from int256, reverting on\\n     * overflow (when the input is less than smallest int240 or\\n     * greater than largest int240).\\n     *\\n     * Counterpart to Solidity's `int240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt240(int256 value) internal pure returns (int240) {\\n        require(value >= type(int240).min && value <= type(int240).max, \\\"SafeCast: value doesn't fit in 240 bits\\\");\\n        return int240(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int232 from int256, reverting on\\n     * overflow (when the input is less than smallest int232 or\\n     * greater than largest int232).\\n     *\\n     * Counterpart to Solidity's `int232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt232(int256 value) internal pure returns (int232) {\\n        require(value >= type(int232).min && value <= type(int232).max, \\\"SafeCast: value doesn't fit in 232 bits\\\");\\n        return int232(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int224 from int256, reverting on\\n     * overflow (when the input is less than smallest int224 or\\n     * greater than largest int224).\\n     *\\n     * Counterpart to Solidity's `int224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt224(int256 value) internal pure returns (int224) {\\n        require(value >= type(int224).min && value <= type(int224).max, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n        return int224(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int216 from int256, reverting on\\n     * overflow (when the input is less than smallest int216 or\\n     * greater than largest int216).\\n     *\\n     * Counterpart to Solidity's `int216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt216(int256 value) internal pure returns (int216) {\\n        require(value >= type(int216).min && value <= type(int216).max, \\\"SafeCast: value doesn't fit in 216 bits\\\");\\n        return int216(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int208 from int256, reverting on\\n     * overflow (when the input is less than smallest int208 or\\n     * greater than largest int208).\\n     *\\n     * Counterpart to Solidity's `int208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt208(int256 value) internal pure returns (int208) {\\n        require(value >= type(int208).min && value <= type(int208).max, \\\"SafeCast: value doesn't fit in 208 bits\\\");\\n        return int208(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int200 from int256, reverting on\\n     * overflow (when the input is less than smallest int200 or\\n     * greater than largest int200).\\n     *\\n     * Counterpart to Solidity's `int200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt200(int256 value) internal pure returns (int200) {\\n        require(value >= type(int200).min && value <= type(int200).max, \\\"SafeCast: value doesn't fit in 200 bits\\\");\\n        return int200(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int192 from int256, reverting on\\n     * overflow (when the input is less than smallest int192 or\\n     * greater than largest int192).\\n     *\\n     * Counterpart to Solidity's `int192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt192(int256 value) internal pure returns (int192) {\\n        require(value >= type(int192).min && value <= type(int192).max, \\\"SafeCast: value doesn't fit in 192 bits\\\");\\n        return int192(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int184 from int256, reverting on\\n     * overflow (when the input is less than smallest int184 or\\n     * greater than largest int184).\\n     *\\n     * Counterpart to Solidity's `int184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt184(int256 value) internal pure returns (int184) {\\n        require(value >= type(int184).min && value <= type(int184).max, \\\"SafeCast: value doesn't fit in 184 bits\\\");\\n        return int184(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int176 from int256, reverting on\\n     * overflow (when the input is less than smallest int176 or\\n     * greater than largest int176).\\n     *\\n     * Counterpart to Solidity's `int176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt176(int256 value) internal pure returns (int176) {\\n        require(value >= type(int176).min && value <= type(int176).max, \\\"SafeCast: value doesn't fit in 176 bits\\\");\\n        return int176(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int168 from int256, reverting on\\n     * overflow (when the input is less than smallest int168 or\\n     * greater than largest int168).\\n     *\\n     * Counterpart to Solidity's `int168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt168(int256 value) internal pure returns (int168) {\\n        require(value >= type(int168).min && value <= type(int168).max, \\\"SafeCast: value doesn't fit in 168 bits\\\");\\n        return int168(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int160 from int256, reverting on\\n     * overflow (when the input is less than smallest int160 or\\n     * greater than largest int160).\\n     *\\n     * Counterpart to Solidity's `int160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt160(int256 value) internal pure returns (int160) {\\n        require(value >= type(int160).min && value <= type(int160).max, \\\"SafeCast: value doesn't fit in 160 bits\\\");\\n        return int160(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int152 from int256, reverting on\\n     * overflow (when the input is less than smallest int152 or\\n     * greater than largest int152).\\n     *\\n     * Counterpart to Solidity's `int152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt152(int256 value) internal pure returns (int152) {\\n        require(value >= type(int152).min && value <= type(int152).max, \\\"SafeCast: value doesn't fit in 152 bits\\\");\\n        return int152(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int144 from int256, reverting on\\n     * overflow (when the input is less than smallest int144 or\\n     * greater than largest int144).\\n     *\\n     * Counterpart to Solidity's `int144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt144(int256 value) internal pure returns (int144) {\\n        require(value >= type(int144).min && value <= type(int144).max, \\\"SafeCast: value doesn't fit in 144 bits\\\");\\n        return int144(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int136 from int256, reverting on\\n     * overflow (when the input is less than smallest int136 or\\n     * greater than largest int136).\\n     *\\n     * Counterpart to Solidity's `int136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt136(int256 value) internal pure returns (int136) {\\n        require(value >= type(int136).min && value <= type(int136).max, \\\"SafeCast: value doesn't fit in 136 bits\\\");\\n        return int136(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int128 from int256, reverting on\\n     * overflow (when the input is less than smallest int128 or\\n     * greater than largest int128).\\n     *\\n     * Counterpart to Solidity's `int128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt128(int256 value) internal pure returns (int128) {\\n        require(value >= type(int128).min && value <= type(int128).max, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n        return int128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int120 from int256, reverting on\\n     * overflow (when the input is less than smallest int120 or\\n     * greater than largest int120).\\n     *\\n     * Counterpart to Solidity's `int120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt120(int256 value) internal pure returns (int120) {\\n        require(value >= type(int120).min && value <= type(int120).max, \\\"SafeCast: value doesn't fit in 120 bits\\\");\\n        return int120(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int112 from int256, reverting on\\n     * overflow (when the input is less than smallest int112 or\\n     * greater than largest int112).\\n     *\\n     * Counterpart to Solidity's `int112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt112(int256 value) internal pure returns (int112) {\\n        require(value >= type(int112).min && value <= type(int112).max, \\\"SafeCast: value doesn't fit in 112 bits\\\");\\n        return int112(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int104 from int256, reverting on\\n     * overflow (when the input is less than smallest int104 or\\n     * greater than largest int104).\\n     *\\n     * Counterpart to Solidity's `int104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt104(int256 value) internal pure returns (int104) {\\n        require(value >= type(int104).min && value <= type(int104).max, \\\"SafeCast: value doesn't fit in 104 bits\\\");\\n        return int104(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int96 from int256, reverting on\\n     * overflow (when the input is less than smallest int96 or\\n     * greater than largest int96).\\n     *\\n     * Counterpart to Solidity's `int96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt96(int256 value) internal pure returns (int96) {\\n        require(value >= type(int96).min && value <= type(int96).max, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n        return int96(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int88 from int256, reverting on\\n     * overflow (when the input is less than smallest int88 or\\n     * greater than largest int88).\\n     *\\n     * Counterpart to Solidity's `int88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt88(int256 value) internal pure returns (int88) {\\n        require(value >= type(int88).min && value <= type(int88).max, \\\"SafeCast: value doesn't fit in 88 bits\\\");\\n        return int88(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int80 from int256, reverting on\\n     * overflow (when the input is less than smallest int80 or\\n     * greater than largest int80).\\n     *\\n     * Counterpart to Solidity's `int80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt80(int256 value) internal pure returns (int80) {\\n        require(value >= type(int80).min && value <= type(int80).max, \\\"SafeCast: value doesn't fit in 80 bits\\\");\\n        return int80(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int72 from int256, reverting on\\n     * overflow (when the input is less than smallest int72 or\\n     * greater than largest int72).\\n     *\\n     * Counterpart to Solidity's `int72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt72(int256 value) internal pure returns (int72) {\\n        require(value >= type(int72).min && value <= type(int72).max, \\\"SafeCast: value doesn't fit in 72 bits\\\");\\n        return int72(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int64 from int256, reverting on\\n     * overflow (when the input is less than smallest int64 or\\n     * greater than largest int64).\\n     *\\n     * Counterpart to Solidity's `int64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt64(int256 value) internal pure returns (int64) {\\n        require(value >= type(int64).min && value <= type(int64).max, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n        return int64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int56 from int256, reverting on\\n     * overflow (when the input is less than smallest int56 or\\n     * greater than largest int56).\\n     *\\n     * Counterpart to Solidity's `int56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt56(int256 value) internal pure returns (int56) {\\n        require(value >= type(int56).min && value <= type(int56).max, \\\"SafeCast: value doesn't fit in 56 bits\\\");\\n        return int56(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int48 from int256, reverting on\\n     * overflow (when the input is less than smallest int48 or\\n     * greater than largest int48).\\n     *\\n     * Counterpart to Solidity's `int48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt48(int256 value) internal pure returns (int48) {\\n        require(value >= type(int48).min && value <= type(int48).max, \\\"SafeCast: value doesn't fit in 48 bits\\\");\\n        return int48(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int40 from int256, reverting on\\n     * overflow (when the input is less than smallest int40 or\\n     * greater than largest int40).\\n     *\\n     * Counterpart to Solidity's `int40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt40(int256 value) internal pure returns (int40) {\\n        require(value >= type(int40).min && value <= type(int40).max, \\\"SafeCast: value doesn't fit in 40 bits\\\");\\n        return int40(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int32 from int256, reverting on\\n     * overflow (when the input is less than smallest int32 or\\n     * greater than largest int32).\\n     *\\n     * Counterpart to Solidity's `int32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt32(int256 value) internal pure returns (int32) {\\n        require(value >= type(int32).min && value <= type(int32).max, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n        return int32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int24 from int256, reverting on\\n     * overflow (when the input is less than smallest int24 or\\n     * greater than largest int24).\\n     *\\n     * Counterpart to Solidity's `int24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt24(int256 value) internal pure returns (int24) {\\n        require(value >= type(int24).min && value <= type(int24).max, \\\"SafeCast: value doesn't fit in 24 bits\\\");\\n        return int24(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int16 from int256, reverting on\\n     * overflow (when the input is less than smallest int16 or\\n     * greater than largest int16).\\n     *\\n     * Counterpart to Solidity's `int16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt16(int256 value) internal pure returns (int16) {\\n        require(value >= type(int16).min && value <= type(int16).max, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n        return int16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int8 from int256, reverting on\\n     * overflow (when the input is less than smallest int8 or\\n     * greater than largest int8).\\n     *\\n     * Counterpart to Solidity's `int8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt8(int256 value) internal pure returns (int8) {\\n        require(value >= type(int8).min && value <= type(int8).max, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n        return int8(value);\\n    }\\n\\n    /**\\n     * @dev Converts an unsigned uint256 into a signed int256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be less than or equal to maxInt256.\\n     *\\n     * _Available since v3.0._\\n     */\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\\n        require(value <= uint256(type(int256).max), \\\"SafeCast: value doesn't fit in an int256\\\");\\n        return int256(value);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/v0.8.x/IAdminACLV0.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\n// Created By: Art Blocks Inc.\\n\\npragma solidity ^0.8.0;\\n\\ninterface IAdminACLV0 {\\n    /**\\n     * @notice Token ID `_tokenId` minted to `_to`.\\n     * @param previousSuperAdmin The previous superAdmin address.\\n     * @param newSuperAdmin The new superAdmin address.\\n     * @param genArt721CoreAddressesToUpdate Array of genArt721Core\\n     * addresses to update to the new superAdmin, for indexing purposes only.\\n     */\\n    event SuperAdminTransferred(\\n        address indexed previousSuperAdmin,\\n        address indexed newSuperAdmin,\\n        address[] genArt721CoreAddressesToUpdate\\n    );\\n\\n    /// Type of the Admin ACL contract, e.g. \\\"AdminACLV0\\\"\\n    function AdminACLType() external view returns (string memory);\\n\\n    /// super admin address\\n    function superAdmin() external view returns (address);\\n\\n    /**\\n     * @notice Calls transferOwnership on other contract from this contract.\\n     * This is useful for updating to a new AdminACL contract.\\n     * @dev this function should be gated to only superAdmin-like addresses.\\n     */\\n    function transferOwnershipOn(\\n        address _contract,\\n        address _newAdminACL\\n    ) external;\\n\\n    /**\\n     * @notice Calls renounceOwnership on other contract from this contract.\\n     * @dev this function should be gated to only superAdmin-like addresses.\\n     */\\n    function renounceOwnershipOn(address _contract) external;\\n\\n    /**\\n     * @notice Checks if sender `_sender` is allowed to call function with selector\\n     * `_selector` on contract `_contract`.\\n     */\\n    function allowed(\\n        address _sender,\\n        address _contract,\\n        bytes4 _selector\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/v0.8.x/ICoreRegistryV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\n// Created By: Art Blocks Inc.\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IEngineRegistryV0.sol\\\";\\n\\ninterface ICoreRegistryV1 is IEngineRegistryV0 {\\n    function registerContracts(\\n        address[] calldata contractAddresses,\\n        bytes32[] calldata coreVersions,\\n        bytes32[] calldata coreTypes\\n    ) external;\\n\\n    function unregisterContracts(address[] calldata contractAddresses) external;\\n\\n    function getNumRegisteredContracts() external view returns (uint256);\\n\\n    function getRegisteredContractAt(\\n        uint256 index\\n    ) external view returns (address);\\n\\n    function isRegisteredContract(\\n        address contractAddress\\n    ) external view returns (bool isRegistered);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/v0.8.x/IEngineRegistryV0.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\n// Created By: Art Blocks Inc.\\npragma solidity ^0.8.0;\\n\\ninterface IEngineRegistryV0 {\\n    /// ADDRESS\\n    /**\\n     * @notice contract has been registered as a contract that is powered by the Art Blocks Engine.\\n     */\\n    event ContractRegistered(\\n        address indexed _contractAddress,\\n        bytes32 _coreVersion,\\n        bytes32 _coreType\\n    );\\n\\n    /// ADDRESS\\n    /**\\n     * @notice contract has been unregistered as a contract that is powered by the Art Blocks Engine.\\n     */\\n    event ContractUnregistered(address indexed _contractAddress);\\n\\n    /**\\n     * @notice Emits a `ContractRegistered` event with the provided information.\\n     * @dev this function should be gated to only deployer addresses.\\n     */\\n    function registerContract(\\n        address _contractAddress,\\n        bytes32 _coreVersion,\\n        bytes32 _coreType\\n    ) external;\\n\\n    /**\\n     * @notice Emits a `ContractUnregistered` event with the provided information, validating that the provided\\n     *         address was indeed previously registered.\\n     * @dev this function should be gated to only deployer addresses.\\n     */\\n    function unregisterContract(address _contractAddress) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/v0.8.x/IFilteredMinterV0.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\n// Created By: Art Blocks Inc.\\n\\npragma solidity ^0.8.0;\\n\\ninterface IFilteredMinterV0 {\\n    /**\\n     * @notice Price per token in wei updated for project `_projectId` to\\n     * `_pricePerTokenInWei`.\\n     */\\n    event PricePerTokenInWeiUpdated(\\n        uint256 indexed _projectId,\\n        uint256 indexed _pricePerTokenInWei\\n    );\\n\\n    /**\\n     * @notice Currency updated for project `_projectId` to symbol\\n     * `_currencySymbol` and address `_currencyAddress`.\\n     */\\n    event ProjectCurrencyInfoUpdated(\\n        uint256 indexed _projectId,\\n        address indexed _currencyAddress,\\n        string _currencySymbol\\n    );\\n\\n    /// togglePurchaseToDisabled updated\\n    event PurchaseToDisabledUpdated(\\n        uint256 indexed _projectId,\\n        bool _purchaseToDisabled\\n    );\\n\\n    // getter function of public variable\\n    function minterType() external view returns (string memory);\\n\\n    function genArt721CoreAddress() external returns (address);\\n\\n    function minterFilterAddress() external returns (address);\\n\\n    // Triggers a purchase of a token from the desired project, to the\\n    // TX-sending address.\\n    function purchase(\\n        uint256 _projectId\\n    ) external payable returns (uint256 tokenId);\\n\\n    // Triggers a purchase of a token from the desired project, to the specified\\n    // receiving address.\\n    function purchaseTo(\\n        address _to,\\n        uint256 _projectId\\n    ) external payable returns (uint256 tokenId);\\n\\n    // Toggles the ability for `purchaseTo` to be called directly with a\\n    // specified receiving address that differs from the TX-sending address.\\n    function togglePurchaseToDisabled(uint256 _projectId) external;\\n\\n    // Called to make the minter contract aware of the max invocations for a\\n    // given project.\\n    function setProjectMaxInvocations(uint256 _projectId) external;\\n\\n    // Gets if token price is configured, token price in wei, currency symbol,\\n    // and currency address, assuming this is project's minter.\\n    // Supersedes any defined core price.\\n    function getPriceInfo(\\n        uint256 _projectId\\n    )\\n        external\\n        view\\n        returns (\\n            bool isConfigured,\\n            uint256 tokenPriceInWei,\\n            string memory currencySymbol,\\n            address currencyAddress\\n        );\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/v0.8.x/IFilteredMinterV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\n// Created By: Art Blocks Inc.\\n\\nimport \\\"./IFilteredMinterV0.sol\\\";\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title This interface extends the IFilteredMinterV0 interface in order to\\n * add support for generic project minter configuration updates.\\n * @dev keys represent strings of finite length encoded in bytes32 to minimize\\n * gas.\\n * @author Art Blocks Inc.\\n */\\ninterface IFilteredMinterV1 is IFilteredMinterV0 {\\n    /// ANY\\n    /**\\n     * @notice Generic project minter configuration event. Removes key `_key`\\n     * for project `_projectId`.\\n     */\\n    event ConfigKeyRemoved(uint256 indexed _projectId, bytes32 _key);\\n\\n    /// BOOL\\n    /**\\n     * @notice Generic project minter configuration event. Sets value of key\\n     * `_key` to `_value` for project `_projectId`.\\n     */\\n    event ConfigValueSet(uint256 indexed _projectId, bytes32 _key, bool _value);\\n\\n    /// UINT256\\n    /**\\n     * @notice Generic project minter configuration event. Sets value of key\\n     * `_key` to `_value` for project `_projectId`.\\n     */\\n    event ConfigValueSet(\\n        uint256 indexed _projectId,\\n        bytes32 _key,\\n        uint256 _value\\n    );\\n\\n    /**\\n     * @notice Generic project minter configuration event. Adds value `_value`\\n     * to the set of uint256 at key `_key` for project `_projectId`.\\n     */\\n    event ConfigValueAddedToSet(\\n        uint256 indexed _projectId,\\n        bytes32 _key,\\n        uint256 _value\\n    );\\n\\n    /**\\n     * @notice Generic project minter configuration event. Removes value\\n     * `_value` to the set of uint256 at key `_key` for project `_projectId`.\\n     */\\n    event ConfigValueRemovedFromSet(\\n        uint256 indexed _projectId,\\n        bytes32 _key,\\n        uint256 _value\\n    );\\n\\n    /// ADDRESS\\n    /**\\n     * @notice Generic project minter configuration event. Sets value of key\\n     * `_key` to `_value` for project `_projectId`.\\n     */\\n    event ConfigValueSet(\\n        uint256 indexed _projectId,\\n        bytes32 _key,\\n        address _value\\n    );\\n\\n    /**\\n     * @notice Generic project minter configuration event. Adds value `_value`\\n     * to the set of addresses at key `_key` for project `_projectId`.\\n     */\\n    event ConfigValueAddedToSet(\\n        uint256 indexed _projectId,\\n        bytes32 _key,\\n        address _value\\n    );\\n\\n    /**\\n     * @notice Generic project minter configuration event. Removes value\\n     * `_value` to the set of addresses at key `_key` for project `_projectId`.\\n     */\\n    event ConfigValueRemovedFromSet(\\n        uint256 indexed _projectId,\\n        bytes32 _key,\\n        address _value\\n    );\\n\\n    /// BYTES32\\n    /**\\n     * @notice Generic project minter configuration event. Sets value of key\\n     * `_key` to `_value` for project `_projectId`.\\n     */\\n    event ConfigValueSet(\\n        uint256 indexed _projectId,\\n        bytes32 _key,\\n        bytes32 _value\\n    );\\n\\n    /**\\n     * @notice Generic project minter configuration event. Adds value `_value`\\n     * to the set of bytes32 at key `_key` for project `_projectId`.\\n     */\\n    event ConfigValueAddedToSet(\\n        uint256 indexed _projectId,\\n        bytes32 _key,\\n        bytes32 _value\\n    );\\n\\n    /**\\n     * @notice Generic project minter configuration event. Removes value\\n     * `_value` to the set of bytes32 at key `_key` for project `_projectId`.\\n     */\\n    event ConfigValueRemovedFromSet(\\n        uint256 indexed _projectId,\\n        bytes32 _key,\\n        bytes32 _value\\n    );\\n\\n    /**\\n     * @dev Strings not supported. Recommend conversion of (short) strings to\\n     * bytes32 to remain gas-efficient.\\n     */\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/v0.8.x/IFilteredMinterV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\n// Created By: Art Blocks Inc.\\n\\nimport \\\"./IFilteredMinterV1.sol\\\";\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title This interface extends the IFilteredMinterV1 interface in order to\\n * add support for manually setting project max invocations.\\n * @author Art Blocks Inc.\\n */\\ninterface IFilteredMinterV2 is IFilteredMinterV1 {\\n    /**\\n     * @notice Local max invocations for project `_projectId`, tied to core contract `_coreContractAddress`,\\n     * updated to `_maxInvocations`.\\n     */\\n    event ProjectMaxInvocationsLimitUpdated(\\n        uint256 indexed _projectId,\\n        uint256 _maxInvocations\\n    );\\n\\n    // Sets the local max invocations for a given project, checking that the provided max invocations is\\n    // less than or equal to the global max invocations for the project set on the core contract.\\n    // This does not impact the max invocations value defined on the core contract.\\n    function manuallyLimitProjectMaxInvocations(\\n        uint256 _projectId,\\n        uint256 _maxInvocations\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/v0.8.x/IGenArt721CoreContractV3_Base.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\n// Created By: Art Blocks Inc.\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IAdminACLV0.sol\\\";\\n/// use the Royalty Registry's IManifold interface for token royalties\\nimport \\\"./IManifold.sol\\\";\\n\\n/**\\n * @title This interface is intended to house interface items that are common\\n * across all GenArt721CoreContractV3 flagship and derivative implementations.\\n * This interface extends the IManifold royalty interface in order to\\n * add support the Royalty Registry by default.\\n * @author Art Blocks Inc.\\n */\\ninterface IGenArt721CoreContractV3_Base is IManifold {\\n    /**\\n     * @notice Token ID `_tokenId` minted to `_to`.\\n     */\\n    event Mint(address indexed _to, uint256 indexed _tokenId);\\n\\n    /**\\n     * @notice currentMinter updated to `_currentMinter`.\\n     * @dev Implemented starting with V3 core\\n     */\\n    event MinterUpdated(address indexed _currentMinter);\\n\\n    /**\\n     * @notice Platform updated on bytes32-encoded field `_field`.\\n     */\\n    event PlatformUpdated(bytes32 indexed _field);\\n\\n    /**\\n     * @notice Project ID `_projectId` updated on bytes32-encoded field\\n     * `_update`.\\n     */\\n    event ProjectUpdated(uint256 indexed _projectId, bytes32 indexed _update);\\n\\n    event ProposedArtistAddressesAndSplits(\\n        uint256 indexed _projectId,\\n        address _artistAddress,\\n        address _additionalPayeePrimarySales,\\n        uint256 _additionalPayeePrimarySalesPercentage,\\n        address _additionalPayeeSecondarySales,\\n        uint256 _additionalPayeeSecondarySalesPercentage\\n    );\\n\\n    event AcceptedArtistAddressesAndSplits(uint256 indexed _projectId);\\n\\n    // version and type of the core contract\\n    // coreVersion is a string of the form \\\"0.x.y\\\"\\n    function coreVersion() external view returns (string memory);\\n\\n    // coreType is a string of the form \\\"GenArt721CoreV3\\\"\\n    function coreType() external view returns (string memory);\\n\\n    // owner (pre-V3 was named admin) of contract\\n    // this is expected to be an Admin ACL contract for V3\\n    function owner() external view returns (address);\\n\\n    // Admin ACL contract for V3, will be at the address owner()\\n    function adminACLContract() external returns (IAdminACLV0);\\n\\n    // backwards-compatible (pre-V3) admin - equal to owner()\\n    function admin() external view returns (address);\\n\\n    /**\\n     * Function determining if _sender is allowed to call function with\\n     * selector _selector on contract `_contract`. Intended to be used with\\n     * peripheral contracts such as minters, as well as internally by the\\n     * core contract itself.\\n     */\\n    function adminACLAllowed(\\n        address _sender,\\n        address _contract,\\n        bytes4 _selector\\n    ) external returns (bool);\\n\\n    /// getter function of public variable\\n    function startingProjectId() external view returns (uint256);\\n\\n    // getter function of public variable\\n    function nextProjectId() external view returns (uint256);\\n\\n    // getter function of public mapping\\n    function tokenIdToProjectId(\\n        uint256 tokenId\\n    ) external view returns (uint256 projectId);\\n\\n    // @dev this is not available in V0\\n    function isMintWhitelisted(address minter) external view returns (bool);\\n\\n    function projectIdToArtistAddress(\\n        uint256 _projectId\\n    ) external view returns (address payable);\\n\\n    function projectIdToAdditionalPayeePrimarySales(\\n        uint256 _projectId\\n    ) external view returns (address payable);\\n\\n    function projectIdToAdditionalPayeePrimarySalesPercentage(\\n        uint256 _projectId\\n    ) external view returns (uint256);\\n\\n    function projectIdToSecondaryMarketRoyaltyPercentage(\\n        uint256 _projectId\\n    ) external view returns (uint256);\\n\\n    function projectURIInfo(\\n        uint256 _projectId\\n    ) external view returns (string memory projectBaseURI);\\n\\n    // @dev new function in V3\\n    function projectStateData(\\n        uint256 _projectId\\n    )\\n        external\\n        view\\n        returns (\\n            uint256 invocations,\\n            uint256 maxInvocations,\\n            bool active,\\n            bool paused,\\n            uint256 completedTimestamp,\\n            bool locked\\n        );\\n\\n    function projectDetails(\\n        uint256 _projectId\\n    )\\n        external\\n        view\\n        returns (\\n            string memory projectName,\\n            string memory artist,\\n            string memory description,\\n            string memory website,\\n            string memory license\\n        );\\n\\n    function projectScriptDetails(\\n        uint256 _projectId\\n    )\\n        external\\n        view\\n        returns (\\n            string memory scriptTypeAndVersion,\\n            string memory aspectRatio,\\n            uint256 scriptCount\\n        );\\n\\n    function projectScriptByIndex(\\n        uint256 _projectId,\\n        uint256 _index\\n    ) external view returns (string memory);\\n\\n    function tokenIdToHash(uint256 _tokenId) external view returns (bytes32);\\n\\n    // function to set a token's hash (must be guarded)\\n    function setTokenHash_8PT(uint256 _tokenId, bytes32 _hash) external;\\n\\n    // @dev gas-optimized signature in V3 for `mint`\\n    function mint_Ecf(\\n        address _to,\\n        uint256 _projectId,\\n        address _by\\n    ) external returns (uint256 tokenId);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/v0.8.x/IGenArt721CoreContractV3_Engine.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\n// Created By: Art Blocks Inc.\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IAdminACLV0.sol\\\";\\nimport \\\"./IGenArt721CoreContractV3_Base.sol\\\";\\n\\ninterface IGenArt721CoreContractV3_Engine is IGenArt721CoreContractV3_Base {\\n    // @dev new function in V3\\n    function getPrimaryRevenueSplits(\\n        uint256 _projectId,\\n        uint256 _price\\n    )\\n        external\\n        view\\n        returns (\\n            uint256 renderProviderRevenue_,\\n            address payable renderProviderAddress_,\\n            uint256 platformProviderRevenue_,\\n            address payable platformProviderAddress_,\\n            uint256 artistRevenue_,\\n            address payable artistAddress_,\\n            uint256 additionalPayeePrimaryRevenue_,\\n            address payable additionalPayeePrimaryAddress_\\n        );\\n\\n    // @dev The render provider primary sales payment address\\n    function renderProviderPrimarySalesAddress()\\n        external\\n        view\\n        returns (address payable);\\n\\n    // @dev The platform provider primary sales payment address\\n    function platformProviderPrimarySalesAddress()\\n        external\\n        view\\n        returns (address payable);\\n\\n    // @dev Percentage of primary sales allocated to the render provider\\n    function renderProviderPrimarySalesPercentage()\\n        external\\n        view\\n        returns (uint256);\\n\\n    // @dev Percentage of primary sales allocated to the platform provider\\n    function platformProviderPrimarySalesPercentage()\\n        external\\n        view\\n        returns (uint256);\\n\\n    // @dev The render provider secondary sales royalties payment address\\n    function renderProviderSecondarySalesAddress()\\n        external\\n        view\\n        returns (address payable);\\n\\n    // @dev The platform provider secondary sales royalties payment address\\n    function platformProviderSecondarySalesAddress()\\n        external\\n        view\\n        returns (address payable);\\n\\n    // @dev Basis points of secondary sales allocated to the render provider\\n    function renderProviderSecondarySalesBPS() external view returns (uint256);\\n\\n    // @dev Basis points of secondary sales allocated to the platform provider\\n    function platformProviderSecondarySalesBPS()\\n        external\\n        view\\n        returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/v0.8.x/IGenArt721CoreContractV3.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\n// Created By: Art Blocks Inc.\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IAdminACLV0.sol\\\";\\nimport \\\"./IGenArt721CoreContractV3_Base.sol\\\";\\n\\n/**\\n * @title This interface extends IGenArt721CoreContractV3_Base with functions\\n * that are part of the Art Blocks Flagship core contract.\\n * @author Art Blocks Inc.\\n */\\n// This interface extends IGenArt721CoreContractV3_Base with functions that are\\n// in part of the Art Blocks Flagship core contract.\\ninterface IGenArt721CoreContractV3 is IGenArt721CoreContractV3_Base {\\n    // @dev new function in V3\\n    function getPrimaryRevenueSplits(\\n        uint256 _projectId,\\n        uint256 _price\\n    )\\n        external\\n        view\\n        returns (\\n            uint256 artblocksRevenue_,\\n            address payable artblocksAddress_,\\n            uint256 artistRevenue_,\\n            address payable artistAddress_,\\n            uint256 additionalPayeePrimaryRevenue_,\\n            address payable additionalPayeePrimaryAddress_\\n        );\\n\\n    // @dev Art Blocks primary sales payment address\\n    function artblocksPrimarySalesAddress()\\n        external\\n        view\\n        returns (address payable);\\n\\n    /**\\n     * @notice Backwards-compatible (pre-V3) function returning Art Blocks\\n     * primary sales payment address (now called artblocksPrimarySalesAddress).\\n     */\\n    function artblocksAddress() external view returns (address payable);\\n\\n    // @dev Percentage of primary sales allocated to Art Blocks\\n    function artblocksPrimarySalesPercentage() external view returns (uint256);\\n\\n    /**\\n     * @notice Backwards-compatible (pre-V3) function returning Art Blocks\\n     * primary sales percentage (now called artblocksPrimarySalesPercentage).\\n     */\\n    function artblocksPercentage() external view returns (uint256);\\n\\n    // @dev Art Blocks secondary sales royalties payment address\\n    function artblocksSecondarySalesAddress()\\n        external\\n        view\\n        returns (address payable);\\n\\n    // @dev Basis points of secondary sales allocated to Art Blocks\\n    function artblocksSecondarySalesBPS() external view returns (uint256);\\n\\n    /**\\n     * @notice Backwards-compatible (pre-V3) function  that gets artist +\\n     * artist's additional payee royalty data for token ID `_tokenId`.\\n     * WARNING: Does not include Art Blocks portion of royalties.\\n     */\\n    function getRoyaltyData(\\n        uint256 _tokenId\\n    )\\n        external\\n        view\\n        returns (\\n            address artistAddress,\\n            address additionalPayee,\\n            uint256 additionalPayeePercentage,\\n            uint256 royaltyFeeByID\\n        );\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/v0.8.x/IManifold.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/// @dev Royalty Registry interface, used to support the Royalty Registry.\\n/// @dev Source: https://github.com/manifoldxyz/royalty-registry-solidity/blob/main/contracts/specs/IManifold.sol\\n\\n/// @author: manifold.xyz\\n\\n/**\\n * @dev Royalty interface for creator core classes\\n */\\ninterface IManifold {\\n    /**\\n     * @dev Get royalites of a token.  Returns list of receivers and basisPoints\\n     *\\n     *  bytes4(keccak256('getRoyalties(uint256)')) == 0xbb3bafd6\\n     *\\n     *  => 0xbb3bafd6 = 0xbb3bafd6\\n     */\\n    function getRoyalties(\\n        uint256 tokenId\\n    ) external view returns (address payable[] memory, uint256[] memory);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/v0.8.x/IMinterBaseV0.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\n// Created By: Art Blocks Inc.\\n\\nimport \\\"./IFilteredMinterV2.sol\\\";\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title This interface defines any events or functions required for a minter\\n * to conform to the MinterBase contract.\\n * @dev The MinterBase contract was not implemented from the beginning of the\\n * MinterSuite contract suite, therefore early versions of some minters may not\\n * conform to this interface.\\n * @author Art Blocks Inc.\\n */\\ninterface IMinterBaseV0 {\\n    // Function that returns if a minter is configured to integrate with a V3 flagship or V3 engine contract.\\n    // Returns true only if the minter is configured to integrate with an engine contract.\\n    function isEngine() external returns (bool isEngine);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/v0.8.x/IMinterFilterV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\n// Created By: Art Blocks Inc.\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ICoreRegistryV1.sol\\\";\\nimport \\\"./IAdminACLV0.sol\\\";\\n\\n/**\\n * @title IMinterFilterV1\\n * @author Art Blocks Inc.\\n * @notice Interface for a new minter filter contract.\\n * This interface does not extend the previous version of the minter filter\\n * interface, as the previous version is not compatible with the new\\n * minter filter architecture.\\n * @dev This interface is for a minter filter that supports multiple core\\n * contracts, and allows for a minter to be set on a per-project basis.\\n */\\ninterface IMinterFilterV1 {\\n    /**\\n     * @notice Emitted when contract is deployed to notify indexing services\\n     * of the new contract deployment.\\n     */\\n    event Deployed();\\n\\n    /**\\n     * @notice Globally approved minter `minter`.\\n     */\\n    event MinterApprovedGlobally(address indexed minter, string minterType);\\n\\n    /**\\n     * @notice Globally revoked minter `minter`.\\n     * @dev contract owner may still approve this minter on a per-contract\\n     * basis.\\n     */\\n    event MinterRevokedGlobally(address indexed minter);\\n\\n    /**\\n     * @notice Approved minter `minter` on core contract\\n     * `coreContract`.\\n     */\\n    event MinterApprovedForContract(\\n        address indexed coreContract,\\n        address indexed minter,\\n        string minterType\\n    );\\n\\n    /**\\n     * @notice Revoked minter `minter` on core contract `coreContract`.\\n     * @dev minter filter owner may still globally approve this minter for all\\n     * contracts.\\n     */\\n    event MinterRevokedForContract(\\n        address indexed coreContract,\\n        address indexed minter\\n    );\\n\\n    /**\\n     * @notice Minter at address `minter` set as minter for project\\n     * `projectId` on core contract `coreContract`.\\n     */\\n    event ProjectMinterRegistered(\\n        uint256 indexed projectId,\\n        address indexed coreContract,\\n        address indexed minter,\\n        string minterType\\n    );\\n\\n    /**\\n     * @notice Minter removed for project `projectId` on core contract\\n     * `coreContract`.\\n     */\\n    event ProjectMinterRemoved(\\n        uint256 indexed projectId,\\n        address indexed coreContract\\n    );\\n\\n    /**\\n     * @notice Admin ACL contract updated to `adminACLContract`.\\n     */\\n    event AdminACLUpdated(address indexed adminACLContract);\\n\\n    /**\\n     * @notice Core Registry contract updated to `coreRegistry`.\\n     */\\n    event CoreRegistryUpdated(address indexed coreRegistry);\\n\\n    // struct used to return minter info\\n    // @dev this is not used for storage of data\\n    struct MinterWithType {\\n        address minterAddress;\\n        string minterType;\\n    }\\n\\n    function setMinterForProject(\\n        uint256 projectId,\\n        address coreContract,\\n        address minter\\n    ) external;\\n\\n    function removeMinterForProject(\\n        uint256 projectId,\\n        address coreContract\\n    ) external;\\n\\n    // @dev function name is optimized for gas\\n    function mint_joo(\\n        address to,\\n        uint256 projectId,\\n        address coreContract,\\n        address sender\\n    ) external returns (uint256);\\n\\n    function updateCoreRegistry(address coreRegistry) external;\\n\\n    /**\\n     * @notice Returns if `sender` is allowed to call function on `contract`\\n     * with `selector` selector, according to the MinterFilter's Admin ACL.\\n     */\\n    function adminACLAllowed(\\n        address sender,\\n        address contract_,\\n        bytes4 selector\\n    ) external returns (bool);\\n\\n    function minterFilterType() external pure returns (string memory);\\n\\n    function getMinterForProject(\\n        uint256 projectId,\\n        address coreContract\\n    ) external view returns (address);\\n\\n    function projectHasMinter(\\n        uint256 projectId,\\n        address coreContract\\n    ) external view returns (bool);\\n\\n    /**\\n     * @notice View that returns if a core contract is registered with the\\n     * core registry, allowing this minter filter to service it.\\n     * @param coreContract core contract address to be checked\\n     */\\n    function isRegisteredCoreContract(\\n        address coreContract\\n    ) external view returns (bool);\\n\\n    /// Address of current core registry contract\\n    function coreRegistry() external view returns (ICoreRegistryV1);\\n\\n    /// The current admin ACL contract\\n    function adminACLContract() external view returns (IAdminACLV0);\\n\\n    /// The quantity of projects on a core contract that have assigned minters\\n    function getNumProjectsOnContractWithMinters(\\n        address coreContract\\n    ) external view returns (uint256);\\n\\n    function getProjectAndMinterInfoOnContractAt(\\n        address coreContract,\\n        uint256 index\\n    )\\n        external\\n        view\\n        returns (\\n            uint256 projectId,\\n            address minterAddress,\\n            string memory minterType\\n        );\\n\\n    function getAllGloballyApprovedMinters()\\n        external\\n        view\\n        returns (MinterWithType[] memory mintersWithTypes);\\n\\n    function getAllContractApprovedMinters(\\n        address coreContract\\n    ) external view returns (MinterWithType[] memory mintersWithTypes);\\n\\n    /**\\n     * Owner of contract.\\n     * @dev This returns the address of the Admin ACL contract.\\n     */\\n    function owner() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/v0.8.x/ISharedMinterDAExpSettlementV0.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\n// Created By: Art Blocks Inc.\\n\\npragma solidity ^0.8.0;\\nimport \\\"./ISharedMinterDAExpV0.sol\\\";\\n\\ninterface ISharedMinterDAExpSettlementV0 is ISharedMinterDAExpV0 {\\n    /// returns latest purchase price for project `projectId`, or 0 if no\\n    /// purchases have been made.\\n    function getProjectLatestPurchasePrice(\\n        uint256 projectId,\\n        address coreContract\\n    ) external view returns (uint256 latestPurchasePrice);\\n\\n    /// returns the number of settleable invocations for project `projectId`.\\n    function getNumSettleableInvocations(\\n        uint256 projectId,\\n        address coreContract\\n    ) external view returns (uint256 numSettleableInvocations);\\n\\n    /// Returns the current excess settlement funds on project `projectId`\\n    /// for address `walletAddress`.\\n    function getProjectExcessSettlementFunds(\\n        uint256 projectId,\\n        address coreContract,\\n        address walletAddress\\n    ) external view returns (uint256 excessSettlementFundsInWei);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/v0.8.x/ISharedMinterDAExpV0.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\n// Created By: Art Blocks Inc.\\n\\npragma solidity ^0.8.0;\\n\\ninterface ISharedMinterDAExpV0 {\\n    function minimumPriceDecayHalfLifeSeconds() external view returns (uint256);\\n\\n    function setMinimumPriceDecayHalfLifeSeconds(\\n        uint256 minimumPriceDecayHalfLifeSeconds\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/v0.8.x/ISharedMinterDAV0.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\n// Created By: Art Blocks Inc.\\n\\npragma solidity ^0.8.0;\\n\\ninterface ISharedMinterDAV0 {\\n    // @dev return variables left unnamed because specific minter\\n    // implementations may return different values for the same slots\\n    function projectAuctionParameters(\\n        uint256 projectId,\\n        address coreContract\\n    ) external view returns (uint40, uint40, uint256, uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/v0.8.x/ISharedMinterSimplePurchaseV0.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\n// Created By: Art Blocks Inc.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Art Blocks Shared Minter Simple Purchase Interface\\n * @notice This interface is designed to be used by minter contracts that\\n * implement a simple purchase model, such that the only args required to\\n * purchase a token are the project id and the core contract address, and an\\n * optional recipient address.\\n */\\ninterface ISharedMinterSimplePurchaseV0 {\\n    // Triggers a purchase of a token from the desired project, to the\\n    // TX-sending address.\\n    function purchase(\\n        uint256 projectId,\\n        address coreContract\\n    ) external payable returns (uint256 tokenId);\\n\\n    // Triggers a purchase of a token from the desired project, to the specified\\n    // receiving address.\\n    function purchaseTo(\\n        address to,\\n        uint256 projectId,\\n        address coreContract\\n    ) external payable returns (uint256 tokenId);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/v0.8.x/ISharedMinterV0.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\n// Created By: Art Blocks Inc.\\n\\npragma solidity ^0.8.0;\\n\\ninterface ISharedMinterV0 {\\n    // Sets the local max invocations for a given project, checking that the provided max invocations is\\n    // less than or equal to the global max invocations for the project set on the core contract.\\n    // This does not impact the max invocations value defined on the core contract.\\n    function manuallyLimitProjectMaxInvocations(\\n        uint256 projectId,\\n        address coreContract,\\n        uint24 maxInvocations\\n    ) external;\\n\\n    // Called to make the minter contract aware of the max invocations for a\\n    // given project.\\n    function syncProjectMaxInvocationsToCore(\\n        uint256 projectId,\\n        address coreContract\\n    ) external;\\n\\n    // getter function of public variable\\n    function minterType() external view returns (string memory);\\n\\n    function minterFilterAddress() external returns (address);\\n\\n    // Gets if token price is configured, token price in wei, currency symbol,\\n    // and currency address, assuming this is project's minter.\\n    // Supersedes any defined core price.\\n    function getPriceInfo(\\n        uint256 projectId,\\n        address coreContract\\n    )\\n        external\\n        view\\n        returns (\\n            bool isConfigured,\\n            uint256 tokenPriceInWei,\\n            string memory currencySymbol,\\n            address currencyAddress\\n        );\\n}\\n\"\r\n    },\r\n    \"contracts/libs/v0.8.x/ABHelpers.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\n// Created By: Art Blocks Inc.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Art Blocks Helpers Library\\n * @notice This library contains helper functions for common operations in the\\n * Art Blocks ecosystem of smart contracts.\\n * @author Art Blocks Inc.\\n */\\n\\nlibrary ABHelpers {\\n    uint256 constant ONE_MILLION = 1_000_000;\\n\\n    /**\\n     * @notice Function to convert token id to project id.\\n     * @param tokenId The id of the token.\\n     */\\n    function tokenIdToProjectId(\\n        uint256 tokenId\\n    ) internal pure returns (uint256) {\\n        // int division properly rounds down\\n        // @dev unchecked because will never divide by zero\\n        unchecked {\\n            return tokenId / ONE_MILLION;\\n        }\\n    }\\n\\n    /**\\n     * @notice Function to convert token id to token number.\\n     * @param tokenId The id of the token.\\n     */\\n    function tokenIdToTokenNumber(\\n        uint256 tokenId\\n    ) internal pure returns (uint256) {\\n        // mod returns remainder, which is the token number\\n        // @dev no way to disable mod zero check in solidity, so not unchecked\\n        return tokenId % ONE_MILLION;\\n    }\\n\\n    /**\\n     * @notice Function to convert token id to token invocation.\\n     * @dev token invocation is the token number plus one, because token #0 is\\n     * invocation 1.\\n     * @param tokenId The id of the token.\\n     */\\n    function tokenIdToTokenInvocation(\\n        uint256 tokenId\\n    ) internal pure returns (uint256) {\\n        // mod returns remainder, which is the token number\\n        // @dev no way to disable mod zero check in solidity, so not unchecked\\n        return (tokenId % ONE_MILLION) + 1;\\n    }\\n\\n    /**\\n     * @notice Function to convert project id and token number to token id.\\n     * @param projectId The id of the project.\\n     * @param tokenNumber The token number.\\n     */\\n    function tokenIdFromProjectIdAndTokenNumber(\\n        uint256 projectId,\\n        uint256 tokenNumber\\n    ) internal pure returns (uint256) {\\n        // @dev intentionally not unchecked to ensure overflow detection, which\\n        // would likley only occur in a malicious call\\n        return (projectId * ONE_MILLION) + tokenNumber;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libs/v0.8.x/AuthLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\n// Created By: Art Blocks Inc.\\n\\npragma solidity ^0.8.0;\\n\\nimport {IGenArt721CoreContractV3_Base} from \\\"../../interfaces/v0.8.x/IGenArt721CoreContractV3_Base.sol\\\";\\nimport {IMinterFilterV1} from \\\"../../interfaces/v0.8.x/IMinterFilterV1.sol\\\";\\n\\n/**\\n * @title Art Blocks Authorization Minter Library\\n * @notice This library contains helper functions that may be used contracts to\\n * check authorization for performing operations in the Art Blocks V3 core\\n * contract ecosystem.\\n * @author Art Blocks Inc.\\n */\\n\\nlibrary AuthLib {\\n    /**\\n     * @notice Function to restrict access to only AdminACL allowed calls, where\\n     * AdminACL is the admin of an IMinterFilterV1.\\n     * Reverts if not allowed.\\n     * @param minterFilterAddress address of the minter filter to be checked,\\n     * should implement IMinterFilterV1\\n     * @param sender address of the caller\\n     * @param contract_ address of the contract being called\\n     * @param selector selector of the function being called\\n     */\\n    function onlyMinterFilterAdminACL(\\n        address minterFilterAddress,\\n        address sender,\\n        address contract_,\\n        bytes4 selector\\n    ) internal {\\n        require(\\n            _minterFilterAdminACLAllowed({\\n                minterFilterAddress: minterFilterAddress,\\n                sender: sender,\\n                contract_: contract_,\\n                selector: selector\\n            }),\\n            \\\"Only MinterFilter AdminACL\\\"\\n        );\\n    }\\n\\n    /**\\n     * @notice Function to restrict access to only AdminACL allowed calls, where\\n     * AdminACL is the admin of a core contract at `coreContract`.\\n     * Reverts if not allowed.\\n     * @param coreContract address of the core contract to be checked\\n     * @param sender address of the caller\\n     * @param contract_ address of the contract being called\\n     * @param selector selector of the function being called\\n     */\\n    function onlyCoreAdminACL(\\n        address coreContract,\\n        address sender,\\n        address contract_,\\n        bytes4 selector\\n    ) internal {\\n        require(\\n            _coreAdminACLAllowed({\\n                coreContract: coreContract,\\n                sender: sender,\\n                contract_: contract_,\\n                selector: selector\\n            }),\\n            \\\"Only Core AdminACL allowed\\\"\\n        );\\n    }\\n\\n    /**\\n     * @notice Throws if `sender` is any account other than the artist of the\\n     * specified project `projectId` on core contract `coreContract`.\\n     * @param projectId The ID of the project being checked.\\n     * @param coreContract The address of the GenArt721CoreContractV3_Base\\n     * contract.\\n     * @param sender Wallet to check. Typically, the address of the caller.\\n     * @dev `sender` must be the artist associated with `projectId` on `coreContract`.\\n     */\\n    function onlyArtist(\\n        uint256 projectId,\\n        address coreContract,\\n        address sender\\n    ) internal view {\\n        require(\\n            _senderIsArtist({\\n                projectId: projectId,\\n                coreContract: coreContract,\\n                sender: sender\\n            }),\\n            \\\"Only Artist\\\"\\n        );\\n    }\\n\\n    /**\\n     * @notice Function to restrict access to only the artist of a project, or AdminACL\\n     * allowed calls, where AdminACL is the admin of a core contract at\\n     * `coreContract`.\\n     * @param projectId id of the project\\n     * @param coreContract address of the core contract to be checked\\n     * @param sender address of the caller\\n     * @param contract_ address of the contract being called\\n     * @param selector selector of the function being called\\n     */\\n    function onlyCoreAdminACLOrArtist(\\n        uint256 projectId,\\n        address coreContract,\\n        address sender,\\n        address contract_,\\n        bytes4 selector\\n    ) internal {\\n        require(\\n            _senderIsArtist({\\n                projectId: projectId,\\n                coreContract: coreContract,\\n                sender: sender\\n            }) ||\\n                _coreAdminACLAllowed({\\n                    coreContract: coreContract,\\n                    sender: sender,\\n                    contract_: contract_,\\n                    selector: selector\\n                }),\\n            \\\"Only Artist or Core Admin ACL\\\"\\n        );\\n    }\\n\\n    // ------------------------------------------------------------------------\\n    // Private functions used internally by this library\\n    // ------------------------------------------------------------------------\\n\\n    /**\\n     * @notice Private function that returns if minter filter contract's AdminACL\\n     * allows `sender` to call function with selector `selector` on contract\\n     * `contract`.\\n     * @param minterFilterAddress address of the minter filter to be checked.\\n     * Should implement IMinterFilterV1.\\n     * @param sender address of the caller\\n     * @param contract_ address of the contract being called\\n     * @param selector selector of the function being called\\n     */\\n    function _minterFilterAdminACLAllowed(\\n        address minterFilterAddress,\\n        address sender,\\n        address contract_,\\n        bytes4 selector\\n    ) private returns (bool) {\\n        return\\n            IMinterFilterV1(minterFilterAddress).adminACLAllowed({\\n                sender: sender,\\n                contract_: contract_,\\n                selector: selector\\n            });\\n    }\\n\\n    /**\\n     * @notice Private function that returns if core contract's AdminACL allows\\n     * `sender` to call function with selector `selector` on contract\\n     * `contract`.\\n     * @param coreContract address of the core contract to be checked\\n     * @param sender address of the caller\\n     * @param contract_ address of the contract being called\\n     * @param selector selector of the function being called\\n     */\\n    function _coreAdminACLAllowed(\\n        address coreContract,\\n        address sender,\\n        address contract_,\\n        bytes4 selector\\n    ) private returns (bool) {\\n        return\\n            IGenArt721CoreContractV3_Base(coreContract).adminACLAllowed({\\n                _sender: sender,\\n                _contract: contract_,\\n                _selector: selector\\n            });\\n    }\\n\\n    /**\\n     * @notice Private function that returns if `sender` is the artist of `projectId`\\n     * on `coreContract`.\\n     * @param projectId project ID to check\\n     * @param coreContract core contract to check\\n     * @param sender wallet to check\\n     */\\n    function _senderIsArtist(\\n        uint256 projectId,\\n        address coreContract,\\n        address sender\\n    ) private view returns (bool senderIsArtist) {\\n        return\\n            sender ==\\n            IGenArt721CoreContractV3_Base(coreContract)\\n                .projectIdToArtistAddress(projectId);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libs/v0.8.x/minter-libs/DAExpLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\n// Created By: Art Blocks Inc.\\n\\npragma solidity ^0.8.0;\\n\\nimport {DALib} from \\\"./DALib.sol\\\";\\n\\n/**\\n * @title Art Blocks Dutch Auction (exponential price curve) Library\\n * @notice This library is designed to implement logic and checks for Art\\n * Blocks projects using an exponential Dutch auctionprice curve for minting\\n * tokens.\\n * @author Art Blocks Inc.\\n */\\n\\nlibrary DAExpLib {\\n    /**\\n     * @notice Auction details set for project `projectId` on core contract\\n     * `coreContract`.\\n     * @param projectId Project Id for which auction details were set\\n     * @param coreContract Core contract address for which auction details were\\n     * set\\n     * @param auctionTimestampStart Timestamp when auction will start\\n     * @param priceDecayHalfLifeSeconds Half life of price decay, in seconds\\n     * @param startPrice Start price of auction\\n     * @param basePrice Base price of auction (end price)\\n     */\\n    event SetAuctionDetailsExp(\\n        uint256 indexed projectId,\\n        address indexed coreContract,\\n        uint40 auctionTimestampStart,\\n        uint40 priceDecayHalfLifeSeconds,\\n        uint256 startPrice,\\n        uint256 basePrice\\n    );\\n\\n    /**\\n     * @notice Minimum allowed price decay half life on the minter updated to\\n     * `minimumPriceDecayHalfLifeSeconds`.\\n     * @param minimumPriceDecayHalfLifeSeconds minimum price decay half life\\n     * for new auctions, in seconds\\n     */\\n    event AuctionMinHalfLifeSecondsUpdated(\\n        uint256 minimumPriceDecayHalfLifeSeconds\\n    );\\n\\n    // position of DA Exp Lib storage, using a diamond storage pattern\\n    // for this library\\n    bytes32 constant DAE_EXP_LIB_STORAGE_POSITION =\\n        keccak256(\\\"daexplib.storage\\\");\\n\\n    struct DAProjectConfig {\\n        // @dev max uint40 ~= 1.1e12 sec ~= 34 thousand years\\n        uint40 timestampStart;\\n        uint40 priceDecayHalfLifeSeconds;\\n        // @dev max uint88 ~= 3e26 Wei = ~300 million ETH, which is well above\\n        // the expected prices of any NFT mint in the foreseeable future.\\n        uint88 startPrice;\\n        uint88 basePrice;\\n    }\\n\\n    // Diamond storage pattern is used in this library\\n    struct DAExpLibStorage {\\n        mapping(address coreContract => mapping(uint256 projectId => DAProjectConfig)) DAProjectConfigs_;\\n    }\\n\\n    /**\\n     * @notice Sets auction details for an exponential-price auction type.\\n     * @dev The function sets the auction start timestamp, price decay\\n     * half-life, starting, and base prices for an exponential-price auction.\\n     * @dev Minter implementations should ensure that any additional guard-\\n     * rails are properly checked outside of this function. For example, the\\n     * minter should check that _priceDecayHalfLifeSeconds is greater than the\\n     * minter's minimum allowable value for price decay half-life (if the\\n     * minter chooses to include that guard-rail).\\n     * @param projectId The project Id to set auction details for.\\n     * @param coreContract The core contract address to set auction details.\\n     * @param auctionTimestampStart The timestamp when the auction will start.\\n     * @param priceDecayHalfLifeSeconds The half-life time for price decay in\\n     * seconds.\\n     * @param startPrice The starting price of the auction.\\n     * @param basePrice The base price of the auction.\\n     * @param allowReconfigureAfterStart Bool indicating whether the auction\\n     * can be reconfigured after it has started. This is sometimes useful for\\n     * minter implementations that want to allow an artist to reconfigure the\\n     * auction after it has reached minter-local max invocations, for example.\\n     */\\n    function setAuctionDetailsExp(\\n        uint256 projectId,\\n        address coreContract,\\n        uint40 auctionTimestampStart,\\n        uint40 priceDecayHalfLifeSeconds,\\n        uint88 startPrice,\\n        uint88 basePrice,\\n        bool allowReconfigureAfterStart\\n    ) internal {\\n        DAProjectConfig storage DAProjectConfig_ = getDAProjectConfig({\\n            projectId: projectId,\\n            coreContract: coreContract\\n        });\\n        require(\\n            DAProjectConfig_.timestampStart == 0 || // uninitialized\\n                block.timestamp < DAProjectConfig_.timestampStart || // auction not yet started\\n                allowReconfigureAfterStart, // specifically allowing reconfiguration after start\\n            \\\"No modifications mid-auction\\\"\\n        );\\n        require(\\n            block.timestamp < auctionTimestampStart,\\n            \\\"Only future auctions\\\"\\n        );\\n        require(\\n            startPrice > basePrice,\\n            \\\"Auction start price must be greater than auction end price\\\"\\n        );\\n        // @dev no coverage, as minter auction min half life may be more\\n        // restrictive than gt 0\\n        require(priceDecayHalfLifeSeconds > 0, \\\"Only half life gt 0\\\");\\n\\n        // EFFECTS\\n        DAProjectConfig_.timestampStart = auctionTimestampStart;\\n        DAProjectConfig_.priceDecayHalfLifeSeconds = priceDecayHalfLifeSeconds;\\n        DAProjectConfig_.startPrice = startPrice;\\n        DAProjectConfig_.basePrice = basePrice;\\n\\n        emit SetAuctionDetailsExp({\\n            projectId: projectId,\\n            coreContract: coreContract,\\n            auctionTimestampStart: auctionTimestampStart,\\n            priceDecayHalfLifeSeconds: priceDecayHalfLifeSeconds,\\n            startPrice: startPrice,\\n            basePrice: basePrice\\n        });\\n    }\\n\\n    function resetAuctionDetails(\\n        uint256 projectId,\\n        address coreContract\\n    ) internal {\\n        // @dev all fields must be deleted, and none of them are a complex type\\n        // @dev getDAProjectConfig not used, as deletion of storage pointers is\\n        // not supported\\n        delete s().DAProjectConfigs_[coreContract][projectId];\\n\\n        emit DALib.ResetAuctionDetails({\\n            projectId: projectId,\\n            coreContract: coreContract\\n        });\\n    }\\n\\n    /**\\n     * @notice Gets price of minting a token given the project's\\n     * DAProjectConfig.\\n     * This function reverts if auction has not yet started, or if auction is\\n     * unconfigured, which is relied upon by certain minter implications for\\n     * security.\\n     * @param projectId Project Id to get price for\\n     * @param coreContract Core contract address to get price for\\n     * @return uint256 current price of token in Wei\\n     */\\n    function getPriceExp(\\n        uint256 projectId,\\n        address coreContract\\n    ) internal view returns (uint256) {\\n        DAProjectConfig storage DAProjectConfig_ = getDAProjectConfig({\\n            projectId: projectId,\\n            coreContract: coreContract\\n        });\\n        // move parameters to memory if used more than once\\n        uint256 timestampStart = DAProjectConfig_.timestampStart;\\n        uint256 priceDecayHalfLifeSeconds = DAProjectConfig_\\n            .priceDecayHalfLifeSeconds;\\n\\n        require(timestampStart > 0, \\\"Only configured auctions\\\");\\n        require(block.timestamp >= timestampStart, \\\"Auction not yet started\\\");\\n        uint256 decayedPrice = DAProjectConfig_.startPrice;\\n        uint256 elapsedTimeSeconds;\\n        unchecked {\\n            // already checked that block.timestamp > _timestampStart above\\n            elapsedTimeSeconds = block.timestamp - timestampStart;\\n        }\\n        // Divide by two (via bit-shifting) for the number of entirely completed\\n        // half-lives that have elapsed since auction start time.\\n        unchecked {\\n            // already required priceDecayHalfLifeSeconds > 0\\n            decayedPrice >>= elapsedTimeSeconds / priceDecayHalfLifeSeconds;\\n        }\\n        // Perform a linear interpolation between partial half-life points, to\\n        // approximate the current place on a perfect exponential decay curve.\\n        unchecked {\\n            // value of expression is provably always less than decayedPrice,\\n            // so no underflow is possible when the subtraction assignment\\n            // operator is used on decayedPrice.\\n            decayedPrice -=\\n                ((decayedPrice *\\n                    (elapsedTimeSeconds % priceDecayHalfLifeSeconds)) /\\n                    priceDecayHalfLifeSeconds) >>\\n                1; // divide by 2 via bitshift 1\\n        }\\n        uint256 basePrice = DAProjectConfig_.basePrice;\\n        if (decayedPrice < basePrice) {\\n            // Price may not decay below stay `basePrice`.\\n            return basePrice;\\n        }\\n        return decayedPrice;\\n    }\\n\\n    /**\\n     * Gets auction base price for project `projectId` on core contract\\n     * `coreContract`.\\n     * @param projectId Project Id to get price for\\n     * @param coreContract Core contract address to get price for\\n     */\\n    function getAuctionBasePrice(\\n        uint256 projectId,\\n        address coreContract\\n    ) internal view returns (uint256) {\\n        return\\n            getDAProjectConfig({\\n                projectId: projectId,\\n                coreContract: coreContract\\n            }).basePrice;\\n    }\\n\\n    /**\\n     * Loads the DAProjectConfig for a given project and core contract.\\n     * @param projectId Project Id to get config for\\n     * @param coreContract Core contract address to get config for\\n     */\\n    function getDAProjectConfig(\\n        uint256 projectId,\\n        address coreContract\\n    ) internal view returns (DAProjectConfig storage) {\\n        return s().DAProjectConfigs_[coreContract][projectId];\\n    }\\n\\n    /**\\n     * @notice Return the storage struct for reading and writing. This library\\n     * uses a diamond storage pattern when managing storage.\\n     * @return storageStruct The DAExpLibStorage struct.\\n     */\\n    function s() internal pure returns (DAExpLibStorage storage storageStruct) {\\n        bytes32 position = DAE_EXP_LIB_STORAGE_POSITION;\\n        assembly (\\\"memory-safe\\\") {\\n            storageStruct.slot := position\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libs/v0.8.x/minter-libs/DALib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\n// Created By: Art Blocks Inc.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Art Blocks Dutch Auction (exponential price curve) Library\\n * @notice This library is designed to implement logic and checks for Art\\n * Blocks projects using an exponential Dutch auctionprice curve for minting\\n * tokens.\\n * @author Art Blocks Inc.\\n */\\n\\nlibrary DALib {\\n    /**\\n     * @notice Auction details cleared for project `projectId` on core contract\\n     * `coreContract`.\\n     * @param projectId Project Id for which auction details were cleared\\n     * @param coreContract Core contract address for which auction details were\\n     * cleared\\n     */\\n    event ResetAuctionDetails(\\n        uint256 indexed projectId,\\n        address indexed coreContract\\n    );\\n}\\n\"\r\n    },\r\n    \"contracts/libs/v0.8.x/minter-libs/GenericMinterEventsLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\n// Created By: Art Blocks Inc.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Art Blocks Generic Events Library\\n * @notice This library is designed to define a set of generic events that all\\n * shared minter libraries may utilize to populate indexed extra minter details\\n * @dev Strings not supported. Recommend conversion of (short) strings to\\n * bytes32 to remain gas-efficient.\\n * @author Art Blocks Inc.\\n */\\nlibrary GenericMinterEventsLib {\\n    /**\\n     * @notice Generic project minter configuration event. Removes key `key`\\n     * for project `projectId`.\\n     * @param projectId Project ID to remove key for\\n     * @param coreContract Core contract address that projectId is on\\n     * @param key Key to remove\\n     */\\n    event ConfigKeyRemoved(\\n        uint256 indexed projectId,\\n        address indexed coreContract,\\n        bytes32 key\\n    );\\n    /// BOOL\\n    /**\\n     * @notice Generic project minter configuration event. Sets value of key\\n     * `key` to `value` for project `projectId`.\\n     * @param projectId Project ID to set key for\\n     * @param coreContract Core contract address that projectId is on\\n     * @param key Key to set\\n     * @param value Value to set key to\\n     */\\n    event ConfigValueSet(\\n        uint256 indexed projectId,\\n        address indexed coreContract,\\n        bytes32 key,\\n        bool value\\n    );\\n    /// UINT256\\n    /**\\n     * @notice Generic project minter configuration event. Sets value of key\\n     * `key` to `value` for project `projectId`.\\n     * @param projectId Project ID to set key for\\n     * @param coreContract Core contract address that projectId is on\\n     * @param key Key to set\\n     * @param value Value to set key to\\n     */\\n    event ConfigValueSet(\\n        uint256 indexed projectId,\\n        address indexed coreContract,\\n        bytes32 key,\\n        uint256 value\\n    );\\n    /**\\n     * @notice Generic project minter configuration event. Adds value `value`\\n     * to the set of uint256 at key `key` for project `projectId`.\\n     * @param projectId Project ID to set key for\\n     * @param coreContract Core contract address that projectId is on\\n     * @param key Key to modify\\n     * @param value Value to add to the key's set\\n     */\\n    event ConfigValueAddedToSet(\\n        uint256 indexed projectId,\\n        address indexed coreContract,\\n        bytes32 key,\\n        uint256 value\\n    );\\n    /**\\n     * @notice Generic project minter configuration event. Removes value\\n     * `value` to the set of uint256 at key `key` for project `projectId`.\\n     * @param projectId Project ID to set key for\\n     * @param coreContract Core contract address that projectId is on\\n     * @param key Key to modify\\n     * @param value Value removed from the key's set\\n     */\\n    event ConfigValueRemovedFromSet(\\n        uint256 indexed projectId,\\n        address indexed coreContract,\\n        bytes32 key,\\n        uint256 value\\n    );\\n    /// ADDRESS\\n    /**\\n     * @notice Generic project minter configuration event. Sets value of key\\n     * `key` to `value` for project `projectId`.\\n     * @param projectId Project ID to set key for\\n     * @param coreContract Core contract address that projectId is on\\n     * @param key Key to set\\n     * @param value Value to set key to\\n     */\\n    event ConfigValueSet(\\n        uint256 indexed projectId,\\n        address indexed coreContract,\\n        bytes32 key,\\n        address value\\n    );\\n    /**\\n     * @notice Generic project minter configuration event. Adds value `value`\\n     * to the set of addresses at key `key` for project `projectId`.\\n     * @param projectId Project ID to set key for\\n     * @param coreContract Core contract address that projectId is on\\n     * @param key Key to modify\\n     * @param value Value to add to the key's set\\n     */\\n    event ConfigValueAddedToSet(\\n        uint256 indexed projectId,\\n        address indexed coreContract,\\n        bytes32 key,\\n        address value\\n    );\\n    /**\\n     * @notice Generic project minter configuration event. Removes value\\n     * `value` to the set of addresses at key `key` for project `projectId`.\\n     * @param projectId Project ID to set key for\\n     * @param coreContract Core contract address that projectId is on\\n     * @param key Key to modify\\n     * @param value Value removed from the key's set\\n     */\\n    event ConfigValueRemovedFromSet(\\n        uint256 indexed projectId,\\n        address indexed coreContract,\\n        bytes32 key,\\n        address value\\n    );\\n    /// BYTES32\\n    /**\\n     * @notice Generic project minter configuration event. Sets value of key\\n     * `key` to `value` for project `projectId`.\\n     * @param projectId Project ID to set key for\\n     * @param coreContract Core contract address that projectId is on\\n     * @param key Key to set\\n     * @param value Value to set key to\\n     */\\n    event ConfigValueSet(\\n        uint256 indexed projectId,\\n        address indexed coreContract,\\n        bytes32 key,\\n        bytes32 value\\n    );\\n    /**\\n     * @notice Generic project minter configuration event. Adds value `value`\\n     * to the set of bytes32 at key `key` for project `projectId`.\\n     * @param projectId Project ID to set key for\\n     * @param coreContract Core contract address that projectId is on\\n     * @param key Key to modify\\n     * @param value Value to add to the key's set\\n     */\\n    event ConfigValueAddedToSet(\\n        uint256 indexed projectId,\\n        address indexed coreContract,\\n        bytes32 key,\\n        bytes32 value\\n    );\\n    /**\\n     * @notice Generic project minter configuration event. Removes value\\n     * `value` to the set of bytes32 at key `key` for project `projectId`.\\n     * @param projectId Project ID to set key for\\n     * @param coreContract Core contract address that projectId is on\\n     * @param key Key to modify\\n     * @param value Value removed from the key's set\\n     */\\n    event ConfigValueRemovedFromSet(\\n        uint256 indexed projectId,\\n        address indexed coreContract,\\n        bytes32 key,\\n        bytes32 value\\n    );\\n}\\n\"\r\n    },\r\n    \"contracts/libs/v0.8.x/minter-libs/MaxInvocationsLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\n// Created By: Art Blocks Inc.\\n\\npragma solidity ^0.8.0;\\n\\nimport {IGenArt721CoreContractV3_Base} from \\\"../../../interfaces/v0.8.x/IGenArt721CoreContractV3_Base.sol\\\";\\n\\nimport {ABHelpers} from \\\"../ABHelpers.sol\\\";\\n\\nimport {Math} from \\\"@openzeppelin-4.7/contracts/utils/math/Math.sol\\\";\\nimport {SafeCast} from \\\"@openzeppelin-4.7/contracts/utils/math/SafeCast.sol\\\";\\n\\n/**\\n * @title Art Blocks Max Invocations Library\\n * @notice This library manages the maximum invocation limits for Art Blocks\\n * projects. It provides functionality for synchronizing, manually limiting, and\\n * updating these limits, ensuring the integrity in relation to the core Art\\n * Blocks contract, and managing updates upon token minting.\\n * @dev Functions include `syncProjectMaxInvocationsToCore`,\\n * `manuallyLimitProjectMaxInvocations`, and `purchaseEffectsInvocations`.\\n * @author Art Blocks Inc.\\n */\\n\\nlibrary MaxInvocationsLib {\\n    using SafeCast for uint256;\\n\\n    /**\\n     * @notice Local max invocations for project `projectId`, tied to core contract `coreContractAddress`,\\n     * updated to `maxInvocations`.\\n     * @param projectId The id of the project.\\n     * @param coreContract The address of the core contract.\\n     * @param maxInvocations The new max invocations limit.\\n     */\\n    event ProjectMaxInvocationsLimitUpdated(\\n        uint256 indexed projectId,\\n        address indexed coreContract,\\n        uint256 maxInvocations\\n    );\\n\\n    // position of Max Invocations Lib storage, using a diamond storage pattern\\n    // for this library\\n    bytes32 constant MAX_INVOCATIONS_LIB_STORAGE_POSITION =\\n        keccak256(\\\"maxinvocationslib.storage\\\");\\n\\n    uint256 internal constant ONE_MILLION = 1_000_000;\\n\\n    /**\\n     * @notice Data structure that holds max invocations project configuration.\\n     */\\n    struct MaxInvocationsProjectConfig {\\n        bool maxHasBeenInvoked;\\n        uint24 maxInvocations;\\n    }\\n\\n    // Diamond storage pattern is used in this library\\n    struct MaxInvocationsLibStorage {\\n        mapping(address coreContract => mapping(uint256 projectId => MaxInvocationsProjectConfig)) maxInvocationsProjectConfigs;\\n    }\\n\\n    /**\\n     * @notice Syncs project's max invocations to core contract value.\\n     * @param projectId The id of the project.\\n     * @param coreContract The address of the core contract.\\n     */\\n    function syncProjectMaxInvocationsToCore(\\n        uint256 projectId,\\n        address coreContract\\n    ) internal {\\n        (\\n            uint256 coreInvocations,\\n            uint256 coreMaxInvocations\\n        ) = coreContractInvocationData({\\n                projectId: projectId,\\n                coreContract: coreContract\\n            });\\n        // update storage with results\\n        MaxInvocationsProjectConfig\\n            storage maxInvocationsProjectConfig = getMaxInvocationsProjectConfig({\\n                projectId: projectId,\\n                coreContract: coreContract\\n            });\\n        // @dev only bugged core would return > 1e6 invocations, but safe-cast\\n        // for additional overflow safety\\n        maxInvocationsProjectConfig.maxInvocations = coreMaxInvocations\\n            .toUint24();\\n\\n        // We need to ensure maxHasBeenInvoked is correctly set after manually syncing the\\n        // local maxInvocations value with the core contract's maxInvocations value.\\n        maxInvocationsProjectConfig.maxHasBeenInvoked =\\n            coreInvocations == coreMaxInvocations;\\n\\n        emit ProjectMaxInvocationsLimitUpdated({\\n            projectId: projectId,\\n            coreContract: coreContract,\\n            maxInvocations: coreMaxInvocations\\n        });\\n    }\\n\\n    /**\\n     * @notice Manually limits project's max invocations.\\n     * @param projectId The id of the project.\\n     * @param coreContract The address of the core contract.\\n     * @param maxInvocations The new max invocations limit.\\n     */\\n    function manuallyLimitProjectMaxInvocations(\\n        uint256 projectId,\\n        address coreContract,\\n        uint24 maxInvocations\\n    ) internal {\\n        // CHECKS\\n        (\\n            uint256 coreInvocations,\\n            uint256 coreMaxInvocations\\n        ) = coreContractInvocationData({\\n                projectId: projectId,\\n                coreContract: coreContract\\n            });\\n        require(\\n            maxInvocations <= coreMaxInvocations,\\n            \\\"Invalid max invocations\\\"\\n        );\\n        require(maxInvocations >= coreInvocations, \\\"Invalid max invocations\\\");\\n\\n        // EFFECTS\\n        MaxInvocationsProjectConfig\\n            storage maxInvocationsProjectConfig = getMaxInvocationsProjectConfig({\\n                projectId: projectId,\\n                coreContract: coreContract\\n            });\\n        // update storage with results\\n        maxInvocationsProjectConfig.maxInvocations = uint24(maxInvocations);\\n        // We need to ensure maxHasBeenInvoked is correctly set after manually setting the\\n        // local maxInvocations value.\\n        maxInvocationsProjectConfig.maxHasBeenInvoked =\\n            coreInvocations == maxInvocations;\\n\\n        emit ProjectMaxInvocationsLimitUpdated({\\n            projectId: projectId,\\n            coreContract: coreContract,\\n            maxInvocations: maxInvocations\\n        });\\n    }\\n\\n    /**\\n     * @notice Validate effects on invocations after purchase. This ensures\\n     * that the token invocation is less than or equal to the local max\\n     * invocations, and also updates the local maxHasBeenInvoked value.\\n     * @dev This function checks that the token invocation is less than or\\n     * equal to the local max invocations, and also updates the local\\n     * maxHasBeenInvoked value.\\n     * @param tokenId The id of the token.\\n     * @param coreContract The address of the core contract.\\n     */\\n    function validateMintEffectsInvocations(\\n        uint256 tokenId,\\n        address coreContract\\n    ) internal {\\n        uint256 projectId = ABHelpers.tokenIdToProjectId(tokenId);\\n        MaxInvocationsProjectConfig\\n            storage maxInvocationsProjectConfig = getMaxInvocationsProjectConfig({\\n                projectId: projectId,\\n                coreContract: coreContract\\n            });\\n        // invocation is token number plus one, and will never overflow due to\\n        // limit of 1e6 invocations per project. block scope for gas efficiency\\n        // (i.e. avoid an unnecessary var initialization to 0).\\n        unchecked {\\n            uint256 tokenInvocation = ABHelpers.tokenIdToTokenInvocation(\\n                tokenId\\n            );\\n            uint256 localMaxInvocations = maxInvocationsProjectConfig\\n                .maxInvocations;\\n            // handle the case where the token invocation == minter local max\\n            // invocations occurred on a different minter, and we have a stale\\n            // local maxHasBeenInvoked value returning a false negative.\\n            // @dev this is a CHECK after EFFECTS, so security was considered\\n            // in detail here.\\n            require(\\n                tokenInvocation <= localMaxInvocations,\\n                \\\"Max invocations reached\\\"\\n            );\\n            // in typical case, update the local maxHasBeenInvoked value\\n            // to true if the token invocation == minter local max invocations\\n            // (enables gas efficient reverts after sellout)\\n            if (tokenInvocation == localMaxInvocations) {\\n                maxInvocationsProjectConfig.maxHasBeenInvoked = true;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Checks that the max invocations have not been reached for a\\n     * given project. This only checks the minter's local max invocations, and\\n     * does not consider the core contract's max invocations.\\n     * The function reverts if the max invocations have been reached.\\n     * @param projectId The id of the project.\\n     * @param coreContract The address of the core contract.\\n     */\\n    function preMintChecks(\\n        uint256 projectId,\\n        address coreContract\\n    ) internal view {\\n        // check that max invocations have not been reached\\n        MaxInvocationsProjectConfig\\n            storage maxInvocationsProjectConfig = getMaxInvocationsProjectConfig({\\n                projectId: projectId,\\n                coreContract: coreContract\\n            });\\n        require(\\n            !maxInvocationsProjectConfig.maxHasBeenInvoked,\\n            \\\"Max invocations reached\\\"\\n        );\\n    }\\n\\n    /**\\n     * @notice Helper function to check if max invocations has not been initialized.\\n     * Returns true if not initialized, false if initialized.\\n     * @param projectId The id of the project.\\n     * @param coreContract The address of the core contract.\\n     * @return bool\\n     * @dev We know a project's max invocations have never been initialized if\\n     * both max invocations and maxHasBeenInvoked are still initial values.\\n     * This is because if maxInvocations were ever set to zero,\\n     * maxHasBeenInvoked would be set to true.\\n     */\\n    function maxInvocationsIsUnconfigured(\\n        uint256 projectId,\\n        address coreContract\\n    ) internal view returns (bool) {\\n        MaxInvocationsProjectConfig\\n            storage maxInvocationsProjectConfig = getMaxInvocationsProjectConfig({\\n                projectId: projectId,\\n                coreContract: coreContract\\n            });\\n        return\\n            maxInvocationsProjectConfig.maxInvocations == 0 &&\\n            !maxInvocationsProjectConfig.maxHasBeenInvoked;\\n    }\\n\\n    /**\\n     * @notice Function returns if invocations remain available for a given project.\\n     * This function calls the core contract to get the most up-to-date\\n     * invocation data (which may be useful to avoid reverts during mint).\\n     * This function considers core contract max invocations, and minter local\\n     * max invocations, and returns a response based on the most limiting\\n     * max invocations value.\\n     * @param projectId The id of the project.\\n     * @param coreContract The address of the core contract.\\n     */\\n    function invocationsRemain(\\n        uint256 projectId,\\n        address coreContract\\n    ) internal view returns (bool) {\\n        // get up-to-data invocation data from core contract\\n        (\\n            uint256 coreInvocations,\\n            uint256 coreMaxInvocations\\n        ) = coreContractInvocationData({\\n                projectId: projectId,\\n                coreContract: coreContract\\n            });\\n        // load minter-local max invocations into memory\\n        MaxInvocationsProjectConfig\\n            storage maxInvocationsProjectConfig = getMaxInvocationsProjectConfig({\\n                projectId: projectId,\\n                coreContract: coreContract\\n            });\\n        // invocations remain available if the core contract has not reached\\n        // the most limiting max invocations, either on minter or core contract\\n        uint256 limitingMaxInvocations = Math.min(\\n            coreMaxInvocations,\\n            maxInvocationsProjectConfig.maxInvocations // local max invocations\\n        );\\n        return coreInvocations < limitingMaxInvocations;\\n    }\\n\\n    /**\\n     * @notice Pulls core contract invocation data for a given project.\\n     * @dev This function calls the core contract to get the invocation data\\n     * @param projectId The id of the project.\\n     * @param coreContract The address of the core contract.\\n     * @return coreInvocations The number of invocations for the project.\\n     * @return coreMaxInvocations The max invocations for the project, as\\n     * defined on the core contract.\\n     */\\n    function coreContractInvocationData(\\n        uint256 projectId,\\n        address coreContract\\n    )\\n        internal\\n        view\\n        returns (uint256 coreInvocations, uint256 coreMaxInvocations)\\n    {\\n        (\\n            coreInvocations,\\n            coreMaxInvocations,\\n            ,\\n            ,\\n            ,\\n\\n        ) = IGenArt721CoreContractV3_Base(coreContract).projectStateData(\\n            projectId\\n        );\\n    }\\n\\n    /**\\n     * @notice Function returns the max invocations for a given project.\\n     * @param projectId The id of the project.\\n     * @param coreContract The address of the core contract.\\n     * to be queried.\\n     */\\n    function getMaxInvocations(\\n        uint256 projectId,\\n        address coreContract\\n    ) internal view returns (uint256) {\\n        MaxInvocationsProjectConfig\\n            storage maxInvocationsProjectConfig = getMaxInvocationsProjectConfig({\\n                projectId: projectId,\\n                coreContract: coreContract\\n            });\\n        return maxInvocationsProjectConfig.maxInvocations;\\n    }\\n\\n    /**\\n     * @notice Function returns if max has been invoked for a given project.\\n     * @param projectId The id of the project.\\n     * @param coreContract The address of the core contract.\\n     * to be queried.\\n     */\\n    function getMaxHasBeenInvoked(\\n        uint256 projectId,\\n        address coreContract\\n    ) internal view returns (bool) {\\n        MaxInvocationsProjectConfig\\n            storage maxInvocationsProjectConfig = getMaxInvocationsProjectConfig({\\n                projectId: projectId,\\n                coreContract: coreContract\\n            });\\n        return maxInvocationsProjectConfig.maxHasBeenInvoked;\\n    }\\n\\n    /**\\n     * @notice Function returns if a project has reached its max invocations.\\n     * Function is labelled as \\\"safe\\\" because it checks the core contract's\\n     * invocations and max invocations. If the local max invocations is greater\\n     * than the core contract's max invocations, it will defer to the core\\n     * contract's max invocations (since those are the limiting factor).\\n     * @param projectId The id of the project.\\n     * @param coreContract The address of the core contract.\\n     */\\n    function projectMaxHasBeenInvokedSafe(\\n        uint256 projectId,\\n        address coreContract\\n    ) internal view returns (bool) {\\n        // get max invocations from core contract\\n        (\\n            uint256 coreInvocations,\\n            uint256 coreMaxInvocations\\n        ) = coreContractInvocationData({\\n                projectId: projectId,\\n                coreContract: coreContract\\n            });\\n\\n        MaxInvocationsProjectConfig\\n            storage maxInvocationsProjectConfig = getMaxInvocationsProjectConfig({\\n                projectId: projectId,\\n                coreContract: coreContract\\n            });\\n        uint256 localMaxInvocations = maxInvocationsProjectConfig\\n            .maxInvocations;\\n        // value is locally defined, and could be out of date.\\n        // only possible illogical state is if local max invocations is\\n        // greater than core contract's max invocations, in which case\\n        // we should use the core contract's max invocations\\n        if (localMaxInvocations > coreMaxInvocations) {\\n            // local max invocations is stale and illogical, defer to core\\n            // contract's max invocations since it is the limiting factor\\n            return (coreMaxInvocations == coreInvocations);\\n        }\\n        // local max invocations is limiting, so check core invocations against\\n        // local max invocations\\n        return (coreInvocations >= localMaxInvocations);\\n    }\\n\\n    /**\\n     * @notice Refreshes max invocations to account for core contract max\\n     * invocations state, without imposing any additional restrictions on the\\n     * minter's max invocations state.\\n     * If minter max invocations have never been populated, this function will\\n     * populate them to equal the core contract's max invocations state (which\\n     * is the least restrictive state).\\n     * If minter max invocations have been populated, this function will ensure\\n     * the minter's max invocations are not greater than the core contract's\\n     * max invocations (which would be stale and illogical), and update the\\n     * minter's max invocations and maxHasBeenInvoked state to be consistent\\n     * with the core contract's max invocations.\\n     * If the minter max invocations have been populated and are not greater\\n     * than the core contract's max invocations, this function will do nothing,\\n     * since that is a valid state in which the minter has been configured to\\n     * be more restrictive than the core contract.\\n     * @dev assumes core contract's max invocations may only be reduced, which\\n     * is the case for all V3 core contracts\\n     * @param projectId The id of the project.\\n     * @param coreContract The address of the core contract.\\n     */\\n    function refreshMaxInvocations(\\n        uint256 projectId,\\n        address coreContract\\n    ) internal {\\n        MaxInvocationsProjectConfig\\n            storage maxInvocationsProjectConfig = getMaxInvocationsProjectConfig({\\n                projectId: projectId,\\n                coreContract: coreContract\\n            });\\n        if (maxInvocationsIsUnconfigured(projectId, coreContract)) {\\n            // populate the minter max invocation state to equal the values on\\n            // the core contract (least restrictive state)\\n            syncProjectMaxInvocationsToCore({\\n                projectId: projectId,\\n                coreContract: coreContract\\n            });\\n        } else {\\n            // if local max invocations were already populated, validate the local state\\n            (\\n                uint256 coreInvocations,\\n                uint256 coreMaxInvocations\\n            ) = coreContractInvocationData({\\n                    projectId: projectId,\\n                    coreContract: coreContract\\n                });\\n\\n            uint256 localMaxInvocations = maxInvocationsProjectConfig\\n                .maxInvocations;\\n            if (localMaxInvocations > coreMaxInvocations) {\\n                // if local max invocations are greater than core max invocations, make\\n                // them equal since that is the least restrictive logical state\\n                // @dev this is only possible if the core contract's max invocations\\n                // have been reduced since the minter's max invocations were last\\n                // updated\\n                // set local max invocations to core contract's max invocations\\n                maxInvocationsProjectConfig.maxInvocations = uint24(\\n                    coreMaxInvocations\\n                );\\n                // update the minter's `maxHasBeenInvoked` state\\n                maxInvocationsProjectConfig\\n                    .maxHasBeenInvoked = (coreMaxInvocations ==\\n                    coreInvocations);\\n                emit ProjectMaxInvocationsLimitUpdated({\\n                    projectId: projectId,\\n                    coreContract: coreContract,\\n                    maxInvocations: coreMaxInvocations\\n                });\\n            } else if (coreInvocations >= localMaxInvocations) {\\n                // core invocations are greater than this minter's max\\n                // invocations, indicating that minting must have occurred on\\n                // another minter. update the minter's `maxHasBeenInvoked` to\\n                // true to prevent any false negatives on\\n                // `getMaxHasBeenInvoked'\\n                maxInvocationsProjectConfig.maxHasBeenInvoked = true;\\n                // @dev do not emit event, because we did not change the value\\n                // of minter-local max invocations\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Loads the MaxInvocationsProjectConfig for a given project and core\\n     * contract.\\n     * @param projectId Project Id to get config for\\n     * @param coreContract Core contract address to get config for\\n     */\\n    function getMaxInvocationsProjectConfig(\\n        uint256 projectId,\\n        address coreContract\\n    ) internal view returns (MaxInvocationsProjectConfig storage) {\\n        return s().maxInvocationsProjectConfigs[coreContract][projectId];\\n    }\\n\\n    /**\\n     * @notice Return the storage struct for reading and writing. This library\\n     * uses a diamond storage pattern when managing storage.\\n     * @return storageStruct The MaxInvocationsLibStorage struct.\\n     */\\n    function s()\\n        internal\\n        pure\\n        returns (MaxInvocationsLibStorage storage storageStruct)\\n    {\\n        bytes32 position = MAX_INVOCATIONS_LIB_STORAGE_POSITION;\\n        assembly (\\\"memory-safe\\\") {\\n            storageStruct.slot := position\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libs/v0.8.x/minter-libs/SettlementExpLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\n// Created By: Art Blocks Inc.\\n\\npragma solidity ^0.8.0;\\n\\nimport {MaxInvocationsLib} from \\\"./MaxInvocationsLib.sol\\\";\\nimport {DAExpLib} from \\\"./DAExpLib.sol\\\";\\nimport {SplitFundsLib} from \\\"./SplitFundsLib.sol\\\";\\nimport {AuthLib} from \\\"../AuthLib.sol\\\";\\nimport {GenericMinterEventsLib} from \\\"./GenericMinterEventsLib.sol\\\";\\n\\nimport {SafeCast} from \\\"@openzeppelin-4.7/contracts/utils/math/SafeCast.sol\\\";\\n\\n/**\\n * @title Art Blocks Settlement Library for Exponential Auctions\\n * @notice This library manages the settlement logic for Art Blocks settlement\\n * minters. It provides functionality for managing a project's settlement state\\n * via the SettlementAuctionProjectConfig struct, and managing an individual's\\n * settlement state on a given project via the Receipt struct.\\n * @author Art Blocks Inc.\\n */\\n\\nlibrary SettlementExpLib {\\n    using SafeCast for uint256;\\n    /**\\n     * @notice Receipt updated event. Emitted when a receipt is updated.\\n     * @param purchaser purchaser address of updated receipt\\n     * @param projectId project ID of updated receipt\\n     * @param coreContract core contract address of updated receipt\\n     * @param numPurchased new number of tokens purchased on project\\n     * @param netPosted new net funds posted on project\\n     */\\n    event ReceiptUpdated(\\n        address indexed purchaser,\\n        uint256 indexed projectId,\\n        address indexed coreContract,\\n        uint24 numPurchased,\\n        uint256 netPosted\\n    );\\n\\n    // position of Settlement Exp Lib storage, using a diamond storage pattern\\n    // for this library\\n    bytes32 constant SETTLEMENT_EXP_LIB_STORAGE_POSITION =\\n        keccak256(\\\"settlementexplib.storage\\\");\\n\\n    bytes32 internal constant CONFIG_CURRENT_SETTLED_PRICE =\\n        \\\"currentSettledPrice\\\";\\n    bytes32 internal constant CONFIG_AUCTION_REVENUES_COLLECTED =\\n        \\\"auctionRevenuesCollected\\\";\\n\\n    // The SettlementAuctionProjectConfig struct tracks the state of a project's\\n    // settlement auction. It tracks the number of tokens minted that have\\n    // potential of future settlement, the latest purchase price of a token on\\n    // the project, and whether or not the auction's revenues have been\\n    // collected.\\n    struct SettlementAuctionProjectConfig {\\n        // set to true only after artist + admin revenues have been collected\\n        bool auctionRevenuesCollected;\\n        // number of tokens minted that have potential of future settlement.\\n        // @dev max uint24 > 16.7 million tokens > 1 million tokens/project max\\n        uint24 numSettleableInvocations;\\n        // When non-zero, this value is used as a reference when an auction is\\n        // reset by admin, and then a new auction is configured by an artist.\\n        // In that case, the new auction will be required to have a starting\\n        // price less than or equal to this value, if one or more purchases\\n        // have been made on this minter.\\n        // @dev max uint88 ~= 3e26 Wei = ~300 million ETH, which is well above\\n        // the expected prices of any NFT mint in the foreseeable future.\\n        // This enables struct packing.\\n        uint88 latestPurchasePrice;\\n        // Track per-project fund balance, in wei. This is used as a redundant\\n        // backstop to prevent one project from draining the minter's balance\\n        // of ETH from other projects, which is a worthwhile failsafe on this\\n        // shared minter.\\n        // @dev max uint88 ~= 3e26 Wei = ~300 million ETH, which is well above\\n        // the expected revenues for a single auction.\\n        // This enables struct packing.\\n        uint88 projectBalance;\\n        // field to store the number of purchases that have been made on the\\n        // project, on this minter. This is used to track if unexpected mints\\n        // from sources other than this minter occur during an auction.\\n        // @dev max uint24 allows for > max project supply of 1 million tokens\\n        // @dev important to pack this field with other fields updated during a\\n        // purchase, for gas efficiency\\n        uint24 numPurchasesOnMinter;\\n        // The number of tokens to be auctioned for the project on this minter.\\n        // This is defined as the number of invocations remaining at the time\\n        // of a project's first mint.\\n        uint24 numTokensToBeAuctioned;\\n        // --- @dev end of storage slot ---\\n    }\\n\\n    // The Receipt struct tracks the state of a user's settlement on a given\\n    // project. It tracks the total funds posted by the user on the project\\n    // and the number of tokens purchased by the user on the project.\\n    struct Receipt {\\n        // max uint232 allows for > 1e51 ETH (much more than max supply)\\n        uint232 netPosted;\\n        // max uint24 still allows for > max project supply of 1 million tokens\\n        uint24 numPurchased;\\n    }\\n\\n    // Diamond storage pattern is used in this library\\n    struct SettlementExpLibStorage {\\n        mapping(address coreContract => mapping(uint256 projectId => SettlementAuctionProjectConfig)) settlementAuctionProjectConfigs;\\n        mapping(address walletAddress => mapping(address coreContract => mapping(uint256 projectId => Receipt))) receipts;\\n    }\\n\\n    /**\\n     * @notice Distributes the net revenues from the project's auction, and\\n     * marks the auction as having had its revenues collected.\\n     * IMPORTANT - this affects state and distributes revenue funds, so it\\n     * performs all three of CHECKS, EFFECTS and INTERACTIONS.\\n     * This function updates a project's balance to reflect the amount of\\n     * revenues distributed, and will revert if underflow occurs.\\n     * @param projectId Project ID to get revenues for\\n     * @param coreContract Core contract address\\n     */\\n    function distributeArtistAndAdminRevenues(\\n        uint256 projectId,\\n        address coreContract\\n    ) internal {\\n        // load the project's settlement auction config\\n        SettlementAuctionProjectConfig\\n            storage settlementAuctionProjectConfig = getSettlementAuctionProjectConfig({\\n                projectId: projectId,\\n                coreContract: coreContract\\n            });\\n        // require revenues to not have already been collected\\n        require(\\n            !settlementAuctionProjectConfig.auctionRevenuesCollected,\\n            \\\"Revenues already collected\\\"\\n        );\\n        // refresh max invocations, updating any local values that are\\n        // illogical with respect to the current core contract state, and\\n        // ensuring that local maxHasBeenInvoked is accurate.\\n        MaxInvocationsLib.refreshMaxInvocations({\\n            projectId: projectId,\\n            coreContract: coreContract\\n        });\\n\\n        // get the current net price of the auction - reverts if no auction\\n        // is configured.\\n        // @dev we use getPriceUnsafe here, since we just safely synced the\\n        // project's max invocations and maxHasBeenInvoked, which guarantees\\n        // an accurate price calculation from getPriceUnsafe, while being\\n        // more gas efficient than getPriceSafe.\\n        // @dev price is guaranteed <= _projectConfig.latestPurchasePrice,\\n        // since this minter enforces monotonically decreasing purchase prices.\\n        // @dev we can trust maxHasBeenInvoked, since we just\\n        // refreshed it above with refreshMaxInvocations, preventing any\\n        // false negatives\\n        bool maxHasBeenInvoked = MaxInvocationsLib.getMaxHasBeenInvoked({\\n            projectId: projectId,\\n            coreContract: coreContract\\n        });\\n        uint256 price = getPriceUnsafe({\\n            projectId: projectId,\\n            coreContract: coreContract,\\n            maxHasBeenInvoked: maxHasBeenInvoked\\n        });\\n        // if the price is not base price, require that the auction have\\n        // reached max invocations. This prevents premature withdrawl\\n        // before final auction price is possible to know.\\n        uint256 basePrice = DAExpLib.getAuctionBasePrice({\\n            projectId: projectId,\\n            coreContract: coreContract\\n        });\\n        if (price != basePrice) {\\n            require(maxHasBeenInvoked, \\\"Active auction not yet sold out\\\");\\n            // if max has been invoked, but all tokens to be auctioned were not\\n            // sold, nonstandard activity has been detected (e.g. project max\\n            // invocations were reduced on core contract after initial\\n            // purchase, purchases were made on a different minter after\\n            // initial purchase, etc.), which could artifically inflate\\n            // sellout price and harm purchasers. In that case, we should\\n            // not revert (since max invocations have been reached), but we\\n            // should require admin to be the caller of this function.\\n            // This provides separation of powers to protect collectors who\\n            // participated in the auction.\\n            // Note that if admin determines the artist has been malicious,\\n            // admin should replace artist address with a wallet controlled by\\n            // admin on the core contract, update payee address on the core,\\n            // collect revenues using this function, then distribute any\\n            // additional settlement funds to purchasers at admin's discretion.\\n            if (\\n                !_allTokensToBeAuctionedWereSold(settlementAuctionProjectConfig)\\n            ) {\\n                AuthLib.onlyCoreAdminACL({\\n                    coreContract: coreContract,\\n                    sender: msg.sender,\\n                    contract_: address(this),\\n                    selector: bytes4(\\n                        keccak256(\\n                            \\\"distributeArtistAndAdminRevenues(uint256,address)\\\"\\n                        )\\n                    )\\n                });\\n            }\\n        } else {\\n            // base price of zero indicates that the auction has not been configured,\\n            // since base price of zero is not allowed when configuring an auction.\\n            // @dev no coverage else branch of following line because redundant,\\n            // acknowledge redundant check\\n            require(basePrice > 0, \\\"Only latestPurchasePrice > 0\\\");\\n            // if the price is base price, the auction is valid and may be claimed\\n            // update the latest purchase price to the base price, to ensure\\n            // the base price is used for all future settlement calculations\\n            // EFFECTS\\n            // @dev base price value was just loaded from uint88 in storage,\\n            // so no safe cast required\\n            settlementAuctionProjectConfig.latestPurchasePrice = uint88(\\n                basePrice\\n            );\\n            // notify indexing service of settled price update\\n            // @dev acknowledge that this event may be emitted prior to\\n            // other state updates in this function, but that is okay because\\n            // the settled price is the only value updated with this event\\n            emit GenericMinterEventsLib.ConfigValueSet({\\n                projectId: projectId,\\n                coreContract: coreContract,\\n                key: CONFIG_CURRENT_SETTLED_PRICE,\\n                value: basePrice\\n            });\\n        }\\n        settlementAuctionProjectConfig.auctionRevenuesCollected = true;\\n        // calculate the artist and admin revenues\\n        uint256 netRevenues = settlementAuctionProjectConfig\\n            .numSettleableInvocations * price;\\n\\n        // reduce project balance by the amount of ETH being distributed\\n        // @dev underflow checked automatically in solidity ^0.8\\n        settlementAuctionProjectConfig.projectBalance -= netRevenues.toUint88();\\n\\n        // INTERACTIONS\\n        SplitFundsLib.splitRevenuesETHNoRefund({\\n            projectId: projectId,\\n            valueInWei: netRevenues,\\n            coreContract: coreContract\\n        });\\n\\n        emit GenericMinterEventsLib.ConfigValueSet({\\n            projectId: projectId,\\n            coreContract: coreContract,\\n            key: CONFIG_AUCTION_REVENUES_COLLECTED,\\n            value: true\\n        });\\n    }\\n\\n    /**\\n     * @notice Reclaims excess settlement funds for purchaser wallet\\n     * `purchaserAddress` on project `projectId`. Excess settlement funds are\\n     * the amount of funds posted by the purchaser that are in excess of the\\n     * amount required to settle the purchaser's tokens on the project.\\n     * Excess settlement funds are sent to address `to`, and function reverts\\n     * if send fails.\\n     * @param projectId Project ID to reclaim excess settlement funds for\\n     * @param coreContract Core contract address\\n     * @param purchaserAddress Address to reclaim excess settlement funds for\\n     * @param to Address to send excess settlement funds to\\n     * @param doSendFunds If true, sends funds to `to`. If false, only updates\\n     * the receipt to reflect the new funds posted, and returns the amount of\\n     * excess settlement funds that still need to be sent to `to`.\\n     * @return remainingUnsentExcessSettlementFunds amount of excess settlement\\n     * funds that still need to be sent to `to`, in wei. If doSendFunds, this\\n     * value will be zero, because funds will have been sent to `to`.\\n     */\\n    function reclaimProjectExcessSettlementFundsTo(\\n        address payable to,\\n        uint256 projectId,\\n        address coreContract,\\n        address purchaserAddress,\\n        bool doSendFunds\\n    ) internal returns (uint256 remainingUnsentExcessSettlementFunds) {\\n        (\\n            uint256 excessSettlementFunds,\\n            uint256 requiredAmountPosted\\n        ) = getProjectExcessSettlementFunds({\\n                projectId: projectId,\\n                coreContract: coreContract,\\n                walletAddress: purchaserAddress\\n            });\\n\\n        SettlementAuctionProjectConfig\\n            storage settlementAuctionProjectConfig = getSettlementAuctionProjectConfig({\\n                projectId: projectId,\\n                coreContract: coreContract\\n            });\\n        Receipt storage receipt = getReceipt({\\n            walletAddress: purchaserAddress,\\n            coreContract: coreContract,\\n            projectId: projectId\\n        });\\n\\n        uint232 newNetPosted = requiredAmountPosted.toUint232();\\n        receipt.netPosted = newNetPosted;\\n\\n        // reduce project balance by the amount of ETH being distributed\\n        // @dev underflow checked automatically in solidity ^0.8\\n        settlementAuctionProjectConfig.projectBalance -= excessSettlementFunds\\n            .toUint88();\\n\\n        emit ReceiptUpdated({\\n            purchaser: purchaserAddress,\\n            projectId: projectId,\\n            coreContract: coreContract,\\n            numPurchased: receipt.numPurchased,\\n            netPosted: newNetPosted\\n        });\\n\\n        // INTERACTIONS\\n        if (doSendFunds) {\\n            bool success_;\\n            (success_, ) = to.call{value: excessSettlementFunds}(\\\"\\\");\\n            require(success_, \\\"Reclaiming failed\\\");\\n        } else {\\n            // return unsent funds amount to caller\\n            remainingUnsentExcessSettlementFunds = excessSettlementFunds;\\n        }\\n    }\\n\\n    /**\\n     * @notice Performs updates to project state prior to a mint being\\n     * initiated, during a purchase transaction. Specifically, this updates the\\n     * number of purchases on this minter (and populates expected number of\\n     * tokens to be auctioned if this is first purchase), increases the\\n     * project's balance by the amount of funds sent with the transaction,\\n     * updates the purchaser's receipt to reflect the new funds posted, checks\\n     * that the updated receipt has sufficient funds posted for the number of\\n     * tokens to be purchased after this transaction, and updates the project's\\n     * latest purchase price to the current price of the token.\\n     * Reverts if insuffient funds have been posted for the number of tokens to\\n     * be purchased after this transaction.\\n     * @param projectId Project ID to perform the pre-mint effects for\\n     * @param coreContract Core contract address\\n     * @param currentPriceInWei current price of token in Wei\\n     * @param msgValue msg.value sent with mint transaction\\n     * @param purchaserAddress Wallet address of purchaser\\n     */\\n    function preMintEffects(\\n        uint256 projectId,\\n        address coreContract,\\n        uint256 currentPriceInWei,\\n        uint256 msgValue,\\n        address purchaserAddress\\n    ) internal {\\n        // load the project's settlement auction config and receipt\\n        SettlementAuctionProjectConfig\\n            storage settlementAuctionProjectConfig = getSettlementAuctionProjectConfig({\\n                projectId: projectId,\\n                coreContract: coreContract\\n            });\\n\\n        // if this is the first purchase on this minter, set the number of\\n        // of tokens to be auctioned to:\\n        // (minter max invocations) - (current core contract invocations)\\n        if (settlementAuctionProjectConfig.numPurchasesOnMinter == 0) {\\n            // get up-to-data invocation data from core contract\\n            (\\n                uint256 coreInvocations,\\n                uint256 coreMaxInvocations\\n            ) = MaxInvocationsLib.coreContractInvocationData({\\n                    projectId: projectId,\\n                    coreContract: coreContract\\n                });\\n            // snap chalkline on the number of tokens to be auctioned on this\\n            // minter\\n            // @dev acknowledge that this value may be stale if the core\\n            // contract's max invocations were reduced since the last time\\n            // the minter's max invocations were updated, but that is desired.\\n            // That case would be classified as \\\"nonstandard activity\\\", so we\\n            // want to require admin to be the withdrawer of revenues in that\\n            // case.\\n            uint256 minterMaxInvocations = MaxInvocationsLib.getMaxInvocations({\\n                projectId: projectId,\\n                coreContract: coreContract\\n            });\\n            // @dev prefer to use stale value minterMaxInvocations here, since\\n            // if it is stale, the artist could have decreased max invocations\\n            // on core contract at last moment unexpectedly, and we want to\\n            // equire admin to be the withdrawer of revenues in that case.\\n            settlementAuctionProjectConfig.numTokensToBeAuctioned = uint24(\\n                minterMaxInvocations - coreInvocations\\n            );\\n            // edge case: minter max invocations > core contract max invocations.\\n            // could be caused by either:\\n            //  - core contract max invocations reduced after configuring\\n            //    auction (this is generally accidental by artist), and did not\\n            //    subsequently update minter's max invocations\\n            //  - artist decreased max invocations on core contract at last\\n            //    moment prior to this initial mint (this is suspicious)\\n            // either way, we want to update minter's local max invocations, so\\n            // that the minter returns the most up-to-date value from function\\n            // `projectMaxHasBeenInvoked` in the future.\\n            // @dev note that this edge case will end up being classified as\\n            // \\\"nonstandard activity\\\" in case of sellout above base price, and\\n            // will require admin concurrence in those cases.\\n            if (minterMaxInvocations > coreMaxInvocations) {\\n                // update minter's max invocations to match core contract\\n                MaxInvocationsLib.syncProjectMaxInvocationsToCore({\\n                    projectId: projectId,\\n                    coreContract: coreContract\\n                });\\n            }\\n        }\\n\\n        // increment the number of purchases on this minter during every purchase\\n        settlementAuctionProjectConfig.numPurchasesOnMinter++;\\n\\n        // update project balance\\n        settlementAuctionProjectConfig.projectBalance += msgValue.toUint88();\\n\\n        _validateReceiptEffects({\\n            walletAddress: purchaserAddress,\\n            projectId: projectId,\\n            coreContract: coreContract,\\n            currentPriceInWei: currentPriceInWei\\n        });\\n\\n        // update latest purchase price (on this minter) in storage\\n        // @dev this is used to enforce monotonically decreasing purchase price\\n        // across multiple auctions\\n        settlementAuctionProjectConfig.latestPurchasePrice = currentPriceInWei\\n            .toUint88();\\n    }\\n\\n    /**\\n     * @notice Performs updates to project state after a mint has been\\n     * successfully completed.\\n     * Specifically, this function distributes revenues if the auction revenues\\n     * have been collected, or increments the number of settleable invocations\\n     * if the auction revenues have not been collected.\\n     * @param projectId Project ID to perform post-mint updates for\\n     * @param coreContract Core contract address\\n     * @param currentPriceInWei current price of token in Wei (the value to be\\n     * distributed if revenues have been collected)\\n     */\\n    function postMintInteractions(\\n        uint256 projectId,\\n        address coreContract,\\n        uint256 currentPriceInWei\\n    ) internal {\\n        // load the project's settlement auction config\\n        SettlementAuctionProjectConfig\\n            storage settlementAuctionProjectConfig = getSettlementAuctionProjectConfig({\\n                projectId: projectId,\\n                coreContract: coreContract\\n            });\\n        if (settlementAuctionProjectConfig.auctionRevenuesCollected) {\\n            // if revenues have been collected, split revenues immediately.\\n            // @dev note that we are guaranteed to be at auction base price,\\n            // since we know we didn't sellout prior to this tx.\\n            // note that we don't refund msg.sender here, since a separate\\n            // settlement mechanism is provided on this minter, unrelated to\\n            // msg.value\\n\\n            // reduce project balance by the amount of ETH being distributed\\n            // @dev specifically, this is not decremented by msg.value, as\\n            // msg.sender is not refunded here\\n            // @dev underflow checked automatically in solidity ^0.8\\n            settlementAuctionProjectConfig.projectBalance -= currentPriceInWei\\n                .toUint88();\\n\\n            // INTERACTIONS\\n            SplitFundsLib.splitRevenuesETHNoRefund({\\n                projectId: projectId,\\n                valueInWei: currentPriceInWei,\\n                coreContract: coreContract\\n            });\\n        } else {\\n            // increment the number of settleable invocations that will be\\n            // claimable by the artist and admin once auction is validated.\\n            // do not split revenue here since will be claimed at a later time.\\n            settlementAuctionProjectConfig.numSettleableInvocations++;\\n            // @dev project balance is unaffected because no funds are distributed\\n        }\\n    }\\n\\n    /**\\n     * @notice Returns number of purchases that have been made on the minter, for a\\n     * given project.\\n     * @param projectId The id of the project.\\n     * @param coreContract The address of the core contract.\\n     */\\n    function getNumPurchasesOnMinter(\\n        uint256 projectId,\\n        address coreContract\\n    ) internal view returns (uint256) {\\n        SettlementAuctionProjectConfig\\n            storage settlementAuctionProjectConfig = getSettlementAuctionProjectConfig({\\n                projectId: projectId,\\n                coreContract: coreContract\\n            });\\n        return settlementAuctionProjectConfig.numPurchasesOnMinter;\\n    }\\n\\n    /**\\n     * @notice Returns the excess settlement funds for purchaser wallet\\n     * `walletAddress` on project `projectId`. Excess settlement funds are\\n     * the amount of funds posted by the purchaser that are in excess of the\\n     * amount required to settle the purchaser's tokens on the project.\\n     * @param projectId Project ID to get revenues for\\n     * @param coreContract Core contract address\\n     * @param walletAddress Address to get excess settlement funds for\\n     * @return excessSettlementFunds excess settlement funds, in wei\\n     * @return requiredAmountPosted required amount to be posted by user, in wei\\n     */\\n    function getProjectExcessSettlementFunds(\\n        uint256 projectId,\\n        address coreContract,\\n        address walletAddress\\n    )\\n        internal\\n        view\\n        returns (uint256 excessSettlementFunds, uint256 requiredAmountPosted)\\n    {\\n        // load the project's settlement auction config\\n        SettlementAuctionProjectConfig\\n            storage _settlementAuctionProjectConfig = getSettlementAuctionProjectConfig({\\n                projectId: projectId,\\n                coreContract: coreContract\\n            });\\n        // load the user's receipt\\n        Receipt storage receipt = getReceipt({\\n            walletAddress: walletAddress,\\n            projectId: projectId,\\n            coreContract: coreContract\\n        });\\n        // require that a user has purchased at least one token on this project\\n        uint256 numPurchased = receipt.numPurchased;\\n        require(numPurchased > 0, \\\"No purchases made by this address\\\");\\n\\n        uint256 currentSettledTokenPrice = _settlementAuctionProjectConfig\\n            .latestPurchasePrice;\\n\\n        // calculate the excess settlement funds amount\\n        // implicit overflow/underflow checks in solidity ^0.8\\n        requiredAmountPosted = numPurchased * currentSettledTokenPrice;\\n        excessSettlementFunds = receipt.netPosted - requiredAmountPosted;\\n    }\\n\\n    /**\\n     * @notice Gets price of minting a token on project `projectId` given\\n     * the project's AuctionParameters and current block timestamp.\\n     * Reverts if auction has not yet started or auction is unconfigured, and\\n     * local hasMaxBeenInvoked is false and revenues have not been withdrawn.\\n     * Price is guaranteed to be accurate unless the minter's local\\n     * hasMaxBeenInvoked is stale and returning a false negative.\\n     * @dev when an accurate price is required regardless of the current state\\n     * state of the locally cached minter max invocations, use the less gas\\n     * efficient function `getPriceSafe`.\\n     * @param projectId Project ID to get price of token for.\\n     * @param coreContract Core contract address to get price for.\\n     * @param maxHasBeenInvoked Bool representing if maxHasBeenInvoked for the\\n     * project.\\n     * @return uint256 current price of token in Wei, accurate if minter max\\n     * invocations are up to date\\n     * @dev This method calculates price decay using a linear interpolation\\n     * of exponential decay based on the artist-provided half-life for price\\n     * decay, `priceDecayHalfLifeSeconds`.\\n     */\\n    function getPriceUnsafe(\\n        uint256 projectId,\\n        address coreContract,\\n        bool maxHasBeenInvoked\\n    ) internal view returns (uint256) {\\n        // load the project's settlement auction config\\n        SettlementAuctionProjectConfig\\n            storage settlementAuctionProjectConfig = getSettlementAuctionProjectConfig({\\n                projectId: projectId,\\n                coreContract: coreContract\\n            });\\n        // return latest purchase price if:\\n        // - minter is aware of a sold-out auction (without updating max\\n        // invocation value)\\n        // - auction revenues have been collected, at which point the latest\\n        // purchase price will never change again\\n        if (\\n            maxHasBeenInvoked ||\\n            settlementAuctionProjectConfig.auctionRevenuesCollected\\n        ) {\\n            return settlementAuctionProjectConfig.latestPurchasePrice;\\n        }\\n        // otherwise calculate price based on current block timestamp and\\n        // auction configuration\\n        // @dev this will revert if auction has not yet started or auction is\\n        // unconfigured, which is relied upon for security.\\n        return\\n            DAExpLib.getPriceExp({\\n                projectId: projectId,\\n                coreContract: coreContract\\n            });\\n    }\\n\\n    /**\\n     * @notice Gets price of minting a token on project `projectId` given\\n     * the project's AuctionParameters and current block timestamp.\\n     * This is labeled as \\\"safe\\\", because price is guaranteed to be accurate\\n     * even in the case of a stale locally cached minter max invocations.\\n     * Reverts if auction has not yet started or auction is unconfigured, and\\n     * auction has not sold out or revenues have not been withdrawn.\\n     * @dev This method is less gas efficient than `getPriceUnsafe`, but is\\n     * guaranteed to be accurate.\\n     * @param projectId Project ID to get price of token for.\\n     * @param coreContract Core contract address to get price for.\\n     * @return tokenPriceInWei current price of token in Wei\\n     * @dev This method calculates price decay using a linear interpolation\\n     * of exponential decay based on the artist-provided half-life for price\\n     * decay, `priceDecayHalfLifeSeconds`.\\n     */\\n    function getPriceSafe(\\n        uint256 projectId,\\n        address coreContract\\n    ) internal view returns (uint256 tokenPriceInWei) {\\n        // get up-to-date maxHasBeenInvoked state from core contract\\n        bool maxHasBeenInvokedSafe = MaxInvocationsLib\\n            .projectMaxHasBeenInvokedSafe({\\n                projectId: projectId,\\n                coreContract: coreContract\\n            });\\n        // get price using up-to-date maxHasBeenInvoked state\\n        tokenPriceInWei = getPriceUnsafe({\\n            projectId: projectId,\\n            coreContract: coreContract,\\n            maxHasBeenInvoked: maxHasBeenInvokedSafe\\n        });\\n    }\\n\\n    /**\\n     * @notice Returns if a new auction's start price is valid, given the current\\n     * state of the project's settlement auction configuration.\\n     * @dev does not check for non-zero start price, since startPrice > basePrice\\n     * is checked in DAExpLib.\\n     * @param projectId Project ID to check start price for\\n     * @param coreContract Core contract address to check start price for\\n     * @param startPrice starting price of new auction, in wei\\n     */\\n    function isValidStartPrice(\\n        uint256 projectId,\\n        address coreContract,\\n        uint256 startPrice\\n    ) internal view returns (bool) {\\n        // load the project's settlement auction config\\n        SettlementAuctionProjectConfig\\n            storage settlementAuctionProjectConfig = getSettlementAuctionProjectConfig({\\n                projectId: projectId,\\n                coreContract: coreContract\\n            });\\n        // If previous purchases have been made, require monotonically\\n        // decreasing purchase prices to preserve settlement and revenue\\n        // claiming logic. Since base price is always non-zero, if\\n        // latestPurchasePrice is zero, then no previous purchases have been\\n        // made, and startPrice may be set to any value.\\n        // @dev DAExpLib checks that startPrice > basePrice, so no need to\\n        // check for non-zero startPrice here.\\n        return (settlementAuctionProjectConfig.latestPurchasePrice == 0 || // never purchased\\n            startPrice <= settlementAuctionProjectConfig.latestPurchasePrice);\\n    }\\n\\n    /**\\n     * @notice Loads the SettlementAuctionProjectConfig for a given project and\\n     * core contract.\\n     * @param projectId Project Id to get config for\\n     * @param coreContract Core contract address to get config for\\n     */\\n    function getSettlementAuctionProjectConfig(\\n        uint256 projectId,\\n        address coreContract\\n    ) internal view returns (SettlementAuctionProjectConfig storage) {\\n        return s().settlementAuctionProjectConfigs[coreContract][projectId];\\n    }\\n\\n    /**\\n     * @notice Loads the Receipt for a given user, project and core contract.\\n     * @param walletAddress User address to get receipt for\\n     * @param projectId Project Id to get config for\\n     * @param coreContract Core contract address to get config for\\n     */\\n    function getReceipt(\\n        address walletAddress,\\n        uint256 projectId,\\n        address coreContract\\n    ) internal view returns (Receipt storage) {\\n        return s().receipts[walletAddress][coreContract][projectId];\\n    }\\n\\n    /**\\n     * @notice Return the storage struct for reading and writing. This library\\n     * uses a diamond storage pattern when managing storage.\\n     * @return storageStruct The SettlementExpLibStorage struct.\\n     */\\n    function s()\\n        internal\\n        pure\\n        returns (SettlementExpLibStorage storage storageStruct)\\n    {\\n        bytes32 position = SETTLEMENT_EXP_LIB_STORAGE_POSITION;\\n        assembly (\\\"memory-safe\\\") {\\n            storageStruct.slot := position\\n        }\\n    }\\n\\n    /**\\n     * @notice Returns if all tokens to be auctioned were sold, for a given project.\\n     * Returns false if the number of tokens to be auctioned is zero, since\\n     * that is the default value for unconfigured values.\\n     * @param settlementAuctionProjectConfig The SettlementAuctionProjectConfig\\n     * struct of the project to check.\\n     */\\n    function _allTokensToBeAuctionedWereSold(\\n        SettlementAuctionProjectConfig storage settlementAuctionProjectConfig\\n    ) private view returns (bool) {\\n        // @dev load numAllocations into memory for gas efficiency\\n        uint256 numTokensToBeAuctioned = settlementAuctionProjectConfig\\n            .numTokensToBeAuctioned;\\n        return\\n            numTokensToBeAuctioned > 0 &&\\n            settlementAuctionProjectConfig.numPurchasesOnMinter ==\\n            numTokensToBeAuctioned;\\n    }\\n\\n    /**\\n     * @notice This function updates the receipt to include `msg.value` and increments\\n     * the number of tokens purchased by 1. It then checks that the updated\\n     * receipt is valid (i.e. sufficient funds have been posted for the\\n     * number of tokens purchased on the updated receipt), and reverts if not.\\n     * The new receipt net posted and num purchased are then returned to make\\n     * the values available in a gas-efficient manner to the caller of this\\n     * function.\\n     * @param walletAddress Address of user to update receipt for\\n     * @param projectId Project ID to update receipt for\\n     * @param coreContract Core contract address\\n     * @param currentPriceInWei current price of token in Wei\\n     * @return netPosted total funds posted by user on project (that have not\\n     * been yet settled), including the current transaction\\n     * @return numPurchased total number of tokens purchased by user on\\n     * project, including the current transaction\\n     */\\n    function _validateReceiptEffects(\\n        address walletAddress,\\n        uint256 projectId,\\n        address coreContract,\\n        uint256 currentPriceInWei\\n    ) private returns (uint232 netPosted, uint24 numPurchased) {\\n        Receipt storage receipt = getReceipt({\\n            walletAddress: walletAddress,\\n            projectId: projectId,\\n            coreContract: coreContract\\n        });\\n        // in memory copy + update\\n        netPosted = (receipt.netPosted + msg.value).toUint232();\\n        numPurchased = receipt.numPurchased + 1;\\n\\n        // require sufficient payment on project\\n        require(\\n            netPosted >= numPurchased * currentPriceInWei,\\n            \\\"Min value to mint req.\\\"\\n        );\\n\\n        // update Receipt in storage\\n        receipt.netPosted = netPosted;\\n        receipt.numPurchased = numPurchased;\\n\\n        // emit event indicating new receipt state\\n        emit ReceiptUpdated({\\n            purchaser: msg.sender,\\n            projectId: projectId,\\n            coreContract: coreContract,\\n            numPurchased: numPurchased,\\n            netPosted: netPosted\\n        });\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libs/v0.8.x/minter-libs/SplitFundsLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\n// Created By: Art Blocks Inc.\\n\\npragma solidity ^0.8.0;\\n\\nimport {IMinterBaseV0} from \\\"../../../interfaces/v0.8.x/IMinterBaseV0.sol\\\";\\nimport {IGenArt721CoreContractV3_Base} from \\\"../../../interfaces/v0.8.x/IGenArt721CoreContractV3_Base.sol\\\";\\nimport {IGenArt721CoreContractV3} from \\\"../../../interfaces/v0.8.x/IGenArt721CoreContractV3.sol\\\";\\nimport {IGenArt721CoreContractV3_Engine} from \\\"../../../interfaces/v0.8.x/IGenArt721CoreContractV3_Engine.sol\\\";\\n\\nimport {IERC20} from \\\"@openzeppelin-4.7/contracts/token/ERC20/IERC20.sol\\\";\\n\\n/**\\n * @title Art Blocks Split Funds Library\\n * @notice This library is designed for the Art Blocks platform. It splits\\n * Ether (ETH) and ERC20 token funds among stakeholders, such as sender\\n * (if refund is applicable), providers, artists, and artists' additional\\n * payees.\\n * @author Art Blocks Inc.\\n */\\n\\nlibrary SplitFundsLib {\\n    /**\\n     * @notice Currency updated for project `projectId` to symbol\\n     * `currencySymbol` and address `currencyAddress`.\\n     * @param projectId Project ID currency was updated for\\n     * @param coreContract Core contract address currency was updated for\\n     * @param currencyAddress Currency address\\n     * @param currencySymbol Currency symbol\\n     */\\n    event ProjectCurrencyInfoUpdated(\\n        uint256 indexed projectId,\\n        address indexed coreContract,\\n        address indexed currencyAddress,\\n        string currencySymbol\\n    );\\n\\n    // position of Split Funds Lib storage, using a diamond storage pattern\\n    // for this library\\n    bytes32 constant SPLIT_FUNDS_LIB_STORAGE_POSITION =\\n        keccak256(\\\"splitfundslib.storage\\\");\\n\\n    // contract-level variables\\n    struct IsEngineCache {\\n        bool isEngine;\\n        bool isCached;\\n    }\\n\\n    // project-level variables\\n    struct SplitFundsProjectConfig {\\n        address currencyAddress; // address(0) if ETH\\n        string currencySymbol; // Assumed to be ETH if null\\n    }\\n\\n    // Diamond storage pattern is used in this library\\n    struct SplitFundsLibStorage {\\n        mapping(address coreContract => mapping(uint256 projectId => SplitFundsProjectConfig)) splitFundsProjectConfigs;\\n        mapping(address coreContract => IsEngineCache) isEngineCacheConfigs;\\n    }\\n\\n    /**\\n     * @notice splits ETH funds between sender (if refund), providers,\\n     * artist, and artist's additional payee for a token purchased on\\n     * project `projectId`.\\n     * WARNING: This function uses msg.value and msg.sender to determine\\n     * refund amounts, and therefore may not be applicable to all use cases\\n     * (e.g. do not use with Dutch Auctions with on-chain settlement).\\n     * @dev This function relies on msg.sender and msg.value, so it must be\\n     * called directly from the contract that is receiving the payment.\\n     * @dev possible DoS during splits is acknowledged, and mitigated by\\n     * business practices, including end-to-end testing on mainnet, and\\n     * admin-accepted artist payment addresses.\\n     * @param projectId Project ID for which funds shall be split.\\n     * @param pricePerTokenInWei Current price of token, in Wei.\\n     * @param coreContract Address of the GenArt721CoreContract associated\\n     * with the project.\\n     */\\n    function splitFundsETHRefundSender(\\n        uint256 projectId,\\n        uint256 pricePerTokenInWei,\\n        address coreContract\\n    ) internal {\\n        if (msg.value > 0) {\\n            // send refund to sender\\n            uint256 refund = msg.value - pricePerTokenInWei;\\n            if (refund > 0) {\\n                (bool success_, ) = msg.sender.call{value: refund}(\\\"\\\");\\n                require(success_, \\\"Refund failed\\\");\\n            }\\n            // split revenues\\n            splitRevenuesETHNoRefund({\\n                projectId: projectId,\\n                valueInWei: pricePerTokenInWei,\\n                coreContract: coreContract\\n            });\\n        }\\n    }\\n\\n    /**\\n     * @notice Splits ETH revenues between providers, artist, and artist's\\n     * additional payee for revenue generated by project `projectId`.\\n     * This function does NOT refund msg.sender, and does NOT use msg.value\\n     * when determining the value to be split.\\n     * @dev possible DoS during splits is acknowledged, and mitigated by\\n     * business practices, including end-to-end testing on mainnet, and\\n     * admin-accepted artist payment addresses.\\n     * @param projectId Project ID for which funds shall be split.\\n     * @param valueInWei Value to be split, in Wei.\\n     * @param coreContract Address of the GenArt721CoreContract\\n     * associated with the project.\\n     */\\n    function splitRevenuesETHNoRefund(\\n        uint256 projectId,\\n        uint256 valueInWei,\\n        address coreContract\\n    ) internal {\\n        if (valueInWei == 0) {\\n            return; // return early\\n        }\\n        // split funds between platforms, artist, and artist's\\n        // additional payee\\n        bool isEngine_ = isEngine(coreContract);\\n        uint256 renderProviderRevenue;\\n        address payable renderProviderAddress;\\n        uint256 platformProviderRevenue;\\n        address payable platformProviderAddress;\\n        uint256 artistRevenue;\\n        address payable artistAddress;\\n        uint256 additionalPayeePrimaryRevenue;\\n        address payable additionalPayeePrimaryAddress;\\n        if (isEngine_) {\\n            // get engine splits\\n            (\\n                renderProviderRevenue,\\n                renderProviderAddress,\\n                platformProviderRevenue,\\n                platformProviderAddress,\\n                artistRevenue,\\n                artistAddress,\\n                additionalPayeePrimaryRevenue,\\n                additionalPayeePrimaryAddress\\n            ) = IGenArt721CoreContractV3_Engine(coreContract)\\n                .getPrimaryRevenueSplits({\\n                    _projectId: projectId,\\n                    _price: valueInWei\\n                });\\n        } else {\\n            // get flagship splits\\n            // @dev note that platformProviderAddress and\\n            // platformProviderRevenue remain 0 for flagship\\n            (\\n                renderProviderRevenue, // artblocks revenue\\n                renderProviderAddress, // artblocks address\\n                artistRevenue,\\n                artistAddress,\\n                additionalPayeePrimaryRevenue,\\n                additionalPayeePrimaryAddress\\n            ) = IGenArt721CoreContractV3(coreContract).getPrimaryRevenueSplits({\\n                _projectId: projectId,\\n                _price: valueInWei\\n            });\\n        }\\n        // require total revenue split is 100%\\n        // @dev note that platformProviderRevenue remains 0 for flagship\\n        require(\\n            renderProviderRevenue +\\n                platformProviderRevenue +\\n                artistRevenue +\\n                additionalPayeePrimaryRevenue ==\\n                valueInWei,\\n            \\\"Invalid revenue split totals\\\"\\n        );\\n        // distribute revenues\\n        // @dev note that platformProviderAddress and platformProviderRevenue\\n        // remain 0 for flagship\\n        _sendPaymentsETH({\\n            platformProviderRevenue: platformProviderRevenue,\\n            platformProviderAddress: platformProviderAddress,\\n            renderProviderRevenue: renderProviderRevenue,\\n            renderProviderAddress: renderProviderAddress,\\n            artistRevenue: artistRevenue,\\n            artistAddress: artistAddress,\\n            additionalPayeePrimaryRevenue: additionalPayeePrimaryRevenue,\\n            additionalPayeePrimaryAddress: additionalPayeePrimaryAddress\\n        });\\n    }\\n\\n    /**\\n     * @notice Splits ERC20 funds between providers, artist, and artist's\\n     * additional payee, for a token purchased on project `projectId`.\\n     * The function performs checks to ensure that the ERC20 token is\\n     * approved for transfer, and that a non-zero ERC20 token address is\\n     * configured.\\n     * @dev This function relies on msg.sender, so it must be\\n     * called directly from the contract that is receiving the payment.\\n     * @dev possible DoS during splits is acknowledged, and mitigated by\\n     * business practices, including end-to-end testing on mainnet, and\\n     * admin-accepted artist payment addresses.\\n     * @param projectId Project ID for which funds shall be split.\\n     * @param pricePerToken Current price of token, in base units. For example,\\n     * if the ERC20 token has 6 decimals, an input value of `1_000_000` would\\n     * represent a price of `1.000000` tokens.\\n     * @param coreContract Core contract address.\\n     */\\n    function splitFundsERC20(\\n        uint256 projectId,\\n        uint256 pricePerToken,\\n        address coreContract\\n    ) internal {\\n        if (pricePerToken == 0) {\\n            return; // nothing to split, return early\\n        }\\n        IERC20 projectCurrency;\\n        // block scope to avoid stack too deep error\\n        {\\n            SplitFundsProjectConfig\\n                storage splitFundsProjectConfig = getSplitFundsProjectConfig({\\n                    projectId: projectId,\\n                    coreContract: coreContract\\n                });\\n            address currencyAddress = splitFundsProjectConfig.currencyAddress;\\n            require(\\n                currencyAddress != address(0),\\n                \\\"ERC20: payment not configured\\\"\\n            );\\n            // ERC20 token is used for payment\\n            validateERC20Approvals({\\n                msgSender: msg.sender,\\n                currencyAddress: currencyAddress,\\n                pricePerToken: pricePerToken\\n            });\\n            projectCurrency = IERC20(currencyAddress);\\n        }\\n        // split remaining funds between foundation, artist, and artist's\\n        bool isEngine_ = isEngine(coreContract);\\n        uint256 renderProviderRevenue;\\n        address payable renderProviderAddress;\\n        uint256 platformProviderRevenue;\\n        address payable platformProviderAddress;\\n        uint256 artistRevenue;\\n        address payable artistAddress;\\n        uint256 additionalPayeePrimaryRevenue;\\n        address payable additionalPayeePrimaryAddress;\\n        if (isEngine_) {\\n            // get engine splits\\n            (\\n                renderProviderRevenue,\\n                renderProviderAddress,\\n                platformProviderRevenue,\\n                platformProviderAddress,\\n                artistRevenue,\\n                artistAddress,\\n                additionalPayeePrimaryRevenue,\\n                additionalPayeePrimaryAddress\\n            ) = IGenArt721CoreContractV3_Engine(coreContract)\\n                .getPrimaryRevenueSplits({\\n                    _projectId: projectId,\\n                    _price: pricePerToken\\n                });\\n        } else {\\n            // get flagship splits\\n            // @dev note that platformProviderAddress and\\n            // platformProviderRevenue remain 0 for flagship\\n            (\\n                renderProviderRevenue, // artblocks revenue\\n                renderProviderAddress, // artblocks address\\n                artistRevenue,\\n                artistAddress,\\n                additionalPayeePrimaryRevenue,\\n                additionalPayeePrimaryAddress\\n            ) = IGenArt721CoreContractV3(coreContract).getPrimaryRevenueSplits({\\n                _projectId: projectId,\\n                _price: pricePerToken\\n            });\\n        }\\n        // require total revenue split is 100%\\n        // @dev note that platformProviderRevenue remains 0 for flagship\\n        require(\\n            renderProviderRevenue +\\n                platformProviderRevenue +\\n                artistRevenue +\\n                additionalPayeePrimaryRevenue ==\\n                pricePerToken,\\n            \\\"Invalid revenue split totals\\\"\\n        );\\n        // distribute revenues\\n        // @dev note that platformProviderAddress and platformProviderRevenue\\n        // remain 0 for flagship\\n        _sendPaymentsERC20({\\n            projectCurrency: projectCurrency,\\n            platformProviderRevenue: platformProviderRevenue,\\n            platformProviderAddress: platformProviderAddress,\\n            renderProviderRevenue: renderProviderRevenue,\\n            renderProviderAddress: renderProviderAddress,\\n            artistRevenue: artistRevenue,\\n            artistAddress: artistAddress,\\n            additionalPayeePrimaryRevenue: additionalPayeePrimaryRevenue,\\n            additionalPayeePrimaryAddress: additionalPayeePrimaryAddress\\n        });\\n    }\\n\\n    /**\\n     * @notice Updates payment currency of the referenced\\n     * SplitFundsProjectConfig to be `currencySymbol` at address\\n     * `currencyAddress`.\\n     * Only supports setting currency info of ERC20 tokens.\\n     * Returns bool that is true if the price should be reset after this\\n     * update. Price is recommended to be reset if the currency address was\\n     * previously configured, but is now being updated to a different currency\\n     * address. This is to protect accidental price reductions when changing\\n     * currency if an artist is changing currencies in an unpaused state.\\n     * @dev artist-defined currency symbol is used instead of any on-chain\\n     * currency symbol.\\n     * @param projectId Project ID to update.\\n     * @param coreContract Core contract address.\\n     * @param currencySymbol Currency symbol.\\n     * @param currencyAddress Currency address.\\n     * @return recommendPriceReset True if the price should be reset after this\\n     * update.\\n     */\\n    function updateProjectCurrencyInfoERC20(\\n        uint256 projectId,\\n        address coreContract,\\n        string memory currencySymbol,\\n        address currencyAddress\\n    ) internal returns (bool recommendPriceReset) {\\n        // CHECKS\\n        require(currencyAddress != address(0), \\\"null address, only ERC20\\\");\\n        require(bytes(currencySymbol).length > 0, \\\"only non-null symbol\\\");\\n        // EFFECTS\\n        SplitFundsProjectConfig\\n            storage splitFundsProjectConfig = getSplitFundsProjectConfig({\\n                projectId: projectId,\\n                coreContract: coreContract\\n            });\\n        // recommend price reset if currency address was previously configured\\n        recommendPriceReset = (splitFundsProjectConfig.currencyAddress !=\\n            address(0));\\n        splitFundsProjectConfig.currencySymbol = currencySymbol;\\n        splitFundsProjectConfig.currencyAddress = currencyAddress;\\n\\n        emit ProjectCurrencyInfoUpdated({\\n            projectId: projectId,\\n            coreContract: coreContract,\\n            currencyAddress: currencyAddress,\\n            currencySymbol: currencySymbol\\n        });\\n    }\\n\\n    /**\\n     * @notice Force sends `amount` (in wei) ETH to `to`, with a gas stipend\\n     * equal to `minterRefundGasLimit`.\\n     * If sending via the normal procedure fails, force sends the ETH by\\n     * creating a temporary contract which uses `SELFDESTRUCT` to force send\\n     * the ETH.\\n     * Reverts if the current contract has insufficient balance.\\n     * @param to The address to send ETH to.\\n     * @param amount The amount of ETH to send.\\n     * @param minterRefundGasLimit The gas limit to use when sending ETH, prior\\n     * to fallback.\\n     * @dev This function is adapted from the `forceSafeTransferETH` function\\n     * in the `https://github.com/Vectorized/solady` repository, with\\n     * modifications to not check if the current contract has sufficient\\n     * balance. Therefore, the contract should be checked for sufficient\\n     * balance before calling this function in the minter itself, if\\n     * applicable.\\n     */\\n    function forceSafeTransferETH(\\n        address to,\\n        uint256 amount,\\n        uint256 minterRefundGasLimit\\n    ) internal {\\n        // Manually inlined because the compiler doesn't inline functions with\\n        // branches.\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // @dev intentionally do not check if this contract has sufficient\\n            // balance, because that is not intended to be a valid state.\\n\\n            // Transfer the ETH and check if it succeeded or not.\\n            if iszero(call(minterRefundGasLimit, to, amount, 0, 0, 0, 0)) {\\n                // if the transfer failed, we create a temporary contract with\\n                // initialization code that uses `SELFDESTRUCT` to force send\\n                // the ETH.\\n                // note: Compatible with `SENDALL`:\\n                // https://eips.ethereum.org/EIPS/eip-4758\\n\\n                //---------------------------------------------------------------------------------------------------------------//\\n                // Opcode  | Opcode + Arguments  | Description        | Stack View                                               //\\n                //---------------------------------------------------------------------------------------------------------------//\\n                // Contract creation code that uses `SELFDESTRUCT` to force send ETH to a specified address.                     //\\n                // Creation code summary: 0x73<20-byte toAddress>0xff                                                            //\\n                //---------------------------------------------------------------------------------------------------------------//\\n                // 0x73    |  0x73_toAddress     | PUSH20 toAddress   | toAddress                                                //\\n                // 0xFF    |  0xFF               | SELFDESTRUCT       |                                                          //\\n                //---------------------------------------------------------------------------------------------------------------//\\n                // Store the address in scratch space, starting at 0x00, which begins the 20-byte address at 32-20=12 in memory\\n                // @dev use scratch space because we have enough space for simple creation code (less than 0x40 bytes)\\n                mstore(0x00, to)\\n                // store opcode PUSH20 immediately before the address, starting at 0x0b (11) in memory\\n                mstore8(0x0b, 0x73)\\n                // store opcode SELFDESTRUCT immediately after the address, starting at 0x20 (32) in memory\\n                mstore8(0x20, 0xff)\\n                // this will always succeed because the contract creation code is\\n                // valid, and the address is valid because it is a 20-byte value\\n                if iszero(create(amount, 0x0b, 0x16)) {\\n                    // @dev For better gas estimation.\\n                    if iszero(gt(gas(), 1000000)) {\\n                        revert(0, 0)\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Returns whether or not the provided address `coreContract`\\n     * is an Art Blocks Engine core contract. Caches the result for future access.\\n     * @param coreContract Address of the core contract to check.\\n     */\\n    function isEngine(address coreContract) internal returns (bool) {\\n        IsEngineCache storage isEngineCache = getIsEngineCacheConfig(\\n            coreContract\\n        );\\n        // check cache, return early if cached\\n        if (isEngineCache.isCached) {\\n            return isEngineCache.isEngine;\\n        }\\n        // populate cache and return result\\n        bool isEngine_ = getV3CoreIsEngineView(coreContract);\\n        isEngineCache.isCached = true;\\n        isEngineCache.isEngine = isEngine_;\\n        return isEngine_;\\n    }\\n\\n    /**\\n     * @notice Returns whether a V3 core contract is an Art Blocks Engine\\n     * contract or not. Return value of false indicates that the core is a\\n     * flagship contract. This function does not update the cache state for the\\n     * given V3 core contract.\\n     * @dev this function reverts if a core contract does not return the\\n     * expected number of return values from getPrimaryRevenueSplits() for\\n     * either a flagship or engine core contract.\\n     * @dev this function uses the length of the return data (in bytes) to\\n     * determine whether the core is an engine or not.\\n     * @param coreContract The address of the deployed core contract.\\n     */\\n    function getV3CoreIsEngineView(\\n        address coreContract\\n    ) internal view returns (bool) {\\n        // call getPrimaryRevenueSplits() on core contract\\n        bytes memory payload = abi.encodeWithSignature(\\n            \\\"getPrimaryRevenueSplits(uint256,uint256)\\\",\\n            0,\\n            0\\n        );\\n        (bool success, bytes memory returnData) = coreContract.staticcall(\\n            payload\\n        );\\n        require(success, \\\"getPrimaryRevenueSplits() call failed\\\");\\n        // determine whether core is engine or not, based on return data length\\n        uint256 returnDataLength = returnData.length;\\n        if (returnDataLength == 6 * 32) {\\n            // 6 32-byte words returned if flagship (not engine)\\n            // @dev 6 32-byte words are expected because the non-engine core\\n            // contracts return a payout address and uint256 payment value for\\n            // the artist, and artist's additional payee, and Art Blocks.\\n            // also note that per Solidity ABI encoding, the address return\\n            // values are padded to 32 bytes.\\n\\n            return false;\\n        } else if (returnDataLength == 8 * 32) {\\n            // 8 32-byte words returned if engine\\n            // @dev 8 32-byte words are expected because the engine core\\n            // contracts return a payout address and uint256 payment value for\\n            // the artist, artist's additional payee, render provider\\n            // typically Art Blocks, and platform provider (partner).\\n            // also note that per Solidity ABI encoding, the address return\\n            // values are padded to 32 bytes.\\n            return true;\\n        }\\n        // unexpected return value length\\n        revert(\\\"Unexpected revenue split bytes\\\");\\n    }\\n\\n    /**\\n     * @notice Gets the currency address and symbol for the referenced\\n     * SplitFundsProjectConfig.\\n     * Only supports ERC20 tokens - returns currencySymbol of `UNCONFIG` if\\n     * `currencyAddress` is zero.\\n     * @param projectId Project ID to get config for\\n     * @param coreContract Core contract address to get config for\\n     * @return currencyAddress\\n     * @return currencySymbol\\n     */\\n    function getCurrencyInfoERC20(\\n        uint256 projectId,\\n        address coreContract\\n    )\\n        internal\\n        view\\n        returns (address currencyAddress, string memory currencySymbol)\\n    {\\n        SplitFundsProjectConfig\\n            storage splitFundsProjectConfig = getSplitFundsProjectConfig({\\n                projectId: projectId,\\n                coreContract: coreContract\\n            });\\n        currencyAddress = splitFundsProjectConfig.currencyAddress;\\n        // default to \\\"UNCONFIG\\\" if project currency address is initial value\\n        currencySymbol = currencyAddress == address(0)\\n            ? \\\"UNCONFIG\\\"\\n            : splitFundsProjectConfig.currencySymbol;\\n    }\\n\\n    /**\\n     * @notice Gets the balance of `currencyAddress` ERC20 tokens for `walletAddress`.\\n     * @param currencyAddress ERC20 token address.\\n     * @param walletAddress wallet address.\\n     * @return balance\\n     */\\n    function getERC20Balance(\\n        address currencyAddress,\\n        address walletAddress\\n    ) internal view returns (uint256) {\\n        return IERC20(currencyAddress).balanceOf(walletAddress);\\n    }\\n\\n    /**\\n     * @notice Gets the allowance of `spenderAddress` to spend `walletAddress`'s\\n     * `currencyAddress` ERC20 tokens.\\n     * @param currencyAddress ERC20 token address.\\n     * @param walletAddress wallet address.\\n     * @param spenderAddress spender address.\\n     * @return allowance\\n     */\\n    function getERC20Allowance(\\n        address currencyAddress,\\n        address walletAddress,\\n        address spenderAddress\\n    ) internal view returns (uint256 allowance) {\\n        allowance = IERC20(currencyAddress).allowance({\\n            owner: walletAddress,\\n            spender: spenderAddress\\n        });\\n        return allowance;\\n    }\\n\\n    /**\\n     * @notice Function validates that `msgSender` has approved the contract to spend at least\\n     * `pricePerToken` of `currencyAddress` ERC20 tokens, and that\\n     * `msgSender` has a balance of at least `pricePerToken` of\\n     * `currencyAddress` ERC20 tokens.\\n     * Reverts if insufficient allowance or balance.\\n     * @param msgSender Address of the message sender to validate.\\n     * @param currencyAddress Address of the ERC20 token to validate.\\n     * @param pricePerToken Price of token, in base units. For example,\\n     * if the ERC20 token has 6 decimals, an input value of `1_000_000` would\\n     * represent a price of `1.000000` tokens.\\n     */\\n    function validateERC20Approvals(\\n        address msgSender,\\n        address currencyAddress,\\n        uint256 pricePerToken\\n    ) private view {\\n        require(\\n            IERC20(currencyAddress).allowance({\\n                owner: msgSender,\\n                spender: address(this)\\n            }) >= pricePerToken,\\n            \\\"Insufficient ERC20 allowance\\\"\\n        );\\n        require(\\n            IERC20(currencyAddress).balanceOf(msgSender) >= pricePerToken,\\n            \\\"Insufficient ERC20 balance\\\"\\n        );\\n    }\\n\\n    /**\\n     * @notice Sends ETH revenues between providers, artist, and artist's\\n     * additional payee. Reverts if any payment fails.\\n     * @dev This function pays priviliged addresses. DoS is acknowledged, and\\n     * mitigated by business practices, including end-to-end testing on\\n     * mainnet, and admin-accepted artist payment addresses.\\n     * @param platformProviderRevenue Platform Provider revenue.\\n     * @param platformProviderAddress Platform Provider address.\\n     * @param renderProviderRevenue Render Provider revenue.\\n     * @param renderProviderAddress Render Provider address.\\n     * @param artistRevenue Artist revenue.\\n     * @param artistAddress Artist address.\\n     * @param additionalPayeePrimaryRevenue Additional Payee revenue.\\n     * @param additionalPayeePrimaryAddress Additional Payee address.\\n     */\\n    function _sendPaymentsETH(\\n        uint256 platformProviderRevenue,\\n        address payable platformProviderAddress,\\n        uint256 renderProviderRevenue,\\n        address payable renderProviderAddress,\\n        uint256 artistRevenue,\\n        address payable artistAddress,\\n        uint256 additionalPayeePrimaryRevenue,\\n        address payable additionalPayeePrimaryAddress\\n    ) private {\\n        // Platform Provider payment (only possible if engine)\\n        if (platformProviderRevenue > 0) {\\n            (bool success, ) = platformProviderAddress.call{\\n                value: platformProviderRevenue\\n            }(\\\"\\\");\\n            require(success, \\\"Platform Provider payment failed\\\");\\n        }\\n        // Render Provider / Art Blocks payment\\n        if (renderProviderRevenue > 0) {\\n            (bool success, ) = renderProviderAddress.call{\\n                value: renderProviderRevenue\\n            }(\\\"\\\");\\n            require(success, \\\"Render Provider payment failed\\\");\\n        }\\n        // artist payment\\n        if (artistRevenue > 0) {\\n            (bool success, ) = artistAddress.call{value: artistRevenue}(\\\"\\\");\\n            require(success, \\\"Artist payment failed\\\");\\n        }\\n        // additional payee payment\\n        if (additionalPayeePrimaryRevenue > 0) {\\n            (bool success, ) = additionalPayeePrimaryAddress.call{\\n                value: additionalPayeePrimaryRevenue\\n            }(\\\"\\\");\\n            require(success, \\\"Additional Payee payment failed\\\");\\n        }\\n    }\\n\\n    /**\\n     * @notice Sends ERC20 revenues between providers, artist, and artist's\\n     * additional payee. Reverts if any payment fails. All revenue values\\n     * should use base units. For example, if the ERC20 token has 6 decimals,\\n     * an input value of `1_000_000` would represent an amount of `1.000000`\\n     * tokens.\\n     * @dev This function relies on msg.sender, so it must be called from\\n     * the contract that is receiving the payment.\\n     * @param projectCurrency IERC20 payment token.\\n     * @param platformProviderRevenue Platform Provider revenue.\\n     * @param platformProviderAddress Platform Provider address.\\n     * @param renderProviderRevenue Render Provider revenue.\\n     * @param renderProviderAddress Render Provider address.\\n     * @param artistRevenue Artist revenue.\\n     * @param artistAddress Artist address.\\n     * @param additionalPayeePrimaryRevenue Additional Payee revenue.\\n     * @param additionalPayeePrimaryAddress Additional Payee address.\\n     */\\n    function _sendPaymentsERC20(\\n        IERC20 projectCurrency,\\n        uint256 platformProviderRevenue,\\n        address payable platformProviderAddress,\\n        uint256 renderProviderRevenue,\\n        address payable renderProviderAddress,\\n        uint256 artistRevenue,\\n        address payable artistAddress,\\n        uint256 additionalPayeePrimaryRevenue,\\n        address payable additionalPayeePrimaryAddress\\n    ) private {\\n        // Platform Provider payment (only possible if engine)\\n        if (platformProviderRevenue > 0) {\\n            require(\\n                projectCurrency.transferFrom({\\n                    from: msg.sender,\\n                    to: platformProviderAddress,\\n                    amount: platformProviderRevenue\\n                }),\\n                \\\"Platform Provider payment failed\\\"\\n            );\\n        }\\n        // Art Blocks payment\\n        if (renderProviderRevenue > 0) {\\n            require(\\n                projectCurrency.transferFrom({\\n                    from: msg.sender,\\n                    to: renderProviderAddress,\\n                    amount: renderProviderRevenue\\n                }),\\n                \\\"Render Provider payment failed\\\"\\n            );\\n        }\\n        // artist payment\\n        if (artistRevenue > 0) {\\n            require(\\n                projectCurrency.transferFrom({\\n                    from: msg.sender,\\n                    to: artistAddress,\\n                    amount: artistRevenue\\n                }),\\n                \\\"Artist payment failed\\\"\\n            );\\n        }\\n        // additional payee payment\\n        if (additionalPayeePrimaryRevenue > 0) {\\n            // @dev some ERC20 may not revert on transfer failure, so we\\n            // check the return value\\n            require(\\n                projectCurrency.transferFrom({\\n                    from: msg.sender,\\n                    to: additionalPayeePrimaryAddress,\\n                    amount: additionalPayeePrimaryRevenue\\n                }),\\n                \\\"Additional Payee payment failed\\\"\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @notice Loads the SplitFundsProjectConfig for a given project and core\\n     * contract.\\n     * @param projectId Project Id to get config for\\n     * @param coreContract Core contract address to get config for\\n     */\\n    function getSplitFundsProjectConfig(\\n        uint256 projectId,\\n        address coreContract\\n    ) internal view returns (SplitFundsProjectConfig storage) {\\n        return s().splitFundsProjectConfigs[coreContract][projectId];\\n    }\\n\\n    /**\\n     * @notice Loads the IsEngineCache for a given core contract.\\n     * @param coreContract Core contract address to get config for\\n     */\\n    function getIsEngineCacheConfig(\\n        address coreContract\\n    ) internal view returns (IsEngineCache storage) {\\n        return s().isEngineCacheConfigs[coreContract];\\n    }\\n\\n    /**\\n     * @notice Return the storage struct for reading and writing. This library\\n     * uses a diamond storage pattern when managing storage.\\n     * @return storageStruct The SetPriceLibStorage struct.\\n     */\\n    function s()\\n        internal\\n        pure\\n        returns (SplitFundsLibStorage storage storageStruct)\\n    {\\n        bytes32 position = SPLIT_FUNDS_LIB_STORAGE_POSITION;\\n        assembly (\\\"memory-safe\\\") {\\n            storageStruct.slot := position\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/minter-suite/Minters/MinterDAExpSettlementV3.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\n// Created By: Art Blocks Inc.\\n\\n// @dev fixed to specific solidity version for clarity and for more clear\\n// source code verification purposes.\\npragma solidity 0.8.19;\\n\\nimport {ISharedMinterSimplePurchaseV0} from \\\"../../interfaces/v0.8.x/ISharedMinterSimplePurchaseV0.sol\\\";\\nimport {ISharedMinterV0} from \\\"../../interfaces/v0.8.x/ISharedMinterV0.sol\\\";\\nimport {ISharedMinterDAV0} from \\\"../../interfaces/v0.8.x/ISharedMinterDAV0.sol\\\";\\nimport {ISharedMinterDAExpV0} from \\\"../../interfaces/v0.8.x/ISharedMinterDAExpV0.sol\\\";\\nimport {ISharedMinterDAExpSettlementV0} from \\\"../../interfaces/v0.8.x/ISharedMinterDAExpSettlementV0.sol\\\";\\nimport {IMinterFilterV1} from \\\"../../interfaces/v0.8.x/IMinterFilterV1.sol\\\";\\n\\nimport {SettlementExpLib} from \\\"../../libs/v0.8.x/minter-libs/SettlementExpLib.sol\\\";\\nimport {SplitFundsLib} from \\\"../../libs/v0.8.x/minter-libs/SplitFundsLib.sol\\\";\\nimport {MaxInvocationsLib} from \\\"../../libs/v0.8.x/minter-libs/MaxInvocationsLib.sol\\\";\\nimport {DAExpLib} from \\\"../../libs/v0.8.x/minter-libs/DAExpLib.sol\\\";\\nimport {AuthLib} from \\\"../../libs/v0.8.x/AuthLib.sol\\\";\\n\\nimport {SafeCast} from \\\"@openzeppelin-4.7/contracts/utils/math/SafeCast.sol\\\";\\nimport {ReentrancyGuard} from \\\"@openzeppelin-4.5/contracts/security/ReentrancyGuard.sol\\\";\\n\\n/**\\n * @title Shared, filtered Minter contract that allows tokens to be minted with\\n * ETH.\\n * Pricing is achieved using an automated Dutch-auction mechanism, with a\\n * settlement mechanism for tokens purchased before the auction ends.\\n * This is designed to be used with GenArt721CoreContractV3 flagship or\\n * engine contracts.\\n * @author Art Blocks Inc.\\n * @notice Privileged Roles and Ownership:\\n * This contract is designed to be managed, with limited powers.\\n * Privileged roles and abilities are controlled by the core contract's Admin\\n * ACL contract and a project's artist. Both of these roles hold extensive\\n * power and can modify minter details.\\n * Care must be taken to ensure that the admin ACL contract and artist\\n * addresses are secure behind a multi-sig or other access control mechanism.\\n * Additionally, the purchaser of a token has some trust assumptions regarding\\n * settlement, beyond typical minter Art Blocks trust assumptions. In general,\\n * Artists and Admin are trusted to not abuse their powers in a way that\\n * would artifically inflate the sellout price of a project. They are\\n * incentivized to not do so, as it would diminish their reputation and\\n * ability to sell future projects. Agreements between Admin and Artist\\n * may or may not be in place to further dissuade artificial inflation of an\\n * auction's sellout price.\\n * ----------------------------------------------------------------------------\\n * The following functions are restricted to the minter filter's Admin ACL\\n * contract:\\n * - setMinimumPriceDecayHalfLifeSeconds\\n * ----------------------------------------------------------------------------\\n * The following functions are restricted to the core contract's Admin ACL\\n * contract:\\n * - resetAuctionDetails (note: this will prevent minting until a new auction\\n *   is created)\\n * ----------------------------------------------------------------------------\\n * The following functions are restricted to a project's artist or the core\\n * contract's Admin ACL contract:\\n * - withdrawArtistAndAdminRevenues (note: this may only be called after an\\n *   auction has sold out or has reached base price)\\n * ----------------------------------------------------------------------------\\n * The following functions are restricted to a project's artist:\\n * - setAuctionDetails (note: this may only be called when there is no active\\n *   auction, and must start at a price less than or equal to any previously\\n *   made purchases)\\n * - manuallyLimitProjectMaxInvocations\\n * - syncProjectMaxInvocationsToCore (not implemented)\\n * ----------------------------------------------------------------------------\\n * Additional admin and artist privileged roles may be described on other\\n * contracts that this minter integrates with.\\n * ----------------------------------------------------------------------------\\n * @notice Caution: While Engine projects must be registered on the Art Blocks\\n * Core Registry to assign this minter, this minter does not enforce that a\\n * project is registered when configured or queried. This is primarily for gas\\n * optimization purposes. It is, therefore, possible that fake projects may be\\n * configured on this minter, but they will not be able to mint tokens due to\\n * checks performed by this minter's Minter Filter.\\n *\\n * @dev Note that while this minter makes use of `block.timestamp` and it is\\n * technically possible that this value is manipulated by block producers via\\n * denial of service (in PoS), such manipulation will not have material impact\\n * on the price values of this minter given the business practices for how\\n * pricing is congfigured for this minter and that variations on the order of\\n * less than a minute should not meaningfully impact price given the minimum\\n * allowable price decay rate that this minter intends to support.\\n */\\ncontract MinterDAExpSettlementV3 is\\n    ReentrancyGuard,\\n    ISharedMinterSimplePurchaseV0,\\n    ISharedMinterV0,\\n    ISharedMinterDAV0,\\n    ISharedMinterDAExpV0,\\n    ISharedMinterDAExpSettlementV0\\n{\\n    using SafeCast for uint256;\\n\\n    /// @notice Minter filter address this minter interacts with\\n    address public immutable minterFilterAddress;\\n\\n    /// @notice Minter filter this minter may interact with.\\n    IMinterFilterV1 private immutable _minterFilter;\\n\\n    /// @notice minterType for this minter\\n    string public constant minterType = \\\"MinterDAExpSettlementV3\\\";\\n\\n    /// @notice minter version for this minter\\n    string public constant minterVersion = \\\"v3.0.0\\\";\\n\\n    /// @notice Minimum price decay half life: price can decay with a half life of a\\n    /// minimum of this amount (can cut in half a minimum of every N seconds).\\n    uint256 public minimumPriceDecayHalfLifeSeconds = 45; // 45 seconds\\n\\n    /**\\n     * @notice Initializes contract to be a Filtered Minter for\\n     * `minterFilter` minter filter.\\n     * @param minterFilter Minter filter for which this will be a\\n     * filtered minter.\\n     */\\n    constructor(address minterFilter) ReentrancyGuard() {\\n        minterFilterAddress = minterFilter;\\n        _minterFilter = IMinterFilterV1(minterFilter);\\n        emit DAExpLib.AuctionMinHalfLifeSecondsUpdated(\\n            minimumPriceDecayHalfLifeSeconds\\n        );\\n    }\\n\\n    /**\\n     * @notice Manually sets the local maximum invocations of project `projectId`\\n     * with the provided `maxInvocations`, checking that `maxInvocations` is less\\n     * than or equal to the value of project `project_id`'s maximum invocations that is\\n     * set on the core contract.\\n     * @dev Note that a `maxInvocations` of 0 can only be set if the current `invocations`\\n     * value is also 0 and this would also set `maxHasBeenInvoked` to true, correctly short-circuiting\\n     * this minter's purchase function, avoiding extra gas costs from the core contract's maxInvocations check.\\n     * @param projectId Project ID to set the maximum invocations for.\\n     * @param coreContract Core contract address for the given project.\\n     * @param maxInvocations Maximum invocations to set for the project.\\n     */\\n    function manuallyLimitProjectMaxInvocations(\\n        uint256 projectId,\\n        address coreContract,\\n        uint24 maxInvocations\\n    ) external {\\n        AuthLib.onlyArtist({\\n            projectId: projectId,\\n            coreContract: coreContract,\\n            sender: msg.sender\\n        });\\n        // @dev guard rail to prevent accidentally adjusting max invocations\\n        // after one or more purchases have been made\\n        require(\\n            SettlementExpLib.getNumPurchasesOnMinter({\\n                projectId: projectId,\\n                coreContract: coreContract\\n            }) == 0,\\n            \\\"Only before purchases\\\"\\n        );\\n        MaxInvocationsLib.manuallyLimitProjectMaxInvocations({\\n            projectId: projectId,\\n            coreContract: coreContract,\\n            maxInvocations: maxInvocations\\n        });\\n    }\\n\\n    /**\\n     * @notice Sets auction details for project `projectId`.\\n     * @param projectId Project ID to set auction details for.\\n     * @param coreContract Core contract address for the given project.\\n     * @param auctionTimestampStart Timestamp at which to start the auction.\\n     * @param priceDecayHalfLifeSeconds The half life with which to decay the\\n     *  price (in seconds).\\n     * @param startPrice Price at which to start the auction, in Wei.\\n     * @param basePrice Resting price of the auction, in Wei.\\n     * @dev Note that a basePrice of `0` will cause the transaction to revert.\\n     */\\n    function setAuctionDetails(\\n        uint256 projectId,\\n        address coreContract,\\n        uint40 auctionTimestampStart,\\n        uint40 priceDecayHalfLifeSeconds,\\n        uint256 startPrice,\\n        uint256 basePrice\\n    ) external {\\n        AuthLib.onlyArtist({\\n            projectId: projectId,\\n            coreContract: coreContract,\\n            sender: msg.sender\\n        });\\n        // CHECKS\\n        // require valid start price on a settlement minter\\n        require(\\n            SettlementExpLib.isValidStartPrice({\\n                projectId: projectId,\\n                coreContract: coreContract,\\n                startPrice: startPrice\\n            }),\\n            \\\"Only monotonic decreasing price\\\"\\n        );\\n        // do not allow a base price of zero (to simplify logic on this minter)\\n        require(basePrice > 0, \\\"Base price must be non-zero\\\");\\n        // require valid half life for this minter\\n        require(\\n            (priceDecayHalfLifeSeconds >= minimumPriceDecayHalfLifeSeconds),\\n            \\\"Price decay half life must be greater than min allowable value\\\"\\n        );\\n\\n        // EFFECTS\\n        DAExpLib.setAuctionDetailsExp({\\n            projectId: projectId,\\n            coreContract: coreContract,\\n            auctionTimestampStart: auctionTimestampStart,\\n            priceDecayHalfLifeSeconds: priceDecayHalfLifeSeconds,\\n            startPrice: startPrice.toUint88(),\\n            basePrice: basePrice.toUint88(),\\n            // we set this to false so it prevents artist from altering auction\\n            // even after max has been invoked (require explicit auction reset\\n            // on settlement minter)\\n            allowReconfigureAfterStart: false\\n        });\\n\\n        // refresh max invocations, ensuring the values are populated, and\\n        // updating any local values that are illogical with respect to the\\n        // current core contract state.\\n        // @dev this refresh enables the guarantee that a project's max\\n        // invocation state is always populated if an auction is configured.\\n        // @dev this minter pays the higher gas cost of a full refresh here due\\n        // to the more severe ux degredation of a stale minter-local max\\n        // invocations state.\\n        MaxInvocationsLib.refreshMaxInvocations({\\n            projectId: projectId,\\n            coreContract: coreContract\\n        });\\n    }\\n\\n    /**\\n     * @notice Sets the minimum and maximum values that are settable for\\n     * `priceDecayHalfLifeSeconds` across all projects.\\n     * @param minimumPriceDecayHalfLifeSeconds_ Minimum price decay half life\\n     * (in seconds).\\n     */\\n    function setMinimumPriceDecayHalfLifeSeconds(\\n        uint256 minimumPriceDecayHalfLifeSeconds_\\n    ) external {\\n        AuthLib.onlyMinterFilterAdminACL({\\n            minterFilterAddress: minterFilterAddress,\\n            sender: msg.sender,\\n            contract_: address(this),\\n            selector: this.setMinimumPriceDecayHalfLifeSeconds.selector\\n        });\\n        require(\\n            minimumPriceDecayHalfLifeSeconds_ > 0,\\n            \\\"Half life of zero not allowed\\\"\\n        );\\n        minimumPriceDecayHalfLifeSeconds = minimumPriceDecayHalfLifeSeconds_;\\n\\n        emit DAExpLib.AuctionMinHalfLifeSecondsUpdated(\\n            minimumPriceDecayHalfLifeSeconds_\\n        );\\n    }\\n\\n    /**\\n     * @notice Resets auction details for project `projectId`, zero-ing out all\\n     * relevant auction fields. Not intended to be used in normal auction\\n     * operation, but rather only in case of the need to halt an auction.\\n     * @param projectId Project ID to set auction details for.\\n     * @param coreContract Core contract address for the given project.\\n     */\\n    function resetAuctionDetails(\\n        uint256 projectId,\\n        address coreContract\\n    ) external {\\n        AuthLib.onlyCoreAdminACL({\\n            coreContract: coreContract,\\n            sender: msg.sender,\\n            contract_: address(this),\\n            selector: this.resetAuctionDetails.selector\\n        });\\n\\n        SettlementExpLib.SettlementAuctionProjectConfig\\n            storage settlementAuctionProjectConfig = SettlementExpLib\\n                .getSettlementAuctionProjectConfig({\\n                    projectId: projectId,\\n                    coreContract: coreContract\\n                });\\n\\n        // no reset after revenues collected, since that solidifies amount due\\n        require(\\n            !settlementAuctionProjectConfig.auctionRevenuesCollected,\\n            \\\"Only before revenues collected\\\"\\n        );\\n\\n        // EFFECTS\\n        // delete auction parameters\\n        DAExpLib.resetAuctionDetails({\\n            projectId: projectId,\\n            coreContract: coreContract\\n        });\\n\\n        // @dev do NOT delete settlement parameters, as they are used to\\n        // determine settlement amounts even through a reset\\n    }\\n\\n    /**\\n     * @notice This withdraws project revenues for the artist and admin.\\n     * This function is only callable by the artist or admin, and only after\\n     * one of the following is true:\\n     * - the auction has sold out above base price\\n     * - the auction has reached base price\\n     * Note that revenues are not claimable if in a temporary state after\\n     * an auction is reset.\\n     * Revenues may only be collected a single time per project.\\n     * After revenues are collected, auction parameters will never be allowed\\n     * to be reset, and excess settlement funds will become immutable and fully\\n     * deterministic.\\n     * @param projectId Project ID to withdraw revenues for.\\n     * @param coreContract Core contract address for the given project.\\n     */\\n    function withdrawArtistAndAdminRevenues(\\n        uint256 projectId,\\n        address coreContract\\n    ) external nonReentrant {\\n        AuthLib.onlyCoreAdminACLOrArtist({\\n            projectId: projectId,\\n            coreContract: coreContract,\\n            sender: msg.sender,\\n            contract_: address(this),\\n            selector: this.withdrawArtistAndAdminRevenues.selector\\n        });\\n\\n        // @dev the following function affects settlement state and marks\\n        // revenues as collected, as well as distributes revenues.\\n        // CHECKS-EFFECTS-INTERACTIONS\\n        // @dev the following function updates the project's balance and will\\n        // revert if the project's balance is insufficient to cover the\\n        // settlement amount (which is expected to not be possible)\\n        SettlementExpLib.distributeArtistAndAdminRevenues({\\n            projectId: projectId,\\n            coreContract: coreContract\\n        });\\n    }\\n\\n    /**\\n     * @notice Reclaims the sender's payment above current settled price for\\n     * project `projectId` on core contract `coreContract`.\\n     * The current settled price is the the price paid for the most recently\\n     * purchased token, or the base price if the artist has withdrawn revenues\\n     * after the auction reached base price.\\n     * This function is callable at any point, but is expected to typically be\\n     * called after auction has sold out above base price or after the auction\\n     * has been purchased at base price. This minimizes the amount of gas\\n     * required to send all excess settlement funds to the sender.\\n     * Sends excess settlement funds to msg.sender.\\n     * @param projectId Project ID to reclaim excess settlement funds on.\\n     * @param coreContract Contract address of the core contract\\n     */\\n    function reclaimProjectExcessSettlementFunds(\\n        uint256 projectId,\\n        address coreContract\\n    ) external {\\n        reclaimProjectExcessSettlementFundsTo({\\n            to: payable(msg.sender),\\n            projectId: projectId,\\n            coreContract: coreContract\\n        });\\n    }\\n\\n    /**\\n     * @notice Reclaims the sender's payment above current settled price for\\n     * projects in `projectIds`. The current settled price is the the price\\n     * paid for the most recently purchased token, or the base price if the\\n     * artist has withdrawn revenues after the auction reached base price.\\n     * This function is callable at any point, but is expected to typically be\\n     * called after auction has sold out above base price or after the auction\\n     * has been purchased at base price. This minimizes the amount of gas\\n     * required to send all excess settlement funds to the sender.\\n     * Sends total of all excess settlement funds to msg.sender in a single\\n     * chunk. Entire transaction reverts if any excess settlement calculation\\n     * fails.\\n     * @param projectIds Array of project IDs to reclaim excess settlement\\n     * funds on.\\n     * @param coreContracts Array of core contract addresses for the given\\n     * projects. Must be in the same order as `projectIds` (aligned by index).\\n     */\\n    function reclaimProjectsExcessSettlementFunds(\\n        uint256[] calldata projectIds,\\n        address[] calldata coreContracts\\n    ) external {\\n        // @dev input validation checks are performed in subcall\\n        reclaimProjectsExcessSettlementFundsTo({\\n            to: payable(msg.sender),\\n            projectIds: projectIds,\\n            coreContracts: coreContracts\\n        });\\n    }\\n\\n    /**\\n     * @notice Purchases a token from project `projectId`.\\n     * @param projectId Project ID to mint a token on.\\n     * @param coreContract Core contract address for the given project.\\n     * @return tokenId Token ID of minted token\\n     */\\n    function purchase(\\n        uint256 projectId,\\n        address coreContract\\n    ) external payable returns (uint256 tokenId) {\\n        tokenId = purchaseTo({\\n            to: msg.sender,\\n            projectId: projectId,\\n            coreContract: coreContract\\n        });\\n\\n        return tokenId;\\n    }\\n\\n    // public getter functions\\n    /**\\n     * @notice Gets the maximum invocations project configuration.\\n     * @param coreContract The address of the core contract.\\n     * @param projectId The ID of the project whose data needs to be fetched.\\n     * @return MaxInvocationsLib.MaxInvocationsProjectConfig instance with the\\n     * configuration data.\\n     */\\n    function maxInvocationsProjectConfig(\\n        uint256 projectId,\\n        address coreContract\\n    )\\n        external\\n        view\\n        returns (MaxInvocationsLib.MaxInvocationsProjectConfig memory)\\n    {\\n        return\\n            MaxInvocationsLib.getMaxInvocationsProjectConfig({\\n                projectId: projectId,\\n                coreContract: coreContract\\n            });\\n    }\\n\\n    /**\\n     * @notice Retrieves the auction parameters for a specific project.\\n     * @param projectId The unique identifier for the project.\\n     * @param coreContract The address of the core contract for the project.\\n     * @return timestampStart The start timestamp for the auction.\\n     * @return priceDecayHalfLifeSeconds The half-life for the price decay\\n     * during the auction, in seconds.\\n     * @return startPrice The starting price of the auction.\\n     * @return basePrice The base price of the auction.\\n     */\\n    function projectAuctionParameters(\\n        uint256 projectId,\\n        address coreContract\\n    )\\n        external\\n        view\\n        returns (\\n            uint40 timestampStart,\\n            uint40 priceDecayHalfLifeSeconds,\\n            uint256 startPrice,\\n            uint256 basePrice\\n        )\\n    {\\n        DAExpLib.DAProjectConfig storage _auctionProjectConfig = DAExpLib\\n            .getDAProjectConfig({\\n                projectId: projectId,\\n                coreContract: coreContract\\n            });\\n        timestampStart = _auctionProjectConfig.timestampStart;\\n        priceDecayHalfLifeSeconds = _auctionProjectConfig\\n            .priceDecayHalfLifeSeconds;\\n        startPrice = _auctionProjectConfig.startPrice;\\n        basePrice = _auctionProjectConfig.basePrice;\\n    }\\n\\n    /**\\n     * @notice Checks if the specified `coreContract` is a valid engine contract.\\n     * @dev This function retrieves the cached value of `coreContract` from\\n     * the `isEngineCache` mapping. If the cached value is already set, it\\n     * returns the cached value. Otherwise, it calls the `getV3CoreIsEngineView`\\n     * function from the `SplitFundsLib` library to check if `coreContract`\\n     * is a valid engine contract.\\n     * @dev This function will revert if the provided `coreContract` is not\\n     * a valid Engine or V3 Flagship contract.\\n     * @param coreContract The address of the contract to check.\\n     * @return bool indicating if `coreContract` is a valid engine contract.\\n     */\\n    function isEngineView(address coreContract) external view returns (bool) {\\n        SplitFundsLib.IsEngineCache storage isEngineCache = SplitFundsLib\\n            .getIsEngineCacheConfig(coreContract);\\n        if (isEngineCache.isCached) {\\n            return isEngineCache.isEngine;\\n        } else {\\n            // @dev this calls the non-state-modifying variant of isEngine\\n            return SplitFundsLib.getV3CoreIsEngineView(coreContract);\\n        }\\n    }\\n\\n    /**\\n     * @notice projectId => has project reached its maximum number of\\n     * invocations? Note that this returns a local cache of the core contract's\\n     * state, and may be out of sync with the core contract. This is\\n     * intentional, as it only enables gas optimization of mints after a\\n     * project's maximum invocations has been reached. A false negative will\\n     * only result in a gas cost increase, since the core contract will still\\n     * enforce a maxInvocation check during minting. A false positive may be possible\\n     * if function `manuallyLimitProjectMaxInvocations` has been invoked, resulting in\\n     * `localMaxInvocations` < `coreContractMaxInvocations`. Based on this rationale, we intentionally\\n     * do not do input validation in this method as to whether or not the input\\n     * @param projectId is an existing project ID.\\n     * @param coreContract is an existing core contract address.\\n     */\\n    function projectMaxHasBeenInvoked(\\n        uint256 projectId,\\n        address coreContract\\n    ) external view returns (bool) {\\n        return\\n            MaxInvocationsLib.getMaxHasBeenInvoked({\\n                projectId: projectId,\\n                coreContract: coreContract\\n            });\\n    }\\n\\n    /**\\n     * @notice projectId => project's maximum number of invocations.\\n     * Optionally synced with core contract value, for gas optimization.\\n     * Note that this returns a local cache of the core contract's\\n     * state, and may be out of sync with the core contract. This is\\n     * intentional, as it only enables gas optimization of mints after a\\n     * project's maximum invocations has been reached.\\n     * @dev A number greater than the core contract's project max invocations\\n     * will only result in a gas cost increase, since the core contract will\\n     * still enforce a maxInvocation check during minting. A number less than\\n     * the core contract's project max invocations is possible if the artist\\n     * has called manuallyLimitProjectMaxInvocations or when the project's max\\n     * invocations have not been synced on this minter, since the\\n     * V3 core contract only allows maximum invocations to be reduced, not\\n     * increased. When this happens, the minter will enable minting, allowing\\n     * the core contract to enforce the max invocations check. Based on this\\n     * rationale, we intentionally do not do input validation in this method as\\n     * to whether or not the input `projectId` is an existing project ID.\\n     * @param projectId is an existing project ID.\\n     * @param coreContract is an existing core contract address.\\n     */\\n    function projectMaxInvocations(\\n        uint256 projectId,\\n        address coreContract\\n    ) external view returns (uint256) {\\n        return\\n            MaxInvocationsLib.getMaxInvocations({\\n                projectId: projectId,\\n                coreContract: coreContract\\n            });\\n    }\\n\\n    /**\\n     * @notice Gets the latest purchase price for project `projectId`, or 0 if\\n     * no purchases have been made.\\n     * @param projectId Project ID to get latest purchase price for.\\n     * @param coreContract Contract address of the core contract\\n     * @return latestPurchasePrice Latest purchase price\\n     */\\n    function getProjectLatestPurchasePrice(\\n        uint256 projectId,\\n        address coreContract\\n    ) external view returns (uint256 latestPurchasePrice) {\\n        SettlementExpLib.SettlementAuctionProjectConfig\\n            storage settlementAuctionProjectConfig = SettlementExpLib\\n                .getSettlementAuctionProjectConfig({\\n                    projectId: projectId,\\n                    coreContract: coreContract\\n                });\\n        return settlementAuctionProjectConfig.latestPurchasePrice;\\n    }\\n\\n    /**\\n     * @notice Gets the number of settleable invocations for project `projectId`.\\n     * @param projectId Project ID to get number of settleable invocations for.\\n     * @param coreContract Contract address of the core contract\\n     * @return numSettleableInvocations Number of settleable invocations\\n     */\\n    function getNumSettleableInvocations(\\n        uint256 projectId,\\n        address coreContract\\n    ) external view returns (uint256 numSettleableInvocations) {\\n        SettlementExpLib.SettlementAuctionProjectConfig\\n            storage settlementAuctionProjectConfig = SettlementExpLib\\n                .getSettlementAuctionProjectConfig({\\n                    projectId: projectId,\\n                    coreContract: coreContract\\n                });\\n        return settlementAuctionProjectConfig.numSettleableInvocations;\\n    }\\n\\n    /**\\n     * @notice Gets the balance of ETH, in wei, currently held by the minter\\n     * for project `projectId`. This value is non-zero if not all purchasers\\n     * have reclaimed their excess settlement funds, or if an artist/admin has\\n     * not yet withdrawn their revenues.\\n     * @param projectId Project ID to get balance for.\\n     * @param coreContract Contract address of the core contract\\n     */\\n    function getProjectBalance(\\n        uint256 projectId,\\n        address coreContract\\n    ) external view returns (uint256 projectBalance) {\\n        SettlementExpLib.SettlementAuctionProjectConfig\\n            storage settlementAuctionProjectConfig = SettlementExpLib\\n                .getSettlementAuctionProjectConfig({\\n                    projectId: projectId,\\n                    coreContract: coreContract\\n                });\\n        return settlementAuctionProjectConfig.projectBalance;\\n    }\\n\\n    /**\\n     * @notice Gets if price of token is configured, price of minting a\\n     * token on project `projectId`, and currency symbol and address to be\\n     * used as payment. Supersedes any core contract price information.\\n     * @param projectId Project ID to get price information for\\n     * @param coreContract Contract address of the core contract\\n     * @return isConfigured true only if token price has been configured on\\n     * this minter\\n     * @return tokenPriceInWei current price of token on this minter - invalid\\n     * if price has not yet been configured\\n     * @return currencySymbol currency symbol for purchases of project on this\\n     * minter. This minter always returns \\\"ETH\\\"\\n     * @return currencyAddress currency address for purchases of project on\\n     * this minter. This minter always returns null address, reserved for ether\\n     */\\n    function getPriceInfo(\\n        uint256 projectId,\\n        address coreContract\\n    )\\n        external\\n        view\\n        returns (\\n            bool isConfigured,\\n            uint256 tokenPriceInWei,\\n            string memory currencySymbol,\\n            address currencyAddress\\n        )\\n    {\\n        DAExpLib.DAProjectConfig storage auctionProjectConfig = DAExpLib\\n            .getDAProjectConfig({\\n                projectId: projectId,\\n                coreContract: coreContract\\n            });\\n\\n        // take action based on configured state\\n        isConfigured = (auctionProjectConfig.startPrice > 0);\\n        if (!isConfigured) {\\n            // In the case of unconfigured auction, return price of zero when\\n            // getPriceSafe would otherwise revert\\n            tokenPriceInWei = 0;\\n        } else if (block.timestamp <= auctionProjectConfig.timestampStart) {\\n            // Provide a reasonable value for `tokenPriceInWei` when\\n            // getPriceSafe would otherwise revert, using the starting price\\n            // before auction starts.\\n            tokenPriceInWei = auctionProjectConfig.startPrice;\\n        } else {\\n            // call getPriceSafe to get the current price\\n            // @dev we do not use getPriceUnsafe here, as this is a view\\n            // function, and we prefer to use the extra gas to appropriately\\n            // correct for the case of a stale minter max invocation state.\\n            tokenPriceInWei = SettlementExpLib.getPriceSafe({\\n                projectId: projectId,\\n                coreContract: coreContract\\n            });\\n        }\\n        currencySymbol = \\\"ETH\\\";\\n        currencyAddress = address(0);\\n    }\\n\\n    /**\\n     * @notice Gets the current excess settlement funds on project `projectId`\\n     * for address `walletAddress`. The returned value is expected to change\\n     * throughtout an auction, since the latest purchase price is used when\\n     * determining excess settlement funds.\\n     * A user may claim excess settlement funds by calling the function\\n     * `reclaimProjectExcessSettlementFunds(_projectId)`.\\n     * @param projectId Project ID to query.\\n     * @param coreContract Contract address of the core contract\\n     * @param walletAddress Account address for which the excess posted funds\\n     * is being queried.\\n     * @return excessSettlementFundsInWei Amount of excess settlement funds, in\\n     * wei\\n     */\\n    function getProjectExcessSettlementFunds(\\n        uint256 projectId,\\n        address coreContract,\\n        address walletAddress\\n    ) external view returns (uint256 excessSettlementFundsInWei) {\\n        // input validation\\n        require(walletAddress != address(0), \\\"No zero address\\\");\\n\\n        (excessSettlementFundsInWei, ) = SettlementExpLib\\n            .getProjectExcessSettlementFunds({\\n                projectId: projectId,\\n                coreContract: coreContract,\\n                walletAddress: walletAddress\\n            });\\n    }\\n\\n    /**\\n     * @notice Reclaims the sender's payment above current settled price for\\n     * project `projectId` on core contract `coreContract`.\\n     * The current settled price is the the price paid for the most recently\\n     * purchased token, or the base price if the artist has withdrawn revenues\\n     * after the auction reached base price.\\n     * This function is callable at any point, but is expected to typically be\\n     * called after auction has sold out above base price or after the auction\\n     * has been purchased at base price. This minimizes the amount of gas\\n     * required to send all excess settlement funds to the sender.\\n     * Sends excess settlement funds to address `to`.\\n     * @param to Address to send excess settlement funds to.\\n     * @param projectId Project ID to reclaim excess settlement funds on.\\n     * @param coreContract Contract address of the core contract\\n     */\\n    function reclaimProjectExcessSettlementFundsTo(\\n        address payable to,\\n        uint256 projectId,\\n        address coreContract\\n    ) public nonReentrant {\\n        require(to != address(0), \\\"No claiming to the zero address\\\");\\n\\n        SettlementExpLib.reclaimProjectExcessSettlementFundsTo({\\n            to: to,\\n            projectId: projectId,\\n            coreContract: coreContract,\\n            purchaserAddress: msg.sender,\\n            doSendFunds: true\\n        });\\n    }\\n\\n    /**\\n     * @notice Reclaims the sender's payment above current settled price for\\n     * projects in `projectIds`. The current settled price is the the price\\n     * paid for the most recently purchased token, or the base price if the\\n     * artist has withdrawn revenues after the auction reached base price.\\n     * This function is callable at any point, but is expected to typically be\\n     * called after auction has sold out above base price or after the auction\\n     * has been purchased at base price. This minimizes the amount of gas\\n     * required to send all excess settlement funds to the sender.\\n     * Sends total of all excess settlement funds to `to` in a single\\n     * chunk. Entire transaction reverts if any excess settlement calculation\\n     * fails.\\n     * @param to Address to send excess settlement funds to.\\n     * @param projectIds Array of project IDs to reclaim excess settlement\\n     * funds on.\\n     * @param coreContracts Array of core contract addresses for the given\\n     * projects. Must be in the same order as `projectIds` (aligned by index).\\n     */\\n    function reclaimProjectsExcessSettlementFundsTo(\\n        address payable to,\\n        uint256[] calldata projectIds,\\n        address[] calldata coreContracts\\n    ) public nonReentrant {\\n        // CHECKS\\n        // input validation\\n        require(to != address(0), \\\"No claiming to the zero address\\\");\\n        uint256 projectIdsLength = projectIds.length;\\n        require(\\n            projectIdsLength == coreContracts.length,\\n            \\\"Array lengths must match\\\"\\n        );\\n        // EFFECTS\\n        // for each project, tally up the excess settlement funds and update\\n        // the receipt in storage\\n        uint256 excessSettlementFunds;\\n        for (uint256 i; i < projectIdsLength; ) {\\n            excessSettlementFunds += SettlementExpLib\\n                .reclaimProjectExcessSettlementFundsTo({\\n                    to: to,\\n                    projectId: projectIds[i],\\n                    coreContract: coreContracts[i],\\n                    purchaserAddress: msg.sender,\\n                    doSendFunds: false // do not send funds, just tally\\n                });\\n\\n            // gas efficiently increment i\\n            // won't overflow due to for loop, as well as gas limts\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        // INTERACTIONS\\n        // send excess settlement funds in a single chunk for all\\n        // projects\\n        bool success_;\\n        (success_, ) = to.call{value: excessSettlementFunds}(\\\"\\\");\\n        require(success_, \\\"Reclaiming failed\\\");\\n    }\\n\\n    /**\\n     * @notice Purchases a token from project `projectId` and sets\\n     * the token's owner to `to`.\\n     * @param to Address to be the new token's owner.\\n     * @param projectId Project ID to mint a token on.\\n     * @param coreContract Core contract address for the given project.\\n     * @return tokenId Token ID of minted token\\n     */\\n    function purchaseTo(\\n        address to,\\n        uint256 projectId,\\n        address coreContract\\n    ) public payable nonReentrant returns (uint256 tokenId) {\\n        // CHECKS\\n        // pre-mint MaxInvocationsLib checks\\n        // Note that `maxHasBeenInvoked` is only checked here to reduce gas\\n        // consumption after a project has been fully minted.\\n        // `maxInvocationsProjectConfig.maxHasBeenInvoked` is locally cached to reduce\\n        // gas consumption, but if not in sync with the core contract's value,\\n        // the core contract also enforces its own max invocation check during\\n        // minting.\\n        MaxInvocationsLib.preMintChecks({\\n            projectId: projectId,\\n            coreContract: coreContract\\n        });\\n\\n        // _getPriceUnsafe reverts if auction has not yet started or auction is\\n        // unconfigured, and auction has not sold out or revenues have not been\\n        // withdrawn.\\n        // @dev _getPriceUnsafe is guaranteed to be accurate unless the core\\n        // contract is limiting invocations and we have stale local state\\n        // returning a false negative that max invocations have been reached.\\n        // This is acceptable, because that case will revert this\\n        // call later on in this function, when the core contract's max\\n        // invocation check fails.\\n        uint256 currentPriceInWei = SettlementExpLib.getPriceUnsafe({\\n            projectId: projectId,\\n            coreContract: coreContract,\\n            maxHasBeenInvoked: false // always false due to MaxInvocationsLib.preMintChecks\\n        });\\n\\n        // EFFECTS\\n        // update and validate receipts, latest purchase price, overall project\\n        // balance, and number of tokens auctioned on this minter\\n        SettlementExpLib.preMintEffects({\\n            projectId: projectId,\\n            coreContract: coreContract,\\n            currentPriceInWei: currentPriceInWei,\\n            msgValue: msg.value,\\n            purchaserAddress: msg.sender\\n        });\\n\\n        // INTERACTIONS\\n        tokenId = _minterFilter.mint_joo({\\n            to: to,\\n            projectId: projectId,\\n            coreContract: coreContract,\\n            sender: msg.sender\\n        });\\n\\n        // verify token invocation is valid given local minter max invocations,\\n        // update local maxHasBeenInvoked\\n        MaxInvocationsLib.validateMintEffectsInvocations({\\n            tokenId: tokenId,\\n            coreContract: coreContract\\n        });\\n\\n        // distribute payments if revenues have been collected, or increment\\n        // number of settleable invocations if revenues have not been collected\\n        SettlementExpLib.postMintInteractions({\\n            projectId: projectId,\\n            coreContract: coreContract,\\n            currentPriceInWei: currentPriceInWei\\n        });\\n    }\\n\\n    /**\\n     * @notice This function is intentionally not implemented for this version\\n     * of the minter. Due to potential for unintended consequences, the\\n     * function `manuallyLimitProjectMaxInvocations` should be used to manually\\n     * and explicitly limit the maximum invocations for a project to a value\\n     * other than the core contract's maximum invocations for a project.\\n     * @param coreContract Core contract address for the given project.\\n     * @param projectId Project ID to set the maximum invocations for.\\n     */\\n    function syncProjectMaxInvocationsToCore(\\n        uint256 projectId,\\n        address coreContract\\n    ) public view {\\n        AuthLib.onlyArtist({\\n            projectId: projectId,\\n            coreContract: coreContract,\\n            sender: msg.sender\\n        });\\n        revert(\\\"Not implemented\\\");\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 25\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"minterFilter\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"coreContract\",\"type\":\"address\"}],\"name\":\"getNumSettleableInvocations\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"numSettleableInvocations\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"coreContract\",\"type\":\"address\"}],\"name\":\"getPriceInfo\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isConfigured\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"tokenPriceInWei\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"currencySymbol\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"currencyAddress\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"coreContract\",\"type\":\"address\"}],\"name\":\"getProjectBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"projectBalance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"coreContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"walletAddress\",\"type\":\"address\"}],\"name\":\"getProjectExcessSettlementFunds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"excessSettlementFundsInWei\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"coreContract\",\"type\":\"address\"}],\"name\":\"getProjectLatestPurchasePrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"latestPurchasePrice\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"coreContract\",\"type\":\"address\"}],\"name\":\"isEngineView\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"coreContract\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"maxInvocations\",\"type\":\"uint24\"}],\"name\":\"manuallyLimitProjectMaxInvocations\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"coreContract\",\"type\":\"address\"}],\"name\":\"maxInvocationsProjectConfig\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"maxHasBeenInvoked\",\"type\":\"bool\"},{\"internalType\":\"uint24\",\"name\":\"maxInvocations\",\"type\":\"uint24\"}],\"internalType\":\"struct MaxInvocationsLib.MaxInvocationsProjectConfig\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minimumPriceDecayHalfLifeSeconds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minterFilterAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minterType\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minterVersion\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"coreContract\",\"type\":\"address\"}],\"name\":\"projectAuctionParameters\",\"outputs\":[{\"internalType\":\"uint40\",\"name\":\"timestampStart\",\"type\":\"uint40\"},{\"internalType\":\"uint40\",\"name\":\"priceDecayHalfLifeSeconds\",\"type\":\"uint40\"},{\"internalType\":\"uint256\",\"name\":\"startPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"basePrice\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"coreContract\",\"type\":\"address\"}],\"name\":\"projectMaxHasBeenInvoked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"coreContract\",\"type\":\"address\"}],\"name\":\"projectMaxInvocations\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"coreContract\",\"type\":\"address\"}],\"name\":\"purchase\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"coreContract\",\"type\":\"address\"}],\"name\":\"purchaseTo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"coreContract\",\"type\":\"address\"}],\"name\":\"reclaimProjectExcessSettlementFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"coreContract\",\"type\":\"address\"}],\"name\":\"reclaimProjectExcessSettlementFundsTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"projectIds\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"coreContracts\",\"type\":\"address[]\"}],\"name\":\"reclaimProjectsExcessSettlementFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"projectIds\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"coreContracts\",\"type\":\"address[]\"}],\"name\":\"reclaimProjectsExcessSettlementFundsTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"coreContract\",\"type\":\"address\"}],\"name\":\"resetAuctionDetails\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"coreContract\",\"type\":\"address\"},{\"internalType\":\"uint40\",\"name\":\"auctionTimestampStart\",\"type\":\"uint40\"},{\"internalType\":\"uint40\",\"name\":\"priceDecayHalfLifeSeconds\",\"type\":\"uint40\"},{\"internalType\":\"uint256\",\"name\":\"startPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"basePrice\",\"type\":\"uint256\"}],\"name\":\"setAuctionDetails\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"minimumPriceDecayHalfLifeSeconds_\",\"type\":\"uint256\"}],\"name\":\"setMinimumPriceDecayHalfLifeSeconds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"coreContract\",\"type\":\"address\"}],\"name\":\"syncProjectMaxInvocationsToCore\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"coreContract\",\"type\":\"address\"}],\"name\":\"withdrawArtistAndAdminRevenues\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "MinterDAExpSettlementV3", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "25", "ConstructorArguments": "000000000000000000000000a2ccfe293bc2cdd78d8166a82d1e18cd2148122b", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}