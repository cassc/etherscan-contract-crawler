{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    function __Ownable_init() internal onlyInitializing {\\n        __Ownable_init_unchained();\\n    }\\n\\n    function __Ownable_init_unchained() internal onlyInitializing {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```solidity\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n *\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     * @custom:oz-retyped-from bool\\n     */\\n    uint8 private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint8 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts.\\n     *\\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\\n     * constructor.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier initializer() {\\n        bool isTopLevelCall = !_initializing;\\n        require(\\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\\n            \\\"Initializable: contract is already initialized\\\"\\n        );\\n        _initialized = 1;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\\n     * are added through upgrades and that require initialization.\\n     *\\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     *\\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier reinitializer(uint8 version) {\\n        require(!_initializing && _initialized < version, \\\"Initializable: contract is already initialized\\\");\\n        _initialized = version;\\n        _initializing = true;\\n        _;\\n        _initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     *\\n     * Emits an {Initialized} event the first time it is successfully executed.\\n     */\\n    function _disableInitializers() internal virtual {\\n        require(!_initializing, \\\"Initializable: contract is initializing\\\");\\n        if (_initialized != type(uint8).max) {\\n            _initialized = type(uint8).max;\\n            emit Initialized(type(uint8).max);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\\n     */\\n    function _getInitializedVersion() internal view returns (uint8) {\\n        return _initialized;\\n    }\\n\\n    /**\\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\\n     */\\n    function _isInitializing() internal view returns (bool) {\\n        return _initializing;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuardUpgradeable is Initializable {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    function __ReentrancyGuard_init() internal onlyInitializing {\\n        __ReentrancyGuard_init_unchained();\\n    }\\n\\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Returns true if the reentrancy guard is currently set to \\\"entered\\\", which indicates there is a\\n     * `nonReentrant` function in the call stack.\\n     */\\n    function _reentrancyGuardEntered() internal view returns (bool) {\\n        return _status == _ENTERED;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     *\\n     * Furthermore, `isContract` will also return true if the target contract within\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\n     * which only has an effect at the end of a transaction.\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal onlyInitializing {\\n    }\\n\\n    function __Context_init_unchained() internal onlyInitializing {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Counters\\n * @author Matt Condon (@shrugs)\\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\\n *\\n * Include with `using Counters for Counters.Counter;`\\n */\\nlibrary CountersUpgradeable {\\n    struct Counter {\\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\\n        uint256 _value; // default: 0\\n    }\\n\\n    function current(Counter storage counter) internal view returns (uint256) {\\n        return counter._value;\\n    }\\n\\n    function increment(Counter storage counter) internal {\\n        unchecked {\\n            counter._value += 1;\\n        }\\n    }\\n\\n    function decrement(Counter storage counter) internal {\\n        uint256 value = counter._value;\\n        require(value > 0, \\\"Counter: decrement overflow\\\");\\n        unchecked {\\n            counter._value = value - 1;\\n        }\\n    }\\n\\n    function reset(Counter storage counter) internal {\\n        counter._value = 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     *\\n     * Furthermore, `isContract` will also return true if the target contract within\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\n     * which only has an effect at the end of a transaction.\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/escrow/Escrow.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/escrow/Escrow.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../access/Ownable.sol\\\";\\nimport \\\"../Address.sol\\\";\\n\\n/**\\n * @title Escrow\\n * @dev Base escrow contract, holds funds designated for a payee until they\\n * withdraw them.\\n *\\n * Intended usage: This contract (and derived escrow contracts) should be a\\n * standalone contract, that only interacts with the contract that instantiated\\n * it. That way, it is guaranteed that all Ether will be handled according to\\n * the `Escrow` rules, and there is no need to check for payable functions or\\n * transfers in the inheritance tree. The contract that uses the escrow as its\\n * payment method should be its owner, and provide public methods redirecting\\n * to the escrow's deposit and withdraw.\\n */\\ncontract Escrow is Ownable {\\n    using Address for address payable;\\n\\n    event Deposited(address indexed payee, uint256 weiAmount);\\n    event Withdrawn(address indexed payee, uint256 weiAmount);\\n\\n    mapping(address => uint256) private _deposits;\\n\\n    function depositsOf(address payee) public view returns (uint256) {\\n        return _deposits[payee];\\n    }\\n\\n    /**\\n     * @dev Stores the sent amount as credit to be withdrawn.\\n     * @param payee The destination address of the funds.\\n     *\\n     * Emits a {Deposited} event.\\n     */\\n    function deposit(address payee) public payable virtual onlyOwner {\\n        uint256 amount = msg.value;\\n        _deposits[payee] += amount;\\n        emit Deposited(payee, amount);\\n    }\\n\\n    /**\\n     * @dev Withdraw accumulated balance for a payee, forwarding all gas to the\\n     * recipient.\\n     *\\n     * WARNING: Forwarding all gas opens the door to reentrancy vulnerabilities.\\n     * Make sure you trust the recipient, or are either following the\\n     * checks-effects-interactions pattern or using {ReentrancyGuard}.\\n     *\\n     * @param payee The address whose funds will be withdrawn and transferred to.\\n     *\\n     * Emits a {Withdrawn} event.\\n     */\\n    function withdraw(address payable payee) public virtual onlyOwner {\\n        uint256 payment = _deposits[payee];\\n\\n        _deposits[payee] = 0;\\n\\n        payee.sendValue(payment);\\n\\n        emit Withdrawn(payee, payment);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/ExchangeArtNFTMarketLogic.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.8;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/escrow/Escrow.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\n\\nimport \\\"./mixins/shared/Constants.sol\\\";\\nimport \\\"./mixins/IdGenerator.sol\\\";\\nimport \\\"./mixins/BuyNowSellingAgreementProvider.sol\\\";\\nimport \\\"./mixins/AuctionSellingAgreementProvider.sol\\\";\\nimport \\\"./mixins/OfferSellingAgreementProvider.sol\\\";\\n\\ncontract ExchangeArtNFTMarketLogic is\\n  Initializable,\\n  IdGenerator,\\n  ReentrancyGuardUpgradeable,\\n  BuyNowSellingAgreementProvider,\\n  OfferSellingAgreementProvider,\\n  AuctionSellingAgreementProvider\\n{\\n  address payable private immutable treasuryAddress =\\n    payable(0xB982539402A3453Dd38828203B6d84894915411a);\\n  Escrow private fallbackEscrow;\\n\\n  constructor() {\\n    _disableInitializers();\\n  }\\n\\n  /**\\n   * @dev See {Initializable-initialize}.\\n   * We mark this function with a special initializer modifier so it can only be called once.\\n   */\\n  function initialize() public initializer {\\n    fallbackEscrow = new Escrow();\\n    IdGenerator.__IdGenerator_init();\\n    ReentrancyGuardUpgradeable.__ReentrancyGuard_init();\\n  }\\n\\n  /**\\n   * Function to withdraw the escrowed amount of a user, in case a standard transfer has failed.\\n   */\\n  function withdrawEscrowedAmount(address payable walletAddress) public {\\n    uint256 depositsOfUser = fallbackEscrow.depositsOf(walletAddress);\\n    if (depositsOfUser == 0) {\\n      revert EscrowWithdrawError__NoFundsToWithdraw(walletAddress);\\n    }\\n    fallbackEscrow.withdraw(walletAddress);\\n  }\\n\\n  /**\\n   * We use the push payment pattern normally, but if the recipient is a contract address which cannot\\n   * accept Ethereum, we fallback to an escrow contract which will hold the funds until they are withdrawn.\\n   */\\n  function _pushPayments(\\n    address payable[] memory recipients,\\n    uint256[] memory amounts\\n  ) internal override(PaymentsAware) {\\n    for (uint256 i = 0; i < recipients.length; i++) {\\n      (bool success, ) = recipients[i].call{value: amounts[i], gas: 20_000}(\\\"\\\");\\n      if (!success) {\\n        fallbackEscrow.deposit{value: amounts[i]}(recipients[i]);\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Internal function to retrieve the treasury address.\\n   */\\n  function _getTreasury()\\n    internal\\n    view\\n    virtual\\n    override(PaymentsAware)\\n    returns (address payable)\\n  {\\n    return treasuryAddress;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IAuctionSellingAgreementProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.8;\\n\\n/// @notice The auction configuration for a specific NFT.\\nstruct AuctionBasicState {\\n  /// @notice The address of the NFT contract.\\n  address nftContract;\\n  /// @notice The id of the NFT.\\n  uint256 tokenId;\\n  /// @notice The owner of the NFT which listed it in auction.\\n  address payable seller;\\n  /// @notice The current highest bidder in this auction.\\n  /// @dev This is `address(0)` until the first bid is placed.\\n  address payable highestBidder;\\n  /// @notice The difference between two subsequent bids, if no ending phase mechanics are applied.\\n  uint256 minimumIncrement;\\n  /// @notice The time at which this auction will not accept any new bids.\\n  /// @dev This is `0` until the first bid is placed in case of a reserve price triggered auction.\\n  uint256 end;\\n  /// @notice The latest price of the NFT in this auction.\\n  /// @dev This is set to the reserve price, and then to the highest bid once the auction has started.\\n  uint256 reservePriceOrHighestBid;\\n  bool isStandardAuction;\\n  bool isPrimarySale;\\n}\\n\\n/// @notice The auction configuration for a specific NFT.\\nstruct AuctionAdditionalConfiguration {\\n  /// @notice During the ending phase, the minimum increment becomes a percentage of the highest bid.\\n  uint256 endingPhase;\\n  /// @notice During the ending phase, add a minimum percentage increase each bid must meet.\\n  uint256 endingPhasePercentageFlip;\\n  /// @notice How long to extend the auction with (in seconds) from the last bid.\\n  uint256 extensionWindow;\\n  /// @notice The time at which this auction has kicked off\\n  /// @dev IMPORTANT - In order to save gas and not define another variable, when the auction is reserved price triggered\\n  /// we pass here the duration\\n  uint256 start;\\n  /// @notice Specifies if this is reserve price triggered auction.\\n  bool isReservePriceTriggered;\\n  // /// @notice The price at which anyoane can aquire this NFT while the auction is ongoing.\\n  // /// @dev This works only if the value is grater than the highest bid.\\n  // uint256 buyOutPrice;\\n}\\n\\n/// @notice All details related to an auction\\nstruct AuctionState {\\n  /// @notice The address of the NFT contract.\\n  address nftContract;\\n  /// @notice The id of the NFT.\\n  uint256 tokenId;\\n  /// @notice The owner of the NFT which listed it in auction.\\n  address payable seller;\\n  /// @notice The difference between two subsequent bids, if no ending phase mechanics are applied.\\n  uint256 minimumIncrement;\\n  /// @notice During the ending phase, the minimum increment becomes a percentage of the highest bid.\\n  uint256 endingPhase;\\n  /// @notice During the ending phase, add a minimum percentage increase each bid must meet.\\n  uint256 endingPhasePercentageFlip;\\n  /// @notice How long to extend the auction with (in seconds) from the last bid.\\n  uint256 extensionWindow;\\n  /// @notice The time at which this auction has kicked off\\n  /// @dev IMPORTANT - In order to save gas and not define another variable, when the auction is reserved price triggered\\n  /// we pass here the duration\\n  uint256 start;\\n  /// @notice The time at which this auction will not accept any new bids.\\n  /// @dev This is `0` until the first bid is placed in case of a reserve price triggered auction.\\n  uint256 end;\\n  /// @notice The current highest bidder in this auction.\\n  /// @dev This is `address(0)` until the first bid is placed.\\n  address payable highestBidder;\\n  /// @notice The latest price of the NFT in this auction.\\n  /// @dev This is set to the reserve price, and then to the highest bid once the auction has started.\\n  uint256 reservePriceOrHighestBid;\\n  /// @notice The price at which anyoane can aquire this NFT while the auction is ongoing.\\n  /// @dev This works only if the value is grater than the highest bid.\\n  //uint256 buyOutPrice;\\n  /// @notice Specifies if this is a primary sale or a secondary one.\\n  bool isPrimarySale;\\n  /// @notice Specifies if this is reserve price triggered auction.\\n  bool isReservePriceTriggered;\\n  bool isStandardAuction;\\n}\\n/// @notice The arguments  that need to be provided on an auction initialization.\\nstruct InitAuctionArguments {\\n  address nftContract;\\n  uint256 tokenId;\\n  uint256 minimumIncrement;\\n  uint256 endingPhase;\\n  uint256 endingPhasePercentageFlip;\\n  uint256 extensionWindow;\\n  uint256 start;\\n  uint256 end;\\n  uint256 reservePrice;\\n  bool isReservePriceTriggered;\\n  bool isPrimarySale;\\n  bool isStandardAuction;\\n  //uint256 buyOutPrice;\\n}\\n\\nstruct AuctionCreatedEventArguments {\\n  address nftContract;\\n  uint256 tokenId;\\n  uint256 minimumIncrement;\\n  uint256 endingPhase;\\n  uint256 endingPhasePercentageFlip;\\n  uint256 extensionWindow;\\n  uint256 start;\\n  uint256 end;\\n  uint256 reservePrice;\\n}\\n\\nstruct BidEventArguments {\\n  address nftContract;\\n  uint256 tokenId;\\n  uint256 id;\\n  address bidder;\\n  address seller;\\n  uint256 amount;\\n  uint256 endTime;\\n  uint256 startTime;\\n  address prevHighestBidder;\\n}\\n\\ninterface IAuctionSellingAgreementProvider {\\n  error NFTMarketAuction__EndingPhaseProvidedWithNopercentageFlip();\\n  error NFTMarketAuction__PercentageFlipGreaterThan100(uint256 percentageFlip);\\n  error NFTMarketAuction__StartGreaterThanEnd();\\n  error NFTMarketAuction__EndingPhaseGraterThanDuration(uint256 endingPhase);\\n  error NFTMarketAuction__ExrtensionWindowGraterThanEndingPhase(\\n    uint256 extensionWindow\\n  );\\n\\n  /**\\n   * @notice Emitted when a bid is placed.\\n   * @param bidInfos All informations needed to index this bid;\\n\\n   */\\n  event AuctionSellingAgreementBidPlaced(BidEventArguments bidInfos);\\n\\n  // /**\\n  //  * @notice Emitted when the buy out is triggered on an auction.\\n  //  * @param auctionId       : The id of the auction this bid was for.\\n  //  * @param buyer           : The buyer who triggered the buyOut.\\n  //  * @param buyOutAmount    : The amount of the bid.\\n  //  */\\n  // event AuctionSellingAgreementBuyOutTriggered(\\n  //   address indexed nftContract,\\n  //   address indexed tokenId,\\n  //   uint256 indexed auctionId,\\n  //   address buyer,\\n  //   uint256 buyOutAmount\\n  // );\\n\\n  /**\\n   * @notice Emitted when an auction is canceled.\\n   * @dev This is only possible if the auction has not received any bids.\\n   * @param auctionId : The id of the auction that was canceled.\\n   */\\n  event AuctionSellingAgreementCancelled(\\n    address indexed nftContract,\\n    uint256 indexed tokenId,\\n    uint256 indexed auctionId,\\n    address seller\\n  );\\n\\n  /**\\n   * @notice Emitted when an NFT is listed for auction.\\n   * @param auctionConfig The configuration of the auction.\\n   * @param auctionId The id of the auction that was created.\\n   *\\n   */\\n  event AuctionSellingAgreementCreated(\\n    uint256 indexed auctionId,\\n    address indexed seller,\\n    AuctionCreatedEventArguments auctionConfig\\n  );\\n\\n  /**\\n   * @notice Emitted when an auction that has already ended is settled,\\n   * indicating that the NFT has been transferred and revenue from the sale distributed.\\n   * @param auctionId The id of the auction that was finalized.\\n   * @param seller The address of the seller.\\n   * @param bidder The address of the highest bidder that won the NFT.\\n   * @param price The value of the highest bid\\n   */\\n  event AuctionSellingAgreementSettled(\\n    address indexed nftContract,\\n    uint256 indexed tokenId,\\n    uint256 indexed auctionId,\\n    address seller,\\n    address bidder,\\n    uint256 price,\\n    bool isPrimarySale\\n  );\\n\\n  /**\\n   * @notice If an auction has been created but has not yet received bids, it may be canceled by the seller.\\n   * @dev The NFT is transferred back to the owner.\\n   * @param auctionId The id of the auction to cancel.\\n   */\\n  function cancelAuctionSellingAgreement(uint256 auctionId) external;\\n\\n  /**\\n   * @notice Creates an auction for the given NFT.\\n   * The NFT is held in escrow until the auction is finalized or canceled.\\n   * @param auctionConfig The auction configuration\\n   */\\n  function createAuctionSellingAgreement(\\n    InitAuctionArguments calldata auctionConfig\\n  ) external;\\n\\n  // /**\\n  //  * @notice If an auction has been created but has not yet received bids, it may be canceled by the seller.\\n  //  * @dev The NFT is transferred back to the owner.\\n  //  */\\n  // function buyOutAuctionSellingAgreement(uint256 auctionId) external payable;\\n\\n  /**\\n   * @notice Place a bid in an auction.\\n   * A bidder may place a bid which is at least the amount defined by `getMinBidAmount`.\\n   * If this is the first bid on a reserve priced triggered auction, the countdown will begin.\\n   * If there is already an outstanding bid, the previous bider will be refunded at this time\\n   * and if the bid is placed in the final moments of the auction, the countdown may be extended.\\n   * @param auctionId The id of the auction to bid on.\\n   */\\n  /* solhint-disable-next-line code-complexity */\\n  function placeBidOnAuctionSellingAgreement(\\n    uint256 auctionId\\n  ) external payable;\\n\\n  /**\\n   * @notice Settle an auction that has already ended.\\n   * This will send the NFT to the highest bidder and distribute revenue for this sale.\\n   */\\n  function settleAuctionSellingAgreement(uint256 auctionId) external payable;\\n\\n  /**\\n   * @notice Returns auction details for a given auctionId.\\n   * @param auctionId The id of the auction to lookup.\\n   */\\n  function getAuctionSellingAgreementDetails(\\n    uint256 auctionId\\n  ) external view returns (AuctionState memory auction);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IBuyNowSellingAgreementProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.8;\\n\\nstruct BuyNowSellingAgreement {\\n  address payable seller;\\n  uint256 price;\\n  uint256 startTime; // if the start time is 0, then the sale start immediately.\\n  bool isPrimarySale;\\n  uint256 id; // a unique identifier for each selling agreement\\n}\\n\\n/**\\n * @dev Interface which declares the custom types, events, errors, and public function that a contract needs to have\\n * @dev to offer the buy-now mechanics.\\n */\\ninterface IBuyNowSellingAgreementProvider {\\n  /**\\n   * @notice Emitted when a buy now selling agreement is created by a seller.\\n   *\\n   * @param nftContract   : The address of the contract that minted the NFT.\\n   * @param tokenId       : The ID of the NFT within the contract.\\n   * @param seller        : The address of the seller who created the selling agreement.\\n   * @param price         : The price at which someone could buy this NFT. Needs to be greater than 0.\\n   * @param startTime     : The timestamp indicating when this NFT can be sold. If set to 0, then the sale starts immediately.\\n   * @param isPrimarySale : Flag indicating if this is a primary sale. Royalty distribution is affected depending on this.\\n   * @param id            : Unique identifier of the sale\\n\\n   */\\n  event BuyNowSellingAgreementCreated(\\n    address indexed nftContract,\\n    uint256 indexed tokenId,\\n    address indexed seller,\\n    uint256 price,\\n    uint256 startTime,\\n    bool isPrimarySale,\\n    uint256 id\\n  );\\n\\n  /**\\n   * @notice Emitted when a buy now selling agreement is accepted by a buyer.\\n   *\\n   * @param nftContract    : The address of the contract that minted the NFT.\\n   * @param tokenId        : The ID of the NFT within the contract.\\n   * @param seller         : The address of the seller.\\n   * @param buyer          : The address of the seller.\\n   * @param wasPrimarySale : Flag indicating if this was a primary sale. Royalty distribution is affected depending on this.\\n   * @param id             : Unique identifier of the sale\\n   * @param price         : The price at which someone could buy this NFT. Needs to be greater than 0.\\n\\n\\n   */\\n  event BuyNowSellingAgreementAccepted(\\n    address indexed nftContract,\\n    uint256 indexed tokenId,\\n    address indexed seller,\\n    address buyer,\\n    bool wasPrimarySale,\\n    uint256 id,\\n    uint256 price\\n  );\\n\\n  /**\\n   * @notice Emitted when a buy now selling agreement is cancelled by the seller.\\n   *\\n   * @param nftContract : The address of the contract that minted the NFT.\\n   * @param tokenId     : The ID of the NFT within the contract.\\n   * @param seller      : The address of the seller.\\n   * @param id            : Unique identifier of the sale\\n\\n   */\\n  event BuyNowSellingAgreementCancelled(\\n    address indexed nftContract,\\n    uint256 indexed tokenId,\\n    address indexed seller,\\n    uint256 id\\n  );\\n\\n  /**\\n   * @notice Emitted when a buy now selling agreement is edited by the seller.\\n   *\\n   * @param nftContract : The address of the contract that minted the NFT.\\n   * @param tokenId     : The ID of the NFT within the contract.\\n   * @param seller      : The address of the seller.\\n   * @param newPrice    : The new price of the selling agreement.\\n   * @param id          : Unique identifier of the sale\\n\\n   */\\n  event BuyNowSellingAgreementEdited(\\n    address indexed nftContract,\\n    uint256 indexed tokenId,\\n    address indexed seller,\\n    uint256 newPrice,\\n    uint256 id\\n  );\\n\\n  /**\\n   * @notice Allows a seller to create a buy now selling agreement for an NFT.\\n   *\\n   * @param nftContractAddress   : The address of the contract that minted the NFT.\\n   * @param tokenId              : The ID of the NFT within the contract.\\n   * @param price                : The price at which someone could buy this NFT. Needs to be greater than 0.\\n   * @param startTime            : The timestamp indicating when this NFT can be sold. If set to 0, then the sale starts immediately.\\n   * @param isPrimarySale        : Flag indicating if this is a primary sale. Royalty distribution is affected depending on this.\\n   *\\n   * @dev There should be no incentive for users to pass the wrong `isPrimarySale` value.\\n   */\\n  function createBuyNowSellingAgreement(\\n    address nftContractAddress,\\n    uint256 tokenId,\\n    uint256 price,\\n    uint256 startTime,\\n    bool isPrimarySale\\n  ) external;\\n\\n  /**\\n   * @notice Allows a buyer to accept a buy now sale agreement for an NFT.\\n   *\\n   * @param nftContractAddress   : The address of the contract that minted the NFT.\\n   * @param tokenId              : The ID of the NFT within the contract.\\n   */\\n  function acceptBuyNowSellingAgreement(\\n    address nftContractAddress,\\n    uint256 tokenId\\n  ) external payable;\\n\\n  /**\\n   * @notice Allows a seller to cancel a buy now sale agreement for an NFT which is already on sale.\\n   *\\n   * @param nftContractAddress   : The address of the contract that minted the NFT.\\n   * @param tokenId              : The ID of the NFT within the contract.\\n   */\\n  function cancelBuyNowSellingAgreement(\\n    address nftContractAddress,\\n    uint256 tokenId\\n  ) external;\\n\\n  /**\\n   * @notice Allows a user to edit the price for a buy now selling agreement.\\n   *\\n   * @param nftContractAddress : The address of the contract that minted the NFT.\\n   * @param tokenId            : The ID of the NFT within the contract.\\n   * @param newPrice           : The new set price for the NFT. Needs to be greater than 0.\\n   */\\n  function editBuyNowSellingAgreement(\\n    address nftContractAddress,\\n    uint256 tokenId,\\n    uint256 newPrice\\n  ) external;\\n\\n  /**\\n   * @notice Returns the buy now sale details for an NFT if one is available.\\n   *\\n   * @dev If no price is found, seller will be address(0) and price will be max uint256.\\n   *\\n   * @param nftContract The address of the NFT contract.\\n   * @param tokenId The id of the NFT.\\n   *\\n   * @return id Unique identification of the sale.\\n   * @return seller The address of the owner that listed a buy price for this NFT.\\n   *         Returns `address(0)` if there is no buy price set for this NFT.\\n   * @return price The price of the NFT.\\n   *         Returns 0 if there is no buy price set for this NFT (since a price of 0 is supported).\\n   * @return startTime The start time of this buy now sale.\\n   *         Returns 0 if sale is not scheduled\\n   * @return isPrimarySale Flag to determine if this is a primary sale.\\n   *         Returns flase if sale does not exist\\n   */\\n  function getBuyNowSellingAgreementDetails(\\n    address nftContract,\\n    uint256 tokenId\\n  )\\n    external\\n    view\\n    returns (\\n      uint256 id,\\n      address seller,\\n      uint256 price,\\n      uint256 startTime,\\n      bool isPrimarySale\\n    );\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IOfferSellingAgreementProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.8;\\n\\nstruct Offer {\\n  /// @notice The address of the NFT contract.\\n  address nftContract;\\n  /// @notice The id of the NFT.\\n  uint256 tokenId;\\n  /// @notice The address of the wallet placing the offer.\\n  address buyer;\\n  /// @notice The amount the buyer is willing to pay for the NFT.\\n  uint256 offerPrice;\\n}\\n\\ninterface IOfferSellingAgreementProvider {\\n  /**\\n   * @notice Emitted when an offer selling agreement is created by a buyer..\\n   *\\n   * @param nftContract   : The address of the contract that minted the NFT.\\n   * @param tokenId       : The ID of the NFT within the contract.\\n   * @param buyer         : The address of the buyer who created the selling agreement.\\n   * @param price         : The offer amount.\\n   * @param id            : Unique identifier of the sale.\\n   */\\n  event OfferSellingAgreementCreated(\\n    address indexed nftContract,\\n    uint256 indexed tokenId,\\n    address indexed buyer,\\n    uint256 price,\\n    uint256 id\\n  );\\n\\n  /**\\n   * @notice Emitted when an offer selling agreement is cancelled by the buyer.\\n   *\\n   * @param nftContract   : The address of the contract that minted the NFT.\\n   * @param tokenId       : The ID of the NFT within the contract.\\n   * @param buyer         : The address of the buyer who created the selling agreement.\\n   * @param price         : The offer amount.\\n   * @param id            : Unique identifier of the sale.\\n   */\\n  event OfferSellingAgreementCancelled(\\n    address indexed nftContract,\\n    uint256 indexed tokenId,\\n    address indexed buyer,\\n    uint256 price,\\n    uint256 id\\n  );\\n\\n  /**\\n   * @notice Emitted when an offer selling agreement is created by a buyer.\\n   *\\n   * @param nftContract   : The address of the contract that minted the NFT.\\n   * @param tokenId       : The ID of the NFT within the contract.\\n   * @param seller        : The address of the seller who accepted the trade.\\n   * @param buyer         : The address of the buyer who created the selling agreement.\\n   * @param price         : The offer amount.\\n   * @param isPrimarySale : Whether this is a primary or secondary sale. Relevant for revenue split.\\n   * @param id            : Unique identifier of the sale.\\n   */\\n  event OfferSellingAgreementAccepted(\\n    address indexed nftContract,\\n    uint256 indexed tokenId,\\n    address indexed seller,\\n    address buyer,\\n    uint256 price,\\n    bool isPrimarySale,\\n    uint256 id\\n  );\\n\\n  /**\\n   * @notice Allows a buyer to place an offer for an NFT.\\n   *\\n   * @param nftContract   : The address of the contract that minted the NFT.\\n   * @param tokenId       : The ID of the NFT within the contract.\\n   * @param offerAmount   : The ID of the NFT within the contract.\\n   */\\n  function createOfferSellingAgreement(\\n    address nftContract,\\n    uint256 tokenId,\\n    uint256 offerAmount\\n  ) external payable;\\n\\n  /**\\n   * @notice Allows a buyer to cancel their offer for a specific NFT.\\n   * @param offerId   : The ID of the offer to cancel.\\n   */\\n  function cancelOfferSellingAgreement(uint256 offerId) external;\\n\\n  /**\\n   * @notice Allows the owner of an NFT to accept an offer placed on that NFT\\n   * @param offerId   : The ID of the offer to accept.\\n   */\\n  function acceptOfferSellingAgreement(\\n    uint256 offerId,\\n    bool isPrimarySale\\n  ) external;\\n\\n  function getOfferSellingAgreementDetails(\\n    uint256 offerId\\n  )\\n    external\\n    view\\n    returns (\\n      address nftContract,\\n      uint256 tokenId,\\n      address buyer,\\n      uint256 offerAmount\\n    );\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IOwnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\ninterface IOwnable {\\n  /**\\n   * @dev Returns the address of the current owner.\\n   */\\n  function owner() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ITokenCreator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\npragma solidity ^0.8.8;\\n\\ninterface ITokenCreator {\\n  /**\\n   * @notice Returns the creator of this NFT collection.\\n   * @param tokenId The ID of the NFT to get the creator payment address for.\\n   * @return creator The creator of this collection.\\n   */\\n  function tokenCreator(\\n    uint256 tokenId\\n  ) external view returns (address payable creator);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/royalties/IGetFees.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\npragma solidity ^0.8.8;\\n\\n/**\\n * @notice An interface for communicating fees to 3rd party marketplaces.\\n * @dev Originally implemented in mainnet contract 0x44d6e8933f8271abcf253c72f9ed7e0e4c0323b3\\n */\\ninterface IGetFees {\\n  /**\\n   * @notice Get the recipient addresses to which creator royalties should be sent.\\n   * @dev The expected royalty amounts are communicated with `getFeeBps`.\\n   * @param tokenId The ID of the NFT to get royalties for.\\n   * @return recipients An array of addresses to which royalties should be sent.\\n   */\\n  function getFeeRecipients(\\n    uint256 tokenId\\n  ) external view returns (address payable[] memory recipients);\\n\\n  /**\\n   * @notice Get the creator royalty amounts to be sent to each recipient, in basis points.\\n   * @dev The expected recipients are communicated with `getFeeRecipients`.\\n   * @param tokenId The ID of the NFT to get royalties for.\\n   * @return royaltiesInBasisPoints The array of fees to be sent to each recipient, in basis points.\\n   */\\n  function getFeeBps(\\n    uint256 tokenId\\n  ) external view returns (uint256[] memory royaltiesInBasisPoints);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/royalties/IGetRoyalties.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.8;\\n\\ninterface IGetRoyalties {\\n  function getRoyalties(\\n    uint256 tokenId\\n  )\\n    external\\n    view\\n    returns (\\n      address payable[] memory recipients,\\n      uint256[] memory royaltiesInBasisPoints\\n    );\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/royalties/IRoyaltyInfo.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\npragma solidity ^0.8.8;\\n\\n// todo: is this used?\\n/**\\n * @notice Interface for EIP-2981: NFT Royalty Standard.\\n * For more see: https://eips.ethereum.org/EIPS/eip-2981.\\n */\\ninterface IRoyaltyInfo {\\n  /**\\n   * @notice Get the creator royalties to be sent.\\n   * @param tokenId The ID of the NFT to get royalties for.\\n   * @param salePrice The total price of the sale.\\n   * @return receiver The address to which royalties should be sent.\\n   * @return royaltyAmount The total amount that should be sent to the `receiver`.\\n   */\\n  function royaltyInfo(\\n    uint256 tokenId,\\n    uint256 salePrice\\n  ) external view returns (address receiver, uint256 royaltyAmount);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/royalties/IRoyaltyRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\n/// @author: manifold.xyz\\n\\nimport \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Royalty registry interface\\n */\\ninterface IRoyaltyRegistry is IERC165 {\\n  event RoyaltyOverride(\\n    address owner,\\n    address tokenAddress,\\n    address royaltyAddress\\n  );\\n\\n  /**\\n   * Override the location of where to look up royalty information for a given token contract.\\n   * Allows for backwards compatibility and implementation of royalty logic for contracts that did not previously support them.\\n   *\\n   * @param tokenAddress    - The token address you wish to override\\n   * @param royaltyAddress  - The royalty override address\\n   */\\n  function setRoyaltyLookupAddress(\\n    address tokenAddress,\\n    address royaltyAddress\\n  ) external;\\n\\n  /**\\n   * Returns royalty address location.  Returns the tokenAddress by default, or the override if it exists\\n   *\\n   * @param tokenAddress    - The token address you are looking up the royalty for\\n   */\\n  function getRoyaltyLookupAddress(\\n    address tokenAddress\\n  ) external view returns (address);\\n\\n  /**\\n   * Whether or not the message sender can override the royalty address for the given token address\\n   *\\n   * @param tokenAddress    - The token address you are looking up the royalty for\\n   */\\n  function overrideAllowed(address tokenAddress) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/AuctionSellingAgreementChecks.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.8;\\nimport \\\"hardhat/console.sol\\\";\\n\\nimport \\\"../mixins/shared/Errors.sol\\\";\\nimport \\\"../interfaces/IAuctionSellingAgreementProvider.sol\\\";\\n\\nlibrary AuctionSellingAgreementChecks {\\n  function mustNotExist(uint256 auctionId) internal pure {\\n    if (auctionId != 0) {\\n      revert NFTMarketAuction__AlreadyExists(auctionId);\\n    }\\n  }\\n\\n  function mustExist(AuctionBasicState memory auction) internal pure {\\n    if (auction.reservePriceOrHighestBid == 0) {\\n      revert NFTMarketAuction__Inexistent();\\n    }\\n  }\\n\\n  function mustBeConfigurable(AuctionBasicState memory auction) internal pure {\\n    if (auction.isStandardAuction) {\\n      revert NFTMarketAuction__IsNotConfigurable();\\n    }\\n  }\\n\\n  function mustHaveEnded(\\n    AuctionBasicState memory auction,\\n    uint256 currentTime\\n  ) internal pure {\\n    if (auction.end > currentTime) {\\n      revert NFTMarketAuction__Ongoing();\\n    }\\n  }\\n\\n  function mustBeOngoing(\\n    AuctionBasicState memory auction,\\n    uint256 currentTime,\\n    bool isReservePriceTriggered\\n  ) internal pure {\\n    if (\\n      (!isReservePriceTriggered && auction.end < currentTime) ||\\n      (isReservePriceTriggered &&\\n        auction.highestBidder != address(0) &&\\n        auction.end < currentTime)\\n    ) {\\n      revert NFTMarketAuction__Ended();\\n    }\\n  }\\n\\n  function callerMustBeSeller(\\n    AuctionBasicState memory auction,\\n    address caller\\n  ) internal pure {\\n    if (auction.seller != caller) {\\n      revert NFTMarketAuction__Inexistent();\\n    }\\n  }\\n\\n  function callerMustNotBeSeller(\\n    AuctionBasicState memory auction,\\n    address caller\\n  ) internal pure {\\n    if (auction.seller == caller) {\\n      revert NFTMarketAuction__callerMustNotBeSeller();\\n    }\\n  }\\n\\n  function mustHaveAtLeastOneBid(\\n    AuctionBasicState memory auction\\n  ) internal pure {\\n    if (auction.highestBidder == address(0)) {\\n      revert NFTMarketAuction__DoesNotHaveBids();\\n    }\\n  }\\n\\n  function mustNotHaveBids(AuctionBasicState memory auction) internal pure {\\n    if (auction.highestBidder != address(0)) {\\n      revert NFTMarketAuction__DoesHaveBids();\\n    }\\n  }\\n\\n  function mustBeGreaterThanOrEqual(\\n    uint256 value,\\n    uint256 compareTo\\n  ) internal pure {\\n    if (compareTo > value) {\\n      revert NFTMarketAuction__PriceNotMet();\\n    }\\n  }\\n\\n  function mustBeReedemedByOwnerOrHighestBidder(\\n    AuctionBasicState memory auction,\\n    address caller\\n  ) internal pure {\\n    if (caller != auction.seller && caller != auction.highestBidder) {\\n      revert NFTMarketAuction__InvalidCaller();\\n    }\\n  }\\n\\n  function callerCannotBeHighestBidder(\\n    AuctionBasicState memory auction,\\n    address caller\\n  ) internal pure {\\n    if (caller == auction.highestBidder) {\\n      revert NFTMarketAuction__callerIsHighestBidder();\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/BuyNowSellingAgreementChecks.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.8;\\n\\nimport \\\"../mixins/shared/Errors.sol\\\";\\nimport \\\"../interfaces/IBuyNowSellingAgreementProvider.sol\\\";\\n\\nlibrary BuyNowSellingAgreementChecks {\\n  function mustNotExist(\\n    BuyNowSellingAgreement memory sellingAgreement\\n  ) internal pure {\\n    if (sellingAgreement.price > 0) {\\n      revert NFTMarketBuyNow__SellingAgreement__AlreadyExists();\\n    }\\n  }\\n\\n  function mustExist(\\n    BuyNowSellingAgreement memory sellingAgreement\\n  ) internal pure {\\n    if (sellingAgreement.price == 0) {\\n      revert NFTMarketBuyNow__SellingAgreement__DoesNotExist();\\n    }\\n  }\\n\\n  function mustHaveStarted(\\n    BuyNowSellingAgreement memory sellingAgreement\\n  ) internal view {\\n    if (sellingAgreement.startTime > block.timestamp) {\\n      revert NFTMarketBuyNow__SellingAgreement__NotStarted();\\n    }\\n  }\\n\\n  function mustBeOwnedBy(\\n    BuyNowSellingAgreement memory sellingAgreement,\\n    address seller\\n  ) internal pure {\\n    if (sellingAgreement.seller != seller) {\\n      revert NFTMarketBuyNow__SellingAgreement__SellerMismatch();\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/ERC165Checks.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\n/**\\n * From https://github.com/OpenZeppelin/openzeppelin-contracts\\n * Copying the method below which is currently unreleased.\\n */\\n\\nimport \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @title Library to query ERC165 support.\\n * @dev Library used to query support of an interface declared via {IERC165}.\\n *\\n * Note that these functions return the actual result of the query: they do not\\n * `revert` if an interface is not supported. It is up to the caller to decide\\n * what to do in these cases.\\n */\\nlibrary ERC165Checks {\\n  /**\\n   * @notice Query if a contract implements an interface, does not check ERC165 support\\n   *\\n   * @param account The address of the contract to query for support of an interface\\n   * @param interfaceId The interface identifier, as specified in ERC-165\\n   *\\n   * @return true if the contract at account indicates support of the interface with\\n   * identifier interfaceId, false otherwise\\n   *\\n   * @dev Assumes that account contains a contract that supports ERC165, otherwise\\n   * the behavior of this method is undefined. This precondition can be checked\\n   * with {supportsERC165}.\\n   *\\n   * Interface identification is specified in ERC-165.\\n   */\\n  function supportsERC165InterfaceUnchecked(\\n    address account,\\n    bytes4 interfaceId\\n  ) internal view returns (bool) {\\n    bytes memory encodedParams = abi.encodeWithSelector(\\n      IERC165.supportsInterface.selector,\\n      interfaceId\\n    );\\n    (bool success, bytes memory result) = account.staticcall{gas: 30_000}(\\n      encodedParams\\n    );\\n    if (result.length < 32) return false;\\n    return success && abi.decode(result, (uint256)) > 0;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/ERC721Checks.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.8;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport \\\"../mixins/shared/Errors.sol\\\";\\n\\nlibrary ERC721Checks {\\n  function sellerMustBeOwner(\\n    IERC721 nftContract,\\n    uint256 tokenId,\\n    address seller\\n  ) internal view {\\n    address owner = nftContract.ownerOf(tokenId);\\n    if (owner != seller) {\\n      revert NFTMarketBuyNow__SellingAgreement__NotTokenOwner();\\n    }\\n  }\\n\\n  function marketplaceMustBeApproved(\\n    IERC721 nftContract,\\n    address seller\\n  ) internal view {\\n    bool approved = nftContract.isApprovedForAll(seller, address(this));\\n    if (!approved) {\\n      revert NFTMarketBuyNow__MarketplaceNotApproved();\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/NumericChecks.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.8;\\n\\nimport \\\"../mixins/shared/Errors.sol\\\";\\n\\nlibrary NumericChecks {\\n  function mustBeGreaterThan(uint256 value, uint256 compareTo) internal pure {\\n    if (compareTo >= value) {\\n      revert ValueNotMet(value, compareTo);\\n    }\\n  }\\n\\n  function mustBeEqualTo(uint256 value, uint256 compareTo) internal pure {\\n    if (compareTo != value) {\\n      revert ValuesNotEqauls(value, compareTo);\\n    }\\n  }\\n\\n  function mustBeValidAmount(uint256 value) internal pure {\\n    if (value < 10_000_000_000_000) {\\n      revert ValueMustBeAboveMinimumAmount(value);\\n    }\\n\\n    if (value % 10_000_000_000_000 != 0) {\\n      revert ValueMustBeMultipleOfMinimumAmount(value);\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/OfferSellingAgreementChecks.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.8;\\n\\nimport \\\"../mixins/shared/Errors.sol\\\";\\nimport \\\"../interfaces/IOfferSellingAgreementProvider.sol\\\";\\n\\nlibrary OfferSellingAgreementChecks {\\n  function mustNotExist(uint256 offerId) internal pure {\\n    if (offerId != 0) {\\n      revert NFTMarketOffers__AlreadyExists(offerId);\\n    }\\n  }\\n\\n  function mustExist(Offer memory offer) internal pure {\\n    if (offer.offerPrice == 0) {\\n      revert NFTMarketOffers__DoesNotExist();\\n    }\\n  }\\n\\n  function mustBeInitializerOf(\\n    address sender,\\n    Offer memory offer\\n  ) internal pure {\\n    if (sender != offer.buyer) {\\n      revert NFTMarketOffers__CallerIsNotInitializer();\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/mixins/AuctionSellingAgreementProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\\\";\\n\\nimport \\\"../libraries/ERC721Checks.sol\\\";\\nimport \\\"../libraries/NumericChecks.sol\\\";\\nimport \\\"../libraries/AuctionSellingAgreementChecks.sol\\\";\\n\\nimport \\\"./shared/PaymentsAware.sol\\\";\\n\\nimport \\\"./IdGenerator.sol\\\";\\nimport \\\"../interfaces/IAuctionSellingAgreementProvider.sol\\\";\\n\\n/**\\n * @title Allows the owner of an NFT to list it in auction.\\n * @notice NFTs in auction are escrowed in the market contract.\\n */\\nabstract contract AuctionSellingAgreementProvider is\\n  Initializable,\\n  IdGenerator,\\n  IAuctionSellingAgreementProvider,\\n  PaymentsAware,\\n  ReentrancyGuardUpgradeable\\n{\\n  using AddressUpgradeable for address payable;\\n  using ERC721Checks for IERC721;\\n  using NumericChecks for uint256;\\n  using AuctionSellingAgreementChecks for AuctionBasicState;\\n  using AuctionSellingAgreementChecks for uint256;\\n\\n  //todo change these\\n  uint256 private constant STANDARD_EXTENSION_WINDOW = 5 minutes;\\n  uint256 private constant STANDARD_DURATION = 24 hours;\\n  uint256 private constant STANDARD_ENDING_PHASE = 15 minutes;\\n  uint256 private constant STANDARD_ENDING_PHASE_PERCENTAGE_FLIP = 10; // percentage;\\n\\n  /// @notice The basic auction configuration\\n  mapping(address => mapping(uint256 => uint256))\\n    private nftContractToTokenIdToAuctionId;\\n  /// @notice The auction id for a specific NFT.\\n  mapping(uint256 => AuctionBasicState) private auctionIdToAuctionBasicState;\\n  /// @notice Extra configurations if the sellers opts in for this feature\\n  mapping(uint256 => AuctionAdditionalConfiguration)\\n    private auctionIdToAuctioAdditionalConfigurations;\\n\\n  /// @notice Confirms that the configs provided are correct\\n  modifier onlyValidAuctionConfig(InitAuctionArguments memory configs) {\\n    configs.reservePrice.mustBeValidAmount();\\n    configs.minimumIncrement.mustBeValidAmount();\\n    if (!configs.isStandardAuction) {\\n      if (configs.endingPhasePercentageFlip == 0 && configs.endingPhase != 0) {\\n        revert NFTMarketAuction__EndingPhaseProvidedWithNopercentageFlip();\\n      }\\n      if (configs.endingPhasePercentageFlip >= 100) {\\n        revert NFTMarketAuction__PercentageFlipGreaterThan100(\\n          configs.endingPhasePercentageFlip\\n        );\\n      }\\n      if (!configs.isReservePriceTriggered && configs.start > configs.end) {\\n        revert NFTMarketAuction__StartGreaterThanEnd();\\n      }\\n      if (\\n        (!configs.isReservePriceTriggered &&\\n          configs.endingPhase > configs.end - configs.start) ||\\n        (configs.isReservePriceTriggered && configs.endingPhase > configs.start)\\n      ) {\\n        revert NFTMarketAuction__EndingPhaseGraterThanDuration(\\n          configs.endingPhase\\n        );\\n      }\\n      if (configs.extensionWindow > configs.endingPhase) {\\n        revert NFTMarketAuction__ExrtensionWindowGraterThanEndingPhase(\\n          configs.extensionWindow\\n        );\\n      }\\n    }\\n\\n    _;\\n  }\\n\\n  /**\\n   * @dev see {IExchangeArtNFTMarketAuction - createAuctionSellingAgreement}\\n   */\\n  function createAuctionSellingAgreement(\\n    // todo memory or call data?\\n    InitAuctionArguments memory auctionConfig\\n  )\\n    external\\n    nonReentrant\\n    // todo remove onlyvalidfunction and add a check to be called only for configurable functions\\n    onlyValidAuctionConfig(auctionConfig)\\n  {\\n    IERC721 nftContract = IERC721(auctionConfig.nftContract);\\n    uint256 auctionId = nftContractToTokenIdToAuctionId[\\n      auctionConfig.nftContract\\n    ][auctionConfig.tokenId];\\n\\n    nftContract.sellerMustBeOwner(auctionConfig.tokenId, msg.sender);\\n    nftContract.marketplaceMustBeApproved(msg.sender);\\n    auctionId.mustNotExist();\\n\\n    nftContract.transferFrom(msg.sender, address(this), auctionConfig.tokenId);\\n    uint256 newAuctionId = getSellingAgreementId();\\n    incrementSellingAgreementId();\\n\\n    // Store the auction details\\n    nftContractToTokenIdToAuctionId[auctionConfig.nftContract][\\n      auctionConfig.tokenId\\n    ] = newAuctionId;\\n    AuctionBasicState storage basicAuctionConfig = auctionIdToAuctionBasicState[\\n      newAuctionId\\n    ];\\n\\n    basicAuctionConfig.nftContract = auctionConfig.nftContract;\\n    basicAuctionConfig.tokenId = auctionConfig.tokenId;\\n    basicAuctionConfig.seller = payable(msg.sender);\\n    basicAuctionConfig.reservePriceOrHighestBid = auctionConfig.reservePrice;\\n    basicAuctionConfig.isPrimarySale = auctionConfig.isPrimarySale;\\n    basicAuctionConfig.isStandardAuction = auctionConfig.isStandardAuction;\\n    basicAuctionConfig.minimumIncrement = auctionConfig.minimumIncrement;\\n\\n    //Save auction configuration details to be sent in the event\\n    AuctionCreatedEventArguments memory auctionConfigsEventInfo;\\n    auctionConfigsEventInfo.nftContract = auctionConfig.nftContract;\\n    auctionConfigsEventInfo.tokenId = auctionConfig.tokenId;\\n    auctionConfigsEventInfo.reservePrice = auctionConfig.reservePrice;\\n    auctionConfigsEventInfo.minimumIncrement = auctionConfig.minimumIncrement;\\n\\n    // If is not a reserve price triggered auction start immediately\\n    if (\\n      !auctionConfig.isReservePriceTriggered && !auctionConfig.isStandardAuction\\n    ) {\\n      basicAuctionConfig.end = auctionConfig.end;\\n      auctionConfigsEventInfo.end = auctionConfig.end;\\n    }\\n    if (!auctionConfig.isStandardAuction) {\\n      AuctionAdditionalConfiguration\\n        storage additionalConfigurations = auctionIdToAuctioAdditionalConfigurations[\\n          newAuctionId\\n        ];\\n      additionalConfigurations.endingPhase = auctionConfig.endingPhase;\\n      //additionalConfigurations.buyOutPrice = auctionConfig.buyOutPrice;\\n\\n      additionalConfigurations.endingPhasePercentageFlip = auctionConfig\\n        .endingPhasePercentageFlip;\\n      additionalConfigurations.extensionWindow = auctionConfig.extensionWindow;\\n      additionalConfigurations.start = auctionConfig.start;\\n      additionalConfigurations.isReservePriceTriggered = auctionConfig\\n        .isReservePriceTriggered;\\n\\n      auctionConfigsEventInfo.endingPhase = auctionConfig.endingPhase;\\n      auctionConfigsEventInfo.endingPhasePercentageFlip = auctionConfig\\n        .endingPhasePercentageFlip;\\n      auctionConfigsEventInfo.extensionWindow = auctionConfig.extensionWindow;\\n      auctionConfigsEventInfo.start = auctionConfig.start;\\n    } else {\\n      auctionConfigsEventInfo.endingPhase = STANDARD_ENDING_PHASE;\\n      auctionConfigsEventInfo\\n        .endingPhasePercentageFlip = STANDARD_ENDING_PHASE_PERCENTAGE_FLIP;\\n      auctionConfigsEventInfo.extensionWindow = STANDARD_EXTENSION_WINDOW;\\n      auctionConfigsEventInfo.start = STANDARD_DURATION;\\n    }\\n\\n    emit AuctionSellingAgreementCreated(\\n      newAuctionId,\\n      msg.sender,\\n      auctionConfigsEventInfo\\n    );\\n  }\\n\\n  /**\\n   * @dev see {IExchangeArtNFTMarketAuction - cancelAuctionSellingAgreement}\\n   */\\n  function cancelAuctionSellingAgreement(\\n    uint256 auctionId\\n  ) external nonReentrant {\\n    AuctionBasicState memory auction = auctionIdToAuctionBasicState[auctionId];\\n    IERC721 nftContract = IERC721(auction.nftContract);\\n\\n    auction.callerMustBeSeller(msg.sender);\\n    auction.mustExist();\\n    auction.mustNotHaveBids();\\n\\n    // Remove the auction.\\n    delete nftContractToTokenIdToAuctionId[auction.nftContract][\\n      auction.tokenId\\n    ];\\n    delete auctionIdToAuctionBasicState[auctionId];\\n    if (!auction.isStandardAuction) {\\n      delete auctionIdToAuctioAdditionalConfigurations[auctionId];\\n    }\\n\\n    nftContract.transferFrom(address(this), msg.sender, auction.tokenId);\\n\\n    emit AuctionSellingAgreementCancelled(\\n      auction.nftContract,\\n      auction.tokenId,\\n      auctionId,\\n      auction.seller\\n    );\\n  }\\n\\n  // /**\\n  //  * @dev see {IExchangeArtNFTMarketAuction - buyOutAuctionSellingAgreement}\\n  //  */\\n  // function buyOutAuctionSellingAgreement(\\n  //   uint256 auctionId\\n  // ) external payable nonReentrant {\\n  //   AuctionBasicState memory auctionBasicState = auctionIdToAuctionBasicState[\\n  //     auctionId\\n  //   ];\\n\\n  //   IERC721 nftContract = IERC721(auctionBasicState.nftContract);\\n  //   auctionBasicState.mustExist();\\n  //   auctionBasicState.mustBeConfigurable();\\n\\n  //   AuctionAdditionalConfiguration\\n  //     memory auctionAdditionalConfigurations = auctionIdToAuctioAdditionalConfigurations[\\n  //       auctionId\\n  //     ];\\n\\n  //   uint256 totalAmountFeesIncluded = auctionBasicState.isPrimarySale\\n  //     ? auctionAdditionalConfigurations.buyOutPrice +\\n  //       (auctionAdditionalConfigurations.buyOutPrice *\\n  //         EXCHANGE_ART_PRIMARY_FEE) /\\n  //       10_000\\n  //     : auctionAdditionalConfigurations.buyOutPrice +\\n  //       (auctionAdditionalConfigurations.buyOutPrice *\\n  //         EXCHANGE_ART_SECONDARY_FEE) /\\n  //       10_000;\\n\\n  //   auctionBasicState.mustBeOngoing(\\n  //     block.timestamp,\\n  //     auctionAdditionalConfigurations.isReservePriceTriggered\\n  //   );\\n\\n  //   auctionAdditionalConfigurations.buyOutPrice.mustBeGreaterThan(\\n  //     auctionBasicState.reservePriceOrHighestBid\\n  //   );\\n  //   msg.value.mustBeEqualTo(totalAmountFeesIncluded);\\n\\n  //   // Remove the auction.\\n  //   delete nftContractToTokenIdToAuctionId[auctionBasicState.nftContract][\\n  //     auctionBasicState.tokenId\\n  //   ];\\n  //   delete auctionIdToAuctionBasicState[auctionId];\\n  //   delete auctionIdToAuctioAdditionalConfigurations[auctionId];\\n\\n  //   nftContract.transferFrom(\\n  //     address(this),\\n  //     msg.sender,\\n  //     auctionBasicState.tokenId\\n  //   );\\n\\n  //   //Distribute revenue for this sale.\\n  //   _handlePayments(\\n  //     auctionBasicState.nftContract,\\n  //     auctionBasicState.tokenId,\\n  //     auctionAdditionalConfigurations.buyOutPrice,\\n  //     auctionBasicState.seller,\\n  //     auctionBasicState.isPrimarySale\\n  //   );\\n\\n  //   emit AuctionSellingAgreementBuyOutTriggered(\\n  //     auctionId,\\n  //     msg.sender,\\n  //     auctionAdditionalConfigurations.buyOutPrice\\n  //   );\\n  // }\\n\\n  /**\\n   * @dev see {IExchangeArtNFTMarketAuction - placeBidOnAuctionSellingAgreement}\\n   */\\n  function placeBidOnAuctionSellingAgreement(\\n    uint256 auctionId\\n  ) public payable nonReentrant {\\n    AuctionBasicState storage auctionDetails = auctionIdToAuctionBasicState[\\n      auctionId\\n    ];\\n    AuctionAdditionalConfiguration\\n      memory auctionAdditionalConfigurations = auctionIdToAuctioAdditionalConfigurations[\\n        auctionId\\n      ];\\n\\n    // we compute the actual bid by subtracting the platform fees from msg.value\\n    uint256 actualBid = auctionDetails.isPrimarySale\\n      ? (msg.value * 100) / 105\\n      : (msg.value * 1000) / 1025;\\n    auctionDetails.mustExist();\\n    // Sellers cannot bid on their auctions\\n    auctionDetails.callerMustNotBeSeller(msg.sender);\\n    auctionDetails.callerCannotBeHighestBidder(msg.sender);\\n\\n    uint256 currentTime = block.timestamp;\\n    bool isFirstBid = auctionDetails.highestBidder == address(0);\\n    bool isStandardAuction = auctionDetails.isStandardAuction;\\n    address payable previousBidder = auctionDetails.highestBidder;\\n\\n    if (\\n      isStandardAuction ||\\n      (!isStandardAuction &&\\n        auctionAdditionalConfigurations.isReservePriceTriggered)\\n    ) {\\n      // we need to start the auction if this is the first bid\\n      if (isFirstBid) {\\n        if (isStandardAuction) {\\n          auctionDetails.end = currentTime + STANDARD_DURATION;\\n        } else {\\n          AuctionAdditionalConfiguration\\n            storage s_auctionAdditionalConfigurations = auctionIdToAuctioAdditionalConfigurations[\\n              auctionId\\n            ];\\n          auctionDetails.end =\\n            currentTime +\\n            auctionAdditionalConfigurations.start;\\n          s_auctionAdditionalConfigurations.start = currentTime;\\n        }\\n      } else {\\n        // Auction is ongoing, check to see if it's still active\\n        auctionDetails.end.mustBeGreaterThanOrEqual(currentTime);\\n      }\\n    } else {\\n      currentTime.mustBeGreaterThanOrEqual(\\n        auctionAdditionalConfigurations.start\\n      );\\n    }\\n\\n    uint256 requiredMinBid = getAuctionSellingAgreementMinBidAmount(auctionId);\\n    uint256 requiredMinBidFeesIncluded = auctionDetails.isPrimarySale\\n      ? requiredMinBid + (requiredMinBid * EXCHANGE_ART_PRIMARY_FEE) / 10_000\\n      : requiredMinBid + (requiredMinBid * EXCHANGE_ART_SECONDARY_FEE) / 10_000;\\n\\n    msg.value.mustBeGreaterThanOrEqual(requiredMinBidFeesIncluded);\\n    actualBid.mustBeGreaterThanOrEqual(requiredMinBid);\\n\\n    if (isFirstBid) {\\n      // Store the bid details.\\n      auctionDetails.reservePriceOrHighestBid = actualBid;\\n      auctionDetails.highestBidder = payable(msg.sender);\\n    } else {\\n      // Update bidder state\\n      uint256 previousBid = auctionDetails.reservePriceOrHighestBid;\\n      auctionDetails.reservePriceOrHighestBid = actualBid;\\n      auctionDetails.highestBidder = payable(msg.sender);\\n\\n      // Refund the previous bidder\\n      address payable[] memory bidderArray = new address payable[](1);\\n      bidderArray[0] = previousBidder;\\n      uint256[] memory previousBidArray = new uint256[](1);\\n      previousBidArray[0] = previousBid;\\n      _pushPayments(bidderArray, previousBidArray);\\n\\n      // When a user outbids another, check to see if a time extension should apply.\\n      // We confirmed that the auction has not ended, so endTime is always >= the current timestamp.\\n      uint256 extensionWindow = isStandardAuction\\n        ? STANDARD_EXTENSION_WINDOW\\n        : auctionAdditionalConfigurations.extensionWindow;\\n      uint256 endTimeWithExtension = block.timestamp + extensionWindow;\\n      if (auctionDetails.end < endTimeWithExtension) {\\n        auctionDetails.end = endTimeWithExtension;\\n        auctionDetails.end = auctionDetails.end;\\n      }\\n    }\\n\\n    BidEventArguments memory eventInfo;\\n    eventInfo.nftContract = auctionDetails.nftContract;\\n    eventInfo.tokenId = auctionDetails.tokenId;\\n    eventInfo.id = auctionId;\\n    eventInfo.bidder = msg.sender;\\n    eventInfo.seller = auctionDetails.seller;\\n    eventInfo.amount = actualBid;\\n    eventInfo.endTime = auctionDetails.end;\\n    eventInfo.startTime = auctionAdditionalConfigurations.start;\\n    eventInfo.prevHighestBidder = previousBidder;\\n\\n    emit AuctionSellingAgreementBidPlaced(eventInfo);\\n  }\\n\\n  /**\\n   * @dev see {IExchangeArtNFTMarketAuction - settleAuctionSellingAgreement}\\n   */\\n  function settleAuctionSellingAgreement(\\n    uint256 auctionId\\n  ) public payable nonReentrant {\\n    AuctionBasicState memory auction = auctionIdToAuctionBasicState[auctionId];\\n    IERC721 nftContract = IERC721(auction.nftContract);\\n\\n    auction.mustExist();\\n    auction.mustHaveEnded(block.timestamp);\\n    auction.mustHaveAtLeastOneBid();\\n    auction.mustBeReedemedByOwnerOrHighestBidder(msg.sender);\\n\\n    // Remove the auction.\\n    delete nftContractToTokenIdToAuctionId[auction.nftContract][\\n      auction.tokenId\\n    ];\\n    delete auctionIdToAuctionBasicState[auctionId];\\n    if (!auction.isStandardAuction) {\\n      delete auctionIdToAuctioAdditionalConfigurations[auctionId];\\n    }\\n\\n    nftContract.transferFrom(\\n      address(this),\\n      auction.highestBidder,\\n      auction.tokenId\\n    );\\n\\n    //Distribute revenue for this sale.\\n    _handlePayments(\\n      auction.nftContract,\\n      auction.tokenId,\\n      auction.reservePriceOrHighestBid,\\n      auction.seller,\\n      auction.isPrimarySale\\n    );\\n\\n    emit AuctionSellingAgreementSettled(\\n      auction.nftContract,\\n      auction.tokenId,\\n      auctionId,\\n      auction.seller,\\n      auction.highestBidder,\\n      auction.reservePriceOrHighestBid,\\n      auction.isPrimarySale\\n    );\\n  }\\n\\n  /**\\n   * @notice Returns the minimum amount a bidder must spend to participate in an auction at this particular moment in time.\\n   * Bids must be greater than or equal to this value or they will revert.\\n   * @param auctionId The id of the auction to check.\\n   * @return minimum The minimum amount for a bid to be accepted.\\n   */\\n  function getAuctionSellingAgreementMinBidAmount(\\n    uint256 auctionId\\n  ) public view returns (uint256 minimum) {\\n    // todo optimize this by sending values as parameters\\n    AuctionBasicState memory auctionDetails = auctionIdToAuctionBasicState[\\n      auctionId\\n    ];\\n    AuctionAdditionalConfiguration\\n      memory auctionAdditionalConfiguration = auctionIdToAuctioAdditionalConfigurations[\\n        auctionId\\n      ];\\n\\n    if (auctionDetails.end == 0 || auctionDetails.highestBidder == address(0)) {\\n      return auctionDetails.reservePriceOrHighestBid;\\n    }\\n    uint256 endingPhase = auctionDetails.isStandardAuction\\n      ? STANDARD_ENDING_PHASE\\n      : auctionAdditionalConfiguration.endingPhase;\\n    uint256 endingPhasePercentageFlip = auctionDetails.isStandardAuction\\n      ? STANDARD_ENDING_PHASE_PERCENTAGE_FLIP\\n      : auctionAdditionalConfiguration.endingPhasePercentageFlip;\\n\\n    if (block.timestamp >= auctionDetails.end - endingPhase) {\\n      // In the ending phase\\n      uint256 percentageBasedBid = auctionDetails.reservePriceOrHighestBid +\\n        (endingPhasePercentageFlip * auctionDetails.reservePriceOrHighestBid) /\\n        100;\\n      uint256 minIncrementBasedBid = auctionDetails.reservePriceOrHighestBid +\\n        auctionDetails.minimumIncrement;\\n\\n      if (percentageBasedBid > minIncrementBasedBid) {\\n        minimum = percentageBasedBid;\\n      } else {\\n        minimum = minIncrementBasedBid;\\n      }\\n    } else {\\n      minimum =\\n        auctionDetails.reservePriceOrHighestBid +\\n        auctionDetails.minimumIncrement;\\n    }\\n  }\\n\\n  /**\\n   * @dev see {IExchangeArtNFTMarketAuction - getAuctionSellingAgrementDetails}\\n   */\\n  function getAuctionSellingAgreementDetails(\\n    uint256 auctionId\\n  ) external view returns (AuctionState memory auction) {\\n    AuctionBasicState\\n      memory auctionStandardDetails = auctionIdToAuctionBasicState[auctionId];\\n\\n    auction.reservePriceOrHighestBid = auctionStandardDetails\\n      .reservePriceOrHighestBid;\\n    auction.nftContract = auctionStandardDetails.nftContract;\\n    auction.minimumIncrement = auctionStandardDetails.minimumIncrement;\\n    auction.highestBidder = auctionStandardDetails.highestBidder;\\n    auction.seller = auctionStandardDetails.seller;\\n    auction.end = auctionStandardDetails.end;\\n    auction.isPrimarySale = auctionStandardDetails.isPrimarySale;\\n    auction.isStandardAuction = auctionStandardDetails.isStandardAuction;\\n    if (auctionStandardDetails.isStandardAuction) {\\n      auction.endingPhase = STANDARD_ENDING_PHASE;\\n      auction.endingPhasePercentageFlip = STANDARD_ENDING_PHASE_PERCENTAGE_FLIP;\\n      auction.extensionWindow = STANDARD_EXTENSION_WINDOW;\\n      //auction.buyOutPrice = 0;\\n      auction.start = 0; // Standard auctions are reserved price triggered so don't have a start time\\n      auction.isReservePriceTriggered = true; // Standard auctions can only be reserved price triggered;\\n    } else {\\n      AuctionAdditionalConfiguration\\n        memory auctionAdditionalConfigurations = auctionIdToAuctioAdditionalConfigurations[\\n          auctionId\\n        ];\\n      auction.endingPhase = auctionAdditionalConfigurations.endingPhase;\\n      auction.endingPhasePercentageFlip = auctionAdditionalConfigurations\\n        .endingPhasePercentageFlip;\\n      auction.extensionWindow = auctionAdditionalConfigurations.extensionWindow;\\n      //auction.buyOutPrice = auctionAdditionalConfigurations.buyOutPrice;\\n      auction.start = auctionAdditionalConfigurations.start;\\n      auction.isReservePriceTriggered = auctionAdditionalConfigurations\\n        .isReservePriceTriggered;\\n    }\\n  }\\n\\n  /**\\n   * @notice Returns the auctionId for a given NFT, or 0 if no auction is found.\\n   * @dev If an auction is canceled, it will not be returned. However the auction may be over and pending finalization.\\n   * @param nftContract The address of the NFT contract.\\n   * @param tokenId The id of the NFT.\\n   * @return auctionId The id of the auction, or 0 if no auction is found.\\n   */\\n  function getAuctionSellingAgreementIdFor(\\n    address nftContract,\\n    uint256 tokenId\\n  ) external view returns (uint256 auctionId) {\\n    auctionId = nftContractToTokenIdToAuctionId[nftContract][tokenId];\\n  }\\n\\n  /**\\n   * @notice This empty reserved space is put in place to allow future versions to add new\\n   * variables without shifting down storage in the inheritance chain.\\n   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n   */\\n  uint256[1_000] private __gap;\\n}\\n\"\r\n    },\r\n    \"contracts/mixins/BuyNowSellingAgreementProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.8;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol\\\";\\nimport \\\"hardhat/console.sol\\\";\\n\\nimport \\\"../interfaces/royalties/IGetRoyalties.sol\\\";\\nimport \\\"../interfaces/IBuyNowSellingAgreementProvider.sol\\\";\\nimport \\\"../mixins/IdGenerator.sol\\\";\\nimport \\\"./shared/Constants.sol\\\";\\nimport \\\"./shared/PaymentsAware.sol\\\";\\nimport \\\"../libraries/NumericChecks.sol\\\";\\nimport \\\"../libraries/BuyNowSellingAgreementChecks.sol\\\";\\nimport \\\"../libraries/ERC721Checks.sol\\\";\\n\\n/**\\n * @dev Contract module which allows users to sell and buy NFTs for a fixed price.\\n *\\n * @dev This module is used through inheritance.\\n * @dev The implementer contract needs implement internal functions defined in IBuyNowSellingAgreementProvider.\\n *\\n * @dev This module simply manages the states of different buy now selling agreements.\\n * @dev It is aware that payments and trasnfers to/from escrow of NFTs need to be handled, but it is the responsibility\\n * @dev   of the implementer contract to provide that logic.\\n */\\nabstract contract BuyNowSellingAgreementProvider is\\n  Initializable,\\n  IdGenerator,\\n  IBuyNowSellingAgreementProvider,\\n  PaymentsAware,\\n  ReentrancyGuardUpgradeable\\n{\\n  using AddressUpgradeable for address payable;\\n  using BuyNowSellingAgreementChecks for BuyNowSellingAgreement;\\n  using NumericChecks for uint256;\\n  using ERC721Checks for IERC721;\\n  using CountersUpgradeable for CountersUpgradeable.Counter;\\n\\n  mapping(address => mapping(uint256 => BuyNowSellingAgreement))\\n    private s_buyNowSellingAgreements;\\n\\n  /// @dev see {IExchangeArtNFTMarketBuyNow-createBuyNowSellingAgreement}\\n  function createBuyNowSellingAgreement(\\n    address nftContractAddress,\\n    uint256 tokenId,\\n    uint256 price,\\n    uint256 startTime,\\n    bool isPrimarySale\\n  ) external override nonReentrant {\\n    BuyNowSellingAgreement memory sellingAgreement = s_buyNowSellingAgreements[\\n      nftContractAddress\\n    ][tokenId];\\n    IERC721 nftContract = IERC721(nftContractAddress);\\n\\n    sellingAgreement.mustNotExist();\\n    price.mustBeValidAmount();\\n    nftContract.sellerMustBeOwner(tokenId, msg.sender);\\n    nftContract.marketplaceMustBeApproved(msg.sender);\\n\\n    nftContract.transferFrom(msg.sender, address(this), tokenId);\\n    uint256 newId = getSellingAgreementId();\\n    incrementSellingAgreementId();\\n\\n    s_buyNowSellingAgreements[nftContractAddress][\\n      tokenId\\n    ] = BuyNowSellingAgreement({\\n      seller: payable(msg.sender),\\n      price: price,\\n      startTime: startTime,\\n      isPrimarySale: isPrimarySale,\\n      id: newId\\n    });\\n\\n    emit BuyNowSellingAgreementCreated(\\n      nftContractAddress,\\n      tokenId,\\n      msg.sender,\\n      price,\\n      startTime,\\n      isPrimarySale,\\n      newId\\n    );\\n  }\\n\\n  /// @dev see {IExchangeArtNFTMarketBuyNow-acceptBuyNowSellingAgreement}\\n  function acceptBuyNowSellingAgreement(\\n    address nftContractAddress,\\n    uint256 tokenId\\n  ) external payable override nonReentrant {\\n    BuyNowSellingAgreement memory sellingAgreement = s_buyNowSellingAgreements[\\n      nftContractAddress\\n    ][tokenId];\\n\\n    sellingAgreement.mustExist();\\n    sellingAgreement.mustHaveStarted();\\n    uint256 totalAmountFeesIncluded = sellingAgreement.isPrimarySale\\n      ? sellingAgreement.price +\\n        (sellingAgreement.price * EXCHANGE_ART_PRIMARY_FEE) /\\n        10_000\\n      : sellingAgreement.price +\\n        (sellingAgreement.price * EXCHANGE_ART_SECONDARY_FEE) /\\n        10_000;\\n\\n    IERC721 nftContract = IERC721(nftContractAddress);\\n    msg.value.mustBeEqualTo(totalAmountFeesIncluded);\\n    nftContract.transferFrom(address(this), msg.sender, tokenId);\\n    delete s_buyNowSellingAgreements[nftContractAddress][tokenId];\\n\\n    _handlePayments(\\n      nftContractAddress,\\n      tokenId,\\n      sellingAgreement.price,\\n      sellingAgreement.seller,\\n      sellingAgreement.isPrimarySale\\n    );\\n\\n    emit BuyNowSellingAgreementAccepted(\\n      nftContractAddress,\\n      tokenId,\\n      sellingAgreement.seller,\\n      msg.sender,\\n      sellingAgreement.isPrimarySale,\\n      sellingAgreement.id,\\n      sellingAgreement.price\\n    );\\n  }\\n\\n  /// @dev see {IExchangeArtNFTMarketBuyNow-cancelBuyNowSellingAgreement}\\n  function cancelBuyNowSellingAgreement(\\n    address nftContractAddress,\\n    uint256 tokenId\\n  ) external override nonReentrant {\\n    BuyNowSellingAgreement memory sellingAgreement = s_buyNowSellingAgreements[\\n      nftContractAddress\\n    ][tokenId];\\n\\n    sellingAgreement.mustExist();\\n    sellingAgreement.mustBeOwnedBy(msg.sender);\\n\\n    IERC721 nftContract = IERC721(nftContractAddress);\\n\\n    nftContract.transferFrom(address(this), msg.sender, tokenId);\\n    delete s_buyNowSellingAgreements[nftContractAddress][tokenId];\\n\\n    emit BuyNowSellingAgreementCancelled(\\n      nftContractAddress,\\n      tokenId,\\n      msg.sender,\\n      sellingAgreement.id\\n    );\\n  }\\n\\n  /// @dev see {IExchangeArtNFTMarketBuyNow-editBuyNowSellingAgreement}\\n  function editBuyNowSellingAgreement(\\n    address nftContractAddress,\\n    uint256 tokenId,\\n    uint256 newPrice\\n  ) external override nonReentrant {\\n    BuyNowSellingAgreement memory sellingAgreement = s_buyNowSellingAgreements[\\n      nftContractAddress\\n    ][tokenId];\\n\\n    sellingAgreement.mustExist();\\n    sellingAgreement.mustBeOwnedBy(msg.sender);\\n    newPrice.mustBeValidAmount();\\n\\n    s_buyNowSellingAgreements[nftContractAddress][tokenId].price = newPrice;\\n    emit BuyNowSellingAgreementEdited(\\n      nftContractAddress,\\n      tokenId,\\n      msg.sender,\\n      newPrice,\\n      sellingAgreement.id\\n    );\\n  }\\n\\n  /// @dev see {IExchangeArtNFTMarketBuyNow-getBuyNowSellingAgreementDetails}\\n  function getBuyNowSellingAgreementDetails(\\n    address nftContract,\\n    uint256 tokenId\\n  )\\n    external\\n    view\\n    returns (\\n      uint256 id,\\n      address seller,\\n      uint256 price,\\n      uint256 startTime,\\n      bool isPrimarySale\\n    )\\n  {\\n    BuyNowSellingAgreement storage buyNowDetails = s_buyNowSellingAgreements[\\n      nftContract\\n    ][tokenId];\\n    seller = buyNowDetails.seller;\\n    if (seller == address(0)) {\\n      return (0, seller, 0, 0, false);\\n    }\\n    id = buyNowDetails.id;\\n    price = buyNowDetails.price;\\n    startTime = buyNowDetails.startTime;\\n    isPrimarySale = buyNowDetails.isPrimarySale;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/mixins/IdGenerator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol\\\";\\n\\n/**\\n */\\nabstract contract IdGenerator is Initializable {\\n  using CountersUpgradeable for CountersUpgradeable.Counter;\\n\\n  CountersUpgradeable.Counter private _sellingAgreementId;\\n\\n  function __IdGenerator_init() internal onlyInitializing {\\n    _sellingAgreementId.increment();\\n  }\\n\\n  function getSellingAgreementId() internal view returns (uint256) {\\n    return _sellingAgreementId.current();\\n  }\\n\\n  function incrementSellingAgreementId() internal {\\n    return _sellingAgreementId.increment();\\n  }\\n\\n  /**\\n   * @notice This empty reserved space is put in place to allow future versions to add new\\n   * variables without shifting down storage in the inheritance chain.\\n   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n   */\\n\\n  uint256[1_000] private __gap;\\n}\\n\"\r\n    },\r\n    \"contracts/mixins/OfferSellingAgreementProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\\\";\\nimport \\\"hardhat/console.sol\\\"; // todo delete when deploying to mainnet\\n\\nimport \\\"../libraries/ERC721Checks.sol\\\";\\nimport \\\"../libraries/NumericChecks.sol\\\";\\nimport \\\"../libraries/OfferSellingAgreementChecks.sol\\\";\\n\\nimport \\\"./shared/PaymentsAware.sol\\\";\\n\\nimport \\\"./IdGenerator.sol\\\";\\nimport \\\"../interfaces/IOfferSellingAgreementProvider.sol\\\";\\n\\nabstract contract OfferSellingAgreementProvider is\\n  Initializable,\\n  IdGenerator,\\n  IOfferSellingAgreementProvider,\\n  PaymentsAware,\\n  ReentrancyGuardUpgradeable\\n{\\n  using OfferSellingAgreementChecks for uint256;\\n  using NumericChecks for uint256;\\n  using OfferSellingAgreementChecks for Offer;\\n  using OfferSellingAgreementChecks for address;\\n  using ERC721Checks for IERC721;\\n\\n  /// @notice The auction configuration for a specific auction id.\\n  mapping(address => mapping(uint256 => mapping(address => uint256)))\\n    private nftContractToTokenIdToSellerAddressToOfferId;\\n  /// @notice The auction id for a specific NFT.\\n  mapping(uint256 => Offer) private offerIdToOffer;\\n\\n  function createOfferSellingAgreement(\\n    address nftContract,\\n    uint256 tokenId,\\n    uint256 offerAmount\\n  ) external payable nonReentrant {\\n    uint256 offerId = nftContractToTokenIdToSellerAddressToOfferId[nftContract][\\n      tokenId\\n    ][msg.sender];\\n\\n    offerAmount.mustBeValidAmount();\\n\\n    // Because Exchange.art has a  buyer fee for all sales, the buyer must send additional eth (equivalent to the primary fee).\\n    // If the offer is accepted, in the case of a primary sale, all the additional eth sent will be sent to the treasury,\\n    // In the case of a secondary sale, the difference between the primary fee and secondary fee will be returned to the buyer.\\n    uint256 primaryFeeValue = (msg.value / 105) * 5;\\n    offerAmount.mustBeEqualTo(msg.value - primaryFeeValue);\\n\\n    offerId.mustNotExist();\\n\\n    uint256 newOfferId = getSellingAgreementId();\\n    incrementSellingAgreementId();\\n\\n    nftContractToTokenIdToSellerAddressToOfferId[nftContract][tokenId][\\n      msg.sender\\n    ] = newOfferId;\\n\\n    Offer storage offer = offerIdToOffer[newOfferId];\\n    offer.buyer = msg.sender;\\n    offer.nftContract = nftContract;\\n    offer.tokenId = tokenId;\\n    offer.offerPrice = offerAmount;\\n\\n    emit OfferSellingAgreementCreated(\\n      nftContract,\\n      tokenId,\\n      msg.sender,\\n      offerAmount,\\n      newOfferId\\n    );\\n  }\\n\\n  function cancelOfferSellingAgreement(uint256 offerId) external nonReentrant {\\n    // todo check if there is a difference between\\n    Offer memory offer = offerIdToOffer[offerId];\\n    offer.mustExist();\\n    msg.sender.mustBeInitializerOf(offer);\\n\\n    address payable[] memory buyerAsArray = new address payable[](1);\\n    buyerAsArray[0] = payable(msg.sender);\\n    uint256[] memory offerAsArray = new uint256[](1);\\n    offerAsArray[0] = (offer.offerPrice * 105) / 100;\\n    _pushPayments(buyerAsArray, offerAsArray);\\n\\n    delete offerIdToOffer[offerId];\\n    delete nftContractToTokenIdToSellerAddressToOfferId[offer.nftContract][\\n      offer.tokenId\\n    ][msg.sender];\\n\\n    emit OfferSellingAgreementCancelled(\\n      offer.nftContract,\\n      offer.tokenId,\\n      offer.buyer,\\n      offer.offerPrice,\\n      offerId\\n    );\\n  }\\n\\n  function acceptOfferSellingAgreement(\\n    uint256 offerId,\\n    bool isPrimarySale\\n  ) external nonReentrant {\\n    Offer memory offer = offerIdToOffer[offerId];\\n    IERC721 nftContract = IERC721(offer.nftContract);\\n\\n    offer.mustExist();\\n    nftContract.sellerMustBeOwner(offer.tokenId, msg.sender);\\n    nftContract.marketplaceMustBeApproved(msg.sender);\\n\\n    delete offerIdToOffer[offerId];\\n    delete nftContractToTokenIdToSellerAddressToOfferId[offer.nftContract][\\n      offer.tokenId\\n    ][offer.buyer];\\n    _handlePayments(\\n      offer.nftContract,\\n      offer.tokenId,\\n      offer.offerPrice,\\n      payable(msg.sender),\\n      isPrimarySale\\n    );\\n\\n    // If this was a secodary sale , half the fees have to be returned to the buyer.\\n    if (!isPrimarySale) {\\n      address payable[] memory buyerAsArray = new address payable[](1);\\n      buyerAsArray[0] = payable(msg.sender);\\n      uint256[] memory offerAsArray = new uint256[](1);\\n      offerAsArray[0] = (offer.offerPrice * 5) / 100 / 2;\\n      _pushPayments(buyerAsArray, offerAsArray);\\n    }\\n\\n    nftContract.transferFrom(msg.sender, offer.buyer, offer.tokenId);\\n\\n    emit OfferSellingAgreementAccepted(\\n      offer.nftContract,\\n      offer.tokenId,\\n      msg.sender,\\n      offer.buyer,\\n      offer.offerPrice,\\n      isPrimarySale,\\n      offerId\\n    );\\n  }\\n\\n  /**\\n   * @notice Returns offer details for a given offerId.\\n   * @param offerId The id of the auction to lookup.\\n   */\\n  function getOfferSellingAgreementDetails(\\n    uint256 offerId\\n  )\\n    external\\n    view\\n    returns (\\n      address nftContract,\\n      uint256 tokenId,\\n      address buyer,\\n      uint256 offerAmount\\n    )\\n  {\\n    Offer memory offer = offerIdToOffer[offerId];\\n    nftContract = offer.nftContract;\\n    tokenId = offer.tokenId;\\n    buyer = offer.buyer;\\n    offerAmount = offer.offerPrice;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/mixins/shared/Constants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\npragma solidity ^0.8.8;\\n\\n/**\\n * @dev 100% in basis points.\\n */\\nuint256 constant BASIS_POINTS = 10_000;\\n\\n/**\\n * @dev The gas limit to send ETH to a single recipient, enough for a contract with a simple receiver.\\n */\\nuint256 constant SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT = 20_000;\\n\\n/**\\n * @dev The gas limit used when making external read-only calls.\\n * This helps to ensure that external calls does not prevent the market from executing.\\n */\\nuint256 constant READ_ONLY_GAS_LIMIT = 40_000;\\n\\nuint256 constant EXCHANGE_ART_PRIMARY_FEE = 500;\\n\\nuint256 constant EXCHANGE_ART_SECONDARY_FEE = 250;\\n\"\r\n    },\r\n    \"contracts/mixins/shared/Errors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.8;\\n\\nerror ValueNotMet(uint256 value, uint256 compareTo);\\nerror ValuesNotEqauls(uint256 value, uint256 compareTo);\\nerror ValueMustBeAboveZero(uint256 value);\\nerror ValueMustBeAboveMinimumAmount(uint256 value);\\nerror ValueMustBeMultipleOfMinimumAmount(uint256 value);\\n\\n// Buy now errors\\nerror NFTMarketBuyNow__MarketplaceNotApproved();\\nerror NFTMarketBuyNow__SellingAgreement__AlreadyExists();\\nerror NFTMarketBuyNow__SellingAgreement__NotTokenOwner();\\nerror NFTMarketBuyNow__SellingAgreement__DoesNotExist();\\nerror NFTMarketBuyNow__SellingAgreement__NotStarted();\\n\\nerror NFTMarketBuyNow__SellingAgreement__SellerMismatch();\\n\\n// Auctions Errors\\nerror NFTMarketAuction__AlreadyExists(uint256 auctionId);\\nerror NFTMarketAuction__Inexistent();\\nerror NFTMarketAuction__DoesNotHaveBids();\\nerror NFTMarketAuction__DoesHaveBids();\\nerror NFTMarketAuction__InvalidCaller();\\nerror NFTMarketAuction__PriceNotMet();\\nerror NFTMarketAuction__Ongoing();\\nerror NFTMarketAuction__Ended();\\nerror NFTMarketAuction__callerMustNotBeSeller();\\nerror NFTMarketAuction__callerIsHighestBidder();\\nerror NFTMarketAuction__ValueMustBeAboveZero(uint256 value);\\nerror NFTMarketAuction__IsNotConfigurable();\\n\\nerror NFTMarketOffers__AlreadyExists(uint256 auctionId);\\nerror NFTMarketOffers__DoesNotExist();\\nerror NFTMarketOffers__CallerIsNotInitializer();\\n\\nerror EscrowWithdrawError__NoFundsToWithdraw(address wallet);\\n\"\r\n    },\r\n    \"contracts/mixins/shared/PaymentsAware.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.8;\\n\\nimport \\\"./Constants.sol\\\";\\nimport \\\"./RoyaltiesAware.sol\\\";\\n\\n/**\\n * @dev Contract module which defines what functions a payment aware contract should implement.\\n * @dev Payment awareness implies knowing how to send different addresses funds via _pushPayments\\n * @dev   and also how to retrieve the treasury address of Exchange.ART via _getTreasury.\\n *\\n * @dev Payment awareness depends on royalty awareness as payments are influenced by the royalty percentage.\\n */\\nabstract contract PaymentsAware is RoyaltiesAware {\\n  function _handlePayments(\\n    address nftContractAddress,\\n    uint256 tokenId,\\n    uint256 price,\\n    address payable seller,\\n    bool isPrimarySale\\n  ) internal {\\n    (\\n      address payable[] memory recipients,\\n      uint256[] memory amounts\\n    ) = _getPaymentStructure(\\n        nftContractAddress,\\n        tokenId,\\n        price,\\n        seller,\\n        _getTreasury(),\\n        isPrimarySale\\n      );\\n\\n    _pushPayments(recipients, amounts);\\n  }\\n\\n  function _pushPayments(\\n    address payable[] memory recipients,\\n    uint256[] memory amounts\\n  ) internal virtual;\\n\\n  function _getTreasury() internal view virtual returns (address payable);\\n\\n  function _getPaymentStructure(\\n    address nftContractAddress,\\n    uint256 tokenId,\\n    uint256 price,\\n    address payable seller,\\n    address payable treasury,\\n    bool isPrimarySale\\n  ) private view returns (address payable[] memory, uint256[] memory) {\\n    (\\n      address payable[] memory creators,\\n      uint256[] memory creatorsBps\\n    ) = _getNFTRoyalties(nftContractAddress, tokenId);\\n\\n    address payable[] memory recipients = new address payable[](\\n      creators.length + 2\\n    );\\n    uint256[] memory amounts = new uint256[](creators.length + 2);\\n    uint256 offset = 0;\\n\\n    // start from the whole sum which needs to be paid\\n    // we have buyer fees, so no need to deduct the exchange fees\\n    uint256 amountLeft = price;\\n\\n    // add the treasury amount to the payment structure\\n    // this will depend on weather the sale is primary or secondary\\n    //   and it will be relative to the original price\\n    if (isPrimarySale) {\\n      uint256 treasuryAmount = (amountLeft * EXCHANGE_ART_PRIMARY_FEE) / 10_000;\\n      recipients[offset] = treasury;\\n      amounts[offset] = treasuryAmount;\\n      offset++;\\n    } else {\\n      uint256 treasuryAmount = (amountLeft * EXCHANGE_ART_SECONDARY_FEE) /\\n        10_000;\\n      recipients[offset] = treasury;\\n      amounts[offset] = treasuryAmount;\\n      offset++;\\n    }\\n\\n    // add the creator amounts to the payment structure\\n    // this depdends on the creator bps of each creator (assuming we were able to correctly retrieve them)\\n    // this will be relative to the original price, depending on weather the sale is primary or secondary\\n    uint256 totalBps;\\n    uint256 royaltyAmount;\\n    for (uint256 i = 0; i < creators.length; i++) {\\n      totalBps += creatorsBps[i];\\n    }\\n    if (isPrimarySale && creators.length > 0) {\\n      for (uint256 i = 0; i < creators.length; i++) {\\n        uint256 creatorAmount = (amountLeft * creatorsBps[i]) / totalBps;\\n        recipients[offset] = creators[i];\\n        amounts[offset] = creatorAmount;\\n        offset++;\\n        royaltyAmount += creatorAmount;\\n      }\\n    } else if (!isPrimarySale && creators.length > 0) {\\n      for (uint256 i = 0; i < creators.length; i++) {\\n        uint256 creatorAmount = (amountLeft * creatorsBps[i]) / 10_000;\\n        recipients[offset] = creators[i];\\n        amounts[offset] = creatorAmount;\\n        offset++;\\n        royaltyAmount += creatorAmount;\\n      }\\n    }\\n    amountLeft = amountLeft - royaltyAmount;\\n\\n    // add the seller to the payment structure\\n    // the amount left is the amount that the seller will receive\\n    // this can potentially be 0\\n    recipients[offset] = seller;\\n    amounts[offset] = amountLeft;\\n    offset++;\\n\\n    return (recipients, amounts);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/mixins/shared/RoyaltiesAware.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.8;\\n\\nimport \\\"../../interfaces/royalties/IRoyaltyInfo.sol\\\";\\nimport \\\"../../interfaces/royalties/IGetRoyalties.sol\\\";\\nimport \\\"../../interfaces/royalties/IRoyaltyRegistry.sol\\\";\\nimport \\\"../../interfaces/royalties/IGetFees.sol\\\";\\nimport \\\"../../interfaces/ITokenCreator.sol\\\";\\nimport \\\"../../interfaces/IOwnable.sol\\\";\\nimport \\\"../shared/Constants.sol\\\";\\nimport \\\"../../libraries/ERC165Checks.sol\\\";\\n\\n/**\\n * @dev Contract module which offers robust royalty retrieving capabilities to implementers.\\n * @dev Royalty awareness implies knowing how to retrieve royalties for a given NFT.\\n *\\n * @dev There are multiple methods to retrieve NFT royalties, defined by various marketplaces.\\n */\\nabstract contract RoyaltiesAware {\\n  using ERC165Checks for address;\\n\\n  IRoyaltyRegistry private immutable _royaltyRegistry =\\n    IRoyaltyRegistry(0xaD2184FB5DBcfC05d8f056542fB25b04fa32A95D);\\n\\n  /**\\n   * @dev We try different ways of retrieving royalties, in this order:\\n   * @dev   1. EIP-2981 royalty standard\\n   * @dev   2. Royalties interface for Manifold\\n   * todo: WIP\\n   */\\n  function _getNFTRoyalties(\\n    address nftContractAddress,\\n    uint256 tokenId\\n  )\\n    internal\\n    view\\n    returns (address payable[] memory creators, uint256[] memory creatorsBps)\\n  {\\n    // Priority 1: EIP-2981 royalty standard\\n    if (\\n      nftContractAddress.supportsERC165InterfaceUnchecked(\\n        type(IRoyaltyInfo).interfaceId\\n      )\\n    ) {\\n      // we don't have access to the price here, but we can calculate the desired creator bps by passing the 10_000 constant\\n      try\\n        IRoyaltyInfo(nftContractAddress).royaltyInfo{gas: 40_000}(\\n          tokenId,\\n          10_000\\n        )\\n      returns (address receiver, uint256 royaltyAmount) {\\n        // Ignore this result when royaltyAmount is 0\\n        if (royaltyAmount > 0) {\\n          creators = new address payable[](1);\\n          creators[0] = payable(receiver);\\n          creatorsBps = new uint256[](1);\\n          creatorsBps[0] = royaltyAmount;\\n          return (creators, creatorsBps);\\n        }\\n      } catch // solhint-disable-next-line no-empty-blocks\\n      {\\n        // Fall through\\n      }\\n    }\\n\\n    // Priority 2: Royalties interface for Manifold (also supported by Exchange contracts)\\n    if (\\n      nftContractAddress.supportsERC165InterfaceUnchecked(\\n        type(IGetRoyalties).interfaceId\\n      )\\n    ) {\\n      try\\n        IGetRoyalties(nftContractAddress).getRoyalties{gas: 40_000}(tokenId)\\n      returns (\\n        address payable[] memory _recipients,\\n        uint256[] memory recipientsBasisPoints\\n      ) {\\n        if (\\n          _recipients.length != 0 &&\\n          _recipients.length == recipientsBasisPoints.length\\n        ) {\\n          return (_recipients, recipientsBasisPoints);\\n        }\\n      } catch // solhint-disable-next-line no-empty-blocks\\n      {\\n        // Fall through\\n      }\\n    }\\n\\n    // Next in order of priorities, try to use the Royalty Registry (https://royaltyregistry.xyz/lookup)\\n    try\\n      _royaltyRegistry.getRoyaltyLookupAddress{gas: 40_000}(nftContractAddress)\\n    returns (address overrideContract) {\\n      if (overrideContract != nftContractAddress) {\\n        nftContractAddress = overrideContract;\\n        // Priority 3: EIP-2981 royalty standard via Royalty Registry\\n        if (\\n          nftContractAddress.supportsERC165InterfaceUnchecked(\\n            type(IRoyaltyInfo).interfaceId\\n          )\\n        ) {\\n          // we don't have access to the price here, but we can calculate the desired creator bps by passing the 10_000 constant\\n          try\\n            IRoyaltyInfo(nftContractAddress).royaltyInfo{gas: 40_000}(\\n              tokenId,\\n              10_000\\n            )\\n          returns (address receiver, uint256 royaltyAmount) {\\n            // Ignore this result when royaltyAmount is 0\\n            if (royaltyAmount > 0) {\\n              creators = new address payable[](1);\\n              creators[0] = payable(receiver);\\n              creatorsBps = new uint256[](1);\\n              creatorsBps[0] = royaltyAmount;\\n              return (creators, creatorsBps);\\n            }\\n          } catch // solhint-disable-next-line no-empty-blocks\\n          {\\n            // Fall through\\n          }\\n        }\\n\\n        // Priority 4: Royalties interface for Manifold via Royalty Registry\\n        if (\\n          nftContractAddress.supportsERC165InterfaceUnchecked(\\n            type(IGetRoyalties).interfaceId\\n          )\\n        ) {\\n          try\\n            IGetRoyalties(nftContractAddress).getRoyalties{gas: 40_000}(tokenId)\\n          returns (\\n            address payable[] memory _recipients,\\n            uint256[] memory recipientsBasisPoints\\n          ) {\\n            if (\\n              _recipients.length != 0 &&\\n              _recipients.length == recipientsBasisPoints.length\\n            ) {\\n              return (_recipients, recipientsBasisPoints);\\n            }\\n          } catch // solhint-disable-next-line no-empty-blocks\\n          {\\n            // Fall through\\n          }\\n        }\\n      }\\n    } catch // solhint-disable-next-line no-empty-blocks\\n    {\\n      // Ignore out of gas errors and continue using the nftContract address\\n    }\\n\\n    // Priority 5: getFee* from contract or override\\n    if (\\n      nftContractAddress.supportsERC165InterfaceUnchecked(\\n        type(IGetFees).interfaceId\\n      )\\n    ) {\\n      try\\n        IGetFees(nftContractAddress).getFeeRecipients{gas: 40_000}(tokenId)\\n      returns (address payable[] memory _recipients) {\\n        if (_recipients.length != 0) {\\n          try\\n            IGetFees(nftContractAddress).getFeeBps{gas: 40_000}(tokenId)\\n          returns (uint256[] memory recipientBasisPoints) {\\n            if (_recipients.length == recipientBasisPoints.length) {\\n              return (_recipients, recipientBasisPoints);\\n            }\\n          } catch // solhint-disable-next-line no-empty-blocks\\n          {\\n            // Fall through\\n          }\\n        }\\n      } catch // solhint-disable-next-line no-empty-blocks\\n      {\\n        // Fall through\\n      }\\n    }\\n\\n    // At this point, all efforts failed, so try to get the sole creator of the NFT collection, and pay him a 10% royalty\\n    // Priority 6: tokenCreator w/ or w/o requiring 165 from contract or override\\n    try\\n      ITokenCreator(nftContractAddress).tokenCreator{gas: 40_000}(tokenId)\\n    returns (address payable _creator) {\\n      if (_creator != address(0)) {\\n        // Only pay the tokenCreator if there wasn't another royalty defined\\n        creators = new address payable[](1);\\n        creators[0] = _creator;\\n        creatorsBps = new uint256[](1);\\n        creatorsBps[0] = 1_000;\\n        return (creators, creatorsBps);\\n      }\\n    } catch // solhint-disable-next-line no-empty-blocks\\n    {\\n      // Fall through\\n    }\\n\\n    // Priority 7: contractOwner w/ or w/o requiring 165 from contract or override\\n    try IOwnable(nftContractAddress).owner{gas: 40_000}() returns (\\n      address owner\\n    ) {\\n      if (owner != address(0)) {\\n        // Only pay the owner if there wasn't another royalty defined\\n        creators = new address payable[](1);\\n        creators[0] = payable(owner);\\n        creatorsBps = new uint256[](1);\\n        creatorsBps[0] = 1_000;\\n        return (creators, creatorsBps);\\n      }\\n    } catch // solhint-disable-next-line no-empty-blocks\\n    {\\n      // Fall through\\n    }\\n\\n    // If no valid payment address or creator is found, return 0 recipients\\n  }\\n}\\n\"\r\n    },\r\n    \"hardhat/console.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >= 0.4.22 <0.9.0;\\n\\nlibrary console {\\n\\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\\n\\n\\tfunction _sendLogPayload(bytes memory payload) private view {\\n\\t\\tuint256 payloadLength = payload.length;\\n\\t\\taddress consoleAddress = CONSOLE_ADDRESS;\\n\\t\\tassembly {\\n\\t\\t\\tlet payloadStart := add(payload, 32)\\n\\t\\t\\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\\n\\t\\t}\\n\\t}\\n\\n\\tfunction log() internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log()\\\"));\\n\\t}\\n\\n\\tfunction logInt(int256 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(int256)\\\", p0));\\n\\t}\\n\\n\\tfunction logUint(uint256 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256)\\\", p0));\\n\\t}\\n\\n\\tfunction logString(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction logBool(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction logAddress(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes(bytes memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes1(bytes1 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes1)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes2(bytes2 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes2)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes3(bytes3 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes3)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes4(bytes4 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes4)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes5(bytes5 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes5)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes6(bytes6 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes6)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes7(bytes7 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes7)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes8(bytes8 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes8)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes9(bytes9 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes9)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes10(bytes10 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes10)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes11(bytes11 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes11)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes12(bytes12 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes12)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes13(bytes13 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes13)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes14(bytes14 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes14)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes15(bytes15 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes15)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes16(bytes16 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes16)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes17(bytes17 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes17)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes18(bytes18 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes18)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes19(bytes19 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes19)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes20(bytes20 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes20)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes21(bytes21 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes21)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes22(bytes22 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes22)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes23(bytes23 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes23)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes24(bytes24 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes24)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes25(bytes25 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes25)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes26(bytes26 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes26)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes27(bytes27 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes27)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes28(bytes28 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes28)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes29(bytes29 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes29)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes30(bytes30 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes30)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes31(bytes31 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes31)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes32(bytes32 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes32)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint256 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256)\\\", p0));\\n\\t}\\n\\n\\tfunction log(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction log(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction log(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"EscrowWithdrawError__NoFundsToWithdraw\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"}],\"name\":\"NFTMarketAuction__AlreadyExists\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NFTMarketAuction__DoesHaveBids\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NFTMarketAuction__DoesNotHaveBids\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"endingPhase\",\"type\":\"uint256\"}],\"name\":\"NFTMarketAuction__EndingPhaseGraterThanDuration\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NFTMarketAuction__EndingPhaseProvidedWithNopercentageFlip\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"extensionWindow\",\"type\":\"uint256\"}],\"name\":\"NFTMarketAuction__ExrtensionWindowGraterThanEndingPhase\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NFTMarketAuction__Inexistent\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NFTMarketAuction__InvalidCaller\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NFTMarketAuction__Ongoing\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"percentageFlip\",\"type\":\"uint256\"}],\"name\":\"NFTMarketAuction__PercentageFlipGreaterThan100\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NFTMarketAuction__PriceNotMet\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NFTMarketAuction__StartGreaterThanEnd\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NFTMarketAuction__callerIsHighestBidder\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NFTMarketAuction__callerMustNotBeSeller\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NFTMarketBuyNow__MarketplaceNotApproved\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NFTMarketBuyNow__SellingAgreement__AlreadyExists\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NFTMarketBuyNow__SellingAgreement__DoesNotExist\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NFTMarketBuyNow__SellingAgreement__NotStarted\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NFTMarketBuyNow__SellingAgreement__NotTokenOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NFTMarketBuyNow__SellingAgreement__SellerMismatch\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"}],\"name\":\"NFTMarketOffers__AlreadyExists\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NFTMarketOffers__CallerIsNotInitializer\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NFTMarketOffers__DoesNotExist\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"ValueMustBeAboveMinimumAmount\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"ValueMustBeMultipleOfMinimumAmount\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"compareTo\",\"type\":\"uint256\"}],\"name\":\"ValuesNotEqauls\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"nftContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"bidder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"prevHighestBidder\",\"type\":\"address\"}],\"indexed\":false,\"internalType\":\"struct BidEventArguments\",\"name\":\"bidInfos\",\"type\":\"tuple\"}],\"name\":\"AuctionSellingAgreementBidPlaced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"nftContract\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"}],\"name\":\"AuctionSellingAgreementCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"nftContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minimumIncrement\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endingPhase\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endingPhasePercentageFlip\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"extensionWindow\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reservePrice\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct AuctionCreatedEventArguments\",\"name\":\"auctionConfig\",\"type\":\"tuple\"}],\"name\":\"AuctionSellingAgreementCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"nftContract\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"bidder\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isPrimarySale\",\"type\":\"bool\"}],\"name\":\"AuctionSellingAgreementSettled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"nftContract\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"wasPrimarySale\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"BuyNowSellingAgreementAccepted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"nftContract\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"BuyNowSellingAgreementCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"nftContract\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isPrimarySale\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"BuyNowSellingAgreementCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"nftContract\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"BuyNowSellingAgreementEdited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"nftContract\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isPrimarySale\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"OfferSellingAgreementAccepted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"nftContract\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"OfferSellingAgreementCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"nftContract\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"OfferSellingAgreementCreated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nftContractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"acceptBuyNowSellingAgreement\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"offerId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isPrimarySale\",\"type\":\"bool\"}],\"name\":\"acceptOfferSellingAgreement\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"}],\"name\":\"cancelAuctionSellingAgreement\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nftContractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"cancelBuyNowSellingAgreement\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"offerId\",\"type\":\"uint256\"}],\"name\":\"cancelOfferSellingAgreement\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"nftContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minimumIncrement\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endingPhase\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endingPhasePercentageFlip\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"extensionWindow\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reservePrice\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isReservePriceTriggered\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isPrimarySale\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isStandardAuction\",\"type\":\"bool\"}],\"internalType\":\"struct InitAuctionArguments\",\"name\":\"auctionConfig\",\"type\":\"tuple\"}],\"name\":\"createAuctionSellingAgreement\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nftContractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isPrimarySale\",\"type\":\"bool\"}],\"name\":\"createBuyNowSellingAgreement\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nftContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"offerAmount\",\"type\":\"uint256\"}],\"name\":\"createOfferSellingAgreement\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nftContractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newPrice\",\"type\":\"uint256\"}],\"name\":\"editBuyNowSellingAgreement\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"}],\"name\":\"getAuctionSellingAgreementDetails\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"nftContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"seller\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minimumIncrement\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endingPhase\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endingPhasePercentageFlip\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"extensionWindow\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"highestBidder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"reservePriceOrHighestBid\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isPrimarySale\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isReservePriceTriggered\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isStandardAuction\",\"type\":\"bool\"}],\"internalType\":\"struct AuctionState\",\"name\":\"auction\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nftContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getAuctionSellingAgreementIdFor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"}],\"name\":\"getAuctionSellingAgreementMinBidAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"minimum\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nftContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getBuyNowSellingAgreementDetails\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isPrimarySale\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"offerId\",\"type\":\"uint256\"}],\"name\":\"getOfferSellingAgreementDetails\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"nftContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"offerAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"}],\"name\":\"placeBidOnAuctionSellingAgreement\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"}],\"name\":\"settleAuctionSellingAgreement\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"walletAddress\",\"type\":\"address\"}],\"name\":\"withdrawEscrowedAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "ExchangeArtNFTMarketLogic", "CompilerVersion": "v0.8.8+commit.dddeac2f", "OptimizationUsed": "1", "Runs": "1000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}