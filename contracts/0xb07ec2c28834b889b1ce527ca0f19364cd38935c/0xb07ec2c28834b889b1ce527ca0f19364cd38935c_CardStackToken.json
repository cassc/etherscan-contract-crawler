{"SourceCode": "pragma solidity ^0.4.13;\r\n\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\ninterface ITokenLedger {\r\n  function totalTokens() external view returns (uint256);\r\n  function totalInCirculation() external view returns (uint256);\r\n  function balanceOf(address account) external view returns (uint256);\r\n  function mintTokens(uint256 amount) external;\r\n  function transfer(address sender, address reciever, uint256 amount) external;\r\n  function creditAccount(address account, uint256 amount) external;\r\n  function debitAccount(address account, uint256 amount) external;\r\n  function addAdmin(address admin) external;\r\n  function removeAdmin(address admin) external;\r\n}\r\n\r\nlibrary CstLibrary {\r\n  using SafeMath for uint256;\r\n\r\n  function getTokenName(address _storage) public view returns(bytes32) {\r\n    return ExternalStorage(_storage).getBytes32Value(\"cstTokenName\");\r\n  }\r\n\r\n  function setTokenName(address _storage, bytes32 tokenName) public {\r\n    ExternalStorage(_storage).setBytes32Value(\"cstTokenName\", tokenName);\r\n  }\r\n\r\n  function getTokenSymbol(address _storage) public view returns(bytes32) {\r\n    return ExternalStorage(_storage).getBytes32Value(\"cstTokenSymbol\");\r\n  }\r\n\r\n  function setTokenSymbol(address _storage, bytes32 tokenName) public {\r\n    ExternalStorage(_storage).setBytes32Value(\"cstTokenSymbol\", tokenName);\r\n  }\r\n\r\n  function getBuyPrice(address _storage) public view returns(uint256) {\r\n    return ExternalStorage(_storage).getUIntValue(\"cstBuyPrice\");\r\n  }\r\n\r\n  function setBuyPrice(address _storage, uint256 value) public {\r\n    ExternalStorage(_storage).setUIntValue(\"cstBuyPrice\", value);\r\n  }\r\n\r\n  function getCirculationCap(address _storage) public view returns(uint256) {\r\n    return ExternalStorage(_storage).getUIntValue(\"cstCirculationCap\");\r\n  }\r\n\r\n  function setCirculationCap(address _storage, uint256 value) public {\r\n    ExternalStorage(_storage).setUIntValue(\"cstCirculationCap\", value);\r\n  }\r\n\r\n  function getBalanceLimit(address _storage) public view returns(uint256) {\r\n    return ExternalStorage(_storage).getUIntValue(\"cstBalanceLimit\");\r\n  }\r\n\r\n  function setBalanceLimit(address _storage, uint256 value) public {\r\n    ExternalStorage(_storage).setUIntValue(\"cstBalanceLimit\", value);\r\n  }\r\n\r\n  function getFoundation(address _storage) public view returns(address) {\r\n    return ExternalStorage(_storage).getAddressValue(\"cstFoundation\");\r\n  }\r\n\r\n  function setFoundation(address _storage, address value) public {\r\n    ExternalStorage(_storage).setAddressValue(\"cstFoundation\", value);\r\n  }\r\n\r\n  function getAllowance(address _storage, address account, address spender) public view returns (uint256) {\r\n    return ExternalStorage(_storage).getMultiLedgerValue(\"cstAllowance\", account, spender);\r\n  }\r\n\r\n  function setAllowance(address _storage, address account, address spender, uint256 allowance) public {\r\n    ExternalStorage(_storage).setMultiLedgerValue(\"cstAllowance\", account, spender, allowance);\r\n  }\r\n\r\n  function getCustomBuyerLimit(address _storage, address buyer) public view returns (uint256) {\r\n    return ExternalStorage(_storage).getLedgerValue(\"cstCustomBuyerLimit\", buyer);\r\n  }\r\n\r\n  function setCustomBuyerLimit(address _storage, address buyer, uint256 value) public {\r\n    ExternalStorage(_storage).setLedgerValue(\"cstCustomBuyerLimit\", buyer, value);\r\n  }\r\n\r\n  function getCustomBuyerForIndex(address _storage, uint256 index) public view returns (address) {\r\n    return ExternalStorage(_storage).ledgerEntryForIndex(keccak256(\"cstCustomBuyerLimit\"), index);\r\n  }\r\n\r\n  function getCustomBuyerMappingCount(address _storage) public view returns(uint256) {\r\n    return ExternalStorage(_storage).getLedgerCount(\"cstCustomBuyerLimit\");\r\n  }\r\n\r\n  function getApprovedBuyer(address _storage, address buyer) public view returns (bool) {\r\n    return ExternalStorage(_storage).getBooleanMapValue(\"cstApprovedBuyer\", buyer);\r\n  }\r\n\r\n  function setApprovedBuyer(address _storage, address buyer, bool value) public {\r\n    ExternalStorage(_storage).setBooleanMapValue(\"cstApprovedBuyer\", buyer, value);\r\n  }\r\n\r\n  function getApprovedBuyerForIndex(address _storage, uint256 index) public view returns (address) {\r\n    return ExternalStorage(_storage).booleanMapEntryForIndex(keccak256(\"cstApprovedBuyer\"), index);\r\n  }\r\n\r\n  function getApprovedBuyerMappingCount(address _storage) public view returns(uint256) {\r\n    return ExternalStorage(_storage).getBooleanMapCount(\"cstApprovedBuyer\");\r\n  }\r\n\r\n  function getTotalUnvestedAndUnreleasedTokens(address _storage) public view returns(uint256) {\r\n    return ExternalStorage(_storage).getUIntValue(\"cstUnvestedAndUnreleasedTokens\");\r\n  }\r\n\r\n  function setTotalUnvestedAndUnreleasedTokens(address _storage, uint256 value) public {\r\n    ExternalStorage(_storage).setUIntValue(\"cstUnvestedAndUnreleasedTokens\", value);\r\n  }\r\n\r\n  function vestingMappingSize(address _storage) public view returns(uint256) {\r\n    return ExternalStorage(_storage).getLedgerCount(\"cstFullyVestedAmount\");\r\n  }\r\n\r\n  function vestingBeneficiaryForIndex(address _storage, uint256 index) public view returns(address) {\r\n    return ExternalStorage(_storage).ledgerEntryForIndex(keccak256(\"cstFullyVestedAmount\"), index);\r\n  }\r\n\r\n  function releasableAmount(address _storage, address beneficiary) public view returns (uint256) {\r\n    uint256 releasedAmount = getVestingReleasedAmount(_storage, beneficiary);\r\n    return vestedAvailableAmount(_storage, beneficiary).sub(releasedAmount);\r\n  }\r\n\r\n  function vestedAvailableAmount(address _storage, address beneficiary) public view returns (uint256) {\r\n    uint256 start = getVestingStart(_storage, beneficiary);\r\n    uint256 fullyVestedAmount = getFullyVestedAmount(_storage, beneficiary);\r\n\r\n    if (start == 0 || fullyVestedAmount == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 duration = getVestingDuration(_storage, beneficiary);\r\n    if (duration == 0) {\r\n      return 0;\r\n    }\r\n    uint256 cliff = getVestingCliff(_storage, beneficiary);\r\n    uint256 revokeDate = getVestingRevokeDate(_storage, beneficiary);\r\n\r\n    if (now < cliff || (revokeDate > 0 && revokeDate < cliff)) {\r\n      return 0;\r\n    } else if (revokeDate > 0 && revokeDate > cliff) {\r\n      return fullyVestedAmount.mul(revokeDate.sub(start)).div(duration);\r\n    } else if (now >= start.add(duration)) {\r\n      return fullyVestedAmount;\r\n    } else {\r\n      return fullyVestedAmount.mul(now.sub(start)).div(duration);\r\n    }\r\n  }\r\n\r\n  function vestedAmount(address _storage, address beneficiary) public view returns (uint256) {\r\n    uint256 start = getVestingStart(_storage, beneficiary);\r\n    uint256 fullyVestedAmount = getFullyVestedAmount(_storage, beneficiary);\r\n\r\n    if (start == 0 || fullyVestedAmount == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 duration = getVestingDuration(_storage, beneficiary);\r\n    if (duration == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 revokeDate = getVestingRevokeDate(_storage, beneficiary);\r\n\r\n    if (now <= start) {\r\n      return 0;\r\n    } else if (revokeDate > 0) {\r\n      return fullyVestedAmount.mul(revokeDate.sub(start)).div(duration);\r\n    } else if (now >= start.add(duration)) {\r\n      return fullyVestedAmount;\r\n    } else {\r\n      return fullyVestedAmount.mul(now.sub(start)).div(duration);\r\n    }\r\n  }\r\n\r\n  function canGrantVestedTokens(address _storage, address beneficiary) public view returns (bool) {\r\n    uint256 existingFullyVestedAmount = getFullyVestedAmount(_storage, beneficiary);\r\n    if (existingFullyVestedAmount == 0) {\r\n      return true;\r\n    }\r\n\r\n    uint256 existingVestedAmount = vestedAvailableAmount(_storage, beneficiary);\r\n    uint256 existingReleasedAmount = getVestingReleasedAmount(_storage, beneficiary);\r\n    uint256 revokeDate = getVestingRevokeDate(_storage, beneficiary);\r\n\r\n    if (revokeDate > 0 ||\r\n        (existingVestedAmount == existingFullyVestedAmount &&\r\n        existingReleasedAmount == existingFullyVestedAmount)) {\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  function canRevokeVesting(address _storage, address beneficiary) public view returns (bool) {\r\n    bool isRevocable = getVestingRevocable(_storage, beneficiary);\r\n    uint256 revokeDate = getVestingRevokeDate(_storage, beneficiary);\r\n    uint256 start = getVestingStart(_storage, beneficiary);\r\n    uint256 duration = getVestingDuration(_storage, beneficiary);\r\n\r\n    return start > 0 &&\r\n           isRevocable &&\r\n           revokeDate == 0 &&\r\n           now < start.add(duration);\r\n  }\r\n\r\n  function revokeVesting(address _storage, address beneficiary) public {\r\n    require(canRevokeVesting(_storage, beneficiary));\r\n\r\n    uint256 totalUnvestedAndUnreleasedAmount = getTotalUnvestedAndUnreleasedTokens(_storage);\r\n    uint256 unvestedAmount = getFullyVestedAmount(_storage, beneficiary).sub(vestedAvailableAmount(_storage, beneficiary));\r\n\r\n    setVestingRevokeDate(_storage, beneficiary, now);\r\n    setTotalUnvestedAndUnreleasedTokens(_storage, totalUnvestedAndUnreleasedAmount.sub(unvestedAmount));\r\n  }\r\n\r\n  function getVestingSchedule(address _storage, address _beneficiary) public\r\n                                                                      view returns (uint256 startDate,\r\n                                                                                        uint256 cliffDate,\r\n                                                                                        uint256 durationSec,\r\n                                                                                        uint256 fullyVestedAmount,\r\n                                                                                        uint256 releasedAmount,\r\n                                                                                        uint256 revokeDate,\r\n                                                                                        bool isRevocable) {\r\n    startDate         = getVestingStart(_storage, _beneficiary);\r\n    cliffDate         = getVestingCliff(_storage, _beneficiary);\r\n    durationSec       = getVestingDuration(_storage, _beneficiary);\r\n    fullyVestedAmount = getFullyVestedAmount(_storage, _beneficiary);\r\n    releasedAmount    = getVestingReleasedAmount(_storage, _beneficiary);\r\n    revokeDate        = getVestingRevokeDate(_storage, _beneficiary);\r\n    isRevocable       = getVestingRevocable(_storage, _beneficiary);\r\n  }\r\n\r\n  function setVestingSchedule(address _storage,\r\n                              address beneficiary,\r\n                              uint256 fullyVestedAmount,\r\n                              uint256 startDate,\r\n                              uint256 cliffDate,\r\n                              uint256 duration,\r\n                              bool isRevocable) public {\r\n    require(canGrantVestedTokens(_storage, beneficiary));\r\n\r\n    uint256 totalUnvestedAndUnreleasedAmount = getTotalUnvestedAndUnreleasedTokens(_storage);\r\n    setTotalUnvestedAndUnreleasedTokens(_storage, totalUnvestedAndUnreleasedAmount.add(fullyVestedAmount));\r\n\r\n    ExternalStorage(_storage).setLedgerValue(\"cstVestingStart\", beneficiary, startDate);\r\n    ExternalStorage(_storage).setLedgerValue(\"cstVestingCliff\", beneficiary, cliffDate);\r\n    ExternalStorage(_storage).setLedgerValue(\"cstVestingDuration\", beneficiary, duration);\r\n    ExternalStorage(_storage).setLedgerValue(\"cstFullyVestedAmount\", beneficiary, fullyVestedAmount);\r\n    ExternalStorage(_storage).setBooleanMapValue(\"cstVestingRevocable\", beneficiary, isRevocable);\r\n\r\n    setVestingRevokeDate(_storage, beneficiary, 0);\r\n    setVestingReleasedAmount(_storage, beneficiary, 0);\r\n  }\r\n\r\n  function releaseVestedTokens(address _storage, address beneficiary) public {\r\n    uint256 unreleased = releasableAmount(_storage, beneficiary);\r\n    uint256 releasedAmount = getVestingReleasedAmount(_storage, beneficiary);\r\n    uint256 totalUnvestedAndUnreleasedAmount = getTotalUnvestedAndUnreleasedTokens(_storage);\r\n\r\n    releasedAmount = releasedAmount.add(unreleased);\r\n    setVestingReleasedAmount(_storage, beneficiary, releasedAmount);\r\n    setTotalUnvestedAndUnreleasedTokens(_storage, totalUnvestedAndUnreleasedAmount.sub(unreleased));\r\n  }\r\n\r\n  function getVestingStart(address _storage, address beneficiary) public view returns(uint256) {\r\n    return ExternalStorage(_storage).getLedgerValue(\"cstVestingStart\", beneficiary);\r\n  }\r\n\r\n  function getVestingCliff(address _storage, address beneficiary) public view returns(uint256) {\r\n    return ExternalStorage(_storage).getLedgerValue(\"cstVestingCliff\", beneficiary);\r\n  }\r\n\r\n  function getVestingDuration(address _storage, address beneficiary) public view returns(uint256) {\r\n    return ExternalStorage(_storage).getLedgerValue(\"cstVestingDuration\", beneficiary);\r\n  }\r\n\r\n  function getFullyVestedAmount(address _storage, address beneficiary) public view returns(uint256) {\r\n    return ExternalStorage(_storage).getLedgerValue(\"cstFullyVestedAmount\", beneficiary);\r\n  }\r\n\r\n  function getVestingRevocable(address _storage, address beneficiary) public view returns(bool) {\r\n    return ExternalStorage(_storage).getBooleanMapValue(\"cstVestingRevocable\", beneficiary);\r\n  }\r\n\r\n  function setVestingReleasedAmount(address _storage, address beneficiary, uint256 value) public {\r\n    ExternalStorage(_storage).setLedgerValue(\"cstVestingReleasedAmount\", beneficiary, value);\r\n  }\r\n\r\n  function getVestingReleasedAmount(address _storage, address beneficiary) public view returns(uint256) {\r\n    return ExternalStorage(_storage).getLedgerValue(\"cstVestingReleasedAmount\", beneficiary);\r\n  }\r\n\r\n  function setVestingRevokeDate(address _storage, address beneficiary, uint256 value) public {\r\n    ExternalStorage(_storage).setLedgerValue(\"cstVestingRevokeDate\", beneficiary, value);\r\n  }\r\n\r\n  function getVestingRevokeDate(address _storage, address beneficiary) public view returns(uint256) {\r\n    return ExternalStorage(_storage).getLedgerValue(\"cstVestingRevokeDate\", beneficiary);\r\n  }\r\n\r\n  function getRewardsContractHash(address _storage) public view returns (bytes32) {\r\n    return ExternalStorage(_storage).getBytes32Value(\"cstRewardsContractHash\");\r\n  }\r\n\r\n  function setRewardsContractHash(address _storage, bytes32 rewardsContractHash) public {\r\n    ExternalStorage(_storage).setBytes32Value(\"cstRewardsContractHash\", rewardsContractHash);\r\n  }\r\n\r\n}\r\n\r\ncontract ERC20 {\r\n  function allowance(address owner, address spender) public view returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address account) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\ncontract administratable is Ownable {\r\n  using SafeMath for uint256;\r\n\r\n  address[] public adminsForIndex;\r\n  address[] public superAdminsForIndex;\r\n  mapping (address => bool) public admins;\r\n  mapping (address => bool) public superAdmins;\r\n  mapping (address => bool) private processedAdmin;\r\n  mapping (address => bool) private processedSuperAdmin;\r\n\r\n  event AddAdmin(address indexed admin);\r\n  event RemoveAdmin(address indexed admin);\r\n  event AddSuperAdmin(address indexed admin);\r\n  event RemoveSuperAdmin(address indexed admin);\r\n\r\n  modifier onlyAdmins {\r\n    if (msg.sender != owner && !superAdmins[msg.sender] && !admins[msg.sender]) revert();\r\n    _;\r\n  }\r\n\r\n  modifier onlySuperAdmins {\r\n    if (msg.sender != owner && !superAdmins[msg.sender]) revert();\r\n    _;\r\n  }\r\n\r\n  function totalSuperAdminsMapping() public view returns (uint256) {\r\n    return superAdminsForIndex.length;\r\n  }\r\n\r\n  function addSuperAdmin(address admin) public onlySuperAdmins {\r\n    require(admin != address(0));\r\n    superAdmins[admin] = true;\r\n    if (!processedSuperAdmin[admin]) {\r\n      superAdminsForIndex.push(admin);\r\n      processedSuperAdmin[admin] = true;\r\n    }\r\n\r\n    emit AddSuperAdmin(admin);\r\n  }\r\n\r\n  function removeSuperAdmin(address admin) public onlySuperAdmins {\r\n    require(admin != address(0));\r\n    superAdmins[admin] = false;\r\n\r\n    emit RemoveSuperAdmin(admin);\r\n  }\r\n\r\n  function totalAdminsMapping() public view returns (uint256) {\r\n    return adminsForIndex.length;\r\n  }\r\n\r\n  function addAdmin(address admin) public onlySuperAdmins {\r\n    require(admin != address(0));\r\n    admins[admin] = true;\r\n    if (!processedAdmin[admin]) {\r\n      adminsForIndex.push(admin);\r\n      processedAdmin[admin] = true;\r\n    }\r\n\r\n    emit AddAdmin(admin);\r\n  }\r\n\r\n  function removeAdmin(address admin) public onlySuperAdmins {\r\n    require(admin != address(0));\r\n    admins[admin] = false;\r\n\r\n    emit RemoveAdmin(admin);\r\n  }\r\n}\r\n\r\ncontract CstLedger is ITokenLedger, administratable {\r\n\r\n  using SafeMath for uint256;\r\n\r\n  uint256 private _totalInCirculation; // warning this does not take into account unvested nor vested-unreleased tokens into consideration\r\n  uint256 private _totalTokens;\r\n  mapping (address => uint256) private _balanceOf;\r\n  mapping (address => bool) private accounts;\r\n  address[] public accountForIndex;\r\n\r\n  function totalTokens() external view returns (uint256) {\r\n    return _totalTokens;\r\n  }\r\n\r\n  function totalInCirculation() external view returns (uint256) {\r\n    return _totalInCirculation;\r\n  }\r\n\r\n  function balanceOf(address account) external view returns (uint256) {\r\n    return _balanceOf[account];\r\n  }\r\n\r\n  function mintTokens(uint256 amount) external onlyAdmins {\r\n    _totalTokens = _totalTokens.add(amount);\r\n  }\r\n\r\n  function ledgerCount() external view returns (uint256) {\r\n    return accountForIndex.length;\r\n  }\r\n\r\n  function makeAccountIterable(address account) internal {\r\n    if (!accounts[account]) {\r\n      accountForIndex.push(account);\r\n      accounts[account] = true;\r\n    }\r\n  }\r\n\r\n  function transfer(address sender, address recipient, uint256 amount) external onlyAdmins {\r\n    require(sender != address(0));\r\n    require(recipient != address(0));\r\n    require(_balanceOf[sender] >= amount);\r\n\r\n    _balanceOf[sender] = _balanceOf[sender].sub(amount);\r\n    _balanceOf[recipient] = _balanceOf[recipient].add(amount);\r\n    makeAccountIterable(recipient);\r\n  }\r\n\r\n  function creditAccount(address account, uint256 amount) external onlyAdmins { // remove tokens\r\n    require(account != address(0));\r\n    require(_balanceOf[account] >= amount);\r\n\r\n    _totalInCirculation = _totalInCirculation.sub(amount);\r\n    _balanceOf[account] = _balanceOf[account].sub(amount);\r\n  }\r\n\r\n  function debitAccount(address account, uint256 amount) external onlyAdmins { // add tokens\r\n    require(account != address(0));\r\n    _totalInCirculation = _totalInCirculation.add(amount);\r\n    _balanceOf[account] = _balanceOf[account].add(amount);\r\n    makeAccountIterable(account);\r\n  }\r\n}\r\n\r\ncontract ExternalStorage is administratable {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(bytes32 => address[]) public primaryLedgerEntryForIndex;\r\n  mapping(bytes32 => mapping(address => address[])) public secondaryLedgerEntryForIndex;\r\n  mapping(bytes32 => mapping(address => mapping(address => uint256))) private MultiLedgerStorage;\r\n  mapping(bytes32 => mapping(address => bool)) private ledgerPrimaryEntries;\r\n  mapping(bytes32 => mapping(address => mapping(address => bool))) private ledgerSecondaryEntries;\r\n\r\n  function getMultiLedgerValue(string record, address primaryAddress, address secondaryAddress) external view returns (uint256) {\r\n    return MultiLedgerStorage[keccak256(abi.encodePacked(record))][primaryAddress][secondaryAddress];\r\n  }\r\n\r\n  function primaryLedgerCount(string record) external view returns (uint256) {\r\n    return primaryLedgerEntryForIndex[keccak256(abi.encodePacked(record))].length;\r\n  }\r\n\r\n  function secondaryLedgerCount(string record, address primaryAddress) external view returns (uint256) {\r\n    return secondaryLedgerEntryForIndex[keccak256(abi.encodePacked(record))][primaryAddress].length;\r\n  }\r\n\r\n  function setMultiLedgerValue(string record, address primaryAddress, address secondaryAddress, uint256 value) external onlyAdmins {\r\n    bytes32 hash = keccak256(abi.encodePacked(record));\r\n    if (!ledgerSecondaryEntries[hash][primaryAddress][secondaryAddress]) {\r\n      secondaryLedgerEntryForIndex[hash][primaryAddress].push(secondaryAddress);\r\n      ledgerSecondaryEntries[hash][primaryAddress][secondaryAddress] = true;\r\n\r\n      if (!ledgerPrimaryEntries[hash][primaryAddress]) {\r\n        primaryLedgerEntryForIndex[hash].push(primaryAddress);\r\n        ledgerPrimaryEntries[hash][primaryAddress] = true;\r\n      }\r\n    }\r\n\r\n    MultiLedgerStorage[hash][primaryAddress][secondaryAddress] = value;\r\n  }\r\n\r\n  mapping(bytes32 => address[]) public ledgerEntryForIndex;\r\n  mapping(bytes32 => mapping(address => uint256)) private LedgerStorage;\r\n  mapping(bytes32 => mapping(address => bool)) private ledgerAccounts;\r\n\r\n  function getLedgerValue(string record, address _address) external view returns (uint256) {\r\n    return LedgerStorage[keccak256(abi.encodePacked(record))][_address];\r\n  }\r\n\r\n  function getLedgerCount(string record) external view returns (uint256) {\r\n    return ledgerEntryForIndex[keccak256(abi.encodePacked(record))].length;\r\n  }\r\n\r\n  function setLedgerValue(string record, address _address, uint256 value) external onlyAdmins {\r\n    bytes32 hash = keccak256(abi.encodePacked(record));\r\n    if (!ledgerAccounts[hash][_address]) {\r\n      ledgerEntryForIndex[hash].push(_address);\r\n      ledgerAccounts[hash][_address] = true;\r\n    }\r\n\r\n    LedgerStorage[hash][_address] = value;\r\n  }\r\n\r\n  mapping(bytes32 => address[]) public booleanMapEntryForIndex;\r\n  mapping(bytes32 => mapping(address => bool)) private BooleanMapStorage;\r\n  mapping(bytes32 => mapping(address => bool)) private booleanMapAccounts;\r\n\r\n  function getBooleanMapValue(string record, address _address) external view returns (bool) {\r\n    return BooleanMapStorage[keccak256(abi.encodePacked(record))][_address];\r\n  }\r\n\r\n  function getBooleanMapCount(string record) external view returns (uint256) {\r\n    return booleanMapEntryForIndex[keccak256(abi.encodePacked(record))].length;\r\n  }\r\n\r\n  function setBooleanMapValue(string record, address _address, bool value) external onlyAdmins {\r\n    bytes32 hash = keccak256(abi.encodePacked(record));\r\n    if (!booleanMapAccounts[hash][_address]) {\r\n      booleanMapEntryForIndex[hash].push(_address);\r\n      booleanMapAccounts[hash][_address] = true;\r\n    }\r\n\r\n    BooleanMapStorage[hash][_address] = value;\r\n  }\r\n\r\n  mapping(bytes32 => uint256) private UIntStorage;\r\n\r\n  function getUIntValue(string record) external view returns (uint256) {\r\n    return UIntStorage[keccak256(abi.encodePacked(record))];\r\n  }\r\n\r\n  function setUIntValue(string record, uint256 value) external onlyAdmins {\r\n    UIntStorage[keccak256(abi.encodePacked(record))] = value;\r\n  }\r\n\r\n  mapping(bytes32 => bytes32) private Bytes32Storage;\r\n\r\n  function getBytes32Value(string record) external view returns (bytes32) {\r\n    return Bytes32Storage[keccak256(abi.encodePacked(record))];\r\n  }\r\n\r\n  function setBytes32Value(string record, bytes32 value) external onlyAdmins {\r\n    Bytes32Storage[keccak256(abi.encodePacked(record))] = value;\r\n  }\r\n\r\n  mapping(bytes32 => address) private AddressStorage;\r\n\r\n  function getAddressValue(string record) external view returns (address) {\r\n    return AddressStorage[keccak256(abi.encodePacked(record))];\r\n  }\r\n\r\n  function setAddressValue(string record, address value) external onlyAdmins {\r\n    AddressStorage[keccak256(abi.encodePacked(record))] = value;\r\n  }\r\n\r\n  mapping(bytes32 => bytes) private BytesStorage;\r\n\r\n  function getBytesValue(string record) external view returns (bytes) {\r\n    return BytesStorage[keccak256(abi.encodePacked(record))];\r\n  }\r\n\r\n  function setBytesValue(string record, bytes value) external onlyAdmins {\r\n    BytesStorage[keccak256(abi.encodePacked(record))] = value;\r\n  }\r\n\r\n  mapping(bytes32 => bool) private BooleanStorage;\r\n\r\n  function getBooleanValue(string record) external view returns (bool) {\r\n    return BooleanStorage[keccak256(abi.encodePacked(record))];\r\n  }\r\n\r\n  function setBooleanValue(string record, bool value) external onlyAdmins {\r\n    BooleanStorage[keccak256(abi.encodePacked(record))] = value;\r\n  }\r\n\r\n  mapping(bytes32 => int256) private IntStorage;\r\n\r\n  function getIntValue(string record) external view returns (int256) {\r\n    return IntStorage[keccak256(abi.encodePacked(record))];\r\n  }\r\n\r\n  function setIntValue(string record, int256 value) external onlyAdmins {\r\n    IntStorage[keccak256(abi.encodePacked(record))] = value;\r\n  }\r\n}\r\n\r\ncontract configurable {\r\n  function configureFromStorage() public returns (bool);\r\n}\r\n\r\ncontract displayable {\r\n  function bytes32ToString(bytes32 x) public pure returns (string) {\r\n    bytes memory bytesString = new bytes(32);\r\n    uint256 charCount = 0;\r\n    for (uint256 j = 0; j < 32; j++) {\r\n      if (x[j] != 0) {\r\n        bytesString[charCount] = x[j];\r\n        charCount++;\r\n      }\r\n    }\r\n    bytes memory bytesStringTrimmed = new bytes(charCount);\r\n    for (j = 0; j < charCount; j++) {\r\n      bytesStringTrimmed[j] = bytesString[j];\r\n    }\r\n    return string(bytesStringTrimmed);\r\n  }\r\n}\r\n\r\ncontract freezable is administratable {\r\n  using SafeMath for uint256;\r\n\r\n  bool public frozenToken;\r\n  // TODO move this into external storage\r\n  address[] public frozenAccountForIndex;\r\n  mapping (address => bool) public frozenAccount;\r\n  mapping (address => bool) private processedAccount;\r\n\r\n  event FrozenFunds(address indexed target, bool frozen);\r\n  event FrozenToken(bool frozen);\r\n\r\n  modifier unlessFrozen {\r\n    require(!frozenToken);\r\n    require(!frozenAccount[msg.sender]);\r\n    _;\r\n  }\r\n\r\n  function totalFrozenAccountsMapping() public view returns(uint256) {\r\n    return frozenAccountForIndex.length;\r\n  }\r\n\r\n  function freezeAccount(address target, bool freeze) public onlySuperAdmins {\r\n    frozenAccount[target] = freeze;\r\n    if (!processedAccount[target]) {\r\n      frozenAccountForIndex.push(target);\r\n      processedAccount[target] = true;\r\n    }\r\n    emit FrozenFunds(target, freeze);\r\n  }\r\n\r\n  function freezeToken(bool freeze) public onlySuperAdmins {\r\n    frozenToken = freeze;\r\n    emit FrozenToken(frozenToken);\r\n  }\r\n\r\n}\r\n\r\ncontract IStorable {\r\n  function getLedgerNameHash() external view returns (bytes32);\r\n  function getStorageNameHash() external view returns (bytes32);\r\n}\r\n\r\ncontract upgradeable is administratable {\r\n  address public predecessor;\r\n  address public successor;\r\n  bool public isTokenContract;\r\n  string public version;\r\n\r\n  event Upgraded(address indexed successor);\r\n  event UpgradedFrom(address indexed predecessor);\r\n  event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n\r\n  modifier unlessUpgraded() {\r\n    if (msg.sender != successor && successor != address(0)) revert();\r\n    _;\r\n  }\r\n\r\n  modifier isUpgraded() {\r\n    if (successor == address(0)) revert();\r\n    _;\r\n  }\r\n\r\n  modifier hasPredecessor() {\r\n    if (predecessor == address(0)) revert();\r\n    _;\r\n  }\r\n\r\n  function isDeprecated() public view returns (bool) {\r\n    return successor != address(0);\r\n  }\r\n\r\n  function upgradeTo(address _successor, uint256 remainingContractBalance) public onlySuperAdmins unlessUpgraded returns (bool){\r\n    require(_successor != address(0));\r\n    successor = _successor;\r\n    if (remainingContractBalance > 0) {\r\n      emit Transfer(this, _successor, remainingContractBalance);\r\n    }\r\n\r\n    emit Upgraded(_successor);\r\n    return true;\r\n  }\r\n\r\n  function upgradedFrom(address _predecessor) public onlySuperAdmins returns (bool) {\r\n    require(_predecessor != address(0));\r\n\r\n    predecessor = _predecessor;\r\n\r\n    emit UpgradedFrom(_predecessor);\r\n\r\n    // TODO refactor this into registry contract when ready for registry upgrade\r\n    if (upgradeable(_predecessor).predecessor() != address(0)) {\r\n      if (upgradeable(_predecessor).isTokenContract()) {\r\n        emit Transfer(_predecessor, this, ERC20(_predecessor).balanceOf(_predecessor));\r\n      }\r\n    } else {\r\n      emit Transfer(this, this, 0); // make etherscan see this as an ERC-20. lets remove in v3\r\n    }\r\n\r\n    return true;\r\n  }\r\n}\r\n\r\ncontract CardStackToken is ERC20,\r\n                           freezable,\r\n                           displayable,\r\n                           upgradeable,\r\n                           configurable,\r\n                           IStorable {\r\n\r\n  using SafeMath for uint256;\r\n  using CstLibrary for address;\r\n\r\n  ITokenLedger public tokenLedger;\r\n  string public storageName;\r\n  string public ledgerName;\r\n  address public externalStorage;\r\n  address public registry;\r\n  uint8 public constant decimals = 18;\r\n  bool public isTokenContract = true;\r\n  bool public haltPurchase;\r\n\r\n  // This state is specific to the first version of the CST\r\n  // token contract and the token generation event, and hence\r\n  // there is no reason to persist in external storage for\r\n  // future contracts.\r\n  bool public allowTransfers;\r\n  mapping (address => bool) public whitelistedTransferer;\r\n  address[] public whitelistedTransfererForIndex;\r\n  mapping (address => bool) private processedWhitelistedTransferer;\r\n  uint256 public contributionMinimum;\r\n\r\n  event Mint(uint256 amountMinted, uint256 totalTokens, uint256 circulationCap);\r\n  event Approval(address indexed _owner,\r\n                 address indexed _spender,\r\n                 uint256 _value);\r\n  event Transfer(address indexed _from,\r\n                 address indexed _to,\r\n                 uint256 _value);\r\n  event WhiteList(address indexed buyer, uint256 holdCap);\r\n  event ConfigChanged(uint256 buyPrice, uint256 circulationCap, uint256 balanceLimit);\r\n  event VestedTokenGrant(address indexed beneficiary, uint256 startDate, uint256 cliffDate, uint256 durationSec, uint256 fullyVestedAmount, bool isRevocable);\r\n  event VestedTokenRevocation(address indexed beneficiary);\r\n  event VestedTokenRelease(address indexed beneficiary, uint256 amount);\r\n  event StorageUpdated(address storageAddress, address ledgerAddress);\r\n  event PurchaseHalted();\r\n  event PurchaseResumed();\r\n\r\n  modifier onlyFoundation {\r\n    address foundation = externalStorage.getFoundation();\r\n    require(foundation != address(0));\r\n    if (msg.sender != owner && msg.sender != foundation) revert();\r\n    _;\r\n  }\r\n\r\n  modifier initStorage {\r\n    address ledgerAddress = Registry(registry).getStorage(ledgerName);\r\n    address storageAddress = Registry(registry).getStorage(storageName);\r\n\r\n    tokenLedger = ITokenLedger(ledgerAddress);\r\n    externalStorage = storageAddress;\r\n    _;\r\n  }\r\n\r\n  constructor(address _registry, string _storageName, string _ledgerName) public payable {\r\n    isTokenContract = true;\r\n    version = \"2\";\r\n    require(_registry != address(0));\r\n    storageName = _storageName;\r\n    ledgerName = _ledgerName;\r\n    registry = _registry;\r\n\r\n    addSuperAdmin(registry);\r\n  }\r\n\r\n  /* This unnamed function is called whenever someone tries to send ether directly to the token contract */\r\n  function () public {\r\n    revert(); // Prevents accidental sending of ether\r\n  }\r\n\r\n  function getLedgerNameHash() external view returns (bytes32) {\r\n    return keccak256(abi.encodePacked(ledgerName));\r\n  }\r\n\r\n  function getStorageNameHash() external view returns (bytes32) {\r\n    return keccak256(abi.encodePacked(storageName));\r\n  }\r\n\r\n  function configure(bytes32 _tokenName,\r\n                     bytes32 _tokenSymbol,\r\n                     uint256 _buyPrice,\r\n                     uint256 _circulationCap,\r\n                     uint256 _balanceLimit,\r\n                     address _foundation) public onlySuperAdmins initStorage returns (bool) {\r\n\r\n    uint256 __buyPrice= externalStorage.getBuyPrice();\r\n    if (__buyPrice> 0 && __buyPrice!= _buyPrice) {\r\n      require(frozenToken);\r\n    }\r\n\r\n    externalStorage.setTokenName(_tokenName);\r\n    externalStorage.setTokenSymbol(_tokenSymbol);\r\n    externalStorage.setBuyPrice(_buyPrice);\r\n    externalStorage.setCirculationCap(_circulationCap);\r\n    externalStorage.setFoundation(_foundation);\r\n    externalStorage.setBalanceLimit(_balanceLimit);\r\n\r\n    emit ConfigChanged(_buyPrice, _circulationCap, _balanceLimit);\r\n\r\n    return true;\r\n  }\r\n\r\n  function configureFromStorage() public onlySuperAdmins unlessUpgraded initStorage returns (bool) {\r\n    freezeToken(true);\r\n    return true;\r\n  }\r\n\r\n  function updateStorage(string newStorageName, string newLedgerName) public onlySuperAdmins unlessUpgraded returns (bool) {\r\n    require(frozenToken);\r\n\r\n    storageName = newStorageName;\r\n    ledgerName = newLedgerName;\r\n\r\n    configureFromStorage();\r\n\r\n    address ledgerAddress = Registry(registry).getStorage(ledgerName);\r\n    address storageAddress = Registry(registry).getStorage(storageName);\r\n    emit StorageUpdated(storageAddress, ledgerAddress);\r\n    return true;\r\n  }\r\n\r\n  function name() public view unlessUpgraded returns(string) {\r\n    return bytes32ToString(externalStorage.getTokenName());\r\n  }\r\n\r\n  function symbol() public view unlessUpgraded returns(string) {\r\n    return bytes32ToString(externalStorage.getTokenSymbol());\r\n  }\r\n\r\n  function totalInCirculation() public view unlessUpgraded returns(uint256) {\r\n    return tokenLedger.totalInCirculation().add(totalUnvestedAndUnreleasedTokens());\r\n  }\r\n\r\n  function cstBalanceLimit() public view unlessUpgraded returns(uint256) {\r\n    return externalStorage.getBalanceLimit();\r\n  }\r\n\r\n  function buyPrice() public view unlessUpgraded returns(uint256) {\r\n    return externalStorage.getBuyPrice();\r\n  }\r\n\r\n  function circulationCap() public view unlessUpgraded returns(uint256) {\r\n    return externalStorage.getCirculationCap();\r\n  }\r\n\r\n  // intentionally allowing this to be visible if upgraded so foundation can\r\n  // withdraw funds from contract that has a successor\r\n  function foundation() public view returns(address) {\r\n    return externalStorage.getFoundation();\r\n  }\r\n\r\n  function totalSupply() public view unlessUpgraded returns(uint256) {\r\n    return tokenLedger.totalTokens();\r\n  }\r\n\r\n  function tokensAvailable() public view unlessUpgraded returns(uint256) {\r\n    return totalSupply().sub(totalInCirculation());\r\n  }\r\n\r\n  function balanceOf(address account) public view unlessUpgraded returns (uint256) {\r\n    address thisAddress = this;\r\n    if (thisAddress == account) {\r\n      return tokensAvailable();\r\n    } else {\r\n      return tokenLedger.balanceOf(account);\r\n    }\r\n  }\r\n\r\n  function transfer(address recipient, uint256 amount) public unlessFrozen unlessUpgraded returns (bool) {\r\n    require(allowTransfers || whitelistedTransferer[msg.sender]);\r\n    require(amount > 0);\r\n    require(!frozenAccount[recipient]);\r\n\r\n    tokenLedger.transfer(msg.sender, recipient, amount);\r\n    emit Transfer(msg.sender, recipient, amount);\r\n\r\n    return true;\r\n  }\r\n\r\n  function mintTokens(uint256 mintedAmount) public onlySuperAdmins unlessUpgraded returns (bool) {\r\n    uint256 _circulationCap = externalStorage.getCirculationCap();\r\n    tokenLedger.mintTokens(mintedAmount);\r\n\r\n    emit Mint(mintedAmount, tokenLedger.totalTokens(), _circulationCap);\r\n\r\n    emit Transfer(address(0), this, mintedAmount);\r\n\r\n    return true;\r\n  }\r\n\r\n  function grantTokens(address recipient, uint256 amount) public onlySuperAdmins unlessUpgraded returns (bool) {\r\n    require(amount <= tokensAvailable());\r\n    require(!frozenAccount[recipient]);\r\n\r\n    tokenLedger.debitAccount(recipient, amount);\r\n    emit Transfer(this, recipient, amount);\r\n\r\n    return true;\r\n  }\r\n\r\n  function setHaltPurchase(bool _haltPurchase) public onlySuperAdmins unlessUpgraded returns (bool) {\r\n    haltPurchase = _haltPurchase;\r\n\r\n    if (_haltPurchase) {\r\n      emit PurchaseHalted();\r\n    } else {\r\n      emit PurchaseResumed();\r\n    }\r\n    return true;\r\n  }\r\n\r\n  function buy() external payable unlessFrozen unlessUpgraded returns (uint256) {\r\n    require(!haltPurchase);\r\n    require(externalStorage.getApprovedBuyer(msg.sender));\r\n\r\n    uint256 _buyPriceTokensPerWei = externalStorage.getBuyPrice();\r\n    uint256 _circulationCap = externalStorage.getCirculationCap();\r\n    require(msg.value > 0);\r\n    require(_buyPriceTokensPerWei > 0);\r\n    require(_circulationCap > 0);\r\n\r\n    uint256 amount = msg.value.mul(_buyPriceTokensPerWei);\r\n    require(totalInCirculation().add(amount) <= _circulationCap);\r\n    require(amount <= tokensAvailable());\r\n\r\n    uint256 balanceLimit;\r\n    uint256 buyerBalance = tokenLedger.balanceOf(msg.sender);\r\n    uint256 customLimit = externalStorage.getCustomBuyerLimit(msg.sender);\r\n    require(contributionMinimum == 0 || buyerBalance.add(amount) >= contributionMinimum);\r\n\r\n    if (customLimit > 0) {\r\n      balanceLimit = customLimit;\r\n    } else {\r\n      balanceLimit = externalStorage.getBalanceLimit();\r\n    }\r\n\r\n    require(balanceLimit > 0 && balanceLimit >= buyerBalance.add(amount));\r\n\r\n    tokenLedger.debitAccount(msg.sender, amount);\r\n    emit Transfer(this, msg.sender, amount);\r\n\r\n    return amount;\r\n  }\r\n\r\n  // intentionally allowing this to be visible if upgraded so foundation can\r\n  // withdraw funds from contract that has a successor\r\n  function foundationWithdraw(uint256 amount) public onlyFoundation returns (bool) {\r\n    /* UNTRUSTED */\r\n    msg.sender.transfer(amount);\r\n\r\n    return true;\r\n  }\r\n\r\n  function foundationDeposit() public payable unlessUpgraded returns (bool) {\r\n    return true;\r\n  }\r\n\r\n  function allowance(address owner, address spender) public view unlessUpgraded returns (uint256) {\r\n    return externalStorage.getAllowance(owner, spender);\r\n  }\r\n\r\n  function transferFrom(address from, address to, uint256 value) public unlessFrozen unlessUpgraded returns (bool) {\r\n    require(allowTransfers);\r\n    require(!frozenAccount[from]);\r\n    require(!frozenAccount[to]);\r\n    require(from != msg.sender);\r\n    require(value > 0);\r\n\r\n    uint256 allowanceValue = allowance(from, msg.sender);\r\n    require(allowanceValue >= value);\r\n\r\n    tokenLedger.transfer(from, to, value);\r\n    externalStorage.setAllowance(from, msg.sender, allowanceValue.sub(value));\r\n\r\n    emit Transfer(from, to, value);\r\n    return true;\r\n  }\r\n\r\n  /* Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   *\r\n   * Please use `increaseApproval` or `decreaseApproval` instead.\r\n   */\r\n  function approve(address spender, uint256 value) public unlessFrozen unlessUpgraded returns (bool) {\r\n    require(spender != address(0));\r\n    require(!frozenAccount[spender]);\r\n    require(msg.sender != spender);\r\n\r\n    externalStorage.setAllowance(msg.sender, spender, value);\r\n\r\n    emit Approval(msg.sender, spender, value);\r\n    return true;\r\n  }\r\n\r\n  function increaseApproval(address spender, uint256 addedValue) public unlessFrozen unlessUpgraded returns (bool) {\r\n    return approve(spender, externalStorage.getAllowance(msg.sender, spender).add(addedValue));\r\n  }\r\n\r\n  function decreaseApproval(address spender, uint256 subtractedValue) public unlessFrozen unlessUpgraded returns (bool) {\r\n    uint256 oldValue = externalStorage.getAllowance(msg.sender, spender);\r\n\r\n    if (subtractedValue > oldValue) {\r\n      return approve(spender, 0);\r\n    } else {\r\n      return approve(spender, oldValue.sub(subtractedValue));\r\n    }\r\n  }\r\n\r\n  function grantVestedTokens(address beneficiary,\r\n                             uint256 fullyVestedAmount,\r\n                             uint256 startDate, // 0 indicates start \"now\"\r\n                             uint256 cliffSec,\r\n                             uint256 durationSec,\r\n                             bool isRevocable) public onlySuperAdmins unlessUpgraded returns(bool) {\r\n\r\n    uint256 _circulationCap = externalStorage.getCirculationCap();\r\n\r\n    require(beneficiary != address(0));\r\n    require(!frozenAccount[beneficiary]);\r\n    require(durationSec >= cliffSec);\r\n    require(totalInCirculation().add(fullyVestedAmount) <= _circulationCap);\r\n    require(fullyVestedAmount <= tokensAvailable());\r\n\r\n    uint256 _now = now;\r\n    if (startDate == 0) {\r\n      startDate = _now;\r\n    }\r\n\r\n    uint256 cliffDate = startDate.add(cliffSec);\r\n\r\n    externalStorage.setVestingSchedule(beneficiary,\r\n                                       fullyVestedAmount,\r\n                                       startDate,\r\n                                       cliffDate,\r\n                                       durationSec,\r\n                                       isRevocable);\r\n\r\n    emit VestedTokenGrant(beneficiary, startDate, cliffDate, durationSec, fullyVestedAmount, isRevocable);\r\n\r\n    return true;\r\n  }\r\n\r\n\r\n  function revokeVesting(address beneficiary) public onlySuperAdmins unlessUpgraded returns (bool) {\r\n    require(beneficiary != address(0));\r\n    externalStorage.revokeVesting(beneficiary);\r\n\r\n    releaseVestedTokensForBeneficiary(beneficiary);\r\n\r\n    emit VestedTokenRevocation(beneficiary);\r\n\r\n    return true;\r\n  }\r\n\r\n  function releaseVestedTokens() public unlessFrozen unlessUpgraded returns (bool) {\r\n    return releaseVestedTokensForBeneficiary(msg.sender);\r\n  }\r\n\r\n  function releaseVestedTokensForBeneficiary(address beneficiary) public unlessFrozen unlessUpgraded returns (bool) {\r\n    require(beneficiary != address(0));\r\n    require(!frozenAccount[beneficiary]);\r\n\r\n    uint256 unreleased = releasableAmount(beneficiary);\r\n\r\n    if (unreleased == 0) { return true; }\r\n\r\n    externalStorage.releaseVestedTokens(beneficiary);\r\n\r\n    tokenLedger.debitAccount(beneficiary, unreleased);\r\n    emit Transfer(this, beneficiary, unreleased);\r\n\r\n    emit VestedTokenRelease(beneficiary, unreleased);\r\n\r\n    return true;\r\n  }\r\n\r\n  function releasableAmount(address beneficiary) public view unlessUpgraded returns (uint256) {\r\n    return externalStorage.releasableAmount(beneficiary);\r\n  }\r\n\r\n  function totalUnvestedAndUnreleasedTokens() public view unlessUpgraded returns (uint256) {\r\n    return externalStorage.getTotalUnvestedAndUnreleasedTokens();\r\n  }\r\n\r\n  function vestingMappingSize() public view unlessUpgraded returns (uint256) {\r\n    return externalStorage.vestingMappingSize();\r\n  }\r\n\r\n  function vestingBeneficiaryForIndex(uint256 index) public view unlessUpgraded returns (address) {\r\n    return externalStorage.vestingBeneficiaryForIndex(index);\r\n  }\r\n\r\n  function vestingSchedule(address _beneficiary) public\r\n                                                 view unlessUpgraded returns (uint256 startDate,\r\n                                                                              uint256 cliffDate,\r\n                                                                              uint256 durationSec,\r\n                                                                              uint256 fullyVestedAmount,\r\n                                                                              uint256 vestedAmount,\r\n                                                                              uint256 vestedAvailableAmount,\r\n                                                                              uint256 releasedAmount,\r\n                                                                              uint256 revokeDate,\r\n                                                                              bool isRevocable) {\r\n    (\r\n      startDate,\r\n      cliffDate,\r\n      durationSec,\r\n      fullyVestedAmount,\r\n      releasedAmount,\r\n      revokeDate,\r\n      isRevocable\r\n    ) =  externalStorage.getVestingSchedule(_beneficiary);\r\n\r\n    vestedAmount = externalStorage.vestedAmount(_beneficiary);\r\n    vestedAvailableAmount = externalStorage.vestedAvailableAmount(_beneficiary);\r\n  }\r\n\r\n  function totalCustomBuyersMapping() public view returns (uint256) {\r\n    return externalStorage.getCustomBuyerMappingCount();\r\n  }\r\n\r\n  function customBuyerLimit(address buyer) public view returns (uint256) {\r\n    return externalStorage.getCustomBuyerLimit(buyer);\r\n  }\r\n\r\n  function customBuyerForIndex(uint256 index) public view returns (address) {\r\n    return externalStorage.getCustomBuyerForIndex(index);\r\n  }\r\n\r\n  function setCustomBuyer(address buyer, uint256 balanceLimit) public onlySuperAdmins unlessUpgraded returns (bool) {\r\n    require(buyer != address(0));\r\n    externalStorage.setCustomBuyerLimit(buyer, balanceLimit);\r\n    addBuyer(buyer);\r\n\r\n    return true;\r\n  }\r\n\r\n  function setAllowTransfers(bool _allowTransfers) public onlySuperAdmins unlessUpgraded returns (bool) {\r\n    allowTransfers = _allowTransfers;\r\n    return true;\r\n  }\r\n\r\n  function setContributionMinimum(uint256 _contributionMinimum) public onlySuperAdmins unlessUpgraded returns (bool) {\r\n    contributionMinimum = _contributionMinimum;\r\n    return true;\r\n  }\r\n\r\n  function totalBuyersMapping() public view returns (uint256) {\r\n    return externalStorage.getApprovedBuyerMappingCount();\r\n  }\r\n\r\n  function approvedBuyer(address buyer) public view returns (bool) {\r\n    return externalStorage.getApprovedBuyer(buyer);\r\n  }\r\n\r\n  function approvedBuyerForIndex(uint256 index) public view returns (address) {\r\n    return externalStorage.getApprovedBuyerForIndex(index);\r\n  }\r\n\r\n  function addBuyer(address buyer) public onlySuperAdmins unlessUpgraded returns (bool) {\r\n    require(buyer != address(0));\r\n    externalStorage.setApprovedBuyer(buyer, true);\r\n\r\n    uint256 balanceLimit = externalStorage.getCustomBuyerLimit(buyer);\r\n    if (balanceLimit == 0) {\r\n      balanceLimit = externalStorage.getBalanceLimit();\r\n    }\r\n\r\n    emit WhiteList(buyer, balanceLimit);\r\n\r\n    return true;\r\n  }\r\n\r\n  function removeBuyer(address buyer) public onlySuperAdmins unlessUpgraded returns (bool) {\r\n    require(buyer != address(0));\r\n    externalStorage.setApprovedBuyer(buyer, false);\r\n\r\n    return true;\r\n  }\r\n\r\n  function totalTransferWhitelistMapping() public view returns (uint256) {\r\n    return whitelistedTransfererForIndex.length;\r\n  }\r\n\r\n  function setWhitelistedTransferer(address transferer, bool _allowTransfers) public onlySuperAdmins unlessUpgraded returns (bool) {\r\n    require(transferer != address(0));\r\n    whitelistedTransferer[transferer] = _allowTransfers;\r\n    if (!processedWhitelistedTransferer[transferer]) {\r\n      whitelistedTransfererForIndex.push(transferer);\r\n      processedWhitelistedTransferer[transferer] = true;\r\n    }\r\n\r\n    return true;\r\n  }\r\n}\r\n\r\ncontract Registry is administratable, upgradeable {\r\n  using SafeMath for uint256;\r\n\r\n  bytes4 constant INTERFACE_META_ID = 0x01ffc9a7;\r\n  bytes4 constant ADDR_INTERFACE_ID = 0x3b3b57de;\r\n  bytes32 constant BARE_DOMAIN_NAMEHASH = 0x794941fae74d6435d1b29ee1c08cc39941ba78470872e6afd0693c7eeb63025c; // namehash for \"cardstack.eth\"\r\n\r\n  mapping(bytes32 => address) public storageForHash;\r\n  mapping(bytes32 => address) public contractForHash;\r\n  mapping(bytes32 => bytes32) public hashForNamehash;\r\n  mapping(bytes32 => bytes32) public namehashForHash;\r\n  string[] public contractNameForIndex;\r\n\r\n  event ContractRegistered(address indexed _contract, string _name, bytes32 namehash);\r\n  event ContractUpgraded(address indexed successor, address indexed predecessor, string name, bytes32 namehash);\r\n  event StorageAdded(address indexed storageAddress, string name);\r\n  event StorageRemoved(address indexed storageAddress, string name);\r\n  event AddrChanged(bytes32 indexed node, address a);\r\n\r\n  function() public {\r\n    revert();\r\n  }\r\n\r\n  function supportsInterface(bytes4 interfaceId) public pure returns (bool) {\r\n    return interfaceId == ADDR_INTERFACE_ID ||\r\n           interfaceId == INTERFACE_META_ID;\r\n  }\r\n\r\n  function addr(bytes32 node) public view returns (address) {\r\n    return contractForHash[hashForNamehash[node]];\r\n  }\r\n\r\n  function getContractHash(string name) public view unlessUpgraded returns (bytes32) {\r\n    return keccak256(abi.encodePacked(name));\r\n  }\r\n\r\n  function numContracts() public view returns(uint256) {\r\n    return contractNameForIndex.length;\r\n  }\r\n\r\n  function setNamehash(string contractName, bytes32 namehash) external onlySuperAdmins unlessUpgraded returns (bool) {\r\n    require(namehash != 0x0);\r\n\r\n    bytes32 hash = keccak256(abi.encodePacked(contractName));\r\n    address contractAddress = contractForHash[hash];\r\n\r\n    require(contractAddress != 0x0);\r\n    require(hashForNamehash[namehash] == 0x0);\r\n\r\n    hashForNamehash[namehash] = hash;\r\n    namehashForHash[hash] = namehash;\r\n\r\n    emit AddrChanged(namehash, contractAddress);\r\n  }\r\n\r\n  function register(string name, address contractAddress, bytes32 namehash) external onlySuperAdmins unlessUpgraded returns (bool) {\r\n    bytes32 hash = keccak256(abi.encodePacked(name));\r\n    require(bytes(name).length > 0);\r\n    require(contractAddress != 0x0);\r\n    require(contractForHash[hash] == 0x0);\r\n    require(hashForNamehash[namehash] == 0x0);\r\n\r\n    contractNameForIndex.push(name);\r\n    contractForHash[hash] = contractAddress;\r\n\r\n    if (namehash != 0x0) {\r\n      hashForNamehash[namehash] = hash;\r\n      namehashForHash[hash] = namehash;\r\n    }\r\n\r\n    address storageAddress = storageForHash[IStorable(contractAddress).getStorageNameHash()];\r\n    address ledgerAddress = storageForHash[IStorable(contractAddress).getLedgerNameHash()];\r\n\r\n    if (storageAddress != 0x0) {\r\n      ExternalStorage(storageAddress).addAdmin(contractAddress);\r\n    }\r\n    if (ledgerAddress != 0x0) {\r\n      CstLedger(ledgerAddress).addAdmin(contractAddress);\r\n    }\r\n\r\n    configurable(contractAddress).configureFromStorage();\r\n\r\n    emit ContractRegistered(contractAddress, name, namehash);\r\n\r\n    if (namehash != 0x0) {\r\n      emit AddrChanged(namehash, contractAddress);\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  function upgradeContract(string name, address successor) external onlySuperAdmins unlessUpgraded returns (bytes32) {\r\n    bytes32 hash = keccak256(abi.encodePacked(name));\r\n    require(successor != 0x0);\r\n    require(contractForHash[hash] != 0x0);\r\n\r\n    address predecessor = contractForHash[hash];\r\n    require(freezable(predecessor).frozenToken());\r\n\r\n    contractForHash[hash] = successor;\r\n\r\n    uint256 remainingContractBalance;\r\n    // we need https://github.com/ethereum/EIPs/issues/165\r\n    // to be able to see if a contract is ERC20 or not...\r\n    if (hash == keccak256(\"cst\")) {\r\n      remainingContractBalance = ERC20(predecessor).balanceOf(predecessor);\r\n    }\r\n\r\n    upgradeable(predecessor).upgradeTo(successor,\r\n                                       remainingContractBalance);\r\n    upgradeable(successor).upgradedFrom(predecessor);\r\n\r\n    address successorStorageAddress = storageForHash[IStorable(successor).getStorageNameHash()];\r\n    address successorLedgerAddress = storageForHash[IStorable(successor).getLedgerNameHash()];\r\n    address predecessorStorageAddress = storageForHash[IStorable(predecessor).getStorageNameHash()];\r\n    address predecessorLedgerAddress = storageForHash[IStorable(predecessor).getLedgerNameHash()];\r\n\r\n    if (successorStorageAddress != 0x0) {\r\n      ExternalStorage(successorStorageAddress).addAdmin(successor);\r\n    }\r\n    if (predecessorStorageAddress != 0x0) {\r\n      ExternalStorage(predecessorStorageAddress).removeAdmin(predecessor);\r\n    }\r\n\r\n    if (successorLedgerAddress != 0x0) {\r\n      CstLedger(successorLedgerAddress).addAdmin(successor);\r\n    }\r\n    if (predecessorLedgerAddress != 0x0) {\r\n      CstLedger(predecessorLedgerAddress).removeAdmin(predecessor);\r\n    }\r\n\r\n    configurable(successor).configureFromStorage();\r\n\r\n    if (hashForNamehash[BARE_DOMAIN_NAMEHASH] == hash) {\r\n      emit AddrChanged(BARE_DOMAIN_NAMEHASH, successor);\r\n    }\r\n    if (namehashForHash[hash] != 0x0 && namehashForHash[hash] != BARE_DOMAIN_NAMEHASH) {\r\n      emit AddrChanged(namehashForHash[hash], successor);\r\n    }\r\n\r\n    emit ContractUpgraded(successor, predecessor, name, namehashForHash[hash]);\r\n    return hash;\r\n  }\r\n\r\n  function addStorage(string name, address storageAddress) external onlySuperAdmins unlessUpgraded {\r\n    require(storageAddress != address(0));\r\n    bytes32 hash = keccak256(abi.encodePacked(name));\r\n    storageForHash[hash] = storageAddress;\r\n\r\n    emit StorageAdded(storageAddress, name);\r\n  }\r\n\r\n  function getStorage(string name) public view unlessUpgraded returns (address) {\r\n    return storageForHash[keccak256(abi.encodePacked(name))];\r\n  }\r\n\r\n  function removeStorage(string name) public onlySuperAdmins unlessUpgraded {\r\n    address storageAddress = storageForHash[keccak256(abi.encodePacked(name))];\r\n    delete storageForHash[keccak256(abi.encodePacked(name))];\r\n\r\n    emit StorageRemoved(storageAddress, name);\r\n  }\r\n}", "ABI": "[{\"constant\":true,\"inputs\":[],\"name\":\"totalAdminsMapping\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"buyer\",\"type\":\"address\"}],\"name\":\"customBuyerLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newStorageName\",\"type\":\"string\"},{\"name\":\"newLedgerName\",\"type\":\"string\"}],\"name\":\"updateStorage\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"beneficiary\",\"type\":\"address\"}],\"name\":\"releasableAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"admin\",\"type\":\"address\"}],\"name\":\"removeAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"configureFromStorage\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"allowTransfers\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"vestingMappingSize\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalFrozenAccountsMapping\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"adminsForIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenLedger\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"beneficiary\",\"type\":\"address\"}],\"name\":\"revokeVesting\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"foundation\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"admins\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"vestingBeneficiaryForIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"admin\",\"type\":\"address\"}],\"name\":\"removeSuperAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contributionMinimum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isTokenContract\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"transferer\",\"type\":\"address\"},{\"name\":\"_allowTransfers\",\"type\":\"bool\"}],\"name\":\"setWhitelistedTransferer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"releaseVestedTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"circulationCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalInCirculation\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenName\",\"type\":\"bytes32\"},{\"name\":\"_tokenSymbol\",\"type\":\"bytes32\"},{\"name\":\"_buyPrice\",\"type\":\"uint256\"},{\"name\":\"_circulationCap\",\"type\":\"uint256\"},{\"name\":\"_balanceLimit\",\"type\":\"uint256\"},{\"name\":\"_foundation\",\"type\":\"address\"}],\"name\":\"configure\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensAvailable\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_predecessor\",\"type\":\"address\"}],\"name\":\"upgradedFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_haltPurchase\",\"type\":\"bool\"}],\"name\":\"setHaltPurchase\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"frozenToken\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"buyer\",\"type\":\"address\"}],\"name\":\"removeBuyer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"successor\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"admin\",\"type\":\"address\"}],\"name\":\"addAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"freeze\",\"type\":\"bool\"}],\"name\":\"freezeToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"registry\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"frozenAccountForIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cstBalanceLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"buyPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"externalStorage\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalUnvestedAndUnreleasedTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getLedgerNameHash\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"x\",\"type\":\"bytes32\"}],\"name\":\"bytes32ToString\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"mintedAmount\",\"type\":\"uint256\"}],\"name\":\"mintTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getStorageNameHash\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"beneficiary\",\"type\":\"address\"}],\"name\":\"releaseVestedTokensForBeneficiary\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"foundationDeposit\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"whitelistedTransfererForIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalBuyersMapping\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buy\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"recipient\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSuperAdminsMapping\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"superAdmins\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"admin\",\"type\":\"address\"}],\"name\":\"addSuperAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"frozenAccount\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"predecessor\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"customBuyerForIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"buyer\",\"type\":\"address\"}],\"name\":\"addBuyer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"buyer\",\"type\":\"address\"}],\"name\":\"approvedBuyer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"superAdminsForIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isDeprecated\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"recipient\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"grantTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contributionMinimum\",\"type\":\"uint256\"}],\"name\":\"setContributionMinimum\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"foundationWithdraw\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ledgerName\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"haltPurchase\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"storageName\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"buyer\",\"type\":\"address\"},{\"name\":\"balanceLimit\",\"type\":\"uint256\"}],\"name\":\"setCustomBuyer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_allowTransfers\",\"type\":\"bool\"}],\"name\":\"setAllowTransfers\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalCustomBuyersMapping\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"target\",\"type\":\"address\"},{\"name\":\"freeze\",\"type\":\"bool\"}],\"name\":\"freezeAccount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalTransferWhitelistMapping\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelistedTransferer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"approvedBuyerForIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_successor\",\"type\":\"address\"},{\"name\":\"remainingContractBalance\",\"type\":\"uint256\"}],\"name\":\"upgradeTo\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"beneficiary\",\"type\":\"address\"},{\"name\":\"fullyVestedAmount\",\"type\":\"uint256\"},{\"name\":\"startDate\",\"type\":\"uint256\"},{\"name\":\"cliffSec\",\"type\":\"uint256\"},{\"name\":\"durationSec\",\"type\":\"uint256\"},{\"name\":\"isRevocable\",\"type\":\"bool\"}],\"name\":\"grantVestedTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"vestingSchedule\",\"outputs\":[{\"name\":\"startDate\",\"type\":\"uint256\"},{\"name\":\"cliffDate\",\"type\":\"uint256\"},{\"name\":\"durationSec\",\"type\":\"uint256\"},{\"name\":\"fullyVestedAmount\",\"type\":\"uint256\"},{\"name\":\"vestedAmount\",\"type\":\"uint256\"},{\"name\":\"vestedAvailableAmount\",\"type\":\"uint256\"},{\"name\":\"releasedAmount\",\"type\":\"uint256\"},{\"name\":\"revokeDate\",\"type\":\"uint256\"},{\"name\":\"isRevocable\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_registry\",\"type\":\"address\"},{\"name\":\"_storageName\",\"type\":\"string\"},{\"name\":\"_ledgerName\",\"type\":\"string\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"amountMinted\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"totalTokens\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"circulationCap\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"holdCap\",\"type\":\"uint256\"}],\"name\":\"WhiteList\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"buyPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"circulationCap\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"balanceLimit\",\"type\":\"uint256\"}],\"name\":\"ConfigChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"startDate\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"cliffDate\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"durationSec\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"fullyVestedAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"isRevocable\",\"type\":\"bool\"}],\"name\":\"VestedTokenGrant\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"}],\"name\":\"VestedTokenRevocation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"VestedTokenRelease\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"storageAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ledgerAddress\",\"type\":\"address\"}],\"name\":\"StorageUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"PurchaseHalted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"PurchaseResumed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"successor\",\"type\":\"address\"}],\"name\":\"Upgraded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"predecessor\",\"type\":\"address\"}],\"name\":\"UpgradedFrom\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"frozen\",\"type\":\"bool\"}],\"name\":\"FrozenFunds\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"frozen\",\"type\":\"bool\"}],\"name\":\"FrozenToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"admin\",\"type\":\"address\"}],\"name\":\"AddAdmin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"admin\",\"type\":\"address\"}],\"name\":\"RemoveAdmin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"admin\",\"type\":\"address\"}],\"name\":\"AddSuperAdmin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"admin\",\"type\":\"address\"}],\"name\":\"RemoveSuperAdmin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]", "ContractName": "CardStackToken", "CompilerVersion": "v0.4.24+commit.e67f0147", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000fc8deeb5cd80a3e8b8de353df9b5b09c71d3ef17000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000000000000a63737453746f7261676500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000b6c65646765722d43415244000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "CstLibrary:5f4928c421a53a9aa161d96886299ded68fb76a2", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://7c35ca72ac77a98c735fe3da0e9208f4e6afbcd86719711e675883cd5caa00f4"}