{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.2;\\n\\ninterface IUniswapV2Router01 {\\n    function factory() external pure returns (address);\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETH(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountToken, uint amountETH);\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountToken, uint amountETH);\\n    function swapExactTokensForTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapTokensForExactTokens(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.2;\\n\\nimport './IUniswapV2Router01.sol';\\n\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountETH);\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountETH);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable;\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/Distributor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\r\\npragma solidity ^0.8.18;\\r\\n\\r\\nimport \\\"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\nimport { IRevenueDistributionToken } from \\\"./interfaces/IRevenueDistributionToken.sol\\\";\\r\\n\\r\\n\\r\\ncontract Redistributor {\\r\\n\\r\\n    uint public totalAccumulated;\\r\\n    \\r\\n    uint public distributionThreshold;\\r\\n\\r\\n    uint public liquidityShare;\\r\\n    uint public crocShare;\\r\\n    uint public vestingPeriod;\\r\\n    uint public distributionTime;\\r\\n\\r\\n    address public croc;\\r\\n    address public crocLp;\\r\\n    address public crocVault;\\r\\n    address public lpVault;\\r\\n    address public creator;\\r\\n\\r\\n\\r\\n    IUniswapV2Router02 public uniswapRouter;\\r\\n\\r\\n    event Distribution(uint ethForCroc, uint ethForLiq);\\r\\n    \\r\\n    constructor(\\r\\n        uint _liquidityShare, \\r\\n        uint _crocShare,\\r\\n        address _crocVault,\\r\\n        address _croc, \\r\\n        address _crocLp,\\r\\n        address _lpVault,\\r\\n        address _uniswapRouter,\\r\\n        uint _vestingPeriod,\\r\\n        uint _threshold\\r\\n    ) {\\r\\n        creator = msg.sender;\\r\\n        liquidityShare = _liquidityShare;\\r\\n        crocShare = _crocShare;\\r\\n        crocVault = _crocVault;\\r\\n        lpVault = _lpVault;\\r\\n        croc = _croc;\\r\\n        crocLp = _crocLp;\\r\\n        uniswapRouter = IUniswapV2Router02(_uniswapRouter);\\r\\n        vestingPeriod = _vestingPeriod;\\r\\n        distributionTime = block.timestamp; \\r\\n        distributionThreshold = _threshold;\\r\\n    }\\r\\n\\r\\n    receive() external payable {\\r\\n        totalAccumulated += msg.value;\\r\\n        if (totalAccumulated >= distributionThreshold && block.timestamp >= distributionTime + 1 days) {\\r\\n            _triggerDistribution();\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function editDistributionThreshold(uint _newThreshold) external {\\r\\n        require(msg.sender == creator, \\\"Only creator can edit threshold\\\");\\r\\n        distributionThreshold = _newThreshold;\\r\\n    }\\r\\n\\r\\n    function acceptVaultOwnership(address _vault) external {\\r\\n        require(msg.sender == creator, \\\"Only creator can accept vault ownership\\\");\\r\\n        IRevenueDistributionToken(_vault).acceptOwnership();\\r\\n    }\\r\\n\\r\\n    function setVaultPendingOwner(address _vault) external {\\r\\n        require(msg.sender == creator, \\\"Only creator can set vault ownership\\\");\\r\\n        IRevenueDistributionToken(_vault).setPendingOwner(creator);\\r\\n    }\\r\\n\\r\\n    function editShares(uint _crocShare, uint _liquidityShare) external {\\r\\n        require(msg.sender == creator, \\\"Only creator can edit shares\\\");\\r\\n        crocShare = _crocShare;\\r\\n        liquidityShare = _liquidityShare;\\r\\n    }\\r\\n\\r\\n    function editVesting(uint _vestingPeriod) external {\\r\\n        require(msg.sender == creator, \\\"Only creator can edit vesting\\\");\\r\\n        vestingPeriod = _vestingPeriod;\\r\\n    }\\r\\n\\r\\n    function updateDistributionTime(uint _newTime) external {\\r\\n        require(msg.sender == creator, \\\"Only creator can change distribution time\\\");\\r\\n        distributionTime = _newTime;\\r\\n    }\\r\\n\\r\\n    function emergencyWithdraw() external  {\\r\\n        require(msg.sender == creator, \\\"Only creator can edit emergency withdraw\\\");\\r\\n        payable(creator).transfer(address(this).balance);\\r\\n    }\\r\\n\\r\\n    function _triggerDistribution() internal {\\r\\n        uint crocAmount = (totalAccumulated * crocShare) / 100;\\r\\n        uint liquidityAmount = totalAccumulated - crocAmount;\\r\\n\\r\\n        // Buy CROC\\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = uniswapRouter.WETH();\\r\\n        path[1] = croc;\\r\\n        uniswapRouter.swapExactETHForTokens{value: crocAmount}(\\r\\n            0, \\r\\n            path,\\r\\n            address(this),\\r\\n            block.timestamp\\r\\n        );\\r\\n    \\r\\n        // Deposit to CrocVault\\r\\n        IERC20(croc).transfer(crocVault, IERC20(path[1]).balanceOf(address(this)));\\r\\n        IRevenueDistributionToken(crocVault).updateVestingSchedule(vestingPeriod);\\r\\n\\r\\n        // Buy more CROC\\r\\n        path[0] = uniswapRouter.WETH(); \\r\\n        path[1] = croc;\\r\\n        uniswapRouter.swapExactETHForTokens{value: liquidityAmount / 2}(\\r\\n            0, \\r\\n            path,\\r\\n            address(this),\\r\\n            block.timestamp\\r\\n        );\\r\\n\\r\\n        // Approve\\r\\n        IERC20(croc).approve(address(uniswapRouter), IERC20(croc).balanceOf(address(this)));\\r\\n\\r\\n        // Add liquidity\\r\\n        uniswapRouter.addLiquidityETH{value: liquidityAmount / 2}(\\r\\n            croc,\\r\\n            IERC20(croc).balanceOf(address(this)),\\r\\n            0,\\r\\n            0,\\r\\n            lpVault,\\r\\n            block.timestamp\\r\\n        );\\r\\n        \\r\\n        IRevenueDistributionToken(lpVault).updateVestingSchedule(vestingPeriod);\\r\\n\\r\\n        emit Distribution(crocAmount, liquidityAmount);\\r\\n\\r\\n        totalAccumulated = 0;\\r\\n        distributionTime = distributionTime + 1 days;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\r\\npragma solidity 0.8.18;\\r\\n\\r\\n/// @title Interface of the ERC20 standard as defined in the EIP, including EIP-2612 permit functionality.\\r\\ninterface IERC20 {\\r\\n\\r\\n    /**************/\\r\\n    /*** Events ***/\\r\\n    /**************/\\r\\n\\r\\n    /**\\r\\n     *  @dev   Emitted when one account has set the allowance of another account over their tokens.\\r\\n     *  @param owner_   Account that tokens are approved from.\\r\\n     *  @param spender_ Account that tokens are approved for.\\r\\n     *  @param amount_  Amount of tokens that have been approved.\\r\\n     */\\r\\n    event Approval(address indexed owner_, address indexed spender_, uint256 amount_);\\r\\n\\r\\n    /**\\r\\n     *  @dev   Emitted when tokens have moved from one account to another.\\r\\n     *  @param owner_     Account that tokens have moved from.\\r\\n     *  @param recipient_ Account that tokens have moved to.\\r\\n     *  @param amount_    Amount of tokens that have been transferred.\\r\\n     */\\r\\n    event Transfer(address indexed owner_, address indexed recipient_, uint256 amount_);\\r\\n\\r\\n    /**************************/\\r\\n    /*** External Functions ***/\\r\\n    /**************************/\\r\\n\\r\\n    /**\\r\\n     *  @dev    Function that allows one account to set the allowance of another account over their tokens.\\r\\n     *          Emits an {Approval} event.\\r\\n     *  @param  spender_ Account that tokens are approved for.\\r\\n     *  @param  amount_  Amount of tokens that have been approved.\\r\\n     *  @return success_ Boolean indicating whether the operation succeeded.\\r\\n     */\\r\\n    function approve(address spender_, uint256 amount_) external returns (bool success_);\\r\\n\\r\\n    /**\\r\\n     *  @dev    Function that allows one account to decrease the allowance of another account over their tokens.\\r\\n     *          Emits an {Approval} event.\\r\\n     *  @param  spender_          Account that tokens are approved for.\\r\\n     *  @param  subtractedAmount_ Amount to decrease approval by.\\r\\n     *  @return success_          Boolean indicating whether the operation succeeded.\\r\\n     */\\r\\n    function decreaseAllowance(address spender_, uint256 subtractedAmount_) external returns (bool success_);\\r\\n\\r\\n    /**\\r\\n     *  @dev    Function that allows one account to increase the allowance of another account over their tokens.\\r\\n     *          Emits an {Approval} event.\\r\\n     *  @param  spender_     Account that tokens are approved for.\\r\\n     *  @param  addedAmount_ Amount to increase approval by.\\r\\n     *  @return success_     Boolean indicating whether the operation succeeded.\\r\\n     */\\r\\n    function increaseAllowance(address spender_, uint256 addedAmount_) external returns (bool success_);\\r\\n\\r\\n    /**\\r\\n     *  @dev   Approve by signature.\\r\\n     *  @param owner_    Owner address that signed the permit.\\r\\n     *  @param spender_  Spender of the permit.\\r\\n     *  @param amount_   Permit approval spend limit.\\r\\n     *  @param deadline_ Deadline after which the permit is invalid.\\r\\n     *  @param v_        ECDSA signature v component.\\r\\n     *  @param r_        ECDSA signature r component.\\r\\n     *  @param s_        ECDSA signature s component.\\r\\n     */\\r\\n    function permit(address owner_, address spender_, uint amount_, uint deadline_, uint8 v_, bytes32 r_, bytes32 s_) external;\\r\\n\\r\\n    /**\\r\\n     *  @dev    Moves an amount of tokens from `msg.sender` to a specified account.\\r\\n     *          Emits a {Transfer} event.\\r\\n     *  @param  recipient_ Account that receives tokens.\\r\\n     *  @param  amount_    Amount of tokens that are transferred.\\r\\n     *  @return success_   Boolean indicating whether the operation succeeded.\\r\\n     */\\r\\n    function transfer(address recipient_, uint256 amount_) external returns (bool success_);\\r\\n\\r\\n    /**\\r\\n     *  @dev    Moves a pre-approved amount of tokens from a sender to a specified account.\\r\\n     *          Emits a {Transfer} event.\\r\\n     *          Emits an {Approval} event.\\r\\n     *  @param  owner_     Account that tokens are moving from.\\r\\n     *  @param  recipient_ Account that receives tokens.\\r\\n     *  @param  amount_    Amount of tokens that are transferred.\\r\\n     *  @return success_   Boolean indicating whether the operation succeeded.\\r\\n     */\\r\\n    function transferFrom(address owner_, address recipient_, uint256 amount_) external returns (bool success_);\\r\\n\\r\\n    /**********************/\\r\\n    /*** View Functions ***/\\r\\n    /**********************/\\r\\n\\r\\n    /**\\r\\n     *  @dev    Returns the allowance that one account has given another over their tokens.\\r\\n     *  @param  owner_     Account that tokens are approved from.\\r\\n     *  @param  spender_   Account that tokens are approved for.\\r\\n     *  @return allowance_ Allowance that one account has given another over their tokens.\\r\\n     */\\r\\n    function allowance(address owner_, address spender_) external view returns (uint256 allowance_);\\r\\n\\r\\n    /**\\r\\n     *  @dev    Returns the amount of tokens owned by a given account.\\r\\n     *  @param  account_ Account that owns the tokens.\\r\\n     *  @return balance_ Amount of tokens owned by a given account.\\r\\n     */\\r\\n    function balanceOf(address account_) external view returns (uint256 balance_);\\r\\n\\r\\n    /**\\r\\n     *  @dev    Returns the decimal precision used by the token.\\r\\n     *  @return decimals_ The decimal precision used by the token.\\r\\n     */\\r\\n    function decimals() external view returns (uint8 decimals_);\\r\\n\\r\\n    /**\\r\\n     *  @dev    Returns the signature domain separator.\\r\\n     *  @return domainSeparator_ The signature domain separator.\\r\\n     */\\r\\n    function DOMAIN_SEPARATOR() external view returns (bytes32 domainSeparator_);\\r\\n\\r\\n    /**\\r\\n     *  @dev    Returns the name of the token.\\r\\n     *  @return name_ The name of the token.\\r\\n     */\\r\\n    function name() external view returns (string memory name_);\\r\\n\\r\\n    /**\\r\\n      *  @dev    Returns the nonce for the given owner.\\r\\n      *  @param  owner_  The address of the owner account.\\r\\n      *  @return nonce_ The nonce for the given owner.\\r\\n     */\\r\\n    function nonces(address owner_) external view returns (uint256 nonce_);\\r\\n\\r\\n    /**\\r\\n     *  @dev    Returns the permit type hash.\\r\\n     *  @return permitTypehash_ The permit type hash.\\r\\n     */\\r\\n    function PERMIT_TYPEHASH() external view returns (bytes32 permitTypehash_);\\r\\n\\r\\n    /**\\r\\n     *  @dev    Returns the symbol of the token.\\r\\n     *  @return symbol_ The symbol of the token.\\r\\n     */\\r\\n    function symbol() external view returns (string memory symbol_);\\r\\n\\r\\n    /**\\r\\n     *  @dev    Returns the total amount of tokens in existence.\\r\\n     *  @return totalSupply_ The total amount of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256 totalSupply_);\\r\\n\\r\\n}\"\r\n    },\r\n    \"contracts/interfaces/IERC4626.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\r\\npragma solidity 0.8.18;\\r\\n\\r\\nimport { IERC20 } from \\\"./IERC20.sol\\\";\\r\\n\\r\\n/// @title A standard for tokenized Vaults with a single underlying ERC-20 token.\\r\\ninterface IERC4626 is IERC20 {\\r\\n\\r\\n    /**************/\\r\\n    /*** Events ***/\\r\\n    /**************/\\r\\n\\r\\n    /**\\r\\n     *  @dev   `caller_` has exchanged `assets_` for `shares_` and transferred them to `owner_`.\\r\\n     *         MUST be emitted when assets are deposited via the `deposit` or `mint` methods.\\r\\n     *  @param caller_ The caller of the function that emitted the `Deposit` event.\\r\\n     *  @param owner_  The owner of the shares.\\r\\n     *  @param assets_ The amount of assets deposited.\\r\\n     *  @param shares_ The amount of shares minted.\\r\\n     */\\r\\n    event Deposit(address indexed caller_, address indexed owner_, uint256 assets_, uint256 shares_);\\r\\n\\r\\n    /**\\r\\n     *  @dev   `caller_`\u00a0has exchanged\u00a0`shares_`, owned by\u00a0`owner_`, for\u00a0`assets_`, and transferred them\u00a0to\u00a0`receiver_`.\\r\\n     *         MUST be emitted when assets are withdrawn via the\u00a0`withdraw`\u00a0or\u00a0`redeem`\u00a0methods.\\r\\n     *  @param caller_   The caller of the function that emitted the `Withdraw` event.\\r\\n     *  @param receiver_ The receiver of the assets.\\r\\n     *  @param owner_    The owner of the shares.\\r\\n     *  @param assets_   The amount of assets withdrawn.\\r\\n     *  @param shares_   The amount of shares burned.\\r\\n     */\\r\\n    event Withdraw(address indexed caller_, address indexed receiver_, address indexed owner_, uint256 assets_, uint256 shares_);\\r\\n\\r\\n    /***********************/\\r\\n    /*** State Variables ***/\\r\\n    /***********************/\\r\\n\\r\\n    /**\\r\\n     *  @dev    The address of the underlying asset used by the Vault.\\r\\n     *          MUST be a contract that implements the ERC-20 standard.\\r\\n     *          MUST NOT revert.\\r\\n     *  @return asset_ The address of the underlying asset.\\r\\n     */\\r\\n    function asset() external view returns (address asset_);\\r\\n\\r\\n    /********************************/\\r\\n    /*** State Changing Functions ***/\\r\\n    /********************************/\\r\\n\\r\\n    /**\\r\\n     *  @dev    Mints `shares_` to `receiver_` by depositing `assets_` into the Vault.\\r\\n     *          MUST emit the {Deposit} event.\\r\\n     *          MUST revert if all of the assets cannot be deposited (due to insufficient approval, deposit limits, slippage, etc).\\r\\n     *  @param  assets_   The amount of assets to deposit.\\r\\n     *  @param  receiver_ The receiver of the shares.\\r\\n     *  @return shares_   The amount of shares minted.\\r\\n     */\\r\\n    function deposit(uint256 assets_, address receiver_) external returns (uint256 shares_);\\r\\n\\r\\n    /**\\r\\n     *  @dev    Mints `shares_` to `receiver_` by depositing `assets_` into the Vault.\\r\\n     *          MUST emit the {Deposit} event.\\r\\n     *          MUST revert if all of shares cannot be minted (due to insufficient approval, deposit limits, slippage, etc).\\r\\n     *  @param  shares_   The amount of shares to mint.\\r\\n     *  @param  receiver_ The receiver of the shares.\\r\\n     *  @return assets_   The amount of assets deposited.\\r\\n     */\\r\\n    function mint(uint256 shares_, address receiver_) external returns (uint256 assets_);\\r\\n\\r\\n    /**\\r\\n     *  @dev    Burns\u00a0`shares_`\u00a0from\u00a0`owner_`\u00a0and sends\u00a0`assets_` to\u00a0`receiver_`.\\r\\n     *          MUST emit the\u00a0{Withdraw}\u00a0event.\\r\\n     *          MUST revert if all of\u00a0the shares\u00a0cannot be redeemed (due to insufficient shares, withdrawal limits, slippage, etc).\\r\\n     *  @param  shares_   The amount of shares to redeem.\\r\\n     *  @param  receiver_ The receiver of the assets.\\r\\n     *  @param  owner_    The owner of the shares.\\r\\n     *  @return assets_   The amount of assets sent to the receiver.\\r\\n     */\\r\\n    function redeem(uint256 shares_, address receiver_, address owner_) external returns (uint256 assets_);\\r\\n\\r\\n    /**\\r\\n     *  @dev    Burns\u00a0`shares_`\u00a0from\u00a0`owner_`\u00a0and sends `assets_`\u00a0to `receiver_`.\\r\\n     *          MUST emit the\u00a0{Withdraw}\u00a0event.\\r\\n     *          MUST revert if all of\u00a0the assets\u00a0cannot be withdrawn (due to insufficient assets, withdrawal limits, slippage, etc).\\r\\n     *  @param  assets_   The amount of assets to withdraw.\\r\\n     *  @param  receiver_ The receiver of the assets.\\r\\n     *  @param  owner_    The owner of the assets.\\r\\n     *  @return shares_   The amount of shares burned from the owner.\\r\\n     */\\r\\n    function withdraw(uint256 assets_, address receiver_, address owner_) external returns (uint256 shares_);\\r\\n\\r\\n    /**********************/\\r\\n    /*** View Functions ***/\\r\\n    /**********************/\\r\\n\\r\\n    /**\\r\\n     *  @dev    The amount of `assets_` the `shares_` are currently equivalent to.\\r\\n     *          MUST NOT be inclusive of any fees that are charged against assets in the Vault.\\r\\n     *          MUST NOT reflect slippage or other on-chain conditions when performing the actual exchange.\\r\\n     *          MUST NOT show any variations depending on the caller.\\r\\n     *          MUST NOT revert.\\r\\n     *  @param  shares_ The amount of shares to convert.\\r\\n     *  @return assets_ The amount of equivalent assets.\\r\\n     */\\r\\n    function convertToAssets(uint256 shares_) external view returns (uint256 assets_);\\r\\n\\r\\n    /**\\r\\n     *  @dev    The amount of `shares_` the `assets_` are currently equivalent to.\\r\\n     *          MUST NOT be inclusive of any fees that are charged against assets in the Vault.\\r\\n     *          MUST NOT reflect slippage or other on-chain conditions when performing the actual exchange.\\r\\n     *          MUST NOT show any variations depending on the caller.\\r\\n     *          MUST NOT revert.\\r\\n     *  @param  assets_ The amount of assets to convert.\\r\\n     *  @return shares_ The amount of equivalent shares.\\r\\n     */\\r\\n    function convertToShares(uint256 assets_) external view returns (uint256 shares_);\\r\\n\\r\\n    /**\\r\\n     *  @dev    Maximum amount of `assets_` that can be deposited on behalf of the `receiver_` through a `deposit` call.\\r\\n     *          MUST return a limited value if the receiver is subject to any limits, or the maximum value otherwise.\\r\\n     *          MUST NOT revert.\\r\\n     *  @param  receiver_ The receiver of the assets.\\r\\n     *  @return assets_   The maximum amount of assets that can be deposited.\\r\\n     */\\r\\n    function maxDeposit(address receiver_) external view returns (uint256 assets_);\\r\\n\\r\\n    /**\\r\\n     *  @dev    Maximum amount of `shares_` that can be minted on behalf of the `receiver_` through a `mint` call.\\r\\n     *          MUST return a limited value if the receiver is subject to any limits, or the maximum value otherwise.\\r\\n     *          MUST NOT revert.\\r\\n     *  @param  receiver_ The receiver of the shares.\\r\\n     *  @return shares_   The maximum amount of shares that can be minted.\\r\\n     */\\r\\n    function maxMint(address receiver_) external view returns (uint256 shares_);\\r\\n\\r\\n    /**\\r\\n     *  @dev    Maximum amount of `shares_` that can be redeemed from the\u00a0`owner_` through a\u00a0`redeem`\u00a0call.\\r\\n     *          MUST return a limited value if\u00a0the owner\u00a0is subject to any limits, or the total amount of owned shares otherwise.\\r\\n     *          MUST\u00a0NOT\u00a0revert.\\r\\n     *  @param  owner_  The owner of the shares.\\r\\n     *  @return shares_ The maximum amount of shares that can be redeemed.\\r\\n     */\\r\\n    function maxRedeem(address owner_) external view returns (uint256 shares_);\\r\\n\\r\\n    /**\\r\\n     *  @dev    Maximum amount of `assets_` that can be withdrawn from the `owner_` through a `withdraw` call.\\r\\n     *          MUST return a limited value if the owner is subject to any limits, or the total amount of owned assets otherwise.\\r\\n     *          MUST NOT revert.\\r\\n     *  @param  owner_  The owner of the assets.\\r\\n     *  @return assets_ The maximum amount of assets that can be withdrawn.\\r\\n     */\\r\\n    function maxWithdraw(address owner_) external view returns (uint256 assets_);\\r\\n\\r\\n    /**\\r\\n     *  @dev    Allows an on-chain or off-chain user to simulate the effects of their deposit at the current block, given current on-chain conditions.\\r\\n     *          MUST return as close to and no more than the exact amount of shares that would be minted in a `deposit` call in the same transaction.\\r\\n     *          MUST NOT account for deposit limits like those returned from `maxDeposit` and should always act as though the deposit would be accepted.\\r\\n     *          MUST NOT revert.\\r\\n     *  @param  assets_ The amount of assets to deposit.\\r\\n     *  @return shares_ The amount of shares that would be minted.\\r\\n     */\\r\\n    function previewDeposit(uint256 assets_) external view returns (uint256 shares_);\\r\\n\\r\\n    /**\\r\\n     *  @dev    Allows an on-chain or off-chain user to simulate the effects of their mint at the current block, given current on-chain conditions.\\r\\n     *          MUST return as close to and no fewer than the exact amount of assets that would be deposited in a `mint` call in the same transaction.\\r\\n     *          MUST NOT account for mint limits like those returned from `maxMint` and should always act as though the minting would be accepted.\\r\\n     *          MUST NOT revert.\\r\\n     *  @param  shares_ The amount of shares to mint.\\r\\n     *  @return assets_ The amount of assets that would be deposited.\\r\\n     */\\r\\n    function previewMint(uint256 shares_) external view returns (uint256 assets_);\\r\\n\\r\\n    /**\\r\\n     *  @dev    Allows an on-chain or off-chain user to simulate the effects of their redemption at the current block, given current on-chain conditions.\\r\\n     *          MUST return as close to and no more than the exact amount of assets that would be withdrawn in a\u00a0`redeem`\u00a0call in the same transaction.\\r\\n     *          MUST NOT account for redemption limits like those returned from `maxRedeem` and should always act as though the redemption would be accepted.\\r\\n     *          MUST NOT revert.\\r\\n     *  @param  shares_ The amount of shares to redeem.\\r\\n     *  @return assets_ The amount of assets that would be withdrawn.\\r\\n     */\\r\\n    function previewRedeem(uint256 shares_) external view returns (uint256 assets_);\\r\\n\\r\\n    /**\\r\\n     *  @dev    Allows an on-chain or off-chain user to simulate the effects of their withdrawal at the current block, given current on-chain conditions.\\r\\n     *          MUST return as close to and no fewer than the exact amount of shares that would be burned in a\u00a0`withdraw`\u00a0call in the same transaction.\\r\\n     *          MUST NOT account for withdrawal limits like those returned from `maxWithdraw` and should always act as though the withdrawal would be accepted.\\r\\n     *          MUST NOT revert.\\r\\n     *  @param  assets_ The amount of assets to withdraw.\\r\\n     *  @return shares_ The amount of shares that would be redeemed.\\r\\n     */\\r\\n    function previewWithdraw(uint256 assets_) external view returns (uint256 shares_);\\r\\n\\r\\n    /**\\r\\n     *  @dev    Total amount of the underlying asset that is managed by the Vault.\\r\\n     *          SHOULD include compounding that occurs from any yields.\\r\\n     *          MUST NOT revert.\\r\\n     *  @return totalAssets_ The total amount of assets the Vault manages.\\r\\n     */\\r\\n    function totalAssets() external view returns (uint256 totalAssets_);\\r\\n\\r\\n}\"\r\n    },\r\n    \"contracts/interfaces/IRevenueDistributionToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\r\\npragma solidity 0.8.18;\\r\\n\\r\\nimport { IERC20 } from \\\"./IERC20.sol\\\";\\r\\n\\r\\nimport { IERC4626 } from \\\"./IERC4626.sol\\\";\\r\\n\\r\\n/// @title A token that represents ownership of future revenues distributed linearly over time.\\r\\ninterface IRevenueDistributionToken is IERC20, IERC4626 {\\r\\n\\r\\n    /**************/\\r\\n    /*** Events ***/\\r\\n    /**************/\\r\\n\\r\\n    /**\\r\\n     *  @dev   Issuance parameters have been updated after a `_mint` or `_burn`.\\r\\n     *  @param freeAssets_   Resulting `freeAssets` (y-intercept) value after accounting update.\\r\\n     *  @param issuanceRate_ The new issuance rate of `asset` until `vestingPeriodFinish_`.\\r\\n     */\\r\\n    event IssuanceParamsUpdated(uint256 freeAssets_, uint256 issuanceRate_);\\r\\n\\r\\n    /**\\r\\n     *  @dev   `newOwner_` has accepted the transferral of RDT ownership from `previousOwner_`.\\r\\n     *  @param previousOwner_ The previous RDT owner.\\r\\n     *  @param newOwner_      The new RDT owner.\\r\\n     */\\r\\n    event OwnershipAccepted(address indexed previousOwner_, address indexed newOwner_);\\r\\n\\r\\n    /**\\r\\n     *  @dev   `owner_` has set the new pending owner of RDT to `pendingOwner_`.\\r\\n     *  @param owner_        The current RDT owner.\\r\\n     *  @param pendingOwner_ The new pending RDT owner.\\r\\n     */\\r\\n    event PendingOwnerSet(address indexed owner_, address indexed pendingOwner_);\\r\\n\\r\\n    /**\\r\\n     *  @dev   `owner_` has updated the RDT vesting schedule to end at `vestingPeriodFinish_`.\\r\\n     *  @param owner_               The current RDT owner.\\r\\n     *  @param vestingPeriodFinish_ When the unvested balance will finish vesting.\\r\\n     */\\r\\n    event VestingScheduleUpdated(address indexed owner_, uint256 vestingPeriodFinish_);\\r\\n\\r\\n    /***********************/\\r\\n    /*** State Variables ***/\\r\\n    /***********************/\\r\\n\\r\\n    /**\\r\\n     *  @dev The total amount of the underlying asset that is currently unlocked and is not time-dependent.\\r\\n     *       Analogous to the y-intercept in a linear function.\\r\\n     */\\r\\n    function freeAssets() external view returns (uint256 freeAssets_);\\r\\n\\r\\n    /**\\r\\n     *  @dev The rate of issuance of the vesting schedule that is currently active.\\r\\n     *       Denominated as the amount of underlying assets vesting per second.\\r\\n     */\\r\\n    function issuanceRate() external view returns (uint256 issuanceRate_);\\r\\n\\r\\n    /**\\r\\n     *  @dev The timestamp of when the linear function was last recalculated.\\r\\n     *       Analogous to t0 in a linear function.\\r\\n     */\\r\\n    function lastUpdated() external view returns (uint256 lastUpdated_);\\r\\n\\r\\n    /**\\r\\n     *  @dev The address of the account that is allowed to update the vesting schedule.\\r\\n     */\\r\\n    function owner() external view returns (address owner_);\\r\\n\\r\\n    /**\\r\\n     *  @dev The next owner, nominated by the current owner.\\r\\n     */\\r\\n    function pendingOwner() external view returns (address pendingOwner_);\\r\\n\\r\\n    /**\\r\\n     *  @dev The precision at which the issuance rate is measured.\\r\\n     */\\r\\n    function precision() external view returns (uint256 precision_);\\r\\n\\r\\n    /**\\r\\n     *  @dev The end of the current vesting schedule.\\r\\n     */\\r\\n    function vestingPeriodFinish() external view returns (uint256 vestingPeriodFinish_);\\r\\n\\r\\n    /********************************/\\r\\n    /*** Administrative Functions ***/\\r\\n    /********************************/\\r\\n\\r\\n    /**\\r\\n     *  @dev Sets the pending owner as the new owner.\\r\\n     *       Can be called only by the pending owner, and only after their nomination by the current owner.\\r\\n     */\\r\\n    function acceptOwnership() external;\\r\\n\\r\\n    /**\\r\\n     *  @dev   Sets a new address as the pending owner.\\r\\n     *  @param pendingOwner_ The address of the next potential owner.\\r\\n     */\\r\\n    function setPendingOwner(address pendingOwner_) external;\\r\\n\\r\\n    /**\\r\\n     *  @dev    Updates the current vesting formula based on the amount of total unvested funds in the contract and the new `vestingPeriod_`.\\r\\n     *  @param  vestingPeriod_ The amount of time over which all currently unaccounted underlying assets will be vested over.\\r\\n     *  @return issuanceRate_  The new issuance rate.\\r\\n     *  @return freeAssets_    The new amount of underlying assets that are unlocked.\\r\\n     */\\r\\n    function updateVestingSchedule(uint256 vestingPeriod_) external returns (uint256 issuanceRate_, uint256 freeAssets_);\\r\\n\\r\\n    /************************/\\r\\n    /*** Staker Functions ***/\\r\\n    /************************/\\r\\n\\r\\n    /**\\r\\n     *  @dev    Does a ERC4626 `deposit` with a ERC-2612 `permit`.\\r\\n     *  @param  assets_   The amount of `asset` to deposit.\\r\\n     *  @param  receiver_ The receiver of the shares.\\r\\n     *  @param  deadline_ The timestamp after which the `permit` signature is no longer valid.\\r\\n     *  @param  v_        ECDSA signature v component.\\r\\n     *  @param  r_        ECDSA signature r component.\\r\\n     *  @param  s_        ECDSA signature s component.\\r\\n     *  @return shares_   The amount of shares minted.\\r\\n     */\\r\\n    function depositWithPermit(uint256 assets_, address receiver_, uint256 deadline_, uint8 v_, bytes32 r_, bytes32 s_) external returns (uint256 shares_);\\r\\n\\r\\n    /**\\r\\n     *  @dev    Does a ERC4626 `mint` with a ERC-2612 `permit`.\\r\\n     *  @param  shares_    The amount of `shares` to mint.\\r\\n     *  @param  receiver_  The receiver of the shares.\\r\\n     *  @param  maxAssets_ The maximum amount of assets that can be taken, as per the permit.\\r\\n     *  @param  deadline_  The timestamp after which the `permit` signature is no longer valid.\\r\\n     *  @param  v_         ECDSA signature v component.\\r\\n     *  @param  r_         ECDSA signature r component.\\r\\n     *  @param  s_         ECDSA signature s component.\\r\\n     *  @return assets_    The amount of shares deposited.\\r\\n     */\\r\\n    function mintWithPermit(uint256 shares_, address receiver_, uint256 maxAssets_, uint256 deadline_, uint8 v_, bytes32 r_, bytes32 s_) external returns (uint256 assets_);\\r\\n\\r\\n\\r\\n    /**********************/\\r\\n    /*** View Functions ***/\\r\\n    /**********************/\\r\\n\\r\\n    /**\\r\\n     *  @dev    Returns the amount of underlying assets owned by the specified account.\\r\\n     *  @param  account_ Address of the account.\\r\\n     *  @return assets_  Amount of assets owned.\\r\\n     */\\r\\n    function balanceOfAssets(address account_) external view returns (uint256 assets_);\\r\\n\\r\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_liquidityShare\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_crocShare\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_crocVault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_croc\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_crocLp\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_lpVault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_uniswapRouter\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_vestingPeriod\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_threshold\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethForCroc\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethForLiq\",\"type\":\"uint256\"}],\"name\":\"Distribution\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"}],\"name\":\"acceptVaultOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"creator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"croc\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"crocLp\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"crocShare\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"crocVault\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distributionThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distributionTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newThreshold\",\"type\":\"uint256\"}],\"name\":\"editDistributionThreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_crocShare\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_liquidityShare\",\"type\":\"uint256\"}],\"name\":\"editShares\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_vestingPeriod\",\"type\":\"uint256\"}],\"name\":\"editVesting\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emergencyWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityShare\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lpVault\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"}],\"name\":\"setVaultPendingOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalAccumulated\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapRouter\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newTime\",\"type\":\"uint256\"}],\"name\":\"updateDistributionTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vestingPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Redistributor", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "00000000000000000000000000000000000000000000000000000000000000210000000000000000000000000000000000000000000000000000000000000043000000000000000000000000427e25f2b424acece4bd84373c6dc82d053e4b3f000000000000000000000000caa79bf8b1d00bf3d4f6dbec6221955871c046180000000000000000000000006b268960693359f8c64e043d72ce7580867521b20000000000000000000000005b8432fc269b818c86a586f5658921dc43c6106b0000000000000000000000007a250d5630b4cf539739df2c5dacb4c659f2488d000000000000000000000000000000000000000000000000000000000002a3000000000000000000000000000000000000000000000000000de0b6b3a7640000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}