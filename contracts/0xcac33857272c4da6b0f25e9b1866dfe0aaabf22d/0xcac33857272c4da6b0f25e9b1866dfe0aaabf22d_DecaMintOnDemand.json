{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Returns true if the reentrancy guard is currently set to \\\"entered\\\", which indicates there is a\\n     * `nonReentrant` function in the call stack.\\n     */\\n    function _reentrancyGuardEntered() internal view returns (bool) {\\n        return _status == _ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/deca-collections/DecaMintOnDemand.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.17;\\n\\nimport {ReentrancyGuard} from \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\n\\nimport {ISettlementValidator} from \\\"../interfaces/internal/ISettlementValidator.sol\\\";\\n\\nimport {IDecaCollectionFactory} from \\\"../interfaces/internal/IDecaCollectionFactory.sol\\\";\\nimport {IDecaCollection} from \\\"../interfaces/internal/IDecaCollection.sol\\\";\\nimport {IDecaMintOnDemand} from \\\"../interfaces/internal/IDecaMintOnDemand.sol\\\";\\n\\nimport {MintStructs} from \\\"./libraries/MintStructs.sol\\\";\\n\\n/**\\n * @notice Allows a creator to mint an NFT to a bidder, without having to pay gas.\\n * @dev Utilises EIP712 off-chain signatures to grant a bidder permission to mint a specific token id,\\n *      which corresponds to an off-chain upload on Deca.\\n * @author 0x-jj, j6i\\n */\\ncontract DecaMintOnDemand is ReentrancyGuard, IDecaMintOnDemand {\\n  /*//////////////////////////////////////////////////////////////\\n                              STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n  /**\\n   * @notice Deca collection factory contract to create collections.\\n   */\\n  IDecaCollectionFactory public immutable factory;\\n\\n  /**\\n   * @notice SettlementValidator contract to validate off-chain signatures.\\n   */\\n  ISettlementValidator public immutable settlementValidator;\\n\\n  /*//////////////////////////////////////////////////////////////\\n                              CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n  constructor(address _factory, address _settlementValidator) {\\n    factory = IDecaCollectionFactory(_factory);\\n    settlementValidator = ISettlementValidator(_settlementValidator);\\n  }\\n\\n  /*//////////////////////////////////////////////////////////////\\n                                 EXTERNAL\\n    //////////////////////////////////////////////////////////////*/\\n\\n  /**\\n   * @notice Creates a new collection via the factory, validates and executes the settlement. If successful, mints the NFT to the bidder.\\n   *         and sends the creator the Ether.\\n   * @param settlement Contains all the info required to validate and execute settlement on chain.\\n   * @param collectionInfo CollectionInfo struct.\\n   * @param collectionInfoSignature Signature to verify against collection info\\n   */\\n  function createCollectionAndSettleBid(\\n    MintStructs.Settlement calldata settlement,\\n    MintStructs.CollectionInfo calldata collectionInfo,\\n    bytes calldata collectionInfoSignature\\n  ) external payable {\\n    settlementValidator.validateCollectionInfo(collectionInfo, collectionInfoSignature);\\n\\n    address collection = factory.createDecaCollection(\\n      IDecaCollectionFactory.CreateDecaCollectionParams({\\n        creator: settlement.acceptanceInfo.creatorAddress,\\n        nonce: collectionInfo.nonce,\\n        recipients: collectionInfo.royaltyRecipients,\\n        collectionName: collectionInfo.collectionName,\\n        collectionSymbol: collectionInfo.collectionSymbol\\n      })\\n    );\\n\\n    if (collection != settlement.acceptanceInfo.collectionAddress) {\\n      revert CollectionMismatch();\\n    }\\n\\n    settleBid(settlement);\\n  }\\n\\n  /*//////////////////////////////////////////////////////////////\\n                                 PUBLIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n  /**\\n   * @notice Validates and executes a settlement. If successful, mints the NFT to the bidder.\\n   *         and sends the creator the Ether.\\n   * @param settlement Contains all the info required to validate and execute settlement on chain.\\n   */\\n  function settleBid(MintStructs.Settlement calldata settlement) public payable nonReentrant {\\n    // Validate bid and acceptance criteria and signatures\\n    bytes32 bidHash = settlementValidator.validateSettlement(settlement, msg.value, msg.sender);\\n\\n    emit BidSettled(\\n      settlement.acceptanceInfo.collectionAddress,\\n      settlement.bidInfo.bidderAddress,\\n      settlement.acceptanceInfo.creatorAddress,\\n      settlement.acceptanceInfo.payslips,\\n      bidHash,\\n      settlement.bidInfo.tokenId,\\n      settlement.bidInfo.priceInWei\\n    );\\n\\n    // Mint NFT to bidder address\\n    IDecaCollection(settlement.acceptanceInfo.collectionAddress).mint(\\n      settlement.bidInfo.bidderAddress,\\n      settlement.bidInfo.tokenId\\n    );\\n\\n    // Transfer ETH to payees\\n    uint256 totalPayout = 0;\\n\\n    for (uint256 i = 0; i < settlement.acceptanceInfo.payslips.length; ) {\\n      MintStructs.Payslip memory payslip = settlement.acceptanceInfo.payslips[i];\\n      totalPayout += payslip.amountInWei;\\n      (bool paymentSuccessful, ) = payslip.recipient.call{value: payslip.amountInWei}(\\\"\\\");\\n      if (!paymentSuccessful) {\\n        revert TransferFailed();\\n      }\\n      unchecked {\\n        i++;\\n      }\\n    }\\n\\n    // Ensure payouts are correct\\n    if (totalPayout != settlement.bidInfo.priceInWei) {\\n      revert PayoutMismatch();\\n    }\\n\\n    uint256 excess = msg.value - settlement.bidInfo.priceInWei;\\n\\n    if (excess > 0) {\\n      (bool excessReturned, ) = settlement.bidInfo.bidderAddress.call{value: excess}(\\\"\\\");\\n      if (!excessReturned) {\\n        revert TransferFailed();\\n      }\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/deca-collections/libraries/MintStructs.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport {Recipient} from \\\"../../interfaces/internal/IDecaCollection.sol\\\";\\n\\n/**\\n * @title MintStructs\\n */\\nlibrary MintStructs {\\n  /**\\n   * @notice BidInfo is the struct that provides info about a bid on a Deca Collection item.\\n   * @dev Token ids are globally unique across all DecaCollections. Contract address is not part of the bid\\n   *      struct so that creators can move a token's collection before minting it, after receiving a bid\\n   * @param nonce Global user order nonce for maker orders\\n   * @param tokenId Id of the token to mint\\n   * @param expiresAt Timestamp bid expires at\\n   * @param priceInWei Bid price in wei\\n   * @param bidderAddress Maker address\\n   */\\n  struct BidInfo {\\n    uint256 nonce;\\n    uint256 tokenId;\\n    uint256 expiresAt;\\n    uint256 priceInWei;\\n    address bidderAddress;\\n  }\\n\\n  /**\\n   * @notice Payslip is the struct for a payout on settlement.\\n   * @dev Payslips are paid out in order, if there is not enough balance to pay out the next payslip, the settlement fails.\\n   * @param amountInWei Amount to pay out in wei\\n   * @param recipient Address to pay out to\\n   */\\n  struct Payslip {\\n    uint256 amountInWei;\\n    address recipient;\\n  }\\n\\n  /**\\n   * @notice AcceptanceInfo is the struct for a taker ask/bid order. It contains the parameters required for a direct purchase.\\n   * @dev AcceptanceInfo struct is matched against a BidInfo struct at the protocol level during settlement.\\n   * @param nonce Nonce to ensure acceptance signature is not re-used\\n   * @param bidSignatureHash BidInfo hash signed by taker\\n   * @param creatorAddress Address of the creator accepting the bid\\n   * @param collectionAddress Address to mint the token on\\n   * @param payslips Array of payslips to be paid out on settlement\\n   */\\n  struct AcceptanceInfo {\\n    uint256 nonce;\\n    bytes32 bidSignatureHash;\\n    address creatorAddress;\\n    address collectionAddress;\\n    Payslip[] payslips;\\n  }\\n\\n  /**\\n   * @notice To enable gasless cancellation of bids, we provide a fast expiring signature that is required during settlement and acts as an off-chain mint pass.\\n   *        If a user tells Deca they want to cancel their bid, we mark it as cancelled internally and refuse to provide a signature for settlement.\\n   *        In case a user wants to cancel their bid without going through Deca in case the expiry time isn't short enough, they can do so on chain.\\n   * @dev bidSignatureHash and acceptanceSignature hashes act as nonces, if either has already been used settlement fails.\\n   * @param expiresAt Timestamp signature expires at\\n   * @param bidSignatureHash BidInfo is the struct that provides info about a bid on a Deca Collection item.\\n   * @param acceptanceSignatureHash AcceptanceInfo struct is matched against a BidInfo struct at the protocol level during settlement.\\n   * @param signer Address owned by Deca used to sign the message\\n   */\\n  struct MintPass {\\n    uint256 expiresAt;\\n    bytes32 bidSignatureHash;\\n    bytes32 acceptanceSignatureHash;\\n    address signer;\\n  }\\n\\n  /**\\n   * @notice A summary of the settlement data required to mint on demand.\\n   * @param bidSignature Signature for the bid info\\n   * @param acceptanceSignature Signature for the acceptance info\\n   * @param mintPassSignature Signature for the mint pass\\n   * @param bidInfo BidInfo struct, signed by bidder\\n   * @param acceptanceInfo AcceptanceInfo struct, signed by creator\\n   * @param mintPass MintPass struct, signed by Deca\\n   */\\n  struct Settlement {\\n    bytes bidSignature;\\n    bytes acceptanceSignature;\\n    bytes mintPassSignature;\\n    BidInfo bidInfo;\\n    AcceptanceInfo acceptanceInfo;\\n    MintPass mintPass;\\n  }\\n\\n  /**\\n   * @notice CollectionInfo is the struct that provides info about a collection being created.\\n   * @param signer Address owned by Deca used to sign the message\\n   * @param nonce Nonce for the collection, used to generate the collection address\\n   * @param collectionName Name of the collection being created\\n   * @param collectionSymbol Symbol of the collection being created\\n   * @param royaltyRecipients Array of secondary market royalty recipients\\n   */\\n  struct CollectionInfo {\\n    address signer;\\n    uint96 nonce;\\n    string collectionName;\\n    string collectionSymbol;\\n    Recipient[] royaltyRecipients;\\n  }\\n\\n  /**\\n   * @notice This is the type hash constant used to compute the maker order hash.\\n   */\\n  bytes32 internal constant _BIDINFO_TYPEHASH =\\n    keccak256(\\n      \\\"BidInfo(\\\"\\n      \\\"uint256 nonce,\\\"\\n      \\\"uint256 tokenId,\\\"\\n      \\\"address bidderAddress,\\\"\\n      \\\"uint256 expiresAt,\\\"\\n      \\\"uint256 priceInWei\\\"\\n      \\\")\\\"\\n    );\\n\\n  /**\\n   * @dev This is the type hash constant used to compute the taker order hash.\\n   */\\n  bytes32 internal constant _ACCEPTANCEINFO_TYPEHASH =\\n    keccak256(\\n      \\\"AcceptanceInfo(\\\"\\n      \\\"uint256 nonce,\\\"\\n      \\\"address creatorAddress,\\\"\\n      \\\"address collectionAddress,\\\"\\n      \\\"bytes32 bidSignatureHash,\\\"\\n      \\\"Payslip[] payslips\\\"\\n      \\\")\\\"\\n      \\\"Payslip(address recipient,uint256 amountInWei)\\\"\\n    );\\n\\n  /**\\n   * @dev This is the type hash constant used to compute the payslip hash.\\n   */\\n  bytes32 internal constant _PAYSLIP_TYPEHASH =\\n    keccak256(\\n      \\\"Payslip(\\\"\\n      \\\"address recipient,\\\"\\n      \\\"uint256 amountInWei\\\"\\n      \\\")\\\"\\n    );\\n\\n  /**\\n   * @dev This is the type hash constant used to compute the mint pass hash.\\n   */\\n  bytes32 internal constant _MINTPASS_TYPEHASH =\\n    keccak256(\\n      \\\"MintPass(\\\"\\n      \\\"address signer,\\\"\\n      \\\"uint256 expiresAt,\\\"\\n      \\\"bytes32 bidSignatureHash,\\\"\\n      \\\"bytes32 acceptanceSignatureHash\\\"\\n      \\\")\\\"\\n    );\\n\\n  /**\\n   * @dev This is the type hash constant used to compute the collection info hash.\\n   */\\n  bytes32 internal constant _COLLECTIONINFO_TYPEHASH =\\n    keccak256(\\n      \\\"CollectionInfo(\\\"\\n      \\\"string collectionName,\\\"\\n      \\\"string collectionSymbol,\\\"\\n      \\\"uint96 nonce,\\\"\\n      \\\"address signer,\\\"\\n      \\\"Recipient[] royaltyRecipients\\\"\\n      \\\")\\\"\\n      \\\"Recipient(address recipient,uint16 bps)\\\"\\n    );\\n\\n  /**\\n   * @dev This is the type hash constant used to compute the recipient hash.\\n   */\\n  bytes32 internal constant _RECIPIENT_TYPEHASH =\\n    keccak256(\\n      \\\"Recipient(\\\"\\n      \\\"address recipient,\\\"\\n      \\\"uint16 bps\\\"\\n      \\\")\\\"\\n    );\\n\\n  /**\\n   * @notice This function is used to compute the EIP712 hash for a BidInfo struct.\\n   * @param bidInfo BidInfo struct\\n   * @return bidInfoHash Hash of the BidInfo struct\\n   */\\n  function hash(BidInfo memory bidInfo) internal pure returns (bytes32) {\\n    return\\n      keccak256(\\n        abi.encode(\\n          _BIDINFO_TYPEHASH,\\n          bidInfo.nonce,\\n          bidInfo.tokenId,\\n          bidInfo.bidderAddress,\\n          bidInfo.expiresAt,\\n          bidInfo.priceInWei\\n        )\\n      );\\n  }\\n\\n  /**\\n   * @notice This function is used to compute the EIP712 hash for an AcceptanceInfo struct.\\n   * @param acceptanceInfo AcceptanceInfo struct\\n   * @return acceptanceInfoHash Hash of the AcceptanceInfo struct\\n   */\\n  function hash(AcceptanceInfo memory acceptanceInfo) internal pure returns (bytes32) {\\n    return\\n      keccak256(\\n        abi.encode(\\n          _ACCEPTANCEINFO_TYPEHASH,\\n          acceptanceInfo.nonce,\\n          acceptanceInfo.creatorAddress,\\n          acceptanceInfo.collectionAddress,\\n          acceptanceInfo.bidSignatureHash,\\n          _encodePayslips(acceptanceInfo.payslips)\\n        )\\n      );\\n  }\\n\\n  /**\\n   * @notice This function is used to compute the EIP712 hash for a Payslip struct.\\n   * @param payslip Payslip struct\\n   * @return payslipHash Hash of the Payslip struct\\n   */\\n  function _encodePayslip(Payslip memory payslip) internal pure returns (bytes32) {\\n    return keccak256(abi.encode(_PAYSLIP_TYPEHASH, payslip.recipient, payslip.amountInWei));\\n  }\\n\\n  /**\\n   * @notice This function is used to compute the EIP712 hash for an array of Payslip structs.\\n   * @param payslips Array of Payslip structs\\n   * @return payslipsHash Hash of the Payslip structs\\n   */\\n  function _encodePayslips(Payslip[] memory payslips) internal pure returns (bytes32) {\\n    bytes32[] memory encodedPayslips = new bytes32[](payslips.length);\\n    for (uint256 i = 0; i < payslips.length; i++) {\\n      encodedPayslips[i] = _encodePayslip(payslips[i]);\\n    }\\n\\n    return keccak256(abi.encodePacked(encodedPayslips));\\n  }\\n\\n  /**\\n   * @notice This function is used to compute the EIP712 hash for a MintPass struct.\\n   * @param mintPass MintPass struct\\n   * @return mintPassHash Hash of the MintPass struct\\n   */\\n  function hash(MintPass memory mintPass) internal pure returns (bytes32) {\\n    return\\n      keccak256(\\n        abi.encode(\\n          _MINTPASS_TYPEHASH,\\n          mintPass.signer,\\n          mintPass.expiresAt,\\n          mintPass.bidSignatureHash,\\n          mintPass.acceptanceSignatureHash\\n        )\\n      );\\n  }\\n\\n  /**\\n   * @notice This function is used to compute the EIP712 hash for a CollectionInfo struct.\\n   * @param collectionInfo CollectionInfo struct\\n   * @return collectionInfoHash Hash of the CollectionInfo struct\\n   */\\n  function hash(CollectionInfo memory collectionInfo) internal pure returns (bytes32) {\\n    return\\n      keccak256(\\n        abi.encode(\\n          _COLLECTIONINFO_TYPEHASH,\\n          keccak256(bytes(collectionInfo.collectionName)),\\n          keccak256(bytes(collectionInfo.collectionSymbol)),\\n          collectionInfo.nonce,\\n          collectionInfo.signer,\\n          _encodeRecipients(collectionInfo.royaltyRecipients)\\n        )\\n      );\\n  }\\n\\n  /**\\n   * @notice This function is used to compute the EIP712 hash for a Recipient struct.\\n   * @param recipient Recipient struct\\n   * @return recipientHash Hash of the Recipient struct\\n   */\\n  function _encodeRecipient(Recipient memory recipient) internal pure returns (bytes32) {\\n    return keccak256(abi.encode(_RECIPIENT_TYPEHASH, recipient.recipient, recipient.bps));\\n  }\\n\\n  /**\\n   * @notice This function is used to compute the EIP712 hash for an array of Recipient structs.\\n   * @param recipients Array of Recipient structs\\n   * @return recipientsHash Hash of the Recipient structs\\n   */\\n  function _encodeRecipients(Recipient[] memory recipients) internal pure returns (bytes32) {\\n    bytes32[] memory encodedRecipients = new bytes32[](recipients.length);\\n    for (uint256 i = 0; i < recipients.length; i++) {\\n      encodedRecipients[i] = _encodeRecipient(recipients[i]);\\n    }\\n\\n    return keccak256(abi.encodePacked(encodedRecipients));\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/internal/IDecaCollection.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.17;\\n\\nstruct Recipient {\\n  address payable recipient;\\n  uint16 bps;\\n}\\n\\ninterface IDecaCollection {\\n  error InvalidTokenId();\\n  error OnlyCreator();\\n  error OnlyMinterOrCreator();\\n  error NotTokenOwnerOrApproved();\\n  error ERC20SplitFailed();\\n  error TotalBpsMustBe10000();\\n  error EthTransferFailed();\\n\\n  /**\\n   * @notice Emitted when ETH is transferred.\\n   * @param account The address of the account which received the ETH.\\n   * @param amount The amount of ETH transferred.\\n   */\\n  event ETHTransferred(address indexed account, uint256 amount);\\n\\n  /**\\n   * @notice Emitted when an ERC20 token is transferred.\\n   * @param erc20Contract The address of the ERC20 contract.\\n   * @param account The address of the account which received the ERC20.\\n   * @param amount The amount of ERC20 transferred.\\n   */\\n  event ERC20Transferred(address indexed erc20Contract, address indexed account, uint256 amount);\\n\\n  /**\\n   * @notice Emitted when the token URI is set on a token.\\n   * @param tokenId The id of the token.\\n   * @param tokenURI The token URI of the token.\\n   */\\n  event TokenUriSet(uint256 indexed tokenId, string tokenURI);\\n\\n  /**\\n   * @notice Emitted when the treasury address is updated.\\n   * @param treasury The address of the new treasury.\\n   */\\n  event TreasuryUpdated(address indexed treasury);\\n\\n  /**\\n   * @notice Emitted when the royalty bps is updated.\\n   * @param royaltyBps The royalty bps.\\n   */\\n  event RoyaltyBpsUpdated(uint256 royaltyBps);\\n\\n  function initialize(\\n    address factory_,\\n    address creator_,\\n    address roleAuthority_,\\n    string calldata name_,\\n    string calldata symbol_,\\n    Recipient[] calldata recipients\\n  ) external;\\n\\n  function creator() external view returns (address);\\n\\n  function exists(uint256 tokenId) external view returns (bool);\\n\\n  function mint(address to, uint256 tokenId) external;\\n\\n  function burn(uint256 tokenId) external;\\n\\n  function mintTimestamps(uint256 tokenId) external view returns (uint256);\\n\\n  function setRecipients(Recipient[] calldata recipients) external;\\n\\n  function setTreasuryAddress(address treasury_) external;\\n\\n  function setRoyaltyBps(uint256 royaltyBps_) external;\\n\\n  function getRecipients() external view returns (Recipient[] memory);\\n\\n  function royaltyInfo(uint256, uint256 _salePrice) external view returns (address receiver, uint256 royaltyAmount);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/internal/IDecaCollectionFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.17;\\n\\nimport {Recipient} from \\\"./IDecaCollection.sol\\\";\\n\\ninterface IDecaCollectionFactory {\\n  error CreatorCannotBeTheZeroAddress();\\n  error OnlyCreator();\\n  error OnlyMinter();\\n  error InterfaceUnsupported();\\n\\n  /**\\n   * @notice Emitted when a new DecaCollection is created from this factory.\\n   * @param collection The address of the new NFT collection contract.\\n   * @param creator The address of the creator which owns the new collection.\\n   * @param collectionName The name of the collection.\\n   */\\n  event DecaCollectionCreated(address indexed collection, address indexed creator, string collectionName);\\n\\n  /**\\n   * @notice Emitted when the metadata resolver is updated.\\n   * @param metadataResolver The address of the new metadata resolver.\\n   */\\n  event MetadataResolverUpdated(address indexed metadataResolver);\\n\\n  /**\\n   * @notice Emitted when the implementation of DecaCollection is updated.\\n   * @param decaCollectionImplementation The address of the new implementation.\\n   * @param newVersion The new version of the implementation.\\n   */\\n  event DecaCollectionImplementationUpdated(address decaCollectionImplementation, uint256 newVersion);\\n\\n  struct CreateDecaCollectionParams {\\n    address creator;\\n    uint96 nonce;\\n    Recipient[] recipients;\\n    string collectionName;\\n    string collectionSymbol;\\n  }\\n\\n  function createDecaCollection(CreateDecaCollectionParams memory params) external returns (address);\\n\\n  function tokenUri(address contractAddress, uint256 tokenId) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/internal/IDecaMintOnDemand.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.17;\\n\\nimport {MintStructs} from \\\"../../deca-collections/libraries/MintStructs.sol\\\";\\n\\ninterface IDecaMintOnDemand {\\n  error TransferFailed();\\n  error CollectionMismatch();\\n  error PayoutMismatch();\\n\\n  /**\\n   * @notice Creates a new collection via the factory, validates and executes the settlement. If successful, mints the NFT to the bidder.\\n   * @param collection Collection address.\\n   * @param bidder Bidder address.\\n   * @param creator Creator address.\\n   * @param payslips Payslips array.\\n   * @param bidId Bid id.\\n   * @param tokenId Token id.\\n   * @param price Price of the bid.\\n   */\\n  event BidSettled(\\n    address indexed collection,\\n    address indexed bidder,\\n    address indexed creator,\\n    MintStructs.Payslip[] payslips,\\n    bytes32 bidId,\\n    uint256 tokenId,\\n    uint256 price\\n  );\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/internal/ISettlementValidator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.17;\\n\\nimport {MintStructs} from \\\"../../deca-collections/libraries/MintStructs.sol\\\";\\n\\ninterface ISettlementValidator {\\n  error ChainIdInvalid();\\n  error SignatureRepeated();\\n  error BidSignatureMismatch();\\n  error AcceptanceSignatureMismatch();\\n  error BidExpired();\\n  error MintPassExpired();\\n  error UnauthorizedMintPassSigner();\\n  error UnauthorizedAcceptanceSigner();\\n  error MintPassSignatureInvalid();\\n  error BidSignatureInvalid();\\n  error AcceptanceSignatureInvalid();\\n  error NotAuthorized();\\n  error TokenAlreadyCreated();\\n  error BidPriceNotMet();\\n  error NonBidderSettle();\\n  error UnauthorizedCollectionInfoSigner();\\n  error CollectionInfoSignatureInvalid();\\n\\n  function usedBidInfoHashes(bytes32 _hash) external view returns (bool);\\n\\n  function usedAcceptanceInfoHashes(bytes32 _hash) external view returns (bool);\\n\\n  function invalidateBid(MintStructs.BidInfo calldata bidInfo) external;\\n\\n  function validateSettlement(\\n    MintStructs.Settlement calldata settlement,\\n    uint256 msgValue,\\n    address msgSender\\n  ) external returns (bytes32 hash);\\n\\n  function validateCollectionInfo(\\n    MintStructs.CollectionInfo calldata collectionInfo,\\n    bytes calldata signature\\n  ) external view;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 10000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_settlementValidator\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"CollectionMismatch\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PayoutMismatch\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferFailed\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"bidder\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amountInWei\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"indexed\":false,\"internalType\":\"struct MintStructs.Payslip[]\",\"name\":\"payslips\",\"type\":\"tuple[]\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"bidId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"BidSettled\",\"type\":\"event\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes\",\"name\":\"bidSignature\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"acceptanceSignature\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"mintPassSignature\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiresAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"priceInWei\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"bidderAddress\",\"type\":\"address\"}],\"internalType\":\"struct MintStructs.BidInfo\",\"name\":\"bidInfo\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"bidSignatureHash\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"creatorAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"collectionAddress\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amountInWei\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"internalType\":\"struct MintStructs.Payslip[]\",\"name\":\"payslips\",\"type\":\"tuple[]\"}],\"internalType\":\"struct MintStructs.AcceptanceInfo\",\"name\":\"acceptanceInfo\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"expiresAt\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"bidSignatureHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"acceptanceSignatureHash\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"}],\"internalType\":\"struct MintStructs.MintPass\",\"name\":\"mintPass\",\"type\":\"tuple\"}],\"internalType\":\"struct MintStructs.Settlement\",\"name\":\"settlement\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"nonce\",\"type\":\"uint96\"},{\"internalType\":\"string\",\"name\":\"collectionName\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"collectionSymbol\",\"type\":\"string\"},{\"components\":[{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"bps\",\"type\":\"uint16\"}],\"internalType\":\"struct Recipient[]\",\"name\":\"royaltyRecipients\",\"type\":\"tuple[]\"}],\"internalType\":\"struct MintStructs.CollectionInfo\",\"name\":\"collectionInfo\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"collectionInfoSignature\",\"type\":\"bytes\"}],\"name\":\"createCollectionAndSettleBid\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"contract IDecaCollectionFactory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes\",\"name\":\"bidSignature\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"acceptanceSignature\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"mintPassSignature\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiresAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"priceInWei\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"bidderAddress\",\"type\":\"address\"}],\"internalType\":\"struct MintStructs.BidInfo\",\"name\":\"bidInfo\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"bidSignatureHash\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"creatorAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"collectionAddress\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amountInWei\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"internalType\":\"struct MintStructs.Payslip[]\",\"name\":\"payslips\",\"type\":\"tuple[]\"}],\"internalType\":\"struct MintStructs.AcceptanceInfo\",\"name\":\"acceptanceInfo\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"expiresAt\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"bidSignatureHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"acceptanceSignatureHash\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"}],\"internalType\":\"struct MintStructs.MintPass\",\"name\":\"mintPass\",\"type\":\"tuple\"}],\"internalType\":\"struct MintStructs.Settlement\",\"name\":\"settlement\",\"type\":\"tuple\"}],\"name\":\"settleBid\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"settlementValidator\",\"outputs\":[{\"internalType\":\"contract ISettlementValidator\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "DecaMintOnDemand", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "10000", "ConstructorArguments": "0000000000000000000000004c150e046504d2eac76b147cb7fdd05858d84d7f000000000000000000000000b2972b886a2ee03db10e1b9190a870b79e453c8f", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}