{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/cryptography/MerkleProof.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev These functions deal with verification of Merkle trees (hash trees),\\n */\\nlibrary MerkleProof {\\n    /**\\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\\n     * defined by `root`. For this, a `proof` must be provided, containing\\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\\n     */\\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\\n        bytes32 computedHash = leaf;\\n\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            bytes32 proofElement = proof[i];\\n\\n            if (computedHash <= proofElement) {\\n                // Hash(current computed hash + current element of the proof)\\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\\n            } else {\\n                // Hash(current element of the proof + current computed hash)\\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\\n            }\\n        }\\n\\n        // Check if the computed hash (root) is equal to the provided root\\n        return computedHash == root;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\\"SafeERC20: decreased allowance below zero\\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) { // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2 <0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Counters.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../math/SafeMath.sol\\\";\\n\\n/**\\n * @title Counters\\n * @author Matt Condon (@shrugs)\\n * @dev Provides counters that can only be incremented or decremented by one. This can be used e.g. to track the number\\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\\n *\\n * Include with `using Counters for Counters.Counter;`\\n * Since it is not possible to overflow a 256 bit integer with increments of one, `increment` can skip the {SafeMath}\\n * overflow check, thereby saving gas. This does assume however correct usage, in that the underlying `_value` is never\\n * directly accessed.\\n */\\nlibrary Counters {\\n    using SafeMath for uint256;\\n\\n    struct Counter {\\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\\n        uint256 _value; // default: 0\\n    }\\n\\n    function current(Counter storage counter) internal view returns (uint256) {\\n        return counter._value;\\n    }\\n\\n    function increment(Counter storage counter) internal {\\n        // The {SafeMath} overflow check can be skipped here, see the comment at the top\\n        counter._value += 1;\\n    }\\n\\n    function decrement(Counter storage counter) internal {\\n        counter._value = counter._value.sub(1);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/SafeCast.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n *\\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\\n * all math on `uint256` and `int256` and then downcasting.\\n */\\nlibrary SafeCast {\\n\\n    /**\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity's `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        require(value < 2**128, \\\"SafeCast: value doesn\\\\'t fit in 128 bits\\\");\\n        return uint128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint64).\\n     *\\n     * Counterpart to Solidity's `uint64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     */\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        require(value < 2**64, \\\"SafeCast: value doesn\\\\'t fit in 64 bits\\\");\\n        return uint64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint32).\\n     *\\n     * Counterpart to Solidity's `uint32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     */\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\n        require(value < 2**32, \\\"SafeCast: value doesn\\\\'t fit in 32 bits\\\");\\n        return uint32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint16).\\n     *\\n     * Counterpart to Solidity's `uint16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     */\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\n        require(value < 2**16, \\\"SafeCast: value doesn\\\\'t fit in 16 bits\\\");\\n        return uint16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint8).\\n     *\\n     * Counterpart to Solidity's `uint8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits.\\n     */\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\n        require(value < 2**8, \\\"SafeCast: value doesn\\\\'t fit in 8 bits\\\");\\n        return uint8(value);\\n    }\\n\\n    /**\\n     * @dev Converts a signed int256 into an unsigned uint256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be greater than or equal to 0.\\n     */\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        require(value >= 0, \\\"SafeCast: value must be positive\\\");\\n        return uint256(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int128 from int256, reverting on\\n     * overflow (when the input is less than smallest int128 or\\n     * greater than largest int128).\\n     *\\n     * Counterpart to Solidity's `int128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt128(int256 value) internal pure returns (int128) {\\n        require(value >= -2**127 && value < 2**127, \\\"SafeCast: value doesn\\\\'t fit in 128 bits\\\");\\n        return int128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int64 from int256, reverting on\\n     * overflow (when the input is less than smallest int64 or\\n     * greater than largest int64).\\n     *\\n     * Counterpart to Solidity's `int64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt64(int256 value) internal pure returns (int64) {\\n        require(value >= -2**63 && value < 2**63, \\\"SafeCast: value doesn\\\\'t fit in 64 bits\\\");\\n        return int64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int32 from int256, reverting on\\n     * overflow (when the input is less than smallest int32 or\\n     * greater than largest int32).\\n     *\\n     * Counterpart to Solidity's `int32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt32(int256 value) internal pure returns (int32) {\\n        require(value >= -2**31 && value < 2**31, \\\"SafeCast: value doesn\\\\'t fit in 32 bits\\\");\\n        return int32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int16 from int256, reverting on\\n     * overflow (when the input is less than smallest int16 or\\n     * greater than largest int16).\\n     *\\n     * Counterpart to Solidity's `int16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt16(int256 value) internal pure returns (int16) {\\n        require(value >= -2**15 && value < 2**15, \\\"SafeCast: value doesn\\\\'t fit in 16 bits\\\");\\n        return int16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int8 from int256, reverting on\\n     * overflow (when the input is less than smallest int8 or\\n     * greater than largest int8).\\n     *\\n     * Counterpart to Solidity's `int8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt8(int256 value) internal pure returns (int8) {\\n        require(value >= -2**7 && value < 2**7, \\\"SafeCast: value doesn\\\\'t fit in 8 bits\\\");\\n        return int8(value);\\n    }\\n\\n    /**\\n     * @dev Converts an unsigned uint256 into a signed int256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be less than or equal to maxInt256.\\n     */\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        require(value < 2**255, \\\"SafeCast: value doesn't fit in an int256\\\");\\n        return int256(value);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/beanstalk/AppStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity =0.7.6;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../interfaces/IDiamondCut.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Counters.sol\\\";\\n\\n/**\\n * @title Account\\n * @author Publius\\n * @notice Stores Farmer-level Beanstalk state.\\n * @dev {Account.State} is the primary struct that is referenced from {Storage.State}. \\n * All other structs in {Account} are referenced in {Account.State}. Each unique\\n * Ethereum address is a Farmer.\\n */\\ncontract Account {\\n    /**\\n     * @notice Stores a Farmer's Plots and Pod allowances.\\n     * @param plots A Farmer's Plots. Maps from Plot index to Pod amount.\\n     * @param podAllowances An allowance mapping for Pods similar to that of the ERC-20 standard. Maps from spender address to allowance amount.\\n     */\\n    struct Field {\\n        mapping(uint256 => uint256) plots;\\n        mapping(address => uint256) podAllowances;\\n    }\\n\\n    /**\\n     * @notice Stores a Farmer's Deposits and Seeds per Deposit, and formerly stored Withdrawals.\\n     * @param withdrawals DEPRECATED: Silo V1 Withdrawals are no longer referenced.\\n     * @param deposits Unripe Bean/LP Deposits (previously Bean/LP Deposits).\\n     * @param depositSeeds BDV of Unripe LP Deposits / 4 (previously # of Seeds in corresponding LP Deposit).\\n     */\\n    struct AssetSilo {\\n        mapping(uint32 => uint256) withdrawals;\\n        mapping(uint32 => uint256) deposits;\\n        mapping(uint32 => uint256) depositSeeds;\\n    }\\n\\n    /**\\n     * @notice Represents a Deposit of a given Token in the Silo at a given Season.\\n     * @param amount The amount of Tokens in the Deposit.\\n     * @param bdv The Bean-denominated value of the total amount of Tokens in the Deposit.\\n     * @dev `amount` and `bdv` are packed as uint128 to save gas.\\n     */\\n    struct Deposit {\\n        uint128 amount; // \u2500\u2500\u2500\u2510 16\\n        uint128 bdv; // \u2500\u2500\u2500\u2500\u2500\u2500\u2518 16 (32/32)\\n    }\\n\\n    /**\\n     * @notice Stores a Farmer's Stalk and Seeds balances.\\n     * @param stalk Balance of the Farmer's Stalk.\\n     * @param seeds DEPRECATED \u2013 Balance of the Farmer's Seeds. Seeds are no longer referenced as of Silo V3.\\n     */\\n    struct Silo {\\n        uint256 stalk;\\n        uint256 seeds;\\n    }\\n\\n    /**\\n     * @notice This struct stores the mow status for each Silo-able token, for each farmer. \\n     * This gets updated each time a farmer mows, or adds/removes deposits.\\n     * @param lastStem The last cumulative grown stalk per bdv index at which the farmer mowed.\\n     * @param bdv The bdv of all of a farmer's deposits of this token type.\\n     * \\n     */\\n    struct MowStatus {\\n        int96 lastStem; // \u2500\u2500\u2500\u2510 12\\n        uint128 bdv; // \u2500\u2500\u2500\u2500\u2500\u2500\u2518 16 (28/32)\\n    }\\n\\n    /**\\n     * @notice Stores a Farmer's Season of Plenty (SOP) balances.\\n     * @param roots The number of Roots a Farmer had when it started Raining.\\n     * @param plentyPerRoot The global Plenty Per Root index at the last time a Farmer updated their Silo.\\n     * @param plenty The balance of a Farmer's plenty. Plenty can be claimed directly for 3CRV.\\n     */\\n    struct SeasonOfPlenty {\\n        uint256 roots;\\n        uint256 plentyPerRoot;\\n        uint256 plenty;\\n    }\\n    \\n    /**\\n     * @notice Defines the state object for a Farmer.\\n     * @param field A Farmer's Field storage.\\n     * @param bean A Farmer's Unripe Bean Deposits only as a result of Replant (previously held the V1 Silo Deposits/Withdrawals for Beans).\\n     * @param lp A Farmer's Unripe LP Deposits as a result of Replant of BEAN:ETH Uniswap v2 LP Tokens (previously held the V1 Silo Deposits/Withdrawals for BEAN:ETH Uniswap v2 LP Tokens).\\n     * @param s A Farmer's Silo storage.\\n     * @param deprecated_votedUntil DEPRECATED \u2013 Replant removed on-chain governance including the ability to vote on BIPs.\\n     * @param lastUpdate The Season in which the Farmer last updated their Silo.\\n     * @param lastSop The last Season that a SOP occured at the time the Farmer last updated their Silo.\\n     * @param lastRain The last Season that it started Raining at the time the Farmer last updated their Silo.\\n     * @param deprecated_lastSIs DEPRECATED \u2013 In Silo V1.2, the Silo reward mechanism was updated to no longer need to store the number of the Supply Increases at the time the Farmer last updated their Silo.\\n     * @param deprecated_proposedUntil DEPRECATED \u2013 Replant removed on-chain governance including the ability to propose BIPs.\\n     * @param deprecated_sop DEPRECATED \u2013 Replant reset the Season of Plenty mechanism\\n     * @param roots A Farmer's Root balance.\\n     * @param deprecated_wrappedBeans DEPRECATED \u2013 Replant generalized Internal Balances. Wrapped Beans are now stored at the AppStorage level.\\n     * @param deposits A Farmer's Silo Deposits stored as a map from Token address to Season of Deposit to Deposit.\\n     * @param withdrawals A Farmer's Withdrawals from the Silo stored as a map from Token address to Season the Withdrawal becomes Claimable to Withdrawn amount of Tokens.\\n     * @param sop A Farmer's Season of Plenty storage.\\n     * @param depositAllowances A mapping of `spender => Silo token address => amount`.\\n     * @param tokenAllowances Internal balance token allowances.\\n     * @param depositPermitNonces A Farmer's current deposit permit nonce\\n     * @param tokenPermitNonces A Farmer's current token permit nonce\\n     */\\n    struct State {\\n        Field field; // A Farmer's Field storage.\\n\\n        /*\\n         * @dev (Silo V1) A Farmer's Unripe Bean Deposits only as a result of Replant\\n         *\\n         * Previously held the V1 Silo Deposits/Withdrawals for Beans.\\n\\n         * NOTE: While the Silo V1 format is now deprecated, this storage slot is used for gas\\n         * efficiency to store Unripe BEAN deposits. See {LibUnripeSilo} for more.\\n         */\\n        AssetSilo bean; \\n\\n        /*\\n         * @dev (Silo V1) Unripe LP Deposits as a result of Replant.\\n         * \\n         * Previously held the V1 Silo Deposits/Withdrawals for BEAN:ETH Uniswap v2 LP Tokens.\\n         * \\n         * BEAN:3CRV and BEAN:LUSD tokens prior to Replant were stored in the Silo V2\\n         * format in the `s.a[account].legacyDeposits` mapping.\\n         *\\n         * NOTE: While the Silo V1 format is now deprecated, unmigrated Silo V1 deposits are still\\n         * stored in this storage slot. See {LibUnripeSilo} for more.\\n         * \\n         */\\n        AssetSilo lp; \\n\\n        /*\\n         * @dev Holds Silo specific state for each account.\\n         */\\n        Silo s;\\n        \\n        uint32 votedUntil; // DEPRECATED \u2013 Replant removed on-chain governance including the ability to vote on BIPs.\\n        uint32 lastUpdate; // The Season in which the Farmer last updated their Silo.\\n        uint32 lastSop; // The last Season that a SOP occured at the time the Farmer last updated their Silo.\\n        uint32 lastRain; // The last Season that it started Raining at the time the Farmer last updated their Silo.\\n        uint128 deltaRoots; // the number of roots to add, in the case where a farmer has mowed in the morning\\n        SeasonOfPlenty deprecated; // DEPRECATED \u2013 Replant reset the Season of Plenty mechanism\\n        uint256 roots; // A Farmer's Root balance.\\n        uint256 wrappedBeans; // DEPRECATED \u2013 Replant generalized Internal Balances. Wrapped Beans are now stored at the AppStorage level.\\n        mapping(address => mapping(uint32 => Deposit)) legacyDeposits; // Legacy Silo V2 Deposits stored as a map from Token address to Season of Deposit to Deposit. NOTE: While the Silo V2 format is now deprecated, unmigrated Silo V2 deposits are still stored in this mapping.\\n        mapping(address => mapping(uint32 => uint256)) withdrawals; // DEPRECATED - Zero withdraw eliminates a need for withdraw mapping\\n        SeasonOfPlenty sop; // A Farmer's Season Of Plenty storage.\\n        mapping(address => mapping(address => uint256)) depositAllowances; // Spender => Silo Token\\n        mapping(address => mapping(IERC20 => uint256)) tokenAllowances; // Token allowances\\n        uint256 depositPermitNonces; // A Farmer's current deposit permit nonce\\n        uint256 tokenPermitNonces; // A Farmer's current token permit nonce\\n        mapping(uint256 => Deposit) deposits; // SiloV3 Deposits stored as a map from uint256 to Deposit. This is an concat of the token address and the CGSPBDV for a ERC20 deposit, and a hash for an ERC721/1155 deposit.\\n        mapping(address => MowStatus) mowStatuses; // Store a MowStatus for each Whitelisted Silo token\\n        mapping(address => bool) isApprovedForAll; // ERC1155 isApprovedForAll mapping \\n    }\\n}\\n\\n/**\\n * @title Storage\\n * @author Publius\\n * @notice Stores system-level Beanstalk state.\\n */\\ncontract Storage {\\n    /**\\n     * @notice DEPRECATED: System-level contract addresses.\\n     * @dev After Replant, Beanstalk stores Token addresses as constants to save gas.\\n     */\\n    struct Contracts {\\n        address bean;\\n        address pair;\\n        address pegPair;\\n        address weth;\\n    }\\n\\n    /**\\n     * @notice System-level Field state variables.\\n     * @param soil The number of Soil currently available. Adjusted during {Sun.stepSun}.\\n     * @param beanSown The number of Bean sown within the current Season. Reset during {Weather.stepWeather}.\\n     * @param pods The pod index; the total number of Pods ever minted.\\n     * @param harvested The harvested index; the total number of Pods that have ever been Harvested.\\n     * @param harvestable The harvestable index; the total number of Pods that have ever been Harvestable. Included previously Harvested Beans.\\n     */\\n    struct Field {\\n        uint128 soil; // \u2500\u2500\u2500\u2500\u2500\u2500\u2510 16\\n        uint128 beanSown; // \u2500\u2500\u2518 16 (32/32)\\n        uint256 pods;\\n        uint256 harvested;\\n        uint256 harvestable;\\n    }\\n\\n    /**\\n     * @notice DEPRECATED: Contained data about each BIP (Beanstalk Improvement Proposal).\\n     * @dev Replant moved governance off-chain. This struct is left for future reference.\\n     * \\n     */\\n    struct Bip {\\n        address proposer; // \u2500\u2500\u2500\u2510 20\\n        uint32 start; //        \u2502 4 (24)\\n        uint32 period; //       \u2502 4 (28)\\n        bool executed; // \u2500\u2500\u2500\u2500\u2500\u2500\u2518 1 (29/32)\\n        int pauseOrUnpause; \\n        uint128 timestamp;\\n        uint256 roots;\\n        uint256 endTotalRoots;\\n    }\\n\\n    /**\\n     * @notice DEPRECATED: Contained data for the DiamondCut associated with each BIP.\\n     * @dev Replant moved governance off-chain. This struct is left for future reference.\\n     * @dev {Storage.DiamondCut} stored DiamondCut-related data for each {Bip}.\\n     */\\n    struct DiamondCut {\\n        IDiamondCut.FacetCut[] diamondCut;\\n        address initAddress;\\n        bytes initData;\\n    }\\n\\n    /**\\n     * @notice DEPRECATED: Contained all governance-related data, including a list of BIPs, votes for each BIP, and the DiamondCut needed to execute each BIP.\\n     * @dev Replant moved governance off-chain. This struct is left for future reference.\\n     * @dev {Storage.Governance} stored all BIPs and Farmer voting information.\\n     */\\n    struct Governance {\\n        uint32[] activeBips;\\n        uint32 bipIndex;\\n        mapping(uint32 => DiamondCut) diamondCuts;\\n        mapping(uint32 => mapping(address => bool)) voted;\\n        mapping(uint32 => Bip) bips;\\n    }\\n\\n    /**\\n     * @notice System-level Silo state; contains deposit and withdrawal data for a particular whitelisted Token.\\n     * @param deposited The total amount of this Token currently Deposited in the Silo.\\n     * @param depositedBdv The total bdv of this Token currently Deposited in the Silo.\\n     * @param withdrawn The total amount of this Token currently Withdrawn From the Silo.\\n     * @dev {Storage.State} contains a mapping from Token address => AssetSilo.\\n     * Currently, the bdv of deposits are asynchronous, and require an on-chain transaction to update.\\n     * Thus, the total bdv of deposits cannot be calculated, and must be stored and updated upon a bdv change.\\n     * \\n     * Note that \\\"Withdrawn\\\" refers to the amount of Tokens that have been Withdrawn\\n     * but not yet Claimed. This will be removed in a future BIP.\\n     */\\n    struct AssetSilo {\\n        uint128 deposited;\\n        uint128 depositedBdv;\\n        uint256 withdrawn;\\n    }\\n\\n    /**\\n     * @notice System-level Silo state variables.\\n     * @param stalk The total amount of active Stalk (including Earned Stalk, excluding Grown Stalk).\\n     * @param deprecated_seeds DEPRECATED: The total amount of active Seeds (excluding Earned Seeds).\\n     * @dev seeds are no longer used internally. Balance is wiped to 0 from the mayflower update. see {mowAndMigrate}.\\n     * @param roots The total amount of Roots.\\n     */\\n    struct Silo {\\n        uint256 stalk;\\n        uint256 deprecated_seeds; \\n        uint256 roots;\\n    }\\n\\n    /**\\n     * @notice System-level Curve Metapool Oracle state variables.\\n     * @param initialized True if the Oracle has been initialzed. It needs to be initialized on Deployment and re-initialized each Unpause.\\n     * @param startSeason The Season the Oracle started minting. Used to ramp up delta b when oracle is first added.\\n     * @param balances The cumulative reserve balances of the pool at the start of the Season (used for computing time weighted average delta b).\\n     * @param timestamp DEPRECATED: The timestamp of the start of the current Season. `LibCurveMinting` now uses `s.season.timestamp` instead of storing its own for gas efficiency purposes.\\n     * @dev Currently refers to the time weighted average deltaB calculated from the BEAN:3CRV pool.\\n     */\\n    struct CurveMetapoolOracle {\\n        bool initialized; // \u2500\u2500\u2500\u2500\u2510 1\\n        uint32 startSeason; // \u2500\u2500\u2518 4 (5/32)\\n        uint256[2] balances;\\n        uint256 timestamp;\\n    }\\n\\n    /**\\n     * @notice System-level Rain balances. Rain occurs when P > 1 and the Pod Rate Excessively Low.\\n     * @dev The `raining` storage variable is stored in the Season section for a gas efficient read operation.\\n     * @param deprecated Previously held Rain start and Rain status variables. Now moved to Season struct for gas efficiency.\\n     * @param pods The number of Pods when it last started Raining.\\n     * @param roots The number of Roots when it last started Raining.\\n     */\\n    struct Rain {\\n        uint256 deprecated;\\n        uint256 pods;\\n        uint256 roots;\\n    }\\n\\n    /**\\n     * @notice System-level Season state variables.\\n     * @param current The current Season in Beanstalk.\\n     * @param lastSop The Season in which the most recent consecutive series of Seasons of Plenty started.\\n     * @param withdrawSeasons The number of Seasons required to Withdraw a Deposit.\\n     * @param lastSopSeason The Season in which the most recent consecutive series of Seasons of Plenty ended.\\n     * @param rainStart Stores the most recent Season in which Rain started.\\n     * @param raining True if it is Raining (P > 1, Pod Rate Excessively Low).\\n     * @param fertilizing True if Beanstalk has Fertilizer left to be paid off.\\n     * @param sunriseBlock The block of the start of the current Season.\\n     * @param abovePeg Boolean indicating whether the previous Season was above or below peg.\\n     * @param stemStartSeason // season in which the stem storage method was introduced\\n     * @param start The timestamp of the Beanstalk deployment rounded down to the nearest hour.\\n     * @param period The length of each season in Beanstalk in seconds.\\n     * @param timestamp The timestamp of the start of the current Season.\\n     */\\n    struct Season {\\n        uint32 current; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 4  \\n        uint32 lastSop; //         \u2502 4 (8)\\n        uint8 withdrawSeasons; //  \u2502 1 (9)\\n        uint32 lastSopSeason; //   \u2502 4 (13)\\n        uint32 rainStart; //       \u2502 4 (17)\\n        bool raining; //           \u2502 1 (18)\\n        bool fertilizing; //       \u2502 1 (19)\\n        uint32 sunriseBlock; //    \u2502 4 (23)\\n        bool abovePeg; //          | 1 (24)\\n        uint16 stemStartSeason; // \u2518 2 (26/32)\\n        uint256 start;\\n        uint256 period;\\n        uint256 timestamp;\\n    }\\n\\n    /**\\n     * @notice System-level Weather state variables.\\n     * @param deprecated 2 slots that were previously used.\\n     * @param lastDSoil Delta Soil; the number of Soil purchased last Season.\\n     * @param lastSowTime The number of seconds it for Soil to sell out last Season.\\n     * @param thisSowTime The number of seconds it for Soil to sell out this Season.\\n     * @param t The Temperature; the maximum interest rate during the current Season for sowing Beans in Soil. Adjusted each Season.\\n     */\\n    struct Weather {\\n        uint256[2] deprecated;\\n        uint128 lastDSoil;  // \u2500\u2500\u2500\u2510 16 (16)\\n        uint32 lastSowTime; //    \u2502 4  (20)\\n        uint32 thisSowTime; //    \u2502 4  (24)\\n        uint32 t; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 4  (28/32)\\n    }\\n\\n    /**\\n     * @notice Describes a Fundraiser.\\n     * @param payee The address to be paid after the Fundraiser has been fully funded.\\n     * @param token The token address that used to raise funds for the Fundraiser.\\n     * @param total The total number of Tokens that need to be raised to complete the Fundraiser.\\n     * @param remaining The remaining number of Tokens that need to to complete the Fundraiser.\\n     * @param start The timestamp at which the Fundraiser started (Fundraisers cannot be started and funded in the same block).\\n     */\\n    struct Fundraiser {\\n        address payee;\\n        address token;\\n        uint256 total;\\n        uint256 remaining;\\n        uint256 start;\\n    }\\n\\n    /**\\n     * @notice Describes the settings for each Token that is Whitelisted in the Silo.\\n     * @param selector The encoded BDV function selector for the Token.\\n     * @param seeds The Seeds Per BDV that the Silo mints in exchange for Depositing this Token.\\n     * @param stalk The Stalk Per BDV that the Silo mints in exchange for Depositing this Token.\\n     * @dev A Token is considered Whitelisted if there exists a non-zero {SiloSettings} selector.\\n     * \\n     * Note: `selector` is an encoded function selector that pertains to an \\n     * external view function with the following signature:\\n     * \\n     * `function tokenToBdv(uint256 amount) public view returns (uint256);`\\n     * \\n     * It is called by {LibTokenSilo} through the use of delegate call to calculate \\n     * the BDV of Tokens at the time of Deposit.\\n     */\\n    struct SiloSettings {\\n        /*\\n         * @dev: \\n         * \\n         * `selector` is an encoded function selector that pertains to \\n         * an external view Beanstalk function with the following signature:\\n         * \\n         * ```\\n         * function tokenToBdv(uint256 amount) public view returns (uint256);\\n         * ```\\n         * \\n         * It is called by `LibTokenSilo` through the use of `delegatecall`\\n         * to calculate a token's BDV at the time of Deposit.\\n         */\\n        bytes4 selector;\\n        /*\\n         * @dev The Stalk Per BDV Per Season represents how much Stalk one BDV of the underlying deposited token\\n         * grows each season. In the past, this was represented by seeds. This is stored as 1e6, plus stalk is stored\\n         *  as 1e10, so 1 legacy seed would be 1e6 * 1e10.\\n         */\\n        uint32 stalkEarnedPerSeason;\\n        /*\\n         * @dev The Stalk Per BDV that the Silo grants in exchange for Depositing this Token.\\n         * previously just called stalk.\\n         */\\n        uint32 stalkIssuedPerBdv;\\n        /*\\n         * @dev The last season in which the stalkEarnedPerSeason for this token was updated\\n         */\\n\\t\\tuint32 milestoneSeason;\\n        /*\\n         * @dev The cumulative amount of grown stalk per BDV for this Silo depositable token at the last stalkEarnedPerSeason update\\n         */\\n\\t\\tint96 milestoneStem;\\n\\n        /*\\n         @dev 1 byte of space is used for different encoding types.\\n         */\\n        bytes1 encodeType;\\n\\n        /// @dev  7 bytes of additional storage space is available here.\\n\\n    }\\n\\n    /**\\n     * @notice Describes the settings for each Unripe Token in Beanstalk.\\n     * @param underlyingToken The address of the Token underlying the Unripe Token.\\n     * @param balanceOfUnderlying The number of Tokens underlying the Unripe Tokens (redemption pool).\\n     * @param merkleRoot The Merkle Root used to validate a claim of Unripe Tokens.\\n     * @dev An Unripe Token is a vesting Token that is redeemable for a a pro rata share\\n     * of the `balanceOfUnderlying`, subject to a penalty based on the percent of\\n     * Unfertilized Beans paid back.\\n     * \\n     * There were two Unripe Tokens added at Replant: \\n     *  - Unripe Bean, with its `underlyingToken` as BEAN;\\n     *  - Unripe LP, with its `underlyingToken` as BEAN:3CRV LP.\\n     * \\n     * Unripe Tokens are initially distributed through the use of a `merkleRoot`.\\n     * \\n     * The existence of a non-zero {UnripeSettings} implies that a Token is an Unripe Token.\\n     */\\n    struct UnripeSettings {\\n        address underlyingToken;\\n        uint256 balanceOfUnderlying;\\n        bytes32 merkleRoot;\\n    }\\n}\\n\\n/**\\n * @title AppStorage\\n * @author Publius\\n * @notice Defines the state object for Beanstalk.\\n * @param deprecated_index DEPRECATED: Was the index of the BEAN token in the BEAN:ETH Uniswap V2 pool.\\n * @param cases The 24 Weather cases (array has 32 items, but caseId = 3 (mod 4) are not cases)\\n * @param paused True if Beanstalk is Paused.\\n * @param pausedAt The timestamp at which Beanstalk was last paused.\\n * @param season Storage.Season\\n * @param c Storage.Contracts\\n * @param f Storage.Field\\n * @param g Storage.Governance\\n * @param co Storage.CurveMetapoolOracle\\n * @param r Storage.Rain\\n * @param s Storage.Silo\\n * @param reentrantStatus An intra-transaction state variable to protect against reentrance.\\n * @param w Storage.Weather\\n * @param earnedBeans The number of Beans distributed to the Silo that have not yet been Deposited as a result of the Earn function being called.\\n * @param deprecated DEPRECATED - 14 slots that used to store state variables which have been deprecated through various updates. Storage slots can be left alone or reused.\\n * @param a mapping (address => Account.State)\\n * @param deprecated_bip0Start DEPRECATED - bip0Start was used to aid in a migration that occured alongside BIP-0.\\n * @param deprecated_hotFix3Start DEPRECATED - hotFix3Start was used to aid in a migration that occured alongside HOTFIX-3.\\n * @param fundraisers A mapping from Fundraiser ID to Storage.Fundraiser.\\n * @param fundraiserIndex The number of Fundraisers that have occured.\\n * @param deprecated_isBudget DEPRECATED - Budget Facet was removed in BIP-14. \\n * @param podListings A mapping from Plot Index to the hash of the Pod Listing.\\n * @param podOrders A mapping from the hash of a Pod Order to the amount of Pods that the Pod Order is still willing to buy.\\n * @param siloBalances A mapping from Token address to Silo Balance storage (amount deposited and withdrawn).\\n * @param ss A mapping from Token address to Silo Settings for each Whitelisted Token. If a non-zero storage exists, a Token is whitelisted.\\n * @param deprecated2 DEPRECATED - 2 slots that used to store state variables which have been depreciated through various updates. Storage slots can be left alone or reused.\\n * @param newEarnedStalk the amount of earned stalk issued this season. Since 1 stalk = 1 bean, it represents the earned beans as well.\\n * @param sops A mapping from Season to Plenty Per Root (PPR) in that Season. Plenty Per Root is 0 if a Season of Plenty did not occur.\\n * @param internalTokenBalance A mapping from Farmer address to Token address to Internal Balance. It stores the amount of the Token that the Farmer has stored as an Internal Balance in Beanstalk.\\n * @param unripeClaimed True if a Farmer has Claimed an Unripe Token. A mapping from Farmer to Unripe Token to its Claim status.\\n * @param u Unripe Settings for a given Token address. The existence of a non-zero Unripe Settings implies that the token is an Unripe Token. The mapping is from Token address to Unripe Settings.\\n * @param fertilizer A mapping from Fertilizer Id to the supply of Fertilizer for each Id.\\n * @param nextFid A linked list of Fertilizer Ids ordered by Id number. Fertilizer Id is the Beans Per Fertilzer level at which the Fertilizer no longer receives Beans. Sort in order by which Fertilizer Id expires next.\\n * @param activeFertilizer The number of active Fertilizer.\\n * @param fertilizedIndex The total number of Fertilizer Beans.\\n * @param unfertilizedIndex The total number of Unfertilized Beans ever.\\n * @param fFirst The lowest active Fertilizer Id (start of linked list that is stored by nextFid). \\n * @param fLast The highest active Fertilizer Id (end of linked list that is stored by nextFid). \\n * @param bpf The cumulative Beans Per Fertilizer (bfp) minted over all Season.\\n * @param vestingPeriodRoots the number of roots to add to the global roots, in the case the user plants in the morning. // placed here to save a storage slot.s\\n * @param recapitalized The nubmer of USDC that has been recapitalized in the Barn Raise.\\n * @param isFarm Stores whether the function is wrapped in the `farm` function (1 if not, 2 if it is).\\n * @param ownerCandidate Stores a candidate address to transfer ownership to. The owner must claim the ownership transfer.\\n * @param wellOracleSnapshots A mapping from Well Oracle address to the Well Oracle Snapshot.\\n * @param beanEthPrice Stores the beanEthPrice during the sunrise() function. Returns 1 otherwise.\\n */\\nstruct AppStorage {\\n    uint8 deprecated_index;\\n    int8[32] cases; \\n    bool paused; // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 1 \\n    uint128 pausedAt; // \u2500\u2500\u2500\u2518 16 (17/32)\\n    Storage.Season season;\\n    Storage.Contracts c;\\n    Storage.Field f;\\n    Storage.Governance g;\\n    Storage.CurveMetapoolOracle co;\\n    Storage.Rain r;\\n    Storage.Silo s;\\n    uint256 reentrantStatus;\\n    Storage.Weather w;\\n\\n    uint256 earnedBeans;\\n    uint256[14] deprecated;\\n    mapping (address => Account.State) a;\\n    uint32 deprecated_bip0Start; // \u2500\u2500\u2500\u2500\u2500\u2510 4\\n    uint32 deprecated_hotFix3Start; // \u2500\u2500\u2518 4 (8/32)\\n    mapping (uint32 => Storage.Fundraiser) fundraisers;\\n    uint32 fundraiserIndex; // 4 (4/32)\\n    mapping (address => bool) deprecated_isBudget;\\n    mapping(uint256 => bytes32) podListings;\\n    mapping(bytes32 => uint256) podOrders;\\n    mapping(address => Storage.AssetSilo) siloBalances;\\n    mapping(address => Storage.SiloSettings) ss;\\n    uint256[2] deprecated2;\\n    uint128 newEarnedStalk; // \u2500\u2500\u2500\u2500\u2500\u2500\u2510 16\\n    uint128 vestingPeriodRoots; // \u2500\u2500\u2518 16 (32/32)\\n    mapping (uint32 => uint256) sops;\\n\\n    // Internal Balances\\n    mapping(address => mapping(IERC20 => uint256)) internalTokenBalance;\\n\\n    // Unripe\\n    mapping(address => mapping(address => bool)) unripeClaimed;\\n    mapping(address => Storage.UnripeSettings) u;\\n\\n    // Fertilizer\\n    mapping(uint128 => uint256) fertilizer;\\n    mapping(uint128 => uint128) nextFid;\\n    uint256 activeFertilizer;\\n    uint256 fertilizedIndex;\\n    uint256 unfertilizedIndex;\\n    uint128 fFirst;\\n    uint128 fLast;\\n    uint128 bpf;\\n    uint256 recapitalized;\\n\\n    // Farm\\n    uint256 isFarm;\\n\\n    // Ownership\\n    address ownerCandidate;\\n\\n    // Well\\n    mapping(address => bytes) wellOracleSnapshots;\\n    uint256 beanEthPrice;\\n}\"\r\n    },\r\n    \"contracts/beanstalk/ReentrancyGuard.sol\": {\r\n      \"content\": \"\\n// SPDX-License-Identifier: MIT\\n\\npragma solidity =0.7.6;\\npragma experimental ABIEncoderV2;\\nimport \\\"./AppStorage.sol\\\";\\n\\n/**\\n * @author Beanstalk Farms\\n * @title Variation of Oepn Zeppelins reentrant guard to include Silo Update\\n * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts%2Fsecurity%2FReentrancyGuard.sol\\n**/\\nabstract contract ReentrancyGuard {\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    AppStorage internal s;\\n    \\n    modifier nonReentrant() {\\n        require(s.reentrantStatus != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n        s.reentrantStatus = _ENTERED;\\n        _;\\n        s.reentrantStatus = _NOT_ENTERED;\\n    }\\n}\"\r\n    },\r\n    \"contracts/beanstalk/silo/EnrootFacet.sol\": {\r\n      \"content\": \"/**\\n * SPDX-License-Identifier: MIT\\n **/\\n\\npragma solidity =0.7.6;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"contracts/libraries/Silo/LibSilo.sol\\\";\\nimport \\\"contracts/libraries/Silo/LibTokenSilo.sol\\\";\\nimport \\\"./SiloFacet/Silo.sol\\\";\\nimport \\\"contracts/libraries/LibSafeMath32.sol\\\";\\nimport \\\"../ReentrancyGuard.sol\\\";\\n\\n\\n/**\\n * @author Publius\\n * @title Enroot Facet handles enrooting Update Deposits\\n **/\\ncontract EnrootFacet is ReentrancyGuard {\\n    using SafeMath for uint256;\\n\\n    event RemoveDeposit(\\n        address indexed account,\\n        address indexed token,\\n        int96 stem,\\n        uint256 amount,\\n        uint256 bdv\\n    );\\n\\n    event RemoveDeposits(\\n        address indexed account,\\n        address indexed token,\\n        int96[] stems,\\n        uint256[] amounts,\\n        uint256 amount,\\n        uint256[] bdvs\\n    );\\n\\n    //////////////////////// UPDATE UNRIPE DEPOSITS ////////////////////////\\n\\n    /**\\n     * @notice Update the BDV of an Unripe Deposit. Allows the user to claim\\n     * Stalk as the BDV of Unripe tokens increases during the Barn\\n     * Raise. This was introduced as a part of the Replant.\\n     *\\n     * @dev Should revert if `ogBDV > newBDV`. A user cannot lose BDV during an\\n     * Enroot operation.\\n     *\\n     * Gas optimization: We neglect to check if `token` is whitelisted. If a\\n     * token is not whitelisted, it cannot be Deposited, and thus cannot be Removed.\\n     * \\n     * {LibTokenSilo-removeDepositFromAccount} should revert if there isn't\\n     * enough balance of `token` to remove.\\n     * Because the amount and the stem of an Deposit does not change, \\n     * an ERC1155 event does not need to be emitted.\\n     */\\n    function enrootDeposit(\\n        address token,\\n        int96 stem,\\n        uint256 amount\\n    ) external payable nonReentrant mowSender(token) {\\n        require(s.u[token].underlyingToken != address(0), \\\"Silo: token not unripe\\\");\\n        // First, remove Deposit and Redeposit with new BDV\\n        uint256 ogBDV = LibTokenSilo.removeDepositFromAccount(\\n            msg.sender,\\n            token,\\n            stem,\\n            amount\\n        );\\n        emit RemoveDeposit(msg.sender, token, stem, amount, ogBDV); // Remove Deposit does not emit an event, while Add Deposit does.\\n\\n        // Calculate the current BDV for `amount` of `token` and add a Deposit.\\n        uint256 newBDV = LibTokenSilo.beanDenominatedValue(token, amount);\\n\\n        LibTokenSilo.addDepositToAccount(\\n            msg.sender, \\n            token, \\n            stem, \\n            amount, \\n            newBDV,\\n            LibTokenSilo.Transfer.noEmitTransferSingle\\n        ); // emits AddDeposit event\\n\\n        // Calculate the difference in BDV. Reverts if `ogBDV > newBDV`.\\n        uint256 deltaBDV = newBDV.sub(ogBDV);\\n        LibTokenSilo.incrementTotalDepositedBdv(token, deltaBDV);\\n\\n        // Mint Stalk associated with the new BDV.\\n        uint256 deltaStalk = deltaBDV.mul(s.ss[token].stalkIssuedPerBdv).add(\\n            LibSilo.stalkReward(stem,\\n                                LibTokenSilo.stemTipForToken(token),\\n                                uint128(deltaBDV))\\n        );\\n\\n        LibSilo.mintStalk(msg.sender, deltaStalk);\\n    }\\n\\n    modifier mowSender(address token) {\\n       LibSilo._mow(msg.sender, token);\\n        _;\\n    }\\n\\n    /** \\n     * @notice Update the BDV of Unripe Deposits. Allows the user to claim Stalk\\n     * as the BDV of Unripe tokens increases during the Barn Raise.\\n     * This was introduced as a part of the Replant.\\n     *\\n     * @dev Should revert if `ogBDV > newBDV`. A user cannot lose BDV during an\\n     * Enroot operation.\\n     *\\n     * Gas optimization: We neglect to check if `token` is whitelisted. If a\\n     * token is not whitelisted, it cannot be Deposited, and thus cannot be Removed.\\n     * {removeDepositsFromAccount} should revert if there isn't enough balance of `token`\\n     * to remove.\\n     */\\n    function enrootDeposits(\\n        address token,\\n        int96[] calldata stems,\\n        uint256[] calldata amounts\\n    ) external payable nonReentrant mowSender(token) {\\n        require(s.u[token].underlyingToken != address(0), \\\"Silo: token not unripe\\\");\\n        // First, remove Deposits because every deposit is in a different season,\\n        // we need to get the total Stalk, not just BDV.\\n        LibSilo.AssetsRemoved memory ar = LibSilo._removeDepositsFromAccount(msg.sender, token, stems, amounts);\\n\\n        // Get new BDV\\n        uint256 newTotalBdv = LibTokenSilo.beanDenominatedValue(token, ar.tokensRemoved);\\n        uint256 stalkAdded; uint256 bdvAdded;\\n\\n        //pulled these vars out because of \\\"CompilerError: Stack too deep, try removing local variables.\\\"\\n        int96 _lastStem = LibTokenSilo.stemTipForToken(token); //need for present season\\n        uint32 _stalkPerBdv = s.ss[token].stalkIssuedPerBdv;\\n\\n        uint256 depositBdv;\\n\\n        // Iterate through all stems, redeposit the tokens with new BDV and\\n        // summate new Stalk.\\n        for (uint256 i; i < stems.length; ++i) {\\n            if (i+1 == stems.length) {\\n                // Ensure that a rounding error does not occur by using the\\n                // remainder BDV for the last Deposit.\\n                depositBdv = newTotalBdv.sub(bdvAdded);\\n            } else {\\n                // depositBdv is a proportional amount of the total bdv.\\n                // Cheaper than calling the BDV function multiple times.\\n                depositBdv = amounts[i].mul(newTotalBdv).div(ar.tokensRemoved);\\n            }\\n            LibTokenSilo.addDepositToAccount(\\n                msg.sender,\\n                token,\\n                stems[i],\\n                amounts[i],\\n                depositBdv,\\n                LibTokenSilo.Transfer.noEmitTransferSingle\\n            );\\n            \\n            stalkAdded = stalkAdded.add(\\n                depositBdv.mul(_stalkPerBdv).add(\\n                    LibSilo.stalkReward(\\n                        stems[i],\\n                        _lastStem,\\n                        uint128(depositBdv)\\n                    )\\n                )\\n            );\\n\\n            bdvAdded = bdvAdded.add(depositBdv);\\n        }\\n\\n        LibTokenSilo.incrementTotalDepositedBdv(token, bdvAdded.sub(ar.bdvRemoved));\\n\\n        // Mint Stalk associated with the delta BDV.\\n        LibSilo.mintStalk(\\n            msg.sender,\\n            stalkAdded.sub(ar.stalkRemoved)\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/beanstalk/silo/SiloFacet/Silo.sol\": {\r\n      \"content\": \"/**\\n * SPDX-License-Identifier: MIT\\n **/\\n\\npragma solidity =0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"./SiloExit.sol\\\";\\n\\n/**\\n * @title Silo\\n * @author Publius, Pizzaman1337, Brean\\n * @notice Provides utility functions for claiming Silo rewards, including:\\n *\\n * - Grown Stalk (see \\\"Mow\\\")\\n * - Earned Beans, Earned Stalk (see \\\"Plant\\\")\\n * - 3CRV earned during a Flood (see \\\"Flood\\\")\\n *\\n * For backwards compatibility, a Flood is sometimes referred to by its old name\\n * \\\"Season of Plenty\\\".\\n */\\n \\ncontract Silo is SiloExit {\\n    using SafeMath for uint256;\\n    using SafeERC20 for IERC20;\\n    using LibSafeMath128 for uint128;\\n\\n    //////////////////////// EVENTS ////////////////////////    \\n\\n    /**\\n     * @notice Emitted when the deposit associated with the Earned Beans of\\n     * `account` are Planted.\\n     * @param account Owns the Earned Beans\\n     * @param beans The amount of Earned Beans claimed by `account`.\\n     */\\n    event Plant(\\n        address indexed account,\\n        uint256 beans\\n    );\\n\\n    /**\\n     * @notice Emitted when 3CRV paid to `account` during a Flood is Claimed.\\n     * @param account Owns and receives the assets paid during a Flood.\\n     * @param plenty The amount of 3CRV claimed by `account`. This is the amount\\n     * that `account` has been paid since their last {ClaimPlenty}.\\n     * \\n     * @dev Flood was previously called a \\\"Season of Plenty\\\". For backwards\\n     * compatibility, the event has not been changed. For more information on \\n     * Flood, see: {Weather.sop}.\\n     */\\n    event ClaimPlenty(\\n        address indexed account,\\n        uint256 plenty\\n    );\\n\\n\\n    /**\\n     * @notice Emitted when `account` gains or loses Stalk.\\n     * @param account The account that gained or lost Stalk.\\n     * @param delta The change in Stalk.\\n     * @param deltaRoots The change in Roots.\\n     *   \\n     * @dev {StalkBalanceChanged} should be emitted anytime a Deposit is added, removed or transferred AND\\n     * anytime an account Mows Grown Stalk.\\n     * @dev BIP-24 included a one-time re-emission of {SeedsBalanceChanged} for accounts that had\\n     * executed a Deposit transfer between the Replant and BIP-24 execution. For more, see:\\n     * [BIP-24](https://github.com/BeanstalkFarms/Beanstalk-Governance-Proposals/blob/master/bip/bip-24-fungible-bdv-support.md)\\n     * [Event-24-Event-Emission](https://github.com/BeanstalkFarms/Event-24-Event-Emission)\\n     */\\n    event StalkBalanceChanged(\\n        address indexed account,\\n        int256 delta,\\n        int256 deltaRoots\\n    );\\n\\n    //////////////////////// INTERNAL: MOW ////////////////////////\\n\\n    /**\\n     * @dev Claims the Grown Stalk for `msg.sender`. Requires token address to mow.\\n     */\\n    modifier mowSender(address token) {\\n        LibSilo._mow(msg.sender, token);\\n        _;\\n    }\\n\\n    //////////////////////// INTERNAL: PLANT ////////////////////////\\n\\n    /**\\n     * @dev Plants the Plantable BDV of `account` associated with its Earned\\n     * Beans.\\n     * \\n     * For more info on Planting, see: {SiloFacet-plant}\\n     */\\n     \\n    function _plant(address account) internal returns (uint256 beans, int96 stemTip) {\\n        // Need to Mow for `account` before we calculate the balance of \\n        // Earned Beans.\\n        \\n        // per the zero withdraw update, planting is handled differently \\n        // depending whether or not the user plants during the vesting period of beanstalk. \\n        // during the vesting period, the earned beans are not issued to the user.\\n        // thus, the roots calculated for a given user is different. \\n        // This is handled by the super mow function, which stores the difference in roots.\\n        LibSilo._mow(account, C.BEAN);\\n        uint256 accountStalk = s.a[account].s.stalk;\\n\\n        // Calculate balance of Earned Beans.\\n        beans = _balanceOfEarnedBeans(account, accountStalk);\\n        stemTip = LibTokenSilo.stemTipForToken(C.BEAN);\\n        s.a[account].deltaRoots = 0; // must be 0'd, as calling balanceOfEarnedBeans would give a invalid amount of beans. \\n        if (beans == 0) return (0,stemTip);\\n        \\n        // Reduce the Silo's supply of Earned Beans.\\n        // SafeCast unnecessary because beans is <= s.earnedBeans.\\n        s.earnedBeans = s.earnedBeans.sub(uint128(beans));\\n        \\n        // Deposit Earned Beans if there are any. Note that 1 Bean = 1 BDV.\\n        LibTokenSilo.addDepositToAccount(\\n            account,\\n            C.BEAN,\\n            stemTip,\\n            beans, // amount\\n            beans, // bdv\\n            LibTokenSilo.Transfer.emitTransferSingle\\n        );\\n        s.a[account].deltaRoots = 0; // must be 0'd, as calling balanceOfEarnedBeans would give a invalid amount of beans. \\n\\n        // Earned Stalk associated with Earned Beans generate more Earned Beans automatically (i.e., auto compounding).\\n        // Earned Stalk are minted when Earned Beans are minted during Sunrise. See {Sun.sol:rewardToSilo} for details.\\n        // Similarly, `account` does not receive additional Roots from Earned Stalk during a Plant.\\n        // The following lines allocate Earned Stalk that has already been minted to `account`.\\n        // Constant is used here rather than s.ss[BEAN].stalkIssuedPerBdv\\n        // for gas savings.\\n        uint256 stalk = beans.mul(C.STALK_PER_BEAN);\\n        s.a[account].s.stalk = accountStalk.add(stalk);\\n\\n\\n        emit StalkBalanceChanged(account, int256(stalk), 0);\\n        emit Plant(account, beans);\\n    }\\n\\n    //////////////////////// INTERNAL: SEASON OF PLENTY ////////////////////////\\n\\n    /**\\n     * @dev Gas optimization: An account can call `{SiloFacet:claimPlenty}` even\\n     * if `s.a[account].sop.plenty == 0`. This would emit a ClaimPlenty event\\n     * with an amount of 0.\\n     */\\n    function _claimPlenty(address account) internal {\\n        // Plenty is earned in the form of 3Crv.\\n        uint256 plenty = s.a[account].sop.plenty;\\n        C.threeCrv().safeTransfer(account, plenty);\\n        delete s.a[account].sop.plenty;\\n\\n        emit ClaimPlenty(account, plenty);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/beanstalk/silo/SiloFacet/SiloExit.sol\": {\r\n      \"content\": \"/*\\n/**\\n * SPDX-License-Identifier: MIT\\n **/\\n\\npragma solidity =0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"contracts/beanstalk/ReentrancyGuard.sol\\\";\\nimport \\\"contracts/libraries/Silo/LibSilo.sol\\\";\\nimport \\\"contracts/libraries/Silo/LibTokenSilo.sol\\\";\\nimport \\\"contracts/libraries/Silo/LibLegacyTokenSilo.sol\\\";\\nimport \\\"contracts/libraries/LibSafeMath32.sol\\\";\\nimport \\\"contracts/libraries/LibSafeMath128.sol\\\";\\nimport \\\"contracts/C.sol\\\";\\n\\n/**\\n * @title SiloExit\\n * @author Publius, Brean, Pizzaman1337\\n * @notice Exposes public view functions for Silo total balances, account\\n * balances, account update history, and Season of Plenty (SOP) balances.\\n *\\n * Provides utility functions like {_season} for upstream usage throughout\\n * SiloFacet.\\n */\\ncontract SiloExit is ReentrancyGuard {\\n    using SafeMath for uint256;\\n    using LibSafeMath32 for uint32;\\n    using LibSafeMath128 for uint128;\\n\\n    /**\\n     * @dev Stores account-level Season of Plenty balances.\\n     * \\n     * Returned by {balanceOfSop}.\\n     */\\n    struct AccountSeasonOfPlenty {\\n        // The Season that it started Raining, if it was Raining during the last\\n        // Season in which `account` updated their Silo. Otherwise, 0.\\n        uint32 lastRain; \\n        // The last Season of Plenty starting Season processed for `account`.\\n        uint32 lastSop;\\n        // `account` balance of Roots when it started raining. \\n        uint256 roots; \\n        // The global Plenty per Root at the last Season in which `account`\\n        // updated their Silo.\\n        uint256 plentyPerRoot; \\n        // `account` balance of unclaimed Bean:3Crv from Seasons of Plenty.\\n        uint256 plenty; \\n    }\\n\\n    //////////////////////// UTILTIES ////////////////////////\\n\\n    /**\\n     * @notice Get the last Season in which `account` updated their Silo.\\n     */\\n    function lastUpdate(address account) public view returns (uint32) {\\n        return s.a[account].lastUpdate;\\n    }\\n\\n    //////////////////////// SILO: TOTALS ////////////////////////\\n\\n    /**\\n     * @notice Returns the total supply of Stalk. Does NOT include Grown Stalk.\\n     */\\n    function totalStalk() public view returns (uint256) {\\n        return s.s.stalk;\\n    }\\n\\n    /**\\n     * @notice Returns the total supply of Roots.\\n     */\\n    function totalRoots() public view returns (uint256) {\\n        return s.s.roots;\\n    }\\n\\n    /**\\n     * @notice Returns the total supply of Earned Beans.\\n     * @dev Beanstalk's \\\"supply\\\" of Earned Beans is a subset of the total Bean\\n     * supply. Earned Beans are simply seignorage Beans held by Beanstalk for \\n     * distribution to Stalkholders during {SiloFacet-plant}.   \\n     */\\n    function totalEarnedBeans() public view returns (uint256) {\\n        return s.earnedBeans;\\n    }\\n\\n    //////////////////////// SILO: ACCOUNT BALANCES ////////////////////////\\n\\n    /**\\n     * @notice Returns the balance of Stalk for `account`. \\n     * Does NOT include Grown Stalk.\\n     * DOES include Earned Stalk.\\n     * @dev Earned Stalk earns Bean Mints, but Grown Stalk does not due to\\n     * computational complexity.\\n     */\\n    function balanceOfStalk(address account) public view returns (uint256) {\\n        return s.a[account].s.stalk.add(balanceOfEarnedStalk(account));\\n    }\\n\\n    /**\\n     * @notice Returns the balance of Roots for `account`.\\n     * @dev Roots within Beanstalk are entirely separate from the \\n     * [ROOT ERC-20 token](https://roottoken.org/).\\n     * \\n     * Roots represent proportional ownership of Stalk:\\n     *  `balanceOfStalk / totalStalk = balanceOfRoots / totalRoots`\\n     * \\n     * Roots are used to calculate Earned Bean, Earned Stalk and Plantable Seed\\n     * balances.\\n     *\\n     * When a Flood occurs, Plenty is distributed based on a Farmer's balance \\n     * of Roots when it started Raining.\\n     */\\n    function balanceOfRoots(address account) public view returns (uint256) {\\n        return s.a[account].roots;\\n    }\\n\\n    /**\\n     * @notice Returns the balance of Grown Stalk for `account`. Grown Stalk is \\n     * earned each Season from BDV and must be Mown via `SiloFacet-mow` to \\n     * apply it to a user's balance.\\n     * \\n     * @dev This passes in the last stem the user mowed at and the current stem\\n     */\\n    function balanceOfGrownStalk(address account, address token)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return\\n            LibSilo._balanceOfGrownStalk(\\n                s.a[account].mowStatuses[token].lastStem, //last stem farmer mowed\\n                LibTokenSilo.stemTipForToken(token), //get latest stem for this token\\n                s.a[account].mowStatuses[token].bdv\\n            );\\n    }\\n\\n    /**\\n     * @notice Returns the balance of Grown Stalk for a single deposit of `token`\\n     * in `stem` for `account`. Grown Stalk is earned each Season from BDV and\\n     * must be Mown via `SiloFacet-mow` to apply it to a user's balance.\\n     *\\n     * @dev This passes in the last stem the user mowed at and the current stem\\n     */\\n    function grownStalkForDeposit(\\n        address account,\\n        address token,\\n        int96 stem\\n    )\\n        public\\n        view\\n        returns (uint grownStalk)\\n    {\\n        return LibTokenSilo.grownStalkForDeposit(account, token, stem);\\n    }\\n    \\n    /**\\n     * @notice Returns the balance of Earned Beans for `account`. Earned Beans\\n     * are the Beans distributed to Stalkholders during {Sun-rewardToSilo}.\\n     */\\n    function balanceOfEarnedBeans(address account)\\n        public\\n        view\\n        returns (uint256 beans)\\n    {\\n        beans = _balanceOfEarnedBeans(account, s.a[account].s.stalk);\\n    }\\n\\n    /**\\n     * @dev Internal function to compute `account` balance of Earned Beans.\\n     *\\n     * The number of Earned Beans is equal to the difference between: \\n     *  - the \\\"expected\\\" Stalk balance, determined from the account balance of \\n     *    Roots. \\n     *  - the \\\"account\\\" Stalk balance, stored in account storage.\\n     * divided by the number of Stalk per Bean.\\n     * The earned beans from the latest season \\n     */\\n    function _balanceOfEarnedBeans(address account, uint256 accountStalk) \\n        internal\\n        view\\n        returns (uint256 beans) {\\n        // There will be no Roots before the first Deposit is made.\\n        if (s.s.roots == 0) return 0;\\n\\n        uint256 stalk;\\n        if(LibSilo.inVestingPeriod()){\\n            stalk = s.s.stalk.sub(s.newEarnedStalk)\\n                .mul(s.a[account].roots.add(s.a[account].deltaRoots)) // add the delta roots of the user\\n                .div(s.s.roots.add(s.vestingPeriodRoots)); // add delta of global roots \\n        } else {\\n            stalk = s.s.stalk\\n                .mul(s.a[account].roots)\\n                .div(s.s.roots);\\n        }\\n        \\n        // Beanstalk rounds down when minting Roots. Thus, it is possible that\\n        // balanceOfRoots / totalRoots * totalStalk < s.a[account].s.stalk.\\n        // As `account` Earned Balance balance should never be negative, \\n        // Beanstalk returns 0 instead.\\n        if (stalk <= accountStalk) return 0;\\n\\n        // Calculate Earned Stalk and convert to Earned Beans.\\n        beans = (stalk - accountStalk).div(C.STALK_PER_BEAN); // Note: SafeMath is redundant here.\\n        if (beans > s.earnedBeans) return s.earnedBeans;\\n\\n        return beans;\\n    }\\n\\n    /**\\n     * @notice Return the `account` balance of Earned Stalk, the Stalk\\n     * associated with Earned Beans.\\n     * @dev Earned Stalk can be derived from Earned Beans because \\n     * 1 Bean => 1 Stalk. See {C-getStalkPerBean}.\\n     */\\n    function balanceOfEarnedStalk(address account)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return balanceOfEarnedBeans(account).mul(C.STALK_PER_BEAN);\\n    }\\n\\n    /**\\n     * @notice Return the balance of Deposited BDV of `token` for a given `account`.\\n     */\\n    function balanceOfDepositedBdv(address account, address token)\\n        external\\n        view\\n        returns (uint256 depositedBdv)\\n    {\\n        depositedBdv = s.a[account].mowStatuses[token].bdv;\\n    }\\n\\n    /**\\n     * @notice Return the Stem at the time that `account` last mowed `token`.\\n     */\\n    function getLastMowedStem(address account, address token)\\n        external\\n        view\\n        returns (int96 lastStem)\\n    {\\n        lastStem = s.a[account].mowStatuses[token].lastStem;\\n    }\\n\\n    /**\\n     * @notice Return the Mow Status of `token` for a given `account`.\\n     * Mow Status includes the Stem at the time that `account` last mowed `token`\\n     * and the balance of Deposited BDV of `token` for `account`.\\n     */\\n    function getMowStatus(address account, address token)\\n        external\\n        view\\n        returns (Account.MowStatus memory mowStatus)\\n    {\\n        mowStatus = s.a[account].mowStatuses[token];\\n    }\\n\\n    //////////////////////// SEASON OF PLENTY ////////////////////////\\n\\n    /**\\n     * @notice Returns the last Season that it started Raining resulting in a \\n     * Season of Plenty.\\n     */\\n    function lastSeasonOfPlenty() public view returns (uint32) {\\n        return s.season.lastSop;\\n    }\\n\\n    /**\\n     * @notice Returns the `account` balance of unclaimed BEAN:3CRV earned from \\n     * Seasons of Plenty.\\n     */\\n    function balanceOfPlenty(address account)\\n        public\\n        view\\n        returns (uint256 plenty)\\n    {\\n        return LibSilo.balanceOfPlenty(account);\\n    }\\n\\n    /**\\n     * @notice Returns the `account` balance of Roots the last time it was \\n     * Raining during a Silo update.\\n     */\\n    function balanceOfRainRoots(address account) public view returns (uint256) {\\n        return s.a[account].sop.roots;\\n    }\\n\\n    /**\\n     * @notice Returns the `account` Season of Plenty related state variables.\\n     * @dev See {AccountSeasonOfPlenty} struct.\\n     */\\n    function balanceOfSop(address account)\\n        external\\n        view\\n        returns (AccountSeasonOfPlenty memory sop)\\n    {\\n        sop.lastRain = s.a[account].lastRain;\\n        sop.lastSop = s.a[account].lastSop;\\n        sop.roots = s.a[account].sop.roots;\\n        sop.plenty = balanceOfPlenty(account);\\n        sop.plentyPerRoot = s.a[account].sop.plentyPerRoot;\\n    }\\n\\n\\n    //////////////////////// STEM ////////////////////////\\n\\n    /**\\n     * @notice Returns the \\\"stemTip\\\" for a given token.\\n     * @dev the stemTip is the Cumulative Grown Stalk Per BDV \\n     * of a given deposited asset since whitelist. \\n     * \\n     * note that a deposit for a given asset may have \\n     * a higher Grown Stalk Per BDV than the stemTip.\\n     * \\n     * This can occur when a deposit is converted from an asset\\n     * with a larger seeds per BDV, to a lower seeds per BDV.\\n     */\\n    function stemTipForToken(address token)\\n        public\\n        view\\n        returns (int96 _stemTip)\\n    {\\n        _stemTip = LibTokenSilo.stemTipForToken(\\n            token\\n        );\\n    }\\n\\n    /**\\n     * @notice given the season/token, returns the stem assoicated with that deposit.\\n     * kept for legacy reasons. \\n     */\\n    function seasonToStem(address token, uint32 season)\\n        public\\n        view\\n        returns (int96 stem)\\n    {\\n        uint256 seedsPerBdv = getSeedsPerToken(address(token));\\n        stem = LibLegacyTokenSilo.seasonToStem(seedsPerBdv, season);\\n    }\\n\\n    /**\\n     * @notice returns the seeds per token, for legacy tokens.\\n     * calling with an non-legacy token will return 0, \\n     * even after the token is whitelisted.\\n     * kept for legacy reasons. \\n     */\\n    function getSeedsPerToken(address token) public view virtual returns (uint256) {\\n        return LibLegacyTokenSilo.getSeedsPerToken(token);\\n    }\\n\\n    /**\\n     * @notice returns the season in which beanstalk initalized siloV3.\\n     */\\n    function stemStartSeason() public view virtual returns (uint16) {\\n        return s.season.stemStartSeason;\\n    }\\n\\n    /**\\n     * @notice returns whether an account needs to migrate to siloV3.\\n     */\\n    function migrationNeeded(address account) public view returns (bool) {\\n        return LibSilo.migrationNeeded(account);\\n    }\\n\\n    /**\\n     * @notice Returns true if Earned Beans from the previous\\n     * Sunrise call are still vesting. \\n     * \\n     * Vesting Earned Beans cannot be received via `plant()` \\n     * until the vesting period is over, and will be forfeited \\n     * if a farmer withdraws during the vesting period. \\n     */\\n    function inVestingPeriod() public view returns (bool) {\\n        return LibSilo.inVestingPeriod();\\n    }\\n    //////////////////////// INTERNAL ////////////////////////\\n\\n    /**\\n     * @notice Returns the current Season number.\\n     */\\n    function _season() internal view returns (uint32) {\\n        return s.season.current;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/C.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity =0.7.6;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./interfaces/IBean.sol\\\";\\nimport \\\"./interfaces/ICurve.sol\\\";\\nimport \\\"./interfaces/IFertilizer.sol\\\";\\nimport \\\"./interfaces/IProxyAdmin.sol\\\";\\nimport \\\"./libraries/Decimal.sol\\\";\\n\\n/**\\n * @title C\\n * @author Publius\\n * @notice Contains constants used throughout Beanstalk.\\n */\\nlibrary C {\\n    using Decimal for Decimal.D256;\\n    using SafeMath for uint256;\\n\\n    //////////////////// Globals ////////////////////\\n\\n    uint256 internal constant PRECISION = 1e18;\\n    uint256 private constant CHAIN_ID = 1;\\n    bytes constant BYTES_ZERO = new bytes(0);\\n\\n    /// @dev The block time for the chain in seconds.\\n    uint256 internal constant BLOCK_LENGTH_SECONDS = 12;\\n\\n    //////////////////// Season ////////////////////\\n\\n    /// @dev The length of a Season meaured in seconds.\\n    uint256 private constant CURRENT_SEASON_PERIOD = 3600; // 1 hour\\n    uint256 internal constant SOP_PRECISION = 1e24;\\n\\n    //////////////////// Silo ////////////////////\\n\\n    uint256 internal constant SEEDS_PER_BEAN = 2;\\n    uint256 internal constant STALK_PER_BEAN = 10000;\\n    uint256 private constant ROOTS_BASE = 1e12;\\n\\n    //////////////////// Exploit Migration ////////////////////\\n\\n    uint256 private constant UNRIPE_LP_PER_DOLLAR = 1884592; // 145_113_507_403_282 / 77_000_000\\n    uint256 private constant ADD_LP_RATIO = 866616;\\n    uint256 private constant INITIAL_HAIRCUT = 185564685220298701;\\n\\n    //////////////////// Contracts ////////////////////\\n\\n    address internal constant BEAN = 0xBEA0000029AD1c77D3d5D23Ba2D8893dB9d1Efab;\\n    address internal constant CURVE_BEAN_METAPOOL = 0xc9C32cd16Bf7eFB85Ff14e0c8603cc90F6F2eE49;\\n\\n    address internal constant UNRIPE_BEAN = 0x1BEA0050E63e05FBb5D8BA2f10cf5800B6224449;\\n    address internal constant UNRIPE_LP = 0x1BEA3CcD22F4EBd3d37d731BA31Eeca95713716D;\\n\\n    address private constant CURVE_3_POOL = 0xbEbc44782C7dB0a1A60Cb6fe97d0b483032FF1C7;\\n    address private constant THREE_CRV = 0x6c3F90f043a72FA612cbac8115EE7e52BDe6E490;\\n\\n    address private constant FERTILIZER = 0x402c84De2Ce49aF88f5e2eF3710ff89bFED36cB6;\\n    address private constant FERTILIZER_ADMIN = 0xfECB01359263C12Aa9eD838F878A596F0064aa6e;\\n\\n    address private constant TRI_CRYPTO = 0xc4AD29ba4B3c580e6D59105FFf484999997675Ff;\\n    address private constant TRI_CRYPTO_POOL = 0xD51a44d3FaE010294C616388b506AcdA1bfAAE46;\\n    address private constant CURVE_ZAP = 0xA79828DF1850E8a3A3064576f380D90aECDD3359;\\n\\n    address private constant UNRIPE_CURVE_BEAN_LUSD_POOL = 0xD652c40fBb3f06d6B58Cb9aa9CFF063eE63d465D;\\n    address private constant UNRIPE_CURVE_BEAN_METAPOOL = 0x3a70DfA7d2262988064A2D051dd47521E43c9BdD;\\n\\n    address internal constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\\n    address internal constant USDT = 0xdAC17F958D2ee523a2206206994597C13D831ec7;\\n    address internal constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\n    address internal constant UNIV3_ETH_USDC_POOL = 0x88e6A0c2dDD26FEEb64F039a2c41296FcB3f5640; // 0.05% pool\\n    address internal constant UNIV3_ETH_USDT_POOL = 0x11b815efB8f581194ae79006d24E0d814B7697F6; // 0.05% pool\\n\\n    // Use external contract for block.basefee as to avoid upgrading existing contracts to solidity v8\\n    address private constant BASE_FEE_CONTRACT = 0x84292919cB64b590C0131550483707E43Ef223aC;\\n\\n    //////////////////// Well ////////////////////\\n\\n    uint256 internal constant WELL_MINIMUM_BEAN_BALANCE = 1000_000_000; // 1,000 Beans\\n    address constant internal BEANSTALK_PUMP = 0xBA510f10E3095B83a0F33aa9ad2544E22570a87C;\\n    address constant BEAN_ETH_WELL = 0xBEA0e11282e2bB5893bEcE110cF199501e872bAd;\\n\\n    function getSeasonPeriod() internal pure returns (uint256) {\\n        return CURRENT_SEASON_PERIOD;\\n    }\\n\\n    function getBlockLengthSeconds() internal pure returns (uint256) {\\n        return BLOCK_LENGTH_SECONDS;\\n    }\\n\\n    function getChainId() internal pure returns (uint256) {\\n        return CHAIN_ID;\\n    }\\n\\n    function getSeedsPerBean() internal pure returns (uint256) {\\n        return SEEDS_PER_BEAN;\\n    }\\n\\n    function getStalkPerBean() internal pure returns (uint256) {\\n      return STALK_PER_BEAN;\\n    }\\n\\n    function getRootsBase() internal pure returns (uint256) {\\n        return ROOTS_BASE;\\n    }\\n\\n    /**\\n     * @dev The pre-exploit BEAN:3CRV Curve metapool address.\\n     */\\n    function unripeLPPool1() internal pure returns (address) {\\n        return UNRIPE_CURVE_BEAN_METAPOOL;\\n    }\\n\\n    /**\\n     * @dev The pre-exploit BEAN:LUSD Curve plain pool address.\\n     */\\n    function unripeLPPool2() internal pure returns (address) {\\n        return UNRIPE_CURVE_BEAN_LUSD_POOL;\\n    }\\n\\n    function unripeBean() internal pure returns (IERC20) {\\n        return IERC20(UNRIPE_BEAN);\\n    }\\n\\n    function unripeLP() internal pure returns (IERC20) {\\n        return IERC20(UNRIPE_LP);\\n    }\\n\\n    function bean() internal pure returns (IBean) {\\n        return IBean(BEAN);\\n    }\\n\\n    function usdc() internal pure returns (IERC20) {\\n        return IERC20(USDC);\\n    }\\n\\n    function curveMetapool() internal pure returns (ICurvePool) {\\n        return ICurvePool(CURVE_BEAN_METAPOOL);\\n    }\\n\\n    function curve3Pool() internal pure returns (I3Curve) {\\n        return I3Curve(CURVE_3_POOL);\\n    }\\n    \\n    function curveZap() internal pure returns (ICurveZap) {\\n        return ICurveZap(CURVE_ZAP);\\n    }\\n\\n    function curveZapAddress() internal pure returns (address) {\\n        return CURVE_ZAP;\\n    }\\n\\n    function curve3PoolAddress() internal pure returns (address) {\\n        return CURVE_3_POOL;\\n    }\\n\\n    function threeCrv() internal pure returns (IERC20) {\\n        return IERC20(THREE_CRV);\\n    }\\n\\n    function UniV3EthUsdc() internal pure returns (address){\\n        return UNIV3_ETH_USDC_POOL;\\n    }\\n\\n    function fertilizer() internal pure returns (IFertilizer) {\\n        return IFertilizer(FERTILIZER);\\n    }\\n\\n    function fertilizerAddress() internal pure returns (address) {\\n        return FERTILIZER;\\n    }\\n\\n    function fertilizerAdmin() internal pure returns (IProxyAdmin) {\\n        return IProxyAdmin(FERTILIZER_ADMIN);\\n    }\\n\\n    function triCryptoPoolAddress() internal pure returns (address) {\\n        return TRI_CRYPTO_POOL;\\n    }\\n\\n    function triCrypto() internal pure returns (IERC20) {\\n        return IERC20(TRI_CRYPTO);\\n    }\\n\\n    function unripeLPPerDollar() internal pure returns (uint256) {\\n        return UNRIPE_LP_PER_DOLLAR;\\n    }\\n\\n    function dollarPerUnripeLP() internal pure returns (uint256) {\\n        return 1e12/UNRIPE_LP_PER_DOLLAR;\\n    }\\n\\n    function exploitAddLPRatio() internal pure returns (uint256) {\\n        return ADD_LP_RATIO;\\n    }\\n\\n    function precision() internal pure returns (uint256) {\\n        return PRECISION;\\n    }\\n\\n    function initialRecap() internal pure returns (uint256) {\\n        return INITIAL_HAIRCUT;\\n    }\\n\\n}\"\r\n    },\r\n    \"contracts/interfaces/IBean.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity =0.7.6;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\n/**\\n * @title IBean\\n * @author Publius\\n * @notice Bean Interface\\n */\\nabstract contract IBean is IERC20 {\\n    function burn(uint256 amount) public virtual;\\n    function burnFrom(address account, uint256 amount) public virtual;\\n    function mint(address account, uint256 amount) public virtual;\\n    function symbol() public view virtual returns (string memory);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ICurve.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma experimental ABIEncoderV2;\\npragma solidity =0.7.6;\\n\\ninterface ICurvePool {\\n    function A_precise() external view returns (uint256);\\n    function get_balances() external view returns (uint256[2] memory);\\n    function totalSupply() external view returns (uint256);\\n    function add_liquidity(uint256[2] memory amounts, uint256 min_mint_amount) external returns (uint256);\\n    function remove_liquidity_one_coin(uint256 _token_amount, int128 i, uint256 min_amount) external returns (uint256);\\n    function balances(int128 i) external view returns (uint256);\\n    function fee() external view returns (uint256);\\n    function coins(uint256 i) external view returns (address);\\n    function get_virtual_price() external view returns (uint256);\\n    function calc_token_amount(uint256[2] calldata amounts, bool deposit) external view returns (uint256);\\n    function calc_withdraw_one_coin(uint256 _token_amount, int128 i) external view returns (uint256);\\n    function exchange(int128 i, int128 j, uint256 dx, uint256 min_dy) external returns (uint256);\\n    function exchange_underlying(int128 i, int128 j, uint256 dx, uint256 min_dy) external returns (uint256);\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n}\\n\\ninterface ICurveZap {\\n    function add_liquidity(address _pool, uint256[4] memory _deposit_amounts, uint256 _min_mint_amount) external returns (uint256);\\n    function calc_token_amount(address _pool, uint256[4] memory _amounts, bool _is_deposit) external returns (uint256);\\n}\\n\\ninterface ICurvePoolR {\\n    function exchange(int128 i, int128 j, uint256 dx, uint256 min_dy, address receiver) external returns (uint256);\\n    function exchange_underlying(int128 i, int128 j, uint256 dx, uint256 min_dy, address receiver) external returns (uint256);\\n    function remove_liquidity_one_coin(uint256 _token_amount, int128 i, uint256 min_amount, address receiver) external returns (uint256);\\n}\\n\\ninterface ICurvePool2R {\\n    function add_liquidity(uint256[2] memory amounts, uint256 min_mint_amount, address reciever) external returns (uint256);\\n    function remove_liquidity(uint256 _burn_amount, uint256[2] memory _min_amounts, address reciever) external returns (uint256[2] calldata);\\n    function remove_liquidity_imbalance(uint256[2] memory _amounts, uint256 _max_burn_amount, address reciever) external returns (uint256);\\n}\\n\\ninterface ICurvePool3R {\\n    function add_liquidity(uint256[3] memory amounts, uint256 min_mint_amount, address reciever) external returns (uint256);\\n    function remove_liquidity(uint256 _burn_amount, uint256[3] memory _min_amounts, address reciever) external returns (uint256[3] calldata);\\n    function remove_liquidity_imbalance(uint256[3] memory _amounts, uint256 _max_burn_amount, address reciever) external returns (uint256);\\n}\\n\\ninterface ICurvePool4R {\\n    function add_liquidity(uint256[4] memory amounts, uint256 min_mint_amount, address reciever) external returns (uint256);\\n    function remove_liquidity(uint256 _burn_amount, uint256[4] memory _min_amounts, address reciever) external returns (uint256[4] calldata);\\n    function remove_liquidity_imbalance(uint256[4] memory _amounts, uint256 _max_burn_amount, address reciever) external returns (uint256);\\n}\\n\\ninterface I3Curve {\\n    function get_virtual_price() external view returns (uint256);\\n}\\n\\ninterface ICurveFactory {\\n    function get_coins(address _pool) external view returns (address[4] calldata);\\n    function get_underlying_coins(address _pool) external view returns (address[8] calldata);\\n}\\n\\ninterface ICurveCryptoFactory {\\n    function get_coins(address _pool) external view returns (address[8] calldata);\\n}\\n\\ninterface ICurvePoolC {\\n    function exchange(uint256 i, uint256 j, uint256 dx, uint256 min_dy) external returns (uint256);\\n}\\n\\ninterface ICurvePoolNoReturn {\\n    function exchange(uint256 i, uint256 j, uint256 dx, uint256 min_dy) external;\\n    function add_liquidity(uint256[3] memory amounts, uint256 min_mint_amount) external;\\n    function remove_liquidity(uint256 _burn_amount, uint256[3] memory _min_amounts) external;\\n    function remove_liquidity_imbalance(uint256[3] memory _amounts, uint256 _max_burn_amount) external;\\n    function remove_liquidity_one_coin(uint256 _token_amount, uint256 i, uint256 min_amount) external;\\n}\\n\\ninterface ICurvePoolNoReturn128 {\\n    function exchange(int128 i, int128 j, uint256 dx, uint256 min_dy) external;\\n    function remove_liquidity_one_coin(uint256 _token_amount, int128 i, uint256 min_amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IDiamondCut.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma experimental ABIEncoderV2;\\npragma solidity =0.7.6;\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n/******************************************************************************/\\n\\ninterface IDiamondCut {\\n    enum FacetCutAction {Add, Replace, Remove}\\n\\n    struct FacetCut {\\n        address facetAddress;\\n        FacetCutAction action;\\n        bytes4[] functionSelectors;\\n    }\\n\\n    /// @notice Add/replace/remove any number of functions and optionally execute\\n    ///         a function with delegatecall\\n    /// @param _diamondCut Contains the facet addresses and function selectors\\n    /// @param _init The address of the contract or facet to execute _calldata\\n    /// @param _calldata A function call, including function selector and arguments\\n    ///                  _calldata is executed with delegatecall on _init\\n    function diamondCut(\\n        FacetCut[] calldata _diamondCut,\\n        address _init,\\n        bytes calldata _calldata\\n    ) external;\\n\\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IFertilizer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma experimental ABIEncoderV2;\\npragma solidity =0.7.6;\\n\\ninterface IFertilizer {\\n    struct Balance {\\n        uint128 amount;\\n        uint128 lastBpf;\\n    }\\n    function beanstalkUpdate(\\n        address account,\\n        uint256[] memory ids,\\n        uint128 bpf\\n    ) external returns (uint256);\\n    function beanstalkMint(address account, uint256 id, uint128 amount, uint128 bpf) external;\\n    function balanceOfFertilized(address account, uint256[] memory ids) external view returns (uint256);\\n    function balanceOfUnfertilized(address account, uint256[] memory ids) external view returns (uint256);\\n    function lastBalanceOf(address account, uint256 id) external view returns (Balance memory);\\n    function lastBalanceOfBatch(address[] memory account, uint256[] memory id) external view returns (Balance[] memory);\\n    function setURI(string calldata newuri) external;\\n}\"\r\n    },\r\n    \"contracts/interfaces/IProxyAdmin.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma experimental ABIEncoderV2;\\npragma solidity =0.7.6;\\ninterface IProxyAdmin {\\n    function upgrade(address proxy, address implementation) external;\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/Decimal.sol\": {\r\n      \"content\": \"/*\\n SPDX-License-Identifier: MIT\\n*/\\n\\npragma solidity =0.7.6;\\npragma experimental ABIEncoderV2;\\n\\nimport { SafeMath } from \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\n/**\\n * @title Decimal\\n * @author dYdX\\n *\\n * Library that defines a fixed-point number with 18 decimal places.\\n */\\nlibrary Decimal {\\n    using SafeMath for uint256;\\n\\n    // ============ Constants ============\\n\\n    uint256 constant BASE = 10**18;\\n\\n    // ============ Structs ============\\n\\n\\n    struct D256 {\\n        uint256 value;\\n    }\\n\\n    // ============ Static Functions ============\\n\\n    function zero()\\n    internal\\n    pure\\n    returns (D256 memory)\\n    {\\n        return D256({ value: 0 });\\n    }\\n\\n    function one()\\n    internal\\n    pure\\n    returns (D256 memory)\\n    {\\n        return D256({ value: BASE });\\n    }\\n\\n    function from(\\n        uint256 a\\n    )\\n    internal\\n    pure\\n    returns (D256 memory)\\n    {\\n        return D256({ value: a.mul(BASE) });\\n    }\\n\\n    function ratio(\\n        uint256 a,\\n        uint256 b\\n    )\\n    internal\\n    pure\\n    returns (D256 memory)\\n    {\\n        return D256({ value: getPartial(a, BASE, b) });\\n    }\\n\\n    // ============ Self Functions ============\\n\\n    function add(\\n        D256 memory self,\\n        uint256 b\\n    )\\n    internal\\n    pure\\n    returns (D256 memory)\\n    {\\n        return D256({ value: self.value.add(b.mul(BASE)) });\\n    }\\n\\n    function sub(\\n        D256 memory self,\\n        uint256 b\\n    )\\n    internal\\n    pure\\n    returns (D256 memory)\\n    {\\n        return D256({ value: self.value.sub(b.mul(BASE)) });\\n    }\\n\\n    function sub(\\n        D256 memory self,\\n        uint256 b,\\n        string memory reason\\n    )\\n    internal\\n    pure\\n    returns (D256 memory)\\n    {\\n        return D256({ value: self.value.sub(b.mul(BASE), reason) });\\n    }\\n\\n    function mul(\\n        D256 memory self,\\n        uint256 b\\n    )\\n    internal\\n    pure\\n    returns (D256 memory)\\n    {\\n        return D256({ value: self.value.mul(b) });\\n    }\\n\\n    function div(\\n        D256 memory self,\\n        uint256 b\\n    )\\n    internal\\n    pure\\n    returns (D256 memory)\\n    {\\n        return D256({ value: self.value.div(b) });\\n    }\\n\\n    function pow(\\n        D256 memory self,\\n        uint256 b\\n    )\\n    internal\\n    pure\\n    returns (D256 memory)\\n    {\\n        if (b == 0) {\\n            return one();\\n        }\\n\\n        D256 memory temp = D256({ value: self.value });\\n        for (uint256 i = 1; i < b; ++i) {\\n            temp = mul(temp, self);\\n        }\\n\\n        return temp;\\n    }\\n\\n    function add(\\n        D256 memory self,\\n        D256 memory b\\n    )\\n    internal\\n    pure\\n    returns (D256 memory)\\n    {\\n        return D256({ value: self.value.add(b.value) });\\n    }\\n\\n    function sub(\\n        D256 memory self,\\n        D256 memory b\\n    )\\n    internal\\n    pure\\n    returns (D256 memory)\\n    {\\n        return D256({ value: self.value.sub(b.value) });\\n    }\\n\\n    function sub(\\n        D256 memory self,\\n        D256 memory b,\\n        string memory reason\\n    )\\n    internal\\n    pure\\n    returns (D256 memory)\\n    {\\n        return D256({ value: self.value.sub(b.value, reason) });\\n    }\\n\\n    function mul(\\n        D256 memory self,\\n        D256 memory b\\n    )\\n    internal\\n    pure\\n    returns (D256 memory)\\n    {\\n        return D256({ value: getPartial(self.value, b.value, BASE) });\\n    }\\n\\n    function div(\\n        D256 memory self,\\n        D256 memory b\\n    )\\n    internal\\n    pure\\n    returns (D256 memory)\\n    {\\n        return D256({ value: getPartial(self.value, BASE, b.value) });\\n    }\\n\\n    function equals(D256 memory self, D256 memory b) internal pure returns (bool) {\\n        return self.value == b.value;\\n    }\\n\\n    function greaterThan(D256 memory self, D256 memory b) internal pure returns (bool) {\\n        return compareTo(self, b) == 2;\\n    }\\n\\n    function lessThan(D256 memory self, D256 memory b) internal pure returns (bool) {\\n        return compareTo(self, b) == 0;\\n    }\\n\\n    function greaterThanOrEqualTo(D256 memory self, D256 memory b) internal pure returns (bool) {\\n        return compareTo(self, b) > 0;\\n    }\\n\\n    function lessThanOrEqualTo(D256 memory self, D256 memory b) internal pure returns (bool) {\\n        return compareTo(self, b) < 2;\\n    }\\n\\n    function isZero(D256 memory self) internal pure returns (bool) {\\n        return self.value == 0;\\n    }\\n\\n    function asUint256(D256 memory self) internal pure returns (uint256) {\\n        return self.value.div(BASE);\\n    }\\n\\n    // ============ Core Methods ============\\n\\n    function getPartial(\\n        uint256 target,\\n        uint256 numerator,\\n        uint256 denominator\\n    )\\n    private\\n    pure\\n    returns (uint256)\\n    {\\n        return target.mul(numerator).div(denominator);\\n    }\\n\\n    function compareTo(\\n        D256 memory a,\\n        D256 memory b\\n    )\\n    private\\n    pure\\n    returns (uint256)\\n    {\\n        if (a.value == b.value) {\\n            return 1;\\n        }\\n        return a.value > b.value ? 2 : 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/LibAppStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity =0.7.6;\\npragma experimental ABIEncoderV2;\\n\\n// Import all of AppStorage to give importers of LibAppStorage access to {Account}, etc.\\nimport \\\"../beanstalk/AppStorage.sol\\\";\\n\\n/**\\n * @title LibAppStorage \\n * @author Publius\\n * @notice Allows libaries to access Beanstalk's state.\\n */\\nlibrary LibAppStorage {\\n    function diamondStorage() internal pure returns (AppStorage storage ds) {\\n        assembly {\\n            ds.slot := 0\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/LibBytes.sol\": {\r\n      \"content\": \"/**\\n * SPDX-License-Identifier: MIT\\n **/\\n \\npragma solidity =0.7.6;\\n\\n/* \\n* @author: Malteasy\\n* @title: LibBytes\\n*/\\n\\nlibrary LibBytes {\\n\\n    /*\\n    * @notice From Solidity Bytes Arrays Utils\\n    * @author Gon\u00e7alo S\u00e1 <goncalo.sa@consensys.net>\\n    */\\n    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {\\n        require(_start + 1 >= _start, \\\"toUint8_overflow\\\");\\n        require(_bytes.length >= _start + 1 , \\\"toUint8_outOfBounds\\\");\\n        uint8 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x1), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    /*\\n    * @notice From Solidity Bytes Arrays Utils\\n    * @author Gon\u00e7alo S\u00e1 <goncalo.sa@consensys.net>\\n    */\\n    function toUint32(bytes memory _bytes, uint256 _start) internal pure returns (uint32) {\\n        require(_start + 4 >= _start, \\\"toUint32_overflow\\\");\\n        require(_bytes.length >= _start + 4, \\\"toUint32_outOfBounds\\\");\\n        uint32 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x4), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    /*\\n    * @notice From Solidity Bytes Arrays Utils\\n    * @author Gon\u00e7alo S\u00e1 <goncalo.sa@consensys.net>\\n    */\\n    function toUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {\\n        require(_start + 32 >= _start, \\\"toUint256_overflow\\\");\\n        require(_bytes.length >= _start + 32, \\\"toUint256_outOfBounds\\\");\\n        uint256 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x20), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    /**\\n    * @notice Loads a slice of a calldata bytes array into memory\\n    * @param b The calldata bytes array to load from\\n    * @param start The start of the slice\\n    * @param length The length of the slice\\n    */\\n    function sliceToMemory(bytes calldata b, uint256 start, uint256 length) internal pure returns (bytes memory) {\\n        bytes memory memBytes = new bytes(length);\\n        for(uint256 i = 0; i < length; ++i) {\\n            memBytes[i] = b[start + i];\\n        }\\n        return memBytes;\\n    }\\n\\n    function packAddressAndStem(address _address, int96 stem) internal pure returns (uint256) {\\n        return uint256(_address) << 96 | uint96(stem);\\n    }\\n\\n    function unpackAddressAndStem(uint256 data) internal pure returns(address, int96) {\\n        return (address(uint160(data >> 96)), int96(int256(data)));\\n    }\\n\\n\\n}\"\r\n    },\r\n    \"contracts/libraries/LibPRBMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity =0.7.6;\\npragma experimental ABIEncoderV2;\\n\\n\\n/**\\n * @title LibPRBMath contains functionality to compute powers of 60.18 unsigned floating point to uint256\\n * Solution taken from https://github.com/paulrberg/prb-math/blob/main/contracts/PRBMathUD60x18.sol\\n * and adapted to Solidity 0.7.6\\n**/\\nlibrary LibPRBMath {\\n\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    // /// @dev How many trailing decimals can be represented.\\n    //uint256 internal constant SCALE = 1e18;\\n\\n    // /// @dev Largest power of two divisor of SCALE.\\n    // uint256 internal constant SCALE_LPOTD = 262144;\\n\\n    // /// @dev SCALE inverted mod 2^256.\\n    // uint256 internal constant SCALE_INVERSE =\\n    //     78156646155174841979727994598816262306175212592076161876661_508869554232690281;\\n\\n\\n    /// @dev How many trailing decimals can be represented.\\n    uint256 internal constant SCALE = 1e18;\\n\\n     /// @dev Half the SCALE number.\\n    uint256 internal constant HALF_SCALE = 5e17;\\n\\n    /// @dev Largest power of two divisor of SCALE.\\n    uint256 internal constant SCALE_LPOTD = 68719476736;\\n\\n    /// @dev SCALE inverted mod 2^256.\\n    uint256 internal constant SCALE_INVERSE =\\n        24147664466589061293728112707504694672000531928996266765558539143717230155537;\\n\\n    function powu(uint256 x, uint256 y) internal pure returns (uint256 result) {\\n        // Calculate the first iteration of the loop in advance.\\n        result = y & 1 > 0 ? x : SCALE;\\n\\n        // Equivalent to \\\"for(y /= 2; y > 0; y /= 2)\\\" but faster.\\n        for (y >>= 1; y > 0; y >>= 1) {\\n            x = mulDivFixedPoint(x, x);\\n\\n            // Equivalent to \\\"y % 2 == 1\\\" but faster.\\n            if (y & 1 > 0) {\\n                result = mulDivFixedPoint(result, x);\\n            }\\n        }\\n    }\\n\\n    function mulDivFixedPoint(uint256 x, uint256 y) internal pure returns (uint256 result) {\\n        uint256 prod0;\\n        uint256 prod1;\\n        assembly {\\n            let mm := mulmod(x, y, not(0))\\n            prod0 := mul(x, y)\\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n        }\\n\\n        if (prod1 >= SCALE) {\\n            revert(\\\"fixed point overflow\\\");\\n        }\\n\\n        uint256 remainder;\\n        uint256 roundUpUnit;\\n        assembly {\\n            remainder := mulmod(x, y, SCALE)\\n            roundUpUnit := gt(remainder, 499999999999999999)\\n        }\\n\\n        if (prod1 == 0) {\\n            result = (prod0 / SCALE) + roundUpUnit;\\n            return result;\\n        }\\n\\n        assembly {\\n            result := add(\\n                mul(\\n                    or(\\n                        div(sub(prod0, remainder), SCALE_LPOTD),\\n                        mul(sub(prod1, gt(remainder, prod0)), add(div(sub(0, SCALE_LPOTD), SCALE_LPOTD), 1))\\n                    ),\\n                    SCALE_INVERSE\\n                ),\\n                roundUpUnit\\n            )\\n        }\\n    }\\n\\n    function mostSignificantBit(uint256 x) internal pure returns (uint256 msb) {\\n        if (x >= 2**128) {\\n            x >>= 128;\\n            msb += 128;\\n        }\\n        if (x >= 2**64) {\\n            x >>= 64;\\n            msb += 64;\\n        }\\n        if (x >= 2**32) {\\n            x >>= 32;\\n            msb += 32;\\n        }\\n        if (x >= 2**16) {\\n            x >>= 16;\\n            msb += 16;\\n        }\\n        if (x >= 2**8) {\\n            x >>= 8;\\n            msb += 8;\\n        }\\n        if (x >= 2**4) {\\n            x >>= 4;\\n            msb += 4;\\n        }\\n        if (x >= 2**2) {\\n            x >>= 2;\\n            msb += 2;\\n        }\\n        if (x >= 2**1) {\\n            // No need to shift x any more.\\n            msb += 1;\\n        }\\n    }\\n\\n    function logBase2(uint256 x) internal pure returns (uint256 result) {\\n        if (x < SCALE) {\\n            revert(\\\"Log Input Too Small\\\");\\n        }\\n        // Calculate the integer part of the logarithm and add it to the result and finally calculate y = x * 2^(-n).\\n        uint256 n = mostSignificantBit(x / SCALE);\\n\\n        // The integer part of the logarithm as an unsigned 60.18-decimal fixed-point number. The operation can't overflow\\n        // because n is maximum 255 and SCALE is 1e18.\\n        result = n * SCALE;\\n\\n        // This is y = x * 2^(-n).\\n        uint256 y = x >> n;\\n\\n        // If y = 1, the fractional part is zero.\\n        if (y == SCALE) {\\n            return result;\\n        }\\n\\n        // Calculate the fractional part via the iterative approximation.\\n        // The \\\"delta >>= 1\\\" part is equivalent to \\\"delta /= 2\\\", but shifting bits is faster.\\n        for (uint256 delta = HALF_SCALE; delta > 0; delta >>= 1) {\\n            y = (y * y) / SCALE;\\n\\n            // Is y^2 > 2 and so in the range [2,4)?\\n            if (y >= 2 * SCALE) {\\n                // Add the 2^(-m) factor to the logarithm.\\n                result += delta;\\n\\n                // Corresponds to z/2 on Wikipedia.\\n                y >>= 1;\\n            }\\n        }\\n    }\\n\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a <= b ? a : b;\\n    }\\n\\n    function min(uint128 a, uint128 b) internal pure returns (uint256) {\\n        return a <= b ? a : b;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1);\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator,\\n        Rounding rounding\\n    ) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n}\"\r\n    },\r\n    \"contracts/libraries/LibSafeMath128.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @author Publius\\n * @title LibSafeMath128 is a uint128 variation of Open Zeppelin's Safe Math library.\\n**/\\nlibrary LibSafeMath128 {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint128 a, uint128 b) internal pure returns (bool, uint128) {\\n        uint128 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint128 a, uint128 b) internal pure returns (bool, uint128) {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint128 a, uint128 b) internal pure returns (bool, uint128) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint128 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint128 a, uint128 b) internal pure returns (bool, uint128) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint128 a, uint128 b) internal pure returns (bool, uint128) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint128 a, uint128 b) internal pure returns (uint128) {\\n        uint128 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint128 a, uint128 b) internal pure returns (uint128) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint128 a, uint128 b) internal pure returns (uint128) {\\n        if (a == 0) return 0;\\n        uint128 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint128 a, uint128 b) internal pure returns (uint128) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint128 a, uint128 b) internal pure returns (uint128) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint128 a, uint128 b, string memory errorMessage) internal pure returns (uint128) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint128 a, uint128 b, string memory errorMessage) internal pure returns (uint128) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint128 a, uint128 b, string memory errorMessage) internal pure returns (uint128) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/LibSafeMath32.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @author Publius\\n * @title LibSafeMath32 is a uint32 variation of Open Zeppelin's Safe Math library.\\n**/\\nlibrary LibSafeMath32 {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint32 a, uint32 b) internal pure returns (bool, uint32) {\\n        uint32 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint32 a, uint32 b) internal pure returns (bool, uint32) {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint32 a, uint32 b) internal pure returns (bool, uint32) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint32 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint32 a, uint32 b) internal pure returns (bool, uint32) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint32 a, uint32 b) internal pure returns (bool, uint32) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint32 a, uint32 b) internal pure returns (uint32) {\\n        uint32 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint32 a, uint32 b) internal pure returns (uint32) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint32 a, uint32 b) internal pure returns (uint32) {\\n        if (a == 0) return 0;\\n        uint32 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint32 a, uint32 b) internal pure returns (uint32) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint32 a, uint32 b) internal pure returns (uint32) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint32 a, uint32 b, string memory errorMessage) internal pure returns (uint32) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint32 a, uint32 b, string memory errorMessage) internal pure returns (uint32) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint32 a, uint32 b, string memory errorMessage) internal pure returns (uint32) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/LibSafeMathSigned128.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @title SignedSafeMath\\n * @dev Signed math operations with safety checks that revert on error.\\n */\\nlibrary LibSafeMathSigned128 {\\n    int128 constant private _INT128_MIN = -2**127;\\n\\n    /**\\n     * @dev Returns the multiplication of two signed integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(int128 a, int128 b) internal pure returns (int128) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        require(!(a == -1 && b == _INT128_MIN), \\\"SignedSafeMath: multiplication overflow\\\");\\n\\n        int128 c = a * b;\\n        require(c / a == b, \\\"SignedSafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two signed integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(int128 a, int128 b) internal pure returns (int128) {\\n        require(b != 0, \\\"SignedSafeMath: division by zero\\\");\\n        require(!(b == -1 && a == _INT128_MIN), \\\"SignedSafeMath: division overflow\\\");\\n\\n        int128 c = a / b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two signed integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(int128 a, int128 b) internal pure returns (int128) {\\n        int128 c = a - b;\\n        require((b >= 0 && c <= a) || (b < 0 && c > a), \\\"SignedSafeMath: subtraction overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two signed integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(int128 a, int128 b) internal pure returns (int128) {\\n        int128 c = a + b;\\n        require((b >= 0 && c >= a) || (b < 0 && c < a), \\\"SignedSafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n}\"\r\n    },\r\n    \"contracts/libraries/LibSafeMathSigned96.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @title SignedSafeMath\\n * @dev Signed math operations with safety checks that revert on error.\\n */\\nlibrary LibSafeMathSigned96 {\\n    int96 constant private _INT96_MIN = -2**95;\\n\\n    /**\\n     * @dev Returns the multiplication of two signed integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(int96 a, int96 b) internal pure returns (int96) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        require(!(a == -1 && b == _INT96_MIN), \\\"SignedSafeMath: multiplication overflow\\\");\\n\\n        int96 c = a * b;\\n        require(c / a == b, \\\"SignedSafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two signed integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(int96 a, int96 b) internal pure returns (int96) {\\n        require(b != 0, \\\"SignedSafeMath: division by zero\\\");\\n        require(!(b == -1 && a == _INT96_MIN), \\\"SignedSafeMath: division overflow\\\");\\n\\n        int96 c = a / b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two signed integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(int96 a, int96 b) internal pure returns (int96) {\\n        int96 c = a - b;\\n        require((b >= 0 && c <= a) || (b < 0 && c > a), \\\"SignedSafeMath: subtraction overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two signed integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(int96 a, int96 b) internal pure returns (int96) {\\n        int96 c = a + b;\\n        require((b >= 0 && c >= a) || (b < 0 && c < a), \\\"SignedSafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n}\"\r\n    },\r\n    \"contracts/libraries/Silo/LibLegacyTokenSilo.sol\": {\r\n      \"content\": \"/**\\n * SPDX-License-Identifier: MIT\\n **/\\n\\npragma solidity =0.7.6;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../../C.sol\\\";\\nimport \\\"./LibSilo.sol\\\";\\nimport \\\"./LibUnripeSilo.sol\\\";\\nimport \\\"../LibAppStorage.sol\\\";\\nimport {LibSafeMathSigned128} from \\\"contracts/libraries/LibSafeMathSigned128.sol\\\";\\nimport {LibSafeMath32} from \\\"contracts/libraries/LibSafeMath32.sol\\\";\\nimport {LibSafeMath128} from \\\"contracts/libraries/LibSafeMath128.sol\\\";\\nimport {SafeMath} from \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport {SafeCast} from \\\"@openzeppelin/contracts/utils/SafeCast.sol\\\";\\nimport {LibBytes} from \\\"contracts/libraries/LibBytes.sol\\\";\\nimport \\\"@openzeppelin/contracts/cryptography/MerkleProof.sol\\\";\\n\\n/**\\n * @title LibLegacyTokenSilo\\n * @author Publius, pizzaman1337\\n * @notice Contains legacy silo logic, used for migrating to the\\n * new SiloV3 stems-based system, and for claiming in-flight withdrawals\\n * from the old silo system.\\n * \\n * After all Silos are migrated to V3 and all deposits are claimed, this \\n * library should no longer be necessary.\\n */\\nlibrary LibLegacyTokenSilo {\\n    using SafeMath for uint256;\\n    using SafeCast for uint256;\\n    using LibSafeMathSigned128 for int128;\\n    using LibSafeMathSigned96 for int96;\\n    using LibSafeMath32 for uint32;\\n    using LibSafeMath128 for uint128;\\n\\n    //to get the new root, run `node scripts/silov3-merkle/stems_merkle.js`\\n    bytes32 constant DISCREPANCY_MERKLE_ROOT = 0xa84dc86252c556839dff46b290f0c401088a65584aa38a163b6b3f7dd7a5b0e8;\\n    uint32 constant ENROOT_FIX_SEASON = 12793; //season in which enroot ebip-8 fix was deployed\\n\\n\\n    //this is the legacy seasons-based remove deposits event, emitted on migration\\n    event RemoveDeposit(\\n        address indexed account,\\n        address indexed token,\\n        uint32 season,\\n        uint256 amount\\n    );\\n\\n    //legacy seeds balanced changed event, used upon migration\\n    event SeedsBalanceChanged(\\n        address indexed account,\\n        int256 delta\\n    );\\n\\n    //legacy stalk balanced changed event, used upon migration\\n    event StalkBalanceChanged(\\n        address indexed account,\\n        int256 delta,\\n        int256 deltaRoots\\n    );\\n\\n    /// @dev these events are grandfathered for claiming deposits. \\n    event RemoveWithdrawals(\\n        address indexed account,\\n        address indexed token,\\n        uint32[] seasons,\\n        uint256 amount\\n    );\\n    event RemoveWithdrawal(\\n        address indexed account,\\n        address indexed token,\\n        uint32 season,\\n        uint256 amount\\n    );\\n\\n    struct MigrateData {\\n        uint128 totalSeeds;\\n        uint128 totalGrownStalk;\\n    }\\n\\n    struct PerDepositData {\\n        uint32 season;\\n        uint128 amount;\\n        uint128 grownStalk;\\n    }\\n\\n    struct PerTokenData {\\n        address token;\\n        int96 stemTip;\\n    }\\n\\n    //////////////////////// REMOVE DEPOSIT ////////////////////////\\n\\n    /**\\n     * @dev Remove `amount` of `token` from a user's Deposit in `season`.\\n     *\\n     * A \\\"Crate\\\" refers to the existing Deposit in storage at:\\n     *  `s.a[account].legacyDeposits[token][season]`\\n     *\\n     * Partially removing a Deposit should scale its BDV proportionally. For ex.\\n     * removing 80% of the tokens from a Deposit should reduce its BDV by 80%.\\n     *\\n     * During an update, `amount` & `bdv` are cast uint256 -> uint128 to\\n     * optimize storage cost, since both values can be packed into one slot.\\n     *\\n     * This function DOES **NOT** EMIT a {RemoveDeposit} event. This\\n     * asymmetry occurs because {removeDepositFromAccount} is called in a loop\\n     * in places where multiple deposits are removed simultaneously, including\\n     * {TokenSilo-removeDepositsFromAccount} and {TokenSilo-_transferDeposits}.\\n     */\\n    function removeDepositFromAccount(\\n        address account,\\n        address token,\\n        uint32 season,\\n        uint256 amount\\n    ) internal returns (uint256 crateBDV) {\\n        \\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n\\n        uint256 crateAmount;\\n        (crateAmount, crateBDV) = (\\n            s.a[account].legacyDeposits[token][season].amount,\\n            s.a[account].legacyDeposits[token][season].bdv\\n        );\\n\\n        // If amount to remove is greater than the amount in the Deposit, migrate legacy Deposit to new Deposit\\n        if (amount > crateAmount) {\\n            // If Unripe Deposit, fetch whole Deposit balance and delete legacy deposit references.\\n            if (LibUnripeSilo.isUnripeBean(token)) {\\n                (crateAmount, crateBDV) = LibUnripeSilo.unripeBeanDeposit(account, season);\\n                LibUnripeSilo.removeLegacyUnripeBeanDeposit(account, season);\\n            } else if (LibUnripeSilo.isUnripeLP(token)) {\\n                (crateAmount, crateBDV) = LibUnripeSilo.unripeLPDeposit(account, season);\\n                LibUnripeSilo.removeLegacyUnripeLPDeposit(account, season);\\n            }\\n            require(crateAmount >= amount, \\\"Silo: Crate balance too low.\\\");\\n        }\\n\\n        // Partial Withdraw\\n        if (amount < crateAmount) {\\n            uint256 removedBDV = amount.mul(crateBDV).div(crateAmount);\\n            uint256 updatedBDV = crateBDV.sub(removedBDV);\\n            uint256 updatedAmount = crateAmount.sub(amount);\\n            require(\\n                updatedBDV <= uint128(-1) && updatedAmount <= uint128(-1),\\n                \\\"Silo: uint128 overflow.\\\"\\n            );\\n\\n            s.a[account].legacyDeposits[token][season].amount = uint128(\\n                updatedAmount\\n            );\\n            s.a[account].legacyDeposits[token][season].bdv = uint128(\\n                updatedBDV\\n            );\\n\\n            return removedBDV;\\n        }\\n\\n        // Full Remove\\n        delete s.a[account].legacyDeposits[token][season];\\n    }\\n\\n    //////////////////////// GETTERS ////////////////////////\\n\\n\\n    /**\\n     * @notice Returns the balance of Grown Stalk for `account` up until the\\n     * Stems deployment season.\\n     * @dev The balance of Grown Stalk for an account can be calculated as:\\n     *\\n     * ```\\n     * elapsedSeasons = currentSeason - lastUpdatedSeason\\n     * grownStalk = balanceOfSeeds * elapsedSeasons\\n     * ```\\n     */\\n    function balanceOfGrownStalkUpToStemsDeployment(address account)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n\\n        uint32 stemStartSeason = uint32(s.season.stemStartSeason);\\n        uint32 lastUpdate = s.a[account].lastUpdate;\\n\\n        if (lastUpdate > stemStartSeason) return 0; \\n        return\\n            stalkReward(\\n                s.a[account].s.seeds,\\n                stemStartSeason.sub(lastUpdate)\\n            );\\n    }\\n\\n    /**\\n     * @param seeds The number of Seeds held.\\n     * @param seasons The number of Seasons that have elapsed.\\n     *\\n     * @dev Calculates the Stalk that has Grown from a given number of Seeds\\n     * over a given number of Seasons.\\n     *\\n     * Each Seed yields 1E-4 (0.0001, or 1 / 10_000) Stalk per Season.\\n     *\\n     * Seasons is measured to 0 decimals. There are no fractional Seasons.\\n     * Seeds are measured to 6 decimals.\\n     * Stalk is measured to 10 decimals.\\n     * \\n     * Example:\\n     *  - `seeds = 1E6` (1 Seed)\\n     *  - `seasons = 1` (1 Season)\\n     *  - The result is `1E6 * 1 = 1E6`. Since Stalk is measured to 10 decimals,\\n     *    this is `1E6/1E10 = 1E-4` Stalk.\\n     */\\n    function stalkReward(uint256 seeds, uint32 seasons)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return seeds.mul(seasons);\\n    }\\n\\n    /** \\n     * @notice Calculates stem based on input season\\n     * @param seedsPerBdv Seeds per bdv for the token you want to find the corresponding stem for\\n     * @param season The season you want to find the corresponding stem for\\n     *\\n     * @dev Used by the mowAndMigrate function to convert seasons to stems, to know which\\n     * stem to deposit in for the new Silo storage system.\\n     */\\n    function seasonToStem(uint256 seedsPerBdv, uint32 season)\\n        internal\\n        view\\n        returns (int96 stem)\\n    {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n        \\n        require(seedsPerBdv > 0, \\\"Silo: Token not supported\\\");\\n\\n        //need to go back in time, calculate the delta between the current season and that old deposit season,\\n        //and that's how many seasons back we need to go. Then, multiply that by seedsPerBdv, and that's our\\n        //negative grown stalk index.\\n\\n        //find the difference between the input season and the Silo v3 epoch season\\n        stem = (int96(season).sub(int96(s.season.stemStartSeason))).mul(int96(seedsPerBdv));\\n    }\\n\\n    /** \\n     * @notice Migrates farmer's deposits from old (seasons based) to new silo (stems based).\\n     * @param account Address of the account to migrate\\n     *\\n     * @dev If a user's lastUpdate was set, which means they previously had deposits in the silo.\\n     * if they currently do not have any deposits to migrate, then this function \\n     * can be used to migrate their account to the new silo cheaply.\\n     */\\n   function _migrateNoDeposits(address account) internal {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n        require(s.a[account].s.seeds == 0, \\\"only for zero seeds\\\");\\n        \\n        require(LibSilo.migrationNeeded(account), \\\"no migration needed\\\");\\n\\n        s.a[account].lastUpdate = s.season.stemStartSeason;\\n    }\\n\\n    /** \\n     * @notice Migrates farmer's deposits from old (seasons based) to new silo (stems based).\\n     * @param account Address of the account to migrate\\n     * @param tokens Array of tokens to migrate\\n     * @param seasons The seasons in which the deposits were made\\n     * @param amounts The amounts of those deposits which are to be migrated\\n     *\\n     * @dev When migrating an account, you must submit all of the account's deposits,\\n     * or the migration will not pass because the seed check will fail. The seed check\\n     * adds up the BDV of all submitted deposits, and multiples by the corresponding\\n     * seed amount for each token type, then compares that to the total seeds stored for that user.\\n     * If everything matches, we know all deposits were submitted, and the migration is valid.\\n     *\\n     * Deposits are migrated to the stem storage system on a 1:1 basis. Accounts with\\n     * lots of deposits may take a considerable amount of gas to migrate.\\n     * \\n     * Returns seeds diff compared to stored amount, for verification in merkle check.\\n     */\\n    function _mowAndMigrate(\\n        address account, \\n        address[] calldata tokens, \\n        uint32[][] calldata seasons,\\n        uint256[][] calldata amounts\\n    ) internal returns (uint256) {\\n        //The balanceOfSeeds(account) > 0 check is necessary if someone updates their Silo\\n        //in the same Season as BIP execution. Such that s.a[account].lastUpdate == s.season.stemStartSeason,\\n        //but they have not migrated yet\\n        require((LibSilo.migrationNeeded(account) || balanceOfSeeds(account) > 0), \\\"no migration needed\\\");\\n\\n\\n        //do a legacy mow using the old silo seasons deposits\\n        LibSilo.mintGrownStalk(account, balanceOfGrownStalkUpToStemsDeployment(account)); //should only mint stalk up to stemStartSeason\\n        updateLastUpdateToNow(account);\\n        //at this point we've completed the guts of the old mow function, now we need to do the migration\\n \\n        MigrateData memory migrateData;\\n \\n        // use of PerTokenData and PerDepositData structs to save on stack depth\\n        for (uint256 i = 0; i < tokens.length; i++) {\\n            PerTokenData memory perTokenData;\\n            perTokenData.token = tokens[i];\\n            perTokenData.stemTip = LibTokenSilo.stemTipForToken(perTokenData.token);\\n \\n            for (uint256 j = 0; j < seasons[i].length; j++) {\\n                PerDepositData memory perDepositData;\\n                perDepositData.season = seasons[i][j];\\n                perDepositData.amount = amounts[i][j].toUint128();\\n \\n                if (perDepositData.amount == 0) {\\n                    // skip deposit calculations if amount deposited in deposit is 0\\n                    continue;\\n                }\\n \\n                // withdraw this deposit\\n                uint256 crateBDV = removeDepositFromAccount(\\n                                    account,\\n                                    perTokenData.token,\\n                                    perDepositData.season,\\n                                    perDepositData.amount\\n                                );\\n \\n                //calculate how much stalk has grown for this deposit\\n                perDepositData.grownStalk = _calcGrownStalkForDeposit(\\n                    crateBDV.mul(getSeedsPerToken(address(perTokenData.token))),\\n                    perDepositData.season\\n                );\\n \\n                // also need to calculate how much stalk has grown since the migration\\n                uint128 stalkGrownSinceStemStartSeason = LibSilo.stalkReward(0, perTokenData.stemTip, crateBDV.toUint128()).toUint128();\\n                perDepositData.grownStalk = perDepositData.grownStalk.add(stalkGrownSinceStemStartSeason);\\n                migrateData.totalGrownStalk = migrateData.totalGrownStalk.add(stalkGrownSinceStemStartSeason);\\n \\n                // add to new silo\\n                LibTokenSilo.addDepositToAccount(\\n                    account, \\n                    perTokenData.token, \\n                    LibTokenSilo.grownStalkAndBdvToStem(\\n                        perTokenData.token, \\n                        perDepositData.grownStalk,\\n                        crateBDV\\n                    ), \\n                    perDepositData.amount, \\n                    crateBDV,\\n                    LibTokenSilo.Transfer.emitTransferSingle\\n                );\\n\\n                // Include Deposit in the total Deposited BDV.\\n                LibTokenSilo.incrementTotalDepositedBdv(perTokenData.token, crateBDV);\\n \\n                // add to running total of seeds\\n                migrateData.totalSeeds = migrateData.totalSeeds.add(crateBDV.mul(getSeedsPerToken(address(perTokenData.token))).toUint128());\\n\\n                // emit legacy RemoveDeposit event\\n                emit RemoveDeposit(account, perTokenData.token, perDepositData.season, perDepositData.amount);\\n            }\\n \\n            // init mow status for this token\\n            setMowStatus(account, perTokenData.token, perTokenData.stemTip);\\n        }\\n \\n        // user deserves stalk grown between stemStartSeason and now\\n        LibSilo.mintGrownStalk(account, migrateData.totalGrownStalk);\\n\\n        //return seeds diff for checking in the \\\"part 2\\\" of this function (stack depth kept it from all fitting in one)\\n        return balanceOfSeeds(account).sub(migrateData.totalSeeds);\\n    }\\n\\n    function _mowAndMigrateMerkleCheck(\\n        address account,\\n        uint256 stalkDiff,\\n        uint256 seedsDiff,\\n        bytes32[] calldata proof,\\n        uint256 seedsVariance\\n    ) internal {\\n        if (seedsDiff > 0) {\\n            //verify merkle tree to determine stalk/seeds diff drift from convert issue\\n            bytes32 leaf = keccak256(abi.encode(account, stalkDiff, seedsDiff));\\n            \\n            require(\\n                MerkleProof.verify(proof, DISCREPANCY_MERKLE_ROOT, leaf),\\n                \\\"UnripeClaim: invalid proof\\\"\\n            );\\n        }\\n\\n        //make sure seedsVariance equals seedsDiff input\\n        require(seedsVariance == seedsDiff, \\\"seeds misalignment, double check submitted deposits\\\");\\n\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n\\n        //emit that all their seeds are gone, note need to take into account seedsDiff\\n        emit SeedsBalanceChanged(account, -int256(s.a[account].s.seeds));\\n\\n        //and wipe out old seed balances (all your seeds are belong to stem)\\n        setBalanceOfSeeds(account, 0);\\n\\n        //stalk diff was calculated based on ENROOT_FIX_SEASON, so we need to calculate\\n        //the amount of stalk that has grown since then\\n        if (seedsDiff > 0) {\\n            uint256 currentStalkDiff = (uint256(s.season.current).sub(ENROOT_FIX_SEASON)).mul(seedsDiff).add(stalkDiff);\\n\\n            //emit the stalk variance\\n            if (currentStalkDiff > 0) {\\n                LibSilo.burnStalk(account, currentStalkDiff);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Updates the lastStem of a given token for an account to the latest Tip.\\n     */\\n    function setMowStatus(address account, address token, int96 stemTip) internal {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n        s.a[account].mowStatuses[token].lastStem = stemTip;\\n    }\\n\\n    /**\\n     * @dev Season getter.\\n     */\\n    function _season() internal view returns (uint32) {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n        return s.season.current;\\n    }\\n\\n    /**\\n     * @notice DEPRECATED: Seeds do not exist in the new system, but will remain as a\\n     * user facing concept for the time being.\\n     * \\n     * @dev Legacy Seed balance getter.\\n     * \\n     */\\n    function balanceOfSeeds(address account) internal view returns (uint256) {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n        return s.a[account].s.seeds;\\n    }\\n\\n    /**\\n     * @notice DEPRECATED: Seeds do not exist in the new system,\\n     * but will remain as a user facing concept for the time being.\\n     * \\n     * @dev sets the seed for an given account.\\n     * \\n     */\\n    function setBalanceOfSeeds(address account, uint256 seeds) internal {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n        s.a[account].s.seeds = seeds;\\n    }\\n\\n    /**\\n     * @dev Updates `lastUpdate` of an account to the current season.\\n     */\\n    function updateLastUpdateToNow(address account) internal {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n        s.a[account].lastUpdate = _season();\\n    }\\n\\n    /**\\n     * @dev Calculates the amount of stalk thats been grown for a given deposit.\\n     */\\n    function _calcGrownStalkForDeposit(\\n        uint256 seedsForDeposit,\\n        uint32 season\\n    ) internal view returns (uint128 grownStalk) {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n        uint32 stemStartSeason = uint32(s.season.stemStartSeason);\\n        return uint128(stalkReward(seedsForDeposit, stemStartSeason - season));\\n    }\\n\\n    /**\\n     * @dev Legacy Seed balance getter.\\n     * \\n     * constants are used in favor of reading from storage for gas savings.\\n     */\\n    function getSeedsPerToken(address token) internal pure returns (uint256) {\\n        if (token == C.BEAN) {\\n            return 2;\\n        } else if (token == C.UNRIPE_BEAN) {\\n            return 2;\\n        } else if (token == C.UNRIPE_LP) {\\n            return 4;\\n        } else if (token == C.CURVE_BEAN_METAPOOL) {\\n            return 4;\\n        }\\n        return 0;\\n    }\\n\\n    ////////////////////////// CLAIM ///////////////////////////////\\n\\n    /** \\n     * @notice DEPRECATED. Internal logic for claiming a singular deposit.\\n     * \\n     * @dev The Zero Withdraw update removed the two-step withdraw & claim process. \\n     * These internal functions are left for backwards compatibility, to allow pending \\n     * withdrawals from before the update to be claimed.\\n     */\\n    function _claimWithdrawal(\\n        address account,\\n        address token,\\n        uint32 season\\n    ) internal returns (uint256) {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n        uint256 amount = _removeTokenWithdrawal(account, token, season);\\n        s.siloBalances[token].withdrawn = s.siloBalances[token].withdrawn.sub(\\n            amount\\n        );\\n        emit RemoveWithdrawal(msg.sender, token, season, amount);\\n        return amount;\\n    }\\n\\n    /** \\n     * @notice DEPRECATED. Internal logic for claiming multiple deposits.\\n     * \\n     * @dev The Zero Withdraw update removed the two-step withdraw & claim process. \\n     * These internal functions are left for backwards compatibility, to allow pending \\n     * withdrawals from before the update to be claimed.\\n     */\\n    function _claimWithdrawals(\\n        address account,\\n        address token,\\n        uint32[] calldata seasons\\n    ) internal returns (uint256 amount) {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n        \\n        for (uint256 i; i < seasons.length; ++i) {\\n            amount = amount.add(\\n                _removeTokenWithdrawal(account, token, seasons[i])\\n            );\\n        }\\n        s.siloBalances[token].withdrawn = s.siloBalances[token].withdrawn.sub(\\n            amount\\n        );\\n        emit RemoveWithdrawals(msg.sender, token, seasons, amount);\\n        return amount;\\n    }\\n\\n    /** \\n     * @notice DEPRECATED. Internal logic for removing the claim multiple deposits.\\n     * \\n     * @dev The Zero Withdraw update removed the two-step withdraw & claim process. \\n     * These internal functions are left for backwards compatibility, to allow pending \\n     * withdrawals from before the update to be claimed.\\n     */\\n    function _removeTokenWithdrawal(\\n        address account,\\n        address token,\\n        uint32 season\\n    ) private returns (uint256) {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n\\n        require(\\n            season <= s.season.current,\\n            \\\"Claim: Withdrawal not receivable\\\"\\n        );\\n        uint256 amount = s.a[account].withdrawals[token][season];\\n        delete s.a[account].withdrawals[token][season];\\n        return amount;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/Silo/LibSilo.sol\": {\r\n      \"content\": \"/**\\n * SPDX-License-Identifier: MIT\\n **/\\n\\npragma solidity =0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"../LibAppStorage.sol\\\";\\nimport {C} from \\\"../../C.sol\\\";\\nimport {SafeMath} from \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport {SafeCast} from \\\"@openzeppelin/contracts/utils/SafeCast.sol\\\";\\nimport {LibBytes} from \\\"../LibBytes.sol\\\";\\nimport {LibPRBMath} from \\\"../LibPRBMath.sol\\\";\\nimport {LibTokenSilo} from \\\"./LibTokenSilo.sol\\\";\\nimport {LibSafeMath128} from \\\"../LibSafeMath128.sol\\\";\\nimport {LibSafeMathSigned96} from \\\"../LibSafeMathSigned96.sol\\\";\\n\\n/**\\n * @title LibSilo\\n * @author Publius\\n * @notice Contains functions for minting, burning, and transferring of\\n * Stalk and Roots within the Silo.\\n *\\n * @dev Here, we refer to \\\"minting\\\" as the combination of\\n * increasing the total balance of Stalk/Roots, as well as allocating\\n * them to a particular account. However, in other places throughout Beanstalk\\n * (like during the Sunrise), Beanstalk's total balance of Stalk increases\\n * without allocating to a particular account. One example is {Sun-rewardToSilo}\\n * which increases `s.s.stalk` but does not allocate it to any account. The\\n * allocation occurs during `{SiloFacet-plant}`. Does this change how we should\\n * call \\\"minting\\\"?\\n *\\n * In the ERC20 context, \\\"minting\\\" increases the supply of a token and allocates\\n * the new tokens to an account in one action. I've adjusted the comments below\\n * to use \\\"mint\\\" in the same sense.\\n */\\nlibrary LibSilo {\\n    using SafeMath for uint256;\\n    using LibSafeMath128 for uint128;\\n    using LibSafeMathSigned96 for int96;\\n    using LibPRBMath for uint256;\\n    using SafeCast for uint256;\\n    \\n    // The `VESTING_PERIOD` is the number of blocks that must pass before\\n    // a farmer is credited with their earned beans issued that season. \\n    uint256 internal constant VESTING_PERIOD = 10;\\n\\n    //////////////////////// EVENTS ////////////////////////    \\n     \\n    /**\\n     * @notice Emitted when `account` gains or loses Stalk.\\n     * @param account The account that gained or lost Stalk.\\n     * @param delta The change in Stalk.\\n     * @param deltaRoots The change in Roots.\\n     *   \\n     * @dev Should be emitted anytime a Deposit is added, removed or transferred\\n     * AND anytime an account Mows Grown Stalk.\\n     * \\n     * BIP-24 included a one-time re-emission of {StalkBalanceChanged} for\\n     * accounts that had executed a Deposit transfer between the Replant and\\n     * BIP-24 execution. For more, see:\\n     *\\n     * [BIP-24](https://bean.money/bip-24)\\n     * [Event-Emission](https://github.com/BeanstalkFarms/BIP-24-Event-Emission)\\n     */\\n    event StalkBalanceChanged(\\n        address indexed account,\\n        int256 delta,\\n        int256 deltaRoots\\n    );\\n\\n    /**\\n     * @notice Emitted when a deposit is removed from the silo.\\n     * \\n     * @param account The account assoicated with the removed deposit.\\n     * @param token The token address of the removed deposit.\\n     * @param stem The stem of the removed deposit.\\n     * @param amount The amount of \\\"token\\\" removed from an deposit.\\n     * @param bdv The instanteous bdv removed from the deposit.\\n     */\\n    event RemoveDeposit(\\n        address indexed account,\\n        address indexed token,\\n        int96 stem,\\n        uint256 amount,\\n        uint256 bdv\\n    );\\n\\n    /**\\n     * @notice Emitted when multiple deposits are removed from the silo.\\n     * \\n     * @param account The account assoicated with the removed deposit.\\n     * @param token The token address of the removed deposit.\\n     * @param stems A list of stems of the removed deposits.\\n     * @param amounts A list of amounts removed from the deposits.\\n     * @param amount the total summation of the amount removed.\\n     * @param bdvs A list of bdvs removed from the deposits.\\n     */\\n    event RemoveDeposits(\\n        address indexed account,\\n        address indexed token,\\n        int96[] stems,\\n        uint256[] amounts,\\n        uint256 amount,\\n        uint256[] bdvs\\n    );\\n\\n    struct AssetsRemoved {\\n        uint256 tokensRemoved;\\n        uint256 stalkRemoved;\\n        uint256 bdvRemoved;\\n    }\\n\\n    /**\\n     * @notice Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n     * transfers.\\n     */\\n    event TransferBatch(\\n        address indexed operator, \\n        address indexed from, \\n        address indexed to, \\n        uint256[] ids, \\n        uint256[] values\\n    );\\n\\n    //////////////////////// MINT ////////////////////////\\n\\n    /**\\n     * @dev Mints Stalk and Roots to `account`.\\n     *\\n     * `roots` are an underlying accounting variable that is used to track\\n     * how many earned beans a user has. \\n     * \\n     * When a farmer's state is updated, the ratio should hold:\\n     * \\n     *  Total Roots     User Roots\\n     * ------------- = ------------\\n     *  Total Stalk     User Stalk\\n     *  \\n     * @param account the address to mint Stalk and Roots to\\n     * @param stalk the amount of stalk to mint\\n     */\\n    function mintStalk(address account, uint256 stalk) internal {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n\\n        // Calculate the amount of Roots for the given amount of Stalk.\\n        uint256 roots;\\n        if (s.s.roots == 0) {\\n            roots = uint256(stalk.mul(C.getRootsBase()));\\n        } else {\\n            roots = s.s.roots.mul(stalk).div(s.s.stalk);\\n        }\\n        \\n        \\n        // increment user and total stalk\\n        s.s.stalk = s.s.stalk.add(stalk);\\n        s.a[account].s.stalk = s.a[account].s.stalk.add(stalk);\\n\\n        // increment user and total roots\\n        s.s.roots = s.s.roots.add(roots);\\n        s.a[account].roots = s.a[account].roots.add(roots);\\n\\n\\n        emit StalkBalanceChanged(account, int256(stalk), int256(roots));\\n    }\\n\\n\\n    /**\\n     * @dev mints grownStalk to `account`.\\n     * \\n     * per the zero-withdraw update, if a user plants during the vesting period (see constant),\\n     * the earned beans of the current season is deferred until the non vesting period.\\n     * However, this causes a slight mismatch in the amount of roots to properly allocate to the user.\\n     * \\n     * The formula for calculating the roots is:\\n     * GainedRoots = TotalRoots * GainedStalk / TotalStalk.\\n     * \\n     * Roots are utilized in {SiloExit.balanceOfEarnedBeans} to calculate the earned beans as such: \\n     * EarnedBeans = (TotalStalk * userRoots / TotalRoots) - userStalk  \\n     * \\n     * Because TotalStalk increments when there are new beans issued (at sunrise), \\n     * the amount of roots issued without the earned beans are:\\n     * GainedRoots = TotalRoots * GainedStalk / (TotalStalk - NewEarnedStalk)\\n     * \\n     * since newEarnedStalk is always equal or greater than 0, the gained roots calculated without the earned beans\\n     * will always be equal or larger than the gained roots calculated with the earned beans.\\n     * \\n     * @param account the address to mint Stalk and Roots to\\n     * @param stalk the amount of stalk to mint\\n     */\\n    function mintGrownStalk(address account, uint256 stalk) internal {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n\\n        uint256 roots;\\n        if (s.s.roots == 0) {\\n            roots = stalk.mul(C.getRootsBase());\\n        } else {\\n            roots = s.s.roots.mul(stalk).div(s.s.stalk);\\n            if (inVestingPeriod()) {\\n                // Safe Math is unnecessary for because total Stalk > new Earned Stalk\\n                uint256 rootsWithoutEarned = s.s.roots.add(s.vestingPeriodRoots).mul(stalk).div(s.s.stalk - s.newEarnedStalk);\\n                // Safe Math is unnecessary for because rootsWithoutEarned >= roots\\n                uint128 deltaRoots = (rootsWithoutEarned - roots).toUint128();\\n                s.vestingPeriodRoots = s.vestingPeriodRoots.add(deltaRoots);\\n                s.a[account].deltaRoots = deltaRoots;\\n            }\\n        }\\n\\n        // increment user and total stalk\\n        s.s.stalk = s.s.stalk.add(stalk);\\n        s.a[account].s.stalk = s.a[account].s.stalk.add(stalk);\\n\\n        // increment user and total roots\\n        s.s.roots = s.s.roots.add(roots);\\n        s.a[account].roots = s.a[account].roots.add(roots);\\n\\n        emit StalkBalanceChanged(account, int256(stalk), int256(roots));\\n    }\\n\\n    //////////////////////// BURN ////////////////////////\\n\\n    /**\\n     * @dev Burns Stalk and Roots from `account`.\\n     *\\n     * if the user withdraws in the vesting period, \\n     * they forfeit their earned beans for that season, \\n     * distrubuted to the other users.\\n     */\\n    function burnStalk(address account, uint256 stalk) internal {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n        if (stalk == 0) return;\\n       \\n        uint256 roots;\\n        // Calculate the amount of Roots for the given amount of Stalk.\\n        // We round up as it prevents an account having roots but no stalk.\\n        \\n        // if the user withdraws in the vesting period, they forfeit their earned beans for that season\\n        // this is distributed to the other users.\\n        if(inVestingPeriod()){\\n            roots = s.s.roots.mulDiv(\\n                stalk,\\n                s.s.stalk-s.newEarnedStalk,\\n                LibPRBMath.Rounding.Up\\n            );\\n            // cast to uint256 to prevent overflow\\n            uint256 deltaRootsRemoved = uint256(s.a[account].deltaRoots)\\n                .mul(stalk)\\n                .div(s.a[account].s.stalk);\\n            s.a[account].deltaRoots = s.a[account].deltaRoots.sub(deltaRootsRemoved.toUint128());\\n        } else {\\n            roots = s.s.roots.mulDiv(\\n            stalk,\\n            s.s.stalk,\\n            LibPRBMath.Rounding.Up);\\n        }\\n\\n        if (roots > s.a[account].roots) roots = s.a[account].roots;\\n\\n        // Decrease supply of Stalk; Remove Stalk from the balance of `account`\\n        s.s.stalk = s.s.stalk.sub(stalk);\\n        s.a[account].s.stalk = s.a[account].s.stalk.sub(stalk);\\n\\n        // Decrease supply of Roots; Remove Roots from the balance of `account`\\n        s.s.roots = s.s.roots.sub(roots);\\n        s.a[account].roots = s.a[account].roots.sub(roots);\\n        \\n        // Oversaturated was previously referred to as Raining and thus\\n        // code references mentioning Rain really refer to Oversaturation\\n        // If Beanstalk is Oversaturated, subtract Roots from both the\\n        // account's and Beanstalk's Oversaturated Roots balances.\\n        // For more info on Oversaturation, See {Weather.handleRain}\\n        if (s.season.raining) {\\n            s.r.roots = s.r.roots.sub(roots);\\n            s.a[account].sop.roots = s.a[account].roots;\\n        }\\n\\n        emit StalkBalanceChanged(account, -int256(stalk), -int256(roots));\\n    }\\n\\n    //////////////////////// TRANSFER ////////////////////////\\n\\n    /**\\n     * @notice Decrements the Stalk and Roots of `sender` and increments the Stalk\\n     * and Roots of `recipient` by the same amount.\\n     * \\n     * If the transfer is done during the vesting period, the earned beans are still\\n     * defered until after the vesting period has elapsed. \\n     * @dev There may be cases where more than the earned beans \\n     * of the current season is vested, but can be claimed after the v.e has ended.\\n     * We accept this inefficency due to \\n     * 1) the short vesting period.\\n     * 2) math complexity/gas costs needed to implement a correct solution.\\n     * 3) security risks.\\n     */\\n    function transferStalk(\\n        address sender,\\n        address recipient,\\n        uint256 stalk\\n    ) internal {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n        uint256 roots;\\n        if(inVestingPeriod()){\\n            // transferring all stalk means that the earned beans is transferred.\\n            // deltaRoots cannot be transferred as it is calculated on an account basis. \\n            if(stalk == s.a[sender].s.stalk){\\n                s.a[sender].deltaRoots = 0;\\n            } else {\\n                // partial transfer\\n                uint256 deltaRootsRemoved = uint256(s.a[sender].deltaRoots)\\n                    .mul(stalk)\\n                    .div(s.a[sender].s.stalk);\\n                s.a[sender].deltaRoots = s.a[sender].deltaRoots.sub(deltaRootsRemoved.toUint128());\\n            }\\n            roots = stalk == s.a[sender].s.stalk\\n                ? s.a[sender].roots\\n                : s.s.roots.sub(1).mul(stalk).div(s.s.stalk - s.newEarnedStalk).add(1);\\n        } else {\\n            roots = stalk == s.a[sender].s.stalk\\n            ? s.a[sender].roots\\n            : s.s.roots.sub(1).mul(stalk).div(s.s.stalk).add(1);\\n        }\\n\\n        // Subtract Stalk and Roots from the 'sender' balance.        \\n        s.a[sender].s.stalk = s.a[sender].s.stalk.sub(stalk);\\n        s.a[sender].roots = s.a[sender].roots.sub(roots);\\n        emit StalkBalanceChanged(sender, -int256(stalk), -int256(roots));\\n\\n        // Add Stalk and Roots to the 'recipient' balance.\\n        s.a[recipient].s.stalk = s.a[recipient].s.stalk.add(stalk);\\n        s.a[recipient].roots = s.a[recipient].roots.add(roots);\\n        emit StalkBalanceChanged(recipient, int256(stalk), int256(roots));\\n    }\\n\\n    /**\\n     * @dev Claims the Grown Stalk for `account` and applies it to their Stalk\\n     * balance. Also handles Season of Plenty related rain.\\n     *\\n     * This is why `_mow()` must be called before any actions that change Seeds,\\n     * including:\\n     *  - {SiloFacet-deposit}\\n     *  - {SiloFacet-withdrawDeposit}\\n     *  - {SiloFacet-withdrawDeposits}\\n     *  - {_plant}\\n     *  - {SiloFacet-transferDeposit(s)}\\n     */\\n   function _mow(address account, address token) internal {\\n\\n        require(!migrationNeeded(account), \\\"Silo: Migration needed\\\");\\n\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n        //sop stuff only needs to be updated once per season\\n        //if it started raininga nd it's still raining, or there was a sop\\n        if (s.season.rainStart > s.season.stemStartSeason) {\\n            uint32 lastUpdate = _lastUpdate(account);\\n            if (lastUpdate <= s.season.rainStart && lastUpdate <= s.season.current) {\\n                // Increments `plenty` for `account` if a Flood has occured.\\n                // Saves Rain Roots for `account` if it is Raining.\\n                handleRainAndSops(account, lastUpdate);\\n\\n                // Reset timer so that Grown Stalk for a particular Season can only be \\n                // claimed one time. \\n                s.a[account].lastUpdate = s.season.current;\\n            }\\n        }\\n        \\n        // Calculate the amount of Grown Stalk claimable by `account`.\\n        // Increase the account's balance of Stalk and Roots.\\n        __mow(account, token);\\n\\n        // was hoping to not have to update lastUpdate, but if you don't, then it's 0 for new depositors, this messes up mow and migrate in unit tests, maybe better to just set this manually for tests?\\n        // anyone that would have done any deposit has to go through mowSender which would have init'd it above zero in the pre-migration days\\n        s.a[account].lastUpdate = s.season.current;\\n    }\\n\\n    /**\\n     * @dev Updates the mowStatus for the given account and token, \\n     * and mints Grown Stalk for the given account and token.\\n     */\\n    function __mow(address account, address token) private {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n\\n        int96 _stemTip = LibTokenSilo.stemTipForToken(token);\\n        int96 _lastStem =  s.a[account].mowStatuses[token].lastStem;\\n        uint128 _bdv = s.a[account].mowStatuses[token].bdv;\\n        \\n        // if \\n        // 1: account has no bdv (new token deposit)\\n        // 2: the lastStem is the same as the stemTip (implying that a user has mowed),\\n        // then skip calculations to save gas.\\n        if (_bdv > 0) {\\n            if (_lastStem == _stemTip) {\\n                return;\\n            }\\n\\n            mintGrownStalk(\\n                account,\\n                _balanceOfGrownStalk(\\n                    _lastStem,\\n                    _stemTip,\\n                    _bdv\\n                )\\n            );\\n        }\\n\\n        // If this `account` has no BDV, skip to save gas. Still need to update lastStem \\n        // (happen on initial deposit, since mow is called before any deposit)\\n        s.a[account].mowStatuses[token].lastStem = _stemTip;\\n        return;\\n    }\\n\\n    /**\\n     * @notice returns the last season an account interacted with the silo.\\n     */\\n    function _lastUpdate(address account) internal view returns (uint32) {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n        return s.a[account].lastUpdate;\\n    }\\n\\n    /**\\n     * @dev internal logic to handle when beanstalk is raining.\\n     */\\n    function handleRainAndSops(address account, uint32 lastUpdate) private {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n        // If no roots, reset Sop counters variables\\n        if (s.a[account].roots == 0) {\\n            s.a[account].lastSop = s.season.rainStart;\\n            s.a[account].lastRain = 0;\\n            return;\\n        }\\n        // If a Sop has occured since last update, calculate rewards and set last Sop.\\n        if (s.season.lastSopSeason > lastUpdate) {\\n            s.a[account].sop.plenty = balanceOfPlenty(account);\\n            s.a[account].lastSop = s.season.lastSop;\\n        }\\n        if (s.season.raining) {\\n            // If rain started after update, set account variables to track rain.\\n            if (s.season.rainStart > lastUpdate) {\\n                s.a[account].lastRain = s.season.rainStart;\\n                s.a[account].sop.roots = s.a[account].roots;\\n            }\\n            // If there has been a Sop since rain started,\\n            // save plentyPerRoot in case another SOP happens during rain.\\n            if (s.season.lastSop == s.season.rainStart) {\\n                s.a[account].sop.plentyPerRoot = s.sops[s.season.lastSop];\\n            }\\n        } else if (s.a[account].lastRain > 0) {\\n            // Reset Last Rain if not raining.\\n            s.a[account].lastRain = 0;\\n        }\\n    }\\n\\n    /**\\n     * @dev returns the balance of amount of grown stalk based on stems.\\n     * @param lastStem the stem assoicated with the last mow\\n     * @param latestStem the current stem for a given token\\n     * @param bdv the bdv used to calculate grown stalk\\n     */\\n    function _balanceOfGrownStalk(\\n        int96 lastStem,\\n        int96 latestStem,\\n        uint128 bdv\\n    ) internal pure returns (uint256)\\n    {\\n        return stalkReward(lastStem, latestStem, bdv);\\n    } \\n\\n    /**\\n     * @dev returns the amount of `plenty` an account has.\\n     */\\n    function balanceOfPlenty(address account)\\n        internal\\n        view\\n        returns (uint256 plenty)\\n    {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n        Account.State storage a = s.a[account];\\n        plenty = a.sop.plenty;\\n        uint256 previousPPR;\\n\\n        // If lastRain > 0, then check if SOP occured during the rain period.\\n        if (s.a[account].lastRain > 0) {\\n            // if the last processed SOP = the lastRain processed season,\\n            // then we use the stored roots to get the delta.\\n            if (a.lastSop == a.lastRain) previousPPR = a.sop.plentyPerRoot;\\n            else previousPPR = s.sops[a.lastSop];\\n            uint256 lastRainPPR = s.sops[s.a[account].lastRain];\\n\\n            // If there has been a SOP duing the rain sesssion since last update, process SOP.\\n            if (lastRainPPR > previousPPR) {\\n                uint256 plentyPerRoot = lastRainPPR - previousPPR;\\n                previousPPR = lastRainPPR;\\n                plenty = plenty.add(\\n                    plentyPerRoot.mul(s.a[account].sop.roots).div(\\n                        C.SOP_PRECISION\\n                    )\\n                );\\n            }\\n        } else {\\n            // If it was not raining, just use the PPR at previous SOP.\\n            previousPPR = s.sops[s.a[account].lastSop];\\n        }\\n\\n        // Handle and SOPs that started + ended before after last Silo update.\\n        if (s.season.lastSop > _lastUpdate(account)) {\\n            uint256 plentyPerRoot = s.sops[s.season.lastSop].sub(previousPPR);\\n            plenty = plenty.add(\\n                plentyPerRoot.mul(s.a[account].roots).div(\\n                    C.SOP_PRECISION\\n                )\\n            );\\n        }\\n    }\\n\\n    //////////////////////// REMOVE ////////////////////////\\n\\n    /**\\n     * @dev Removes from a single Deposit, emits the RemoveDeposit event,\\n     * and returns the Stalk/BDV that were removed.\\n     *\\n     * Used in:\\n     * - {TokenSilo:_withdrawDeposit}\\n     * - {TokenSilo:_transferDeposit}\\n     */\\n    function _removeDepositFromAccount(\\n        address account,\\n        address token,\\n        int96 stem,\\n        uint256 amount,\\n        LibTokenSilo.Transfer transferType\\n    )\\n        internal\\n        returns (\\n            uint256 stalkRemoved,\\n            uint256 bdvRemoved\\n        )\\n    {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n\\n        bdvRemoved = LibTokenSilo.removeDepositFromAccount(account, token, stem, amount);\\n\\n        //need to get amount of stalk earned by this deposit (index of now minus index of when deposited)\\n        stalkRemoved = bdvRemoved.mul(s.ss[token].stalkIssuedPerBdv).add(\\n            stalkReward(\\n                stem, //this is the index of when it was deposited\\n                LibTokenSilo.stemTipForToken(token), //this is latest for this token\\n                bdvRemoved.toUint128()\\n            )\\n        );\\n        /** \\n         *  {_removeDepositFromAccount} is used for both withdrawing and transferring deposits.\\n         *  In the case of a withdraw, only the {TransferSingle} Event needs to be emitted.\\n         *  In the case of a transfer, a different {TransferSingle}/{TransferBatch} \\n         *  Event is emitted in {TokenSilo._transferDeposit(s)}, \\n         *  and thus, this event is ommited.\\n         */\\n        if(transferType == LibTokenSilo.Transfer.emitTransferSingle){\\n            // \\\"removing\\\" a deposit is equivalent to \\\"burning\\\" an ERC1155 token.\\n            emit LibTokenSilo.TransferSingle(\\n                msg.sender, // operator\\n                account, // from\\n                address(0), // to\\n                LibBytes.packAddressAndStem(token, stem), // depositid\\n                amount // token amount\\n            );\\n        }\\n        emit RemoveDeposit(account, token, stem, amount, bdvRemoved);\\n    }\\n\\n    /**\\n     * @dev Removes from multiple Deposits, emits the RemoveDeposits\\n     * event, and returns the Stalk/BDV that were removed.\\n     * \\n     * Used in:\\n     * - {TokenSilo:_withdrawDeposits}\\n     * - {SiloFacet:enrootDeposits}\\n     */\\n    function _removeDepositsFromAccount(\\n        address account,\\n        address token,\\n        int96[] calldata stems,\\n        uint256[] calldata amounts\\n    ) internal returns (AssetsRemoved memory ar) {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n\\n        //make bdv array and add here?\\n        uint256[] memory bdvsRemoved = new uint256[](stems.length);\\n        uint256[] memory removedDepositIDs = new uint256[](stems.length);\\n\\n        for (uint256 i; i < stems.length; ++i) {\\n            uint256 crateBdv = LibTokenSilo.removeDepositFromAccount(\\n                account,\\n                token,\\n                stems[i],\\n                amounts[i]\\n            );\\n            bdvsRemoved[i] = crateBdv;\\n            removedDepositIDs[i] = LibBytes.packAddressAndStem(token, stems[i]);\\n            ar.bdvRemoved = ar.bdvRemoved.add(crateBdv);\\n            ar.tokensRemoved = ar.tokensRemoved.add(amounts[i]);\\n\\n            ar.stalkRemoved = ar.stalkRemoved.add(\\n                stalkReward(\\n                    stems[i],\\n                    LibTokenSilo.stemTipForToken(token),\\n                    crateBdv.toUint128()\\n                )\\n            );\\n\\n        }\\n\\n        ar.stalkRemoved = ar.stalkRemoved.add(\\n            ar.bdvRemoved.mul(s.ss[token].stalkIssuedPerBdv)\\n        );\\n\\n        // \\\"removing\\\" deposits is equivalent to \\\"burning\\\" a batch of ERC1155 tokens.\\n        emit TransferBatch(msg.sender, account, address(0), removedDepositIDs, amounts);\\n        emit RemoveDeposits(account, token, stems, amounts, ar.tokensRemoved, bdvsRemoved);\\n    }\\n\\n    \\n    //////////////////////// UTILITIES ////////////////////////\\n\\n    /**\\n     * @dev Calculates the Stalk reward based on the start and end\\n     * stems, and the amount of BDV deposited. Stems represent the\\n     * amount of grown stalk per BDV, so the difference between the \\n     * start index and end index (stem) multiplied by the amount of\\n     * bdv deposited will give the amount of stalk earned.\\n     * formula: stalk = bdv * (\u0394stalkPerBdv)\\n     */\\n    function stalkReward(int96 startStem, int96 endStem, uint128 bdv) //are the types what we want here?\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        int96 reward = endStem.sub(startStem).mul(int96(bdv));\\n        \\n        return uint128(reward);\\n    }\\n\\n    /**\\n     * @dev check whether beanstalk is in the vesting period.\\n     */\\n    function inVestingPeriod() internal view returns (bool) {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n        return block.number - s.season.sunriseBlock <= VESTING_PERIOD;\\n    }\\n\\n    /**\\n     * @dev check whether the account needs to be migrated.\\n     */\\n    function migrationNeeded(address account) internal view returns (bool) {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n        return s.a[account].lastUpdate > 0 && s.a[account].lastUpdate < s.season.stemStartSeason;\\n    }\\n}\"\r\n    },\r\n    \"contracts/libraries/Silo/LibTokenSilo.sol\": {\r\n      \"content\": \"/**\\n * SPDX-License-Identifier: MIT\\n **/\\n\\npragma solidity =0.7.6;\\npragma experimental ABIEncoderV2;\\n\\nimport {SafeMath} from \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport {SafeCast} from \\\"@openzeppelin/contracts/utils/SafeCast.sol\\\";\\nimport \\\"../LibAppStorage.sol\\\";\\nimport \\\"../../C.sol\\\";\\nimport \\\"contracts/libraries/LibSafeMath32.sol\\\";\\nimport \\\"contracts/libraries/LibSafeMath128.sol\\\";\\nimport \\\"contracts/libraries/LibSafeMathSigned128.sol\\\";\\nimport \\\"contracts/libraries/LibSafeMathSigned96.sol\\\";\\nimport \\\"contracts/libraries/LibBytes.sol\\\";\\n\\n\\n/**\\n * @title LibTokenSilo\\n * @author Publius, Pizzaman1337\\n * @notice Contains functions for depositing, withdrawing and claiming\\n * whitelisted Silo tokens.\\n *\\n * For functionality related to Stalk, and Roots, see {LibSilo}.\\n */\\nlibrary LibTokenSilo {\\n    using SafeMath for uint256;\\n    using LibSafeMath128 for uint128;\\n    using LibSafeMath32 for uint32;\\n    using LibSafeMathSigned128 for int128;\\n    using SafeCast for int128;\\n    using SafeCast for uint256;\\n    using LibSafeMathSigned96 for int96;\\n\\n\\n    //////////////////////// ENUM ////////////////////////\\n    /**\\n     * @dev when a user deposits or withdraws a deposit, the\\n     * {TrasferSingle} event is emitted. However, in the case\\n     * of a transfer, this emission is ommited. This enum is\\n     * used to determine if the event should be emitted.\\n     */\\n    enum Transfer {\\n        emitTransferSingle,\\n        noEmitTransferSingle\\n    }\\n\\n    //////////////////////// EVENTS ////////////////////////\\n\\n    /**\\n     * @dev IMPORTANT: copy of {TokenSilo-AddDeposit}, check there for details.\\n     */\\n    event AddDeposit(\\n        address indexed account,\\n        address indexed token,\\n        int96 stem,\\n        uint256 amount,\\n        uint256 bdv\\n    );\\n\\n    // added as the ERC1155 deposit upgrade\\n    event TransferSingle(\\n        address indexed operator, \\n        address indexed sender, \\n        address indexed recipient, \\n        uint256 depositId, \\n        uint256 amount\\n    );\\n\\n\\n    //////////////////////// ACCOUNTING: TOTALS ////////////////////////\\n    \\n    /**\\n     * @dev Increment the total amount and bdv of `token` deposited in the Silo.\\n     */\\n    function incrementTotalDeposited(address token, uint256 amount, uint256 bdv) internal {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n        s.siloBalances[token].deposited = s.siloBalances[token].deposited.add(\\n            amount.toUint128()\\n        );\\n        s.siloBalances[token].depositedBdv = s.siloBalances[token].depositedBdv.add(\\n            bdv.toUint128()\\n        );\\n    }\\n\\n    /**\\n     * @dev Decrement the total amount and bdv of `token` deposited in the Silo.\\n     */\\n    function decrementTotalDeposited(address token, uint256 amount, uint256 bdv) internal {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n        s.siloBalances[token].deposited = s.siloBalances[token].deposited.sub(\\n            amount.toUint128()\\n        );\\n        s.siloBalances[token].depositedBdv = s.siloBalances[token].depositedBdv.sub(\\n            bdv.toUint128()\\n        );\\n    }\\n\\n    /**\\n     * @dev Increment the total bdv of `token` deposited in the Silo. Used in Enroot.\\n     */\\n    function incrementTotalDepositedBdv(address token, uint256 bdv) internal {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n        s.siloBalances[token].depositedBdv = s.siloBalances[token].depositedBdv.add(\\n            bdv.toUint128()\\n        );\\n    }\\n\\n    //////////////////////// ADD DEPOSIT ////////////////////////\\n\\n    /**\\n     * @return stalk The amount of Stalk received for this Deposit.\\n     * \\n     * @dev Calculate the current BDV for `amount` of `token`, then perform \\n     * Deposit accounting.\\n     */\\n    function deposit(\\n        address account,\\n        address token,\\n        int96 stem,\\n        uint256 amount\\n    ) internal returns (uint256) {\\n        uint256 bdv = beanDenominatedValue(token, amount);\\n        return depositWithBDV(account, token, stem, amount, bdv);\\n    }\\n\\n    /**\\n     * @dev Once the BDV received for Depositing `amount` of `token` is known, \\n     * add a Deposit for `account` and update the total amount Deposited.\\n     *\\n     * `s.ss[token].stalkIssuedPerBdv` stores the number of Stalk per BDV for `token`.\\n     */\\n    function depositWithBDV(\\n        address account,\\n        address token,\\n        int96 stem,\\n        uint256 amount,\\n        uint256 bdv\\n    ) internal returns (uint256 stalk) {\\n        require(bdv > 0, \\\"Silo: No Beans under Token.\\\");\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n        \\n        incrementTotalDeposited(token, amount, bdv);\\n        addDepositToAccount(\\n            account, \\n            token, \\n            stem, \\n            amount, \\n            bdv, \\n            Transfer.emitTransferSingle  \\n        ); \\n        stalk = bdv.mul(s.ss[token].stalkIssuedPerBdv);\\n    }\\n\\n    /**\\n     * @dev Add `amount` of `token` to a user's Deposit in `stemTipForToken`. Requires a\\n     * precalculated `bdv`.\\n     *\\n     * If a Deposit doesn't yet exist, one is created. Otherwise, the existing\\n     * Deposit is updated.\\n     * \\n     * `amount` & `bdv` are downcasted uint256 -> uint128 to optimize storage cost,\\n     * since both values can be packed into one slot.\\n     * \\n     * Unlike {removeDepositFromAccount}, this function DOES EMIT an \\n     * {AddDeposit} event. See {removeDepositFromAccount} for more details.\\n     */\\n    function addDepositToAccount(\\n        address account,\\n        address token,\\n        int96 stem,\\n        uint256 amount,\\n        uint256 bdv,\\n        Transfer transferType\\n    ) internal {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n        uint256 depositId = LibBytes.packAddressAndStem(\\n            token,\\n            stem\\n        );\\n\\n        // add amount to the deposits, and update the deposit.\\n        s.a[account].deposits[depositId].amount = \\n            s.a[account].deposits[depositId].amount.add(amount.toUint128());\\n        s.a[account].deposits[depositId].bdv = \\n            s.a[account].deposits[depositId].bdv.add(bdv.toUint128());\\n        \\n        // update the mow status (note: mow status is per token, not per depositId)\\n        // SafeMath not necessary as the bdv is already checked to be <= type(uint128).max\\n        s.a[account].mowStatuses[token].bdv = uint128(s.a[account].mowStatuses[token].bdv.add(uint128(bdv)));\\n\\n        /** \\n         *  {addDepositToAccount} is used for both depositing and transferring deposits.\\n         *  In the case of a deposit, only the {TransferSingle} Event needs to be emitted.\\n         *  In the case of a transfer, a different {TransferSingle}/{TransferBatch} \\n         *  Event is emitted in {TokenSilo._transferDeposit(s)}, \\n         *  and thus, this event is ommited.\\n         */\\n        if(transferType == Transfer.emitTransferSingle){\\n            emit TransferSingle(\\n                msg.sender, // operator\\n                address(0), // from\\n                account, // to\\n                uint256(depositId), // depositID\\n                amount // token amount\\n            );\\n        }\\n        emit AddDeposit(account, token, stem, amount, bdv);\\n    }\\n\\n    //////////////////////// REMOVE DEPOSIT ////////////////////////\\n\\n    /**\\n     * @dev Remove `amount` of `token` from a user's Deposit in `stem`.\\n     *\\n     * A \\\"Crate\\\" refers to the existing Deposit in storage at:\\n     *  `s.a[account].deposits[token][stem]`\\n     *\\n     * Partially removing a Deposit should scale its BDV proportionally. For ex.\\n     * removing 80% of the tokens from a Deposit should reduce its BDV by 80%.\\n     *\\n     * During an update, `amount` & `bdv` are cast uint256 -> uint128 to\\n     * optimize storage cost, since both values can be packed into one slot.\\n     *\\n     * This function DOES **NOT** EMIT a {RemoveDeposit} event. This\\n     * asymmetry occurs because {removeDepositFromAccount} is called in a loop\\n     * in places where multiple deposits are removed simultaneously, including\\n     * {TokenSilo-removeDepositsFromAccount} and {TokenSilo-_transferDeposits}.\\n     */\\n\\n    function removeDepositFromAccount(\\n        address account,\\n        address token,\\n        int96 stem,\\n        uint256 amount\\n    ) internal returns (uint256 crateBDV) {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n        uint256 depositId = LibBytes.packAddressAndStem(token,stem);\\n\\n        uint256 crateAmount = s.a[account].deposits[depositId].amount;\\n        crateBDV = s.a[account].deposits[depositId].bdv;\\n\\n        require(amount <= crateAmount, \\\"Silo: Crate balance too low.\\\");\\n\\n        // Partial remove\\n        if (amount < crateAmount) {\\n            uint256 removedBDV = amount.mul(crateBDV).div(crateAmount);\\n            uint256 updatedBDV = crateBDV.sub(removedBDV);\\n            uint256 updatedAmount = crateAmount.sub(amount);\\n\\n            // SafeCast unnecessary b/c updatedAmount <= crateAmount and updatedBDV <= crateBDV, which are both <= type(uint128).max\\n            s.a[account].deposits[depositId].amount = uint128(updatedAmount);\\n            s.a[account].deposits[depositId].bdv = uint128(updatedBDV);\\n            //remove from the mow status bdv amount, which keeps track of total token deposited per farmer\\n            s.a[account].mowStatuses[token].bdv = s.a[account].mowStatuses[token].bdv.sub(\\n                removedBDV.toUint128()\\n            );\\n            return removedBDV;\\n        }\\n        // Full remove\\n        if (crateAmount > 0) delete s.a[account].deposits[depositId];\\n\\n\\n        // SafeMath unnecessary b/c crateBDV <= type(uint128).max\\n        s.a[account].mowStatuses[token].bdv = s.a[account].mowStatuses[token].bdv.sub(\\n            uint128(crateBDV)\\n        );\\n    }\\n\\n    //////////////////////// GETTERS ////////////////////////\\n\\n    /**\\n     * @dev Calculate the BDV (\\\"Bean Denominated Value\\\") for `amount` of `token`.\\n     * \\n     * Makes a call to a BDV function defined in the SiloSettings for this \\n     * `token`. See {AppStorage.sol:Storage-SiloSettings} for more information.\\n     */\\n    function beanDenominatedValue(address token, uint256 amount)\\n        internal\\n        view\\n        returns (uint256 bdv)\\n    {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n        require(s.ss[token].selector != bytes4(0), \\\"Silo: Token not whitelisted\\\");\\n\\n        (bool success, bytes memory data) = address(this).staticcall(\\n            encodeBdvFunction(\\n                token,\\n                s.ss[token].encodeType,\\n                s.ss[token].selector,\\n                amount\\n            )\\n        );\\n\\n        if (!success) {\\n            if (data.length == 0) revert();\\n            assembly {\\n                revert(add(32, data), mload(data))\\n            }\\n        }\\n\\n        assembly {\\n            bdv := mload(add(data, add(0x20, 0)))\\n        }\\n    }\\n\\n    function encodeBdvFunction(\\n        address token,\\n        bytes1 encodeType,\\n        bytes4 selector,\\n        uint256 amount\\n    )\\n        internal\\n        pure\\n        returns (bytes memory callData)\\n    {\\n        if (encodeType == 0x00) {\\n            callData = abi.encodeWithSelector(\\n                selector,\\n                amount\\n            );\\n        } else if (encodeType == 0x01) {\\n            callData = abi.encodeWithSelector(\\n                selector,\\n                token,\\n                amount\\n            );\\n        } else {\\n            revert(\\\"Silo: Invalid encodeType\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Locate the `amount` and `bdv` for a user's Deposit in storage.\\n     * \\n     * Silo V3 Deposits are stored within each {Account} as a mapping of:\\n     *  `uint256 DepositID => { uint128 amount, uint128 bdv }`\\n     *  The DepositID is the concatination of the token address and the stem.\\n     * \\n     * Silo V2 deposits are only usable after a successful migration, see\\n     * mowAndMigrate within the Migration facet.\\n     *\\n     */\\n    function getDeposit(\\n        address account,\\n        address token,\\n        int96 stem\\n    ) internal view returns (uint256 amount, uint256 bdv) {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n        uint256 depositId = LibBytes.packAddressAndStem(\\n            token,\\n            stem\\n        );\\n        amount = s.a[account].deposits[depositId].amount;\\n        bdv = s.a[account].deposits[depositId].bdv;\\n    }\\n    \\n    /**\\n     * @dev Get the number of Stalk per BDV per Season for a whitelisted token. Formerly just seeds.\\n     * Note this is stored as 1e6, i.e. 1_000_000 units of this is equal to 1 old seed.\\n     */\\n    function stalkEarnedPerSeason(address token) internal view returns (uint256) {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n        return uint256(s.ss[token].stalkEarnedPerSeason);\\n    }\\n\\n    /**\\n     * @dev Get the number of Stalk per BDV for a whitelisted token. Formerly just stalk.\\n     */\\n    function stalkIssuedPerBdv(address token) internal view returns (uint256) {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n        return uint256(s.ss[token].stalkIssuedPerBdv);\\n    }\\n\\n    /**\\n     * @dev returns the cumulative stalk per BDV (stemTip) for a whitelisted token.\\n     */\\n    function stemTipForToken(address token)\\n        internal\\n        view\\n        returns (int96 _stemTipForToken)\\n    {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n        \\n        // SafeCast unnecessary because all casted variables are types smaller that int96.\\n        _stemTipForToken = s.ss[token].milestoneStem +\\n        int96(s.ss[token].stalkEarnedPerSeason).mul(\\n            int96(s.season.current).sub(int96(s.ss[token].milestoneSeason))\\n        ).div(1e6); //round here \\n    }\\n\\n    /**\\n     * @dev returns the amount of grown stalk a deposit has earned.\\n     */\\n    function grownStalkForDeposit(\\n        address account,\\n        address token,\\n        int96 stem\\n    )\\n        internal\\n        view\\n        returns (uint grownStalk)\\n    {\\n        // stemTipForToken(token) > depositGrownStalkPerBdv for all valid Deposits\\n        int96 _stemTip = stemTipForToken(token);\\n        require(stem <= _stemTip, \\\"Silo: Invalid Deposit\\\");\\n         // The check in the above line guarantees that subtraction result is positive\\n         // and thus the cast to `uint256` is safe.\\n        uint deltaStemTip = uint256(_stemTip.sub(stem));\\n        (, uint bdv) = getDeposit(account, token, stem);\\n\\n        grownStalk = deltaStemTip.mul(bdv);\\n    }\\n\\n    /**\\n     * @dev returns the amount of grown stalk a deposit would have, based on the stem of the deposit.\\n     */\\n    function calculateStalkFromStemAndBdv(address token, int96 grownStalkIndexOfDeposit, uint256 bdv)\\n        internal\\n        view\\n        returns (int96 grownStalk)\\n    {\\n        // current latest grown stalk index\\n        int96 _stemTipForToken = stemTipForToken(address(token));\\n\\n        return _stemTipForToken.sub(grownStalkIndexOfDeposit).mul(toInt96(bdv));\\n    }\\n\\n    /**\\n     * @dev returns the stem of a deposit, based on the amount of grown stalk it has earned.\\n     */\\n    function calculateGrownStalkAndStem(address token, uint256 grownStalk, uint256 bdv)\\n        internal\\n        view \\n        returns (uint256 _grownStalk, int96 stem)\\n    {\\n        int96 _stemTipForToken = stemTipForToken(token);\\n        stem = _stemTipForToken.sub(toInt96(grownStalk.div(bdv)));\\n        _grownStalk = uint256(_stemTipForToken.sub(stem).mul(toInt96(bdv)));\\n    }\\n\\n\\n    /**\\n     * @dev returns the amount of grown stalk a deposit would have, based on the stem of the deposit.\\n     * Similar to calculateStalkFromStemAndBdv, but has an additional check to prevent division by 0.\\n     */\\n    function grownStalkAndBdvToStem(address token, uint256 grownStalk, uint256 bdv)\\n        internal\\n        view\\n        returns (int96 cumulativeGrownStalk)\\n    {\\n        // first get current latest grown stalk index\\n        int96 _stemTipForToken = stemTipForToken(token);\\n        // then calculate how much stalk each individual bdv has grown\\n        // there's a > 0 check here, because if you have a small amount of unripe bean deposit, the bdv could\\n        // end up rounding to zero, then you get a divide by zero error and can't migrate without losing that deposit\\n\\n        // prevent divide by zero error\\n        int96 grownStalkPerBdv = bdv > 0 ? toInt96(grownStalk.div(bdv)) : 0;\\n\\n        // subtract from the current latest index, so we get the index the deposit should have happened at\\n        return _stemTipForToken.sub(grownStalkPerBdv);\\n    }\\n\\n    function toInt96(uint256 value) internal pure returns (int96) {\\n        require(value <= uint256(type(int96).max), \\\"SafeCast: value doesn't fit in an int96\\\");\\n        return int96(value);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/Silo/LibUnripeSilo.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity =0.7.6;\\npragma experimental ABIEncoderV2;\\n\\nimport {SafeMath} from \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport {AppStorage, LibAppStorage, Account} from \\\"../LibAppStorage.sol\\\";\\nimport {LibSafeMath128} from \\\"../LibSafeMath128.sol\\\";\\nimport {C} from \\\"contracts/C.sol\\\";\\n\\n/**\\n * @title LibUnripeSilo\\n * @author Publius\\n * @notice Contains functions for interacting with Unripe Silo deposits.\\n * Provides a unified interface that works across legacy storage references.\\n * \\n * @dev Beanstalk was exploited on April 17, 2022. All tokens that existed at\\n * this time, including whitelisted LP tokens, are now defunct and referred to \\n * as \\\"legacy\\\" or \\\"pre-exploit\\\" tokens.\\n *\\n * Legacy token addresses are listed here:\\n * https://docs.bean.money/almanac/protocol/contracts#pre-exploit-contracts\\n *\\n * When Beanstalk was Replanted on Aug 6, 2022, new two tokens \u2014\u00a0Unripe Bean and \\n * Unripe BEAN:3CRV \u2014 were created and whitelisted in the Silo. See {Replant8-init}.\\n * \\n * At the time of exploit, there were three forms of LP whitelisted in the Silo:\\n * BEAN:ETH, BEAN:3CRV, and BEAN:LUSD. However, only one LP token was created\\n * during the Replant: BEAN:3CRV (at a new address). \\n * \\n * Existing Bean and LP Depositors were credited with Unripe Bean Deposits and \\n * Unripe BEAN:3CRV Deposits respectively, equal to the BDV of each Deposit\\n * at the end of the pre-exploit block.\\n * \\n * {Replant7-init} migrated the Deposits through events by emitting:\\n *  1. {RemoveSeason(s)} or {LPRemove} for Bean and LP Deposits\\n *  2. {AddDeposit} for Unripe Bean and Unripe LP distributions\\n * \\n * This operation was performed for all accounts with Silo Deposits to prevent\\n * users from being required to perform a manual migration (and thus pay gas).\\n * \\n * However, moving all on-chain Bean Deposit storage variables to the Silo V2 \\n * storage mapping during {Replant7-init} was prohibitively expensive.\\n *\\n * This library remaps pre-exploit Bean and LP Deposit storage references to\\n * Unripe Bean and Unripe BEAN:3CRV Deposits. New Unripe Bean and Unripe \\n * BEAN:3CRV Deposits are stored in the expected Silo V2 storage location.\\n */\\nlibrary LibUnripeSilo {\\n    using SafeMath for uint256;\\n    using LibSafeMath128 for uint128;\\n\\n    /*\\n     * The values below represent the {LibTokenSilo-beanDenominatedValue} of \\n     * each pre-exploit LP token at the end of Block 14602789 (the block before \\n     * the exploit).\\n     * \\n     * {LibUnripeSilo} uses these constants to migrate pre-exploit LP Deposits.\\n     * \\n     * Note that the BDV of BEAN itself is always 1, hence why only LP tokens\\n     * appear below.\\n     */\\n    \\n    uint256 private constant AMOUNT_TO_BDV_BEAN_ETH = 119_894_802_186_829; // 18 decimal precision\\n    uint256 private constant AMOUNT_TO_BDV_BEAN_3CRV = 992_035; // 6 decimal precision\\n    uint256 private constant AMOUNT_TO_BDV_BEAN_LUSD = 983_108; // 6 decimal precision\\n\\n    //////////////////////// Unripe BEAN ////////////////////////\\n\\n    /*\\n     * Unripe Bean Deposits stored in the Silo V1 Bean storage reference have\\n     * not yet been Enrooted, as Enrooting moves the Deposit into the Unripe Bean\\n     * Silo V2 storage reference (See {SiloFacet-enrootDeposit(s)}).\\n     * \\n     * Thus, the BDV of Unripe Bean Deposits stored in the Silo V1 Bean storage \\n     * is equal to the amount deposited times the initial % recapitalized when \\n     * Beanstalk was Replanted.\\n     *\\n     * As Beanstalk continues to recapitalize, users can call \\n     * {SiloFacet-enrootDeposit(s)} to update the BDV of their Unripe Deposits. \\n     */\\n\\n    /**\\n     * @dev Removes all Unripe Beans deposited stored in `account` legacy \\n     * Silo V1 storage and returns the BDV.\\n     *\\n     * Since Deposited Beans have a BDV of 1, 1 Bean in Silo V1 storage equals\\n     * 1 Unripe Bean. \\n     */\\n    function removeLegacyUnripeBeanDeposit(\\n        address account,\\n        uint32 season\\n    ) internal {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n        delete s.a[account].bean.deposits[season];\\n    }\\n\\n    /**\\n     * @dev Returns true if the provided address is the Unripe Bean address.\\n     */\\n    function isUnripeBean(address token) internal pure returns (bool b) {\\n        b = token == C.UNRIPE_BEAN;\\n    }\\n\\n    /**\\n     * @dev Calculate the `amount` and `bdv` of an Unripe Bean deposit. Sums\\n     * across the amounts stored in Silo V1 and Silo V2 storage.\\n     * \\n     * This is Unripe Bean equivalent of {LibTokenSilo-tokenDeposit}.\\n     */\\n    function unripeBeanDeposit(address account, uint32 season)\\n        internal\\n        view\\n        returns (uint256 amount, uint256 bdv)\\n    {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n        uint256 legacyAmount = s.a[account].bean.deposits[season];\\n        \\n        // Sum the `account` pre-exploit Silo V1 Bean Balance \\n        // and the Silo V2 Unripe Bean Balance\\n        amount = uint256(\\n            s.a[account].legacyDeposits[C.UNRIPE_BEAN][season].amount\\n        ).add(legacyAmount);\\n        \\n        // Sum the BDV of the `account` pre-exploit Silo V1 Bean Balance \\n        // and the BDV value stored in the Unripe Bean Silo V2 storage reference.\\n        //\\n        // The BDV of the Silo V1 Bean Balance is equal to the amount of Beans\\n        // (where 1 Bean = 1 BDV) times the initial recapitalization percent.\\n        bdv = uint256(s.a[account].legacyDeposits[C.UNRIPE_BEAN][season].bdv)\\n            .add(legacyAmount.mul(C.initialRecap()).div(1e18));\\n        \\n    }\\n    //////////////////////// Unripe LP ////////////////////////\\n\\n    /*\\n     * Unripe LP Deposits stored in the pre-exploit Bean:LUSD and BEAN:3CRV Silo\\n     * V2 and the BEAN:ETH legacy Silo V1 storage have not been Enrooted, as\\n     * Enrooting moves the Deposit into the Unripe BEAN:3CRV Silo V2 storage \\n     * reference (See {SiloFacet.enrootDeposit(s)}).\\n     * \\n     * Thus, the BDV of Unripe BEAN:3CRV Deposits stored in the Silo V1 Bean\\n     * storage is equal to the BDV of the amount of token times initial\\n     * % recapitalized when Beanstalk was Replanted.\\n     */\\n\\n    /**\\n     * @dev Removes all Unripe BEAN:3CRV stored in _any_ of the\\n     * pre-exploit LP Token Silo storage mappings and returns the BDV. \\n     *\\n     * \\n     * 1. Silo V1 format, pre-exploit BEAN:ETH LP token\\n     * 2. Silo V2 format, pre-exploit BEAN:3CRV LP token\\n     * 3. Silo V2 format, pre-exploit BEAN:LUSD LP token\\n     */\\n    function removeLegacyUnripeLPDeposit(\\n        address account,\\n        uint32 season\\n    ) internal {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n        delete s.a[account].lp.depositSeeds[season];\\n        delete s.a[account].lp.deposits[season];\\n        delete s.a[account].legacyDeposits[C.unripeLPPool1()][season];\\n        delete s.a[account].legacyDeposits[C.unripeLPPool2()][season];\\n    }\\n\\n    /**1000000000000000017348\\n     * @dev Returns true if the provided address is the Unripe LP token address.\\n     */\\n    function isUnripeLP(address token) internal pure returns (bool b) {\\n        b = token == C.UNRIPE_LP;\\n    }\\n\\n    /**\\n     * @dev Calculate the `amount` and `bdv` of a given Unripe BEAN:3CRV deposit.\\n     *\\n     * This is Unripe LP equivalent of {LibTokenSilo-tokenDeposit}.\\n     */\\n    function unripeLPDeposit(address account, uint32 season)\\n        internal\\n        view\\n        returns (uint256 amount, uint256 bdv)\\n    {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n        \\n        // Fetch the amount and BDV stored in all 3 pre-exploit LP Silo Deposit storages.\\n        // See {getBeanEthUnripeLP}, {getBean3CrvUnripeLP} and {getBeanLusdUnripeLP}\\n        (amount, bdv) = getBeanEthUnripeLP(account, season);\\n        (uint256 amount1, uint256 bdv1) = getBean3CrvUnripeLP(account, season);\\n        (uint256 amount2, uint256 bdv2) = getBeanLusdUnripeLP(account, season);\\n\\n        // Summate the amount acrosses all 4 potential Unripe BEAN:3CRV storage locations.\\n        amount = uint256(\\n            s.a[account].legacyDeposits[C.UNRIPE_LP][season].amount\\n        ).add(amount.add(amount1).add(amount2));\\n        \\n        // Summate the BDV acrosses all 3 pre-exploit LP Silo Deposit storages\\n        // and haircut by the inital recapitalization percent.\\n        uint256 legBdv = bdv.add(bdv1).add(bdv2)\\n            .mul(C.initialRecap())\\n            .div(C.precision());\\n        \\n        // Summate the pre-exploit legacy BDV and the BDV stored in the\\n        // Unripe BEAN:3CRV Silo Deposit storage.\\n        bdv = uint256(\\n            s.a[account].legacyDeposits[C.UNRIPE_LP][season].bdv\\n        ).add(legBdv);\\n        \\n    }\\n\\n    /*\\n     * For the following `get*LP()` functions, make note:\\n     * \\n     * @return amount The amount of _Unripe LP_ associated with the pre-exploit \\n     * Deposit. Does NOT equal the amount of tokens in the Deposit. Instead,\\n     * this equals the BDV of all tokens in in this Deposit _at the block \\n     * Beanstalk was exploited_.\\n     * @return bdv The BDV contained in the pre-exploit Deposit.\\n     */\\n\\n    /**\\n     * @dev Calculate the `amount` and `bdv` for a Unripe LP deposit stored in\\n     * the pre-exploit BEAN:ETH storage location (Silo V1 format).\\n     *\\n     * Note: In Silo V1, Beanstalk stored the number of Seeds associated with a \\n     * BEAN:ETH LP Deposit instead of the BDV. BDV was then derived as \\n     * `seeds / 4`. \\n     * \\n     * The legacy BEAN:ETH LP token had a precision of 18 decimals.\\n     */\\n    function getBeanEthUnripeLP(address account, uint32 season)\\n        private\\n        view\\n        returns (uint256 amount, uint256 bdv)\\n    {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n        bdv = s.a[account].lp.depositSeeds[season].div(4);\\n\\n        // `amount` is equal to the pre-exploit BDV of the Deposited BEAN:ETH\\n        // tokens. This is the equivalent amount of Unripe BEAN:3CRV LP.\\n        amount = s\\n            .a[account]\\n            .lp\\n            .deposits[season]\\n            .mul(AMOUNT_TO_BDV_BEAN_ETH)\\n            .div(1e18);\\n    }\\n\\n    /**\\n     * @dev Calculate the `amount` and `bdv` for a Unripe LP deposit stored in\\n     * the pre-exploit BEAN:LUSD storage location (Silo V2 format).\\n     * \\n     * The legacy BEAN:LUSD LP token had a precision of 18 decimals.\\n     */\\n    function getBeanLusdUnripeLP(address account, uint32 season)\\n        private\\n        view\\n        returns (uint256 amount, uint256 bdv)\\n    {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n        bdv = uint256(s.a[account].legacyDeposits[C.unripeLPPool2()][season].bdv);\\n\\n        // `amount` is equal to the pre-exploit BDV of the Deposited BEAN:LUSD\\n        // tokens. This is the equivalent amount of Unripe BEAN:3CRV LP.\\n        amount = uint256(\\n            s.a[account].legacyDeposits[C.unripeLPPool2()][season].amount\\n        ).mul(AMOUNT_TO_BDV_BEAN_LUSD).div(C.precision());\\n    }\\n\\n    /**\\n     * @dev Calculate the `amount` and `bdv` for a Unripe LP deposit stored in \\n     * the pre-exploit BEAN:3CRV storage location (Silo V2 format).\\n     * \\n     * The legacy BEAN:3CRV LP token had a precision of 18 decimals.\\n     */\\n    function getBean3CrvUnripeLP(address account, uint32 season)\\n        private\\n        view\\n        returns (uint256 amount, uint256 bdv)\\n    {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n        bdv = uint256(s.a[account].legacyDeposits[C.unripeLPPool1()][season].bdv);\\n\\n        // `amount` is equal to the pre-exploit BDV of the Deposited BEAN:3CRV\\n        // tokens. This is the equivalent amount of Unripe BEAN:3CRV LP.\\n        amount = uint256(\\n            s.a[account].legacyDeposits[C.unripeLPPool1()][season].amount\\n        ).mul(AMOUNT_TO_BDV_BEAN_3CRV).div(C.precision());\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"int96\",\"name\":\"stem\",\"type\":\"int96\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bdv\",\"type\":\"uint256\"}],\"name\":\"RemoveDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"int96[]\",\"name\":\"stems\",\"type\":\"int96[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"bdvs\",\"type\":\"uint256[]\"}],\"name\":\"RemoveDeposits\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"int96\",\"name\":\"stem\",\"type\":\"int96\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"enrootDeposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"int96[]\",\"name\":\"stems\",\"type\":\"int96[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"enrootDeposits\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}]", "ContractName": "EnrootFacet", "CompilerVersion": "v0.7.6+commit.7338295f", "OptimizationUsed": "1", "Runs": "1000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}