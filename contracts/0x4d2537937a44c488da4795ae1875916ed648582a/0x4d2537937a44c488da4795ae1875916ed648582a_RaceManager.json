{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/RaceManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity >=0.8.18;\\n\\nimport \\\"solmate/auth/Owned.sol\\\";\\nimport \\\"solmate/tokens/ERC20.sol\\\";\\nimport \\\"solmate/utils/SafeTransferLib.sol\\\";\\nimport \\\"./interfaces/IHotWheels.sol\\\";\\n\\n// Errors\\nerror NoActiveRace();\\nerror ActiveRace();\\nerror RaceDataMismatch();\\nerror BettingStillActive();\\nerror AlreadyPlacedBet();\\nerror AlreadyClaimed();\\nerror DidntParticipate();\\nerror DidntWin();\\nerror InvalidLane();\\nerror MissingTokenApproval();\\nerror NotEnoughTokens();\\nerror BettingEndedAlready();\\nerror InvalidRaceId();\\nerror InvalidToken();\\nerror InvalidHouse();\\nerror NotEnoughInPool();\\n\\n// Data structures\\nstruct BetData {\\n    bool claimed;\\n    uint8 lane;\\n    uint256 amount;\\n}\\n\\nstruct RaceData {\\n    bool active;\\n    bool bettingActive;\\n    bool houseWithdrew;\\n    uint8 winningLane;\\n    uint256 totalBet;\\n}\\n\\ncontract RaceManager is Owned {\\n    // Constants\\n    IHotWheels public immutable token;\\n    address public immutable house;\\n\\n    // Race data\\n    uint32 public currentRace = 0;\\n    uint32 public lastRace = 0;\\n    RaceData[] public raceData;\\n\\n    // Betting data\\n    mapping(uint32 => mapping(address => BetData)) public betData;\\n    mapping(uint32 => address[]) public bettors;\\n    mapping(address => uint32) public totalBetsMade;\\n    mapping(uint32 => mapping(uint8 => uint256)) public betPerRacePerLane;\\n\\n    // Winnings data\\n    uint256 public totalAmountWon = 0;\\n\\n    // Events\\n    event RaceStarted(uint32 raceId);\\n    event BetAdded(uint32 raceId, address addr, uint8 lane, uint256 amount);\\n    event BettingEnded(uint32 raceId);\\n    event RaceEnded(uint32 raceId, uint8 winningLane);\\n\\n    // Modifiers\\n    modifier needsActiveRace() {\\n        if (currentRace == 0) revert NoActiveRace();\\n        _;\\n    }\\n\\n    modifier noActiveRace() {\\n        if (currentRace > 0) revert ActiveRace();\\n        _;\\n    }\\n\\n    // Functionality\\n    constructor(address tokenContract, address houseWallet) Owned(msg.sender) {\\n        if (tokenContract == address(0x0)) revert InvalidToken();\\n        if (houseWallet == address(0x0)) revert InvalidHouse();\\n\\n        // Initialize bettors to fix slither uninitialized-state\\n        bettors[0] = [address(0)];\\n\\n        token = IHotWheels(payable(tokenContract));\\n        house = houseWallet;\\n    }\\n\\n    receive() external payable {}\\n    fallback() external payable {}\\n\\n    function betRace(uint8 lane, uint256 amount) external needsActiveRace {\\n        if (token.balanceOf(msg.sender) < amount) revert NotEnoughTokens();\\n        if (token.allowance(msg.sender, address(this)) < amount) revert MissingTokenApproval();\\n        if (lane == 0 || lane > 6) revert InvalidLane();\\n\\n        address bettor = msg.sender;\\n        uint32 raceId = currentRace;\\n\\n        address[] storage raceBettors = bettors[raceId - 1];\\n        BetData storage data = betData[raceId - 1][bettor];\\n        RaceData storage race = raceData[raceId - 1];\\n\\n        if (!race.bettingActive) revert BettingEndedAlready();\\n        if (data.lane > 0 || data.amount > 0) revert AlreadyPlacedBet();\\n\\n        betData[raceId - 1][bettor] = BetData(false, lane, amount);\\n        betPerRacePerLane[raceId - 1][lane] += amount;\\n        race.totalBet += amount;\\n\\n        totalBetsMade[msg.sender] += 1;\\n        raceBettors.push(msg.sender);\\n\\n        SafeTransferLib.safeTransferFrom(ERC20(address(token)), bettor, address(this), amount);\\n\\n        emit BetAdded(raceId, bettor, lane, amount);\\n    }\\n\\n    function claimWinnings(uint32 raceId) public {\\n        if (raceId > raceData.length) revert InvalidRaceId();\\n\\n        address bettor = msg.sender;\\n        BetData storage data = betData[raceId - 1][bettor];\\n        RaceData storage race = raceData[raceId - 1];\\n\\n        uint8 lane = data.lane;\\n\\n        if (data.claimed) revert AlreadyClaimed();\\n        if (data.amount == 0) revert DidntParticipate();\\n        if (data.lane != race.winningLane) revert DidntWin();\\n\\n        data.claimed = true;\\n\\n        uint256 totalWinBet = betPerRacePerLane[raceId - 1][lane];\\n        uint256 totalLoseBet = 0;\\n        for (uint8 otherLane = 1; otherLane <= 6; otherLane++) {\\n            if (otherLane == lane) continue;\\n\\n            totalLoseBet += betPerRacePerLane[raceId - 1][otherLane];\\n        }\\n\\n        uint256 winnings = _calculateWinnings(data.amount, totalLoseBet, totalWinBet);\\n\\n        // This only triggers costly-loop warning if called from claimAllWinnings\\n        //slither-disable-next-line costly-loop\\n        totalAmountWon += winnings;\\n\\n        // pay out tokens for race\\n        SafeTransferLib.safeTransfer(ERC20(address(token)), bettor, winnings);\\n    }\\n\\n    function claimAllWinnings() external {\\n        address bettor = msg.sender;\\n        for (uint32 raceId = 1; raceId <= raceData.length; raceId++) {\\n            RaceData storage race = raceData[raceId - 1];\\n            BetData storage data = betData[raceId - 1][bettor];\\n\\n            if (data.amount == 0) continue;\\n            if (data.claimed) continue;\\n            if (data.lane != race.winningLane) continue;\\n\\n            claimWinnings(raceId);\\n        }\\n    }\\n\\n    // Admin functions\\n    function startRace() external onlyOwner noActiveRace {\\n        currentRace = lastRace + 1;\\n\\n        uint32 raceId = currentRace;\\n\\n        raceData.push(RaceData(true, true, false, 0, 0));\\n\\n        if (raceData.length != raceId) revert RaceDataMismatch();\\n\\n        emit RaceStarted(raceId);\\n    }\\n\\n    function endBetting() external onlyOwner needsActiveRace {\\n        uint32 raceId = currentRace;\\n        RaceData storage data = raceData[raceId - 1];\\n\\n        if (!data.bettingActive) revert BettingEndedAlready();\\n\\n        data.bettingActive = false;\\n\\n        emit BettingEnded(raceId);\\n    }\\n\\n    function endRace(uint8 winningLane) external onlyOwner needsActiveRace {\\n        uint32 raceId = currentRace;\\n        RaceData storage data = raceData[raceId - 1];\\n\\n        if (data.bettingActive) revert BettingStillActive();\\n\\n        data.active = false;\\n        data.winningLane = winningLane;\\n        lastRace = raceId;\\n        currentRace = 0;\\n\\n        emit RaceEnded(raceId, winningLane);\\n    }\\n\\n    function sweep() external onlyOwner noActiveRace {\\n        // Transfer all funds into the house wallet\\n        SafeTransferLib.safeTransfer(ERC20(address(token)), house, token.balanceOf(address(this)));\\n        // if for some reason there are native tokens in the contract\\n        SafeTransferLib.safeTransferETH(house, address(this).balance);\\n    }\\n\\n    function swapTokensForEth(address wallet, uint256 tokenAmount) private {\\n        // generate the uniswap pair path of token -> weth\\n        address[] memory path = new address[](2);\\n        path[0] = address(token);\\n        path[1] = token.uniswapV2Router().WETH();\\n        token.approve(address(token.uniswapV2Router()), tokenAmount);\\n        // make the swap\\n        token.uniswapV2Router().swapExactTokensForETHSupportingFeeOnTransferTokens(\\n            tokenAmount,\\n            0, // accept any amount of ETH\\n            path,\\n            wallet,\\n            block.timestamp\\n        );\\n    }\\n\\n    // Withdraw house winnings, this is going to be expensive.\\n    function houseWithdraw(uint32 raceId) external onlyOwner {\\n        if (raceId > raceData.length) revert InvalidRaceId();\\n\\n        RaceData storage race = raceData[raceId - 1];\\n        if (race.active) revert ActiveRace();\\n        if (race.houseWithdrew) revert AlreadyClaimed();\\n\\n        uint8 lane = race.winningLane;\\n        uint256 totalLoseBet = 0;\\n        for (uint8 otherLane = 1; otherLane <= 6; otherLane++) {\\n            if (otherLane == lane) continue;\\n\\n            totalLoseBet += betPerRacePerLane[raceId - 1][otherLane];\\n        }\\n\\n        uint256 houseWinnings = totalLoseBet / 10;\\n\\n        swapTokensForEth(house, houseWinnings);\\n\\n        race.houseWithdrew = true;\\n    }\\n\\n    // View functions\\n    function unclaimedWinnings(address bettor) public view returns (uint32[] memory) {\\n        uint32[] memory unclaimed;\\n        uint256 length = raceData.length;\\n\\n        for (uint32 raceId; raceId < length; raceId++) {\\n            BetData storage data = betData[raceId][bettor];\\n            RaceData storage race = raceData[raceId];\\n\\n            if (race.active) continue;\\n            if (race.winningLane != data.lane) continue;\\n            if (data.amount == 0) continue;\\n            if (data.claimed) continue;\\n\\n            unclaimed[unclaimed.length] = raceId;\\n        }\\n\\n        return unclaimed;\\n    }\\n\\n    function getUnclaimedBalance(address bettor) public view returns (uint256) {\\n        uint256 unclaimed = 0;\\n        uint256 length = raceData.length;\\n\\n        for (uint32 raceId; raceId < length; raceId++) {\\n            BetData storage data = betData[raceId][bettor];\\n            RaceData storage race = raceData[raceId];\\n\\n            uint8 lane = data.lane;\\n\\n            if (race.active) continue;\\n            if (race.winningLane != lane) continue;\\n            if (data.amount == 0) continue;\\n            if (data.claimed) continue;\\n\\n            uint256 totalWinBet = betPerRacePerLane[raceId][lane];\\n            uint256 totalLoseBet = 0;\\n            for (uint8 otherLane = 1; otherLane <= 6; otherLane++) {\\n                if (otherLane == lane) continue;\\n\\n                totalLoseBet += betPerRacePerLane[raceId][otherLane];\\n            }\\n\\n            unclaimed += _calculateWinnings(data.amount, totalLoseBet, totalWinBet);\\n        }\\n\\n        return unclaimed;\\n    }\\n\\n    function participatedInRaces(address bettor) public view returns (uint32[] memory) {\\n        uint32 counter = 0;\\n        uint32[] memory participated = new uint32[](totalBetsMade[bettor]);\\n        uint256 length = raceData.length;\\n\\n        for (uint32 raceId; raceId < length; raceId++) {\\n            BetData storage data = betData[raceId][bettor];\\n\\n            if (data.amount == 0) continue;\\n\\n            participated[counter] = raceId;\\n            counter++;\\n        }\\n\\n        return participated;\\n    }\\n\\n    function _totalRaces() public view returns (uint256) {\\n        uint256 racesComplete = raceData.length;\\n        if (currentRace > 0) racesComplete -= 1;\\n\\n        return racesComplete;\\n    }\\n\\n    function getRaceBets(uint32 index) public view returns (uint256, uint256, uint256, uint256, uint256, uint256) {\\n        return (\\n            betPerRacePerLane[index][1],\\n            betPerRacePerLane[index][2],\\n            betPerRacePerLane[index][3],\\n            betPerRacePerLane[index][4],\\n            betPerRacePerLane[index][5],\\n            betPerRacePerLane[index][6]\\n        );\\n    }\\n\\n    // Pure functions\\n    function _calculateWinnings(uint256 amount, uint256 totalLoseBet, uint256 totalWinBet)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        uint256 winAmount = 0;\\n        if (totalLoseBet > 0) {\\n            uint256 houseTax = totalLoseBet / 10; // Deduct from winnings 10% for house tax\\n            winAmount = (amount * (totalLoseBet - houseTax)) / totalWinBet;\\n        }\\n\\n        return amount + winAmount;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/auth/Owned.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Simple single owner authorization mixin.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Owned.sol)\\nabstract contract Owned {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event OwnershipTransferred(address indexed user, address indexed newOwner);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            OWNERSHIP STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    address public owner;\\n\\n    modifier onlyOwner() virtual {\\n        require(msg.sender == owner, \\\"UNAUTHORIZED\\\");\\n\\n        _;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(address _owner) {\\n        owner = _owner;\\n\\n        emit OwnershipTransferred(address(0), _owner);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             OWNERSHIP LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        owner = newOwner;\\n\\n        emit OwnershipTransferred(msg.sender, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/tokens/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\\nabstract contract ERC20 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    uint8 public immutable decimals;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            EIP-2612 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\n\\n    mapping(address => uint256) public nonces;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n\\n        INITIAL_CHAIN_ID = block.chainid;\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        balanceOf[msg.sender] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\n\\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\\n\\n        balanceOf[from] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             EIP-2612 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        require(deadline >= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\n\\n        // Unchecked because the only math done is incrementing\\n        // the owner's nonce which cannot realistically overflow.\\n        unchecked {\\n            address recoveredAddress = ecrecover(\\n                keccak256(\\n                    abi.encodePacked(\\n                        \\\"\\\\x19\\\\x01\\\",\\n                        DOMAIN_SEPARATOR(),\\n                        keccak256(\\n                            abi.encode(\\n                                keccak256(\\n                                    \\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\"\\n                                ),\\n                                owner,\\n                                spender,\\n                                value,\\n                                nonces[owner]++,\\n                                deadline\\n                            )\\n                        )\\n                    )\\n                ),\\n                v,\\n                r,\\n                s\\n            );\\n\\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"INVALID_SIGNER\\\");\\n\\n            allowance[recoveredAddress][spender] = value;\\n        }\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\n    }\\n\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                    keccak256(bytes(name)),\\n                    keccak256(\\\"1\\\"),\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        totalSupply += amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        balanceOf[from] -= amount;\\n\\n        // Cannot underflow because a user's balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply -= amount;\\n        }\\n\\n        emit Transfer(from, address(0), amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/utils/SafeTransferLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"../tokens/ERC20.sol\\\";\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\\nlibrary SafeTransferLib {\\n    /*//////////////////////////////////////////////////////////////\\n                             ETH OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Transfer the ETH and store if it succeeded or not.\\n            success := call(gas(), to, amount, 0, 0, 0, 0)\\n        }\\n\\n        require(success, \\\"ETH_TRANSFER_FAILED\\\");\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            ERC20 OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferFrom(\\n        ERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), and(from, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \\\"from\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \\\"amount\\\" argument. Masking not required as it's a full 32 byte type.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"TRANSFER_FROM_FAILED\\\");\\n    }\\n\\n    function safeTransfer(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument. Masking not required as it's a full 32 byte type.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"TRANSFER_FAILED\\\");\\n    }\\n\\n    function safeApprove(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument. Masking not required as it's a full 32 byte type.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"APPROVE_FAILED\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IHotWheels.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity >=0.8.18;\\npragma abicoder v2;\\n\\nimport \\\"./IUniswapV2Factory.sol\\\";\\nimport \\\"./IUniswapV2Pair.sol\\\";\\nimport \\\"./IUniswapV2Router.sol\\\";\\n\\ninterface IERC20 {\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    function totalSupply() external view returns (uint256);\\n    function balanceOf(address account) external view returns (uint256);\\n    function transfer(address to, uint256 value) external returns (bool);\\n    function allowance(address owner, address spender) external view returns (uint256);\\n    function approve(address spender, uint256 value) external returns (bool);\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\\ninterface IHotWheels is IERC20 {\\n    function uniswapV2Router() external view returns (IUniswapV2Router02);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IUniswapV2Factory.sol\": {\r\n      \"content\": \"pragma solidity >=0.8.18;\\n\\ninterface IUniswapV2Factory {\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint256);\\n\\n    function feeTo() external view returns (address);\\n    function feeToSetter() external view returns (address);\\n\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\n    function allPairs(uint256) external view returns (address pair);\\n    function allPairsLength() external view returns (uint256);\\n\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\n\\n    function setFeeTo(address) external;\\n    function setFeeToSetter(address) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IUniswapV2Pair.sol\": {\r\n      \"content\": \"pragma solidity >=0.8.18;\\n\\ninterface IUniswapV2Pair {\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    function name() external pure returns (string memory);\\n    function symbol() external pure returns (string memory);\\n    function decimals() external pure returns (uint8);\\n    function totalSupply() external view returns (uint256);\\n    function balanceOf(address owner) external view returns (uint256);\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n    function transfer(address to, uint256 value) external returns (bool);\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n    function nonces(address owner) external view returns (uint256);\\n\\n    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)\\n        external;\\n\\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\\n    event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed to);\\n    event Swap(\\n        address indexed sender,\\n        uint256 amount0In,\\n        uint256 amount1In,\\n        uint256 amount0Out,\\n        uint256 amount1Out,\\n        address indexed to\\n    );\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint256);\\n    function factory() external view returns (address);\\n    function token0() external view returns (address);\\n    function token1() external view returns (address);\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n    function price0CumulativeLast() external view returns (uint256);\\n    function price1CumulativeLast() external view returns (uint256);\\n    function kLast() external view returns (uint256);\\n\\n    function mint(address to) external returns (uint256 liquidity);\\n    function burn(address to) external returns (uint256 amount0, uint256 amount1);\\n    function swap(uint256 amount0Out, uint256 amount1Out, address to, bytes calldata data) external;\\n    function skim(address to) external;\\n    function sync() external;\\n\\n    function initialize(address, address) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IUniswapV2Router.sol\": {\r\n      \"content\": \"pragma solidity >=0.8.18;\\n\\ninterface IUniswapV2Router01 {\\n    function factory() external pure returns (address);\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint256 amountADesired,\\n        uint256 amountBDesired,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);\\n    function addLiquidityETH(\\n        address token,\\n        uint256 amountTokenDesired,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline\\n    ) external payable returns (uint256 amountToken, uint256 amountETH, uint256 liquidity);\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint256 liquidity,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256 amountA, uint256 amountB);\\n    function removeLiquidityETH(\\n        address token,\\n        uint256 liquidity,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256 amountToken, uint256 amountETH);\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint256 liquidity,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline,\\n        bool approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external returns (uint256 amountA, uint256 amountB);\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint256 liquidity,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline,\\n        bool approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external returns (uint256 amountToken, uint256 amountETH);\\n    function swapExactTokensForTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n    function swapTokensForExactTokens(\\n        uint256 amountOut,\\n        uint256 amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n    function swapExactETHForTokens(uint256 amountOutMin, address[] calldata path, address to, uint256 deadline)\\n        external\\n        payable\\n        returns (uint256[] memory amounts);\\n    function swapTokensForExactETH(\\n        uint256 amountOut,\\n        uint256 amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n    function swapExactTokensForETH(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n    function swapETHForExactTokens(uint256 amountOut, address[] calldata path, address to, uint256 deadline)\\n        external\\n        payable\\n        returns (uint256[] memory amounts);\\n\\n    function quote(uint256 amountA, uint256 reserveA, uint256 reserveB) external pure returns (uint256 amountB);\\n    function getAmountOut(uint256 amountIn, uint256 reserveIn, uint256 reserveOut)\\n        external\\n        pure\\n        returns (uint256 amountOut);\\n    function getAmountIn(uint256 amountOut, uint256 reserveIn, uint256 reserveOut)\\n        external\\n        pure\\n        returns (uint256 amountIn);\\n    function getAmountsOut(uint256 amountIn, address[] calldata path)\\n        external\\n        view\\n        returns (uint256[] memory amounts);\\n    function getAmountsIn(uint256 amountOut, address[] calldata path)\\n        external\\n        view\\n        returns (uint256[] memory amounts);\\n}\\n\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\n        address token,\\n        uint256 liquidity,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256 amountETH);\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n        address token,\\n        uint256 liquidity,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline,\\n        bool approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external returns (uint256 amountETH);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external;\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external payable;\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"openzeppelin/=lib/openzeppelin-contracts/contracts/\",\r\n      \"solmate/=lib/solmate/src/\",\r\n      \"v3-core/=lib/v3-core/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"houseWallet\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ActiveRace\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AlreadyClaimed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AlreadyPlacedBet\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BettingEndedAlready\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BettingStillActive\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DidntParticipate\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DidntWin\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidHouse\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidLane\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidRaceId\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MissingTokenApproval\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoActiveRace\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotEnoughTokens\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RaceDataMismatch\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"raceId\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"lane\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"BetAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"raceId\",\"type\":\"uint32\"}],\"name\":\"BettingEnded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"raceId\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"winningLane\",\"type\":\"uint8\"}],\"name\":\"RaceEnded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"raceId\",\"type\":\"uint32\"}],\"name\":\"RaceStarted\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"_totalRaces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"betData\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"claimed\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"lane\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"},{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"betPerRacePerLane\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"lane\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"betRace\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"bettors\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimAllWinnings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"raceId\",\"type\":\"uint32\"}],\"name\":\"claimWinnings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentRace\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"endBetting\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"winningLane\",\"type\":\"uint8\"}],\"name\":\"endRace\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"index\",\"type\":\"uint32\"}],\"name\":\"getRaceBets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"bettor\",\"type\":\"address\"}],\"name\":\"getUnclaimedBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"house\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"raceId\",\"type\":\"uint32\"}],\"name\":\"houseWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastRace\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"bettor\",\"type\":\"address\"}],\"name\":\"participatedInRaces\",\"outputs\":[{\"internalType\":\"uint32[]\",\"name\":\"\",\"type\":\"uint32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"raceData\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"bettingActive\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"houseWithdrew\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"winningLane\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"totalBet\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startRace\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sweep\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IHotWheels\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalAmountWon\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalBetsMade\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"bettor\",\"type\":\"address\"}],\"name\":\"unclaimedWinnings\",\"outputs\":[{\"internalType\":\"uint32[]\",\"name\":\"\",\"type\":\"uint32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "RaceManager", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000677ba6de47bfc5e8c2941a03b1bee24e7827258b00000000000000000000000045ccfe5e20f36f8f6252d1e7f0723cddfc386b07", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}