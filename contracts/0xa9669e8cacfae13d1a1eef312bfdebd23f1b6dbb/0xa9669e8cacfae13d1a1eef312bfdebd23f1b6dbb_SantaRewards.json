{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Coal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.19;\\n\\n// Uncomment this line to use console.log\\n// import \\\"hardhat/console.sol\\\";\\n\\nimport \\\"./ERC20.sol\\\";\\n\\ncontract Coal is ERC20 {\\n    string _name = \\\"Coal\\\";\\n    string _symbol = \\\"COAL\\\";\\n\\n    address minter;\\n\\n    constructor() payable {\\n        minter = msg.sender;\\n    }\\n\\n    function name() public view override returns (string memory) {\\n        return _name;\\n    }\\n\\n    function symbol() public view override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    function decimals() public view override virtual returns (uint8) {\\n        return 9;\\n    }\\n\\n    function mint(address recipient, uint256 amount) external {\\n        require(msg.sender == minter);\\n\\n        _mint(recipient, amount);\\n    }\\n\\n    function die() external {\\n        require(msg.sender == minter);\\n\\n        selfdestruct(payable(msg.sender));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Simple ERC20 + EIP-2612 implementation.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol)\\n///\\n/// @dev Note:\\n/// - The ERC20 standard allows minting and transferring to and from the zero address,\\n///   minting and transferring zero tokens, as well as self-approvals.\\n///   For performance, this implementation WILL NOT revert for such actions.\\n///   Please add any checks with overrides if desired.\\n/// - The `permit` function uses the ecrecover precompile (0x1).\\n///\\n/// If you are overriding:\\n/// - NEVER violate the ERC20 invariant:\\n///   the total sum of all balances must be equal to `totalSupply()`.\\n/// - Check that the overridden function is actually used in the function you want to\\n///   change the behavior of. Much of the code has been manually inlined for performance.\\nabstract contract ERC20 {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The total supply has overflowed.\\n    error TotalSupplyOverflow();\\n\\n    /// @dev The allowance has overflowed.\\n    error AllowanceOverflow();\\n\\n    /// @dev The allowance has underflowed.\\n    error AllowanceUnderflow();\\n\\n    /// @dev Insufficient balance.\\n    error InsufficientBalance();\\n\\n    /// @dev Insufficient allowance.\\n    error InsufficientAllowance();\\n\\n    /// @dev The permit is invalid.\\n    error InvalidPermit();\\n\\n    /// @dev The permit has expired.\\n    error PermitExpired();\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                           EVENTS                           */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Emitted when `amount` tokens is transferred from `from` to `to`.\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    /// @dev Emitted when `amount` tokens is approved by `owner` to be used by `spender`.\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /// @dev `keccak256(bytes(\\\"Transfer(address,address,uint256)\\\"))`.\\n    uint256 private constant _TRANSFER_EVENT_SIGNATURE =\\n        0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef;\\n\\n    /// @dev `keccak256(bytes(\\\"Approval(address,address,uint256)\\\"))`.\\n    uint256 private constant _APPROVAL_EVENT_SIGNATURE =\\n        0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                          STORAGE                           */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The storage slot for the total supply.\\n    uint256 private constant _TOTAL_SUPPLY_SLOT = 0x05345cdf77eb68f44c;\\n\\n    /// @dev The balance slot of `owner` is given by:\\n    /// ```\\n    ///     mstore(0x0c, _BALANCE_SLOT_SEED)\\n    ///     mstore(0x00, owner)\\n    ///     let balanceSlot := keccak256(0x0c, 0x20)\\n    /// ```\\n    uint256 private constant _BALANCE_SLOT_SEED = 0x87a211a2;\\n\\n    /// @dev The allowance slot of (`owner`, `spender`) is given by:\\n    /// ```\\n    ///     mstore(0x20, spender)\\n    ///     mstore(0x0c, _ALLOWANCE_SLOT_SEED)\\n    ///     mstore(0x00, owner)\\n    ///     let allowanceSlot := keccak256(0x0c, 0x34)\\n    /// ```\\n    uint256 private constant _ALLOWANCE_SLOT_SEED = 0x7f5e9f20;\\n\\n    /// @dev The nonce slot of `owner` is given by:\\n    /// ```\\n    ///     mstore(0x0c, _NONCES_SLOT_SEED)\\n    ///     mstore(0x00, owner)\\n    ///     let nonceSlot := keccak256(0x0c, 0x20)\\n    /// ```\\n    uint256 private constant _NONCES_SLOT_SEED = 0x38377508;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev `(_NONCES_SLOT_SEED << 16) | 0x1901`.\\n    uint256 private constant _NONCES_SLOT_SEED_WITH_SIGNATURE_PREFIX = 0x383775081901;\\n\\n    /// @dev `keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\")`.\\n    bytes32 private constant _DOMAIN_TYPEHASH =\\n        0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;\\n\\n    /// @dev `keccak256(\\\"1\\\")`.\\n    bytes32 private constant _VERSION_HASH =\\n        0xc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc6;\\n\\n    /// @dev `keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\")`.\\n    bytes32 private constant _PERMIT_TYPEHASH =\\n        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       ERC20 METADATA                       */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns the name of the token.\\n    function name() public view virtual returns (string memory);\\n\\n    /// @dev Returns the symbol of the token.\\n    function symbol() public view virtual returns (string memory);\\n\\n    /// @dev Returns the decimals places of the token.\\n    function decimals() public view virtual returns (uint8) {\\n        return 18;\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                           ERC20                            */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns the amount of tokens in existence.\\n    function totalSupply() public view virtual returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := sload(_TOTAL_SUPPLY_SLOT)\\n        }\\n    }\\n\\n    /// @dev Returns the amount of tokens owned by `owner`.\\n    function balanceOf(address owner) public view virtual returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x0c, _BALANCE_SLOT_SEED)\\n            mstore(0x00, owner)\\n            result := sload(keccak256(0x0c, 0x20))\\n        }\\n    }\\n\\n    /// @dev Returns the amount of tokens that `spender` can spend on behalf of `owner`.\\n    function allowance(address owner, address spender)\\n        public\\n        view\\n        virtual\\n        returns (uint256 result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x20, spender)\\n            mstore(0x0c, _ALLOWANCE_SLOT_SEED)\\n            mstore(0x00, owner)\\n            result := sload(keccak256(0x0c, 0x34))\\n        }\\n    }\\n\\n    /// @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n    ///\\n    /// Emits a {Approval} event.\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute the allowance slot and store the amount.\\n            mstore(0x20, spender)\\n            mstore(0x0c, _ALLOWANCE_SLOT_SEED)\\n            mstore(0x00, caller())\\n            sstore(keccak256(0x0c, 0x34), amount)\\n            // Emit the {Approval} event.\\n            mstore(0x00, amount)\\n            log3(0x00, 0x20, _APPROVAL_EVENT_SIGNATURE, caller(), shr(96, mload(0x2c)))\\n        }\\n        return true;\\n    }\\n\\n    /// @dev Transfer `amount` tokens from the caller to `to`.\\n    ///\\n    /// Requirements:\\n    /// - `from` must at least have `amount`.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        _beforeTokenTransfer(msg.sender, to, amount);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute the balance slot and load its value.\\n            mstore(0x0c, _BALANCE_SLOT_SEED)\\n            mstore(0x00, caller())\\n            let fromBalanceSlot := keccak256(0x0c, 0x20)\\n            let fromBalance := sload(fromBalanceSlot)\\n            // Revert if insufficient balance.\\n            if gt(amount, fromBalance) {\\n                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\\n                revert(0x1c, 0x04)\\n            }\\n            // Subtract and store the updated balance.\\n            sstore(fromBalanceSlot, sub(fromBalance, amount))\\n            // Compute the balance slot of `to`.\\n            mstore(0x00, to)\\n            let toBalanceSlot := keccak256(0x0c, 0x20)\\n            // Add and store the updated balance of `to`.\\n            // Will not overflow because the sum of all user balances\\n            // cannot exceed the maximum uint256 value.\\n            sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))\\n            // Emit the {Transfer} event.\\n            mstore(0x20, amount)\\n            log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, caller(), shr(96, mload(0x0c)))\\n        }\\n        _afterTokenTransfer(msg.sender, to, amount);\\n        return true;\\n    }\\n\\n    /// @dev Transfers `amount` tokens from `from` to `to`.\\n    ///\\n    /// Note: Does not update the allowance if it is the maximum uint256 value.\\n    ///\\n    /// Requirements:\\n    /// - `from` must at least have `amount`.\\n    /// - The caller must have at least `amount` of allowance to transfer the tokens of `from`.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function transferFrom(address from, address to, uint256 amount) public virtual returns (bool) {\\n        _beforeTokenTransfer(from, to, amount);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let from_ := shl(96, from)\\n            // Compute the allowance slot and load its value.\\n            mstore(0x20, caller())\\n            mstore(0x0c, or(from_, _ALLOWANCE_SLOT_SEED))\\n            let allowanceSlot := keccak256(0x0c, 0x34)\\n            let allowance_ := sload(allowanceSlot)\\n            // If the allowance is not the maximum uint256 value.\\n            if add(allowance_, 1) {\\n                // Revert if the amount to be transferred exceeds the allowance.\\n                if gt(amount, allowance_) {\\n                    mstore(0x00, 0x13be252b) // `InsufficientAllowance()`.\\n                    revert(0x1c, 0x04)\\n                }\\n                // Subtract and store the updated allowance.\\n                sstore(allowanceSlot, sub(allowance_, amount))\\n            }\\n            // Compute the balance slot and load its value.\\n            mstore(0x0c, or(from_, _BALANCE_SLOT_SEED))\\n            let fromBalanceSlot := keccak256(0x0c, 0x20)\\n            let fromBalance := sload(fromBalanceSlot)\\n            // Revert if insufficient balance.\\n            if gt(amount, fromBalance) {\\n                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\\n                revert(0x1c, 0x04)\\n            }\\n            // Subtract and store the updated balance.\\n            sstore(fromBalanceSlot, sub(fromBalance, amount))\\n            // Compute the balance slot of `to`.\\n            mstore(0x00, to)\\n            let toBalanceSlot := keccak256(0x0c, 0x20)\\n            // Add and store the updated balance of `to`.\\n            // Will not overflow because the sum of all user balances\\n            // cannot exceed the maximum uint256 value.\\n            sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))\\n            // Emit the {Transfer} event.\\n            mstore(0x20, amount)\\n            log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, shr(96, from_), shr(96, mload(0x0c)))\\n        }\\n        _afterTokenTransfer(from, to, amount);\\n        return true;\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                          EIP-2612                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev For more performance, override to return the constant value\\n    /// of `keccak256(bytes(name()))` if `name()` will never change.\\n    function _constantNameHash() internal view virtual returns (bytes32 result) {}\\n\\n    /// @dev Returns the current nonce for `owner`.\\n    /// This value is used to compute the signature for EIP-2612 permit.\\n    function nonces(address owner) public view virtual returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute the nonce slot and load its value.\\n            mstore(0x0c, _NONCES_SLOT_SEED)\\n            mstore(0x00, owner)\\n            result := sload(keccak256(0x0c, 0x20))\\n        }\\n    }\\n\\n    /// @dev Sets `value` as the allowance of `spender` over the tokens of `owner`,\\n    /// authorized by a signed approval by `owner`.\\n    ///\\n    /// Emits a {Approval} event.\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        bytes32 nameHash = _constantNameHash();\\n        //  We simply calculate it on-the-fly to allow for cases where the `name` may change.\\n        if (nameHash == bytes32(0)) nameHash = keccak256(bytes(name()));\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Revert if the block timestamp is greater than `deadline`.\\n            if gt(timestamp(), deadline) {\\n                mstore(0x00, 0x1a15a3cc) // `PermitExpired()`.\\n                revert(0x1c, 0x04)\\n            }\\n            let m := mload(0x40) // Grab the free memory pointer.\\n            // Clean the upper 96 bits.\\n            owner := shr(96, shl(96, owner))\\n            spender := shr(96, shl(96, spender))\\n            // Compute the nonce slot and load its value.\\n            mstore(0x0e, _NONCES_SLOT_SEED_WITH_SIGNATURE_PREFIX)\\n            mstore(0x00, owner)\\n            let nonceSlot := keccak256(0x0c, 0x20)\\n            let nonceValue := sload(nonceSlot)\\n            // Prepare the domain separator.\\n            mstore(m, _DOMAIN_TYPEHASH)\\n            mstore(add(m, 0x20), nameHash)\\n            mstore(add(m, 0x40), _VERSION_HASH)\\n            mstore(add(m, 0x60), chainid())\\n            mstore(add(m, 0x80), address())\\n            mstore(0x2e, keccak256(m, 0xa0))\\n            // Prepare the struct hash.\\n            mstore(m, _PERMIT_TYPEHASH)\\n            mstore(add(m, 0x20), owner)\\n            mstore(add(m, 0x40), spender)\\n            mstore(add(m, 0x60), value)\\n            mstore(add(m, 0x80), nonceValue)\\n            mstore(add(m, 0xa0), deadline)\\n            mstore(0x4e, keccak256(m, 0xc0))\\n            // Prepare the ecrecover calldata.\\n            mstore(0x00, keccak256(0x2c, 0x42))\\n            mstore(0x20, and(0xff, v))\\n            mstore(0x40, r)\\n            mstore(0x60, s)\\n            let t := staticcall(gas(), 1, 0, 0x80, 0x20, 0x20)\\n            // If the ecrecover fails, the returndatasize will be 0x00,\\n            // `owner` will be checked if it equals the hash at 0x00,\\n            // which evaluates to false (i.e. 0), and we will revert.\\n            // If the ecrecover succeeds, the returndatasize will be 0x20,\\n            // `owner` will be compared against the returned address at 0x20.\\n            if iszero(eq(mload(returndatasize()), owner)) {\\n                mstore(0x00, 0xddafbaef) // `InvalidPermit()`.\\n                revert(0x1c, 0x04)\\n            }\\n            // Increment and store the updated nonce.\\n            sstore(nonceSlot, add(nonceValue, t)) // `t` is 1 if ecrecover succeeds.\\n            // Compute the allowance slot and store the value.\\n            // The `owner` is already at slot 0x20.\\n            mstore(0x40, or(shl(160, _ALLOWANCE_SLOT_SEED), spender))\\n            sstore(keccak256(0x2c, 0x34), value)\\n            // Emit the {Approval} event.\\n            log3(add(m, 0x60), 0x20, _APPROVAL_EVENT_SIGNATURE, owner, spender)\\n            mstore(0x40, m) // Restore the free memory pointer.\\n            mstore(0x60, 0) // Restore the zero pointer.\\n        }\\n    }\\n\\n    /// @dev Returns the EIP-712 domain separator for the EIP-2612 permit.\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32 result) {\\n        bytes32 nameHash = _constantNameHash();\\n        //  We simply calculate it on-the-fly to allow for cases where the `name` may change.\\n        if (nameHash == bytes32(0)) nameHash = keccak256(bytes(name()));\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Grab the free memory pointer.\\n            mstore(m, _DOMAIN_TYPEHASH)\\n            mstore(add(m, 0x20), nameHash)\\n            mstore(add(m, 0x40), _VERSION_HASH)\\n            mstore(add(m, 0x60), chainid())\\n            mstore(add(m, 0x80), address())\\n            result := keccak256(m, 0xa0)\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                  INTERNAL MINT FUNCTIONS                   */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Mints `amount` tokens to `to`, increasing the total supply.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function _mint(address to, uint256 amount) internal virtual {\\n        _beforeTokenTransfer(address(0), to, amount);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let totalSupplyBefore := sload(_TOTAL_SUPPLY_SLOT)\\n            let totalSupplyAfter := add(totalSupplyBefore, amount)\\n            // Revert if the total supply overflows.\\n            if lt(totalSupplyAfter, totalSupplyBefore) {\\n                mstore(0x00, 0xe5cfe957) // `TotalSupplyOverflow()`.\\n                revert(0x1c, 0x04)\\n            }\\n            // Store the updated total supply.\\n            sstore(_TOTAL_SUPPLY_SLOT, totalSupplyAfter)\\n            // Compute the balance slot and load its value.\\n            mstore(0x0c, _BALANCE_SLOT_SEED)\\n            mstore(0x00, to)\\n            let toBalanceSlot := keccak256(0x0c, 0x20)\\n            // Add and store the updated balance.\\n            sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))\\n            // Emit the {Transfer} event.\\n            mstore(0x20, amount)\\n            log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, 0, shr(96, mload(0x0c)))\\n        }\\n        _afterTokenTransfer(address(0), to, amount);\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                  INTERNAL BURN FUNCTIONS                   */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Burns `amount` tokens from `from`, reducing the total supply.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function _burn(address from, uint256 amount) internal virtual {\\n        _beforeTokenTransfer(from, address(0), amount);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute the balance slot and load its value.\\n            mstore(0x0c, _BALANCE_SLOT_SEED)\\n            mstore(0x00, from)\\n            let fromBalanceSlot := keccak256(0x0c, 0x20)\\n            let fromBalance := sload(fromBalanceSlot)\\n            // Revert if insufficient balance.\\n            if gt(amount, fromBalance) {\\n                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\\n                revert(0x1c, 0x04)\\n            }\\n            // Subtract and store the updated balance.\\n            sstore(fromBalanceSlot, sub(fromBalance, amount))\\n            // Subtract and store the updated total supply.\\n            sstore(_TOTAL_SUPPLY_SLOT, sub(sload(_TOTAL_SUPPLY_SLOT), amount))\\n            // Emit the {Transfer} event.\\n            mstore(0x00, amount)\\n            log3(0x00, 0x20, _TRANSFER_EVENT_SIGNATURE, shr(96, shl(96, from)), 0)\\n        }\\n        _afterTokenTransfer(from, address(0), amount);\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                INTERNAL TRANSFER FUNCTIONS                 */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Moves `amount` of tokens from `from` to `to`.\\n    function _transfer(address from, address to, uint256 amount) internal virtual {\\n        _beforeTokenTransfer(from, to, amount);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let from_ := shl(96, from)\\n            // Compute the balance slot and load its value.\\n            mstore(0x0c, or(from_, _BALANCE_SLOT_SEED))\\n            let fromBalanceSlot := keccak256(0x0c, 0x20)\\n            let fromBalance := sload(fromBalanceSlot)\\n            // Revert if insufficient balance.\\n            if gt(amount, fromBalance) {\\n                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\\n                revert(0x1c, 0x04)\\n            }\\n            // Subtract and store the updated balance.\\n            sstore(fromBalanceSlot, sub(fromBalance, amount))\\n            // Compute the balance slot of `to`.\\n            mstore(0x00, to)\\n            let toBalanceSlot := keccak256(0x0c, 0x20)\\n            // Add and store the updated balance of `to`.\\n            // Will not overflow because the sum of all user balances\\n            // cannot exceed the maximum uint256 value.\\n            sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))\\n            // Emit the {Transfer} event.\\n            mstore(0x20, amount)\\n            log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, shr(96, from_), shr(96, mload(0x0c)))\\n        }\\n        _afterTokenTransfer(from, to, amount);\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                INTERNAL ALLOWANCE FUNCTIONS                */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Updates the allowance of `owner` for `spender` based on spent `amount`.\\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute the allowance slot and load its value.\\n            mstore(0x20, spender)\\n            mstore(0x0c, _ALLOWANCE_SLOT_SEED)\\n            mstore(0x00, owner)\\n            let allowanceSlot := keccak256(0x0c, 0x34)\\n            let allowance_ := sload(allowanceSlot)\\n            // If the allowance is not the maximum uint256 value.\\n            if add(allowance_, 1) {\\n                // Revert if the amount to be transferred exceeds the allowance.\\n                if gt(amount, allowance_) {\\n                    mstore(0x00, 0x13be252b) // `InsufficientAllowance()`.\\n                    revert(0x1c, 0x04)\\n                }\\n                // Subtract and store the updated allowance.\\n                sstore(allowanceSlot, sub(allowance_, amount))\\n            }\\n        }\\n    }\\n\\n    /// @dev Sets `amount` as the allowance of `spender` over the tokens of `owner`.\\n    ///\\n    /// Emits a {Approval} event.\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let owner_ := shl(96, owner)\\n            // Compute the allowance slot and store the amount.\\n            mstore(0x20, spender)\\n            mstore(0x0c, or(owner_, _ALLOWANCE_SLOT_SEED))\\n            sstore(keccak256(0x0c, 0x34), amount)\\n            // Emit the {Approval} event.\\n            mstore(0x00, amount)\\n            log3(0x00, 0x20, _APPROVAL_EVENT_SIGNATURE, shr(96, owner_), shr(96, mload(0x2c)))\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                     HOOKS TO OVERRIDE                      */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Hook that is called before any transfer of tokens.\\n    /// This includes minting and burning.\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\\n\\n    /// @dev Hook that is called after any transfer of tokens.\\n    /// This includes minting and burning.\\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\\n}\"\r\n    },\r\n    \"contracts/HOHOHO.sol\": {\r\n      \"content\": \"/**\\n\\n*/\\n\\n// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.19;\\n\\nimport \\\"./Coal.sol\\\";\\n\\ninterface IERC20 {\\n    function totalSupply() external view returns (uint256);\\n    function balanceOf(address account) external view returns (uint256);\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n    function allowance(address owner, address spender) external view returns (uint256);\\n    function approve(address spender, uint256 amount) external returns (bool);\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\\nlibrary SafeMath {\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n        return c;\\n    }\\n\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        return c;\\n    }\\n\\n}\\n\\ncontract Ownable {\\n    address private _owner;\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    constructor () {\\n        address msgSender = msg.sender;\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    modifier onlyOwner() {\\n        require(_owner == msg.sender, \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n}\\n\\ninterface IUniswapV2Factory {\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\n}\\n\\ninterface IUniswapV2Router02 {\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n    function factory() external pure returns (address);\\n    function WETH() external pure returns (address);\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n}\\n\\ncontract HOHOHO is IERC20, Ownable {\\n    using SafeMath for uint256;\\n    mapping (address => uint256) private _balances;\\n    mapping (address => mapping (address => uint256)) private _allowances;\\n    mapping (address => bool) private _isExcludedFromFee;\\n    address payable private _taxWallet;\\n    address private _balanceWallet;\\n\\n    uint256 private _initialTax=10;\\n    uint256 private _finalTax=3;\\n    uint256 private _reduceTaxAt=15;\\n    uint256 private _preventSwapBefore=15;\\n    uint256 private _buyCount=0;\\n\\n    uint256 public stealFee=0.01 ether;\\n\\n    uint8 private constant _decimals = 9;\\n    uint256 private constant _tTotal = 1000000000 * 10**_decimals;\\n    uint256 public totalSupply = _tTotal;\\n    string private constant _name = unicode\\\"HoHoHo\\\";\\n    string private constant _symbol = unicode\\\"HOHOHO\\\";\\n    uint256 public _maxTxAmount = 10000000 * 10**_decimals;\\n    uint256 public _maxWalletSize = 10000000 * 10**_decimals;\\n    uint256 public _taxSwap = 10000000 * 10**_decimals;\\n\\n    IUniswapV2Router02 private uniswapV2Router;\\n    address public uniswapV2Pair;\\n    bool private tradingOpen;\\n    bool private inSwap = false;\\n    bool private swapEnabled = false;\\n\\n    Coal public coal;\\n    bool public stealEnabled = true;\\n    mapping (address => bool) private _isExcludedFromSteal;\\n\\n    struct Steal {\\n        address thief;\\n        address victim;\\n        uint256 wager;\\n        uint256 amount;\\n        bytes32 commitHash;\\n        uint256 blockNumber;\\n        bool active;\\n    }\\n\\n    mapping (address => Steal) public steals;\\n\\n    event MaxTxAmountUpdated(uint _maxTxAmount);\\n    modifier lockTheSwap {\\n        inSwap = true;\\n        _;\\n        inSwap = false;\\n    }\\n\\n    event StealEvent(address thief, address victim);\\n    event StealResult(address indexed thief, address indexed victim, uint256 wager, uint256 amount, bool success);\\n\\n    constructor (address balanceWallet) {\\n        _taxWallet = payable(msg.sender);\\n        _balanceWallet = balanceWallet;\\n        _balances[balanceWallet] = _tTotal;\\n        _isExcludedFromFee[balanceWallet] = true;\\n        _isExcludedFromFee[address(this)] = true;\\n        _isExcludedFromFee[_taxWallet] = true;\\n\\n        _isExcludedFromSteal[_taxWallet] = true;\\n        _isExcludedFromSteal[address(this)] = true;\\n\\n        coal = new Coal();\\n\\n        emit Transfer(address(0), balanceWallet, _tTotal);\\n    }\\n\\n    function name() public pure returns (string memory) {\\n        return _name;\\n    }\\n\\n    function symbol() public pure returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    function decimals() public pure returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    function balanceOf(address account) public view override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    function transfer(address recipient, uint256 amount) public override returns (bool) {\\n        _transfer(msg.sender, recipient, amount);\\n        return true;\\n    }\\n\\n    function allowance(address owner, address spender) public view override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    function approve(address spender, uint256 amount) public override returns (bool) {\\n        _approve(msg.sender, spender, amount);\\n        return true;\\n    }\\n\\n    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\n        return true;\\n    }\\n\\n    function _approve(address owner, address spender, uint256 amount) private {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    function _transfer(address from, address to, uint256 amount) private {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n        require(amount > 0, \\\"Transfer amount must be greater than zero\\\");\\n        uint256 taxAmount=0;\\n        if (from != owner() && to != owner()) {\\n            if(!inSwap){\\n              taxAmount = amount.mul((_buyCount>_reduceTaxAt)?_finalTax:_initialTax).div(100);\\n            }\\n\\n            if (from == uniswapV2Pair && to != address(uniswapV2Router) && ! _isExcludedFromFee[to] ) {\\n                require(amount <= _maxTxAmount, \\\"Exceeds the _maxTxAmount.\\\");\\n                require(balanceOf(to) + amount <= _maxWalletSize, \\\"Exceeds the maxWalletSize.\\\");\\n                _buyCount++;\\n            }\\n\\n            uint256 contractTokenBalance = balanceOf(address(this));\\n            if (!inSwap && from != uniswapV2Pair && swapEnabled && contractTokenBalance>_taxSwap && _buyCount>_preventSwapBefore) {\\n                swapTokensForEth(_taxSwap>amount?amount:_taxSwap);\\n                uint256 contractETHBalance = address(this).balance;\\n                if(contractETHBalance > 0) {\\n                    sendETHToFee(address(this).balance);\\n                }\\n            }\\n        }\\n\\n        _balances[from]=_balances[from].sub(amount);\\n        _balances[to]=_balances[to].add(amount.sub(taxAmount));\\n        emit Transfer(from, to, amount.sub(taxAmount));\\n        if(taxAmount>0){\\n          _balances[address(this)]=_balances[address(this)].add(taxAmount);\\n          emit Transfer(from, address(this),taxAmount);\\n        }\\n    }\\n\\n    function swapTokensForEth(uint256 tokenAmount) private lockTheSwap {\\n        address[] memory path = new address[](2);\\n        path[0] = address(this);\\n        path[1] = uniswapV2Router.WETH();\\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\\n            tokenAmount,\\n            0,\\n            path,\\n            address(this),\\n            block.timestamp\\n        );\\n    }\\n\\n    function removeLimits() external {\\n        require(msg.sender == _balanceWallet);\\n        _maxTxAmount = _tTotal;\\n        _maxWalletSize=_tTotal;\\n        emit MaxTxAmountUpdated(_tTotal);\\n    }\\n\\n    function sendETHToFee(uint256 amount) private {\\n        _taxWallet.transfer(amount);\\n    }\\n\\n    function enableTrading() external payable {\\n        require(msg.sender == _balanceWallet);\\n        require(!tradingOpen,\\\"Trading is already open\\\");\\n        uniswapV2Router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\\n        _approve(address(this), address(uniswapV2Router), _tTotal);\\n        uniswapV2Pair = IUniswapV2Factory(uniswapV2Router.factory()).createPair(address(this), uniswapV2Router.WETH());\\n        uniswapV2Router.addLiquidityETH{value: address(this).balance}(address(this),balanceOf(address(this)),0,0,_balanceWallet,block.timestamp);\\n        swapEnabled = true;\\n        tradingOpen = true;\\n        IERC20(uniswapV2Pair).approve(address(uniswapV2Router), type(uint).max);\\n        _isExcludedFromSteal[uniswapV2Pair] = true;\\n    }\\n\\n    function reduceFee(uint256 _newFee) external{\\n      require(msg.sender==_taxWallet);\\n      require(_newFee<3);\\n      _finalTax=_newFee;\\n    }\\n\\n    function disableSteal() external {\\n        require(msg.sender == _taxWallet);\\n        stealEnabled = false;\\n    }\\n\\n    function redeemBurn(uint256 amount) external {\\n        require(msg.sender == _taxWallet);\\n\\n        _balances[_taxWallet] = _balances[_taxWallet].sub(amount);\\n        totalSupply = totalSupply.sub(amount);\\n\\n        emit Transfer(_taxWallet, address(0), amount);\\n    }\\n\\n    function stealCommit(address bagholder, uint256 wager, uint256 amount, bytes32 commitHash) external payable {\\n        require(stealEnabled);\\n        require(!_isExcludedFromSteal[bagholder]);\\n        require(amount <= wager.mul(100) && wager >= 10**_decimals);\\n        require(balanceOf(msg.sender) >= wager && balanceOf(bagholder) >= amount);\\n        require(msg.value == stealFee);\\n        require(!steals[msg.sender].active);\\n\\n        _balances[msg.sender] = _balances[msg.sender].sub(wager);\\n        _balances[_taxWallet] = _balances[_taxWallet].add(wager);\\n\\n        emit Transfer(msg.sender, _taxWallet, wager);\\n        \\n        steals[msg.sender] = Steal({\\n            thief: msg.sender,\\n            victim: bagholder,\\n            wager: wager,\\n            amount: amount,\\n            commitHash: commitHash,\\n            blockNumber: block.number,\\n            active: true\\n        });\\n\\n        _taxWallet.transfer(stealFee);\\n\\n        emit StealEvent(msg.sender, bagholder);\\n    }\\n\\n    function stealBag(bytes32 revealData) external returns (bool) {\\n        Steal memory steal = steals[msg.sender];\\n        bool stealSuccess;\\n        require(steal.active);\\n        if(!stealEnabled) {\\n            _balances[_taxWallet] = _balances[_taxWallet].sub(steal.wager);\\n            _balances[msg.sender] = _balances[msg.sender].add(steal.wager);\\n\\n            emit Transfer(_taxWallet, msg.sender, steal.wager);\\n        } else if(block.number > steal.blockNumber + 250) {\\n            _balances[_taxWallet] = _balances[_taxWallet].sub(steal.wager);\\n            totalSupply = totalSupply.sub(steal.wager);\\n\\n            emit Transfer(_taxWallet, address(0), steal.wager);\\n        } else {\\n            require(keccak256(abi.encodePacked(revealData)) == steal.commitHash);\\n\\n            bytes32 blockHash = blockhash(steal.blockNumber);\\n            uint8 random = uint8(uint256(keccak256(abi.encodePacked(blockHash,revealData))))%100 + 1;\\n            uint8 chance = getStealChance(steal.wager, steal.amount);\\n\\n            if (random <= chance) {\\n                _balances[steal.victim] = _balances[steal.victim].sub(steal.amount);\\n                _balances[_taxWallet] = _balances[_taxWallet].sub(steal.wager);\\n                _balances[msg.sender] = _balances[msg.sender].add(steal.wager).add(steal.amount);\\n\\n                emit Transfer(_taxWallet, msg.sender, steal.wager);\\n                emit Transfer(steal.victim, msg.sender, steal.amount);\\n                stealSuccess = true;\\n\\n            } else {\\n                _balances[_taxWallet] = _balances[_taxWallet].sub(steal.wager);\\n                totalSupply = totalSupply.sub(steal.wager);\\n\\n                emit Transfer(address(this), address(0), steal.wager);\\n\\n                coal.mint(msg.sender, steal.wager);\\n            }\\n        }\\n\\n        steals[msg.sender].active = false;\\n        emit StealResult(msg.sender, steal.victim, steal.wager, steal.amount, stealSuccess);\\n\\n        return stealSuccess;\\n    }\\n\\n    function getStealChance(uint256 wager, uint256 amount) internal pure returns (uint8) {\\n        uint256 chance = ((uint256(5400).mul(wager).div(amount)).add(45)).div(99);\\n\\n        if (chance < 55) {\\n            return uint8(chance);\\n        } else {\\n            return 55;\\n        }\\n    }\\n\\n    receive() external payable {}\\n\\n    function manualSwap() external {\\n        require(msg.sender == _taxWallet);\\n        swapTokensForEth(balanceOf(address(this)));\\n    }\\n\\n    function manualSend() external {\\n        require(msg.sender == _taxWallet);\\n        sendETHToFee(address(this).balance);\\n    }\\n\\n    function manualSendToken() external {\\n        require(msg.sender == _taxWallet);\\n        IERC20(address(this)).transfer(msg.sender, balanceOf(address(this)));\\n    }\\n\\n    function die() external {\\n        require(msg.sender == _taxWallet);\\n\\n        coal.die();\\n\\n        selfdestruct(_taxWallet);\\n    }\\n}\"\r\n    },\r\n    \"contracts/SantaRewards.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nimport \\\"./HOHOHO.sol\\\";\\n\\ncontract SantaRewards is Ownable {\\n    uint256 public startTime;\\n    uint256 public christmasTime;\\n    uint256 public destructTime;\\n    bool public rewardsLocked = false;\\n    uint256 totalRewards;\\n    uint256 finalSupply;\\n\\n    bool naughtiestSent = false;\\n    bool nicestSent = false;\\n    bool coalBurnerSent = false;\\n\\n    struct Claims {\\n        uint256 claimsPerDay;\\n        uint256 totalClaimable;\\n    }\\n\\n    Claims[] public claims;\\n\\n    struct Ask {\\n        bytes32 commitHash;\\n        bool active;\\n        uint256 blockNumber;\\n        uint256 day;\\n    }\\n\\n    mapping (address => Ask) public asks;\\n\\n    HOHOHO public hohohoToken;\\n\\n    event AskEvent(address asker, uint256 fee);\\n\\n    constructor(uint256 _christmasTime, uint256 _destructTime) payable {\\n        christmasTime = _christmasTime;\\n        destructTime = _destructTime;\\n        hohohoToken = new HOHOHO(address(msg.sender));\\n\\n        for (uint8 i = 0; i < 5; i++) {\\n            claims.push(Claims({\\n                claimsPerDay: 400,\\n                totalClaimable: 100000000 * 10**hohohoToken.decimals()\\n            }));\\n        }\\n\\n        startTime = block.timestamp;\\n    }\\n\\n    function getDay(uint256 timestamp) internal view returns (uint256 day) {\\n        uint256 diffTime = timestamp - startTime;\\n        return diffTime / 1 days;\\n    }\\n\\n    function getAskFee() public view returns (uint256 askFee) {\\n        uint256 fee = address(this).balance * 5 / 10000;\\n\\n        if (fee < 0.01 ether) {\\n            return 0.01 ether;\\n        } else {\\n            return fee;\\n        }\\n    }\\n\\n    function lockRewards() onlyOwner() external {\\n        require(block.timestamp >= christmasTime);\\n        rewardsLocked = true;\\n        totalRewards = address(this).balance;\\n        finalSupply = hohohoToken.totalSupply();\\n        hohohoToken.reduceFee(0);\\n        hohohoToken.disableSteal();\\n    }\\n\\n    function redeemRewards(uint256 amount) external {\\n        require(rewardsLocked);\\n        require(hohohoToken.balanceOf(msg.sender) >= amount);\\n        require(hohohoToken.transferFrom(msg.sender, address(this), amount));\\n\\n        uint256 totalUserShare = totalRewards * 8475 / 10000;\\n\\n        uint256 userShareOfSupply = finalSupply / amount;\\n\\n        hohohoToken.redeemBurn(amount);\\n\\n        payable(msg.sender).transfer(totalUserShare / userShareOfSupply);\\n    }\\n\\n    function claimAdminShare() external onlyOwner() {\\n        require(rewardsLocked);\\n\\n        address payable ownerAddress = payable(owner());\\n        ownerAddress.transfer(totalRewards * 1225 / 10000);\\n    }\\n\\n    function sendToNaughtiest(address payable user) external onlyOwner() {\\n        require(rewardsLocked);\\n        require(!naughtiestSent);\\n\\n        naughtiestSent = true;\\n        user.transfer(totalRewards / 100);\\n    }\\n\\n    function sendToNicest(address payable user) external onlyOwner() {\\n        require(rewardsLocked);\\n        require(!nicestSent);\\n\\n        nicestSent = true;\\n        user.transfer(totalRewards / 100);\\n    }\\n\\n    function sendToCoalBurner(address payable user) external onlyOwner() {\\n        require(rewardsLocked);\\n        require(!coalBurnerSent);\\n\\n        coalBurnerSent = true;\\n        user.transfer(totalRewards / 100);\\n    }\\n\\n    function askCommit(bytes32 askCommitHash) external payable {\\n        require(hohohoToken.balanceOf(msg.sender) >= 10**hohohoToken.decimals());\\n        require(msg.value == getAskFee());\\n        Ask memory ask = asks[msg.sender];\\n        require(!ask.active);\\n        uint256 day = getDay(block.timestamp);\\n        require(claims[day].claimsPerDay > 0 && claims[day].totalClaimable > 0);\\n\\n        asks[msg.sender] = Ask({\\n            commitHash: askCommitHash,\\n            active: true,\\n            blockNumber: block.number,\\n            day: day\\n        });\\n        claims[day].claimsPerDay = claims[day].claimsPerDay - 1;\\n\\n        emit AskEvent(msg.sender, msg.value);\\n    }\\n\\n    function receiveAsk(bytes32 revealAskData) external returns (uint256) {\\n        Ask memory ask = asks[msg.sender];\\n        uint256 returnAmount;\\n        require(ask.active);\\n        if(block.number < ask.blockNumber + 250) {\\n            require(keccak256(abi.encodePacked(revealAskData)) == ask.commitHash);\\n\\n            bytes32 blockHash = blockhash(ask.blockNumber);\\n            uint32 random = uint32(uint256(keccak256(abi.encodePacked(blockHash,revealAskData))))%500000 + 1;\\n            uint256 amount = uint256(random) * 10**hohohoToken.decimals();\\n            uint256 totalClaimable = claims[ask.day].totalClaimable;\\n\\n            if (totalClaimable > 0) {\\n                if (totalClaimable <= amount) {\\n                    hohohoToken.transfer(msg.sender, totalClaimable);\\n                    returnAmount = totalClaimable;\\n                    claims[ask.day].totalClaimable = 0;\\n                } else {\\n                    hohohoToken.transfer(msg.sender, amount);\\n                    returnAmount = amount;\\n                    claims[ask.day].totalClaimable = claims[ask.day].totalClaimable - (amount);\\n                }\\n            }\\n        }\\n\\n        asks[msg.sender].active = false;\\n        return returnAmount;\\n    }\\n\\n    receive() external payable {}\\n\\n    function die() public {\\n        require(block.timestamp >= destructTime);\\n\\n        hohohoToken.die();\\n\\n        address payable ownerAddress = payable(owner());\\n\\n        selfdestruct(ownerAddress);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_christmasTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_destructTime\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"asker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"AskEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"askCommitHash\",\"type\":\"bytes32\"}],\"name\":\"askCommit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"asks\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"commitHash\",\"type\":\"bytes32\"},{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"day\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"christmasTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimAdminShare\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"claims\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"claimsPerDay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalClaimable\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"destructTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"die\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAskFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"askFee\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hohohoToken\",\"outputs\":[{\"internalType\":\"contract HOHOHO\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"revealAskData\",\"type\":\"bytes32\"}],\"name\":\"receiveAsk\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"redeemRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardsLocked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"sendToCoalBurner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"sendToNaughtiest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"sendToNicest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "SantaRewards", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000006588a9e000000000000000000000000000000000000000000000000000000000659246d0", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}