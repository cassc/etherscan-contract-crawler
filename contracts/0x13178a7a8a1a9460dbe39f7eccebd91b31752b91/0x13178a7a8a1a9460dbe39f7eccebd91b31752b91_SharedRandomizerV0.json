{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/interfaces/v0.8.x/IAdminACLV0.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\n// Created By: Art Blocks Inc.\\n\\npragma solidity ^0.8.0;\\n\\ninterface IAdminACLV0 {\\n    /**\\n     * @notice Token ID `_tokenId` minted to `_to`.\\n     * @param previousSuperAdmin The previous superAdmin address.\\n     * @param newSuperAdmin The new superAdmin address.\\n     * @param genArt721CoreAddressesToUpdate Array of genArt721Core\\n     * addresses to update to the new superAdmin, for indexing purposes only.\\n     */\\n    event SuperAdminTransferred(\\n        address indexed previousSuperAdmin,\\n        address indexed newSuperAdmin,\\n        address[] genArt721CoreAddressesToUpdate\\n    );\\n\\n    /// Type of the Admin ACL contract, e.g. \\\"AdminACLV0\\\"\\n    function AdminACLType() external view returns (string memory);\\n\\n    /// super admin address\\n    function superAdmin() external view returns (address);\\n\\n    /**\\n     * @notice Calls transferOwnership on other contract from this contract.\\n     * This is useful for updating to a new AdminACL contract.\\n     * @dev this function should be gated to only superAdmin-like addresses.\\n     */\\n    function transferOwnershipOn(\\n        address _contract,\\n        address _newAdminACL\\n    ) external;\\n\\n    /**\\n     * @notice Calls renounceOwnership on other contract from this contract.\\n     * @dev this function should be gated to only superAdmin-like addresses.\\n     */\\n    function renounceOwnershipOn(address _contract) external;\\n\\n    /**\\n     * @notice Checks if sender `_sender` is allowed to call function with selector\\n     * `_selector` on contract `_contract`.\\n     */\\n    function allowed(\\n        address _sender,\\n        address _contract,\\n        bytes4 _selector\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/v0.8.x/IGenArt721CoreContractV3_Base.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\n// Created By: Art Blocks Inc.\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IAdminACLV0.sol\\\";\\n/// use the Royalty Registry's IManifold interface for token royalties\\nimport \\\"./IManifold.sol\\\";\\n\\n/**\\n * @title This interface is intended to house interface items that are common\\n * across all GenArt721CoreContractV3 flagship and derivative implementations.\\n * This interface extends the IManifold royalty interface in order to\\n * add support the Royalty Registry by default.\\n * @author Art Blocks Inc.\\n */\\ninterface IGenArt721CoreContractV3_Base is IManifold {\\n    /**\\n     * @notice Token ID `_tokenId` minted to `_to`.\\n     */\\n    event Mint(address indexed _to, uint256 indexed _tokenId);\\n\\n    /**\\n     * @notice currentMinter updated to `_currentMinter`.\\n     * @dev Implemented starting with V3 core\\n     */\\n    event MinterUpdated(address indexed _currentMinter);\\n\\n    /**\\n     * @notice Platform updated on bytes32-encoded field `_field`.\\n     */\\n    event PlatformUpdated(bytes32 indexed _field);\\n\\n    /**\\n     * @notice Project ID `_projectId` updated on bytes32-encoded field\\n     * `_update`.\\n     */\\n    event ProjectUpdated(uint256 indexed _projectId, bytes32 indexed _update);\\n\\n    event ProposedArtistAddressesAndSplits(\\n        uint256 indexed _projectId,\\n        address _artistAddress,\\n        address _additionalPayeePrimarySales,\\n        uint256 _additionalPayeePrimarySalesPercentage,\\n        address _additionalPayeeSecondarySales,\\n        uint256 _additionalPayeeSecondarySalesPercentage\\n    );\\n\\n    event AcceptedArtistAddressesAndSplits(uint256 indexed _projectId);\\n\\n    // version and type of the core contract\\n    // coreVersion is a string of the form \\\"0.x.y\\\"\\n    function coreVersion() external view returns (string memory);\\n\\n    // coreType is a string of the form \\\"GenArt721CoreV3\\\"\\n    function coreType() external view returns (string memory);\\n\\n    // owner (pre-V3 was named admin) of contract\\n    // this is expected to be an Admin ACL contract for V3\\n    function owner() external view returns (address);\\n\\n    // Admin ACL contract for V3, will be at the address owner()\\n    function adminACLContract() external returns (IAdminACLV0);\\n\\n    // backwards-compatible (pre-V3) admin - equal to owner()\\n    function admin() external view returns (address);\\n\\n    /**\\n     * Function determining if _sender is allowed to call function with\\n     * selector _selector on contract `_contract`. Intended to be used with\\n     * peripheral contracts such as minters, as well as internally by the\\n     * core contract itself.\\n     */\\n    function adminACLAllowed(\\n        address _sender,\\n        address _contract,\\n        bytes4 _selector\\n    ) external returns (bool);\\n\\n    /// getter function of public variable\\n    function startingProjectId() external view returns (uint256);\\n\\n    // getter function of public variable\\n    function nextProjectId() external view returns (uint256);\\n\\n    // getter function of public mapping\\n    function tokenIdToProjectId(\\n        uint256 tokenId\\n    ) external view returns (uint256 projectId);\\n\\n    // @dev this is not available in V0\\n    function isMintWhitelisted(address minter) external view returns (bool);\\n\\n    function projectIdToArtistAddress(\\n        uint256 _projectId\\n    ) external view returns (address payable);\\n\\n    function projectIdToAdditionalPayeePrimarySales(\\n        uint256 _projectId\\n    ) external view returns (address payable);\\n\\n    function projectIdToAdditionalPayeePrimarySalesPercentage(\\n        uint256 _projectId\\n    ) external view returns (uint256);\\n\\n    function projectIdToSecondaryMarketRoyaltyPercentage(\\n        uint256 _projectId\\n    ) external view returns (uint256);\\n\\n    function projectURIInfo(\\n        uint256 _projectId\\n    ) external view returns (string memory projectBaseURI);\\n\\n    // @dev new function in V3\\n    function projectStateData(\\n        uint256 _projectId\\n    )\\n        external\\n        view\\n        returns (\\n            uint256 invocations,\\n            uint256 maxInvocations,\\n            bool active,\\n            bool paused,\\n            uint256 completedTimestamp,\\n            bool locked\\n        );\\n\\n    function projectDetails(\\n        uint256 _projectId\\n    )\\n        external\\n        view\\n        returns (\\n            string memory projectName,\\n            string memory artist,\\n            string memory description,\\n            string memory website,\\n            string memory license\\n        );\\n\\n    function projectScriptDetails(\\n        uint256 _projectId\\n    )\\n        external\\n        view\\n        returns (\\n            string memory scriptTypeAndVersion,\\n            string memory aspectRatio,\\n            uint256 scriptCount\\n        );\\n\\n    function projectScriptByIndex(\\n        uint256 _projectId,\\n        uint256 _index\\n    ) external view returns (string memory);\\n\\n    function tokenIdToHash(uint256 _tokenId) external view returns (bytes32);\\n\\n    // function to set a token's hash (must be guarded)\\n    function setTokenHash_8PT(uint256 _tokenId, bytes32 _hash) external;\\n\\n    // @dev gas-optimized signature in V3 for `mint`\\n    function mint_Ecf(\\n        address _to,\\n        uint256 _projectId,\\n        address _by\\n    ) external returns (uint256 tokenId);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/v0.8.x/IManifold.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/// @dev Royalty Registry interface, used to support the Royalty Registry.\\n/// @dev Source: https://github.com/manifoldxyz/royalty-registry-solidity/blob/main/contracts/specs/IManifold.sol\\n\\n/// @author: manifold.xyz\\n\\n/**\\n * @dev Royalty interface for creator core classes\\n */\\ninterface IManifold {\\n    /**\\n     * @dev Get royalites of a token.  Returns list of receivers and basisPoints\\n     *\\n     *  bytes4(keccak256('getRoyalties(uint256)')) == 0xbb3bafd6\\n     *\\n     *  => 0xbb3bafd6 = 0xbb3bafd6\\n     */\\n    function getRoyalties(\\n        uint256 tokenId\\n    ) external view returns (address payable[] memory, uint256[] memory);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/v0.8.x/IPseudorandomAtomic.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\n// Creatd By: Art Blocks Inc.\\n\\npragma solidity ^0.8.0;\\n\\ninterface IPseudorandomAtomic {\\n    /**\\n     * @notice This function atomically returns a pseudorandom bytes32 value.\\n     * @param _entropy entropy to be included during the pseudorandom\\n     * generation process. An example of entropy might be the hash of a core\\n     * contract's address, and the ID of the token being generated.\\n     */\\n    function getPseudorandomAtomic(bytes32 _entropy) external returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/v0.8.x/IRandomizer_V3CoreBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\n// Creatd By: Art Blocks Inc.\\n\\npragma solidity ^0.8.0;\\n\\ninterface IRandomizer_V3CoreBase {\\n    /**\\n     * @notice This function is intended to be called by a core contract, and\\n     * the core contract can be assured that the randomizer will call back to\\n     * the calling contract to set the token hash seed for `_tokenId` via\\n     * `setTokenHash_8PT`.\\n     * @dev This function may revert if hash seed generation is improperly\\n     * configured (for example, if in polyptych mode, but no hash seed has been\\n     * previously configured).\\n     * @dev This function is not specifically gated to any specific caller, but\\n     * will only call back to the calling contract, `msg.sender`, to set the\\n     * specified token's hash seed.\\n     * A third party contract calling this function will not be able to set the\\n     * token hash seed on a different core contract.\\n     * @param _tokenId The token ID must be assigned a hash.\\n     */\\n    function assignTokenHash(uint256 _tokenId) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/v0.8.x/ISharedRandomizerV0.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\n// Creatd By: Art Blocks Inc.\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IRandomizer_V3CoreBase.sol\\\";\\n\\ninterface ISharedRandomizerV0 is IRandomizer_V3CoreBase {\\n    /**\\n     * @notice The pseudorandom atomic contract that is used to generate\\n     * pseudorandom values for this randomizer was updated.\\n     */\\n    event PseudorandomAtomicContractUpdated(\\n        address indexed pseudorandomAtomicContract\\n    );\\n\\n    /**\\n     * @notice Contract at `hashSeedSetterContract` allowed to assign\\n     * token hash seeds on core contract `coreContract` for project\\n     * `projectId`.\\n     */\\n    event HashSeedSetterForProjectUpdated(\\n        address indexed coreContract,\\n        uint256 indexed projectId,\\n        address indexed hashSeedSetterContract\\n    );\\n\\n    /**\\n     * @notice Project with ID `projectId` is is or is not using a hash seed\\n     * setter contract to assign token hash seeds on core contract.\\n     */\\n    event ProjectUsingHashSeedSetterUpdated(\\n        address coreContract,\\n        uint256 projectId,\\n        bool usingHashSeedSetter\\n    );\\n\\n    /**\\n     * @notice Allows the artist of a project to set the contract that is\\n     * allowed to assign hash seeds to tokens. Typically, this is expected to\\n     * be a minter contract, such as `MinterPolyptychV1`.\\n     * @param coreContract - the core contract that is being configured\\n     * @param projectId - the project ID that is being configured\\n     * @param hashSeedSetterContract - the contract that is allowed to assign\\n     * hash seeds to tokens\\n     */\\n    function setHashSeedSetterContract(\\n        address coreContract,\\n        uint256 projectId,\\n        address hashSeedSetterContract\\n    ) external;\\n\\n    /**\\n     * @notice Allows the artist of a project to configure their project to\\n     * only allow the specified hash seed setter contract to assign new token\\n     * hash seeds. When this is enabled, the hash seed setter contract is\\n     * responsible for assigning hash seeds to tokens, and the randomizer\\n     * contract will not use the pseudorandom atomic contract to generate\\n     * hash seeds.\\n     * An example use case is where the artist wants to mint a polyptych panel\\n     * (second, third, etc.) of a project, and therefore wants to re-use\\n     * specific hash seeds of the original project.\\n     * @param coreContract - The address of the core contract\\n     * @param projectId - The ID of the project to be toggled\\n     */\\n    function toggleProjectUseAssignedHashSeed(\\n        address coreContract,\\n        uint256 projectId\\n    ) external;\\n\\n    /**\\n     * @notice Pre-set the hash seed for a token. This function is only\\n     * callable by the hash seed setter contract of the project.\\n     * @param coreContract - The address of the core contract of `tokenId`\\n     * @param tokenId - The ID of the token to set the hash seed for\\n     * @param hashSeed - The hash seed to set for `tokenId`\\n     * @dev Only callable by the hash seed setter contract of `coreContract`.\\n     */\\n    function preSetHashSeed(\\n        address coreContract,\\n        uint256 tokenId,\\n        bytes12 hashSeed\\n    ) external;\\n\\n    /**\\n     * @notice Boolean representing whether or not project with ID `projectId`\\n     * on core contract `coreContract` is currently using a hash seed setter\\n     * contract to assign hash seeds to tokens.\\n     */\\n    function projectUsesHashSeedSetter(\\n        address coreContract,\\n        uint256 projectId\\n    ) external view returns (bool usingHashSeedSetter);\\n\\n    /**\\n     * Returns the hash seed setter contract for a given core contract.\\n     * Returns address(0) if no hash seed setter contract is set for the core.\\n     * @param coreContract - The address of the core contract\\n     * @param projectId - The ID of the project to query\\n     */\\n    function hashSeedSetterContracts(\\n        address coreContract,\\n        uint256 projectId\\n    ) external view returns (address hashSeedSetterContract);\\n\\n    /**\\n     * Returns the current pre-assigned hash seed for a given token ID.\\n     * Returns bytes12(0) if no hash seed has been set for the token.\\n     * Note that this only returns the pre-assigned hash seed for tokens that\\n     * are configured to use a hash seed setter contract. In typical cases\\n     * where the project is not configured to use a hash seed setter contract,\\n     * the hash seed is generated on-chain by the pseudorandom atomic contract\\n     * and is not stored on-chain in this randomizer contract, and therefore\\n     * this function will return bytes12(0).\\n     * @param coreContract - The address of the core contract of `tokenId`\\n     * @param tokenId - The ID of the token to get the hash seed for\\n     * @return hashSeed - The stored hash seed for `tokenId`\\n     */\\n    function preAssignedHashSeed(\\n        address coreContract,\\n        uint256 tokenId\\n    ) external view returns (bytes12 hashSeed);\\n}\\n\"\r\n    },\r\n    \"contracts/randomizer/shared/SharedRandomizerV0.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\n// Creatd By: Art Blocks Inc.\\n\\n// @dev fixed to specific solidity version for clarity and for more clear\\n// source code verification purposes.\\npragma solidity 0.8.19;\\n\\nimport \\\"../../interfaces/v0.8.x/IGenArt721CoreContractV3_Base.sol\\\";\\nimport \\\"../../interfaces/v0.8.x/ISharedRandomizerV0.sol\\\";\\nimport \\\"../../interfaces/v0.8.x/IPseudorandomAtomic.sol\\\";\\n\\n/**\\n * @title A shared randomizer contract that enables support of many Art Blocks\\n * and Art Blocks Engine core contracts with a single randomizer.\\n * @notice This randomizer is designed to be used with many core contracts that\\n * implement the `IGenArt721CoreContractV3_Base` interface. It exclusively uses\\n * atomic callbacks, and will assign a token's hash before returning from the\\n * `assignTokenHash` function, as long as the call does not revert.\\n *\\n * The randomizer generates a token's hash seed in one of two ways:\\n * 1. If the project of the token is specified as using a hash seed setter\\n * contract, the randomizer will assign the token the hash seed as previously\\n * pre-set by the project's hash seed setter contract. If no hash seed has\\n * been set, the randomizer will revert (will not assign null token hash).\\n * 2. If the project of the token is not specified as using a hash seed setter\\n * contract, the randomizer will generate a new hash seed using the\\n * `IPseudorandomAtomic` contract, which is immutable and set during\\n * deployment.\\n *\\n * @dev When using this randomizer for ployptych minting, several requirements\\n * may be required by the hash seed setter contract, including the possibility\\n * that a token's hash seed must be available in a public getter function on\\n * the core contract. Please inspect the hash seed setter contract to ensure\\n * that all requirements are met.\\n *\\n * @notice Privileged Roles and Ownership:\\n * Privileged roles and abilities are controlled by each core contract's\\n * artists.\\n * These roles hold extensive power and can influence the behavior of this\\n * randomizer.\\n * Care must be taken to ensure that the artist addresses are secure.\\n * ----------------------------------------------------------------------------\\n * The following functions are restricted to only the Artist address:\\n * - setHashSeedSetterContract\\n * - toggleProjectUseAssignedHashSeed\\n * ----------------------------------------------------------------------------\\n * The following function is restricted to only the hash seed setter contract\\n * of a given core contract:\\n * - preSetHashSeed\\n * ----------------------------------------------------------------------------\\n * Additional admin and artist privileged roles may be described on minters,\\n * registries, and other contracts that may interact with this randomizer.\\n */\\ncontract SharedRandomizerV0 is ISharedRandomizerV0 {\\n    IPseudorandomAtomic public immutable pseudorandomAtomicContract;\\n\\n    // constant used to obtain the project ID from the token ID\\n    uint256 internal constant ONE_MILLION = 1_000_000;\\n\\n    // mapping of core contract => token ID => pre-assigned hash seed\\n    // @dev this mapping is only used when the project is configured as using\\n    // a hash seed setter contract. It is not populated when the project is\\n    // using pseudorandomAtomicContract.\\n    mapping(address coreContract => mapping(uint256 tokenId => bytes12 preAssignedHashSeed))\\n        private _preAssignedHashSeeds;\\n\\n    // mapping of core contract => project ID => usesHashSeedSetter Contract\\n    mapping(address coreContract => mapping(uint256 projectId => bool usesHashSeedSetter))\\n        private _projectUsesHashSeedSetter;\\n\\n    // mapping of core contract => projectId => hash seed setter contract\\n    mapping(address coreContract => mapping(uint256 projectId => address hashSeedSetterContract))\\n        private _hashSeedSetterContracts;\\n\\n    // modifier to restrict access to only Artist allowed calls\\n    function _onlyArtist(\\n        address coreContract,\\n        uint256 projectId\\n    ) internal view {\\n        require(\\n            msg.sender ==\\n                IGenArt721CoreContractV3_Base(coreContract)\\n                    .projectIdToArtistAddress(projectId),\\n            \\\"Only Artist\\\"\\n        );\\n    }\\n\\n    /**\\n     * Modifier to restrict access to only calls by the hash seed setter\\n     * contract of a given project.\\n     * @param coreContract core contract address associated with the project\\n     * @param projectId project ID being set\\n     */\\n    function _onlyHashSeedSetterContract(\\n        address coreContract,\\n        uint256 projectId\\n    ) internal view {\\n        require(\\n            msg.sender == _hashSeedSetterContracts[coreContract][projectId],\\n            \\\"Only Hash Seed Setter Contract\\\"\\n        );\\n    }\\n\\n    /**\\n     *\\n     * @param pseudorandomAtomicContract_ Address of the pseudorandom atomic\\n     * contract to use for atomically generating random values. This contract\\n     * does not have an owner, and therefore the pseudorandom atomic contract\\n     * address cannot be changed after deployment.\\n     */\\n    constructor(address pseudorandomAtomicContract_) {\\n        pseudorandomAtomicContract = IPseudorandomAtomic(\\n            pseudorandomAtomicContract_\\n        );\\n        emit PseudorandomAtomicContractUpdated({\\n            pseudorandomAtomicContract: pseudorandomAtomicContract_\\n        });\\n    }\\n\\n    /**\\n     * @inheritdoc ISharedRandomizerV0\\n     */\\n    function setHashSeedSetterContract(\\n        address coreContract,\\n        uint256 projectId,\\n        address hashSeedSetterContract\\n    ) external {\\n        _onlyArtist({projectId: projectId, coreContract: coreContract});\\n        _hashSeedSetterContracts[coreContract][\\n            projectId\\n        ] = hashSeedSetterContract;\\n        emit HashSeedSetterForProjectUpdated({\\n            coreContract: coreContract,\\n            projectId: projectId,\\n            hashSeedSetterContract: hashSeedSetterContract\\n        });\\n    }\\n\\n    /**\\n     * @inheritdoc ISharedRandomizerV0\\n     */\\n    function toggleProjectUseAssignedHashSeed(\\n        address coreContract,\\n        uint256 projectId\\n    ) external {\\n        _onlyArtist({projectId: projectId, coreContract: coreContract});\\n        _projectUsesHashSeedSetter[coreContract][\\n            projectId\\n        ] = !_projectUsesHashSeedSetter[coreContract][projectId];\\n        emit ProjectUsingHashSeedSetterUpdated({\\n            coreContract: coreContract,\\n            projectId: projectId,\\n            usingHashSeedSetter: _projectUsesHashSeedSetter[coreContract][\\n                projectId\\n            ]\\n        });\\n    }\\n\\n    /**\\n     * @inheritdoc ISharedRandomizerV0\\n     */\\n    function preSetHashSeed(\\n        address coreContract,\\n        uint256 tokenId,\\n        bytes12 hashSeed\\n    ) external {\\n        uint256 projectId = _tokenIdToProjectId(tokenId);\\n        _onlyHashSeedSetterContract({\\n            projectId: projectId,\\n            coreContract: coreContract\\n        });\\n        _preAssignedHashSeeds[coreContract][tokenId] = hashSeed;\\n        // @dev event indicating token hash seed assigned is not required for\\n        // subgraph indexing because token hash seeds are still assigned\\n        // atomically in `assignTokenHash` function. If token hash seeds were\\n        // assigned async, event emission may be required to support subgraph\\n        // indexing.\\n    }\\n\\n    /**\\n     * @inheritdoc IRandomizer_V3CoreBase\\n     */\\n    function assignTokenHash(uint256 tokenId) external {\\n        // @dev This function is not specifically gated to any specific caller,\\n        // but will only call back to the calling contract, `msg.sender`, to\\n        // set the specified token's hash seed.\\n        // A third party contract calling this function will not be able to set\\n        // the token hash seed on a different core contract.\\n        // @dev variables are named to improve readability\\n        address coreContract = msg.sender;\\n        uint256 projectId = _tokenIdToProjectId(tokenId);\\n        bytes32 hashSeed;\\n        if (_projectUsesHashSeedSetter[coreContract][projectId]) {\\n            hashSeed = _preAssignedHashSeeds[coreContract][tokenId];\\n        } else {\\n            hashSeed = _getPseudorandomAtomic({\\n                coreContract: coreContract,\\n                tokenId: tokenId\\n            });\\n        }\\n        // verify that the hash seed is non-zero\\n        require(hashSeed != 0, \\\"Only non-zero hash seed\\\");\\n        // assign the token hash seed on the core contract\\n        IGenArt721CoreContractV3_Base(coreContract).setTokenHash_8PT({\\n            _tokenId: tokenId,\\n            _hash: hashSeed\\n        });\\n    }\\n\\n    /**\\n     * @inheritdoc ISharedRandomizerV0\\n     */\\n    function projectUsesHashSeedSetter(\\n        address coreContract,\\n        uint256 projectId\\n    ) external view returns (bool usingHashSeedSetter) {\\n        return _projectUsesHashSeedSetter[coreContract][projectId];\\n    }\\n\\n    /**\\n     * @inheritdoc ISharedRandomizerV0\\n     */\\n    function hashSeedSetterContracts(\\n        address coreContract,\\n        uint256 projectId\\n    ) external view returns (address _hashSeedSetterContract) {\\n        return _hashSeedSetterContracts[coreContract][projectId];\\n    }\\n\\n    /**\\n     * @inheritdoc ISharedRandomizerV0\\n     */\\n    function preAssignedHashSeed(\\n        address coreContract,\\n        uint256 tokenId\\n    ) external view returns (bytes12 _hashSeed) {\\n        return _preAssignedHashSeeds[coreContract][tokenId];\\n    }\\n\\n    /**\\n     * @notice Internal function to atomically obtain a pseudorandom number\\n     * from the configured pseudorandom contract.\\n     * @param coreContract - The core contract that is requesting an atomic\\n     * pseudorandom number.\\n     * @param tokenId - The token ID on `coreContract` that is associated\\n     * with the pseudorandom number request.\\n     */\\n    function _getPseudorandomAtomic(\\n        address coreContract,\\n        uint256 tokenId\\n    ) internal returns (bytes32) {\\n        return\\n            pseudorandomAtomicContract.getPseudorandomAtomic(\\n                keccak256(abi.encodePacked(coreContract, tokenId))\\n            );\\n    }\\n\\n    /**\\n     * @notice Gets the project ID for a given `tokenId`.\\n     * @param tokenId Token ID to be queried.\\n     * @return projectId Project ID for given `tokenId`.\\n     */\\n    function _tokenIdToProjectId(\\n        uint256 tokenId\\n    ) internal pure returns (uint256 projectId) {\\n        return tokenId / ONE_MILLION;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 25\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pseudorandomAtomicContract_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"coreContract\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"hashSeedSetterContract\",\"type\":\"address\"}],\"name\":\"HashSeedSetterForProjectUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"coreContract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"usingHashSeedSetter\",\"type\":\"bool\"}],\"name\":\"ProjectUsingHashSeedSetterUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pseudorandomAtomicContract\",\"type\":\"address\"}],\"name\":\"PseudorandomAtomicContractUpdated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"assignTokenHash\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"coreContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"}],\"name\":\"hashSeedSetterContracts\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_hashSeedSetterContract\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"coreContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"preAssignedHashSeed\",\"outputs\":[{\"internalType\":\"bytes12\",\"name\":\"_hashSeed\",\"type\":\"bytes12\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"coreContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes12\",\"name\":\"hashSeed\",\"type\":\"bytes12\"}],\"name\":\"preSetHashSeed\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"coreContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"}],\"name\":\"projectUsesHashSeedSetter\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"usingHashSeedSetter\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pseudorandomAtomicContract\",\"outputs\":[{\"internalType\":\"contract IPseudorandomAtomic\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"coreContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"hashSeedSetterContract\",\"type\":\"address\"}],\"name\":\"setHashSeedSetterContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"coreContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"}],\"name\":\"toggleProjectUseAssignedHashSeed\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "SharedRandomizerV0", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "25", "ConstructorArguments": "00000000000000000000000029c2931a018a9298208ccff4659730cc1b87f1c9", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}