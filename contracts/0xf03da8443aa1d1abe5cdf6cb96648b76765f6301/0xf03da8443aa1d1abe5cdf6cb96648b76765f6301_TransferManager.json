{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/TransferManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.20;\\n\\nimport { OwnableTwoSteps } from \\\"./OwnableTwoSteps.sol\\\";\\nimport { LowLevelERC20Transfer } from \\\"./lowLevelCallers/LowLevelERC20Transfer.sol\\\";\\nimport { LowLevelERC721Transfer } from \\\"./lowLevelCallers/LowLevelERC721Transfer.sol\\\";\\nimport { LowLevelERC1155Transfer } from \\\"./lowLevelCallers/LowLevelERC1155Transfer.sol\\\";\\n\\n// Interfaces and errors\\nimport { ITransferManager } from \\\"./interfaces/ITransferManager.sol\\\";\\nimport { AmountInvalid, LengthsInvalid } from \\\"./errors/SharedErrors.sol\\\";\\n\\n// Enums\\nimport { TokenType } from \\\"./enums/TokenType.sol\\\";\\n\\n/**\\n * @title TransferManager\\n * @notice This contract provides the transfer functions for ERC20/ERC721/ERC1155 for contracts that require them.\\n *         Token type \\\"0\\\" refers to ERC20 transfer functions.\\n *         Token type \\\"1\\\" refers to ERC721 transfer functions.\\n *         Token type \\\"2\\\" refers to ERC1155 transfer functions.\\n * @dev \\\"Safe\\\" transfer functions for ERC721 are not implemented since they come with added gas costs\\n *       to verify if the recipient is a contract as it requires verifying the receiver interface is valid.\\n */\\ncontract TransferManager is\\n    ITransferManager,\\n    LowLevelERC20Transfer,\\n    LowLevelERC721Transfer,\\n    LowLevelERC1155Transfer,\\n    OwnableTwoSteps\\n{\\n    /**\\n     * @notice This returns whether the user has approved the operator address.\\n     * The first address is the user and the second address is the operator.\\n     */\\n    mapping(address => mapping(address => bool)) public hasUserApprovedOperator;\\n\\n    /**\\n     * @notice This returns whether the operator address is allowed by this contract's owner.\\n     */\\n    mapping(address => bool) public isOperatorAllowed;\\n\\n    /**\\n     * @notice Constructor\\n     * @param _owner Owner address\\n     */\\n    constructor(address _owner) OwnableTwoSteps(_owner) { }\\n\\n    /**\\n     * @inheritdoc ITransferManager\\n     */\\n    function transferERC20(address tokenAddress, address from, address to, uint256 amount) external {\\n        _isOperatorValidForTransfer(from, msg.sender);\\n\\n        if (amount == 0) {\\n            revert AmountInvalid();\\n        }\\n\\n        _executeERC20TransferFrom(tokenAddress, from, to, amount);\\n    }\\n\\n    /**\\n     * @inheritdoc ITransferManager\\n     */\\n    function transferItemERC721(address tokenAddress, address from, address to, uint256 itemId) external {\\n        _isOperatorValidForTransfer(from, msg.sender);\\n        _executeERC721TransferFrom(tokenAddress, from, to, itemId);\\n    }\\n\\n    /**\\n     * @inheritdoc ITransferManager\\n     */\\n    function transferItemsERC721(\\n        address tokenAddress,\\n        address from,\\n        address to,\\n        uint256[] calldata itemIds,\\n        uint256[] calldata amounts\\n    )\\n        external\\n    {\\n        uint256 length = itemIds.length;\\n        if (length == 0 || amounts.length != length) {\\n            revert LengthsInvalid();\\n        }\\n\\n        _isOperatorValidForTransfer(from, msg.sender);\\n\\n        for (uint256 i; i < length;) {\\n            if (amounts[i] != 1) {\\n                revert AmountInvalid();\\n            }\\n            _executeERC721TransferFrom(tokenAddress, from, to, itemIds[i]);\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @inheritdoc ITransferManager\\n     */\\n    function transferItemERC1155(\\n        address tokenAddress,\\n        address from,\\n        address to,\\n        uint256 itemId,\\n        uint256 amount\\n    )\\n        external\\n    {\\n        _isOperatorValidForTransfer(from, msg.sender);\\n        if (amount == 0) {\\n            revert AmountInvalid();\\n        }\\n        _executeERC1155SafeTransferFrom(tokenAddress, from, to, itemId, amount);\\n    }\\n\\n    /**\\n     * @inheritdoc ITransferManager\\n     */\\n    function transferItemsERC1155(\\n        address tokenAddress,\\n        address from,\\n        address to,\\n        uint256[] calldata itemIds,\\n        uint256[] calldata amounts\\n    )\\n        external\\n    {\\n        uint256 length = itemIds.length;\\n\\n        if (length == 0 || amounts.length != length) {\\n            revert LengthsInvalid();\\n        }\\n\\n        _isOperatorValidForTransfer(from, msg.sender);\\n\\n        if (length == 1) {\\n            if (amounts[0] == 0) {\\n                revert AmountInvalid();\\n            }\\n            _executeERC1155SafeTransferFrom(tokenAddress, from, to, itemIds[0], amounts[0]);\\n        } else {\\n            for (uint256 i; i < length;) {\\n                if (amounts[i] == 0) {\\n                    revert AmountInvalid();\\n                }\\n\\n                unchecked {\\n                    ++i;\\n                }\\n            }\\n            _executeERC1155SafeBatchTransferFrom(tokenAddress, from, to, itemIds, amounts);\\n        }\\n    }\\n\\n    /**\\n     * @inheritdoc ITransferManager\\n     */\\n    function transferBatchItemsAcrossCollections(\\n        BatchTransferItem[] calldata items,\\n        address from,\\n        address to\\n    )\\n        external\\n    {\\n        uint256 itemsLength = items.length;\\n\\n        if (itemsLength == 0) {\\n            revert LengthsInvalid();\\n        }\\n\\n        if (from != msg.sender) {\\n            _isOperatorValidForTransfer(from, msg.sender);\\n        }\\n\\n        for (uint256 i; i < itemsLength;) {\\n            uint256[] calldata itemIds = items[i].itemIds;\\n            uint256 itemIdsLengthForSingleCollection = itemIds.length;\\n            uint256[] calldata amounts = items[i].amounts;\\n\\n            TokenType tokenType = items[i].tokenType;\\n\\n            if (tokenType == TokenType.ERC20) {\\n                if (itemIdsLengthForSingleCollection != 0 || amounts.length != 1) {\\n                    revert LengthsInvalid();\\n                }\\n            } else {\\n                if (itemIdsLengthForSingleCollection == 0 || amounts.length != itemIdsLengthForSingleCollection) {\\n                    revert LengthsInvalid();\\n                }\\n            }\\n\\n            if (tokenType == TokenType.ERC20) {\\n                uint256 amount = amounts[0];\\n                if (amount == 0) {\\n                    revert AmountInvalid();\\n                }\\n                _executeERC20TransferFrom(items[i].tokenAddress, from, to, amount);\\n            } else if (tokenType == TokenType.ERC721) {\\n                for (uint256 j; j < itemIdsLengthForSingleCollection;) {\\n                    if (amounts[j] != 1) {\\n                        revert AmountInvalid();\\n                    }\\n                    _executeERC721TransferFrom(items[i].tokenAddress, from, to, itemIds[j]);\\n                    unchecked {\\n                        ++j;\\n                    }\\n                }\\n            } else if (tokenType == TokenType.ERC1155) {\\n                for (uint256 j; j < itemIdsLengthForSingleCollection;) {\\n                    if (amounts[j] == 0) {\\n                        revert AmountInvalid();\\n                    }\\n\\n                    unchecked {\\n                        ++j;\\n                    }\\n                }\\n                _executeERC1155SafeBatchTransferFrom(items[i].tokenAddress, from, to, itemIds, amounts);\\n            }\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @inheritdoc ITransferManager\\n     */\\n    function grantApprovals(address[] calldata operators) external {\\n        uint256 length = operators.length;\\n\\n        if (length == 0) {\\n            revert LengthsInvalid();\\n        }\\n\\n        for (uint256 i; i < length;) {\\n            address operator = operators[i];\\n\\n            if (!isOperatorAllowed[operator]) {\\n                revert OperatorNotAllowed();\\n            }\\n\\n            if (hasUserApprovedOperator[msg.sender][operator]) {\\n                revert OperatorAlreadyApprovedByUser();\\n            }\\n\\n            hasUserApprovedOperator[msg.sender][operator] = true;\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        emit ApprovalsGranted(msg.sender, operators);\\n    }\\n\\n    /**\\n     * @inheritdoc ITransferManager\\n     */\\n    function revokeApprovals(address[] calldata operators) external {\\n        uint256 length = operators.length;\\n        if (length == 0) {\\n            revert LengthsInvalid();\\n        }\\n\\n        for (uint256 i; i < length;) {\\n            address operator = operators[i];\\n\\n            if (!hasUserApprovedOperator[msg.sender][operator]) {\\n                revert OperatorNotApprovedByUser();\\n            }\\n\\n            delete hasUserApprovedOperator[msg.sender][operator];\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        emit ApprovalsRemoved(msg.sender, operators);\\n    }\\n\\n    /**\\n     * @inheritdoc ITransferManager\\n     */\\n    function allowOperator(address operator) external onlyOwner {\\n        if (isOperatorAllowed[operator]) {\\n            revert OperatorAlreadyAllowed();\\n        }\\n\\n        isOperatorAllowed[operator] = true;\\n\\n        emit OperatorAllowed(operator);\\n    }\\n\\n    /**\\n     * @inheritdoc ITransferManager\\n     */\\n    function removeOperator(address operator) external onlyOwner {\\n        if (!isOperatorAllowed[operator]) {\\n            revert OperatorNotAllowed();\\n        }\\n\\n        delete isOperatorAllowed[operator];\\n\\n        emit OperatorRemoved(operator);\\n    }\\n\\n    /**\\n     * @notice This function is internal and verifies whether the transfer\\n     *         (by an operator on behalf of a user) is valid. If not, it reverts.\\n     * @param user User address\\n     * @param operator Operator address\\n     */\\n    function _isOperatorValidForTransfer(address user, address operator) private view {\\n        if (isOperatorAllowed[operator] && hasUserApprovedOperator[user][operator]) {\\n            return;\\n        }\\n\\n        revert TransferCallerInvalid();\\n    }\\n}\\n\"\r\n    },\r\n    \"src/OwnableTwoSteps.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\n// Interfaces\\nimport {IOwnableTwoSteps} from \\\"./interfaces/IOwnableTwoSteps.sol\\\";\\n\\n/**\\n * @title OwnableTwoSteps\\n * @notice This contract offers transfer of ownership in two steps with potential owner\\n *         having to confirm the transaction to become the owner.\\n *         Renouncement of the ownership is also a two-step process since the next potential owner is the address(0).\\n */\\nabstract contract OwnableTwoSteps is IOwnableTwoSteps {\\n    /**\\n     * @notice Address of the current owner.\\n     */\\n    address public owner;\\n\\n    /**\\n     * @notice Address of the potential owner.\\n     */\\n    address public potentialOwner;\\n\\n    /**\\n     * @notice Ownership status.\\n     */\\n    Status public ownershipStatus;\\n\\n    /**\\n     * @notice Modifier to wrap functions for contracts that inherit this contract.\\n     */\\n    modifier onlyOwner() {\\n        _onlyOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @notice Constructor\\n     * @param _owner The contract's owner\\n     */\\n    constructor(address _owner) {\\n        owner = _owner;\\n        emit NewOwner(_owner);\\n    }\\n\\n    /**\\n     * @notice This function is used to cancel the ownership transfer.\\n     * @dev This function can be used for both cancelling a transfer to a new owner and\\n     *      cancelling the renouncement of the ownership.\\n     */\\n    function cancelOwnershipTransfer() external onlyOwner {\\n        Status _ownershipStatus = ownershipStatus;\\n        if (_ownershipStatus == Status.NoOngoingTransfer) {\\n            revert NoOngoingTransferInProgress();\\n        }\\n\\n        if (_ownershipStatus == Status.TransferInProgress) {\\n            delete potentialOwner;\\n        }\\n\\n        delete ownershipStatus;\\n\\n        emit CancelOwnershipTransfer();\\n    }\\n\\n    /**\\n     * @notice This function is used to confirm the ownership renouncement.\\n     */\\n    function confirmOwnershipRenouncement() external onlyOwner {\\n        if (ownershipStatus != Status.RenouncementInProgress) {\\n            revert RenouncementNotInProgress();\\n        }\\n\\n        delete owner;\\n        delete ownershipStatus;\\n\\n        emit NewOwner(address(0));\\n    }\\n\\n    /**\\n     * @notice This function is used to confirm the ownership transfer.\\n     * @dev This function can only be called by the current potential owner.\\n     */\\n    function confirmOwnershipTransfer() external {\\n        if (ownershipStatus != Status.TransferInProgress) {\\n            revert TransferNotInProgress();\\n        }\\n\\n        if (msg.sender != potentialOwner) {\\n            revert WrongPotentialOwner();\\n        }\\n\\n        owner = msg.sender;\\n        delete ownershipStatus;\\n        delete potentialOwner;\\n\\n        emit NewOwner(msg.sender);\\n    }\\n\\n    /**\\n     * @notice This function is used to initiate the transfer of ownership to a new owner.\\n     * @param newPotentialOwner New potential owner address\\n     */\\n    function initiateOwnershipTransfer(address newPotentialOwner) external onlyOwner {\\n        if (ownershipStatus != Status.NoOngoingTransfer) {\\n            revert TransferAlreadyInProgress();\\n        }\\n\\n        ownershipStatus = Status.TransferInProgress;\\n        potentialOwner = newPotentialOwner;\\n\\n        /**\\n         * @dev This function can only be called by the owner, so msg.sender is the owner.\\n         *      We don't have to SLOAD the owner again.\\n         */\\n        emit InitiateOwnershipTransfer(msg.sender, newPotentialOwner);\\n    }\\n\\n    /**\\n     * @notice This function is used to initiate the ownership renouncement.\\n     */\\n    function initiateOwnershipRenouncement() external onlyOwner {\\n        if (ownershipStatus != Status.NoOngoingTransfer) {\\n            revert TransferAlreadyInProgress();\\n        }\\n\\n        ownershipStatus = Status.RenouncementInProgress;\\n\\n        emit InitiateOwnershipRenouncement();\\n    }\\n\\n    function _onlyOwner() private view {\\n        if (msg.sender != owner) revert NotOwner();\\n    }\\n}\\n\"\r\n    },\r\n    \"src/lowLevelCallers/LowLevelERC20Transfer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\n// Interfaces\\nimport {IERC20} from \\\"../interfaces/generic/IERC20.sol\\\";\\n\\n// Errors\\nimport {ERC20TransferFail, ERC20TransferFromFail} from \\\"../errors/LowLevelErrors.sol\\\";\\nimport {NotAContract} from \\\"../errors/GenericErrors.sol\\\";\\n\\n/**\\n * @title LowLevelERC20Transfer\\n * @notice This contract contains low-level calls to transfer ERC20 tokens.\\n */\\ncontract LowLevelERC20Transfer {\\n    /**\\n     * @notice Execute ERC20 transferFrom\\n     * @param currency Currency address\\n     * @param from Sender address\\n     * @param to Recipient address\\n     * @param amount Amount to transfer\\n     */\\n    function _executeERC20TransferFrom(address currency, address from, address to, uint256 amount) internal {\\n        if (currency.code.length == 0) {\\n            revert NotAContract();\\n        }\\n\\n        (bool status, bytes memory data) = currency.call(abi.encodeCall(IERC20.transferFrom, (from, to, amount)));\\n\\n        if (!status) {\\n            revert ERC20TransferFromFail();\\n        }\\n\\n        if (data.length > 0) {\\n            if (!abi.decode(data, (bool))) {\\n                revert ERC20TransferFromFail();\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Execute ERC20 (direct) transfer\\n     * @param currency Currency address\\n     * @param to Recipient address\\n     * @param amount Amount to transfer\\n     */\\n    function _executeERC20DirectTransfer(address currency, address to, uint256 amount) internal {\\n        if (currency.code.length == 0) {\\n            revert NotAContract();\\n        }\\n\\n        (bool status, bytes memory data) = currency.call(abi.encodeCall(IERC20.transfer, (to, amount)));\\n\\n        if (!status) {\\n            revert ERC20TransferFail();\\n        }\\n\\n        if (data.length > 0) {\\n            if (!abi.decode(data, (bool))) {\\n                revert ERC20TransferFail();\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/lowLevelCallers/LowLevelERC721Transfer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\n// Interfaces\\nimport {IERC721} from \\\"../interfaces/generic/IERC721.sol\\\";\\n\\n// Errors\\nimport {ERC721TransferFromFail} from \\\"../errors/LowLevelErrors.sol\\\";\\nimport {NotAContract} from \\\"../errors/GenericErrors.sol\\\";\\n\\n/**\\n * @title LowLevelERC721Transfer\\n * @notice This contract contains low-level calls to transfer ERC721 tokens.\\n */\\ncontract LowLevelERC721Transfer {\\n    /**\\n     * @notice Execute ERC721 transferFrom\\n     * @param collection Address of the collection\\n     * @param from Address of the sender\\n     * @param to Address of the recipient\\n     * @param tokenId tokenId to transfer\\n     */\\n    function _executeERC721TransferFrom(address collection, address from, address to, uint256 tokenId) internal {\\n        if (collection.code.length == 0) {\\n            revert NotAContract();\\n        }\\n\\n        (bool status, ) = collection.call(abi.encodeCall(IERC721.transferFrom, (from, to, tokenId)));\\n\\n        if (!status) {\\n            revert ERC721TransferFromFail();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/lowLevelCallers/LowLevelERC1155Transfer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\n// Interfaces\\nimport {IERC1155} from \\\"../interfaces/generic/IERC1155.sol\\\";\\n\\n// Errors\\nimport {ERC1155SafeTransferFromFail, ERC1155SafeBatchTransferFromFail} from \\\"../errors/LowLevelErrors.sol\\\";\\nimport {NotAContract} from \\\"../errors/GenericErrors.sol\\\";\\n\\n/**\\n * @title LowLevelERC1155Transfer\\n * @notice This contract contains low-level calls to transfer ERC1155 tokens.\\n */\\ncontract LowLevelERC1155Transfer {\\n    /**\\n     * @notice Execute ERC1155 safeTransferFrom\\n     * @param collection Address of the collection\\n     * @param from Address of the sender\\n     * @param to Address of the recipient\\n     * @param tokenId tokenId to transfer\\n     * @param amount Amount to transfer\\n     */\\n    function _executeERC1155SafeTransferFrom(\\n        address collection,\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        uint256 amount\\n    ) internal {\\n        if (collection.code.length == 0) {\\n            revert NotAContract();\\n        }\\n\\n        (bool status, ) = collection.call(abi.encodeCall(IERC1155.safeTransferFrom, (from, to, tokenId, amount, \\\"\\\")));\\n\\n        if (!status) {\\n            revert ERC1155SafeTransferFromFail();\\n        }\\n    }\\n\\n    /**\\n     * @notice Execute ERC1155 safeBatchTransferFrom\\n     * @param collection Address of the collection\\n     * @param from Address of the sender\\n     * @param to Address of the recipient\\n     * @param tokenIds Array of tokenIds to transfer\\n     * @param amounts Array of amounts to transfer\\n     */\\n    function _executeERC1155SafeBatchTransferFrom(\\n        address collection,\\n        address from,\\n        address to,\\n        uint256[] calldata tokenIds,\\n        uint256[] calldata amounts\\n    ) internal {\\n        if (collection.code.length == 0) {\\n            revert NotAContract();\\n        }\\n\\n        (bool status, ) = collection.call(\\n            abi.encodeCall(IERC1155.safeBatchTransferFrom, (from, to, tokenIds, amounts, \\\"\\\"))\\n        );\\n\\n        if (!status) {\\n            revert ERC1155SafeBatchTransferFromFail();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ITransferManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.20;\\n\\n// Enums\\nimport { TokenType } from \\\"../enums/TokenType.sol\\\";\\n\\n/**\\n * @title ITransferManager\\n */\\ninterface ITransferManager {\\n    /**\\n     * @notice This struct is only used for transferBatchItemsAcrossCollections.\\n     * @param tokenAddress Token address\\n     * @param tokenType 0 for ERC721, 1 for ERC1155\\n     * @param itemIds Array of item ids to transfer\\n     * @param amounts Array of amounts to transfer\\n     */\\n    struct BatchTransferItem {\\n        address tokenAddress;\\n        TokenType tokenType;\\n        uint256[] itemIds;\\n        uint256[] amounts;\\n    }\\n\\n    /**\\n     * @notice It is emitted if operators' approvals to transfer NFTs are granted by a user.\\n     * @param user Address of the user\\n     * @param operators Array of operator addresses\\n     */\\n    event ApprovalsGranted(address user, address[] operators);\\n\\n    /**\\n     * @notice It is emitted if operators' approvals to transfer NFTs are revoked by a user.\\n     * @param user Address of the user\\n     * @param operators Array of operator addresses\\n     */\\n    event ApprovalsRemoved(address user, address[] operators);\\n\\n    /**\\n     * @notice It is emitted if a new operator is added to the global allowlist.\\n     * @param operator Operator address\\n     */\\n    event OperatorAllowed(address operator);\\n\\n    /**\\n     * @notice It is emitted if an operator is removed from the global allowlist.\\n     * @param operator Operator address\\n     */\\n    event OperatorRemoved(address operator);\\n\\n    /**\\n     * @notice It is returned if the operator to approve has already been approved by the user.\\n     */\\n    error OperatorAlreadyApprovedByUser();\\n\\n    /**\\n     * @notice It is returned if the operator to revoke has not been previously approved by the user.\\n     */\\n    error OperatorNotApprovedByUser();\\n\\n    /**\\n     * @notice It is returned if the transfer caller is already allowed by the owner.\\n     * @dev This error can only be returned for owner operations.\\n     */\\n    error OperatorAlreadyAllowed();\\n\\n    /**\\n     * @notice It is returned if the operator to approve is not in the global allowlist defined by the owner.\\n     * @dev This error can be returned if the user tries to grant approval to an operator address not in the\\n     *      allowlist or if the owner tries to remove the operator from the global allowlist.\\n     */\\n    error OperatorNotAllowed();\\n\\n    /**\\n     * @notice It is returned if the transfer caller is invalid.\\n     *         For a transfer called to be valid, the operator must be in the global allowlist and\\n     *         approved by the 'from' user.\\n     */\\n    error TransferCallerInvalid();\\n\\n    /**\\n     * @notice This function transfers ERC20 tokens.\\n     * @param tokenAddress Token address\\n     * @param from Sender address\\n     * @param to Recipient address\\n     * @param amount amount\\n     */\\n    function transferERC20(address tokenAddress, address from, address to, uint256 amount) external;\\n\\n    /**\\n     * @notice This function transfers a single item for a single ERC721 collection.\\n     * @param tokenAddress Token address\\n     * @param from Sender address\\n     * @param to Recipient address\\n     * @param itemId Item ID\\n     */\\n    function transferItemERC721(address tokenAddress, address from, address to, uint256 itemId) external;\\n\\n    /**\\n     * @notice This function transfers items for a single ERC721 collection.\\n     * @param tokenAddress Token address\\n     * @param from Sender address\\n     * @param to Recipient address\\n     * @param itemIds Array of itemIds\\n     * @param amounts Array of amounts\\n     */\\n    function transferItemsERC721(\\n        address tokenAddress,\\n        address from,\\n        address to,\\n        uint256[] calldata itemIds,\\n        uint256[] calldata amounts\\n    )\\n        external;\\n\\n    /**\\n     * @notice This function transfers a single item for a single ERC1155 collection.\\n     * @param tokenAddress Token address\\n     * @param from Sender address\\n     * @param to Recipient address\\n     * @param itemId Item ID\\n     * @param amount Amount\\n     */\\n    function transferItemERC1155(\\n        address tokenAddress,\\n        address from,\\n        address to,\\n        uint256 itemId,\\n        uint256 amount\\n    )\\n        external;\\n\\n    /**\\n     * @notice This function transfers items for a single ERC1155 collection.\\n     * @param tokenAddress Token address\\n     * @param from Sender address\\n     * @param to Recipient address\\n     * @param itemIds Array of itemIds\\n     * @param amounts Array of amounts\\n     * @dev It does not allow batch transferring if from = msg.sender since native function should be used.\\n     */\\n    function transferItemsERC1155(\\n        address tokenAddress,\\n        address from,\\n        address to,\\n        uint256[] calldata itemIds,\\n        uint256[] calldata amounts\\n    )\\n        external;\\n\\n    /**\\n     * @notice This function transfers items across an array of tokens that can be ERC20, ERC721 and ERC1155.\\n     * @param items Array of BatchTransferItem\\n     * @param from Sender address\\n     * @param to Recipient address\\n     */\\n    function transferBatchItemsAcrossCollections(\\n        BatchTransferItem[] calldata items,\\n        address from,\\n        address to\\n    )\\n        external;\\n\\n    /**\\n     * @notice This function allows a user to grant approvals for an array of operators.\\n     *         Users cannot grant approvals if the operator is not allowed by this contract's owner.\\n     * @param operators Array of operator addresses\\n     * @dev Each operator address must be globally allowed to be approved.\\n     */\\n    function grantApprovals(address[] calldata operators) external;\\n\\n    /**\\n     * @notice This function allows a user to revoke existing approvals for an array of operators.\\n     * @param operators Array of operator addresses\\n     * @dev Each operator address must be approved at the user level to be revoked.\\n     */\\n    function revokeApprovals(address[] calldata operators) external;\\n\\n    /**\\n     * @notice This function allows an operator to be added for the shared transfer system.\\n     *         Once the operator is allowed, users can grant NFT approvals to this operator.\\n     * @param operator Operator address to allow\\n     * @dev Only callable by owner.\\n     */\\n    function allowOperator(address operator) external;\\n\\n    /**\\n     * @notice This function allows the user to remove an operator for the shared transfer system.\\n     * @param operator Operator address to remove\\n     * @dev Only callable by owner.\\n     */\\n    function removeOperator(address operator) external;\\n}\\n\"\r\n    },\r\n    \"src/errors/SharedErrors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.20;\\n\\n/**\\n * @notice It is returned if the amount is invalid.\\n *         For ERC20, if amount is 0.\\n *         For ERC721, any number that is not 1.\\n *         For ERC1155, if amount is 0.\\n */\\nerror AmountInvalid();\\n\\n/**\\n * @notice It is returned if there is either a mismatch or an error in the length of the array(s).\\n */\\nerror LengthsInvalid();\\n\"\r\n    },\r\n    \"src/enums/TokenType.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.20;\\n\\nenum TokenType {\\n    ERC20,\\n    ERC721,\\n    ERC1155\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IOwnableTwoSteps.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\n/**\\n * @title IOwnableTwoSteps\\n */\\ninterface IOwnableTwoSteps {\\n    /**\\n     * @notice This enum keeps track of the ownership status.\\n     * @param NoOngoingTransfer The default status when the owner is set\\n     * @param TransferInProgress The status when a transfer to a new owner is initialized\\n     * @param RenouncementInProgress The status when a transfer to address(0) is initialized\\n     */\\n    enum Status {\\n        NoOngoingTransfer,\\n        TransferInProgress,\\n        RenouncementInProgress\\n    }\\n\\n    /**\\n     * @notice This is returned when there is no transfer of ownership in progress.\\n     */\\n    error NoOngoingTransferInProgress();\\n\\n    /**\\n     * @notice This is returned when the caller is not the owner.\\n     */\\n    error NotOwner();\\n\\n    /**\\n     * @notice This is returned when there is no renouncement in progress but\\n     *         the owner tries to validate the ownership renouncement.\\n     */\\n    error RenouncementNotInProgress();\\n\\n    /**\\n     * @notice This is returned when the transfer is already in progress but the owner tries\\n     *         initiate a new ownership transfer.\\n     */\\n    error TransferAlreadyInProgress();\\n\\n    /**\\n     * @notice This is returned when there is no ownership transfer in progress but the\\n     *         ownership change tries to be approved.\\n     */\\n    error TransferNotInProgress();\\n\\n    /**\\n     * @notice This is returned when the ownership transfer is attempted to be validated by the\\n     *         a caller that is not the potential owner.\\n     */\\n    error WrongPotentialOwner();\\n\\n    /**\\n     * @notice This is emitted if the ownership transfer is cancelled.\\n     */\\n    event CancelOwnershipTransfer();\\n\\n    /**\\n     * @notice This is emitted if the ownership renouncement is initiated.\\n     */\\n    event InitiateOwnershipRenouncement();\\n\\n    /**\\n     * @notice This is emitted if the ownership transfer is initiated.\\n     * @param previousOwner Previous/current owner\\n     * @param potentialOwner Potential/future owner\\n     */\\n    event InitiateOwnershipTransfer(address previousOwner, address potentialOwner);\\n\\n    /**\\n     * @notice This is emitted when there is a new owner.\\n     */\\n    event NewOwner(address newOwner);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/generic/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\ninterface IERC20 {\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"src/errors/LowLevelErrors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\n/**\\n * @notice It is emitted if the ETH transfer fails.\\n */\\nerror ETHTransferFail();\\n\\n/**\\n * @notice It is emitted if the ERC20 approval fails.\\n */\\nerror ERC20ApprovalFail();\\n\\n/**\\n * @notice It is emitted if the ERC20 transfer fails.\\n */\\nerror ERC20TransferFail();\\n\\n/**\\n * @notice It is emitted if the ERC20 transferFrom fails.\\n */\\nerror ERC20TransferFromFail();\\n\\n/**\\n * @notice It is emitted if the ERC721 transferFrom fails.\\n */\\nerror ERC721TransferFromFail();\\n\\n/**\\n * @notice It is emitted if the ERC1155 safeTransferFrom fails.\\n */\\nerror ERC1155SafeTransferFromFail();\\n\\n/**\\n * @notice It is emitted if the ERC1155 safeBatchTransferFrom fails.\\n */\\nerror ERC1155SafeBatchTransferFromFail();\\n\"\r\n    },\r\n    \"src/errors/GenericErrors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\n/**\\n * @notice It is emitted if the call recipient is not a contract.\\n */\\nerror NotAContract();\\n\"\r\n    },\r\n    \"src/interfaces/generic/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\ninterface IERC721 {\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    function approve(address to, uint256 tokenId) external;\\n\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/generic/IERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\ninterface IERC1155 {\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] values\\n    );\\n\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n\\n    event URI(string value, uint256 indexed id);\\n\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    function balanceOfBatch(\\n        address[] calldata accounts,\\n        uint256[] calldata ids\\n    ) external view returns (uint256[] memory);\\n\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\\n\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@chainlink/contracts/=lib/chainlink/contracts/\",\r\n      \"@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/\",\r\n      \"chainlink/=lib/chainlink/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"lib/forge-std:ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"lib/openzeppelin-contracts:ds-test/=lib/openzeppelin-contracts/lib/forge-std/lib/ds-test/src/\",\r\n      \"lib/openzeppelin-contracts:erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"lib/openzeppelin-contracts:forge-std/=lib/openzeppelin-contracts/lib/forge-std/src/\",\r\n      \"lib/openzeppelin-contracts:openzeppelin/=lib/openzeppelin-contracts/contracts/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 5000\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"viaIR\": true,\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AmountInvalid\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC1155SafeBatchTransferFromFail\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC1155SafeTransferFromFail\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC20TransferFromFail\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC721TransferFromFail\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LengthsInvalid\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoOngoingTransferInProgress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotAContract\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OperatorAlreadyAllowed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OperatorAlreadyApprovedByUser\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OperatorNotAllowed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OperatorNotApprovedByUser\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RenouncementNotInProgress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferAlreadyInProgress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferCallerInvalid\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferNotInProgress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WrongPotentialOwner\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"operators\",\"type\":\"address[]\"}],\"name\":\"ApprovalsGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"operators\",\"type\":\"address[]\"}],\"name\":\"ApprovalsRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"CancelOwnershipTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"InitiateOwnershipRenouncement\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"potentialOwner\",\"type\":\"address\"}],\"name\":\"InitiateOwnershipTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"NewOwner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"OperatorAllowed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"OperatorRemoved\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"allowOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cancelOwnershipTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"confirmOwnershipRenouncement\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"confirmOwnershipTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"operators\",\"type\":\"address[]\"}],\"name\":\"grantApprovals\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"hasUserApprovedOperator\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initiateOwnershipRenouncement\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newPotentialOwner\",\"type\":\"address\"}],\"name\":\"initiateOwnershipTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isOperatorAllowed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ownershipStatus\",\"outputs\":[{\"internalType\":\"enum IOwnableTwoSteps.Status\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"potentialOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"removeOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"operators\",\"type\":\"address[]\"}],\"name\":\"revokeApprovals\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"enum TokenType\",\"name\":\"tokenType\",\"type\":\"uint8\"},{\"internalType\":\"uint256[]\",\"name\":\"itemIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"internalType\":\"struct ITransferManager.BatchTransferItem[]\",\"name\":\"items\",\"type\":\"tuple[]\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"transferBatchItemsAcrossCollections\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"itemId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferItemERC1155\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"itemId\",\"type\":\"uint256\"}],\"name\":\"transferItemERC721\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"itemIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"transferItemsERC1155\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"itemIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"transferItemsERC721\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "TransferManager", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "5000", "ConstructorArguments": "0000000000000000000000009f4c97f45df17e3723cf8f507fd8e03be69c39ac", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}