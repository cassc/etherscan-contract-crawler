{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/SmartYield.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nimport \\\"./lib/math/MathUtils.sol\\\";\\n\\nimport \\\"./IController.sol\\\";\\nimport \\\"./ISmartYield.sol\\\";\\n\\nimport \\\"./IProvider.sol\\\";\\n\\nimport \\\"./model/IBondModel.sol\\\";\\nimport \\\"./IBond.sol\\\";\\nimport \\\"./JuniorToken.sol\\\";\\n\\ncontract SmartYield is\\n    JuniorToken,\\n    ISmartYield\\n{\\n    using SafeMath for uint256;\\n\\n    uint256 public constant MAX_UINT256 = uint256(-1);\\n    uint256 public constant EXP_SCALE = 1e18;\\n\\n    // controller address\\n    address public override controller;\\n\\n    // address of IProviderPool\\n    address public pool;\\n\\n    // senior BOND (NFT)\\n    address public seniorBond; // IBond\\n\\n    // junior BOND (NFT)\\n    address public juniorBond; // IBond\\n\\n    // underlying amount in matured and liquidated juniorBonds\\n    uint256 public underlyingLiquidatedJuniors;\\n\\n    // tokens amount in unmatured juniorBonds or matured and unliquidated\\n    uint256 public tokensInJuniorBonds;\\n\\n    // latest SeniorBond Id\\n    uint256 public seniorBondId;\\n\\n    // latest JuniorBond Id\\n    uint256 public juniorBondId;\\n\\n    // last index of juniorBondsMaturities that was liquidated\\n    uint256 public juniorBondsMaturitiesPrev;\\n    // list of junior bond maturities (timestamps)\\n    uint256[] public juniorBondsMaturities;\\n\\n    // checkpoints for all JuniorBonds matureing at (timestamp) -> (JuniorBondsAt)\\n    // timestamp -> JuniorBondsAt\\n    mapping(uint256 => JuniorBondsAt) public juniorBondsMaturingAt;\\n\\n    // metadata for senior bonds\\n    // bond id => bond (SeniorBond)\\n    mapping(uint256 => SeniorBond) public seniorBonds;\\n\\n    // metadata for junior bonds\\n    // bond id => bond (JuniorBond)\\n    mapping(uint256 => JuniorBond) public juniorBonds;\\n\\n    // pool state / average bond\\n    // holds rate of payment by juniors to seniors\\n    SeniorBond public abond;\\n\\n    bool public _setup;\\n\\n    // emitted when user buys junior ERC20 tokens\\n    event BuyTokens(address indexed buyer, uint256 underlyingIn, uint256 tokensOut, uint256 fee);\\n    // emitted when user sells junior ERC20 tokens and forfeits their share of the debt\\n    event SellTokens(address indexed seller, uint256 tokensIn, uint256 underlyingOut, uint256 forfeits);\\n\\n    event BuySeniorBond(address indexed buyer, uint256 indexed seniorBondId, uint256 underlyingIn, uint256 gain, uint256 forDays);\\n\\n    event RedeemSeniorBond(address indexed owner, uint256 indexed seniorBondId, uint256 fee);\\n\\n    event BuyJuniorBond(address indexed buyer, uint256 indexed juniorBondId, uint256 tokensIn, uint256 maturesAt);\\n\\n    event RedeemJuniorBond(address indexed owner, uint256 indexed juniorBondId, uint256 underlyingOut);\\n\\n    modifier onlyControllerOrDao {\\n      require(\\n        msg.sender == controller || msg.sender == IController(controller).dao(),\\n        \\\"PPC: only controller/DAO\\\"\\n      );\\n      _;\\n    }\\n\\n    constructor(\\n      string memory name_,\\n      string memory symbol_,\\n      uint8 decimals_\\n    )\\n      JuniorToken(name_, symbol_, decimals_)\\n    {}\\n\\n    function setup(\\n      address controller_,\\n      address pool_,\\n      address seniorBond_,\\n      address juniorBond_\\n    )\\n      external\\n    {\\n        require(\\n          false == _setup,\\n          \\\"SY: already setup\\\"\\n        );\\n\\n        controller = controller_;\\n        pool = pool_;\\n        seniorBond = seniorBond_;\\n        juniorBond = juniorBond_;\\n\\n        _setup = true;\\n    }\\n\\n    // externals\\n\\n    // change the controller, only callable by old controller or dao\\n    function setController(address newController_)\\n      external override\\n      onlyControllerOrDao\\n    {\\n      controller = newController_;\\n    }\\n\\n    // buy at least _minTokens with _underlyingAmount, before _deadline passes\\n    function buyTokens(\\n      uint256 underlyingAmount_,\\n      uint256 minTokens_,\\n      uint256 deadline_\\n    )\\n      external override\\n    {\\n        _beforeProviderOp(block.timestamp);\\n\\n        require(\\n          false == IController(controller).PAUSED_BUY_JUNIOR_TOKEN(),\\n          \\\"SY: buyTokens paused\\\"\\n        );\\n\\n        require(\\n          block.timestamp <= deadline_,\\n          \\\"SY: buyTokens deadline\\\"\\n        );\\n\\n        uint256 fee = MathUtils.fractionOf(underlyingAmount_, IController(controller).FEE_BUY_JUNIOR_TOKEN());\\n        // (underlyingAmount_ - fee) * EXP_SCALE / price()\\n        uint256 getsTokens = (underlyingAmount_.sub(fee)).mul(EXP_SCALE).div(price());\\n\\n        require(\\n          getsTokens >= minTokens_,\\n          \\\"SY: buyTokens minTokens\\\"\\n        );\\n\\n        // ---\\n\\n        address buyer = msg.sender;\\n\\n        IProvider(pool)._takeUnderlying(buyer, underlyingAmount_);\\n        IProvider(pool)._depositProvider(underlyingAmount_, fee);\\n        _mint(buyer, getsTokens);\\n\\n        emit BuyTokens(buyer, underlyingAmount_, getsTokens, fee);\\n    }\\n\\n    // sell _tokens for at least _minUnderlying, before _deadline and forfeit potential future gains\\n    function sellTokens(\\n      uint256 tokenAmount_,\\n      uint256 minUnderlying_,\\n      uint256 deadline_\\n    )\\n      external override\\n    {\\n        _beforeProviderOp(block.timestamp);\\n\\n        require(\\n          block.timestamp <= deadline_,\\n          \\\"SY: sellTokens deadline\\\"\\n        );\\n\\n        // share of these tokens in the debt\\n        // tokenAmount_ * EXP_SCALE / totalSupply()\\n        uint256 debtShare = tokenAmount_.mul(EXP_SCALE).div(totalSupply());\\n        // (abondDebt() * debtShare) / EXP_SCALE\\n        uint256 forfeits = abondDebt().mul(debtShare).div(EXP_SCALE);\\n        // debt share is forfeit, and only diff is returned to user\\n        // (tokenAmount_ * price()) / EXP_SCALE - forfeits\\n        uint256 toPay = tokenAmount_.mul(price()).div(EXP_SCALE).sub(forfeits);\\n\\n        require(\\n          toPay >= minUnderlying_,\\n          \\\"SY: sellTokens minUnderlying\\\"\\n        );\\n\\n        // ---\\n\\n        address seller = msg.sender;\\n\\n        _burn(seller, tokenAmount_);\\n        IProvider(pool)._withdrawProvider(toPay, 0);\\n        IProvider(pool)._sendUnderlying(seller, toPay);\\n\\n        emit SellTokens(seller, tokenAmount_, toPay, forfeits);\\n    }\\n\\n    // Purchase a senior bond with principalAmount_ underlying for forDays_, buyer gets a bond with gain >= minGain_ or revert. deadline_ is timestamp before which tx is not rejected.\\n    // returns gain\\n    function buyBond(\\n        uint256 principalAmount_,\\n        uint256 minGain_,\\n        uint256 deadline_,\\n        uint16 forDays_\\n    )\\n      external override\\n      returns (uint256)\\n    {\\n        _beforeProviderOp(block.timestamp);\\n\\n        require(\\n          false == IController(controller).PAUSED_BUY_SENIOR_BOND(),\\n          \\\"SY: buyBond paused\\\"\\n        );\\n\\n        require(\\n          block.timestamp <= deadline_,\\n          \\\"SY: buyBond deadline\\\"\\n        );\\n\\n        require(\\n            0 < forDays_ && forDays_ <= IController(controller).BOND_LIFE_MAX(),\\n            \\\"SY: buyBond forDays\\\"\\n        );\\n\\n        uint256 gain = bondGain(principalAmount_, forDays_);\\n\\n        require(\\n          gain >= minGain_,\\n          \\\"SY: buyBond minGain\\\"\\n        );\\n\\n        require(\\n          gain > 0,\\n          \\\"SY: buyBond gain 0\\\"\\n        );\\n\\n        require(\\n          gain < underlyingLoanable(),\\n          \\\"SY: buyBond underlyingLoanable\\\"\\n        );\\n\\n        uint256 issuedAt = block.timestamp;\\n\\n        // ---\\n\\n        address buyer = msg.sender;\\n\\n        IProvider(pool)._takeUnderlying(buyer, principalAmount_);\\n        IProvider(pool)._depositProvider(principalAmount_, 0);\\n\\n        SeniorBond memory b =\\n            SeniorBond(\\n                principalAmount_,\\n                gain,\\n                issuedAt,\\n                uint256(1 days) * uint256(forDays_) + issuedAt,\\n                false\\n            );\\n\\n        _mintBond(buyer, b);\\n\\n        emit BuySeniorBond(buyer, seniorBondId, principalAmount_, gain, forDays_);\\n\\n        return gain;\\n    }\\n\\n    // buy an nft with tokenAmount_ jTokens, that matures at abond maturesAt\\n    function buyJuniorBond(\\n      uint256 tokenAmount_,\\n      uint256 maxMaturesAt_,\\n      uint256 deadline_\\n    )\\n      external override\\n    {\\n        _beforeProviderOp(block.timestamp);\\n\\n        // 1 + abond.maturesAt / EXP_SCALE\\n        uint256 maturesAt = abond.maturesAt.div(EXP_SCALE).add(1);\\n\\n        require(\\n          block.timestamp <= deadline_,\\n          \\\"SY: buyJuniorBond deadline\\\"\\n        );\\n\\n        require(\\n          maturesAt <= maxMaturesAt_,\\n          \\\"SY: buyJuniorBond maxMaturesAt\\\"\\n        );\\n\\n        JuniorBond memory jb = JuniorBond(\\n          tokenAmount_,\\n          maturesAt\\n        );\\n\\n        // ---\\n\\n        address buyer = msg.sender;\\n\\n        _takeTokens(buyer, tokenAmount_);\\n        _mintJuniorBond(buyer, jb);\\n\\n        emit BuyJuniorBond(buyer, juniorBondId, tokenAmount_, maturesAt);\\n\\n        // if abond.maturesAt is past we can liquidate, but juniorBondsMaturingAt might have already been liquidated\\n        if (block.timestamp >= maturesAt) {\\n            JuniorBondsAt memory jBondsAt = juniorBondsMaturingAt[jb.maturesAt];\\n\\n            if (jBondsAt.price == 0) {\\n                _liquidateJuniorsAt(jb.maturesAt);\\n            } else {\\n                // juniorBondsMaturingAt was previously liquidated,\\n                _burn(address(this), jb.tokens); // burns user's locked tokens reducing the jToken supply\\n                // underlyingLiquidatedJuniors += jb.tokens * jBondsAt.price / EXP_SCALE\\n                underlyingLiquidatedJuniors = underlyingLiquidatedJuniors.add(\\n                  jb.tokens.mul(jBondsAt.price).div(EXP_SCALE)\\n                );\\n                _unaccountJuniorBond(jb);\\n            }\\n            return this.redeemJuniorBond(juniorBondId);\\n        }\\n    }\\n\\n    // Redeem a senior bond by it's id. Anyone can redeem but owner gets principal + gain\\n    function redeemBond(\\n      uint256 bondId_\\n    )\\n      external override\\n    {\\n        _beforeProviderOp(block.timestamp);\\n\\n        require(\\n            block.timestamp >= seniorBonds[bondId_].maturesAt,\\n            \\\"SY: redeemBond not matured\\\"\\n        );\\n\\n        // bondToken.ownerOf will revert for burned tokens\\n        address payTo = IBond(seniorBond).ownerOf(bondId_);\\n        // seniorBonds[bondId_].gain + seniorBonds[bondId_].principal\\n        uint256 payAmnt = seniorBonds[bondId_].gain.add(seniorBonds[bondId_].principal);\\n        uint256 fee = MathUtils.fractionOf(seniorBonds[bondId_].gain, IController(controller).FEE_REDEEM_SENIOR_BOND());\\n        payAmnt = payAmnt.sub(fee);\\n\\n        // ---\\n\\n        if (seniorBonds[bondId_].liquidated == false) {\\n            seniorBonds[bondId_].liquidated = true;\\n            _unaccountBond(seniorBonds[bondId_]);\\n        }\\n\\n        // bondToken.burn will revert for already burned tokens\\n        IBond(seniorBond).burn(bondId_);\\n\\n        IProvider(pool)._withdrawProvider(payAmnt, fee);\\n        IProvider(pool)._sendUnderlying(payTo, payAmnt);\\n\\n        emit RedeemSeniorBond(payTo, bondId_, fee);\\n    }\\n\\n    // once matured, redeem a jBond for underlying\\n    function redeemJuniorBond(uint256 jBondId_)\\n        external override\\n    {\\n        _beforeProviderOp(block.timestamp);\\n\\n        JuniorBond memory jb = juniorBonds[jBondId_];\\n        require(\\n            jb.maturesAt <= block.timestamp,\\n            \\\"SY: redeemJuniorBond maturesAt\\\"\\n        );\\n\\n        JuniorBondsAt memory jBondsAt = juniorBondsMaturingAt[jb.maturesAt];\\n\\n        // blows up if already burned\\n        address payTo = IBond(juniorBond).ownerOf(jBondId_);\\n        // jBondsAt.price * jb.tokens / EXP_SCALE\\n        uint256 payAmnt = jBondsAt.price.mul(jb.tokens).div(EXP_SCALE);\\n\\n        // ---\\n\\n        _burnJuniorBond(jBondId_);\\n        IProvider(pool)._withdrawProvider(payAmnt, 0);\\n        IProvider(pool)._sendUnderlying(payTo, payAmnt);\\n        underlyingLiquidatedJuniors = underlyingLiquidatedJuniors.sub(payAmnt);\\n\\n        emit RedeemJuniorBond(payTo, jBondId_, payAmnt);\\n    }\\n\\n    // returns the maximum theoretically possible daily rate for senior bonds,\\n    // in reality the actual rate given to a bond will always be lower due to slippage\\n    function maxBondDailyRate()\\n      external override\\n    returns (uint256)\\n    {\\n      return IBondModel(IController(controller).bondModel()).maxDailyRate(\\n        underlyingTotal(),\\n        underlyingLoanable(),\\n        IController(controller).providerRatePerDay()\\n      );\\n    }\\n\\n    function liquidateJuniorBonds(uint256 upUntilTimestamp_)\\n      external override\\n    {\\n      require(\\n        upUntilTimestamp_ <= block.timestamp,\\n        \\\"SY: liquidateJuniorBonds in future\\\"\\n      );\\n      _beforeProviderOp(upUntilTimestamp_);\\n    }\\n\\n  // /externals\\n\\n  // publics\\n\\n    // given a principal amount and a number of days, compute the guaranteed bond gain, excluding principal\\n    function bondGain(uint256 principalAmount_, uint16 forDays_)\\n      public override\\n    returns (uint256)\\n    {\\n      return IBondModel(IController(controller).bondModel()).gain(\\n        underlyingTotal(),\\n        underlyingLoanable(),\\n        IController(controller).providerRatePerDay(),\\n        principalAmount_,\\n        forDays_\\n      );\\n    }\\n\\n    // jToken price * EXP_SCALE\\n    function price()\\n      public override\\n    returns (uint256)\\n    {\\n        uint256 ts = totalSupply();\\n        // (ts == 0) ? EXP_SCALE : (underlyingJuniors() * EXP_SCALE) / ts\\n        return (ts == 0) ? EXP_SCALE : underlyingJuniors().mul(EXP_SCALE).div(ts);\\n    }\\n\\n    function underlyingTotal()\\n      public virtual override\\n    returns(uint256)\\n    {\\n      // underlyingBalance() - underlyingLiquidatedJuniors\\n      return IProvider(pool).underlyingBalance().sub(underlyingLiquidatedJuniors);\\n    }\\n\\n    function underlyingJuniors()\\n      public virtual override\\n    returns (uint256)\\n    {\\n      // underlyingTotal() - abond.principal - abondPaid()\\n      return underlyingTotal().sub(abond.principal).sub(abondPaid());\\n    }\\n\\n    function underlyingLoanable()\\n      public virtual override\\n    returns (uint256)\\n    {\\n        // underlyingTotal - abond.principal - abond.gain - queued withdrawls\\n        uint256 _underlyingTotal = underlyingTotal();\\n        // abond.principal - abond.gain - (tokensInJuniorBonds * price() / EXP_SCALE)\\n        uint256 _lockedUnderlying = abond.principal.add(abond.gain).add(\\n          tokensInJuniorBonds.mul(price()).div(EXP_SCALE)\\n        );\\n\\n        if (_lockedUnderlying > _underlyingTotal) {\\n          // abond.gain and (tokensInJuniorBonds in underlying) can overlap, so there is a cases where _lockedUnderlying > _underlyingTotal\\n          return 0;\\n        }\\n\\n        // underlyingTotal() - abond.principal - abond.gain - (tokensInJuniorBonds * price() / EXP_SCALE)\\n        return _underlyingTotal.sub(_lockedUnderlying);\\n    }\\n\\n    function abondGain()\\n      public view override\\n    returns (uint256)\\n    {\\n        return abond.gain;\\n    }\\n\\n    function abondPaid()\\n      public view override\\n    returns (uint256)\\n    {\\n        uint256 ts = block.timestamp * EXP_SCALE;\\n        if (ts <= abond.issuedAt || (abond.maturesAt <= abond.issuedAt)) {\\n          return 0;\\n        }\\n\\n        uint256 duration = abond.maturesAt.sub(abond.issuedAt);\\n        uint256 paidDuration = MathUtils.min(ts.sub(abond.issuedAt), duration);\\n        // abondGain() * paidDuration / duration\\n        return abondGain().mul(paidDuration).div(duration);\\n    }\\n\\n    function abondDebt()\\n      public view override\\n    returns (uint256)\\n    {\\n        // abondGain() - abondPaid()\\n        return abondGain().sub(abondPaid());\\n    }\\n\\n  // /publics\\n\\n  // internals\\n\\n    // liquidates junior bonds up to upUntilTimestamp_ timestamp\\n    function _beforeProviderOp(uint256 upUntilTimestamp_) internal {\\n      // this modifier will be added to the begginging of all (write) functions.\\n      // The first tx after a queued liquidation's timestamp will trigger the liquidation\\n      // reducing the jToken supply, and setting aside owed_dai for withdrawals\\n      for (uint256 i = juniorBondsMaturitiesPrev; i < juniorBondsMaturities.length; i++) {\\n          if (upUntilTimestamp_ >= juniorBondsMaturities[i]) {\\n              _liquidateJuniorsAt(juniorBondsMaturities[i]);\\n              juniorBondsMaturitiesPrev = i.add(1);\\n          } else {\\n              break;\\n          }\\n      }\\n    }\\n\\n    function _liquidateJuniorsAt(uint256 timestamp_)\\n      internal\\n    {\\n        JuniorBondsAt storage jBondsAt = juniorBondsMaturingAt[timestamp_];\\n\\n        require(\\n          jBondsAt.tokens > 0,\\n          \\\"SY: nothing to liquidate\\\"\\n        );\\n\\n        require(\\n          jBondsAt.price == 0,\\n          \\\"SY: already liquidated\\\"\\n        );\\n\\n        jBondsAt.price = price();\\n\\n        // ---\\n\\n        // underlyingLiquidatedJuniors += jBondsAt.tokens * jBondsAt.price / EXP_SCALE;\\n        underlyingLiquidatedJuniors = underlyingLiquidatedJuniors.add(\\n          jBondsAt.tokens.mul(jBondsAt.price).div(EXP_SCALE)\\n        );\\n        _burn(address(this), jBondsAt.tokens); // burns Junior locked tokens reducing the jToken supply\\n        tokensInJuniorBonds = tokensInJuniorBonds.sub(jBondsAt.tokens);\\n    }\\n\\n    // removes matured seniorBonds from being accounted in abond\\n    function unaccountBonds(uint256[] memory bondIds_)\\n      external override\\n    {\\n      uint256 currentTime = block.timestamp;\\n\\n      for (uint256 f = 0; f < bondIds_.length; f++) {\\n        if (\\n            currentTime >= seniorBonds[bondIds_[f]].maturesAt &&\\n            seniorBonds[bondIds_[f]].liquidated == false\\n        ) {\\n            seniorBonds[bondIds_[f]].liquidated = true;\\n            _unaccountBond(seniorBonds[bondIds_[f]]);\\n        }\\n      }\\n    }\\n\\n    function _mintBond(address to_, SeniorBond memory bond_)\\n      internal\\n    {\\n        require(\\n          seniorBondId < MAX_UINT256,\\n          \\\"SY: _mintBond\\\"\\n        );\\n\\n        seniorBondId++;\\n        seniorBonds[seniorBondId] = bond_;\\n        _accountBond(bond_);\\n        IBond(seniorBond).mint(to_, seniorBondId);\\n    }\\n\\n    // when a new bond is added to the pool, we want:\\n    // - to average abond.maturesAt (the earliest date at which juniors can fully exit), this shortens the junior exit date compared to the date of the last active bond\\n    // - to keep the price for jTokens before a bond is bought ~equal with the price for jTokens after a bond is bought\\n    function _accountBond(SeniorBond memory b_)\\n      internal\\n    {\\n        uint256 _now = block.timestamp * EXP_SCALE;\\n\\n        //abondDebt() + b_.gain\\n        uint256 newDebt = abondDebt().add(b_.gain);\\n        // for the very first bond or the first bond after abond maturity: abondDebt() = 0 => newMaturesAt = b.maturesAt\\n        // (abond.maturesAt * abondDebt() + b_.maturesAt * EXP_SCALE * b_.gain) / newDebt\\n        uint256 newMaturesAt = (abond.maturesAt.mul(abondDebt()).add(b_.maturesAt.mul(EXP_SCALE).mul(b_.gain))).div(newDebt);\\n\\n        // (uint256(1) + ((abond.gain + b_.gain) * (newMaturesAt - _now)) / newDebt)\\n        uint256 newDuration = (abond.gain.add(b_.gain)).mul(newMaturesAt.sub(_now)).div(newDebt).add(1);\\n        // timestamp = timestamp - tokens * d / tokens\\n        uint256 newIssuedAt = newMaturesAt.sub(newDuration, \\\"SY: liquidate some seniorBonds\\\");\\n\\n        abond = SeniorBond(\\n          abond.principal.add(b_.principal),\\n          abond.gain.add(b_.gain),\\n          newIssuedAt,\\n          newMaturesAt,\\n          false\\n        );\\n    }\\n\\n    // when a bond is redeemed from the pool, we want:\\n    // - for abond.maturesAt (the earliest date at which juniors can fully exit) to remain the same as before the redeem\\n    // - to keep the price for jTokens before a bond is bought ~equal with the price for jTokens after a bond is bought\\n    function _unaccountBond(SeniorBond memory b_)\\n      internal\\n    {\\n        uint256 now_ = block.timestamp * EXP_SCALE;\\n\\n        if ((now_ >= abond.maturesAt)) {\\n          // abond matured\\n          // abondDebt() == 0\\n          abond = SeniorBond(\\n            abond.principal.sub(b_.principal),\\n            abond.gain - b_.gain,\\n            now_.sub(abond.maturesAt.sub(abond.issuedAt)),\\n            now_,\\n            false\\n          );\\n\\n          return;\\n        }\\n        // uint256(1) + (abond.gain - b_.gain) * (abond.maturesAt - now_) / abondDebt()\\n        uint256 newDuration = (abond.gain.sub(b_.gain)).mul(abond.maturesAt.sub(now_)).div(abondDebt()).add(1);\\n        // timestamp = timestamp - tokens * d / tokens\\n        uint256 newIssuedAt = abond.maturesAt.sub(newDuration, \\\"SY: liquidate some seniorBonds\\\");\\n\\n        abond = SeniorBond(\\n          abond.principal.sub(b_.principal),\\n          abond.gain.sub(b_.gain),\\n          newIssuedAt,\\n          abond.maturesAt,\\n          false\\n        );\\n    }\\n\\n    function _mintJuniorBond(address to_, JuniorBond memory jb_)\\n      internal\\n    {\\n        require(\\n          juniorBondId < MAX_UINT256,\\n          \\\"SY: _mintJuniorBond\\\"\\n        );\\n\\n        juniorBondId++;\\n        juniorBonds[juniorBondId] = jb_;\\n\\n        _accountJuniorBond(jb_);\\n        IBond(juniorBond).mint(to_, juniorBondId);\\n    }\\n\\n    function _accountJuniorBond(JuniorBond memory jb_)\\n      internal\\n    {\\n        // tokensInJuniorBonds += jb_.tokens\\n        tokensInJuniorBonds = tokensInJuniorBonds.add(jb_.tokens);\\n\\n        JuniorBondsAt storage jBondsAt = juniorBondsMaturingAt[jb_.maturesAt];\\n        uint256 tmp;\\n\\n        if (jBondsAt.tokens == 0 && block.timestamp < jb_.maturesAt) {\\n          juniorBondsMaturities.push(jb_.maturesAt);\\n          for (uint256 i = juniorBondsMaturities.length - 1; i >= MathUtils.max(1, juniorBondsMaturitiesPrev); i--) {\\n            if (juniorBondsMaturities[i] > juniorBondsMaturities[i - 1]) {\\n              break;\\n            }\\n            tmp = juniorBondsMaturities[i - 1];\\n            juniorBondsMaturities[i - 1] = juniorBondsMaturities[i];\\n            juniorBondsMaturities[i] = tmp;\\n          }\\n        }\\n\\n        // jBondsAt.tokens += jb_.tokens\\n        jBondsAt.tokens = jBondsAt.tokens.add(jb_.tokens);\\n    }\\n\\n    function _burnJuniorBond(uint256 bondId_) internal {\\n        // blows up if already burned\\n        IBond(juniorBond).burn(bondId_);\\n    }\\n\\n    function _unaccountJuniorBond(JuniorBond memory jb_) internal {\\n        // tokensInJuniorBonds -= jb_.tokens;\\n        tokensInJuniorBonds = tokensInJuniorBonds.sub(jb_.tokens);\\n        JuniorBondsAt storage jBondsAt = juniorBondsMaturingAt[jb_.maturesAt];\\n        // jBondsAt.tokens -= jb_.tokens;\\n        jBondsAt.tokens = jBondsAt.tokens.sub(jb_.tokens);\\n    }\\n\\n    function _takeTokens(address from_, uint256 amount_) internal {\\n        _transfer(from_, address(this), amount_);\\n    }\\n\\n  // /internals\\n\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/lib/math/MathUtils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.7.6;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\nlibrary MathUtils {\\n\\n    using SafeMath for uint256;\\n\\n    uint256 public constant EXP_SCALE = 1e18;\\n\\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        z = x < y ? x : y;\\n    }\\n\\n    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        z = x > y ? x : y;\\n    }\\n\\n    function compound(\\n        // in wei\\n        uint256 principal,\\n        // rate is * EXP_SCALE\\n        uint256 ratePerPeriod,\\n        uint16 periods\\n    ) internal pure returns (uint256) {\\n      if (0 == ratePerPeriod) {\\n        return principal;\\n      }\\n\\n      while (periods > 0) {\\n          // principal += principal * ratePerPeriod / EXP_SCALE;\\n          principal = principal.add(principal.mul(ratePerPeriod).div(EXP_SCALE));\\n          periods -= 1;\\n      }\\n\\n      return principal;\\n    }\\n\\n    function compound2(\\n      uint256 principal,\\n      uint256 ratePerPeriod,\\n      uint16 periods\\n    ) internal pure returns (uint256) {\\n      if (0 == ratePerPeriod) {\\n        return principal;\\n      }\\n\\n      while (periods > 0) {\\n        if (periods % 2 == 1) {\\n          //principal += principal * ratePerPeriod / EXP_SCALE;\\n          principal = principal.add(principal.mul(ratePerPeriod).div(EXP_SCALE));\\n          periods -= 1;\\n        } else {\\n          //ratePerPeriod = ((2 * ratePerPeriod * EXP_SCALE) + (ratePerPeriod * ratePerPeriod)) / EXP_SCALE;\\n          ratePerPeriod = ((uint256(2).mul(ratePerPeriod).mul(EXP_SCALE)).add(ratePerPeriod.mul(ratePerPeriod))).div(EXP_SCALE);\\n          periods /= 2;\\n        }\\n      }\\n\\n      return principal;\\n    }\\n\\n    function linearGain(\\n      uint256 principal,\\n      uint256 ratePerPeriod,\\n      uint16 periods\\n    ) internal pure returns (uint256) {\\n      return principal.add(\\n        fractionOf(principal, ratePerPeriod.mul(periods))\\n      );\\n    }\\n\\n    // computes a * f / EXP_SCALE\\n    function fractionOf(uint256 a, uint256 f) internal pure returns (uint256) {\\n      return a.mul(f).div(EXP_SCALE);\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/IController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"./Governed.sol\\\";\\nimport \\\"./IProvider.sol\\\";\\nimport \\\"./ISmartYield.sol\\\";\\n\\nabstract contract IController is Governed {\\n\\n    uint256 public constant EXP_SCALE = 1e18;\\n\\n    address public pool; // compound provider pool\\n\\n    address public smartYield; // smartYield\\n\\n    address public oracle; // IYieldOracle\\n\\n    address public bondModel; // IBondModel\\n\\n    address public feesOwner; // fees are sent here\\n\\n    // max accepted cost of harvest when converting COMP -> underlying,\\n    // if harvest gets less than (COMP to underlying at spot price) - HARVEST_COST%, it will revert.\\n    // if it gets more, the difference goes to the harvest caller\\n    uint256 public HARVEST_COST = 40 * 1e15; // 4%\\n\\n    // fee for buying jTokens\\n    uint256 public FEE_BUY_JUNIOR_TOKEN = 3 * 1e15; // 0.3%\\n\\n    // fee for redeeming a sBond\\n    uint256 public FEE_REDEEM_SENIOR_BOND = 100 * 1e15; // 10%\\n\\n    // max rate per day for sBonds\\n    uint256 public BOND_MAX_RATE_PER_DAY = 719065000000000; // APY 30% / year\\n\\n    // max duration of a purchased sBond\\n    uint16 public BOND_LIFE_MAX = 90; // in days\\n\\n    bool public PAUSED_BUY_JUNIOR_TOKEN = false;\\n\\n    bool public PAUSED_BUY_SENIOR_BOND = false;\\n\\n    function setHarvestCost(uint256 newValue_)\\n      public\\n      onlyDao\\n    {\\n        require(\\n          HARVEST_COST < EXP_SCALE,\\n          \\\"IController: HARVEST_COST too large\\\"\\n        );\\n        HARVEST_COST = newValue_;\\n    }\\n\\n    function setBondMaxRatePerDay(uint256 newVal_)\\n      public\\n      onlyDao\\n    {\\n      BOND_MAX_RATE_PER_DAY = newVal_;\\n    }\\n\\n    function setBondLifeMax(uint16 newVal_)\\n      public\\n      onlyDao\\n    {\\n      BOND_LIFE_MAX = newVal_;\\n    }\\n\\n    function setFeeBuyJuniorToken(uint256 newVal_)\\n      public\\n      onlyDao\\n    {\\n      FEE_BUY_JUNIOR_TOKEN = newVal_;\\n    }\\n\\n    function setFeeRedeemSeniorBond(uint256 newVal_)\\n      public\\n      onlyDao\\n    {\\n      FEE_REDEEM_SENIOR_BOND = newVal_;\\n    }\\n\\n    function setPaused(bool buyJToken_, bool buySBond_)\\n      public\\n      onlyDaoOrGuardian\\n    {\\n      PAUSED_BUY_JUNIOR_TOKEN = buyJToken_;\\n      PAUSED_BUY_SENIOR_BOND = buySBond_;\\n    }\\n\\n    function setOracle(address newVal_)\\n      public\\n      onlyDao\\n    {\\n      oracle = newVal_;\\n    }\\n\\n    function setBondModel(address newVal_)\\n      public\\n      onlyDao\\n    {\\n      bondModel = newVal_;\\n    }\\n\\n    function setFeesOwner(address newVal_)\\n      public\\n      onlyDao\\n    {\\n      feesOwner = newVal_;\\n    }\\n\\n    function yieldControllTo(address newController_)\\n      public\\n      onlyDao\\n    {\\n      IProvider(pool).setController(newController_);\\n      ISmartYield(smartYield).setController(newController_);\\n    }\\n\\n    function providerRatePerDay() external virtual returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/ISmartYield.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.7.6;\\npragma abicoder v2;\\n\\ninterface ISmartYield {\\n\\n    // a senior BOND (metadata for NFT)\\n    struct SeniorBond {\\n        // amount seniors put in\\n        uint256 principal;\\n        // amount yielded at the end. total = principal + gain\\n        uint256 gain;\\n        // bond was issued at timestamp\\n        uint256 issuedAt;\\n        // bond matures at timestamp\\n        uint256 maturesAt;\\n        // was it liquidated yet\\n        bool liquidated;\\n    }\\n\\n    // a junior BOND (metadata for NFT)\\n    struct JuniorBond {\\n        // amount of tokens (jTokens) junior put in\\n        uint256 tokens;\\n        // bond matures at timestamp\\n        uint256 maturesAt;\\n    }\\n\\n    // a checkpoint for all JuniorBonds with same maturity date JuniorBond.maturesAt\\n    struct JuniorBondsAt {\\n        // sum of JuniorBond.tokens for JuniorBonds with the same JuniorBond.maturesAt\\n        uint256 tokens;\\n        // price at which JuniorBonds will be paid. Initially 0 -> unliquidated (price is in the future or not yet liquidated)\\n        uint256 price;\\n    }\\n\\n    function controller() external view returns (address);\\n\\n    function buyBond(uint256 principalAmount_, uint256 minGain_, uint256 deadline_, uint16 forDays_) external returns (uint256);\\n\\n    function redeemBond(uint256 bondId_) external;\\n\\n    function unaccountBonds(uint256[] memory bondIds_) external;\\n\\n    function buyTokens(uint256 underlyingAmount_, uint256 minTokens_, uint256 deadline_) external;\\n\\n    /**\\n     * sell all tokens instantly\\n     */\\n    function sellTokens(uint256 tokens_, uint256 minUnderlying_, uint256 deadline_) external;\\n\\n    function buyJuniorBond(uint256 tokenAmount_, uint256 maxMaturesAt_, uint256 deadline_) external;\\n\\n    function redeemJuniorBond(uint256 jBondId_) external;\\n\\n    function liquidateJuniorBonds(uint256 upUntilTimestamp_) external;\\n\\n    /**\\n     * token purchase price\\n     */\\n    function price() external returns (uint256);\\n\\n    function abondPaid() external view returns (uint256);\\n\\n    function abondDebt() external view returns (uint256);\\n\\n    function abondGain() external view returns (uint256);\\n\\n    /**\\n     * @notice current total underlying balance, without accruing interest\\n     */\\n    function underlyingTotal() external returns (uint256);\\n\\n    /**\\n     * @notice current underlying loanable, without accruing interest\\n     */\\n    function underlyingLoanable() external returns (uint256);\\n\\n    function underlyingJuniors() external returns (uint256);\\n\\n    function bondGain(uint256 principalAmount_, uint16 forDays_) external returns (uint256);\\n\\n    function maxBondDailyRate() external returns (uint256);\\n\\n    function setController(address newController_) external;\\n}\\n\"\r\n    },\r\n    \"contracts/IProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.7.6;\\npragma abicoder v2;\\n\\ninterface IProvider {\\n\\n    function smartYield() external view returns (address);\\n\\n    function controller() external view returns (address);\\n\\n    function underlyingFees() external view returns (uint256);\\n\\n    // deposit underlyingAmount_ into provider, add takeFees_ to fees\\n    function _depositProvider(uint256 underlyingAmount_, uint256 takeFees_) external;\\n\\n    // withdraw underlyingAmount_ from provider, add takeFees_ to fees\\n    function _withdrawProvider(uint256 underlyingAmount_, uint256 takeFees_) external;\\n\\n    function _takeUnderlying(address from_, uint256 amount_) external;\\n\\n    function _sendUnderlying(address to_, uint256 amount_) external;\\n\\n    function transferFees() external;\\n\\n    // current total underlying balance as measured by the provider pool, without fees\\n    function underlyingBalance() external returns (uint256);\\n\\n    function setController(address newController_) external;\\n}\\n\"\r\n    },\r\n    \"contracts/model/IBondModel.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.7.6;\\npragma abicoder v2;\\n\\ninterface IBondModel {\\n\\n    function gain(uint256 total_, uint256 loanable_, uint256 dailyRate_, uint256 principal_, uint16 forDays_) external pure returns (uint256);\\n\\n    function maxDailyRate(uint256 total_, uint256 loanable_, uint256 dailyRate_) external pure returns (uint256);\\n\\n}\\n\"\r\n    },\r\n    \"contracts/IBond.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\n\\ninterface IBond is IERC721 {\\n    function smartYield() external view returns (address);\\n\\n    function mint(address to, uint256 tokenId) external;\\n\\n    function burn(uint256 tokenId) external;\\n}\\n\"\r\n    },\r\n    \"contracts/JuniorToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\n\\nabstract contract JuniorToken is ERC20 {\\n\\n    constructor(\\n      string memory name_,\\n      string memory symbol_,\\n      uint8 decimals_\\n    )\\n      ERC20(name_, symbol_)\\n    {\\n      _setupDecimals(decimals_);\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/Governed.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.7.6;\\npragma abicoder v2;\\n\\nabstract contract Governed {\\n\\n  address public dao;\\n  address public guardian;\\n\\n  modifier onlyDao {\\n    require(\\n        dao == msg.sender,\\n        \\\"GOV: not dao\\\"\\n      );\\n    _;\\n  }\\n\\n  modifier onlyDaoOrGuardian {\\n    require(\\n      msg.sender == dao || msg.sender == guardian,\\n      \\\"GOV: not dao/guardian\\\"\\n    );\\n    _;\\n  }\\n\\n  constructor()\\n  {\\n    dao = msg.sender;\\n    guardian = msg.sender;\\n  }\\n\\n  function setDao(address dao_)\\n    external\\n    onlyDao\\n  {\\n    dao = dao_;\\n  }\\n\\n  function setGuardian(address guardian_)\\n    external\\n    onlyDao\\n  {\\n    guardian = guardian_;\\n  }\\n\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2 <0.8.0;\\n\\nimport \\\"../../introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n      * @dev Safely transfers `tokenId` token from `from` to `to`.\\n      *\\n      * Requirements:\\n      *\\n      * - `from` cannot be the zero address.\\n      * - `to` cannot be the zero address.\\n      * - `tokenId` token must exist and be owned by `from`.\\n      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n      *\\n      * Emits a {Transfer} event.\\n      */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../../utils/Context.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\n * of returning `false` on failure. This behavior is nonetheless conventional\\n * and does not conflict with the expectations of ERC20 applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20 {\\n    using SafeMath for uint256;\\n\\n    mapping (address => uint256) private _balances;\\n\\n    mapping (address => mapping (address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n    uint8 private _decimals;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\\n     * a default value of 18.\\n     *\\n     * To select a different value for {decimals}, use {_setupDecimals}.\\n     *\\n     * All three of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor (string memory name_, string memory symbol_) public {\\n        _name = name_;\\n        _symbol = symbol_;\\n        _decimals = 18;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\\n     * called.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``sender``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \\\"ERC20: decreased allowance below zero\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\n     *\\n     * This is internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n\\n        _balances[sender] = _balances[sender].sub(amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        _balances[recipient] = _balances[recipient].add(amount);\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply = _totalSupply.add(amount);\\n        _balances[account] = _balances[account].add(amount);\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        _balances[account] = _balances[account].sub(amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        _totalSupply = _totalSupply.sub(amount);\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Sets {decimals} to a value other than the default one of 18.\\n     *\\n     * WARNING: This function should only be called from the constructor. Most\\n     * applications that interact with token contracts will not expect\\n     * {decimals} to ever change, and may work incorrectly if it does.\\n     */\\n    function _setupDecimals(uint8 decimals_) internal virtual {\\n        _decimals = decimals_;\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be to transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 9999\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name_\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol_\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"decimals_\",\"type\":\"uint8\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"juniorBondId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maturesAt\",\"type\":\"uint256\"}],\"name\":\"BuyJuniorBond\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"seniorBondId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"underlyingIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gain\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"forDays\",\"type\":\"uint256\"}],\"name\":\"BuySeniorBond\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"underlyingIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensOut\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"BuyTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"juniorBondId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"underlyingOut\",\"type\":\"uint256\"}],\"name\":\"RedeemJuniorBond\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"seniorBondId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"RedeemSeniorBond\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"underlyingOut\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"forfeits\",\"type\":\"uint256\"}],\"name\":\"SellTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"EXP_SCALE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_UINT256\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_setup\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"abond\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"principal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gain\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"issuedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maturesAt\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"liquidated\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"abondDebt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"abondGain\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"abondPaid\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"principalAmount_\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"forDays_\",\"type\":\"uint16\"}],\"name\":\"bondGain\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"principalAmount_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minGain_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline_\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"forDays_\",\"type\":\"uint16\"}],\"name\":\"buyBond\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmount_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxMaturesAt_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline_\",\"type\":\"uint256\"}],\"name\":\"buyJuniorBond\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"underlyingAmount_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minTokens_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline_\",\"type\":\"uint256\"}],\"name\":\"buyTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"controller\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"juniorBond\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"juniorBondId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"juniorBonds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maturesAt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"juniorBondsMaturingAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"juniorBondsMaturities\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"juniorBondsMaturitiesPrev\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"upUntilTimestamp_\",\"type\":\"uint256\"}],\"name\":\"liquidateJuniorBonds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxBondDailyRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"price\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"bondId_\",\"type\":\"uint256\"}],\"name\":\"redeemBond\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"jBondId_\",\"type\":\"uint256\"}],\"name\":\"redeemJuniorBond\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmount_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minUnderlying_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline_\",\"type\":\"uint256\"}],\"name\":\"sellTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"seniorBond\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"seniorBondId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"seniorBonds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"principal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gain\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"issuedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maturesAt\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"liquidated\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newController_\",\"type\":\"address\"}],\"name\":\"setController\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"controller_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"pool_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"seniorBond_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"juniorBond_\",\"type\":\"address\"}],\"name\":\"setup\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokensInJuniorBonds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"bondIds_\",\"type\":\"uint256[]\"}],\"name\":\"unaccountBonds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"underlyingJuniors\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"underlyingLiquidatedJuniors\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"underlyingLoanable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"underlyingTotal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "SmartYield", "CompilerVersion": "v0.7.6+commit.7338295f", "OptimizationUsed": "1", "Runs": "9999", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000000000001200000000000000000000000000000000000000000000000000000000000000164261726e427269646765206a756e696f72206144414900000000000000000000000000000000000000000000000000000000000000000000000000000000000762625f6144414900000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}