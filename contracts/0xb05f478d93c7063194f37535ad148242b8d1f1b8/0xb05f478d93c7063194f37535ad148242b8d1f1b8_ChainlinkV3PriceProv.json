{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/priceProviders/chainlinkV3/ChainlinkV3PriceProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\nimport \\\"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\\\";\\n\\nimport \\\"../PriceProvider.sol\\\";\\nimport \\\"../IERC20LikeV2.sol\\\";\\n\\ncontract ChainlinkV3PriceProvider is PriceProvider {\\n    using SafeMath for uint256;\\n\\n    struct AssetData {\\n        // Time threshold to invalidate stale prices\\n        uint256 heartbeat;\\n        // If true, we bypass the aggregator and consult the fallback provider directly\\n        bool forceFallback;\\n        // If true, the aggregator returns price in USD, so we need to convert to QUOTE\\n        bool convertToQuote;\\n        // Chainlink aggregator proxy\\n        AggregatorV3Interface aggregator;\\n        // Provider used if the aggregator's price is invalid or if it became disabled\\n        IPriceProvider fallbackProvider;\\n    }\\n\\n    /// @dev Aggregator that converts from USD to quote token\\n    AggregatorV3Interface internal immutable _QUOTE_AGGREGATOR; // solhint-disable-line var-name-mixedcase\\n\\n    /// @dev Decimals used by the _QUOTE_AGGREGATOR\\n    uint8 internal immutable _QUOTE_AGGREGATOR_DECIMALS; // solhint-disable-line var-name-mixedcase\\n\\n    /// @dev Used to optimize calculations in emergency disable function\\n    // solhint-disable-next-line var-name-mixedcase\\n    uint256 internal immutable _MAX_PRICE_DIFF = type(uint256).max / (100 * EMERGENCY_PRECISION);\\n    \\n    // @dev Precision to use for the EMERGENCY_THRESHOLD\\n    uint256 public constant EMERGENCY_PRECISION = 1e6;\\n\\n    /// @dev Disable the aggregator if the difference with the fallback is higher than this percentage (10%)\\n    uint256 public constant EMERGENCY_THRESHOLD = 10 * EMERGENCY_PRECISION; // solhint-disable-line var-name-mixedcase\\n\\n    /// @dev this is basically `PriceProvider.quoteToken.decimals()`\\n    uint8 internal immutable _QUOTE_TOKEN_DECIMALS; // solhint-disable-line var-name-mixedcase\\n\\n    /// @dev Address allowed to call the emergencyDisable function, can be set by the owner\\n    address public emergencyManager;\\n\\n    /// @dev Threshold used to determine if the price returned by the _QUOTE_AGGREGATOR is valid\\n    uint256 public quoteAggregatorHeartbeat;\\n\\n    /// @dev Data used for each asset\\n    mapping(address => AssetData) public assetData;\\n\\n    event NewAggregator(address indexed asset, AggregatorV3Interface indexed aggregator, bool convertToQuote);\\n    event NewFallbackPriceProvider(address indexed asset, IPriceProvider indexed fallbackProvider);\\n    event NewHeartbeat(address indexed asset, uint256 heartbeat);\\n    event NewQuoteAggregatorHeartbeat(uint256 heartbeat);\\n    event NewEmergencyManager(address indexed emergencyManager);\\n    event AggregatorDisabled(address indexed asset, AggregatorV3Interface indexed aggregator);\\n\\n    error AggregatorDidNotChange();\\n    error AggregatorPriceNotAvailable();\\n    error AssetNotSupported();\\n    error EmergencyManagerDidNotChange();\\n    error EmergencyThresholdNotReached();\\n    error FallbackProviderAlreadySet();\\n    error FallbackProviderDidNotChange();\\n    error FallbackProviderNotSet();\\n    error HeartbeatDidNotChange();\\n    error InvalidAggregator();\\n    error InvalidAggregatorDecimals();\\n    error InvalidFallbackPriceProvider();\\n    error InvalidHeartbeat();\\n    error OnlyEmergencyManager();\\n    error QuoteAggregatorHeartbeatDidNotChange();\\n\\n    modifier onlyAssetSupported(address _asset) {\\n        if (!assetSupported(_asset)) {\\n            revert AssetNotSupported();\\n        }\\n\\n        _;\\n    }\\n\\n    constructor(\\n        IPriceProvidersRepository _priceProvidersRepository,\\n        address _emergencyManager,\\n        AggregatorV3Interface _quoteAggregator,\\n        uint256 _quoteAggregatorHeartbeat\\n    ) PriceProvider(_priceProvidersRepository) {\\n        _setEmergencyManager(_emergencyManager);\\n        _QUOTE_TOKEN_DECIMALS = IERC20LikeV2(quoteToken).decimals();\\n        _QUOTE_AGGREGATOR = _quoteAggregator;\\n        _QUOTE_AGGREGATOR_DECIMALS = _quoteAggregator.decimals();\\n        quoteAggregatorHeartbeat = _quoteAggregatorHeartbeat;\\n    }\\n\\n    /// @inheritdoc IPriceProvider\\n    function assetSupported(address _asset) public view virtual override returns (bool) {\\n        AssetData storage data = assetData[_asset];\\n\\n        // Asset is supported if:\\n        //     - the asset is the quote token\\n        //       OR\\n        //     - the aggregator address is defined AND\\n        //         - the aggregator is not disabled\\n        //           OR\\n        //         - the fallback is defined\\n\\n        if (_asset == quoteToken) {\\n            return true;\\n        }\\n\\n        if (address(data.aggregator) != address(0)) {\\n            return !data.forceFallback || address(data.fallbackProvider) != address(0);\\n        }\\n\\n        return false;\\n    }\\n\\n    /// @dev Returns price directly from aggregator using all internal settings except of fallback provider\\n    /// @param _asset Asset for which we want to get the price\\n    function getAggregatorPrice(address _asset) public view virtual returns (bool success, uint256 price) {\\n        (success, price) = _getAggregatorPrice(_asset);\\n    }\\n    \\n    /// @inheritdoc IPriceProvider\\n    function getPrice(address _asset) public view virtual override returns (uint256) {\\n        address quote = quoteToken;\\n\\n        if (_asset == quote) {\\n            return 10 ** _QUOTE_TOKEN_DECIMALS;\\n        }\\n\\n        (bool success, uint256 price) = _getAggregatorPrice(_asset);\\n\\n        return success ? price : _getFallbackPrice(_asset);\\n    }\\n\\n    /// @dev Sets the aggregator, fallbackProvider and heartbeat for an asset. Can only be called by the manager.\\n    /// @param _asset Asset to setup\\n    /// @param _aggregator Chainlink aggregator proxy\\n    /// @param _fallbackProvider Provider to use if the price is invalid or if the aggregator was disabled\\n    /// @param _heartbeat Threshold in seconds to invalidate a stale price\\n    function setupAsset(\\n        address _asset,\\n        AggregatorV3Interface _aggregator,\\n        IPriceProvider _fallbackProvider,\\n        uint256 _heartbeat,\\n        bool _convertToQuote\\n    ) external virtual onlyManager {\\n        // This has to be done first so that `_setAggregator` works\\n        _setHeartbeat(_asset, _heartbeat);\\n\\n        if (!_setAggregator(_asset, _aggregator, _convertToQuote)) revert AggregatorDidNotChange();\\n\\n        // We don't care if this doesn't change\\n        _setFallbackPriceProvider(_asset, _fallbackProvider);\\n    }\\n\\n    /// @dev Sets the aggregator for an asset. Can only be called by the manager.\\n    /// @param _asset Asset for which to set the aggregator\\n    /// @param _aggregator Aggregator to set\\n    function setAggregator(address _asset, AggregatorV3Interface _aggregator, bool _convertToQuote)\\n        external\\n        virtual\\n        onlyManager\\n        onlyAssetSupported(_asset)\\n    {\\n        if (!_setAggregator(_asset, _aggregator, _convertToQuote)) revert AggregatorDidNotChange();\\n    }\\n\\n    /// @dev Sets the fallback provider for an asset. Can only be called by the manager.\\n    /// @param _asset Asset for which to set the fallback provider\\n    /// @param _fallbackProvider Provider to set\\n    function setFallbackPriceProvider(address _asset, IPriceProvider _fallbackProvider)\\n        external\\n        virtual\\n        onlyManager\\n        onlyAssetSupported(_asset)\\n    {\\n        if (!_setFallbackPriceProvider(_asset, _fallbackProvider)) {\\n            revert FallbackProviderDidNotChange();\\n        }\\n    }\\n\\n    /// @dev Sets the heartbeat threshold for an asset. Can only be called by the manager.\\n    /// @param _asset Asset for which to set the heartbeat threshold\\n    /// @param _heartbeat Threshold to set\\n    function setHeartbeat(address _asset, uint256 _heartbeat)\\n        external\\n        virtual\\n        onlyManager\\n        onlyAssetSupported(_asset)\\n    {\\n        if (!_setHeartbeat(_asset, _heartbeat)) revert HeartbeatDidNotChange();\\n    }\\n\\n    /// @dev Sets the quote aggregator heartbeat threshold. Can only be called by the manager.\\n    /// @param _heartbeat Threshold to set\\n    function setQuoteAggregatorHeartbeat(uint256 _heartbeat)\\n        external\\n        virtual\\n        onlyManager\\n    {\\n        if (!_setQuoteAggregatorHeartbeat(_heartbeat)) revert QuoteAggregatorHeartbeatDidNotChange();\\n    }\\n\\n    /// @dev Sets the emergencyManager. Can only be called by the manager.\\n    /// @param _emergencyManager Emergency manager to set\\n    function setEmergencyManager(address _emergencyManager) external virtual onlyManager {\\n        if (!_setEmergencyManager(_emergencyManager)) revert EmergencyManagerDidNotChange();\\n    }\\n\\n    /// @dev Disables the aggregator for an asset if there is a big discrepancy between the aggregator and the\\n    /// fallback provider. The only way to reenable the asset is by calling setupAsset or setAggregator again.\\n    /// Can only be called by the emergencyManager.\\n    /// @param _asset Asset for which to disable the aggregator\\n    function emergencyDisable(address _asset) external virtual {\\n        if (msg.sender != emergencyManager) {\\n            revert OnlyEmergencyManager();\\n        }\\n\\n        (bool success, uint256 price) = _getAggregatorPrice(_asset);\\n\\n        if (!success) {\\n            revert AggregatorPriceNotAvailable();\\n        }\\n\\n        uint256 fallbackPrice = _getFallbackPrice(_asset);\\n\\n        uint256 diff;\\n\\n        unchecked {\\n            // It is ok to uncheck because of the initial fallbackPrice >= price check\\n            diff = fallbackPrice >= price ? fallbackPrice - price : price - fallbackPrice;\\n        }\\n\\n        if (diff > _MAX_PRICE_DIFF || (diff * 100 * EMERGENCY_PRECISION) / price < EMERGENCY_THRESHOLD) {\\n            revert EmergencyThresholdNotReached();\\n        }\\n\\n        // Disable main aggregator, fallback stays enabled\\n        assetData[_asset].forceFallback = true;\\n\\n        emit AggregatorDisabled(_asset, assetData[_asset].aggregator);\\n    }\\n\\n    function getFallbackProvider(address _asset) external view virtual returns (IPriceProvider) {\\n        return assetData[_asset].fallbackProvider;\\n    }\\n\\n    function _getAggregatorPrice(address _asset) internal view virtual returns (bool success, uint256 price) {\\n        AssetData storage data = assetData[_asset];\\n\\n        uint256 heartbeat = data.heartbeat;\\n        bool forceFallback = data.forceFallback;\\n        AggregatorV3Interface aggregator = data.aggregator;\\n\\n        if (address(aggregator) == address(0)) revert AssetNotSupported();\\n\\n        (\\n            /*uint80 roundID*/,\\n            int256 aggregatorPrice,\\n            /*uint256 startedAt*/,\\n            uint256 timestamp,\\n            /*uint80 answeredInRound*/\\n        ) = aggregator.latestRoundData();\\n\\n        // If a valid price is returned and it was updated recently\\n        if (!forceFallback && _isValidPrice(aggregatorPrice, timestamp, heartbeat)) {\\n            uint256 result;\\n\\n            if (data.convertToQuote) {\\n                // _toQuote performs decimal normalization internally\\n                result = _toQuote(uint256(aggregatorPrice));\\n            } else {\\n                uint8 aggregatorDecimals = aggregator.decimals();\\n                result = _normalizeWithDecimals(uint256(aggregatorPrice), aggregatorDecimals);\\n            }\\n\\n            return (true, result);\\n        }\\n\\n        return (false, 0);\\n    }\\n\\n    function _getFallbackPrice(address _asset) internal view virtual returns (uint256) {\\n        IPriceProvider fallbackProvider = assetData[_asset].fallbackProvider;\\n\\n        if (address(fallbackProvider) == address(0)) revert FallbackProviderNotSet();\\n\\n        return fallbackProvider.getPrice(_asset);\\n    }\\n\\n    function _setEmergencyManager(address _emergencyManager) internal virtual returns (bool changed) {\\n        if (_emergencyManager == emergencyManager) {\\n            return false;\\n        }\\n\\n        emergencyManager = _emergencyManager;\\n\\n        emit NewEmergencyManager(_emergencyManager);\\n\\n        return true;\\n    }\\n\\n    function _setAggregator(\\n        address _asset,\\n        AggregatorV3Interface _aggregator,\\n        bool _convertToQuote\\n    ) internal virtual returns (bool changed) {\\n        if (address(_aggregator) == address(0)) revert InvalidAggregator();\\n\\n        AssetData storage data = assetData[_asset];\\n\\n        if (data.aggregator == _aggregator && data.forceFallback == false) {\\n            return false;\\n        }\\n\\n        // There doesn't seem to be a way to verify if this is a \\\"valid\\\" aggregator (other than getting the price)\\n        data.forceFallback = false;\\n        data.aggregator = _aggregator;\\n\\n        (bool success,) = _getAggregatorPrice(_asset);\\n\\n        if (!success) revert AggregatorPriceNotAvailable();\\n\\n        if (_convertToQuote && _aggregator.decimals() != _QUOTE_AGGREGATOR_DECIMALS) {\\n            revert InvalidAggregatorDecimals();\\n        }\\n\\n        // We want to always update this\\n        assetData[_asset].convertToQuote = _convertToQuote;\\n\\n        emit NewAggregator(_asset, _aggregator, _convertToQuote);\\n\\n        return true;\\n    }\\n\\n    function _setFallbackPriceProvider(address _asset, IPriceProvider _fallbackProvider)\\n        internal\\n        virtual\\n        returns (bool changed)\\n    {\\n        if (_fallbackProvider == assetData[_asset].fallbackProvider) {\\n            return false;\\n        }\\n\\n        assetData[_asset].fallbackProvider = _fallbackProvider;\\n\\n        if (address(_fallbackProvider) != address(0)) {\\n            if (\\n                !priceProvidersRepository.isPriceProvider(_fallbackProvider) ||\\n                !_fallbackProvider.assetSupported(_asset) ||\\n                _fallbackProvider.quoteToken() != quoteToken\\n            ) {\\n                revert InvalidFallbackPriceProvider();\\n            }\\n\\n            // Make sure it doesn't revert\\n            _getFallbackPrice(_asset);\\n        }\\n\\n        emit NewFallbackPriceProvider(_asset, _fallbackProvider);\\n\\n        return true;\\n    }\\n\\n    function _setHeartbeat(address _asset, uint256 _heartbeat) internal virtual returns (bool changed) {\\n        // Arbitrary limit, Chainlink's threshold is always less than a day\\n        if (_heartbeat > 2 days) revert InvalidHeartbeat();\\n\\n        if (_heartbeat == assetData[_asset].heartbeat) {\\n            return false;\\n        }\\n\\n        assetData[_asset].heartbeat = _heartbeat;\\n\\n        emit NewHeartbeat(_asset, _heartbeat);\\n\\n        return true;\\n    }\\n\\n    function _setQuoteAggregatorHeartbeat(uint256 _heartbeat) internal virtual returns (bool changed) {\\n        // Arbitrary limit, Chainlink's threshold is always less than a day\\n        if (_heartbeat > 2 days) revert InvalidHeartbeat();\\n\\n        if (_heartbeat == quoteAggregatorHeartbeat) {\\n            return false;\\n        }\\n\\n        quoteAggregatorHeartbeat = _heartbeat;\\n\\n        emit NewQuoteAggregatorHeartbeat(_heartbeat);\\n\\n        return true;\\n    }\\n\\n    /// @dev Adjusts the given price to use the same decimals as the quote token.\\n    /// @param _price Price to adjust decimals\\n    /// @param _decimals Decimals considered in `_price`\\n    function _normalizeWithDecimals(uint256 _price, uint8 _decimals) internal view virtual returns (uint256) {\\n        // We want to return the price of 1 asset token, but with the decimals of the quote token\\n        if (_QUOTE_TOKEN_DECIMALS == _decimals) {\\n            return _price;\\n        } else if (_QUOTE_TOKEN_DECIMALS < _decimals) {\\n            return _price / 10 ** (_decimals - _QUOTE_TOKEN_DECIMALS);\\n        } else {\\n            return _price * 10 ** (_QUOTE_TOKEN_DECIMALS - _decimals);\\n        }\\n    }\\n\\n    /// @dev Converts a price returned by an aggregator to quote units\\n    function _toQuote(uint256 _price) internal view virtual returns (uint256) {\\n       (\\n            /*uint80 roundID*/,\\n            int256 aggregatorPrice,\\n            /*uint256 startedAt*/,\\n            uint256 timestamp,\\n            /*uint80 answeredInRound*/\\n        ) = _QUOTE_AGGREGATOR.latestRoundData();\\n\\n        // If an invalid price is returned\\n        if (!_isValidPrice(aggregatorPrice, timestamp, quoteAggregatorHeartbeat)) {\\n            revert AggregatorPriceNotAvailable();\\n        }\\n\\n        // _price and aggregatorPrice should both have the same decimals so we normalize here\\n        return _price * 10 ** _QUOTE_TOKEN_DECIMALS / uint256(aggregatorPrice);\\n    }\\n\\n    function _isValidPrice(int256 _price, uint256 _timestamp, uint256 _heartbeat) internal view virtual returns (bool) {\\n        return _price > 0 && block.timestamp - _timestamp < _heartbeat;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface AggregatorV3Interface {\\n  function decimals() external view returns (uint8);\\n\\n  function description() external view returns (string memory);\\n\\n  function version() external view returns (uint256);\\n\\n  // getRoundData and latestRoundData should both raise \\\"No data present\\\"\\n  // if they do not have data to report, instead of returning unset values\\n  // which could be misinterpreted as actual reported values.\\n  function getRoundData(uint80 _roundId)\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n  function latestRoundData()\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n}\\n\"\r\n    },\r\n    \"contracts/priceProviders/PriceProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.7.6 <0.9.0;\\n\\nimport \\\"../lib/Ping.sol\\\";\\nimport \\\"../interfaces/IPriceProvider.sol\\\";\\nimport \\\"../interfaces/IPriceProvidersRepository.sol\\\";\\n\\n/// @title PriceProvider\\n/// @notice Abstract PriceProvider contract, parent of all PriceProviders\\n/// @dev Price provider is a contract that directly integrates with a price source, ie. a DEX or alternative system\\n/// like Chainlink to calculate TWAP prices for assets. Each price provider should support a single price source\\n/// and multiple assets.\\nabstract contract PriceProvider is IPriceProvider {\\n    /// @notice PriceProvidersRepository address\\n    IPriceProvidersRepository public immutable priceProvidersRepository;\\n\\n    /// @notice Token address which prices are quoted in. Must be the same as PriceProvidersRepository.quoteToken\\n    address public immutable override quoteToken;\\n\\n    modifier onlyManager() {\\n        if (priceProvidersRepository.manager() != msg.sender) revert(\\\"OnlyManager\\\");\\n        _;\\n    }\\n\\n    /// @param _priceProvidersRepository address of PriceProvidersRepository\\n    constructor(IPriceProvidersRepository _priceProvidersRepository) {\\n        if (\\n            !Ping.pong(_priceProvidersRepository.priceProvidersRepositoryPing)            \\n        ) {\\n            revert(\\\"InvalidPriceProviderRepository\\\");\\n        }\\n\\n        priceProvidersRepository = _priceProvidersRepository;\\n        quoteToken = _priceProvidersRepository.quoteToken();\\n    }\\n\\n    /// @inheritdoc IPriceProvider\\n    function priceProviderPing() external pure override returns (bytes4) {\\n        return this.priceProviderPing.selector;\\n    }\\n\\n    function _revertBytes(bytes memory _errMsg, string memory _customErr) internal pure {\\n        if (_errMsg.length > 0) {\\n            assembly { // solhint-disable-line no-inline-assembly\\n                revert(add(32, _errMsg), mload(_errMsg))\\n            }\\n        }\\n\\n        revert(_customErr);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/priceProviders/IERC20LikeV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.7.6;\\n\\n/// @dev This is only meant to be used by price providers, which use a different\\n/// Solidity version than the rest of the codebase. This way de won't need to include\\n/// an additional version of OpenZeppelin's library.\\ninterface IERC20LikeV2 {\\n    function decimals() external view returns (uint8);\\n    function balanceOf(address) external view returns(uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/lib/Ping.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.7.6 <0.9.0;\\n\\n\\nlibrary Ping {\\n    function pong(function() external pure returns(bytes4) pingFunction) internal pure returns (bool) {\\n        return pingFunction.address != address(0) && pingFunction.selector == pingFunction();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPriceProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.7.6 <0.9.0;\\n\\n/// @title Common interface for Silo Price Providers\\ninterface IPriceProvider {\\n    /// @notice Returns \\\"Time-Weighted Average Price\\\" for an asset. Calculates TWAP price for quote/asset.\\n    /// It unifies all tokens decimal to 18, examples:\\n    /// - if asses == quote it returns 1e18\\n    /// - if asset is USDC and quote is ETH and ETH costs ~$3300 then it returns ~0.0003e18 WETH per 1 USDC\\n    /// @param _asset address of an asset for which to read price\\n    /// @return price of asses with 18 decimals, throws when pool is not ready yet to provide price\\n    function getPrice(address _asset) external view returns (uint256 price);\\n\\n    /// @dev Informs if PriceProvider is setup for asset. It does not means PriceProvider can provide price right away.\\n    /// Some providers implementations need time to \\\"build\\\" buffer for TWAP price,\\n    /// so price may not be available yet but this method will return true.\\n    /// @param _asset asset in question\\n    /// @return TRUE if asset has been setup, otherwise false\\n    function assetSupported(address _asset) external view returns (bool);\\n\\n    /// @notice Gets token address in which prices are quoted\\n    /// @return quoteToken address\\n    function quoteToken() external view returns (address);\\n\\n    /// @notice Helper method that allows easily detects, if contract is PriceProvider\\n    /// @dev this can save us from simple human errors, in case we use invalid address\\n    /// but this should NOT be treated as security check\\n    /// @return always true\\n    function priceProviderPing() external pure returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPriceProvidersRepository.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.7.6 <0.9.0;\\n\\nimport \\\"./IPriceProvider.sol\\\";\\n\\ninterface IPriceProvidersRepository {\\n    /// @notice Emitted when price provider is added\\n    /// @param newPriceProvider new price provider address\\n    event NewPriceProvider(IPriceProvider indexed newPriceProvider);\\n\\n    /// @notice Emitted when price provider is removed\\n    /// @param priceProvider removed price provider address\\n    event PriceProviderRemoved(IPriceProvider indexed priceProvider);\\n\\n    /// @notice Emitted when asset is assigned to price provider\\n    /// @param asset assigned asset   address\\n    /// @param priceProvider price provider address\\n    event PriceProviderForAsset(address indexed asset, IPriceProvider indexed priceProvider);\\n\\n    /// @notice Register new price provider\\n    /// @param _priceProvider address of price provider\\n    function addPriceProvider(IPriceProvider _priceProvider) external;\\n\\n    /// @notice Unregister price provider\\n    /// @param _priceProvider address of price provider to be removed\\n    function removePriceProvider(IPriceProvider _priceProvider) external;\\n\\n    /// @notice Sets price provider for asset\\n    /// @dev Request for asset price is forwarded to the price provider assigned to that asset\\n    /// @param _asset address of an asset for which price provider will be used\\n    /// @param _priceProvider address of price provider\\n    function setPriceProviderForAsset(address _asset, IPriceProvider _priceProvider) external;\\n\\n    /// @notice Returns \\\"Time-Weighted Average Price\\\" for an asset\\n    /// @param _asset address of an asset for which to read price\\n    /// @return price TWAP price of a token with 18 decimals\\n    function getPrice(address _asset) external view returns (uint256 price);\\n\\n    /// @notice Gets price provider assigned to an asset\\n    /// @param _asset address of an asset for which to get price provider\\n    /// @return priceProvider address of price provider\\n    function priceProviders(address _asset) external view returns (IPriceProvider priceProvider);\\n\\n    /// @notice Gets token address in which prices are quoted\\n    /// @return quoteToken address\\n    function quoteToken() external view returns (address);\\n\\n    /// @notice Gets manager role address\\n    /// @return manager role address\\n    function manager() external view returns (address);\\n\\n    /// @notice Checks if providers are available for an asset\\n    /// @param _asset asset address to check\\n    /// @return returns TRUE if price feed is ready, otherwise false\\n    function providersReadyForAsset(address _asset) external view returns (bool);\\n\\n    /// @notice Returns true if address is a registered price provider\\n    /// @param _provider address of price provider to be removed\\n    /// @return true if address is a registered price provider, otherwise false\\n    function isPriceProvider(IPriceProvider _provider) external view returns (bool);\\n\\n    /// @notice Gets number of price providers registered\\n    /// @return number of price providers registered\\n    function providersCount() external view returns (uint256);\\n\\n    /// @notice Gets an array of price providers\\n    /// @return array of price providers\\n    function providerList() external view returns (address[] memory);\\n\\n    /// @notice Sanity check function\\n    /// @return returns always TRUE\\n    function priceProvidersRepositoryPing() external pure returns (bytes4);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IPriceProvidersRepository\",\"name\":\"_priceProvidersRepository\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_emergencyManager\",\"type\":\"address\"},{\"internalType\":\"contract AggregatorV3Interface\",\"name\":\"_quoteAggregator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_quoteAggregatorHeartbeat\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AggregatorDidNotChange\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AggregatorPriceNotAvailable\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AssetNotSupported\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"EmergencyManagerDidNotChange\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"EmergencyThresholdNotReached\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FallbackProviderAlreadySet\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FallbackProviderDidNotChange\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FallbackProviderNotSet\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"HeartbeatDidNotChange\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidAggregator\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidAggregatorDecimals\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidFallbackPriceProvider\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidHeartbeat\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyEmergencyManager\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"QuoteAggregatorHeartbeatDidNotChange\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract AggregatorV3Interface\",\"name\":\"aggregator\",\"type\":\"address\"}],\"name\":\"AggregatorDisabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract AggregatorV3Interface\",\"name\":\"aggregator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"convertToQuote\",\"type\":\"bool\"}],\"name\":\"NewAggregator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"emergencyManager\",\"type\":\"address\"}],\"name\":\"NewEmergencyManager\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract IPriceProvider\",\"name\":\"fallbackProvider\",\"type\":\"address\"}],\"name\":\"NewFallbackPriceProvider\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"heartbeat\",\"type\":\"uint256\"}],\"name\":\"NewHeartbeat\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"heartbeat\",\"type\":\"uint256\"}],\"name\":\"NewQuoteAggregatorHeartbeat\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"EMERGENCY_PRECISION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"EMERGENCY_THRESHOLD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"assetData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"heartbeat\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"forceFallback\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"convertToQuote\",\"type\":\"bool\"},{\"internalType\":\"contract AggregatorV3Interface\",\"name\":\"aggregator\",\"type\":\"address\"},{\"internalType\":\"contract IPriceProvider\",\"name\":\"fallbackProvider\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"}],\"name\":\"assetSupported\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"}],\"name\":\"emergencyDisable\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emergencyManager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"}],\"name\":\"getAggregatorPrice\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"}],\"name\":\"getFallbackProvider\",\"outputs\":[{\"internalType\":\"contract IPriceProvider\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"}],\"name\":\"getPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceProviderPing\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceProvidersRepository\",\"outputs\":[{\"internalType\":\"contract IPriceProvidersRepository\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"quoteAggregatorHeartbeat\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"quoteToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"},{\"internalType\":\"contract AggregatorV3Interface\",\"name\":\"_aggregator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_convertToQuote\",\"type\":\"bool\"}],\"name\":\"setAggregator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_emergencyManager\",\"type\":\"address\"}],\"name\":\"setEmergencyManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"},{\"internalType\":\"contract IPriceProvider\",\"name\":\"_fallbackProvider\",\"type\":\"address\"}],\"name\":\"setFallbackPriceProvider\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_heartbeat\",\"type\":\"uint256\"}],\"name\":\"setHeartbeat\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_heartbeat\",\"type\":\"uint256\"}],\"name\":\"setQuoteAggregatorHeartbeat\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"},{\"internalType\":\"contract AggregatorV3Interface\",\"name\":\"_aggregator\",\"type\":\"address\"},{\"internalType\":\"contract IPriceProvider\",\"name\":\"_fallbackProvider\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_heartbeat\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_convertToQuote\",\"type\":\"bool\"}],\"name\":\"setupAsset\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "ChainlinkV3PriceProvider", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000007c2ca9d502f2409beceafa68e97a176ff805029f000000000000000000000000e1f03b7b0ebf84e9b9f62a1db40f1efb8faa7d220000000000000000000000005f4ec3df9cbd43714fe2740f5e3616155c5b84190000000000000000000000000000000000000000000000000000000000001c20", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}