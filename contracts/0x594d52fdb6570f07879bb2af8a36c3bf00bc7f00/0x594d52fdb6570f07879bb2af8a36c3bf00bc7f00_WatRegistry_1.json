{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/WatRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.16;\\n\\nimport {Auth} from \\\"chronicle-std/auth/Auth.sol\\\";\\n\\nimport {IWatRegistry} from \\\"./IWatRegistry.sol\\\";\\n\\n/**\\n * @title WatRegistry\\n *\\n * @notice Registry to manage feed and bar configurations for non-mainnet wats\\n *\\n * @dev The contract uses the `chronicle-std/Auth` module for access control.\\n *      While the registry is publicly readable, state mutating functions are\\n *      only callable by auth'ed addresses.\\n */\\ncontract WatRegistry is IWatRegistry, Auth {\\n    /// @dev Mapping storing a wat's bar configuration.\\n    mapping(bytes32 => uint8) internal _bar;\\n\\n    /// @dev Mapping storing a wat's list of lifted feeds.\\n    ///\\n    /// @custom:invariant Every feed for every wat maps to 1 in _feedsLookup[wat].\\n    ///                     \u2200wat \u220a Bytes32: \u2200x \u220a Address: x \u220a _feeds[wat] \u2192 _feedsLookup[wat][x] = 1\\n    /// @custom:invariant List does not contain duplicates.\\n    ///                     \u2200wat \u220a Bytes32: \u2200x \u220a Address: count(_feeds[wat], x) <= 1\\n    mapping(bytes32 => address[]) internal _feeds;\\n\\n    /// @dev Mapping storing whether a wat has a feed lifted.\\n    /// @dev Used to prevent duplicates in _feeds[wat].\\n    ///\\n    /// @custom:invariant Image of mapping is {0, 1}\\n    ///                     \u2200wat \u220a Bytes32: \u2200x \u220a Address: _feedsLookup[wat][x] \u220a {0, 1}\\n    mapping(bytes32 => mapping(address => uint)) _feedsLookup;\\n\\n    // -- Constructor --\\n\\n    constructor(address initialAuthed) Auth(initialAuthed) {}\\n\\n    // -- Public View Functions --\\n\\n    /// @inheritdoc IWatRegistry\\n    function bar(bytes32 wat) external view returns (uint8) {\\n        return _bar[wat];\\n    }\\n\\n    /// @inheritdoc IWatRegistry\\n    function feeds(bytes32 wat) external view returns (address[] memory) {\\n        return _feeds[wat];\\n    }\\n\\n    // -- Auth'ed Functions --\\n\\n    /// @inheritdoc IWatRegistry\\n    function setBar(bytes32 wat, uint8 bar_) external auth {\\n        if (_bar[wat] != bar_) {\\n            emit BarUpdated(msg.sender, wat, _bar[wat], bar_);\\n\\n            _bar[wat] = bar_;\\n        }\\n    }\\n\\n    /// @inheritdoc IWatRegistry\\n    function lift(bytes32 wat, address feed) external auth {\\n        _lift(wat, feed);\\n    }\\n\\n    /// @inheritdoc IWatRegistry\\n    function lift(bytes32 wat, address[] memory feeds_) external auth {\\n        for (uint i; i < feeds_.length; i++) {\\n            _lift(wat, feeds_[i]);\\n        }\\n    }\\n\\n    /// @inheritdoc IWatRegistry\\n    function drop(bytes32 wat, address feed) external auth {\\n        _drop(wat, feed);\\n    }\\n\\n    /// @inheritdoc IWatRegistry\\n    function drop(bytes32 wat, address[] memory feeds_) external auth {\\n        for (uint i; i < feeds_.length; i++) {\\n            _drop(wat, feeds_[i]);\\n        }\\n    }\\n\\n    // -- Internal Helpers --\\n\\n    function _lift(bytes32 wat, address feed) internal {\\n        if (_feedsLookup[wat][feed] == 1) return;\\n\\n        _feedsLookup[wat][feed] = 1;\\n        _feeds[wat].push(feed);\\n\\n        emit FeedLifted(msg.sender, wat, feed);\\n    }\\n\\n    function _drop(bytes32 wat, address feed) internal {\\n        if (_feedsLookup[wat][feed] == 0) return;\\n\\n        _feedsLookup[wat][feed] = 0;\\n\\n        address[] storage feeds_ = _feeds[wat];\\n        for (uint i; i < feeds_.length; i++) {\\n            if (feeds_[i] == feed) {\\n                feeds_[i] = feeds_[feeds_.length - 1];\\n                feeds_.pop();\\n\\n                emit FeedDropped(msg.sender, wat, feed);\\n\\n                break;\\n            }\\n        }\\n    }\\n}\\n\\n/**\\n * @dev Contract overwrite to deploy contract instances with specific naming.\\n *\\n *      For more info, see docs/Deployment.md.\\n */\\ncontract WatRegistry_1 is WatRegistry {\\n    constructor(address initialAuthed) WatRegistry(initialAuthed) {}\\n}\\n\"\r\n    },\r\n    \"lib/chronicle-std/src/auth/Auth.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.16;\\n\\nimport {IAuth} from \\\"./IAuth.sol\\\";\\n\\n/**\\n * @title Auth Module\\n *\\n * @dev The `Auth` contract module provides a basic access control mechanism,\\n *      where a set of addresses are granted access to protected functions.\\n *      These addresses are said to be _auth'ed_.\\n *\\n *      Initially, the address given as constructor argument is the only address\\n *      auth'ed. Through the `rely(address)` and `deny(address)` functions,\\n *      auth'ed callers are able to grant/renounce auth to/from addresses.\\n *\\n *      This module is used through inheritance. It will make available the\\n *      modifier `auth`, which can be applied to functions to restrict their\\n *      use to only auth'ed callers.\\n */\\nabstract contract Auth is IAuth {\\n    /// @dev Mapping storing whether address is auth'ed.\\n    /// @custom:invariant Image of mapping is {0, 1}.\\n    ///                     \u2200x \u220a Address: _wards[x] \u220a {0, 1}\\n    /// @custom:invariant Only address given as constructor argument is authenticated after deployment.\\n    ///                     deploy(initialAuthed) \u2192 (\u2200x \u220a Address: _wards[x] == 1 \u2192 x == initialAuthed)\\n    /// @custom:invariant Only functions `rely` and `deny` may mutate the mapping's state.\\n    ///                     \u2200x \u220a Address: preTx(_wards[x]) != postTx(_wards[x])\\n    ///                                     \u2192 (msg.sig == \\\"rely\\\" \u2228 msg.sig == \\\"deny\\\")\\n    /// @custom:invariant Mapping's state may only be mutated by authenticated caller.\\n    ///                     \u2200x \u220a Address: preTx(_wards[x]) != postTx(_wards[x]) \u2192 _wards[msg.sender] = 1\\n    mapping(address => uint) private _wards;\\n\\n    /// @dev List of addresses possibly being auth'ed.\\n    /// @dev May contain duplicates.\\n    /// @dev May contain addresses not being auth'ed anymore.\\n    /// @custom:invariant Every address being auth'ed once is element of the list.\\n    ///                     \u2200x \u220a Address: authed(x) -> x \u220a _wardsTouched\\n    address[] private _wardsTouched;\\n\\n    /// @dev Ensures caller is auth'ed.\\n    modifier auth() {\\n        assembly (\\\"memory-safe\\\") {\\n            // Compute slot of _wards[msg.sender].\\n            mstore(0x00, caller())\\n            mstore(0x20, _wards.slot)\\n            let slot := keccak256(0x00, 0x40)\\n\\n            // Revert if caller not auth'ed.\\n            let isAuthed := sload(slot)\\n            if iszero(isAuthed) {\\n                // Store selector of `NotAuthorized(address)`.\\n                mstore(0x00, 0x4a0bfec1)\\n                // Store msg.sender.\\n                mstore(0x20, caller())\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x24)\\n            }\\n        }\\n        _;\\n    }\\n\\n    constructor(address initialAuthed) {\\n        _wards[initialAuthed] = 1;\\n        _wardsTouched.push(initialAuthed);\\n\\n        // Note to use address(0) as caller to indicate address was auth'ed\\n        // during deployment.\\n        emit AuthGranted(address(0), initialAuthed);\\n    }\\n\\n    /// @inheritdoc IAuth\\n    function rely(address who) external auth {\\n        if (_wards[who] == 1) return;\\n\\n        _wards[who] = 1;\\n        _wardsTouched.push(who);\\n        emit AuthGranted(msg.sender, who);\\n    }\\n\\n    /// @inheritdoc IAuth\\n    function deny(address who) external auth {\\n        if (_wards[who] == 0) return;\\n\\n        _wards[who] = 0;\\n        emit AuthRenounced(msg.sender, who);\\n    }\\n\\n    /// @inheritdoc IAuth\\n    function authed(address who) public view returns (bool) {\\n        return _wards[who] == 1;\\n    }\\n\\n    /// @inheritdoc IAuth\\n    /// @custom:invariant Only contains auth'ed addresses.\\n    ///                     \u2200x \u220a authed(): _wards[x] == 1\\n    /// @custom:invariant Contains all auth'ed addresses.\\n    ///                     \u2200x \u220a Address: _wards[x] == 1 \u2192 x \u220a authed()\\n    function authed() public view returns (address[] memory) {\\n        // Initiate array with upper limit length.\\n        address[] memory wardsList = new address[](_wardsTouched.length);\\n\\n        // Iterate through all possible auth'ed addresses.\\n        uint ctr;\\n        for (uint i; i < wardsList.length; i++) {\\n            // Add address only if still auth'ed.\\n            if (_wards[_wardsTouched[i]] == 1) {\\n                wardsList[ctr++] = _wardsTouched[i];\\n            }\\n        }\\n\\n        // Set length of array to number of auth'ed addresses actually included.\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(wardsList, ctr)\\n        }\\n\\n        return wardsList;\\n    }\\n\\n    /// @inheritdoc IAuth\\n    function wards(address who) public view returns (uint) {\\n        return _wards[who];\\n    }\\n}\\n\"\r\n    },\r\n    \"src/IWatRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.16;\\n\\ninterface IWatRegistry {\\n    /// @notice Emitted when a wat's bar updated.\\n    /// @param caller The caller's address.\\n    /// @param wat The wat bar was updated for.\\n    /// @param oldBar The old bar's value.\\n    /// @param newBar The new bar's value.\\n    event BarUpdated(\\n        address indexed caller, bytes32 indexed wat, uint8 oldBar, uint8 newBar\\n    );\\n\\n    /// @notice Emitted when new feed lifted for a wat.\\n    /// @param caller The caller's address.\\n    /// @param wat The wat the feed was lifted for.\\n    /// @param feed The feed address lifted.\\n    event FeedLifted(\\n        address indexed caller, bytes32 indexed wat, address indexed feed\\n    );\\n\\n    /// @notice Emitted when a wat's feed dropped.\\n    /// @param caller The caller's address.\\n    /// @param wat The wat the feed was dropped for.\\n    /// @param feed The feed address dropped.\\n    event FeedDropped(\\n        address indexed caller, bytes32 indexed wat, address indexed feed\\n    );\\n\\n    // -- View Functionality --\\n\\n    /// @notice Returns the bar configuration for wat `wat`.\\n    /// @param wat The wat of which to return its bar configuration.\\n    /// @return bar The bar configuration for wat `wat`.\\n    function bar(bytes32 wat) external view returns (uint8 bar);\\n\\n    /// @notice Returns the list of feeds lifted for wat `wat`.\\n    /// @param wat The wat of which to return its lifted feeds.\\n    /// @return feeds The lifted feeds for wat `wat`.\\n    function feeds(bytes32 wat)\\n        external\\n        view\\n        returns (address[] memory feeds);\\n\\n    // -- Auth'ed Functionality --\\n\\n    /// @notice Updates the bar configuration for wat `wat` to `bar`.\\n    /// @dev Only callable by auth'ed address.\\n    /// @param wat The wat to update its bar.\\n    /// @param bar The bar configuration to set for wat `wat`.\\n    function setBar(bytes32 wat, uint8 bar) external;\\n\\n    /// @notice Lifts feed `feed` for wat `wat`.\\n    /// @dev Only callable by auth'ed address.\\n    /// @param wat The wat to lift feed `feed` for.\\n    /// @param feed The feed to lift for wat `wat`.\\n    function lift(bytes32 wat, address feed) external;\\n\\n    /// @notice Lifts feeds `feeds` for wat `wat`.\\n    /// @dev Only callable by auth'ed address.\\n    /// @param wat The wat to lift feeds `feeds` for.\\n    /// @param feeds The feeds to lift for wat `wat`.\\n    function lift(bytes32 wat, address[] memory feeds) external;\\n\\n    /// @notice Drops feed `feed` for wat `wat`.\\n    /// @dev Only callable by auth'ed address.\\n    /// @param wat The wat to drop feed `feed` for.\\n    /// @param feed The feed to drop for wat `wat`.\\n    function drop(bytes32 wat, address feed) external;\\n\\n    /// @notice Drops feeds `feeds` for wat `wat`.\\n    /// @dev Only callable by auth'ed address.\\n    /// @param wat The wat to drop feeds `feeds` for.\\n    /// @param feeds The feeds to drop for wat `wat`.\\n    function drop(bytes32 wat, address[] memory feeds) external;\\n}\\n\"\r\n    },\r\n    \"lib/chronicle-std/src/auth/IAuth.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.16;\\n\\ninterface IAuth {\\n    /// @notice Thrown by protected function if caller not auth'ed.\\n    /// @param caller The caller's address.\\n    error NotAuthorized(address caller);\\n\\n    /// @notice Emitted when auth granted to address.\\n    /// @param caller The caller's address.\\n    /// @param who The address auth got granted to.\\n    event AuthGranted(address indexed caller, address indexed who);\\n\\n    /// @notice Emitted when auth renounced from address.\\n    /// @param caller The caller's address.\\n    /// @param who The address auth got renounced from.\\n    event AuthRenounced(address indexed caller, address indexed who);\\n\\n    /// @notice Grants address `who` auth.\\n    /// @dev Only callable by auth'ed address.\\n    /// @param who The address to grant auth.\\n    function rely(address who) external;\\n\\n    /// @notice Renounces address `who`'s auth.\\n    /// @dev Only callable by auth'ed address.\\n    /// @param who The address to renounce auth.\\n    function deny(address who) external;\\n\\n    /// @notice Returns whether address `who` is auth'ed.\\n    /// @param who The address to check.\\n    /// @return True if `who` is auth'ed, false otherwise.\\n    function authed(address who) external view returns (bool);\\n\\n    /// @notice Returns full list of addresses granted auth.\\n    /// @dev May contain duplicates.\\n    /// @return List of addresses granted auth.\\n    function authed() external view returns (address[] memory);\\n\\n    /// @notice Returns whether address `who` is auth'ed.\\n    /// @custom:deprecated Use `authed(address)(bool)` instead.\\n    /// @param who The address to check.\\n    /// @return 1 if `who` is auth'ed, 0 otherwise.\\n    function wards(address who) external view returns (uint);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"chronicle-std/=lib/chronicle-std/src/\",\r\n      \"@script/chronicle-std/=lib/chronicle-std/script/\",\r\n      \"lib/chronicle-std:src/=lib/chronicle-std/src/\",\r\n      \"greenhouse/=lib/greenhouse/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 10000\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"viaIR\": true,\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"initialAuthed\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"NotAuthorized\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"AuthGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"AuthRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"wat\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"oldBar\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"newBar\",\"type\":\"uint8\"}],\"name\":\"BarUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"wat\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"feed\",\"type\":\"address\"}],\"name\":\"FeedDropped\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"wat\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"feed\",\"type\":\"address\"}],\"name\":\"FeedLifted\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"authed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"authed\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"wat\",\"type\":\"bytes32\"}],\"name\":\"bar\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"deny\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"wat\",\"type\":\"bytes32\"},{\"internalType\":\"address[]\",\"name\":\"feeds_\",\"type\":\"address[]\"}],\"name\":\"drop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"wat\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"feed\",\"type\":\"address\"}],\"name\":\"drop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"wat\",\"type\":\"bytes32\"}],\"name\":\"feeds\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"wat\",\"type\":\"bytes32\"},{\"internalType\":\"address[]\",\"name\":\"feeds_\",\"type\":\"address[]\"}],\"name\":\"lift\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"wat\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"feed\",\"type\":\"address\"}],\"name\":\"lift\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"rely\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"wat\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"bar_\",\"type\":\"uint8\"}],\"name\":\"setBar\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"wards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "WatRegistry_1", "CompilerVersion": "v0.8.16+commit.07a7930e", "OptimizationUsed": "1", "Runs": "10000", "ConstructorArguments": "000000000000000000000000c50dfedb7e93ef7a3daccad7987d0960c4e2cd4b", "EVMVersion": "london", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}