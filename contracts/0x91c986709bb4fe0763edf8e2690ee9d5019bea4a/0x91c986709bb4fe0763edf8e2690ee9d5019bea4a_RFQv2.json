{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/RFQv2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.6;\\npragma abicoder v2;\\n\\nimport { SafeMath } from \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport { Address } from \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\n\\nimport { TokenCollector } from \\\"./utils/TokenCollector.sol\\\";\\nimport { BaseLibEIP712 } from \\\"./utils/BaseLibEIP712.sol\\\";\\nimport { Asset } from \\\"./utils/Asset.sol\\\";\\nimport { Offer } from \\\"./utils/Offer.sol\\\";\\nimport { RFQOrder, getRFQOrderHash } from \\\"./utils/RFQOrder.sol\\\";\\nimport { LibConstant } from \\\"./utils/LibConstant.sol\\\";\\nimport { SignatureValidator } from \\\"./utils/SignatureValidator.sol\\\";\\nimport { StrategyBase } from \\\"./utils/StrategyBase.sol\\\";\\nimport { IRFQv2 } from \\\"./interfaces/IRFQv2.sol\\\";\\n\\n/// @title RFQv2 Contract\\n/// @author imToken Labs\\ncontract RFQv2 is IRFQv2, StrategyBase, TokenCollector, SignatureValidator, BaseLibEIP712 {\\n    using SafeMath for uint256;\\n    using Asset for address;\\n\\n    address payable public feeCollector;\\n\\n    /// @notice Emitted when fee collector address is updated\\n    /// @param newFeeCollector The address of the new fee collector\\n    event SetFeeCollector(address newFeeCollector);\\n\\n    receive() external payable {}\\n\\n    constructor(\\n        address _owner,\\n        address _userProxy,\\n        address _weth,\\n        address _permStorage,\\n        address _spender,\\n        address _uniswapPermit2,\\n        address payable _feeCollector\\n    ) StrategyBase(_owner, _userProxy, _weth, _permStorage, _spender) TokenCollector(_uniswapPermit2, _spender) {\\n        feeCollector = _feeCollector;\\n    }\\n\\n    /// @notice Set fee collector\\n    /// @notice Only owner can call\\n    /// @param _newFeeCollector The address of the new fee collector\\n    function setFeeCollector(address payable _newFeeCollector) external onlyOwner {\\n        require(_newFeeCollector != address(0), \\\"zero address\\\");\\n        feeCollector = _newFeeCollector;\\n\\n        emit SetFeeCollector(_newFeeCollector);\\n    }\\n\\n    /// @inheritdoc IRFQv2\\n    function fillRFQ(\\n        RFQOrder calldata order,\\n        bytes calldata makerSignature,\\n        bytes calldata makerTokenPermit,\\n        bytes calldata takerSignature,\\n        bytes calldata takerTokenPermit\\n    ) external payable override onlyUserProxy {\\n        Offer calldata _offer = order.offer;\\n        // check the offer deadline and fee factor\\n        require(_offer.expiry > block.timestamp, \\\"offer expired\\\");\\n        require(_offer.feeFactor < LibConstant.BPS_MAX, \\\"invalid fee factor\\\");\\n        require(order.recipient != address(0), \\\"zero recipient\\\");\\n\\n        // check if the offer is available to be filled\\n        (bytes32 offerHash, bytes32 rfqOrderHash) = getRFQOrderHash(order);\\n\\n        // check and set\\n        permStorage.setRFQOfferFilled(offerHash);\\n\\n        // check maker signature\\n        require(isValidSignature(_offer.maker, getEIP712Hash(offerHash), bytes(\\\"\\\"), makerSignature), \\\"invalid signature\\\");\\n\\n        // check taker signature if needed\\n        if (_offer.taker != msg.sender) {\\n            require(isValidSignature(_offer.taker, getEIP712Hash(rfqOrderHash), bytes(\\\"\\\"), takerSignature), \\\"invalid signature\\\");\\n        }\\n\\n        // transfer takerToken to maker\\n        if (_offer.takerToken.isETH()) {\\n            require(msg.value == _offer.takerTokenAmount, \\\"invalid msg value\\\");\\n            weth.deposit{ value: msg.value }();\\n            weth.transfer(_offer.maker, msg.value);\\n        } else {\\n            require(msg.value == 0, \\\"invalid msg value\\\");\\n            _collect(_offer.takerToken, _offer.taker, _offer.maker, _offer.takerTokenAmount, takerTokenPermit);\\n        }\\n\\n        // collect makerToken from maker to this\\n        _collect(_offer.makerToken, _offer.maker, address(this), _offer.makerTokenAmount, makerTokenPermit);\\n\\n        // transfer makerToken to recipient (sub fee)\\n        uint256 fee = _offer.makerTokenAmount.mul(_offer.feeFactor).div(LibConstant.BPS_MAX);\\n        uint256 makerTokenToTaker = _offer.makerTokenAmount.sub(fee);\\n        {\\n            // determine if WETH unwrap is needed, send out ETH if makerToken is WETH\\n            address makerToken = _offer.makerToken;\\n            if (makerToken == address(weth)) {\\n                weth.withdraw(_offer.makerTokenAmount);\\n                makerToken = LibConstant.ETH_ADDRESS;\\n            }\\n\\n            // collect fee if present\\n            if (fee > 0) {\\n                makerToken.transferTo(feeCollector, fee);\\n            }\\n\\n            makerToken.transferTo(order.recipient, makerTokenToTaker);\\n        }\\n\\n        _emitFilledRFQEvent(offerHash, order, makerTokenToTaker);\\n    }\\n\\n    function _emitFilledRFQEvent(\\n        bytes32 _offerHash,\\n        RFQOrder calldata _rfqOrder,\\n        uint256 _makerTokenToTaker\\n    ) internal {\\n        emit FilledRFQ(\\n            _offerHash,\\n            _rfqOrder.offer.taker,\\n            _rfqOrder.offer.maker,\\n            _rfqOrder.offer.takerToken,\\n            _rfqOrder.offer.takerTokenAmount,\\n            _rfqOrder.offer.makerToken,\\n            _rfqOrder.offer.makerTokenAmount,\\n            _rfqOrder.recipient,\\n            _makerTokenToTaker,\\n            _rfqOrder.offer.feeFactor\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/TokenCollector.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.6;\\npragma abicoder v2;\\n\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport { SafeERC20 } from \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\n\\nimport { IUniswapPermit2 } from \\\"../interfaces/IUniswapPermit2.sol\\\";\\nimport { ISpender } from \\\"../interfaces/ISpender.sol\\\";\\nimport { IERC20Permit } from \\\"../interfaces/IERC20Permit.sol\\\";\\n\\nabstract contract TokenCollector {\\n    using SafeERC20 for IERC20;\\n\\n    enum Source {\\n        TokenlonSpender,\\n        Token,\\n        TokenPermit,\\n        Permit2AllowanceTransfer,\\n        Permit2SignatureTransfer\\n    }\\n\\n    address public immutable permit2;\\n    address public immutable tokenlonSpender;\\n\\n    constructor(address _permit2, address _tokenlonSpender) {\\n        permit2 = _permit2;\\n        tokenlonSpender = _tokenlonSpender;\\n    }\\n\\n    function _collect(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 amount,\\n        bytes calldata data\\n    ) internal {\\n        Source src = Source(uint8(data[0]));\\n\\n        if (src == Source.TokenlonSpender) {\\n            ISpender(tokenlonSpender).spendFromUser(from, token, amount);\\n            if (to != address(this)) {\\n                IERC20(token).safeTransfer(to, amount);\\n            }\\n            return;\\n        } else if (src == Source.Token) {\\n            return IERC20(token).safeTransferFrom(from, to, amount);\\n        } else if (src == Source.TokenPermit) {\\n            (bool success, bytes memory result) = token.call(abi.encodePacked(IERC20Permit.permit.selector, data[1:]));\\n            if (!success) {\\n                assembly {\\n                    revert(add(result, 32), returndatasize())\\n                }\\n            }\\n            return IERC20(token).safeTransferFrom(from, to, amount);\\n        } else if (src == Source.Permit2AllowanceTransfer) {\\n            bytes memory permit2Data = data[1:];\\n            if (permit2Data.length > 0) {\\n                (bool success, bytes memory result) = permit2.call(abi.encodePacked(IUniswapPermit2.permit.selector, permit2Data));\\n                if (!success) {\\n                    assembly {\\n                        revert(add(result, 32), returndatasize())\\n                    }\\n                }\\n            }\\n            return IUniswapPermit2(permit2).transferFrom(from, to, uint160(amount), token);\\n        } else if (src == Source.Permit2SignatureTransfer) {\\n            bytes memory permit2Data = data[1:];\\n            require(permit2Data.length != 0, \\\"empty permit2 data\\\");\\n            (uint256 nonce, uint256 deadline, bytes memory permitSig) = abi.decode(permit2Data, (uint256, uint256, bytes));\\n            IUniswapPermit2.PermitTransferFrom memory permit = IUniswapPermit2.PermitTransferFrom({\\n                permitted: IUniswapPermit2.TokenPermissions({ token: token, amount: amount }),\\n                nonce: nonce,\\n                deadline: deadline\\n            });\\n            IUniswapPermit2.SignatureTransferDetails memory detail = IUniswapPermit2.SignatureTransferDetails({ to: to, requestedAmount: amount });\\n            return IUniswapPermit2(permit2).permitTransferFrom(permit, detail, from, permitSig);\\n        }\\n\\n        // won't be reached\\n        revert();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/BaseLibEIP712.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.6;\\n\\nabstract contract BaseLibEIP712 {\\n    // EIP-191 Header\\n    string public constant EIP191_HEADER = \\\"\\\\x19\\\\x01\\\";\\n\\n    // EIP712Domain\\n    string public constant EIP712_DOMAIN_NAME = \\\"Tokenlon\\\";\\n    string public constant EIP712_DOMAIN_VERSION = \\\"v5\\\";\\n\\n    // EIP712Domain Separator\\n    bytes32 public immutable originalEIP712DomainSeparator;\\n    uint256 public immutable originalChainId;\\n\\n    constructor() {\\n        originalEIP712DomainSeparator = _buildDomainSeparator();\\n        originalChainId = getChainID();\\n    }\\n\\n    /**\\n     * @dev Return `chainId`\\n     */\\n    function getChainID() internal pure returns (uint256) {\\n        uint256 chainId;\\n        assembly {\\n            chainId := chainid()\\n        }\\n        return chainId;\\n    }\\n\\n    function _buildDomainSeparator() private view returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                    keccak256(bytes(EIP712_DOMAIN_NAME)),\\n                    keccak256(bytes(EIP712_DOMAIN_VERSION)),\\n                    getChainID(),\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    function _getDomainSeparator() private view returns (bytes32) {\\n        if (getChainID() == originalChainId) {\\n            return originalEIP712DomainSeparator;\\n        } else {\\n            return _buildDomainSeparator();\\n        }\\n    }\\n\\n    function getEIP712Hash(bytes32 structHash) internal view returns (bytes32) {\\n        return keccak256(abi.encodePacked(EIP191_HEADER, _getDomainSeparator(), structHash));\\n    }\\n\\n    function EIP712_DOMAIN_SEPARATOR() external view returns (bytes32) {\\n        return _getDomainSeparator();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/Asset.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.0;\\n\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport { SafeERC20 } from \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\n\\nimport { LibConstant } from \\\"./LibConstant.sol\\\";\\n\\nlibrary Asset {\\n    using SafeERC20 for IERC20;\\n\\n    function isETH(address addr) internal pure returns (bool) {\\n        return (addr == LibConstant.ETH_ADDRESS || addr == LibConstant.ZERO_ADDRESS);\\n    }\\n\\n    function transferTo(\\n        address asset,\\n        address payable to,\\n        uint256 amount\\n    ) internal {\\n        if (to == address(this)) {\\n            return;\\n        }\\n        if (isETH(asset)) {\\n            // @dev forward all available gas and may cause reentrancy\\n            require(address(this).balance >= amount, \\\"insufficient balance\\\");\\n            (bool success, ) = to.call{ value: amount }(\\\"\\\");\\n            require(success, \\\"unable to send ETH\\\");\\n        } else {\\n            IERC20(asset).safeTransfer(to, amount);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/Offer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.6;\\n\\nstring constant OFFER_TYPESTRING = \\\"Offer(address taker,address maker,address takerToken,uint256 takerTokenAmount,address makerToken,uint256 makerTokenAmount,uint256 feeFactor,uint256 expiry,uint256 salt)\\\";\\n\\nbytes32 constant OFFER_DATA_TYPEHASH = keccak256(bytes(OFFER_TYPESTRING));\\n\\nstruct Offer {\\n    address taker;\\n    address payable maker;\\n    address takerToken;\\n    uint256 takerTokenAmount;\\n    address makerToken;\\n    uint256 makerTokenAmount;\\n    uint256 feeFactor;\\n    uint256 expiry;\\n    uint256 salt;\\n}\\n\\n// solhint-disable-next-line func-visibility\\nfunction getOfferHash(Offer memory offer) pure returns (bytes32) {\\n    return\\n        keccak256(\\n            abi.encode(\\n                OFFER_DATA_TYPEHASH,\\n                offer.taker,\\n                offer.maker,\\n                offer.takerToken,\\n                offer.takerTokenAmount,\\n                offer.makerToken,\\n                offer.makerTokenAmount,\\n                offer.feeFactor,\\n                offer.expiry,\\n                offer.salt\\n            )\\n        );\\n}\\n\"\r\n    },\r\n    \"contracts/utils/RFQOrder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.6;\\n\\nimport { Offer, getOfferHash, OFFER_TYPESTRING } from \\\"./Offer.sol\\\";\\n\\nstring constant RFQ_ORDER_TYPESTRING = string(abi.encodePacked(\\\"RFQOrder(Offer offer,address recipient)\\\", OFFER_TYPESTRING));\\n\\nbytes32 constant RFQ_ORDER_TYPEHASH = keccak256(bytes(RFQ_ORDER_TYPESTRING));\\n\\nstruct RFQOrder {\\n    Offer offer;\\n    address payable recipient;\\n}\\n\\n// solhint-disable-next-line func-visibility\\nfunction getRFQOrderHash(RFQOrder memory rfqOrder) pure returns (bytes32 offerHash, bytes32 orderHash) {\\n    offerHash = getOfferHash(rfqOrder.offer);\\n    orderHash = keccak256(abi.encode(RFQ_ORDER_TYPEHASH, offerHash, rfqOrder.recipient));\\n}\\n\"\r\n    },\r\n    \"contracts/utils/LibConstant.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.6;\\n\\nlibrary LibConstant {\\n    int256 internal constant MAX_INT = 2**255 - 1;\\n    uint256 internal constant MAX_UINT = 2**256 - 1;\\n    uint16 internal constant BPS_MAX = 10000;\\n    address internal constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n    address internal constant ZERO_ADDRESS = address(0);\\n}\\n\"\r\n    },\r\n    \"contracts/utils/SignatureValidator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.6;\\n\\nimport \\\"../interfaces/IERC1271Wallet.sol\\\";\\nimport \\\"./LibBytes.sol\\\";\\n\\ninterface IWallet {\\n    /// @dev Verifies that a signature is valid.\\n    /// @param hash Message hash that is signed.\\n    /// @param signature Proof of signing.\\n    /// @return isValid Validity of order signature.\\n    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bool isValid);\\n}\\n\\n/**\\n * @dev Contains logic for signature validation.\\n * Signatures from wallet contracts assume ERC-1271 support (https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1271.md)\\n * Notes: Methods are strongly inspired by contracts in https://github.com/0xProject/0x-monorepo/blob/development/\\n */\\ncontract SignatureValidator {\\n    using LibBytes for bytes;\\n\\n    /***********************************|\\n  |             Variables             |\\n  |__________________________________*/\\n\\n    // bytes4(keccak256(\\\"isValidSignature(bytes,bytes)\\\"))\\n    bytes4 internal constant ERC1271_MAGICVALUE = 0x20c13b0b;\\n\\n    // bytes4(keccak256(\\\"isValidSignature(bytes32,bytes)\\\"))\\n    bytes4 internal constant ERC1271_MAGICVALUE_BYTES32 = 0x1626ba7e;\\n\\n    // Allowed signature types.\\n    enum SignatureType {\\n        Illegal, // 0x00, default value\\n        Invalid, // 0x01\\n        EIP712, // 0x02\\n        EthSign, // 0x03\\n        WalletBytes, // 0x04  standard 1271 wallet type\\n        WalletBytes32, // 0x05  standard 1271 wallet type\\n        Wallet, // 0x06  0x wallet type for signature compatibility\\n        NSignatureTypes // 0x07, number of signature types. Always leave at end.\\n    }\\n\\n    /***********************************|\\n  |        Signature Functions        |\\n  |__________________________________*/\\n\\n    /**\\n     * @dev Verifies that a hash has been signed by the given signer.\\n     * @param _signerAddress  Address that should have signed the given hash.\\n     * @param _hash           Hash of the EIP-712 encoded data\\n     * @param _data           Full EIP-712 data structure that was hashed and signed\\n     * @param _sig            Proof that the hash has been signed by signer.\\n     *      For non wallet signatures, _sig is expected to be an array tightly encoded as\\n     *      (bytes32 r, bytes32 s, uint8 v, uint256 nonce, SignatureType sigType)\\n     * @return isValid True if the address recovered from the provided signature matches the input signer address.\\n     */\\n    function isValidSignature(\\n        address _signerAddress,\\n        bytes32 _hash,\\n        bytes memory _data,\\n        bytes memory _sig\\n    ) public view returns (bool isValid) {\\n        require(_sig.length > 0, \\\"SignatureValidator#isValidSignature: length greater than 0 required\\\");\\n\\n        require(_signerAddress != address(0x0), \\\"SignatureValidator#isValidSignature: invalid signer\\\");\\n\\n        // Pop last byte off of signature byte array.\\n        uint8 signatureTypeRaw = uint8(_sig.popLastByte());\\n\\n        // Ensure signature is supported\\n        require(signatureTypeRaw < uint8(SignatureType.NSignatureTypes), \\\"SignatureValidator#isValidSignature: unsupported signature\\\");\\n\\n        // Extract signature type\\n        SignatureType signatureType = SignatureType(signatureTypeRaw);\\n\\n        // Variables are not scoped in Solidity.\\n        uint8 v;\\n        bytes32 r;\\n        bytes32 s;\\n        address recovered;\\n\\n        // Always illegal signature.\\n        // This is always an implicit option since a signer can create a\\n        // signature array with invalid type or length. We may as well make\\n        // it an explicit option. This aids testing and analysis. It is\\n        // also the initialization value for the enum type.\\n        if (signatureType == SignatureType.Illegal) {\\n            revert(\\\"SignatureValidator#isValidSignature: illegal signature\\\");\\n\\n            // Signature using EIP712\\n        } else if (signatureType == SignatureType.EIP712) {\\n            require(_sig.length == 65 || _sig.length == 97, \\\"SignatureValidator#isValidSignature: length 65 or 97 required\\\");\\n            r = _sig.readBytes32(0);\\n            s = _sig.readBytes32(32);\\n            v = uint8(_sig[64]);\\n            recovered = ecrecover(_hash, v, r, s);\\n            isValid = _signerAddress == recovered;\\n            return isValid;\\n\\n            // Signed using web3.eth_sign() or Ethers wallet.signMessage()\\n        } else if (signatureType == SignatureType.EthSign) {\\n            require(_sig.length == 65 || _sig.length == 97, \\\"SignatureValidator#isValidSignature: length 65 or 97 required\\\");\\n            r = _sig.readBytes32(0);\\n            s = _sig.readBytes32(32);\\n            v = uint8(_sig[64]);\\n            recovered = ecrecover(keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", _hash)), v, r, s);\\n            isValid = _signerAddress == recovered;\\n            return isValid;\\n\\n            // Signature verified by wallet contract with data validation.\\n        } else if (signatureType == SignatureType.WalletBytes) {\\n            isValid = ERC1271_MAGICVALUE == IERC1271Wallet(_signerAddress).isValidSignature(_data, _sig);\\n            return isValid;\\n\\n            // Signature verified by wallet contract without data validation.\\n        } else if (signatureType == SignatureType.WalletBytes32) {\\n            isValid = ERC1271_MAGICVALUE_BYTES32 == IERC1271Wallet(_signerAddress).isValidSignature(_hash, _sig);\\n            return isValid;\\n        } else if (signatureType == SignatureType.Wallet) {\\n            isValid = isValidWalletSignature(_hash, _signerAddress, _sig);\\n            return isValid;\\n        }\\n\\n        // Anything else is illegal (We do not return false because\\n        // the signature may actually be valid, just not in a format\\n        // that we currently support. In this case returning false\\n        // may lead the caller to incorrectly believe that the\\n        // signature was invalid.)\\n        revert(\\\"SignatureValidator#isValidSignature: unsupported signature\\\");\\n    }\\n\\n    /// @dev Verifies signature using logic defined by Wallet contract.\\n    /// @param hash Any 32 byte hash.\\n    /// @param walletAddress Address that should have signed the given hash\\n    ///                      and defines its own signature verification method.\\n    /// @param signature Proof that the hash has been signed by signer.\\n    /// @return isValid True if signature is valid for given wallet..\\n    function isValidWalletSignature(\\n        bytes32 hash,\\n        address walletAddress,\\n        bytes memory signature\\n    ) internal view returns (bool isValid) {\\n        bytes memory _calldata = abi.encodeWithSelector(IWallet(walletAddress).isValidSignature.selector, hash, signature);\\n        bytes32 magic_salt = bytes32(bytes4(keccak256(\\\"isValidWalletSignature(bytes32,address,bytes)\\\")));\\n        assembly {\\n            if iszero(extcodesize(walletAddress)) {\\n                // Revert with `Error(\\\"WALLET_ERROR\\\")`\\n                mstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\\n                mstore(32, 0x0000002000000000000000000000000000000000000000000000000000000000)\\n                mstore(64, 0x0000000c57414c4c45545f4552524f5200000000000000000000000000000000)\\n                mstore(96, 0)\\n                revert(0, 100)\\n            }\\n\\n            let cdStart := add(_calldata, 32)\\n            let success := staticcall(\\n                gas(), // forward all gas\\n                walletAddress, // address of Wallet contract\\n                cdStart, // pointer to start of input\\n                mload(_calldata), // length of input\\n                cdStart, // write output over input\\n                32 // output size is 32 bytes\\n            )\\n\\n            if iszero(eq(returndatasize(), 32)) {\\n                // Revert with `Error(\\\"WALLET_ERROR\\\")`\\n                mstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\\n                mstore(32, 0x0000002000000000000000000000000000000000000000000000000000000000)\\n                mstore(64, 0x0000000c57414c4c45545f4552524f5200000000000000000000000000000000)\\n                mstore(96, 0)\\n                revert(0, 100)\\n            }\\n\\n            switch success\\n            case 0 {\\n                // Revert with `Error(\\\"WALLET_ERROR\\\")`\\n                mstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\\n                mstore(32, 0x0000002000000000000000000000000000000000000000000000000000000000)\\n                mstore(64, 0x0000000c57414c4c45545f4552524f5200000000000000000000000000000000)\\n                mstore(96, 0)\\n                revert(0, 100)\\n            }\\n            case 1 {\\n                // Signature is valid if call did not revert and returned true\\n                isValid := eq(\\n                    and(mload(cdStart), 0xffffffff00000000000000000000000000000000000000000000000000000000),\\n                    and(magic_salt, 0xffffffff00000000000000000000000000000000000000000000000000000000)\\n                )\\n            }\\n        }\\n        return isValid;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/StrategyBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\n\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./LibConstant.sol\\\";\\nimport \\\"../interfaces/IWETH.sol\\\";\\nimport \\\"../interfaces/IStrategyBase.sol\\\";\\nimport \\\"../interfaces/ISpender.sol\\\";\\nimport \\\"../interfaces/IPermanentStorage.sol\\\";\\n\\n/// @title StrategyBase Abstract Contract\\n/// @author imToken Labs\\n/// @dev This contract is shared by every Tokenlon strategy contracts\\nabstract contract StrategyBase is IStrategyBase, Ownable {\\n    using SafeERC20 for IERC20;\\n\\n    address public immutable userProxy;\\n    IWETH public immutable weth;\\n    IPermanentStorage public immutable permStorage;\\n    ISpender public spender;\\n\\n    constructor(\\n        address _owner,\\n        address _userProxy,\\n        address _weth,\\n        address _permStorage,\\n        address _spender\\n    ) Ownable(_owner) {\\n        userProxy = _userProxy;\\n        weth = IWETH(_weth);\\n        permStorage = IPermanentStorage(_permStorage);\\n        spender = ISpender(_spender);\\n    }\\n\\n    modifier onlyUserProxy() {\\n        require(address(userProxy) == msg.sender, \\\"Strategy: not from UserProxy contract\\\");\\n        _;\\n    }\\n\\n    /// @inheritdoc IStrategyBase\\n    function upgradeSpender(address _newSpender) external override onlyOwner {\\n        require(_newSpender != address(0), \\\"Strategy: spender can not be zero address\\\");\\n        spender = ISpender(_newSpender);\\n\\n        emit UpgradeSpender(_newSpender);\\n    }\\n\\n    /// @inheritdoc IStrategyBase\\n    function setAllowance(address[] calldata _tokenList, address _spender) external override onlyOwner {\\n        for (uint256 i = 0; i < _tokenList.length; ++i) {\\n            IERC20(_tokenList[i]).safeApprove(_spender, LibConstant.MAX_UINT);\\n\\n            emit AllowTransfer(_spender, _tokenList[i]);\\n        }\\n    }\\n\\n    /// @inheritdoc IStrategyBase\\n    function closeAllowance(address[] calldata _tokenList, address _spender) external override onlyOwner {\\n        for (uint256 i = 0; i < _tokenList.length; ++i) {\\n            IERC20(_tokenList[i]).safeApprove(_spender, 0);\\n\\n            emit DisallowTransfer(_spender, _tokenList[i]);\\n        }\\n    }\\n\\n    /// @inheritdoc IStrategyBase\\n    function depositETH() external override onlyOwner {\\n        uint256 balance = address(this).balance;\\n        if (balance > 0) {\\n            weth.deposit{ value: balance }();\\n\\n            emit DepositETH(balance);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IRFQv2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.0;\\npragma abicoder v2;\\n\\nimport { RFQOrder } from \\\"../utils/RFQOrder.sol\\\";\\n\\n/// @title IRFQv2 Interface\\n/// @author imToken Labs\\ninterface IRFQv2 {\\n    /// @notice Emitted when an order is settled\\n    /// @param offerHash The hash of the offer to be filled\\n    /// @param user The address of the user\\n    /// @param maker The address of the offer maker\\n    /// @param takerToken The address of taker token\\n    /// @param takerTokenAmount The amount of taker token\\n    /// @param makerToken The address of maker token\\n    /// @param makerTokenAmount The amount of maker token\\n    /// @param recipient The address of recipient that will receive the maker token\\n    /// @param settleAmount The actual amount that recipient will receive (after fee, if any)\\n    /// @param feeFactor The fee factor of this settlement\\n    event FilledRFQ(\\n        bytes32 indexed offerHash,\\n        address indexed user,\\n        address indexed maker,\\n        address takerToken,\\n        uint256 takerTokenAmount,\\n        address makerToken,\\n        uint256 makerTokenAmount,\\n        address recipient,\\n        uint256 settleAmount,\\n        uint256 feeFactor\\n    );\\n\\n    /// @notice Settle a RFQ order\\n    /// @notice Signature from maker and user should be both provided\\n    /// @param rfqOrder The order that is going to be filled\\n    /// @param makerSignature The signature of the offer\\n    /// @param makerTokenPermit The token permit data of the maker\\n    /// @param takerSignature The signature of the whole order\\n    /// @param takerTokenPermit The token permit data of the taker\\n    function fillRFQ(\\n        RFQOrder calldata rfqOrder,\\n        bytes calldata makerSignature,\\n        bytes calldata makerTokenPermit,\\n        bytes calldata takerSignature,\\n        bytes calldata takerTokenPermit\\n    ) external payable;\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\\"SafeERC20: decreased allowance below zero\\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) { // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IUniswapPermit2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.0;\\npragma abicoder v2;\\n\\ninterface IUniswapPermit2 {\\n    /*\\n     * Allowance Transfer\\n     */\\n\\n    /// @notice The permit data for a token\\n    struct PermitDetails {\\n        // ERC20 token address\\n        address token;\\n        // the maximum amount allowed to spend\\n        uint160 amount;\\n        // timestamp at which a spender's token allowances become invalid\\n        uint48 expiration;\\n        // an incrementing value indexed per owner,token,and spender for each signature\\n        uint48 nonce;\\n    }\\n\\n    /// @notice The permit message signed for a single token allownce\\n    struct PermitSingle {\\n        // the permit data for a single token alownce\\n        PermitDetails details;\\n        // address permissioned on the allowed tokens\\n        address spender;\\n        // deadline on the permit signature\\n        uint256 sigDeadline;\\n    }\\n\\n    /// @notice Returns the domain separator for the current chain.\\n    /// @dev Uses cached version if chainid and address are unchanged from construction.\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n\\n    /// @notice A mapping from owner address to token address to spender address to PackedAllowance struct, which contains details and conditions of the approval.\\n    /// @notice The mapping is indexed in the above order see: allowance[ownerAddress][tokenAddress][spenderAddress]\\n    /// @dev The packed slot holds the allowed amount, expiration at which the allowed amount is no longer valid, and current nonce thats updated on any signature based approvals.\\n    function allowance(\\n        address user,\\n        address token,\\n        address spender\\n    )\\n        external\\n        view\\n        returns (\\n            uint160 amount,\\n            uint48 expiration,\\n            uint48 nonce\\n        );\\n\\n    /// @notice Permit a spender to a given amount of the owners token via the owner's EIP-712 signature\\n    /// @dev May fail if the owner's nonce was invalidated in-flight by invalidateNonce\\n    /// @param owner The owner of the tokens being approved\\n    /// @param permitSingle Data signed over by the owner specifying the terms of approval\\n    /// @param signature The owner's signature over the permit data\\n    function permit(\\n        address owner,\\n        PermitSingle memory permitSingle,\\n        bytes calldata signature\\n    ) external;\\n\\n    /// @notice Transfer approved tokens from one address to another\\n    /// @param from The address to transfer from\\n    /// @param to The address of the recipient\\n    /// @param amount The amount of the token to transfer\\n    /// @param token The token address to transfer\\n    /// @dev Requires the from address to have approved at least the desired amount\\n    /// of tokens to msg.sender.\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint160 amount,\\n        address token\\n    ) external;\\n\\n    /// @notice Approves the spender to use up to amount of the specified token up until the expiration\\n    /// @param token The token to approve\\n    /// @param spender The spender address to approve\\n    /// @param amount The approved amount of the token\\n    /// @param expiration The timestamp at which the approval is no longer valid\\n    /// @dev The packed allowance also holds a nonce, which will stay unchanged in approve\\n    /// @dev Setting amount to type(uint160).max sets an unlimited approval\\n    function approve(\\n        address token,\\n        address spender,\\n        uint160 amount,\\n        uint48 expiration\\n    ) external;\\n\\n    /*\\n     * Signature Transfer\\n     */\\n\\n    /// @notice The token and amount details for a transfer signed in the permit transfer signature\\n    struct TokenPermissions {\\n        // ERC20 token address\\n        address token;\\n        // the maximum amount that can be spent\\n        uint256 amount;\\n    }\\n\\n    /// @notice The signed permit message for a single token transfer\\n    struct PermitTransferFrom {\\n        TokenPermissions permitted;\\n        // a unique value for every token owner's signature to prevent signature replays\\n        uint256 nonce;\\n        // deadline on the permit signature\\n        uint256 deadline;\\n    }\\n\\n    /// @notice Specifies the recipient address and amount for batched transfers.\\n    /// @dev Recipients and amounts correspond to the index of the signed token permissions array.\\n    /// @dev Reverts if the requested amount is greater than the permitted signed amount.\\n    struct SignatureTransferDetails {\\n        // recipient address\\n        address to;\\n        // spender requested amount\\n        uint256 requestedAmount;\\n    }\\n\\n    /// @notice Transfers a token using a signed permit message\\n    /// @dev Reverts if the requested amount is greater than the permitted signed amount\\n    /// @param permit The permit data signed over by the owner\\n    /// @param owner The owner of the tokens to transfer\\n    /// @param transferDetails The spender's requested transfer details for the permitted token\\n    /// @param signature The signature to verify\\n    function permitTransferFrom(\\n        PermitTransferFrom memory permit,\\n        SignatureTransferDetails calldata transferDetails,\\n        address owner,\\n        bytes calldata signature\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ISpender.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.0;\\n\\ninterface ISpender {\\n    // System events\\n    event TimeLockActivated(uint256 activatedTimeStamp);\\n    // Owner events\\n    event SetAllowanceTarget(address allowanceTarget);\\n    event SetNewSpender(address newSpender);\\n    event SetConsumeGasERC20Token(address token);\\n    event TearDownAllowanceTarget(uint256 tearDownTimeStamp);\\n    event BlackListToken(address token, bool isBlacklisted);\\n    event AuthorizeSpender(address spender, bool isAuthorized);\\n\\n    function spendFromUser(\\n        address _user,\\n        address _tokenAddr,\\n        uint256 _amount\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.0;\\n\\ninterface IERC20Permit {\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC1271Wallet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.0;\\n\\ninterface IERC1271Wallet {\\n    /**\\n     * @notice Verifies whether the provided signature is valid with respect to the provided data\\n     * @dev MUST return the correct magic value if the signature provided is valid for the provided data\\n     *   > The bytes4 magic value to return when signature is valid is 0x20c13b0b : bytes4(keccak256(\\\"isValidSignature(bytes,bytes)\\\")\\n     *   > This function MAY modify Ethereum's state\\n     * @param _data       Arbitrary length data signed on the behalf of address(this)\\n     * @param _signature  Signature byte array associated with _data\\n     * @return magicValue Magic value 0x20c13b0b if the signature is valid and 0x0 otherwise\\n     *\\n     */\\n    function isValidSignature(bytes calldata _data, bytes calldata _signature) external view returns (bytes4 magicValue);\\n\\n    /**\\n     * @notice Verifies whether the provided signature is valid with respect to the provided hash\\n     * @dev MUST return the correct magic value if the signature provided is valid for the provided hash\\n     *   > The bytes4 magic value to return when signature is valid is 0x20c13b0b : bytes4(keccak256(\\\"isValidSignature(bytes,bytes)\\\")\\n     *   > This function MAY modify Ethereum's state\\n     * @param _hash       keccak256 hash that was signed\\n     * @param _signature  Signature byte array associated with _data\\n     * @return magicValue Magic value 0x20c13b0b if the signature is valid and 0x0 otherwise\\n     */\\n    function isValidSignature(bytes32 _hash, bytes calldata _signature) external view returns (bytes4 magicValue);\\n}\\n\"\r\n    },\r\n    \"contracts/utils/LibBytes.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2018 ZeroEx Intl.\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n  you may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n  http://www.apache.org/licenses/LICENSE-2.0\\n  Unless required by applicable law or agreed to in writing, software\\n  distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions and\\n  limitations under the License.\\n  This is a truncated version of the original LibBytes.sol library from ZeroEx.\\n*/\\n// SPDX-License-Identifier: Apache-2.0\\n\\npragma solidity ^0.7.6;\\n\\nlibrary LibBytes {\\n    using LibBytes for bytes;\\n\\n    /***********************************|\\n  |        Pop Bytes Functions        |\\n  |__________________________________*/\\n\\n    /**\\n     * @dev Pops the last byte off of a byte array by modifying its length.\\n     * @param b Byte array that will be modified.\\n     * @return result The byte that was popped off.\\n     */\\n    function popLastByte(bytes memory b) internal pure returns (bytes1 result) {\\n        require(b.length > 0, \\\"LibBytes#popLastByte: greater than zero length required\\\");\\n\\n        // Store last byte.\\n        result = b[b.length - 1];\\n\\n        assembly {\\n            // Decrement length of byte array.\\n            let newLen := sub(mload(b), 1)\\n            mstore(b, newLen)\\n        }\\n        return result;\\n    }\\n\\n    /// @dev Reads an address from a position in a byte array.\\n    /// @param b Byte array containing an address.\\n    /// @param index Index in byte array of address.\\n    /// @return result address from byte array.\\n    function readAddress(bytes memory b, uint256 index) internal pure returns (address result) {\\n        require(\\n            b.length >= index + 20, // 20 is length of address\\n            \\\"LibBytes#readAddress greater or equal to 20 length required\\\"\\n        );\\n\\n        // Add offset to index:\\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\\n        index += 20;\\n\\n        // Read address from array memory\\n        assembly {\\n            // 1. Add index to address of bytes array\\n            // 2. Load 32-byte word from memory\\n            // 3. Apply 20-byte mask to obtain address\\n            result := and(mload(add(b, index)), 0xffffffffffffffffffffffffffffffffffffffff)\\n        }\\n        return result;\\n    }\\n\\n    /***********************************|\\n  |        Read Bytes Functions       |\\n  |__________________________________*/\\n\\n    /**\\n     * @dev Reads a bytes32 value from a position in a byte array.\\n     * @param b Byte array containing a bytes32 value.\\n     * @param index Index in byte array of bytes32 value.\\n     * @return result bytes32 value from byte array.\\n     */\\n    function readBytes32(bytes memory b, uint256 index) internal pure returns (bytes32 result) {\\n        require(b.length >= index + 32, \\\"LibBytes#readBytes32 greater or equal to 32 length required\\\");\\n\\n        // Arrays are prefixed by a 256 bit length parameter\\n        index += 32;\\n\\n        // Read the bytes32 from array memory\\n        assembly {\\n            result := mload(add(b, index))\\n        }\\n        return result;\\n    }\\n\\n    /// @dev Reads an unpadded bytes4 value from a position in a byte array.\\n    /// @param b Byte array containing a bytes4 value.\\n    /// @param index Index in byte array of bytes4 value.\\n    /// @return result bytes4 value from byte array.\\n    function readBytes4(bytes memory b, uint256 index) internal pure returns (bytes4 result) {\\n        require(b.length >= index + 4, \\\"LibBytes#readBytes4 greater or equal to 4 length required\\\");\\n\\n        // Arrays are prefixed by a 32 byte length field\\n        index += 32;\\n\\n        // Read the bytes4 from array memory\\n        assembly {\\n            result := mload(add(b, index))\\n            // Solidity does not require us to clean the trailing bytes.\\n            // We do it anyway\\n            result := and(result, 0xFFFFFFFF00000000000000000000000000000000000000000000000000000000)\\n        }\\n        return result;\\n    }\\n\\n    function readBytes2(bytes memory b, uint256 index) internal pure returns (bytes2 result) {\\n        require(b.length >= index + 2, \\\"LibBytes#readBytes2 greater or equal to 2 length required\\\");\\n\\n        // Arrays are prefixed by a 32 byte length field\\n        index += 32;\\n\\n        // Read the bytes4 from array memory\\n        assembly {\\n            result := mload(add(b, index))\\n            // Solidity does not require us to clean the trailing bytes.\\n            // We do it anyway\\n            result := and(result, 0xFFFF000000000000000000000000000000000000000000000000000000000000)\\n        }\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.6;\\n\\n/// @title Ownable Contract\\n/// @author imToken Labs\\nabstract contract Ownable {\\n    address public owner;\\n    address public nominatedOwner;\\n\\n    event OwnerNominated(address indexed newOwner);\\n    event OwnerChanged(address indexed oldOwner, address indexed newOwner);\\n\\n    constructor(address _owner) {\\n        require(_owner != address(0), \\\"owner should not be 0\\\");\\n        owner = _owner;\\n    }\\n\\n    modifier onlyOwner() {\\n        require(msg.sender == owner, \\\"not owner\\\");\\n        _;\\n    }\\n\\n    /// @notice Activate new ownership\\n    /// @notice Only nominated owner can call\\n    function acceptOwnership() external {\\n        require(msg.sender == nominatedOwner, \\\"not nominated\\\");\\n        emit OwnerChanged(owner, nominatedOwner);\\n\\n        owner = nominatedOwner;\\n        nominatedOwner = address(0);\\n    }\\n\\n    /// @notice Give up the ownership\\n    /// @notice Only owner can call\\n    /// @notice Ownership cannot be recovered\\n    function renounceOwnership() external onlyOwner {\\n        require(nominatedOwner == address(0), \\\"pending nomination exists\\\");\\n        emit OwnerChanged(owner, address(0));\\n        owner = address(0);\\n    }\\n\\n    /// @notice Nominate new owner\\n    /// @notice Only owner can call\\n    /// @param newOwner The address of the new owner\\n    function nominateNewOwner(address newOwner) external onlyOwner {\\n        nominatedOwner = newOwner;\\n        emit OwnerNominated(newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IWETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.0;\\n\\ninterface IWETH {\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function deposit() external payable;\\n\\n    function withdraw(uint256 amount) external;\\n\\n    function transfer(address dst, uint256 wad) external returns (bool);\\n\\n    function transferFrom(\\n        address src,\\n        address dst,\\n        uint256 wad\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IStrategyBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.0;\\n\\n/// @title IStrategyBase Interface\\n/// @author imToken Labs\\ninterface IStrategyBase {\\n    /// @notice Emitted when Tokenlon spender address is updated\\n    /// @param newSpender The address of the new Tokenlon spender\\n    event UpgradeSpender(address newSpender);\\n\\n    /// @notice Emitted when allowing another account to spend assets\\n    /// @param spender The address that is allowed to transfer tokens\\n    event AllowTransfer(address indexed spender, address token);\\n\\n    /// @notice Emitted when disallowing an account to spend assets\\n    /// @param spender The address that is removed from allow list\\n    event DisallowTransfer(address indexed spender, address token);\\n\\n    /// @notice Emitted when ETH converted to WETH\\n    /// @param amount The amount of converted ETH\\n    event DepositETH(uint256 amount);\\n\\n    /// @notice Update the address of Tokenlon spender\\n    /// @notice Only owner can call\\n    /// @param _newSpender The address of the new spender\\n    function upgradeSpender(address _newSpender) external;\\n\\n    /// @notice Set allowance of tokens to an address\\n    /// @notice Only owner can call\\n    /// @param _tokenList The list of tokens\\n    /// @param _spender The address that will be allowed\\n    function setAllowance(address[] calldata _tokenList, address _spender) external;\\n\\n    /// @notice Clear allowance of tokens to an address\\n    /// @notice Only owner can call\\n    /// @param _tokenList The list of tokens\\n    /// @param _spender The address that will be cleared\\n    function closeAllowance(address[] calldata _tokenList, address _spender) external;\\n\\n    /// @notice Convert ETH in this contract to WETH\\n    /// @notice Only owner can call\\n    function depositETH() external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPermanentStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.0;\\n\\ninterface IPermanentStorage {\\n    // Operator events\\n    event OperatorNominated(address indexed newOperator);\\n    event OperatorChanged(address indexed oldOperator, address indexed newOperator);\\n    event SetPermission(bytes32 storageId, address role, bool enabled);\\n    event UpgradeAMMWrapper(address newAMMWrapper);\\n    event UpgradePMM(address newPMM);\\n    event UpgradeRFQ(address newRFQ);\\n    event UpgradeRFQv2(address newRFQv2);\\n    event UpgradeLimitOrder(address newLimitOrder);\\n    event UpgradeWETH(address newWETH);\\n    event SetCurvePoolInfo(address makerAddr, address[] underlyingCoins, address[] coins, bool supportGetD);\\n    event SetRelayerValid(address relayer, bool valid);\\n\\n    function hasPermission(bytes32 _storageId, address _role) external view returns (bool);\\n\\n    function ammWrapperAddr() external view returns (address);\\n\\n    function pmmAddr() external view returns (address);\\n\\n    function rfqAddr() external view returns (address);\\n\\n    function rfqv2Addr() external view returns (address);\\n\\n    function limitOrderAddr() external view returns (address);\\n\\n    function wethAddr() external view returns (address);\\n\\n    function getCurvePoolInfo(\\n        address _makerAddr,\\n        address _takerAssetAddr,\\n        address _makerAssetAddr\\n    )\\n        external\\n        view\\n        returns (\\n            int128 takerAssetIndex,\\n            int128 makerAssetIndex,\\n            uint16 swapMethod,\\n            bool supportGetDx\\n        );\\n\\n    function setCurvePoolInfo(\\n        address _makerAddr,\\n        address[] calldata _underlyingCoins,\\n        address[] calldata _coins,\\n        bool _supportGetDx\\n    ) external;\\n\\n    function isAMMTransactionSeen(bytes32 _transactionHash) external view returns (bool);\\n\\n    function isRFQTransactionSeen(bytes32 _transactionHash) external view returns (bool);\\n\\n    function isRFQOfferFilled(bytes32 _offerHash) external view returns (bool);\\n\\n    function isLimitOrderTransactionSeen(bytes32 _transactionHash) external view returns (bool);\\n\\n    function isLimitOrderAllowFillSeen(bytes32 _allowFillHash) external view returns (bool);\\n\\n    function isRelayerValid(address _relayer) external view returns (bool);\\n\\n    function setAMMTransactionSeen(bytes32 _transactionHash) external;\\n\\n    function setRFQTransactionSeen(bytes32 _transactionHash) external;\\n\\n    function setRFQOfferFilled(bytes32 _offerHash) external;\\n\\n    function setLimitOrderTransactionSeen(bytes32 _transactionHash) external;\\n\\n    function setLimitOrderAllowFillSeen(bytes32 _allowFillHash) external;\\n\\n    function setRelayersValid(address[] memory _relayers, bool[] memory _isValids) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@openzeppelin/=lib/openzeppelin-contracts/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/contracts/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_userProxy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_weth\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_permStorage\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_uniswapPermit2\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_feeCollector\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"AllowTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DepositETH\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"DisallowTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"offerHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"maker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"takerToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"takerTokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"makerToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"makerTokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"settleAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"feeFactor\",\"type\":\"uint256\"}],\"name\":\"FilledRFQ\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerNominated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newFeeCollector\",\"type\":\"address\"}],\"name\":\"SetFeeCollector\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newSpender\",\"type\":\"address\"}],\"name\":\"UpgradeSpender\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"EIP191_HEADER\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"EIP712_DOMAIN_NAME\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"EIP712_DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"EIP712_DOMAIN_VERSION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_tokenList\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"closeAllowance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeCollector\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"taker\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"maker\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"takerToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"takerTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"makerToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"makerTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feeFactor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"}],\"internalType\":\"struct Offer\",\"name\":\"offer\",\"type\":\"tuple\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"internalType\":\"struct RFQOrder\",\"name\":\"order\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"makerSignature\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"makerTokenPermit\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"takerSignature\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"takerTokenPermit\",\"type\":\"bytes\"}],\"name\":\"fillRFQ\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_signerAddress\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_hash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_sig\",\"type\":\"bytes\"}],\"name\":\"isValidSignature\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isValid\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"nominateNewOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nominatedOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"originalChainId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"originalEIP712DomainSeparator\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"permStorage\",\"outputs\":[{\"internalType\":\"contract IPermanentStorage\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"permit2\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_tokenList\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"setAllowance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_newFeeCollector\",\"type\":\"address\"}],\"name\":\"setFeeCollector\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"spender\",\"outputs\":[{\"internalType\":\"contract ISpender\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenlonSpender\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newSpender\",\"type\":\"address\"}],\"name\":\"upgradeSpender\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"userProxy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"weth\",\"outputs\":[{\"internalType\":\"contract IWETH\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "RFQv2", "CompilerVersion": "v0.7.6+commit.7338295f", "OptimizationUsed": "1", "Runs": "1000", "ConstructorArguments": "00000000000000000000000063ef071b8a69c52a88dca4a844286aeff195129f00000000000000000000000003f34be1bf910116595db1b11e9d1b2ca5d59659000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc20000000000000000000000006d9cc14a1d36e6ff13fc6efa9e9326fcd12e79030000000000000000000000003c68dfc45dc92c9c605d92b49858073e10b857a6000000000000000000000000000000000022d473030f116ddee9f6b43ac78ba300000000000000000000000091c986709bb4fe0763edf8e2690ee9d5019bea4a", "EVMVersion": "istanbul", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}