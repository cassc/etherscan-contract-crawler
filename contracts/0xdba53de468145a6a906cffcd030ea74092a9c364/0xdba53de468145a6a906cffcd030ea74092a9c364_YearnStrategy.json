{"SourceCode": "// SPDX-License-Identifier: GPL-3.0\r\npragma solidity 0.8.19;\r\n\r\n/// @notice Simple ERC20 + EIP-2612 implementation.\r\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/tokens/ERC20.sol)\r\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\r\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol)\r\n///\r\n/// @dev Note:\r\n/// - The ERC20 standard allows minting and transferring to and from the zero address,\r\n///   minting and transferring zero tokens, as well as self-approvals.\r\n///   For performance, this implementation WILL NOT revert for such actions.\r\n///   Please add any checks with overrides if desired.\r\n/// - The `permit` function uses the ecrecover precompile (0x1).\r\n///\r\n/// If you are overriding:\r\n/// - NEVER violate the ERC20 invariant:\r\n///   the total sum of all balances must be equal to `totalSupply()`.\r\n/// - Check that the overridden function is actually used in the function you want to\r\n///   change the behavior of. Much of the code has been manually inlined for performance.\r\nabstract contract ERC20 {\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                       CUSTOM ERRORS                        */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev The total supply has overflowed.\r\n    error TotalSupplyOverflow();\r\n\r\n    /// @dev The allowance has overflowed.\r\n    error AllowanceOverflow();\r\n\r\n    /// @dev The allowance has underflowed.\r\n    error AllowanceUnderflow();\r\n\r\n    /// @dev Insufficient balance.\r\n    error InsufficientBalance();\r\n\r\n    /// @dev Insufficient allowance.\r\n    error InsufficientAllowance();\r\n\r\n    /// @dev The permit is invalid.\r\n    error InvalidPermit();\r\n\r\n    /// @dev The permit has expired.\r\n    error PermitExpired();\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                           EVENTS                           */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev Emitted when `amount` tokens is transferred from `from` to `to`.\r\n    event Transfer(address indexed from, address indexed to, uint256 amount);\r\n\r\n    /// @dev Emitted when `amount` tokens is approved by `owner` to be used by `spender`.\r\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\r\n\r\n    /// @dev `keccak256(bytes(\"Transfer(address,address,uint256)\"))`.\r\n    uint256 private constant _TRANSFER_EVENT_SIGNATURE =\r\n        0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef;\r\n\r\n    /// @dev `keccak256(bytes(\"Approval(address,address,uint256)\"))`.\r\n    uint256 private constant _APPROVAL_EVENT_SIGNATURE =\r\n        0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925;\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                          STORAGE                           */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev The storage slot for the total supply.\r\n    uint256 private constant _TOTAL_SUPPLY_SLOT = 0x05345cdf77eb68f44c;\r\n\r\n    /// @dev The balance slot of `owner` is given by:\r\n    /// ```\r\n    ///     mstore(0x0c, _BALANCE_SLOT_SEED)\r\n    ///     mstore(0x00, owner)\r\n    ///     let balanceSlot := keccak256(0x0c, 0x20)\r\n    /// ```\r\n    uint256 private constant _BALANCE_SLOT_SEED = 0x87a211a2;\r\n\r\n    /// @dev The allowance slot of (`owner`, `spender`) is given by:\r\n    /// ```\r\n    ///     mstore(0x20, spender)\r\n    ///     mstore(0x0c, _ALLOWANCE_SLOT_SEED)\r\n    ///     mstore(0x00, owner)\r\n    ///     let allowanceSlot := keccak256(0x0c, 0x34)\r\n    /// ```\r\n    uint256 private constant _ALLOWANCE_SLOT_SEED = 0x7f5e9f20;\r\n\r\n    /// @dev The nonce slot of `owner` is given by:\r\n    /// ```\r\n    ///     mstore(0x0c, _NONCES_SLOT_SEED)\r\n    ///     mstore(0x00, owner)\r\n    ///     let nonceSlot := keccak256(0x0c, 0x20)\r\n    /// ```\r\n    uint256 private constant _NONCES_SLOT_SEED = 0x38377508;\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                         CONSTANTS                          */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev `(_NONCES_SLOT_SEED << 16) | 0x1901`.\r\n    uint256 private constant _NONCES_SLOT_SEED_WITH_SIGNATURE_PREFIX = 0x383775081901;\r\n\r\n    /// @dev `keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\")`.\r\n    bytes32 private constant _DOMAIN_TYPEHASH =\r\n        0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;\r\n\r\n    /// @dev `keccak256(\"1\")`.\r\n    bytes32 private constant _VERSION_HASH =\r\n        0xc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc6;\r\n\r\n    /// @dev `keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\")`.\r\n    bytes32 private constant _PERMIT_TYPEHASH =\r\n        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                       ERC20 METADATA                       */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev Returns the name of the token.\r\n    function name() public view virtual returns (string memory);\r\n\r\n    /// @dev Returns the symbol of the token.\r\n    function symbol() public view virtual returns (string memory);\r\n\r\n    /// @dev Returns the decimals places of the token.\r\n    function decimals() public view virtual returns (uint8) {\r\n        return 18;\r\n    }\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                           ERC20                            */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev Returns the amount of tokens in existence.\r\n    function totalSupply() public view virtual returns (uint256 result) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            result := sload(_TOTAL_SUPPLY_SLOT)\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the amount of tokens owned by `owner`.\r\n    function balanceOf(address owner) public view virtual returns (uint256 result) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            mstore(0x0c, _BALANCE_SLOT_SEED)\r\n            mstore(0x00, owner)\r\n            result := sload(keccak256(0x0c, 0x20))\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the amount of tokens that `spender` can spend on behalf of `owner`.\r\n    function allowance(address owner, address spender)\r\n        public\r\n        view\r\n        virtual\r\n        returns (uint256 result)\r\n    {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            mstore(0x20, spender)\r\n            mstore(0x0c, _ALLOWANCE_SLOT_SEED)\r\n            mstore(0x00, owner)\r\n            result := sload(keccak256(0x0c, 0x34))\r\n        }\r\n    }\r\n\r\n    /// @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n    ///\r\n    /// Emits a {Approval} event.\r\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Compute the allowance slot and store the amount.\r\n            mstore(0x20, spender)\r\n            mstore(0x0c, _ALLOWANCE_SLOT_SEED)\r\n            mstore(0x00, caller())\r\n            sstore(keccak256(0x0c, 0x34), amount)\r\n            // Emit the {Approval} event.\r\n            mstore(0x00, amount)\r\n            log3(0x00, 0x20, _APPROVAL_EVENT_SIGNATURE, caller(), shr(96, mload(0x2c)))\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /// @dev Transfer `amount` tokens from the caller to `to`.\r\n    ///\r\n    /// Requirements:\r\n    /// - `from` must at least have `amount`.\r\n    ///\r\n    /// Emits a {Transfer} event.\r\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\r\n        _beforeTokenTransfer(msg.sender, to, amount);\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Compute the balance slot and load its value.\r\n            mstore(0x0c, _BALANCE_SLOT_SEED)\r\n            mstore(0x00, caller())\r\n            let fromBalanceSlot := keccak256(0x0c, 0x20)\r\n            let fromBalance := sload(fromBalanceSlot)\r\n            // Revert if insufficient balance.\r\n            if gt(amount, fromBalance) {\r\n                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n            // Subtract and store the updated balance.\r\n            sstore(fromBalanceSlot, sub(fromBalance, amount))\r\n            // Compute the balance slot of `to`.\r\n            mstore(0x00, to)\r\n            let toBalanceSlot := keccak256(0x0c, 0x20)\r\n            // Add and store the updated balance of `to`.\r\n            // Will not overflow because the sum of all user balances\r\n            // cannot exceed the maximum uint256 value.\r\n            sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))\r\n            // Emit the {Transfer} event.\r\n            mstore(0x20, amount)\r\n            log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, caller(), shr(96, mload(0x0c)))\r\n        }\r\n        _afterTokenTransfer(msg.sender, to, amount);\r\n        return true;\r\n    }\r\n\r\n    /// @dev Transfers `amount` tokens from `from` to `to`.\r\n    ///\r\n    /// Note: Does not update the allowance if it is the maximum uint256 value.\r\n    ///\r\n    /// Requirements:\r\n    /// - `from` must at least have `amount`.\r\n    /// - The caller must have at least `amount` of allowance to transfer the tokens of `from`.\r\n    ///\r\n    /// Emits a {Transfer} event.\r\n    function transferFrom(address from, address to, uint256 amount) public virtual returns (bool) {\r\n        _beforeTokenTransfer(from, to, amount);\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let from_ := shl(96, from)\r\n            // Compute the allowance slot and load its value.\r\n            mstore(0x20, caller())\r\n            mstore(0x0c, or(from_, _ALLOWANCE_SLOT_SEED))\r\n            let allowanceSlot := keccak256(0x0c, 0x34)\r\n            let allowance_ := sload(allowanceSlot)\r\n            // If the allowance is not the maximum uint256 value.\r\n            if add(allowance_, 1) {\r\n                // Revert if the amount to be transferred exceeds the allowance.\r\n                if gt(amount, allowance_) {\r\n                    mstore(0x00, 0x13be252b) // `InsufficientAllowance()`.\r\n                    revert(0x1c, 0x04)\r\n                }\r\n                // Subtract and store the updated allowance.\r\n                sstore(allowanceSlot, sub(allowance_, amount))\r\n            }\r\n            // Compute the balance slot and load its value.\r\n            mstore(0x0c, or(from_, _BALANCE_SLOT_SEED))\r\n            let fromBalanceSlot := keccak256(0x0c, 0x20)\r\n            let fromBalance := sload(fromBalanceSlot)\r\n            // Revert if insufficient balance.\r\n            if gt(amount, fromBalance) {\r\n                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n            // Subtract and store the updated balance.\r\n            sstore(fromBalanceSlot, sub(fromBalance, amount))\r\n            // Compute the balance slot of `to`.\r\n            mstore(0x00, to)\r\n            let toBalanceSlot := keccak256(0x0c, 0x20)\r\n            // Add and store the updated balance of `to`.\r\n            // Will not overflow because the sum of all user balances\r\n            // cannot exceed the maximum uint256 value.\r\n            sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))\r\n            // Emit the {Transfer} event.\r\n            mstore(0x20, amount)\r\n            log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, shr(96, from_), shr(96, mload(0x0c)))\r\n        }\r\n        _afterTokenTransfer(from, to, amount);\r\n        return true;\r\n    }\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                          EIP-2612                          */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev For more performance, override to return the constant value\r\n    /// of `keccak256(bytes(name()))` if `name()` will never change.\r\n    function _constantNameHash() internal view virtual returns (bytes32 result) {}\r\n\r\n    /// @dev Returns the current nonce for `owner`.\r\n    /// This value is used to compute the signature for EIP-2612 permit.\r\n    function nonces(address owner) public view virtual returns (uint256 result) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Compute the nonce slot and load its value.\r\n            mstore(0x0c, _NONCES_SLOT_SEED)\r\n            mstore(0x00, owner)\r\n            result := sload(keccak256(0x0c, 0x20))\r\n        }\r\n    }\r\n\r\n    /// @dev Sets `value` as the allowance of `spender` over the tokens of `owner`,\r\n    /// authorized by a signed approval by `owner`.\r\n    ///\r\n    /// Emits a {Approval} event.\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) public virtual {\r\n        bytes32 nameHash = _constantNameHash();\r\n        //  We simply calculate it on-the-fly to allow for cases where the `name` may change.\r\n        if (nameHash == bytes32(0)) nameHash = keccak256(bytes(name()));\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Revert if the block timestamp is greater than `deadline`.\r\n            if gt(timestamp(), deadline) {\r\n                mstore(0x00, 0x1a15a3cc) // `PermitExpired()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n            let m := mload(0x40) // Grab the free memory pointer.\r\n            // Clean the upper 96 bits.\r\n            owner := shr(96, shl(96, owner))\r\n            spender := shr(96, shl(96, spender))\r\n            // Compute the nonce slot and load its value.\r\n            mstore(0x0e, _NONCES_SLOT_SEED_WITH_SIGNATURE_PREFIX)\r\n            mstore(0x00, owner)\r\n            let nonceSlot := keccak256(0x0c, 0x20)\r\n            let nonceValue := sload(nonceSlot)\r\n            // Prepare the domain separator.\r\n            mstore(m, _DOMAIN_TYPEHASH)\r\n            mstore(add(m, 0x20), nameHash)\r\n            mstore(add(m, 0x40), _VERSION_HASH)\r\n            mstore(add(m, 0x60), chainid())\r\n            mstore(add(m, 0x80), address())\r\n            mstore(0x2e, keccak256(m, 0xa0))\r\n            // Prepare the struct hash.\r\n            mstore(m, _PERMIT_TYPEHASH)\r\n            mstore(add(m, 0x20), owner)\r\n            mstore(add(m, 0x40), spender)\r\n            mstore(add(m, 0x60), value)\r\n            mstore(add(m, 0x80), nonceValue)\r\n            mstore(add(m, 0xa0), deadline)\r\n            mstore(0x4e, keccak256(m, 0xc0))\r\n            // Prepare the ecrecover calldata.\r\n            mstore(0x00, keccak256(0x2c, 0x42))\r\n            mstore(0x20, and(0xff, v))\r\n            mstore(0x40, r)\r\n            mstore(0x60, s)\r\n            let t := staticcall(gas(), 1, 0, 0x80, 0x20, 0x20)\r\n            // If the ecrecover fails, the returndatasize will be 0x00,\r\n            // `owner` will be checked if it equals the hash at 0x00,\r\n            // which evaluates to false (i.e. 0), and we will revert.\r\n            // If the ecrecover succeeds, the returndatasize will be 0x20,\r\n            // `owner` will be compared against the returned address at 0x20.\r\n            if iszero(eq(mload(returndatasize()), owner)) {\r\n                mstore(0x00, 0xddafbaef) // `InvalidPermit()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n            // Increment and store the updated nonce.\r\n            sstore(nonceSlot, add(nonceValue, t)) // `t` is 1 if ecrecover succeeds.\r\n            // Compute the allowance slot and store the value.\r\n            // The `owner` is already at slot 0x20.\r\n            mstore(0x40, or(shl(160, _ALLOWANCE_SLOT_SEED), spender))\r\n            sstore(keccak256(0x2c, 0x34), value)\r\n            // Emit the {Approval} event.\r\n            log3(add(m, 0x60), 0x20, _APPROVAL_EVENT_SIGNATURE, owner, spender)\r\n            mstore(0x40, m) // Restore the free memory pointer.\r\n            mstore(0x60, 0) // Restore the zero pointer.\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the EIP-712 domain separator for the EIP-2612 permit.\r\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32 result) {\r\n        bytes32 nameHash = _constantNameHash();\r\n        //  We simply calculate it on-the-fly to allow for cases where the `name` may change.\r\n        if (nameHash == bytes32(0)) nameHash = keccak256(bytes(name()));\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let m := mload(0x40) // Grab the free memory pointer.\r\n            mstore(m, _DOMAIN_TYPEHASH)\r\n            mstore(add(m, 0x20), nameHash)\r\n            mstore(add(m, 0x40), _VERSION_HASH)\r\n            mstore(add(m, 0x60), chainid())\r\n            mstore(add(m, 0x80), address())\r\n            result := keccak256(m, 0xa0)\r\n        }\r\n    }\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                  INTERNAL MINT FUNCTIONS                   */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev Mints `amount` tokens to `to`, increasing the total supply.\r\n    ///\r\n    /// Emits a {Transfer} event.\r\n    function _mint(address to, uint256 amount) internal virtual {\r\n        _beforeTokenTransfer(address(0), to, amount);\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let totalSupplyBefore := sload(_TOTAL_SUPPLY_SLOT)\r\n            let totalSupplyAfter := add(totalSupplyBefore, amount)\r\n            // Revert if the total supply overflows.\r\n            if lt(totalSupplyAfter, totalSupplyBefore) {\r\n                mstore(0x00, 0xe5cfe957) // `TotalSupplyOverflow()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n            // Store the updated total supply.\r\n            sstore(_TOTAL_SUPPLY_SLOT, totalSupplyAfter)\r\n            // Compute the balance slot and load its value.\r\n            mstore(0x0c, _BALANCE_SLOT_SEED)\r\n            mstore(0x00, to)\r\n            let toBalanceSlot := keccak256(0x0c, 0x20)\r\n            // Add and store the updated balance.\r\n            sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))\r\n            // Emit the {Transfer} event.\r\n            mstore(0x20, amount)\r\n            log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, 0, shr(96, mload(0x0c)))\r\n        }\r\n        _afterTokenTransfer(address(0), to, amount);\r\n    }\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                  INTERNAL BURN FUNCTIONS                   */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev Burns `amount` tokens from `from`, reducing the total supply.\r\n    ///\r\n    /// Emits a {Transfer} event.\r\n    function _burn(address from, uint256 amount) internal virtual {\r\n        _beforeTokenTransfer(from, address(0), amount);\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Compute the balance slot and load its value.\r\n            mstore(0x0c, _BALANCE_SLOT_SEED)\r\n            mstore(0x00, from)\r\n            let fromBalanceSlot := keccak256(0x0c, 0x20)\r\n            let fromBalance := sload(fromBalanceSlot)\r\n            // Revert if insufficient balance.\r\n            if gt(amount, fromBalance) {\r\n                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n            // Subtract and store the updated balance.\r\n            sstore(fromBalanceSlot, sub(fromBalance, amount))\r\n            // Subtract and store the updated total supply.\r\n            sstore(_TOTAL_SUPPLY_SLOT, sub(sload(_TOTAL_SUPPLY_SLOT), amount))\r\n            // Emit the {Transfer} event.\r\n            mstore(0x00, amount)\r\n            log3(0x00, 0x20, _TRANSFER_EVENT_SIGNATURE, shr(96, shl(96, from)), 0)\r\n        }\r\n        _afterTokenTransfer(from, address(0), amount);\r\n    }\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                INTERNAL TRANSFER FUNCTIONS                 */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev Moves `amount` of tokens from `from` to `to`.\r\n    function _transfer(address from, address to, uint256 amount) internal virtual {\r\n        _beforeTokenTransfer(from, to, amount);\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let from_ := shl(96, from)\r\n            // Compute the balance slot and load its value.\r\n            mstore(0x0c, or(from_, _BALANCE_SLOT_SEED))\r\n            let fromBalanceSlot := keccak256(0x0c, 0x20)\r\n            let fromBalance := sload(fromBalanceSlot)\r\n            // Revert if insufficient balance.\r\n            if gt(amount, fromBalance) {\r\n                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n            // Subtract and store the updated balance.\r\n            sstore(fromBalanceSlot, sub(fromBalance, amount))\r\n            // Compute the balance slot of `to`.\r\n            mstore(0x00, to)\r\n            let toBalanceSlot := keccak256(0x0c, 0x20)\r\n            // Add and store the updated balance of `to`.\r\n            // Will not overflow because the sum of all user balances\r\n            // cannot exceed the maximum uint256 value.\r\n            sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))\r\n            // Emit the {Transfer} event.\r\n            mstore(0x20, amount)\r\n            log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, shr(96, from_), shr(96, mload(0x0c)))\r\n        }\r\n        _afterTokenTransfer(from, to, amount);\r\n    }\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                INTERNAL ALLOWANCE FUNCTIONS                */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev Updates the allowance of `owner` for `spender` based on spent `amount`.\r\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Compute the allowance slot and load its value.\r\n            mstore(0x20, spender)\r\n            mstore(0x0c, _ALLOWANCE_SLOT_SEED)\r\n            mstore(0x00, owner)\r\n            let allowanceSlot := keccak256(0x0c, 0x34)\r\n            let allowance_ := sload(allowanceSlot)\r\n            // If the allowance is not the maximum uint256 value.\r\n            if add(allowance_, 1) {\r\n                // Revert if the amount to be transferred exceeds the allowance.\r\n                if gt(amount, allowance_) {\r\n                    mstore(0x00, 0x13be252b) // `InsufficientAllowance()`.\r\n                    revert(0x1c, 0x04)\r\n                }\r\n                // Subtract and store the updated allowance.\r\n                sstore(allowanceSlot, sub(allowance_, amount))\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Sets `amount` as the allowance of `spender` over the tokens of `owner`.\r\n    ///\r\n    /// Emits a {Approval} event.\r\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let owner_ := shl(96, owner)\r\n            // Compute the allowance slot and store the amount.\r\n            mstore(0x20, spender)\r\n            mstore(0x0c, or(owner_, _ALLOWANCE_SLOT_SEED))\r\n            sstore(keccak256(0x0c, 0x34), amount)\r\n            // Emit the {Approval} event.\r\n            mstore(0x00, amount)\r\n            log3(0x00, 0x20, _APPROVAL_EVENT_SIGNATURE, shr(96, owner_), shr(96, mload(0x2c)))\r\n        }\r\n    }\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                     HOOKS TO OVERRIDE                      */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev Hook that is called before any transfer of tokens.\r\n    /// This includes minting and burning.\r\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\r\n\r\n    /// @dev Hook that is called after any transfer of tokens.\r\n    /// This includes minting and burning.\r\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\r\n}\r\n\r\ninterface IYearnGauge {\r\n    function getReward(address _account) external;\r\n\r\n    function setRecipient(address _recipient) external;\r\n}\r\n\r\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\r\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/SafeTransferLib.sol)\r\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\r\n///\r\n/// @dev Note:\r\n/// - For ETH transfers, please use `forceSafeTransferETH` for DoS protection.\r\n/// - For ERC20s, this implementation won't check that a token has code,\r\n///   responsibility is delegated to the caller.\r\nlibrary SafeTransferLib {\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                       CUSTOM ERRORS                        */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev The ETH transfer has failed.\r\n    error ETHTransferFailed();\r\n\r\n    /// @dev The ERC20 `transferFrom` has failed.\r\n    error TransferFromFailed();\r\n\r\n    /// @dev The ERC20 `transfer` has failed.\r\n    error TransferFailed();\r\n\r\n    /// @dev The ERC20 `approve` has failed.\r\n    error ApproveFailed();\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                         CONSTANTS                          */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev Suggested gas stipend for contract receiving ETH that disallows any storage writes.\r\n    uint256 internal constant GAS_STIPEND_NO_STORAGE_WRITES = 2300;\r\n\r\n    /// @dev Suggested gas stipend for contract receiving ETH to perform a few\r\n    /// storage reads and writes, but low enough to prevent griefing.\r\n    uint256 internal constant GAS_STIPEND_NO_GRIEF = 100000;\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                       ETH OPERATIONS                       */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    // If the ETH transfer MUST succeed with a reasonable gas budget, use the force variants.\r\n    //\r\n    // The regular variants:\r\n    // - Forwards all remaining gas to the target.\r\n    // - Reverts if the target reverts.\r\n    // - Reverts if the current contract has insufficient balance.\r\n    //\r\n    // The force variants:\r\n    // - Forwards with an optional gas stipend\r\n    //   (defaults to `GAS_STIPEND_NO_GRIEF`, which is sufficient for most cases).\r\n    // - If the target reverts, or if the gas stipend is exhausted,\r\n    //   creates a temporary contract to force send the ETH via `SELFDESTRUCT`.\r\n    //   Future compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758.\r\n    // - Reverts if the current contract has insufficient balance.\r\n    //\r\n    // The try variants:\r\n    // - Forwards with a mandatory gas stipend.\r\n    // - Instead of reverting, returns whether the transfer succeeded.\r\n\r\n    /// @dev Sends `amount` (in wei) ETH to `to`.\r\n    function safeTransferETH(address to, uint256 amount) internal {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            if iszero(call(gas(), to, amount, codesize(), 0x00, codesize(), 0x00)) {\r\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Sends all the ETH in the current contract to `to`.\r\n    function safeTransferAllETH(address to) internal {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Transfer all the ETH and check if it succeeded or not.\r\n            if iszero(call(gas(), to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\r\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\r\n    function forceSafeTransferETH(address to, uint256 amount, uint256 gasStipend) internal {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            if lt(selfbalance(), amount) {\r\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n            if iszero(call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)) {\r\n                mstore(0x00, to) // Store the address in scratch space.\r\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\r\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\r\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Force sends all the ETH in the current contract to `to`, with a `gasStipend`.\r\n    function forceSafeTransferAllETH(address to, uint256 gasStipend) internal {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            if iszero(call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\r\n                mstore(0x00, to) // Store the address in scratch space.\r\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\r\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\r\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with `GAS_STIPEND_NO_GRIEF`.\r\n    function forceSafeTransferETH(address to, uint256 amount) internal {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            if lt(selfbalance(), amount) {\r\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, amount, codesize(), 0x00, codesize(), 0x00)) {\r\n                mstore(0x00, to) // Store the address in scratch space.\r\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\r\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\r\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Force sends all the ETH in the current contract to `to`, with `GAS_STIPEND_NO_GRIEF`.\r\n    function forceSafeTransferAllETH(address to) internal {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // forgefmt: disable-next-item\r\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\r\n                mstore(0x00, to) // Store the address in scratch space.\r\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\r\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\r\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\r\n    function trySafeTransferETH(address to, uint256 amount, uint256 gasStipend)\r\n        internal\r\n        returns (bool success)\r\n    {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            success := call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)\r\n        }\r\n    }\r\n\r\n    /// @dev Sends all the ETH in the current contract to `to`, with a `gasStipend`.\r\n    function trySafeTransferAllETH(address to, uint256 gasStipend)\r\n        internal\r\n        returns (bool success)\r\n    {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            success := call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)\r\n        }\r\n    }\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                      ERC20 OPERATIONS                      */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\r\n    /// Reverts upon failure.\r\n    ///\r\n    /// The `from` account must have at least `amount` approved for\r\n    /// the current contract to manage.\r\n    function safeTransferFrom(address token, address from, address to, uint256 amount) internal {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let m := mload(0x40) // Cache the free memory pointer.\r\n            mstore(0x60, amount) // Store the `amount` argument.\r\n            mstore(0x40, to) // Store the `to` argument.\r\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\r\n            mstore(0x0c, 0x23b872dd000000000000000000000000) // `transferFrom(address,address,uint256)`.\r\n            // Perform the transfer, reverting upon failure.\r\n            if iszero(\r\n                and( // The arguments of `and` are evaluated from right to left.\r\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\r\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\r\n                )\r\n            ) {\r\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n            mstore(0x60, 0) // Restore the zero slot to zero.\r\n            mstore(0x40, m) // Restore the free memory pointer.\r\n        }\r\n    }\r\n\r\n    /// @dev Sends all of ERC20 `token` from `from` to `to`.\r\n    /// Reverts upon failure.\r\n    ///\r\n    /// The `from` account must have their entire balance approved for\r\n    /// the current contract to manage.\r\n    function safeTransferAllFrom(address token, address from, address to)\r\n        internal\r\n        returns (uint256 amount)\r\n    {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let m := mload(0x40) // Cache the free memory pointer.\r\n            mstore(0x40, to) // Store the `to` argument.\r\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\r\n            mstore(0x0c, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\r\n            // Read the balance, reverting upon failure.\r\n            if iszero(\r\n                and( // The arguments of `and` are evaluated from right to left.\r\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\r\n                    staticcall(gas(), token, 0x1c, 0x24, 0x60, 0x20)\r\n                )\r\n            ) {\r\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n            mstore(0x00, 0x23b872dd) // `transferFrom(address,address,uint256)`.\r\n            amount := mload(0x60) // The `amount` is already at 0x60. We'll need to return it.\r\n            // Perform the transfer, reverting upon failure.\r\n            if iszero(\r\n                and( // The arguments of `and` are evaluated from right to left.\r\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\r\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\r\n                )\r\n            ) {\r\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n            mstore(0x60, 0) // Restore the zero slot to zero.\r\n            mstore(0x40, m) // Restore the free memory pointer.\r\n        }\r\n    }\r\n\r\n    /// @dev Sends `amount` of ERC20 `token` from the current contract to `to`.\r\n    /// Reverts upon failure.\r\n    function safeTransfer(address token, address to, uint256 amount) internal {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            mstore(0x14, to) // Store the `to` argument.\r\n            mstore(0x34, amount) // Store the `amount` argument.\r\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\r\n            // Perform the transfer, reverting upon failure.\r\n            if iszero(\r\n                and( // The arguments of `and` are evaluated from right to left.\r\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\r\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\r\n                )\r\n            ) {\r\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\r\n        }\r\n    }\r\n\r\n    /// @dev Sends all of ERC20 `token` from the current contract to `to`.\r\n    /// Reverts upon failure.\r\n    function safeTransferAll(address token, address to) internal returns (uint256 amount) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            mstore(0x00, 0x70a08231) // Store the function selector of `balanceOf(address)`.\r\n            mstore(0x20, address()) // Store the address of the current contract.\r\n            // Read the balance, reverting upon failure.\r\n            if iszero(\r\n                and( // The arguments of `and` are evaluated from right to left.\r\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\r\n                    staticcall(gas(), token, 0x1c, 0x24, 0x34, 0x20)\r\n                )\r\n            ) {\r\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n            mstore(0x14, to) // Store the `to` argument.\r\n            amount := mload(0x34) // The `amount` is already at 0x34. We'll need to return it.\r\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\r\n            // Perform the transfer, reverting upon failure.\r\n            if iszero(\r\n                and( // The arguments of `and` are evaluated from right to left.\r\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\r\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\r\n                )\r\n            ) {\r\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\r\n        }\r\n    }\r\n\r\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\r\n    /// Reverts upon failure.\r\n    function safeApprove(address token, address to, uint256 amount) internal {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            mstore(0x14, to) // Store the `to` argument.\r\n            mstore(0x34, amount) // Store the `amount` argument.\r\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\r\n            // Perform the approval, reverting upon failure.\r\n            if iszero(\r\n                and( // The arguments of `and` are evaluated from right to left.\r\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\r\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\r\n                )\r\n            ) {\r\n                mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\r\n        }\r\n    }\r\n\r\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\r\n    /// If the initial attempt to approve fails, attempts to reset the approved amount to zero,\r\n    /// then retries the approval again (some tokens, e.g. USDT, requires this).\r\n    /// Reverts upon failure.\r\n    function safeApproveWithRetry(address token, address to, uint256 amount) internal {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            mstore(0x14, to) // Store the `to` argument.\r\n            mstore(0x34, amount) // Store the `amount` argument.\r\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\r\n            // Perform the approval, retrying upon failure.\r\n            if iszero(\r\n                and( // The arguments of `and` are evaluated from right to left.\r\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\r\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\r\n                )\r\n            ) {\r\n                mstore(0x34, 0) // Store 0 for the `amount`.\r\n                mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\r\n                pop(call(gas(), token, 0, 0x10, 0x44, codesize(), 0x00)) // Reset the approval.\r\n                mstore(0x34, amount) // Store back the original `amount`.\r\n                // Retry the approval, reverting upon failure.\r\n                if iszero(\r\n                    and(\r\n                        or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\r\n                        call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\r\n                    )\r\n                ) {\r\n                    mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\r\n                    revert(0x1c, 0x04)\r\n                }\r\n            }\r\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the amount of ERC20 `token` owned by `account`.\r\n    /// Returns zero if the `token` does not exist.\r\n    function balanceOf(address token, address account) internal view returns (uint256 amount) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            mstore(0x14, account) // Store the `account` argument.\r\n            mstore(0x00, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\r\n            amount :=\r\n                mul(\r\n                    mload(0x20),\r\n                    and( // The arguments of `and` are evaluated from right to left.\r\n                        gt(returndatasize(), 0x1f), // At least 32 bytes returned.\r\n                        staticcall(gas(), token, 0x10, 0x24, 0x20, 0x20)\r\n                    )\r\n                )\r\n        }\r\n    }\r\n}\r\n\r\ninterface ISDTDistributor {\r\n    function distribute(address gaugeAddr) external;\r\n}\r\n\r\ninterface IYearnRewardPool {\r\n    // solhint-disable-next-line\r\n    function checkpoint_token() external;\r\n\r\n    // solhint-disable-next-line\r\n    function checkpoint_total_supply() external;\r\n\r\n    function claim(address _user) external;\r\n}\r\n\r\n/// @notice UUPS proxy mixin.\r\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/UUPSUpgradeable.sol)\r\n/// @author Modified from OpenZeppelin\r\n/// (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/proxy/utils/UUPSUpgradeable.sol)\r\n///\r\n/// Note:\r\n/// - This implementation is intended to be used with ERC1967 proxies.\r\n/// See: `LibClone.deployERC1967` and related functions.\r\n/// - This implementation is NOT compatible with legacy OpenZeppelin proxies\r\n/// which do not store the implementation at `_ERC1967_IMPLEMENTATION_SLOT`.\r\nabstract contract UUPSUpgradeable {\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                       CUSTOM ERRORS                        */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev The upgrade failed.\r\n    error UpgradeFailed();\r\n\r\n    /// @dev The call is from an unauthorized call context.\r\n    error UnauthorizedCallContext();\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                         IMMUTABLES                         */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev For checking if the context is a delegate call.\r\n    uint256 private immutable __self = uint256(uint160(address(this)));\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                           EVENTS                           */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev Emitted when the proxy's implementation is upgraded.\r\n    event Upgraded(address indexed implementation);\r\n\r\n    /// @dev `keccak256(bytes(\"Upgraded(address)\"))`.\r\n    uint256 private constant _UPGRADED_EVENT_SIGNATURE =\r\n        0xbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b;\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                          STORAGE                           */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev The ERC-1967 storage slot for the implementation in the proxy.\r\n    /// `uint256(keccak256(\"eip1967.proxy.implementation\")) - 1`.\r\n    bytes32 internal constant _ERC1967_IMPLEMENTATION_SLOT =\r\n        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                      UUPS OPERATIONS                       */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev Please override this function to check if `msg.sender` is authorized\r\n    /// to upgrade the proxy to `newImplementation`, reverting if not.\r\n    /// ```\r\n    ///     function _authorizeUpgrade(address) internal override onlyOwner {}\r\n    /// ```\r\n    function _authorizeUpgrade(address newImplementation) internal virtual;\r\n\r\n    /// @dev Returns the storage slot used by the implementation,\r\n    /// as specified in [ERC1822](https://eips.ethereum.org/EIPS/eip-1822).\r\n    ///\r\n    /// Note: The `notDelegated` modifier prevents accidental upgrades to\r\n    /// an implementation that is a proxy contract.\r\n    function proxiableUUID() public view virtual notDelegated returns (bytes32) {\r\n        // This function must always return `_ERC1967_IMPLEMENTATION_SLOT` to comply with ERC1967.\r\n        return _ERC1967_IMPLEMENTATION_SLOT;\r\n    }\r\n\r\n    /// @dev Upgrades the proxy's implementation to `newImplementation`.\r\n    /// Emits a {Upgraded} event.\r\n    ///\r\n    /// Note: The `onlyProxy` modifier prevents accidental calling on the implementation.\r\n    function upgradeTo(address newImplementation) public payable virtual onlyProxy {\r\n        _authorizeUpgrade(newImplementation);\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            newImplementation := shr(96, shl(96, newImplementation)) // Clears upper 96 bits.\r\n            mstore(0x01, 0x52d1902d) // `proxiableUUID()`.\r\n            let s := _ERC1967_IMPLEMENTATION_SLOT\r\n            // Check if `newImplementation` implements `proxiableUUID` correctly.\r\n            if iszero(eq(mload(staticcall(gas(), newImplementation, 0x1d, 0x04, 0x01, 0x20)), s)) {\r\n                mstore(0x01, 0x55299b49) // `UpgradeFailed()`.\r\n                revert(0x1d, 0x04)\r\n            }\r\n            // Emit the {Upgraded} event.\r\n            log2(codesize(), 0x00, _UPGRADED_EVENT_SIGNATURE, newImplementation)\r\n            sstore(s, newImplementation) // Updates the implementation.\r\n        }\r\n    }\r\n\r\n    /// @dev Upgrades the proxy's implementation to `newImplementation`.\r\n    /// Emits a {Upgraded} event.\r\n    ///\r\n    /// Note: This function calls `upgradeTo` internally,\r\n    /// followed by a delegatecall to `newImplementation`.\r\n    function upgradeToAndCall(address newImplementation, bytes calldata data)\r\n        public\r\n        payable\r\n        virtual\r\n    {\r\n        upgradeTo(newImplementation);\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Forwards the `data` to `newImplementation` via delegatecall.\r\n            let m := mload(0x40)\r\n            calldatacopy(m, data.offset, data.length)\r\n            if iszero(delegatecall(gas(), newImplementation, m, data.length, codesize(), 0x00)) {\r\n                // Bubble up the revert if the call reverts.\r\n                returndatacopy(m, 0x00, returndatasize())\r\n                revert(m, returndatasize())\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Requires that the execution is performed through a proxy.\r\n    modifier onlyProxy() {\r\n        uint256 s = __self;\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // To enable use cases with an immutable default implementation in the bytecode,\r\n            // (see: ERC6551Proxy), we don't require that the proxy address must match the\r\n            // value stored in the implementation slot, which may not be initialized.\r\n            if eq(s, address()) {\r\n                mstore(0x00, 0x9f03a026) // `UnauthorizedCallContext()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n        }\r\n        _;\r\n    }\r\n\r\n    /// @dev Requires that the execution is NOT performed via delegatecall.\r\n    /// This is the opposite of `onlyProxy`.\r\n    modifier notDelegated() {\r\n        uint256 s = __self;\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            if iszero(eq(s, address())) {\r\n                mstore(0x00, 0x9f03a026) // `UnauthorizedCallContext()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n        }\r\n        _;\r\n    }\r\n}\r\n\r\n/// @notice Arithmetic library with operations for fixed-point numbers.\r\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/FixedPointMathLib.sol)\r\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)\r\nlibrary FixedPointMathLib {\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                       CUSTOM ERRORS                        */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev The operation failed, as the output exceeds the maximum value of uint256.\r\n    error ExpOverflow();\r\n\r\n    /// @dev The operation failed, as the output exceeds the maximum value of uint256.\r\n    error FactorialOverflow();\r\n\r\n    /// @dev The operation failed, due to an overflow.\r\n    error RPowOverflow();\r\n\r\n    /// @dev The operation failed, due to an multiplication overflow.\r\n    error MulWadFailed();\r\n\r\n    /// @dev The operation failed, either due to a\r\n    /// multiplication overflow, or a division by a zero.\r\n    error DivWadFailed();\r\n\r\n    /// @dev The multiply-divide operation failed, either due to a\r\n    /// multiplication overflow, or a division by a zero.\r\n    error MulDivFailed();\r\n\r\n    /// @dev The division failed, as the denominator is zero.\r\n    error DivFailed();\r\n\r\n    /// @dev The full precision multiply-divide operation failed, either due\r\n    /// to the result being larger than 256 bits, or a division by a zero.\r\n    error FullMulDivFailed();\r\n\r\n    /// @dev The output is undefined, as the input is less-than-or-equal to zero.\r\n    error LnWadUndefined();\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                         CONSTANTS                          */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev The scalar of ETH and most ERC20s.\r\n    uint256 internal constant WAD = 1e18;\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*              SIMPLIFIED FIXED POINT OPERATIONS             */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev Equivalent to `(x * y) / WAD` rounded down.\r\n    function mulWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Equivalent to `require(y == 0 || x <= type(uint256).max / y)`.\r\n            if mul(y, gt(x, div(not(0), y))) {\r\n                mstore(0x00, 0xbac65e5b) // `MulWadFailed()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n            z := div(mul(x, y), WAD)\r\n        }\r\n    }\r\n\r\n    /// @dev Equivalent to `(x * y) / WAD` rounded up.\r\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Equivalent to `require(y == 0 || x <= type(uint256).max / y)`.\r\n            if mul(y, gt(x, div(not(0), y))) {\r\n                mstore(0x00, 0xbac65e5b) // `MulWadFailed()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n            z := add(iszero(iszero(mod(mul(x, y), WAD))), div(mul(x, y), WAD))\r\n        }\r\n    }\r\n\r\n    /// @dev Equivalent to `(x * WAD) / y` rounded down.\r\n    function divWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Equivalent to `require(y != 0 && (WAD == 0 || x <= type(uint256).max / WAD))`.\r\n            if iszero(mul(y, iszero(mul(WAD, gt(x, div(not(0), WAD)))))) {\r\n                mstore(0x00, 0x7c5f487d) // `DivWadFailed()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n            z := div(mul(x, WAD), y)\r\n        }\r\n    }\r\n\r\n    /// @dev Equivalent to `(x * WAD) / y` rounded up.\r\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Equivalent to `require(y != 0 && (WAD == 0 || x <= type(uint256).max / WAD))`.\r\n            if iszero(mul(y, iszero(mul(WAD, gt(x, div(not(0), WAD)))))) {\r\n                mstore(0x00, 0x7c5f487d) // `DivWadFailed()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n            z := add(iszero(iszero(mod(mul(x, WAD), y))), div(mul(x, WAD), y))\r\n        }\r\n    }\r\n\r\n    /// @dev Equivalent to `x` to the power of `y`.\r\n    /// because `x ** y = (e ** ln(x)) ** y = e ** (ln(x) * y)`.\r\n    function powWad(int256 x, int256 y) internal pure returns (int256) {\r\n        // Using `ln(x)` means `x` must be greater than 0.\r\n        return expWad((lnWad(x) * y) / int256(WAD));\r\n    }\r\n\r\n    /// @dev Returns `exp(x)`, denominated in `WAD`.\r\n    function expWad(int256 x) internal pure returns (int256 r) {\r\n        unchecked {\r\n            // When the result is < 0.5 we return zero. This happens when\r\n            // x <= floor(log(0.5e18) * 1e18) ~ -42e18\r\n            if (x <= -42139678854452767551) return r;\r\n\r\n            /// @solidity memory-safe-assembly\r\n            assembly {\r\n                // When the result is > (2**255 - 1) / 1e18 we can not represent it as an\r\n                // int. This happens when x >= floor(log((2**255 - 1) / 1e18) * 1e18) ~ 135.\r\n                if iszero(slt(x, 135305999368893231589)) {\r\n                    mstore(0x00, 0xa37bfec9) // `ExpOverflow()`.\r\n                    revert(0x1c, 0x04)\r\n                }\r\n            }\r\n\r\n            // x is now in the range (-42, 136) * 1e18. Convert to (-42, 136) * 2**96\r\n            // for more intermediate precision and a binary basis. This base conversion\r\n            // is a multiplication by 1e18 / 2**96 = 5**18 / 2**78.\r\n            x = (x << 78) / 5 ** 18;\r\n\r\n            // Reduce range of x to (-\u00bd ln 2, \u00bd ln 2) * 2**96 by factoring out powers\r\n            // of two such that exp(x) = exp(x') * 2**k, where k is an integer.\r\n            // Solving this gives k = round(x / log(2)) and x' = x - k * log(2).\r\n            int256 k = ((x << 96) / 54916777467707473351141471128 + 2 ** 95) >> 96;\r\n            x = x - k * 54916777467707473351141471128;\r\n\r\n            // k is in the range [-61, 195].\r\n\r\n            // Evaluate using a (6, 7)-term rational approximation.\r\n            // p is made monic, we'll multiply by a scale factor later.\r\n            int256 y = x + 1346386616545796478920950773328;\r\n            y = ((y * x) >> 96) + 57155421227552351082224309758442;\r\n            int256 p = y + x - 94201549194550492254356042504812;\r\n            p = ((p * y) >> 96) + 28719021644029726153956944680412240;\r\n            p = p * x + (4385272521454847904659076985693276 << 96);\r\n\r\n            // We leave p in 2**192 basis so we don't need to scale it back up for the division.\r\n            int256 q = x - 2855989394907223263936484059900;\r\n            q = ((q * x) >> 96) + 50020603652535783019961831881945;\r\n            q = ((q * x) >> 96) - 533845033583426703283633433725380;\r\n            q = ((q * x) >> 96) + 3604857256930695427073651918091429;\r\n            q = ((q * x) >> 96) - 14423608567350463180887372962807573;\r\n            q = ((q * x) >> 96) + 26449188498355588339934803723976023;\r\n\r\n            /// @solidity memory-safe-assembly\r\n            assembly {\r\n                // Div in assembly because solidity adds a zero check despite the unchecked.\r\n                // The q polynomial won't have zeros in the domain as all its roots are complex.\r\n                // No scaling is necessary because p is already 2**96 too large.\r\n                r := sdiv(p, q)\r\n            }\r\n\r\n            // r should be in the range (0.09, 0.25) * 2**96.\r\n\r\n            // We now need to multiply r by:\r\n            // * the scale factor s = ~6.031367120.\r\n            // * the 2**k factor from the range reduction.\r\n            // * the 1e18 / 2**96 factor for base conversion.\r\n            // We do this all at once, with an intermediate result in 2**213\r\n            // basis, so the final right shift is always by a positive amount.\r\n            r = int256(\r\n                (uint256(r) * 3822833074963236453042738258902158003155416615667) >> uint256(195 - k)\r\n            );\r\n        }\r\n    }\r\n\r\n    /// @dev Returns `ln(x)`, denominated in `WAD`.\r\n    function lnWad(int256 x) internal pure returns (int256 r) {\r\n        unchecked {\r\n            /// @solidity memory-safe-assembly\r\n            assembly {\r\n                if iszero(sgt(x, 0)) {\r\n                    mstore(0x00, 0x1615e638) // `LnWadUndefined()`.\r\n                    revert(0x1c, 0x04)\r\n                }\r\n            }\r\n\r\n            // We want to convert x from 10**18 fixed point to 2**96 fixed point.\r\n            // We do this by multiplying by 2**96 / 10**18. But since\r\n            // ln(x * C) = ln(x) + ln(C), we can simply do nothing here\r\n            // and add ln(2**96 / 10**18) at the end.\r\n\r\n            // Compute k = log2(x) - 96.\r\n            int256 k;\r\n            /// @solidity memory-safe-assembly\r\n            assembly {\r\n                k := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\r\n                k := or(k, shl(6, lt(0xffffffffffffffff, shr(k, x))))\r\n                k := or(k, shl(5, lt(0xffffffff, shr(k, x))))\r\n                k := or(k, shl(4, lt(0xffff, shr(k, x))))\r\n                k := or(k, shl(3, lt(0xff, shr(k, x))))\r\n                k := or(k, shl(2, lt(0xf, shr(k, x))))\r\n                k := sub(or(k, byte(shr(k, x), hex\"00000101020202020303030303030303\")), 96)\r\n            }\r\n\r\n            // Reduce range of x to (1, 2) * 2**96\r\n            // ln(2^k * x) = k * ln(2) + ln(x)\r\n            x = int256(uint256(x << uint256(159 - k)) >> 159);\r\n\r\n            // Evaluate using a (8, 8)-term rational approximation.\r\n            // p is made monic, we will multiply by a scale factor later.\r\n            int256 p = x + 3273285459638523848632254066296;\r\n            p = ((p * x) >> 96) + 24828157081833163892658089445524;\r\n            p = ((p * x) >> 96) + 43456485725739037958740375743393;\r\n            p = ((p * x) >> 96) - 11111509109440967052023855526967;\r\n            p = ((p * x) >> 96) - 45023709667254063763336534515857;\r\n            p = ((p * x) >> 96) - 14706773417378608786704636184526;\r\n            p = p * x - (795164235651350426258249787498 << 96);\r\n\r\n            // We leave p in 2**192 basis so we don't need to scale it back up for the division.\r\n            // q is monic by convention.\r\n            int256 q = x + 5573035233440673466300451813936;\r\n            q = ((q * x) >> 96) + 71694874799317883764090561454958;\r\n            q = ((q * x) >> 96) + 283447036172924575727196451306956;\r\n            q = ((q * x) >> 96) + 401686690394027663651624208769553;\r\n            q = ((q * x) >> 96) + 204048457590392012362485061816622;\r\n            q = ((q * x) >> 96) + 31853899698501571402653359427138;\r\n            q = ((q * x) >> 96) + 909429971244387300277376558375;\r\n            /// @solidity memory-safe-assembly\r\n            assembly {\r\n                // Div in assembly because solidity adds a zero check despite the unchecked.\r\n                // The q polynomial is known not to have zeros in the domain.\r\n                // No scaling required because p is already 2**96 too large.\r\n                r := sdiv(p, q)\r\n            }\r\n\r\n            // r is in the range (0, 0.125) * 2**96\r\n\r\n            // Finalization, we need to:\r\n            // * multiply by the scale factor s = 5.549\u2026\r\n            // * add ln(2**96 / 10**18)\r\n            // * add k * ln(2)\r\n            // * multiply by 10**18 / 2**96 = 5**18 >> 78\r\n\r\n            // mul s * 5e18 * 2**96, base is now 5**18 * 2**192\r\n            r *= 1677202110996718588342820967067443963516166;\r\n            // add ln(2) * k * 5e18 * 2**192\r\n            r += 16597577552685614221487285958193947469193820559219878177908093499208371 * k;\r\n            // add ln(2**96 / 10**18) * 5e18 * 2**192\r\n            r += 600920179829731861736702779321621459595472258049074101567377883020018308;\r\n            // base conversion: mul 2**18 / 2**192\r\n            r >>= 174;\r\n        }\r\n    }\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                  GENERAL NUMBER UTILITIES                  */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev Calculates `floor(a * b / d)` with full precision.\r\n    /// Throws if result overflows a uint256 or when `d` is zero.\r\n    /// Credit to Remco Bloemen under MIT license: https://2\u03c0.com/21/muldiv\r\n    function fullMulDiv(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 result) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            for {} 1 {} {\r\n                // 512-bit multiply `[p1 p0] = x * y`.\r\n                // Compute the product mod `2**256` and mod `2**256 - 1`\r\n                // then use the Chinese Remainder Theorem to reconstruct\r\n                // the 512 bit result. The result is stored in two 256\r\n                // variables such that `product = p1 * 2**256 + p0`.\r\n\r\n                // Least significant 256 bits of the product.\r\n                let p0 := mul(x, y)\r\n                let mm := mulmod(x, y, not(0))\r\n                // Most significant 256 bits of the product.\r\n                let p1 := sub(mm, add(p0, lt(mm, p0)))\r\n\r\n                // Handle non-overflow cases, 256 by 256 division.\r\n                if iszero(p1) {\r\n                    if iszero(d) {\r\n                        mstore(0x00, 0xae47f702) // `FullMulDivFailed()`.\r\n                        revert(0x1c, 0x04)\r\n                    }\r\n                    result := div(p0, d)\r\n                    break\r\n                }\r\n\r\n                // Make sure the result is less than `2**256`. Also prevents `d == 0`.\r\n                if iszero(gt(d, p1)) {\r\n                    mstore(0x00, 0xae47f702) // `FullMulDivFailed()`.\r\n                    revert(0x1c, 0x04)\r\n                }\r\n\r\n                /*------------------- 512 by 256 division --------------------*/\r\n\r\n                // Make division exact by subtracting the remainder from `[p1 p0]`.\r\n                // Compute remainder using mulmod.\r\n                let r := mulmod(x, y, d)\r\n                // `t` is the least significant bit of `d`.\r\n                // Always greater or equal to 1.\r\n                let t := and(d, sub(0, d))\r\n                // Divide `d` by `t`, which is a power of two.\r\n                d := div(d, t)\r\n                // Invert `d mod 2**256`\r\n                // Now that `d` is an odd number, it has an inverse\r\n                // modulo `2**256` such that `d * inv = 1 mod 2**256`.\r\n                // Compute the inverse by starting with a seed that is correct\r\n                // correct for four bits. That is, `d * inv = 1 mod 2**4`.\r\n                let inv := xor(mul(3, d), 2)\r\n                // Now use Newton-Raphson iteration to improve the precision.\r\n                // Thanks to Hensel's lifting lemma, this also works in modular\r\n                // arithmetic, doubling the correct bits in each step.\r\n                inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**8\r\n                inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**16\r\n                inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**32\r\n                inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**64\r\n                inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**128\r\n                result :=\r\n                    mul(\r\n                        // Divide [p1 p0] by the factors of two.\r\n                        // Shift in bits from `p1` into `p0`. For this we need\r\n                        // to flip `t` such that it is `2**256 / t`.\r\n                        or(mul(sub(p1, gt(r, p0)), add(div(sub(0, t), t), 1)), div(sub(p0, r), t)),\r\n                        // inverse mod 2**256\r\n                        mul(inv, sub(2, mul(d, inv)))\r\n                    )\r\n                break\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Calculates `floor(x * y / d)` with full precision, rounded up.\r\n    /// Throws if result overflows a uint256 or when `d` is zero.\r\n    /// Credit to Uniswap-v3-core under MIT license:\r\n    /// https://github.com/Uniswap/v3-core/blob/contracts/libraries/FullMath.sol\r\n    function fullMulDivUp(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 result) {\r\n        result = fullMulDiv(x, y, d);\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            if mulmod(x, y, d) {\r\n                result := add(result, 1)\r\n                if iszero(result) {\r\n                    mstore(0x00, 0xae47f702) // `FullMulDivFailed()`.\r\n                    revert(0x1c, 0x04)\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Returns `floor(x * y / d)`.\r\n    /// Reverts if `x * y` overflows, or `d` is zero.\r\n    function mulDiv(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Equivalent to require(d != 0 && (y == 0 || x <= type(uint256).max / y))\r\n            if iszero(mul(d, iszero(mul(y, gt(x, div(not(0), y)))))) {\r\n                mstore(0x00, 0xad251c27) // `MulDivFailed()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n            z := div(mul(x, y), d)\r\n        }\r\n    }\r\n\r\n    /// @dev Returns `ceil(x * y / d)`.\r\n    /// Reverts if `x * y` overflows, or `d` is zero.\r\n    function mulDivUp(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Equivalent to require(d != 0 && (y == 0 || x <= type(uint256).max / y))\r\n            if iszero(mul(d, iszero(mul(y, gt(x, div(not(0), y)))))) {\r\n                mstore(0x00, 0xad251c27) // `MulDivFailed()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n            z := add(iszero(iszero(mod(mul(x, y), d))), div(mul(x, y), d))\r\n        }\r\n    }\r\n\r\n    /// @dev Returns `ceil(x / d)`.\r\n    /// Reverts if `d` is zero.\r\n    function divUp(uint256 x, uint256 d) internal pure returns (uint256 z) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            if iszero(d) {\r\n                mstore(0x00, 0x65244e4e) // `DivFailed()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n            z := add(iszero(iszero(mod(x, d))), div(x, d))\r\n        }\r\n    }\r\n\r\n    /// @dev Returns `max(0, x - y)`.\r\n    function zeroFloorSub(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            z := mul(gt(x, y), sub(x, y))\r\n        }\r\n    }\r\n\r\n    /// @dev Exponentiate `x` to `y` by squaring, denominated in base `b`.\r\n    /// Reverts if the computation overflows.\r\n    function rpow(uint256 x, uint256 y, uint256 b) internal pure returns (uint256 z) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            z := mul(b, iszero(y)) // `0 ** 0 = 1`. Otherwise, `0 ** n = 0`.\r\n            if x {\r\n                z := xor(b, mul(xor(b, x), and(y, 1))) // `z = isEven(y) ? scale : x`\r\n                let half := shr(1, b) // Divide `b` by 2.\r\n                // Divide `y` by 2 every iteration.\r\n                for { y := shr(1, y) } y { y := shr(1, y) } {\r\n                    let xx := mul(x, x) // Store x squared.\r\n                    let xxRound := add(xx, half) // Round to the nearest number.\r\n                    // Revert if `xx + half` overflowed, or if `x ** 2` overflows.\r\n                    if or(lt(xxRound, xx), shr(128, x)) {\r\n                        mstore(0x00, 0x49f7642b) // `RPowOverflow()`.\r\n                        revert(0x1c, 0x04)\r\n                    }\r\n                    x := div(xxRound, b) // Set `x` to scaled `xxRound`.\r\n                    // If `y` is odd:\r\n                    if and(y, 1) {\r\n                        let zx := mul(z, x) // Compute `z * x`.\r\n                        let zxRound := add(zx, half) // Round to the nearest number.\r\n                        // If `z * x` overflowed or `zx + half` overflowed:\r\n                        if or(xor(div(zx, x), z), lt(zxRound, zx)) {\r\n                            // Revert if `x` is non-zero.\r\n                            if iszero(iszero(x)) {\r\n                                mstore(0x00, 0x49f7642b) // `RPowOverflow()`.\r\n                                revert(0x1c, 0x04)\r\n                            }\r\n                        }\r\n                        z := div(zxRound, b) // Return properly scaled `zxRound`.\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the square root of `x`.\r\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // `floor(sqrt(2**15)) = 181`. `sqrt(2**15) - 181 = 2.84`.\r\n            z := 181 // The \"correct\" value is 1, but this saves a multiplication later.\r\n\r\n            // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad\r\n            // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.\r\n\r\n            // Let `y = x / 2**r`. We check `y >= 2**(k + 8)`\r\n            // but shift right by `k` bits to ensure that if `x >= 256`, then `y >= 256`.\r\n            let r := shl(7, lt(0xffffffffffffffffffffffffffffffffff, x))\r\n            r := or(r, shl(6, lt(0xffffffffffffffffff, shr(r, x))))\r\n            r := or(r, shl(5, lt(0xffffffffff, shr(r, x))))\r\n            r := or(r, shl(4, lt(0xffffff, shr(r, x))))\r\n            z := shl(shr(1, r), z)\r\n\r\n            // Goal was to get `z*z*y` within a small factor of `x`. More iterations could\r\n            // get y in a tighter range. Currently, we will have y in `[256, 256*(2**16))`.\r\n            // We ensured `y >= 256` so that the relative difference between `y` and `y+1` is small.\r\n            // That's not possible if `x < 256` but we can just verify those cases exhaustively.\r\n\r\n            // Now, `z*z*y <= x < z*z*(y+1)`, and `y <= 2**(16+8)`, and either `y >= 256`, or `x < 256`.\r\n            // Correctness can be checked exhaustively for `x < 256`, so we assume `y >= 256`.\r\n            // Then `z*sqrt(y)` is within `sqrt(257)/sqrt(256)` of `sqrt(x)`, or about 20bps.\r\n\r\n            // For `s` in the range `[1/256, 256]`, the estimate `f(s) = (181/1024) * (s+1)`\r\n            // is in the range `(1/2.84 * sqrt(s), 2.84 * sqrt(s))`,\r\n            // with largest error when `s = 1` and when `s = 256` or `1/256`.\r\n\r\n            // Since `y` is in `[256, 256*(2**16))`, let `a = y/65536`, so that `a` is in `[1/256, 256)`.\r\n            // Then we can estimate `sqrt(y)` using\r\n            // `sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2**18`.\r\n\r\n            // There is no overflow risk here since `y < 2**136` after the first branch above.\r\n            z := shr(18, mul(z, add(shr(r, x), 65536))) // A `mul()` is saved from starting `z` at 181.\r\n\r\n            // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.\r\n            z := shr(1, add(z, div(x, z)))\r\n            z := shr(1, add(z, div(x, z)))\r\n            z := shr(1, add(z, div(x, z)))\r\n            z := shr(1, add(z, div(x, z)))\r\n            z := shr(1, add(z, div(x, z)))\r\n            z := shr(1, add(z, div(x, z)))\r\n            z := shr(1, add(z, div(x, z)))\r\n\r\n            // If `x+1` is a perfect square, the Babylonian method cycles between\r\n            // `floor(sqrt(x))` and `ceil(sqrt(x))`. This statement ensures we return floor.\r\n            // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division\r\n            z := sub(z, lt(div(x, z), z))\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the cube root of `x`.\r\n    /// Credit to bout3fiddy and pcaversaccio under AGPLv3 license:\r\n    /// https://github.com/pcaversaccio/snekmate/blob/main/src/utils/Math.vy\r\n    function cbrt(uint256 x) internal pure returns (uint256 z) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\r\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\r\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\r\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\r\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\r\n\r\n            z := div(shl(div(r, 3), shl(lt(0xf, shr(r, x)), 0xf)), xor(7, mod(r, 3)))\r\n\r\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\r\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\r\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\r\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\r\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\r\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\r\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\r\n\r\n            z := sub(z, lt(div(x, mul(z, z)), z))\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the square root of `x`, denominated in `WAD`.\r\n    function sqrtWad(uint256 x) internal pure returns (uint256 z) {\r\n        unchecked {\r\n            z = 10 ** 9;\r\n            if (x <= type(uint256).max / 10 ** 36 - 1) {\r\n                x *= 10 ** 18;\r\n                z = 1;\r\n            }\r\n            z *= sqrt(x);\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the cube root of `x`, denominated in `WAD`.\r\n    function cbrtWad(uint256 x) internal pure returns (uint256 z) {\r\n        unchecked {\r\n            z = 10 ** 12;\r\n            if (x <= (type(uint256).max / 10 ** 36) * 10 ** 18 - 1) {\r\n                if (x >= type(uint256).max / 10 ** 36) {\r\n                    x *= 10 ** 18;\r\n                    z = 10 ** 6;\r\n                } else {\r\n                    x *= 10 ** 36;\r\n                    z = 1;\r\n                }\r\n            }\r\n            z *= cbrt(x);\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the factorial of `x`.\r\n    function factorial(uint256 x) internal pure returns (uint256 result) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            if iszero(lt(x, 58)) {\r\n                mstore(0x00, 0xaba0f2a2) // `FactorialOverflow()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n            for { result := 1 } x { x := sub(x, 1) } { result := mul(result, x) }\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the log2 of `x`.\r\n    /// Equivalent to computing the index of the most significant bit (MSB) of `x`.\r\n    /// Returns 0 if `x` is zero.\r\n    function log2(uint256 x) internal pure returns (uint256 r) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\r\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\r\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\r\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\r\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\r\n            r := or(r, shl(2, lt(0xf, shr(r, x))))\r\n            r := or(r, byte(shr(r, x), hex\"00000101020202020303030303030303\"))\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the log2 of `x`, rounded up.\r\n    /// Returns 0 if `x` is zero.\r\n    function log2Up(uint256 x) internal pure returns (uint256 r) {\r\n        r = log2(x);\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            r := add(r, lt(shl(r, 1), x))\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the log10 of `x`.\r\n    /// Returns 0 if `x` is zero.\r\n    function log10(uint256 x) internal pure returns (uint256 r) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            if iszero(lt(x, 100000000000000000000000000000000000000)) {\r\n                x := div(x, 100000000000000000000000000000000000000)\r\n                r := 38\r\n            }\r\n            if iszero(lt(x, 100000000000000000000)) {\r\n                x := div(x, 100000000000000000000)\r\n                r := add(r, 20)\r\n            }\r\n            if iszero(lt(x, 10000000000)) {\r\n                x := div(x, 10000000000)\r\n                r := add(r, 10)\r\n            }\r\n            if iszero(lt(x, 100000)) {\r\n                x := div(x, 100000)\r\n                r := add(r, 5)\r\n            }\r\n            r := add(r, add(gt(x, 9), add(gt(x, 99), add(gt(x, 999), gt(x, 9999)))))\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the log10 of `x`, rounded up.\r\n    /// Returns 0 if `x` is zero.\r\n    function log10Up(uint256 x) internal pure returns (uint256 r) {\r\n        r = log10(x);\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            r := add(r, lt(exp(10, r), x))\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the log256 of `x`.\r\n    /// Returns 0 if `x` is zero.\r\n    function log256(uint256 x) internal pure returns (uint256 r) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\r\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\r\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\r\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\r\n            r := or(shr(3, r), lt(0xff, shr(r, x)))\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the log256 of `x`, rounded up.\r\n    /// Returns 0 if `x` is zero.\r\n    function log256Up(uint256 x) internal pure returns (uint256 r) {\r\n        r = log256(x);\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            r := add(r, lt(shl(shl(3, r), 1), x))\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the average of `x` and `y`.\r\n    function avg(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        unchecked {\r\n            z = (x & y) + ((x ^ y) >> 1);\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the average of `x` and `y`.\r\n    function avg(int256 x, int256 y) internal pure returns (int256 z) {\r\n        unchecked {\r\n            z = (x >> 1) + (y >> 1) + (((x & 1) + (y & 1)) >> 1);\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the absolute value of `x`.\r\n    function abs(int256 x) internal pure returns (uint256 z) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            z := xor(sub(0, shr(255, x)), add(sub(0, shr(255, x)), x))\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the absolute distance between `x` and `y`.\r\n    function dist(int256 x, int256 y) internal pure returns (uint256 z) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            z := xor(mul(xor(sub(y, x), sub(x, y)), sgt(x, y)), sub(y, x))\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the minimum of `x` and `y`.\r\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            z := xor(x, mul(xor(x, y), lt(y, x)))\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the minimum of `x` and `y`.\r\n    function min(int256 x, int256 y) internal pure returns (int256 z) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            z := xor(x, mul(xor(x, y), slt(y, x)))\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the maximum of `x` and `y`.\r\n    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            z := xor(x, mul(xor(x, y), gt(y, x)))\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the maximum of `x` and `y`.\r\n    function max(int256 x, int256 y) internal pure returns (int256 z) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            z := xor(x, mul(xor(x, y), sgt(y, x)))\r\n        }\r\n    }\r\n\r\n    /// @dev Returns `x`, bounded to `minValue` and `maxValue`.\r\n    function clamp(uint256 x, uint256 minValue, uint256 maxValue)\r\n        internal\r\n        pure\r\n        returns (uint256 z)\r\n    {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            z := xor(x, mul(xor(x, minValue), gt(minValue, x)))\r\n            z := xor(z, mul(xor(z, maxValue), lt(maxValue, z)))\r\n        }\r\n    }\r\n\r\n    /// @dev Returns `x`, bounded to `minValue` and `maxValue`.\r\n    function clamp(int256 x, int256 minValue, int256 maxValue) internal pure returns (int256 z) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            z := xor(x, mul(xor(x, minValue), sgt(minValue, x)))\r\n            z := xor(z, mul(xor(z, maxValue), slt(maxValue, z)))\r\n        }\r\n    }\r\n\r\n    /// @dev Returns greatest common divisor of `x` and `y`.\r\n    function gcd(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            for { z := x } y {} {\r\n                let t := y\r\n                y := mod(z, y)\r\n                z := t\r\n            }\r\n        }\r\n    }\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                   RAW NUMBER OPERATIONS                    */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev Returns `x + y`, without checking for overflow.\r\n    function rawAdd(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        unchecked {\r\n            z = x + y;\r\n        }\r\n    }\r\n\r\n    /// @dev Returns `x + y`, without checking for overflow.\r\n    function rawAdd(int256 x, int256 y) internal pure returns (int256 z) {\r\n        unchecked {\r\n            z = x + y;\r\n        }\r\n    }\r\n\r\n    /// @dev Returns `x - y`, without checking for underflow.\r\n    function rawSub(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        unchecked {\r\n            z = x - y;\r\n        }\r\n    }\r\n\r\n    /// @dev Returns `x - y`, without checking for underflow.\r\n    function rawSub(int256 x, int256 y) internal pure returns (int256 z) {\r\n        unchecked {\r\n            z = x - y;\r\n        }\r\n    }\r\n\r\n    /// @dev Returns `x * y`, without checking for overflow.\r\n    function rawMul(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        unchecked {\r\n            z = x * y;\r\n        }\r\n    }\r\n\r\n    /// @dev Returns `x * y`, without checking for overflow.\r\n    function rawMul(int256 x, int256 y) internal pure returns (int256 z) {\r\n        unchecked {\r\n            z = x * y;\r\n        }\r\n    }\r\n\r\n    /// @dev Returns `x / y`, returning 0 if `y` is zero.\r\n    function rawDiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            z := div(x, y)\r\n        }\r\n    }\r\n\r\n    /// @dev Returns `x / y`, returning 0 if `y` is zero.\r\n    function rawSDiv(int256 x, int256 y) internal pure returns (int256 z) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            z := sdiv(x, y)\r\n        }\r\n    }\r\n\r\n    /// @dev Returns `x % y`, returning 0 if `y` is zero.\r\n    function rawMod(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            z := mod(x, y)\r\n        }\r\n    }\r\n\r\n    /// @dev Returns `x % y`, returning 0 if `y` is zero.\r\n    function rawSMod(int256 x, int256 y) internal pure returns (int256 z) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            z := smod(x, y)\r\n        }\r\n    }\r\n\r\n    /// @dev Returns `(x + y) % d`, return 0 if `d` if zero.\r\n    function rawAddMod(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            z := addmod(x, y, d)\r\n        }\r\n    }\r\n\r\n    /// @dev Returns `(x * y) % d`, return 0 if `d` if zero.\r\n    function rawMulMod(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            z := mulmod(x, y, d)\r\n        }\r\n    }\r\n}\r\n\r\ninterface ILocker {\r\n    function claimRewards(address _rewardToken, address _recipient) external;\r\n\r\n    function execute(address _to, uint256 _value, bytes calldata _data) external returns (bool, bytes memory);\r\n\r\n    function increaseAmount(uint256 _amount) external;\r\n\r\n    function increaseUnlockTime(uint256 _time) external;\r\n\r\n    function release() external;\r\n\r\n    function release(address _recipient) external;\r\n\r\n    function setGovernance(address _gov) external;\r\n\r\n    function setStrategy(address _strategy) external;\r\n\r\n    function governance() external view returns (address);\r\n}\r\n\r\nlibrary SafeExecute {\r\n    error CALL_FAILED();\r\n\r\n    function safeExecute(ILocker locker, address to, uint256 value, bytes memory data)\r\n        internal\r\n        returns (bool success)\r\n    {\r\n        (success,) = locker.execute(to, value, data);\r\n    }\r\n}\r\n\r\ninterface ILiquidityGauge {\r\n    struct Reward {\r\n        address token;\r\n        address distributor;\r\n        uint256 period_finish;\r\n        uint256 rate;\r\n        uint256 last_update;\r\n        uint256 integral;\r\n    }\r\n\r\n    function deposit_reward_token(address _rewardToken, uint256 _amount) external;\r\n\r\n    function claim_rewards_for(address _user, address _recipient) external;\r\n\r\n    function working_balances(address _address) external view returns (uint256);\r\n\r\n    function deposit(uint256 _value, address _addr) external;\r\n\r\n    function reward_tokens(uint256 _i) external view returns (address);\r\n\r\n    function reward_data(address _tokenReward) external view returns (Reward memory);\r\n\r\n    function balanceOf(address) external view returns (uint256);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function claimable_reward(address _user, address _reward_token) external view returns (uint256);\r\n\r\n    function claimable_tokens(address _user) external returns (uint256);\r\n\r\n    function user_checkpoint(address _user) external returns (bool);\r\n\r\n    function commit_transfer_ownership(address) external;\r\n\r\n    function apply_transfer_ownership() external;\r\n\r\n    function claim_rewards(address) external;\r\n\r\n    function add_reward(address, address) external;\r\n\r\n    function set_claimer(address) external;\r\n\r\n    function admin() external view returns (address);\r\n\r\n    function lp_token() external view returns (address);\r\n\r\n    function set_reward_distributor(address _rewardToken, address _newDistrib) external;\r\n\r\n    function initialize(\r\n        address staking_token,\r\n        address admin,\r\n        address SDT,\r\n        address voting_escrow,\r\n        address veBoost_proxy,\r\n        address distributor\r\n    ) external;\r\n}\r\n\r\n/// @notice Main access point of the locker.\r\n/// @dev Is Upgradable.\r\nabstract contract Strategy is UUPSUpgradeable {\r\n    using SafeExecute for ILocker;\r\n    using SafeTransferLib for ERC20;\r\n    using FixedPointMathLib for uint256;\r\n\r\n    /// @notice Denominator for fixed point math.\r\n    uint256 public constant DENOMINATOR = 10_000;\r\n\r\n    /// @notice Address of the locker contract.\r\n    ILocker public immutable locker;\r\n\r\n    /// @notice Address of the Voting Escrow contract.\r\n    address public immutable veToken;\r\n\r\n    /// @notice Address of the token being rewarded.\r\n    address public immutable rewardToken;\r\n\r\n    /// @notice Address of the rewardToken Minter.\r\n    /// @dev Eg. CRV Minter.\r\n    address public immutable minter;\r\n\r\n    /// @notice Address of the governance.\r\n    address public governance;\r\n\r\n    /// @notice Address of the future governance contract.\r\n    address public futureGovernance;\r\n\r\n    /// @notice Interface for Stake DAO token Accumulator\r\n    address public accumulator;\r\n\r\n    /// @notice Curve DAO token Fee Distributor\r\n    address public feeDistributor;\r\n\r\n    /// @notice Reward Token for veToken holders.\r\n    address public feeRewardToken;\r\n\r\n    /// @notice Stake DAO SDT Distributor\r\n    address public SDTDistributor;\r\n\r\n    /// @notice Address of the factory.\r\n    address public factory;\r\n\r\n    /// @notice Address accruing protocol fees.\r\n    address public feeReceiver;\r\n\r\n    /// @notice Percentage of fees charged on `rewardToken` claimed.\r\n    uint256 public protocolFeesPercent;\r\n\r\n    /// @notice Amount of fees charged on `rewardToken` claimed\r\n    uint256 public feesAccrued;\r\n\r\n    /// @notice Percentage of fees charged on `rewardToken` claimed to incentivize claimers.\r\n    uint256 public claimIncentiveFee;\r\n\r\n    /// @notice Map vaults address -> is vault active\r\n    mapping(address => bool) public vaults;\r\n\r\n    /// @notice Map `_asset_`to corresponding liquidity gauge.\r\n    mapping(address => address) public gauges;\r\n\r\n    /// @notice Map liquidity gauge address -> gauge type (0,1,2,3).\r\n    mapping(address => uint256) public lGaugeType;\r\n\r\n    /// @notice Map native liquidity gauge to Stake DAO Reward Distributor.\r\n    mapping(address => address) public rewardDistributors;\r\n\r\n    /// @notice Map addresses allowed to interact with the `execute` function.\r\n    mapping(address => bool) public allowed;\r\n\r\n    ////////////////////////////////////////////////////////////////\r\n    /// --- EVENTS & ERRORS\r\n    ///////////////////////////////////////////////////////////////\r\n\r\n    /// @notice Event emitted when governance is changed.\r\n    /// @param newGovernance Address of the new governance.\r\n    event GovernanceChanged(address indexed newGovernance);\r\n\r\n    /// @notice Error emitted when input address is null\r\n    error ADDRESS_NULL();\r\n\r\n    /// @notice Error emitted when low level call failed\r\n    error LOW_LEVEL_CALL_FAILED();\r\n\r\n    /// @notice Error emitted when sum of fees is above 100%\r\n    error FEE_TOO_HIGH();\r\n\r\n    /// @notice Error emitted when auth failed\r\n    error GOVERNANCE();\r\n\r\n    /// @notice Error emitted when auth failed\r\n    error UNAUTHORIZED();\r\n\r\n    /// @notice Error emitted when auth failed\r\n    error GOVERNANCE_OR_FACTORY();\r\n\r\n    /// @notice Error emitted when trying to allow an EOA.\r\n    error NOT_CONTRACT();\r\n\r\n    //////////////////////////////////////////////////////\r\n    /// --- CONSTRUCTOR\r\n    //////////////////////////////////////////////////////\r\n\r\n    constructor(address owner, address _locker, address _veToken, address _rewardToken, address _minter) {\r\n        governance = owner;\r\n\r\n        minter = _minter;\r\n        veToken = _veToken;\r\n        locker = ILocker(_locker);\r\n        rewardToken = _rewardToken;\r\n    }\r\n\r\n    /// @notice Initialize the strategy.\r\n    /// @param owner Address of the owner.\r\n    /// @dev The implementation should not be initalized since the constructor already define the governance.\r\n    function initialize(address owner) external virtual {\r\n        if (governance != address(0)) revert GOVERNANCE();\r\n        governance = owner;\r\n\r\n        /// Initialize the SDT Distributor.\r\n        SDTDistributor = 0x9C99dffC1De1AfF7E7C1F36fCdD49063A281e18C;\r\n    }\r\n\r\n    //////////////////////////////////////////////////////\r\n    /// --- MODIFIERS\r\n    //////////////////////////////////////////////////////\r\n\r\n    modifier onlyVault() {\r\n        if (!vaults[msg.sender]) revert UNAUTHORIZED();\r\n        _;\r\n    }\r\n\r\n    modifier onlyGovernance() {\r\n        if (msg.sender != governance) revert GOVERNANCE();\r\n        _;\r\n    }\r\n\r\n    modifier onlyGovernanceOrAllowed() {\r\n        if (msg.sender != governance && !allowed[msg.sender]) revert UNAUTHORIZED();\r\n        _;\r\n    }\r\n\r\n    modifier onlyGovernanceOrFactory() {\r\n        if (msg.sender != governance && msg.sender != factory) revert GOVERNANCE_OR_FACTORY();\r\n        _;\r\n    }\r\n\r\n    //////////////////////////////////////////////////////\r\n    /// --- DEPOSIT / WITHDRAWAL LOGIC\r\n    //////////////////////////////////////////////////////\r\n\r\n    /// @notice Deposit LP token.\r\n    /// @param asset Address of LP token to deposit.\r\n    /// @param amount Amount of LP token to deposit.\r\n    /// @dev Only callable by approved vaults.\r\n    function deposit(address asset, uint256 amount) external onlyVault {\r\n        // Transfer the token to this contract.\r\n        SafeTransferLib.safeTransferFrom(asset, msg.sender, address(this), amount);\r\n\r\n        /// Deposit the token in the locker.\r\n        _deposit(asset, amount);\r\n    }\r\n\r\n    /// @notice Withdraw LP token.\r\n    /// @param asset Address of LP token to withdraw.\r\n    /// @param amount Amount of LP token to withdraw.\r\n    /// @dev Only callable by approved vaults.\r\n    function withdraw(address asset, uint256 amount) external onlyVault {\r\n        /// Withdraw from the locker.\r\n        _withdraw(asset, amount);\r\n\r\n        /// Transfer the token to the vault.\r\n        SafeTransferLib.safeTransfer(asset, msg.sender, amount);\r\n    }\r\n\r\n    //////////////////////////////////////////////////////\r\n    /// --- LOCKER FUNCTIONS\r\n    //////////////////////////////////////////////////////\r\n\r\n    /// @notice Deposit into the gauge trhoug the Locker.\r\n    /// @param asset Address of LP token to deposit.\r\n    /// @param gauge Address of Liqudity gauge corresponding to LP token.\r\n    /// @param amount Amount of LP token to deposit.\r\n    function _depositIntoLocker(address asset, address gauge, uint256 amount) internal virtual {\r\n        /// Transfer the LP token to the Locker.\r\n        SafeTransferLib.safeTransfer(asset, address(locker), amount);\r\n\r\n        /// Deposit into the Gauge trough the Locker.\r\n        locker.execute(gauge, 0, abi.encodeWithSignature(\"deposit(uint256)\", amount));\r\n    }\r\n\r\n    /// @notice Withdraw from the gauge trhoug the Locker.\r\n    /// @param asset Address of LP token to withdraw.\r\n    /// @param gauge Address of Liqudity gauge corresponding to LP token.\r\n    /// @param amount Amount of LP token to withdraw.\r\n    function _withdrawFromLocker(address asset, address gauge, uint256 amount) internal virtual {\r\n        /// Withdraw from the Gauge trough the Locker.\r\n        locker.execute(gauge, 0, abi.encodeWithSignature(\"withdraw(uint256)\", amount));\r\n\r\n        /// Transfer the _asset_ from the Locker to this contract.\r\n        _transferFromLocker(asset, address(this), amount);\r\n    }\r\n\r\n    //////////////////////////////////////////////////////\r\n    /// --- CLAIM & DISTRIBUTION LOGIC\r\n    //////////////////////////////////////////////////////\r\n\r\n    /// @notice Claim `FeeRewardToken` from the Fee Distributor and send it to the Accumulator contract.\r\n    function claimNativeRewards() external {\r\n        /// Claim from the Fee Distributor.\r\n        _claimNativeRewards();\r\n    }\r\n\r\n    /// @notice Harvest rewards from the gauge trhoug the Locker.\r\n    /// @param asset Address of LP token to harvest.\r\n    /// @param distributeSDT Boolean indicating if SDT should be distributed to the rewarDistributor.\r\n    /// @dev distributeSDT Should be called only if the rewardDistributor is valid to receive SDT inflation.\r\n    /// @param claimExtra Boolean indicating if extra rewards should be claimed from the Locker.\r\n    function harvest(address asset, bool distributeSDT, bool claimExtra) public virtual {\r\n        /// If the _asset is valid, it should be mapped to a gauge.\r\n        address gauge = gauges[asset];\r\n        if (gauge == address(0)) revert ADDRESS_NULL();\r\n\r\n        /// Cache the rewardDistributor address.\r\n        address rewardDistributor = rewardDistributors[gauge];\r\n\r\n        /// 1. Claim `rewardToken` from the Gauge.\r\n        uint256 claimed = _claimRewardToken(gauge);\r\n\r\n        /// 2. Distribute SDT\r\n        // Distribute SDT to the related gauge\r\n        if (distributeSDT) {\r\n            ISDTDistributor(SDTDistributor).distribute(rewardDistributor);\r\n        }\r\n\r\n        /// 3. Check for additional rewards from the Locker.\r\n        /// If there's the `rewardToken` as extra reward, we add it to the `_claimed` amount in order to distribute it only\r\n        /// once.\r\n        if (claimExtra) {\r\n            claimed += _claimExtraRewards(gauge, rewardDistributor);\r\n        }\r\n\r\n        /// 4. Take Fees from _claimed amount.\r\n        claimed -= (_chargeProtocolFees(claimed) + _distributeClaimIncentive(claimed));\r\n\r\n        /// 5. Distribute the rewardToken.\r\n        ILiquidityGauge(rewardDistributor).deposit_reward_token(rewardToken, claimed);\r\n    }\r\n\r\n    //////////////////////////////////////////////////////\r\n    /// --- PROTOCOL FEES ACCOUNTING\r\n    //////////////////////////////////////////////////////\r\n\r\n    /// @notice Claim protocol fees and send them to the fee receiver.\r\n    function claimProtocolFees() external {\r\n        if (feesAccrued == 0) return;\r\n        if (feeReceiver == address(0)) revert ADDRESS_NULL();\r\n\r\n        uint256 _feesAccrued = feesAccrued;\r\n        feesAccrued = 0;\r\n\r\n        SafeTransferLib.safeTransfer(rewardToken, feeReceiver, _feesAccrued);\r\n    }\r\n\r\n    /// @notice Internal function to charge protocol fees from `rewardToken` claimed by the locker.\r\n    /// @return _amount Amount left after charging protocol fees.\r\n    function _chargeProtocolFees(uint256 amount) internal returns (uint256) {\r\n        if (amount == 0 || protocolFeesPercent == 0) return 0;\r\n\r\n        uint256 _feeAccrued = amount.mulDiv(protocolFeesPercent, DENOMINATOR);\r\n        feesAccrued += _feeAccrued;\r\n\r\n        return _feeAccrued;\r\n    }\r\n\r\n    /// @notice Distribute claim incentive to the claimer to incentivize claiming.\r\n    /// @return _amount Amount left after distributing claim incentive.\r\n    function _distributeClaimIncentive(uint256 amount) internal returns (uint256) {\r\n        if (amount == 0 || claimIncentiveFee == 0) return 0;\r\n\r\n        uint256 claimerIncentive = amount.mulDiv(claimIncentiveFee, DENOMINATOR);\r\n\r\n        SafeTransferLib.safeTransfer(rewardToken, msg.sender, claimerIncentive);\r\n\r\n        return claimerIncentive;\r\n    }\r\n\r\n    //////////////////////////////////////////////////////\r\n    /// --- INTERNAL DEPOSIT / WITHDRAWAL IMPLEMENTATIONS\r\n    //////////////////////////////////////////////////////\r\n\r\n    /// @notice Deposit LP token.\r\n    /// @param asset Address of LP token to deposit.\r\n    /// @param amount Amount of LP token to deposit.\r\n    function _deposit(address asset, uint256 amount) internal virtual {\r\n        address gauge = gauges[asset];\r\n        if (gauge == address(0)) revert ADDRESS_NULL();\r\n\r\n        _depositIntoLocker(asset, gauge, amount);\r\n    }\r\n\r\n    /// @notice Withdraw LP token.\r\n    /// @param token Address of LP token to withdraw.\r\n    /// @param amount Amount of LP token to withdraw.\r\n    function _withdraw(address token, uint256 amount) internal virtual {\r\n        address gauge = gauges[token];\r\n        if (gauge == address(0)) revert ADDRESS_NULL();\r\n\r\n        _withdrawFromLocker(token, gauge, amount);\r\n    }\r\n\r\n    //////////////////////////////////////////////////////\r\n    /// --- INTERNAL CLAIM IMPLEMENTATIONS\r\n    //////////////////////////////////////////////////////\r\n\r\n    /// @notice Internal implementation of native reward claim compatible with FeeDistributor.vy like contracts.\r\n    function _claimNativeRewards() internal virtual {\r\n        locker.execute(feeDistributor, 0, abi.encodeWithSignature(\"claim()\"));\r\n\r\n        /// Check if there is something to send.\r\n        uint256 _claimed = ERC20(feeRewardToken).balanceOf(address(locker));\r\n        if (_claimed == 0) return;\r\n\r\n        /// Transfer the rewards to the Accumulator contract.\r\n        _transferFromLocker(feeRewardToken, accumulator, _claimed);\r\n    }\r\n\r\n    /// @notice Claim `rewardToken` allocated for a gauge.\r\n    /// @param gauge Address of the liquidity gauge to claim for.\r\n    function _claimRewardToken(address gauge) internal virtual returns (uint256 _claimed) {\r\n        /// Snapshot before claim.\r\n        uint256 _snapshotBalance = ERC20(rewardToken).balanceOf(address(locker));\r\n\r\n        /// Claim.\r\n        locker.execute(minter, 0, abi.encodeWithSignature(\"mint(address)\", gauge));\r\n\r\n        /// Snapshot after claim.\r\n        _claimed = ERC20(rewardToken).balanceOf(address(locker)) - _snapshotBalance;\r\n\r\n        /// Transfer the claimed amount to this contract.\r\n        _transferFromLocker(rewardToken, address(this), _claimed);\r\n    }\r\n\r\n    /// @notice Claim extra rewards from the locker.\r\n    /// @param gauge Address of the liquidity gauge to claim from.\r\n    /// @param rewardDistributor Address of the reward distributor to distribute the extra rewards to.\r\n    /// @return _rewardTokenClaimed Amount of `rewardToken` claimed.\r\n    /// @dev If `rewardToken` is an extra reward, it will be added to the `_rewardTokenClaimed` amount to avoid double distribution.\r\n    function _claimExtraRewards(address gauge, address rewardDistributor)\r\n        internal\r\n        virtual\r\n        returns (uint256 _rewardTokenClaimed)\r\n    {\r\n        /// If the gauge doesn't support extra rewards, skip.\r\n        if (lGaugeType[gauge] > 0) return 0;\r\n\r\n        // Cache the reward tokens and their balance before locker\r\n        address[8] memory extraRewardTokens;\r\n        uint256[8] memory snapshotLockerRewardBalances;\r\n\r\n        uint8 i;\r\n        address extraRewardToken;\r\n        /// There can be up to 8 extra reward tokens.\r\n        for (i; i < 8;) {\r\n            /// Get extra reward token address.\r\n            extraRewardToken = ILiquidityGauge(gauge).reward_tokens(i);\r\n            if (extraRewardToken == address(0)) break;\r\n\r\n            // Add the reward token address on the array\r\n            extraRewardTokens[i] = extraRewardToken;\r\n            // Add the reward token balance ot the locker on the array\r\n            snapshotLockerRewardBalances[i] = ERC20(extraRewardToken).balanceOf(address(locker));\r\n\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        }\r\n\r\n        /// There's two ways to claim extra rewards:\r\n        /// 1. Call claim_rewards on the gauge with the strategy as receiver.\r\n        /// 2. Call claim_rewards on the gauge with the locker as receiver, then transfer the rewards from the locker to the strategy.\r\n        /// 1 is not supported by all gauges, so we try to call it first, and if it fails, we fallback to 2.\r\n        (bool isRewardReceived,) = locker.execute(\r\n            gauge, 0, abi.encodeWithSignature(\"claim_rewards(address,address)\", address(locker), address(this))\r\n        );\r\n\r\n        if (!isRewardReceived) {\r\n            ILiquidityGauge(gauge).claim_rewards(address(locker));\r\n        }\r\n\r\n        for (i = 0; i < 8;) {\r\n            extraRewardToken = extraRewardTokens[i];\r\n            if (extraRewardToken == address(0)) break;\r\n            uint256 claimed;\r\n            if (!isRewardReceived) {\r\n                claimed = ERC20(extraRewardToken).balanceOf(address(locker)) - snapshotLockerRewardBalances[i];\r\n                if (claimed != 0) {\r\n                    // Transfer the freshly rewards from the locker to this contract.\r\n                    _transferFromLocker(extraRewardToken, address(this), claimed);\r\n                }\r\n            }\r\n\r\n            if (extraRewardToken == rewardToken) {\r\n                _rewardTokenClaimed += claimed;\r\n            } else {\r\n                claimed = ERC20(extraRewardToken).balanceOf(address(this));\r\n                if (claimed != 0) {\r\n                    // Distribute the extra reward token.\r\n                    ILiquidityGauge(rewardDistributor).deposit_reward_token(extraRewardToken, claimed);\r\n                }\r\n            }\r\n\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        }\r\n    }\r\n\r\n    //////////////////////////////////////////////////////\r\n    /// --- VIEW FUNCTIONS\r\n    //////////////////////////////////////////////////////\r\n\r\n    function balanceOf(address asset) public view virtual returns (uint256) {\r\n        // Get the gauge address\r\n        address gauge = gauges[asset];\r\n        if (gauge == address(0)) revert ADDRESS_NULL();\r\n\r\n        return ILiquidityGauge(gauge).balanceOf(address(locker));\r\n    }\r\n\r\n    //////////////////////////////////////////////////////\r\n    /// --- INTERNAL HELPER FUNCTIONS\r\n    //////////////////////////////////////////////////////\r\n\r\n    function _transferFromLocker(address asset, address recipient, uint256 amount) internal {\r\n        locker.safeExecute(asset, 0, abi.encodeWithSignature(\"transfer(address,uint256)\", recipient, amount));\r\n    }\r\n\r\n    //////////////////////////////////////////////////////\r\n    /// --- MIGRATION LOGIC\r\n    //////////////////////////////////////////////////////\r\n\r\n    /// @notice If we ever decide to migrate the strategy, we can use this function to migrate the LP token.\r\n    /// @dev Only callable by the vault.\r\n    /// @param asset Address of LP token to migrate.\r\n    /// @dev Built only to support the old implementation of the vault, but it will be killed.\r\n    function migrateLP(address asset) public virtual onlyVault {\r\n        // Get gauge address\r\n        address gauge = gauges[asset];\r\n        if (gauge == address(0)) revert ADDRESS_NULL();\r\n\r\n        // Get the amount of LP token staked in the gauge by the locker\r\n        uint256 amount = ERC20(gauge).balanceOf(address(locker));\r\n\r\n        // Locker withdraw all from the gauge\r\n        locker.safeExecute(gauge, 0, abi.encodeWithSignature(\"withdraw(uint256)\", amount));\r\n\r\n        // Locker transfer the LP token to the vault\r\n        _transferFromLocker(asset, msg.sender, amount);\r\n    }\r\n\r\n    //////////////////////////////////////////////////////\r\n    /// --- FACTORY STRATEGY SETTERS\r\n    //////////////////////////////////////////////////////\r\n\r\n    /// @notice Toogle vault status\r\n    /// @param vault Address of the vault to toggle\r\n    function toggleVault(address vault) external onlyGovernanceOrFactory {\r\n        if (vault == address(0)) revert ADDRESS_NULL();\r\n        vaults[vault] = !vaults[vault];\r\n    }\r\n\r\n    /// @notice Set gauge address for a LP token\r\n    /// @param token Address of LP token corresponding to `gauge`\r\n    /// @param gauge Address of liquidity gauge corresponding to `token`\r\n    function setGauge(address token, address gauge) external onlyGovernanceOrFactory {\r\n        if (token == address(0)) revert ADDRESS_NULL();\r\n        if (gauge == address(0)) revert ADDRESS_NULL();\r\n\r\n        gauges[token] = gauge;\r\n\r\n        /// Approve trough the locker.\r\n        locker.safeExecute(token, 0, abi.encodeWithSignature(\"approve(address,uint256)\", gauge, 0));\r\n        locker.safeExecute(token, 0, abi.encodeWithSignature(\"approve(address,uint256)\", gauge, type(uint256).max));\r\n    }\r\n\r\n    /// @notice Set type for a Liquidity gauge\r\n    /// @param gauge Address of Liquidity gauge\r\n    /// @param gaugeType Type of Liquidity gauge\r\n    function setLGtype(address gauge, uint256 gaugeType) external onlyGovernanceOrFactory {\r\n        if (gauge == address(0)) revert ADDRESS_NULL();\r\n        lGaugeType[gauge] = gaugeType;\r\n    }\r\n\r\n    /// @notice Set rewardDistributor for a Liquidity gauge\r\n    /// @param gauge Address of Liquidity gauge\r\n    /// @param rewardDistributor Address of rewardDistributor\r\n    function setRewardDistributor(address gauge, address rewardDistributor) external onlyGovernanceOrFactory {\r\n        if (gauge == address(0) || rewardDistributor == address(0)) revert ADDRESS_NULL();\r\n        rewardDistributors[gauge] = rewardDistributor;\r\n\r\n        /// Approve the rewardDistributor to spend token.\r\n        SafeTransferLib.safeApproveWithRetry(rewardToken, rewardDistributor, type(uint256).max);\r\n    }\r\n\r\n    /// @notice Accept Reward Distrbutor Ownership.\r\n    /// @dev Gauge need to call this function to accept ownership of the rewardDistributor because ownership is transfered in two steps.\r\n    /// @param rewardDistributor Address of rewardDistributor.\r\n    function acceptRewardDistributorOwnership(address rewardDistributor) external onlyGovernanceOrFactory {\r\n        if (rewardDistributor == address(0)) revert ADDRESS_NULL();\r\n\r\n        (bool success,) = address(rewardDistributor).call(abi.encodeWithSignature(\"accept_transfer_ownership()\"));\r\n        if (!success) revert LOW_LEVEL_CALL_FAILED();\r\n    }\r\n\r\n    //////////////////////////////////////////////////////\r\n    /// --- GOVERNANCE STRATEGY SETTERS\r\n    //////////////////////////////////////////////////////\r\n\r\n    /// @notice Transfer the governance to a new address.\r\n    /// @param _governance Address of the new governance.\r\n    function transferGovernance(address _governance) external onlyGovernance {\r\n        futureGovernance = _governance;\r\n    }\r\n\r\n    /// @notice Accept the governance transfer.\r\n    function acceptGovernance() external {\r\n        if (msg.sender != futureGovernance) revert GOVERNANCE();\r\n\r\n        governance = msg.sender;\r\n        emit GovernanceChanged(msg.sender);\r\n    }\r\n\r\n    /// @notice Set Accumulator new address\r\n    /// @param newAccumulator Address of new Accumulator\r\n    function setAccumulator(address newAccumulator) external onlyGovernance {\r\n        if (newAccumulator == address(0)) revert ADDRESS_NULL();\r\n        accumulator = newAccumulator;\r\n    }\r\n\r\n    /// @notice Set Factory address.\r\n    /// @param _factory Address of new Accumulator\r\n    function setFactory(address _factory) external onlyGovernance {\r\n        if (_factory == address(0)) revert ADDRESS_NULL();\r\n\r\n        /// Remove allocation for the old factory.\r\n        allowed[factory] = false;\r\n\r\n        factory = _factory;\r\n\r\n        /// Allow the factory to interact with this contract.\r\n        allowed[_factory] = true;\r\n    }\r\n\r\n    /// @notice Set new RewardToken FeeDistributor new address\r\n    /// @param newCurveRewardToken Address of new Accumulator\r\n    function setFeeRewardToken(address newCurveRewardToken) external onlyGovernance {\r\n        if (newCurveRewardToken == address(0)) revert ADDRESS_NULL();\r\n        feeRewardToken = newCurveRewardToken;\r\n    }\r\n\r\n    /// @notice Set FeeDistributor new address\r\n    /// @param newFeeDistributor Address of new Accumulator\r\n    function setFeeDistributor(address newFeeDistributor) external onlyGovernance {\r\n        if (newFeeDistributor == address(0)) revert ADDRESS_NULL();\r\n        feeDistributor = newFeeDistributor;\r\n    }\r\n\r\n    /// @notice Set SdtDistributor new address\r\n    /// @param newSdtDistributor Address of new SdtDistributor\r\n    function setSdtDistributor(address newSdtDistributor) external onlyGovernance {\r\n        if (newSdtDistributor == address(0)) revert ADDRESS_NULL();\r\n        SDTDistributor = newSdtDistributor;\r\n    }\r\n\r\n    /// @notice Set FeeReceiver new address.\r\n    /// @param _feeReceiver Address of new FeeReceiver.\r\n    function setFeeReceiver(address _feeReceiver) external onlyGovernance {\r\n        if (_feeReceiver == address(0)) revert ADDRESS_NULL();\r\n        feeReceiver = _feeReceiver;\r\n    }\r\n\r\n    /// @notice Update protocol fees.\r\n    /// @param protocolFee New protocol fee.\r\n    function updateProtocolFee(uint256 protocolFee) external onlyGovernance {\r\n        if (claimIncentiveFee + protocolFee > DENOMINATOR) revert FEE_TOO_HIGH();\r\n        protocolFeesPercent = protocolFee;\r\n    }\r\n\r\n    /// @notice Update claimIncentive fees.\r\n    /// @param _claimIncentiveFee New Claim Incentive Fees\r\n    function updateClaimIncentiveFee(uint256 _claimIncentiveFee) external onlyGovernance {\r\n        if (protocolFeesPercent + _claimIncentiveFee > DENOMINATOR) revert FEE_TOO_HIGH();\r\n        claimIncentiveFee = _claimIncentiveFee;\r\n    }\r\n\r\n    /// @notice Allow a module to interact with the `execute` function.\r\n    /// @dev excodesize can be bypassed but whitelist should go through governance.\r\n    function allowAddress(address _address) external onlyGovernance {\r\n        if (_address == address(0)) revert ADDRESS_NULL();\r\n\r\n        /// Check if the address is a contract.\r\n        int256 size;\r\n        assembly {\r\n            size := extcodesize(_address)\r\n        }\r\n        if (size == 0) revert NOT_CONTRACT();\r\n\r\n        allowed[_address] = true;\r\n    }\r\n\r\n    /// @notice Disallow a module to interact with the `execute` function.\r\n    function disallowAddress(address _address) external onlyGovernance {\r\n        allowed[_address] = false;\r\n    }\r\n\r\n    //////////////////////////////////////////////////////\r\n    /// --- GOVERNANCE OR ALLOWED FUNCTIONS\r\n    //////////////////////////////////////////////////////\r\n\r\n    /// @notice Add Extra Reward Token to a Liquidity Gauge.\r\n    /// @dev Allowed contract need to do extra checks for the safety of the token to add.\r\n    /// Eg. Check if the token is a gauge token, or if the token is already added, rebasing, in the gauge controller etc.\r\n    function addRewardToken(address gauge, address extraRewardToken) external onlyGovernanceOrAllowed {\r\n        if (gauge == address(0) || extraRewardToken == address(0)) revert ADDRESS_NULL();\r\n\r\n        /// Get the rewardDistributor address to add the reward token to.\r\n        address _rewardDistributor = rewardDistributors[gauge];\r\n\r\n        /// Approve the rewardDistributor to spend token.\r\n        SafeTransferLib.safeApproveWithRetry(extraRewardToken, _rewardDistributor, type(uint256).max);\r\n\r\n        /// Add it to the Gauge with Distributor as this contract.\r\n        ILiquidityGauge(_rewardDistributor).add_reward(extraRewardToken, address(this));\r\n    }\r\n\r\n    /// @notice Execute a function.\r\n    /// @param to Address of the contract to execute.\r\n    /// @param value Value to send to the contract.\r\n    /// @param data Data to send to the contract.\r\n    /// @return success_ Boolean indicating if the execution was successful.\r\n    /// @return result_ Bytes containing the result of the execution.\r\n    function execute(address to, uint256 value, bytes calldata data)\r\n        external\r\n        onlyGovernanceOrAllowed\r\n        returns (bool, bytes memory)\r\n    {\r\n        (bool success, bytes memory result) = to.call{value: value}(data);\r\n        return (success, result);\r\n    }\r\n\r\n    /// UUPS Upgradeability.\r\n    function _authorizeUpgrade(address newImplementation) internal override onlyGovernance {}\r\n\r\n    receive() external payable {}\r\n}\r\n\r\n/// @notice Main access point of Yearn Locker.\r\ncontract YearnStrategy is Strategy {\r\n    using SafeExecute for ILocker;\r\n\r\n    /// @notice Reward Pool Contract to distribute DYFI.\r\n    /// @dev Need to set it at deployment since it's a proxy.\r\n    address public dyfiRewardPool = 0x2391Fc8f5E417526338F5aa3968b1851C16D894E;\r\n\r\n    /// @notice Mapping of Reward Distributors to Reward Receivers.\r\n    mapping(address => address) public rewardReceivers;\r\n\r\n    /// @notice Constructor.\r\n    /// @param _owner Address of the strategy owner.\r\n    /// @param _locker Address of the locker.\r\n    /// @param _veToken Address of the veToken.\r\n    /// @param _rewardToken Address of the reward token.\r\n    /// @param _minter Address of the platform minter.\r\n    constructor(address _owner, address _locker, address _veToken, address _rewardToken, address _minter)\r\n        Strategy(_owner, _locker, _veToken, _rewardToken, _minter)\r\n    {}\r\n\r\n    function claimDYFIRewardPool() external {\r\n        /// Claim dYFI reward from the dYFI reward pool.\r\n        IYearnRewardPool(dyfiRewardPool).claim(address(locker));\r\n\r\n        /// Transfer the whole dYFI locker's amount to the acc.\r\n        _transferFromLocker(rewardToken, accumulator, ERC20(rewardToken).balanceOf(address(locker)));\r\n    }\r\n\r\n    /// @notice Claim `rewardToken` allocated for a gauge.\r\n    /// @param _gauge Address of the liquidity gauge to claim for.\r\n    /// @return _claimed Number of DYFI claimed\r\n    function _claimRewardToken(address _gauge) internal override returns (uint256 _claimed) {\r\n        /// Claim the reward from the yearn gauge.\r\n        IYearnGauge(_gauge).getReward(address(locker));\r\n\r\n        /// Transfer the whole balance here from the reward recipient.\r\n        address rewardReceiver = rewardReceivers[_gauge];\r\n        _claimed = ERC20(rewardToken).balanceOf(rewardReceiver);\r\n\r\n        SafeTransferLib.safeTransferFrom(rewardToken, rewardReceiver, address(this), _claimed);\r\n    }\r\n\r\n    /// @notice Claim extra rewards from the locker.\r\n    function _claimExtraRewards(address, address) internal override returns (uint256) {}\r\n\r\n    /// @notice Internal implementation of native reward claim compatible with FeeDistributor.vy like contracts.\r\n    function _claimNativeRewards() internal override {\r\n        /// Claim YFI from the YFI reward pool.\r\n        locker.claimRewards(feeRewardToken, accumulator);\r\n    }\r\n\r\n    /// @notice Withdraw from the gauge through the Locker.\r\n    /// @param _gauge Address of Liqudity gauge corresponding to LP token.\r\n    /// @param _amount Amount of LP token to withdraw.\r\n    function _withdrawFromLocker(address, address _gauge, uint256 _amount) internal override {\r\n        /// Withdraw from the Gauge trough the Locker.\r\n        locker.safeExecute(\r\n            _gauge,\r\n            0,\r\n            abi.encodeWithSignature(\"withdraw(uint256,address,address)\", _amount, address(this), address(locker))\r\n        );\r\n    }\r\n\r\n    /// @notice Update the reward receiver for a gauge.\r\n    /// @dev Make sure to claim all rewards from the previous receiver before updating.\r\n    function setRewardReceiver(address _gauge, address _rewardReceiver) external onlyGovernanceOrFactory {\r\n        /// Update the reward receiver.\r\n        rewardReceivers[_gauge] = _rewardReceiver;\r\n\r\n        /// Set the reward receiver in the gauge.\r\n        locker.safeExecute(_gauge, 0, abi.encodeWithSignature(\"setRecipient(address)\", address(_rewardReceiver)));\r\n    }\r\n\r\n    /// @notice Set the dYFI reward pool.\r\n    function setDYFIRewardPool(address _dyfiRewardPool) external onlyGovernance {\r\n        dyfiRewardPool = _dyfiRewardPool;\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_locker\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_veToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_rewardToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_minter\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ADDRESS_NULL\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FEE_TOO_HIGH\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"GOVERNANCE\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"GOVERNANCE_OR_FACTORY\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LOW_LEVEL_CALL_FAILED\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NOT_CONTRACT\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UNAUTHORIZED\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnauthorizedCallContext\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UpgradeFailed\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newGovernance\",\"type\":\"address\"}],\"name\":\"GovernanceChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"Upgraded\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DENOMINATOR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SDTDistributor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptGovernance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"rewardDistributor\",\"type\":\"address\"}],\"name\":\"acceptRewardDistributorOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"accumulator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"gauge\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"extraRewardToken\",\"type\":\"address\"}],\"name\":\"addRewardToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"allowAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimDYFIRewardPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimIncentiveFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimNativeRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimProtocolFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"disallowAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dyfiRewardPool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeDistributor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeRewardToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feesAccrued\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"futureGovernance\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"gauges\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governance\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"distributeSDT\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"claimExtra\",\"type\":\"bool\"}],\"name\":\"harvest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lGaugeType\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"locker\",\"outputs\":[{\"internalType\":\"contract ILocker\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"}],\"name\":\"migrateLP\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"protocolFeesPercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proxiableUUID\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"rewardDistributors\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"rewardReceivers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAccumulator\",\"type\":\"address\"}],\"name\":\"setAccumulator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_dyfiRewardPool\",\"type\":\"address\"}],\"name\":\"setDYFIRewardPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"}],\"name\":\"setFactory\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newFeeDistributor\",\"type\":\"address\"}],\"name\":\"setFeeDistributor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeReceiver\",\"type\":\"address\"}],\"name\":\"setFeeReceiver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newCurveRewardToken\",\"type\":\"address\"}],\"name\":\"setFeeRewardToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"gauge\",\"type\":\"address\"}],\"name\":\"setGauge\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"gauge\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"gaugeType\",\"type\":\"uint256\"}],\"name\":\"setLGtype\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"gauge\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rewardDistributor\",\"type\":\"address\"}],\"name\":\"setRewardDistributor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_gauge\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_rewardReceiver\",\"type\":\"address\"}],\"name\":\"setRewardReceiver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newSdtDistributor\",\"type\":\"address\"}],\"name\":\"setSdtDistributor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"}],\"name\":\"toggleVault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_governance\",\"type\":\"address\"}],\"name\":\"transferGovernance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_claimIncentiveFee\",\"type\":\"uint256\"}],\"name\":\"updateClaimIncentiveFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"protocolFee\",\"type\":\"uint256\"}],\"name\":\"updateProtocolFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"}],\"name\":\"upgradeTo\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"upgradeToAndCall\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"vaults\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"veToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "YearnStrategy", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000f930ebbd05ef8b25b1797b9b2109ddc9b0d43063000000000000000000000000f750162fd81f9a436d74d737ef6ee8fc08e9822000000000000000000000000090c1f9220d90d3966fbee24045edd73e1d588ad500000000000000000000000041252e8691e964f7de35156b68493bab6797a2750000000000000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU GPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://d6723d772d19e2ede7b721b5fa9429127aa98845e8bf7a7879ca263d5c09f5ac"}