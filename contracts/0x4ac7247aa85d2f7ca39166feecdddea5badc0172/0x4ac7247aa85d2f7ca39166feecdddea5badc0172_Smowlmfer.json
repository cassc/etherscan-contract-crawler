{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"sha.sol\": {\r\n      \"content\": \"\\r\\n/** \\r\\n *  SourceUnit: c:\\\\Users\\\\chris\\\\Downloads\\\\nftProject\\\\here.sol\\r\\n*/\\r\\n            \\r\\n////// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Provides information about the current execution context, including the\\r\\n * sender of the transaction and its data. While these are generally available\\r\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\r\\n * manner, since when dealing with meta-transactions the account sending and\\r\\n * paying for execution may not be the actual sender (as far as an application\\r\\n * is concerned).\\r\\n *\\r\\n * This contract is only required for intermediate, library-like contracts.\\r\\n */\\r\\nabstract contract Context {\\r\\n    function _msgSender() internal view virtual returns (address) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n\\r\\n    function _msgData() internal view virtual returns (bytes calldata) {\\r\\n        return msg.data;\\r\\n    }\\r\\n}\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n/** \\r\\n *  SourceUnit: c:\\\\Users\\\\chris\\\\Downloads\\\\nftProject\\\\here.sol\\r\\n*/\\r\\n            \\r\\n////// SPDX-License-Identifier-FLATTEN-SUPPRESS-WARNING: MIT\\r\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC165 standard, as defined in the\\r\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\r\\n *\\r\\n * Implementers can declare support of contract interfaces, which can then be\\r\\n * queried by others ({ERC165Checker}).\\r\\n *\\r\\n * For an implementation, see {ERC165}.\\r\\n */\\r\\ninterface IERC165 {\\r\\n    /**\\r\\n     * @dev Returns true if this contract implements the interface defined by\\r\\n     * `interfaceId`. See the corresponding\\r\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\r\\n     * to learn more about how these ids are created.\\r\\n     *\\r\\n     * This function call must use less than 30 000 gas.\\r\\n     */\\r\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\r\\n}\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n/** \\r\\n *  SourceUnit: c:\\\\Users\\\\chris\\\\Downloads\\\\nftProject\\\\here.sol\\r\\n*/\\r\\n            \\r\\n////// SPDX-License-Identifier-FLATTEN-SUPPRESS-WARNING: MIT\\r\\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/IERC1155.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n////import \\\"../../utils/introspection/IERC165.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\r\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\r\\n *\\r\\n * _Available since v3.1._\\r\\n */\\r\\ninterface IERC1155 is IERC165 {\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\\r\\n     */\\r\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\r\\n     * transfers.\\r\\n     */\\r\\n    event TransferBatch(\\r\\n        address indexed operator,\\r\\n        address indexed from,\\r\\n        address indexed to,\\r\\n        uint256[] ids,\\r\\n        uint256[] values\\r\\n    );\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\r\\n     * `approved`.\\r\\n     */\\r\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\r\\n     *\\r\\n     * If an {URI} event was emitted for `id`, the standard\\r\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\r\\n     * returned by {IERC1155MetadataURI-uri}.\\r\\n     */\\r\\n    event URI(string value, uint256 indexed id);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `account` cannot be the zero address.\\r\\n     */\\r\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `accounts` and `ids` must have the same length.\\r\\n     */\\r\\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256[] memory);\\r\\n\\r\\n    /**\\r\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\r\\n     *\\r\\n     * Emits an {ApprovalForAll} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `operator` cannot be the caller.\\r\\n     */\\r\\n    function setApprovalForAll(address operator, bool approved) external;\\r\\n\\r\\n    /**\\r\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\r\\n     *\\r\\n     * See {setApprovalForAll}.\\r\\n     */\\r\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\r\\n     *\\r\\n     * Emits a {TransferSingle} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `to` cannot be the zero address.\\r\\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\r\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\r\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\r\\n     * acceptance magic value.\\r\\n     */\\r\\n    function safeTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 id,\\r\\n        uint256 amount,\\r\\n        bytes calldata data\\r\\n    ) external;\\r\\n\\r\\n    /**\\r\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\r\\n     *\\r\\n     * Emits a {TransferBatch} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `ids` and `amounts` must have the same length.\\r\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\r\\n     * acceptance magic value.\\r\\n     */\\r\\n    function safeBatchTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256[] calldata ids,\\r\\n        uint256[] calldata amounts,\\r\\n        bytes calldata data\\r\\n    ) external;\\r\\n}\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n/** \\r\\n *  SourceUnit: c:\\\\Users\\\\chris\\\\Downloads\\\\nftProject\\\\here.sol\\r\\n*/\\r\\n            \\r\\n////// SPDX-License-Identifier-FLATTEN-SUPPRESS-WARNING: MIT\\r\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n////import \\\"./IERC165.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Implementation of the {IERC165} interface.\\r\\n *\\r\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\r\\n * for the additional interface id that will be supported. For example:\\r\\n *\\r\\n * ```solidity\\r\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\r\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\r\\n * }\\r\\n * ```\\r\\n *\\r\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\r\\n */\\r\\nabstract contract ERC165 is IERC165 {\\r\\n    /**\\r\\n     * @dev See {IERC165-supportsInterface}.\\r\\n     */\\r\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\r\\n        return interfaceId == type(IERC165).interfaceId;\\r\\n    }\\r\\n}\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n/** \\r\\n *  SourceUnit: c:\\\\Users\\\\chris\\\\Downloads\\\\nftProject\\\\here.sol\\r\\n*/\\r\\n            \\r\\n////// SPDX-License-Identifier-FLATTEN-SUPPRESS-WARNING: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\\r\\n\\r\\npragma solidity ^0.8.1;\\r\\n\\r\\n/**\\r\\n * @dev Collection of functions related to the address type\\r\\n */\\r\\nlibrary Address {\\r\\n    /**\\r\\n     * @dev Returns true if `account` is a contract.\\r\\n     *\\r\\n     * [////IMPORTANT]\\r\\n     * ====\\r\\n     * It is unsafe to assume that an address for which this function returns\\r\\n     * false is an externally-owned account (EOA) and not a contract.\\r\\n     *\\r\\n     * Among others, `isContract` will return false for the following\\r\\n     * types of addresses:\\r\\n     *\\r\\n     *  - an externally-owned account\\r\\n     *  - a contract in construction\\r\\n     *  - an address where a contract will be created\\r\\n     *  - an address where a contract lived, but was destroyed\\r\\n     * ====\\r\\n     *\\r\\n     * [IMPORTANT]\\r\\n     * ====\\r\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\r\\n     *\\r\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\r\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\r\\n     * constructor.\\r\\n     * ====\\r\\n     */\\r\\n    function isContract(address account) internal view returns (bool) {\\r\\n        // This method relies on extcodesize/address.code.length, which returns 0\\r\\n        // for contracts in construction, since the code is only stored at the end\\r\\n        // of the constructor execution.\\r\\n\\r\\n        return account.code.length > 0;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\r\\n     * `recipient`, forwarding all available gas and reverting on errors.\\r\\n     *\\r\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\r\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\r\\n     * imposed by `transfer`, making them unable to receive funds via\\r\\n     * `transfer`. {sendValue} removes this limitation.\\r\\n     *\\r\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\r\\n     *\\r\\n     * ////IMPORTANT: because control is transferred to `recipient`, care must be\\r\\n     * taken to not create reentrancy vulnerabilities. Consider using\\r\\n     * {ReentrancyGuard} or the\\r\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\r\\n     */\\r\\n    function sendValue(address payable recipient, uint256 amount) internal {\\r\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\r\\n\\r\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\r\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Performs a Solidity function call using a low level `call`. A\\r\\n     * plain `call` is an unsafe replacement for a function call: use this\\r\\n     * function instead.\\r\\n     *\\r\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\r\\n     * function (like regular Solidity function calls).\\r\\n     *\\r\\n     * Returns the raw returned data. To convert to the expected return value,\\r\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `target` must be a contract.\\r\\n     * - calling `target` with `data` must not revert.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\r\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\r\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCall(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        string memory errorMessage\\r\\n    ) internal returns (bytes memory) {\\r\\n        return functionCallWithValue(target, data, 0, errorMessage);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\r\\n     * but also transferring `value` wei to `target`.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - the calling contract must have an ETH balance of at least `value`.\\r\\n     * - the called Solidity function must be `payable`.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCallWithValue(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        uint256 value\\r\\n    ) internal returns (bytes memory) {\\r\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\r\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCallWithValue(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        uint256 value,\\r\\n        string memory errorMessage\\r\\n    ) internal returns (bytes memory) {\\r\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\r\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\r\\n\\r\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\r\\n        return verifyCallResult(success, returndata, errorMessage);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\r\\n     * but performing a static call.\\r\\n     *\\r\\n     * _Available since v3.3._\\r\\n     */\\r\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\r\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\r\\n     * but performing a static call.\\r\\n     *\\r\\n     * _Available since v3.3._\\r\\n     */\\r\\n    function functionStaticCall(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        string memory errorMessage\\r\\n    ) internal view returns (bytes memory) {\\r\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\r\\n\\r\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\r\\n        return verifyCallResult(success, returndata, errorMessage);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\r\\n     * but performing a delegate call.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\r\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\r\\n     * but performing a delegate call.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function functionDelegateCall(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        string memory errorMessage\\r\\n    ) internal returns (bytes memory) {\\r\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\r\\n\\r\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\r\\n        return verifyCallResult(success, returndata, errorMessage);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\r\\n     * revert reason using the provided one.\\r\\n     *\\r\\n     * _Available since v4.3._\\r\\n     */\\r\\n    function verifyCallResult(\\r\\n        bool success,\\r\\n        bytes memory returndata,\\r\\n        string memory errorMessage\\r\\n    ) internal pure returns (bytes memory) {\\r\\n        if (success) {\\r\\n            return returndata;\\r\\n        } else {\\r\\n            // Look for revert reason and bubble it up if present\\r\\n            if (returndata.length > 0) {\\r\\n                // The easiest way to bubble the revert reason is using memory via assembly\\r\\n\\r\\n                assembly {\\r\\n                    let returndata_size := mload(returndata)\\r\\n                    revert(add(32, returndata), returndata_size)\\r\\n                }\\r\\n            } else {\\r\\n                revert(errorMessage);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n/** \\r\\n *  SourceUnit: c:\\\\Users\\\\chris\\\\Downloads\\\\nftProject\\\\here.sol\\r\\n*/\\r\\n            \\r\\n////// SPDX-License-Identifier-FLATTEN-SUPPRESS-WARNING: MIT\\r\\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/IERC1155MetadataURI.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n////import \\\"../IERC1155.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\\r\\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\\r\\n *\\r\\n * _Available since v3.1._\\r\\n */\\r\\ninterface IERC1155MetadataURI is IERC1155 {\\r\\n    /**\\r\\n     * @dev Returns the URI for token type `id`.\\r\\n     *\\r\\n     * If the `\\\\{id\\\\}` substring is present in the URI, it must be replaced by\\r\\n     * clients with the actual token type ID.\\r\\n     */\\r\\n    function uri(uint256 id) external view returns (string memory);\\r\\n}\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n/** \\r\\n *  SourceUnit: c:\\\\Users\\\\chris\\\\Downloads\\\\nftProject\\\\here.sol\\r\\n*/\\r\\n            \\r\\n////// SPDX-License-Identifier-FLATTEN-SUPPRESS-WARNING: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n////import \\\"../../utils/introspection/IERC165.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev _Available since v3.1._\\r\\n */\\r\\ninterface IERC1155Receiver is IERC165 {\\r\\n    /**\\r\\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\\r\\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\\r\\n     *\\r\\n     * NOTE: To accept the transfer, this must return\\r\\n     * `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\r\\n     * (i.e. 0xf23a6e61, or its own function selector).\\r\\n     *\\r\\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\\r\\n     * @param from The address which previously owned the token\\r\\n     * @param id The ID of the token being transferred\\r\\n     * @param value The amount of tokens being transferred\\r\\n     * @param data Additional data with no specified format\\r\\n     * @return `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))` if transfer is allowed\\r\\n     */\\r\\n    function onERC1155Received(\\r\\n        address operator,\\r\\n        address from,\\r\\n        uint256 id,\\r\\n        uint256 value,\\r\\n        bytes calldata data\\r\\n    ) external returns (bytes4);\\r\\n\\r\\n    /**\\r\\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\\r\\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\\r\\n     * been updated.\\r\\n     *\\r\\n     * NOTE: To accept the transfer(s), this must return\\r\\n     * `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\r\\n     * (i.e. 0xbc197c81, or its own function selector).\\r\\n     *\\r\\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\\r\\n     * @param from The address which previously owned the token\\r\\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\\r\\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\\r\\n     * @param data Additional data with no specified format\\r\\n     * @return `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))` if transfer is allowed\\r\\n     */\\r\\n    function onERC1155BatchReceived(\\r\\n        address operator,\\r\\n        address from,\\r\\n        uint256[] calldata ids,\\r\\n        uint256[] calldata values,\\r\\n        bytes calldata data\\r\\n    ) external returns (bytes4);\\r\\n}\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n/** \\r\\n *  SourceUnit: c:\\\\Users\\\\chris\\\\Downloads\\\\nftProject\\\\here.sol\\r\\n*/\\r\\n            \\r\\n////// SPDX-License-Identifier-FLATTEN-SUPPRESS-WARNING: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n////import \\\"../../utils/introspection/IERC165.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Required interface of an ERC721 compliant contract.\\r\\n */\\r\\ninterface IERC721 is IERC165 {\\r\\n    /**\\r\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\r\\n     */\\r\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the number of tokens in ``owner``'s account.\\r\\n     */\\r\\n    function balanceOf(address owner) external view returns (uint256 balance);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the owner of the `tokenId` token.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `tokenId` must exist.\\r\\n     */\\r\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\r\\n\\r\\n    /**\\r\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `from` cannot be the zero address.\\r\\n     * - `to` cannot be the zero address.\\r\\n     * - `tokenId` token must exist and be owned by `from`.\\r\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\r\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function safeTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 tokenId,\\r\\n        bytes calldata data\\r\\n    ) external;\\r\\n\\r\\n    /**\\r\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\r\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `from` cannot be the zero address.\\r\\n     * - `to` cannot be the zero address.\\r\\n     * - `tokenId` token must exist and be owned by `from`.\\r\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\r\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function safeTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 tokenId\\r\\n    ) external;\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\r\\n     *\\r\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `from` cannot be the zero address.\\r\\n     * - `to` cannot be the zero address.\\r\\n     * - `tokenId` token must be owned by `from`.\\r\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 tokenId\\r\\n    ) external;\\r\\n\\r\\n    /**\\r\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\r\\n     * The approval is cleared when the token is transferred.\\r\\n     *\\r\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The caller must own the token or be an approved operator.\\r\\n     * - `tokenId` must exist.\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address to, uint256 tokenId) external;\\r\\n\\r\\n    /**\\r\\n     * @dev Approve or remove `operator` as an operator for the caller.\\r\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The `operator` cannot be the caller.\\r\\n     *\\r\\n     * Emits an {ApprovalForAll} event.\\r\\n     */\\r\\n    function setApprovalForAll(address operator, bool _approved) external;\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the account approved for `tokenId` token.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `tokenId` must exist.\\r\\n     */\\r\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\r\\n     *\\r\\n     * See {setApprovalForAll}\\r\\n     */\\r\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\r\\n}\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n/** \\r\\n *  SourceUnit: c:\\\\Users\\\\chris\\\\Downloads\\\\nftProject\\\\here.sol\\r\\n*/\\r\\n            \\r\\n////// SPDX-License-Identifier-FLATTEN-SUPPRESS-WARNING: MIT\\r\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n////import \\\"../IERC721.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\r\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\r\\n */\\r\\ninterface IERC721Metadata is IERC721 {\\r\\n    /**\\r\\n     * @dev Returns the token collection name.\\r\\n     */\\r\\n    function name() external view returns (string memory);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the token collection symbol.\\r\\n     */\\r\\n    function symbol() external view returns (string memory);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\r\\n     */\\r\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\r\\n}\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n/** \\r\\n *  SourceUnit: c:\\\\Users\\\\chris\\\\Downloads\\\\nftProject\\\\here.sol\\r\\n*/\\r\\n            \\r\\n////// SPDX-License-Identifier-FLATTEN-SUPPRESS-WARNING: MIT\\r\\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev String operations.\\r\\n */\\r\\nlibrary Strings {\\r\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\r\\n\\r\\n    /**\\r\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\r\\n     */\\r\\n    function toString(uint256 value) internal pure returns (string memory) {\\r\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\r\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\r\\n\\r\\n        if (value == 0) {\\r\\n            return \\\"0\\\";\\r\\n        }\\r\\n        uint256 temp = value;\\r\\n        uint256 digits;\\r\\n        while (temp != 0) {\\r\\n            digits++;\\r\\n            temp /= 10;\\r\\n        }\\r\\n        bytes memory buffer = new bytes(digits);\\r\\n        while (value != 0) {\\r\\n            digits -= 1;\\r\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\r\\n            value /= 10;\\r\\n        }\\r\\n        return string(buffer);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\r\\n     */\\r\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\r\\n        if (value == 0) {\\r\\n            return \\\"0x00\\\";\\r\\n        }\\r\\n        uint256 temp = value;\\r\\n        uint256 length = 0;\\r\\n        while (temp != 0) {\\r\\n            length++;\\r\\n            temp >>= 8;\\r\\n        }\\r\\n        return toHexString(value, length);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\r\\n     */\\r\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\r\\n        bytes memory buffer = new bytes(2 * length + 2);\\r\\n        buffer[0] = \\\"0\\\";\\r\\n        buffer[1] = \\\"x\\\";\\r\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\r\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\r\\n            value >>= 4;\\r\\n        }\\r\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\r\\n        return string(buffer);\\r\\n    }\\r\\n}\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n/** \\r\\n *  SourceUnit: c:\\\\Users\\\\chris\\\\Downloads\\\\nftProject\\\\here.sol\\r\\n*/\\r\\n            \\r\\n////// SPDX-License-Identifier-FLATTEN-SUPPRESS-WARNING: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @title ERC721 token receiver interface\\r\\n * @dev Interface for any contract that wants to support safeTransfers\\r\\n * from ERC721 asset contracts.\\r\\n */\\r\\ninterface IERC721Receiver {\\r\\n    /**\\r\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\r\\n     * by `operator` from `from`, this function is called.\\r\\n     *\\r\\n     * It must return its Solidity selector to confirm the token transfer.\\r\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\r\\n     *\\r\\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\\r\\n     */\\r\\n    function onERC721Received(\\r\\n        address operator,\\r\\n        address from,\\r\\n        uint256 tokenId,\\r\\n        bytes calldata data\\r\\n    ) external returns (bytes4);\\r\\n}\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n/** \\r\\n *  SourceUnit: c:\\\\Users\\\\chris\\\\Downloads\\\\nftProject\\\\here.sol\\r\\n*/\\r\\n            \\r\\n////// SPDX-License-Identifier-FLATTEN-SUPPRESS-WARNING: MIT\\r\\n// ERC721A Contracts v3.3.0\\r\\n// Creator: Chiru Labs\\r\\n\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\n////import '@openzeppelin/contracts/token/ERC721/IERC721.sol';\\r\\n////import '@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol';\\r\\n\\r\\n/**\\r\\n * @dev Interface of an ERC721A compliant contract.\\r\\n */\\r\\ninterface IERC721A is IERC721, IERC721Metadata {\\r\\n    /**\\r\\n     * The caller must own the token or be an approved operator.\\r\\n     */\\r\\n    error ApprovalCallerNotOwnerNorApproved();\\r\\n\\r\\n    /**\\r\\n     * The token does not exist.\\r\\n     */\\r\\n    error ApprovalQueryForNonexistentToken();\\r\\n\\r\\n    /**\\r\\n     * The caller cannot approve to their own address.\\r\\n     */\\r\\n    error ApproveToCaller();\\r\\n\\r\\n    /**\\r\\n     * The caller cannot approve to the current owner.\\r\\n     */\\r\\n    error ApprovalToCurrentOwner();\\r\\n\\r\\n    /**\\r\\n     * Cannot query the balance for the zero address.\\r\\n     */\\r\\n    error BalanceQueryForZeroAddress();\\r\\n\\r\\n    /**\\r\\n     * Cannot mint to the zero address.\\r\\n     */\\r\\n    error MintToZeroAddress();\\r\\n\\r\\n    /**\\r\\n     * The quantity of tokens minted must be more than zero.\\r\\n     */\\r\\n    error MintZeroQuantity();\\r\\n\\r\\n    /**\\r\\n     * The token does not exist.\\r\\n     */\\r\\n    error OwnerQueryForNonexistentToken();\\r\\n\\r\\n    /**\\r\\n     * The caller must own the token or be an approved operator.\\r\\n     */\\r\\n    error TransferCallerNotOwnerNorApproved();\\r\\n\\r\\n    /**\\r\\n     * The token must be owned by `from`.\\r\\n     */\\r\\n    error TransferFromIncorrectOwner();\\r\\n\\r\\n    /**\\r\\n     * Cannot safely transfer to a contract that does not implement the ERC721Receiver interface.\\r\\n     */\\r\\n    error TransferToNonERC721ReceiverImplementer();\\r\\n\\r\\n    /**\\r\\n     * Cannot transfer to the zero address.\\r\\n     */\\r\\n    error TransferToZeroAddress();\\r\\n\\r\\n    /**\\r\\n     * The token does not exist.\\r\\n     */\\r\\n    error URIQueryForNonexistentToken();\\r\\n\\r\\n    // Compiler will pack this into a single 256bit word.\\r\\n    struct TokenOwnership {\\r\\n        // The address of the owner.\\r\\n        address addr;\\r\\n        // Keeps track of the start time of ownership with minimal overhead for tokenomics.\\r\\n        uint64 startTimestamp;\\r\\n        // Whether the token has been burned.\\r\\n        bool burned;\\r\\n    }\\r\\n\\r\\n    // Compiler will pack this into a single 256bit word.\\r\\n    struct AddressData {\\r\\n        // Realistically, 2**64-1 is more than enough.\\r\\n        uint64 balance;\\r\\n        // Keeps track of mint count with minimal overhead for tokenomics.\\r\\n        uint64 numberMinted;\\r\\n        // Keeps track of burn count with minimal overhead for tokenomics.\\r\\n        uint64 numberBurned;\\r\\n        // For miscellaneous variable(s) pertaining to the address\\r\\n        // (e.g. number of whitelist mint slots used).\\r\\n        // If there are multiple variables, please pack them into a uint64.\\r\\n        uint64 aux;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the total amount of tokens stored by the contract.\\r\\n     * \\r\\n     * Burned tokens are calculated here, use `_totalMinted()` if you want to count just minted tokens.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n}\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n/** \\r\\n *  SourceUnit: c:\\\\Users\\\\chris\\\\Downloads\\\\nftProject\\\\here.sol\\r\\n*/\\r\\n            \\r\\n////// SPDX-License-Identifier-FLATTEN-SUPPRESS-WARNING: MIT\\r\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n////import \\\"../utils/Context.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Contract module which provides a basic access control mechanism, where\\r\\n * there is an account (an owner) that can be granted exclusive access to\\r\\n * specific functions.\\r\\n *\\r\\n * By default, the owner account will be the one that deploys the contract. This\\r\\n * can later be changed with {transferOwnership}.\\r\\n *\\r\\n * This module is used through inheritance. It will make available the modifier\\r\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\r\\n * the owner.\\r\\n */\\r\\nabstract contract Ownable is Context {\\r\\n    address private _owner;\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    /**\\r\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\r\\n     */\\r\\n    constructor() {\\r\\n        _transferOwnership(_msgSender());\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the address of the current owner.\\r\\n     */\\r\\n    function owner() public view virtual returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if called by any account other than the owner.\\r\\n     */\\r\\n    modifier onlyOwner() {\\r\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Leaves the contract without owner. It will not be possible to call\\r\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\r\\n     *\\r\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\r\\n     * thereby removing any functionality that is only available to the owner.\\r\\n     */\\r\\n    function renounceOwnership() public virtual onlyOwner {\\r\\n        _transferOwnership(address(0));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     * Can only be called by the current owner.\\r\\n     */\\r\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\r\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\r\\n        _transferOwnership(newOwner);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     * Internal function without access restriction.\\r\\n     */\\r\\n    function _transferOwnership(address newOwner) internal virtual {\\r\\n        address oldOwner = _owner;\\r\\n        _owner = newOwner;\\r\\n        emit OwnershipTransferred(oldOwner, newOwner);\\r\\n    }\\r\\n}\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n/** \\r\\n *  SourceUnit: c:\\\\Users\\\\chris\\\\Downloads\\\\nftProject\\\\here.sol\\r\\n*/\\r\\n            \\r\\n////// SPDX-License-Identifier-FLATTEN-SUPPRESS-WARNING: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC1155/ERC1155.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n////import \\\"./IERC1155.sol\\\";\\r\\n////import \\\"./IERC1155Receiver.sol\\\";\\r\\n////import \\\"./extensions/IERC1155MetadataURI.sol\\\";\\r\\n////import \\\"../../utils/Address.sol\\\";\\r\\n////import \\\"../../utils/Context.sol\\\";\\r\\n////import \\\"../../utils/introspection/ERC165.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Implementation of the basic standard multi-token.\\r\\n * See https://eips.ethereum.org/EIPS/eip-1155\\r\\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\\r\\n *\\r\\n * _Available since v3.1._\\r\\n */\\r\\ncontract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {\\r\\n    using Address for address;\\r\\n\\r\\n    // Mapping from token ID to account balances\\r\\n    mapping(uint256 => mapping(address => uint256)) private _balances;\\r\\n\\r\\n    // Mapping from account to operator approvals\\r\\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\\r\\n\\r\\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\\r\\n    string private _uri;\\r\\n\\r\\n    /**\\r\\n     * @dev See {_setURI}.\\r\\n     */\\r\\n    constructor(string memory uri_) {\\r\\n        _setURI(uri_);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC165-supportsInterface}.\\r\\n     */\\r\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\\r\\n        return\\r\\n            interfaceId == type(IERC1155).interfaceId ||\\r\\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\\r\\n            super.supportsInterface(interfaceId);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC1155MetadataURI-uri}.\\r\\n     *\\r\\n     * This implementation returns the same URI for *all* token types. It relies\\r\\n     * on the token type ID substitution mechanism\\r\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\\r\\n     *\\r\\n     * Clients calling this function must replace the `\\\\{id\\\\}` substring with the\\r\\n     * actual token type ID.\\r\\n     */\\r\\n    function uri(uint256) public view virtual override returns (string memory) {\\r\\n        return _uri;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC1155-balanceOf}.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `account` cannot be the zero address.\\r\\n     */\\r\\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\\r\\n        require(account != address(0), \\\"ERC1155: balance query for the zero address\\\");\\r\\n        return _balances[id][account];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC1155-balanceOfBatch}.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `accounts` and `ids` must have the same length.\\r\\n     */\\r\\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\\r\\n        public\\r\\n        view\\r\\n        virtual\\r\\n        override\\r\\n        returns (uint256[] memory)\\r\\n    {\\r\\n        require(accounts.length == ids.length, \\\"ERC1155: accounts and ids length mismatch\\\");\\r\\n\\r\\n        uint256[] memory batchBalances = new uint256[](accounts.length);\\r\\n\\r\\n        for (uint256 i = 0; i < accounts.length; ++i) {\\r\\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\\r\\n        }\\r\\n\\r\\n        return batchBalances;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC1155-setApprovalForAll}.\\r\\n     */\\r\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\r\\n        _setApprovalForAll(_msgSender(), operator, approved);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC1155-isApprovedForAll}.\\r\\n     */\\r\\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\\r\\n        return _operatorApprovals[account][operator];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC1155-safeTransferFrom}.\\r\\n     */\\r\\n    function safeTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 id,\\r\\n        uint256 amount,\\r\\n        bytes memory data\\r\\n    ) public virtual override {\\r\\n        require(\\r\\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\\r\\n            \\\"ERC1155: caller is not owner nor approved\\\"\\r\\n        );\\r\\n        _safeTransferFrom(from, to, id, amount, data);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC1155-safeBatchTransferFrom}.\\r\\n     */\\r\\n    function safeBatchTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256[] memory ids,\\r\\n        uint256[] memory amounts,\\r\\n        bytes memory data\\r\\n    ) public virtual override {\\r\\n        require(\\r\\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\\r\\n            \\\"ERC1155: transfer caller is not owner nor approved\\\"\\r\\n        );\\r\\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\r\\n     *\\r\\n     * Emits a {TransferSingle} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `to` cannot be the zero address.\\r\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\r\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\r\\n     * acceptance magic value.\\r\\n     */\\r\\n    function _safeTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 id,\\r\\n        uint256 amount,\\r\\n        bytes memory data\\r\\n    ) internal virtual {\\r\\n        require(to != address(0), \\\"ERC1155: transfer to the zero address\\\");\\r\\n\\r\\n        address operator = _msgSender();\\r\\n        uint256[] memory ids = _asSingletonArray(id);\\r\\n        uint256[] memory amounts = _asSingletonArray(amount);\\r\\n\\r\\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\\r\\n\\r\\n        uint256 fromBalance = _balances[id][from];\\r\\n        require(fromBalance >= amount, \\\"ERC1155: insufficient balance for transfer\\\");\\r\\n        unchecked {\\r\\n            _balances[id][from] = fromBalance - amount;\\r\\n        }\\r\\n        _balances[id][to] += amount;\\r\\n\\r\\n        emit TransferSingle(operator, from, to, id, amount);\\r\\n\\r\\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\\r\\n\\r\\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.\\r\\n     *\\r\\n     * Emits a {TransferBatch} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\r\\n     * acceptance magic value.\\r\\n     */\\r\\n    function _safeBatchTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256[] memory ids,\\r\\n        uint256[] memory amounts,\\r\\n        bytes memory data\\r\\n    ) internal virtual {\\r\\n        require(ids.length == amounts.length, \\\"ERC1155: ids and amounts length mismatch\\\");\\r\\n        require(to != address(0), \\\"ERC1155: transfer to the zero address\\\");\\r\\n\\r\\n        address operator = _msgSender();\\r\\n\\r\\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\\r\\n\\r\\n        for (uint256 i = 0; i < ids.length; ++i) {\\r\\n            uint256 id = ids[i];\\r\\n            uint256 amount = amounts[i];\\r\\n\\r\\n            uint256 fromBalance = _balances[id][from];\\r\\n            require(fromBalance >= amount, \\\"ERC1155: insufficient balance for transfer\\\");\\r\\n            unchecked {\\r\\n                _balances[id][from] = fromBalance - amount;\\r\\n            }\\r\\n            _balances[id][to] += amount;\\r\\n        }\\r\\n\\r\\n        emit TransferBatch(operator, from, to, ids, amounts);\\r\\n\\r\\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\\r\\n\\r\\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Sets a new URI for all token types, by relying on the token type ID\\r\\n     * substitution mechanism\\r\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\\r\\n     *\\r\\n     * By this mechanism, any occurrence of the `\\\\{id\\\\}` substring in either the\\r\\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\\r\\n     * clients with the token type ID.\\r\\n     *\\r\\n     * For example, the `https://token-cdn-domain/\\\\{id\\\\}.json` URI would be\\r\\n     * interpreted by clients as\\r\\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\\r\\n     * for token type ID 0x4cce0.\\r\\n     *\\r\\n     * See {uri}.\\r\\n     *\\r\\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\\r\\n     * this function emits no events.\\r\\n     */\\r\\n    function _setURI(string memory newuri) internal virtual {\\r\\n        _uri = newuri;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `to`.\\r\\n     *\\r\\n     * Emits a {TransferSingle} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `to` cannot be the zero address.\\r\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\r\\n     * acceptance magic value.\\r\\n     */\\r\\n    function _mint(\\r\\n        address to,\\r\\n        uint256 id,\\r\\n        uint256 amount,\\r\\n        bytes memory data\\r\\n    ) internal virtual {\\r\\n        require(to != address(0), \\\"ERC1155: mint to the zero address\\\");\\r\\n\\r\\n        address operator = _msgSender();\\r\\n        uint256[] memory ids = _asSingletonArray(id);\\r\\n        uint256[] memory amounts = _asSingletonArray(amount);\\r\\n\\r\\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\\r\\n\\r\\n        _balances[id][to] += amount;\\r\\n        emit TransferSingle(operator, address(0), to, id, amount);\\r\\n\\r\\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\\r\\n\\r\\n        _doSafeTransferAcceptanceCheck(operator, address(0), to, id, amount, data);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `ids` and `amounts` must have the same length.\\r\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\r\\n     * acceptance magic value.\\r\\n     */\\r\\n    function _mintBatch(\\r\\n        address to,\\r\\n        uint256[] memory ids,\\r\\n        uint256[] memory amounts,\\r\\n        bytes memory data\\r\\n    ) internal virtual {\\r\\n        require(to != address(0), \\\"ERC1155: mint to the zero address\\\");\\r\\n        require(ids.length == amounts.length, \\\"ERC1155: ids and amounts length mismatch\\\");\\r\\n\\r\\n        address operator = _msgSender();\\r\\n\\r\\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\\r\\n\\r\\n        for (uint256 i = 0; i < ids.length; i++) {\\r\\n            _balances[ids[i]][to] += amounts[i];\\r\\n        }\\r\\n\\r\\n        emit TransferBatch(operator, address(0), to, ids, amounts);\\r\\n\\r\\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\\r\\n\\r\\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Destroys `amount` tokens of token type `id` from `from`\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `from` cannot be the zero address.\\r\\n     * - `from` must have at least `amount` tokens of token type `id`.\\r\\n     */\\r\\n    function _burn(\\r\\n        address from,\\r\\n        uint256 id,\\r\\n        uint256 amount\\r\\n    ) internal virtual {\\r\\n        require(from != address(0), \\\"ERC1155: burn from the zero address\\\");\\r\\n\\r\\n        address operator = _msgSender();\\r\\n        uint256[] memory ids = _asSingletonArray(id);\\r\\n        uint256[] memory amounts = _asSingletonArray(amount);\\r\\n\\r\\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \\\"\\\");\\r\\n\\r\\n        uint256 fromBalance = _balances[id][from];\\r\\n        require(fromBalance >= amount, \\\"ERC1155: burn amount exceeds balance\\\");\\r\\n        unchecked {\\r\\n            _balances[id][from] = fromBalance - amount;\\r\\n        }\\r\\n\\r\\n        emit TransferSingle(operator, from, address(0), id, amount);\\r\\n\\r\\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \\\"\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `ids` and `amounts` must have the same length.\\r\\n     */\\r\\n    function _burnBatch(\\r\\n        address from,\\r\\n        uint256[] memory ids,\\r\\n        uint256[] memory amounts\\r\\n    ) internal virtual {\\r\\n        require(from != address(0), \\\"ERC1155: burn from the zero address\\\");\\r\\n        require(ids.length == amounts.length, \\\"ERC1155: ids and amounts length mismatch\\\");\\r\\n\\r\\n        address operator = _msgSender();\\r\\n\\r\\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \\\"\\\");\\r\\n\\r\\n        for (uint256 i = 0; i < ids.length; i++) {\\r\\n            uint256 id = ids[i];\\r\\n            uint256 amount = amounts[i];\\r\\n\\r\\n            uint256 fromBalance = _balances[id][from];\\r\\n            require(fromBalance >= amount, \\\"ERC1155: burn amount exceeds balance\\\");\\r\\n            unchecked {\\r\\n                _balances[id][from] = fromBalance - amount;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        emit TransferBatch(operator, from, address(0), ids, amounts);\\r\\n\\r\\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \\\"\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Approve `operator` to operate on all of `owner` tokens\\r\\n     *\\r\\n     * Emits a {ApprovalForAll} event.\\r\\n     */\\r\\n    function _setApprovalForAll(\\r\\n        address owner,\\r\\n        address operator,\\r\\n        bool approved\\r\\n    ) internal virtual {\\r\\n        require(owner != operator, \\\"ERC1155: setting approval status for self\\\");\\r\\n        _operatorApprovals[owner][operator] = approved;\\r\\n        emit ApprovalForAll(owner, operator, approved);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Hook that is called before any token transfer. This includes minting\\r\\n     * and burning, as well as batched variants.\\r\\n     *\\r\\n     * The same hook is called on both single and batched variants. For single\\r\\n     * transfers, the length of the `id` and `amount` arrays will be 1.\\r\\n     *\\r\\n     * Calling conditions (for each `id` and `amount` pair):\\r\\n     *\\r\\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\r\\n     * of token type `id` will be  transferred to `to`.\\r\\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\\r\\n     * for `to`.\\r\\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\\r\\n     * will be burned.\\r\\n     * - `from` and `to` are never both zero.\\r\\n     * - `ids` and `amounts` have the same, non-zero length.\\r\\n     *\\r\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\r\\n     */\\r\\n    function _beforeTokenTransfer(\\r\\n        address operator,\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256[] memory ids,\\r\\n        uint256[] memory amounts,\\r\\n        bytes memory data\\r\\n    ) internal virtual {}\\r\\n\\r\\n    /**\\r\\n     * @dev Hook that is called after any token transfer. This includes minting\\r\\n     * and burning, as well as batched variants.\\r\\n     *\\r\\n     * The same hook is called on both single and batched variants. For single\\r\\n     * transfers, the length of the `id` and `amount` arrays will be 1.\\r\\n     *\\r\\n     * Calling conditions (for each `id` and `amount` pair):\\r\\n     *\\r\\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\r\\n     * of token type `id` will be  transferred to `to`.\\r\\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\\r\\n     * for `to`.\\r\\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\\r\\n     * will be burned.\\r\\n     * - `from` and `to` are never both zero.\\r\\n     * - `ids` and `amounts` have the same, non-zero length.\\r\\n     *\\r\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\r\\n     */\\r\\n    function _afterTokenTransfer(\\r\\n        address operator,\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256[] memory ids,\\r\\n        uint256[] memory amounts,\\r\\n        bytes memory data\\r\\n    ) internal virtual {}\\r\\n\\r\\n    function _doSafeTransferAcceptanceCheck(\\r\\n        address operator,\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 id,\\r\\n        uint256 amount,\\r\\n        bytes memory data\\r\\n    ) private {\\r\\n        if (to.isContract()) {\\r\\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\\r\\n                if (response != IERC1155Receiver.onERC1155Received.selector) {\\r\\n                    revert(\\\"ERC1155: ERC1155Receiver rejected tokens\\\");\\r\\n                }\\r\\n            } catch Error(string memory reason) {\\r\\n                revert(reason);\\r\\n            } catch {\\r\\n                revert(\\\"ERC1155: transfer to non ERC1155Receiver implementer\\\");\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _doSafeBatchTransferAcceptanceCheck(\\r\\n        address operator,\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256[] memory ids,\\r\\n        uint256[] memory amounts,\\r\\n        bytes memory data\\r\\n    ) private {\\r\\n        if (to.isContract()) {\\r\\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\\r\\n                bytes4 response\\r\\n            ) {\\r\\n                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {\\r\\n                    revert(\\\"ERC1155: ERC1155Receiver rejected tokens\\\");\\r\\n                }\\r\\n            } catch Error(string memory reason) {\\r\\n                revert(reason);\\r\\n            } catch {\\r\\n                revert(\\\"ERC1155: transfer to non ERC1155Receiver implementer\\\");\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\\r\\n        uint256[] memory array = new uint256[](1);\\r\\n        array[0] = element;\\r\\n\\r\\n        return array;\\r\\n    }\\r\\n}\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n/** \\r\\n *  SourceUnit: c:\\\\Users\\\\chris\\\\Downloads\\\\nftProject\\\\here.sol\\r\\n*/\\r\\n            \\r\\n////// SPDX-License-Identifier-FLATTEN-SUPPRESS-WARNING: MIT\\r\\n// ERC721A Contracts v3.3.0\\r\\n// Creator: Chiru Labs\\r\\n\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\n////import './IERC721A.sol';\\r\\n////import '@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol';\\r\\n////import '@openzeppelin/contracts/utils/Address.sol';\\r\\n////import '@openzeppelin/contracts/utils/Context.sol';\\r\\n////import '@openzeppelin/contracts/utils/Strings.sol';\\r\\n////import '@openzeppelin/contracts/utils/introspection/ERC165.sol';\\r\\n\\r\\n/**\\r\\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\\r\\n * the Metadata extension. Built to optimize for lower gas during batch mints.\\r\\n *\\r\\n * Assumes serials are sequentially minted starting at _startTokenId() (defaults to 0, e.g. 0, 1, 2, 3..).\\r\\n *\\r\\n * Assumes that an owner cannot have more than 2**64 - 1 (max value of uint64) of supply.\\r\\n *\\r\\n * Assumes that the maximum token id cannot exceed 2**256 - 1 (max value of uint256).\\r\\n */\\r\\ncontract ERC721A is Context, ERC165, IERC721A {\\r\\n    using Address for address;\\r\\n    using Strings for uint256;\\r\\n\\r\\n    // The tokenId of the next token to be minted.\\r\\n    uint256 internal _currentIndex;\\r\\n\\r\\n    // The number of tokens burned.\\r\\n    uint256 internal _burnCounter;\\r\\n\\r\\n    // Token name\\r\\n    string private _name;\\r\\n\\r\\n    // Token symbol\\r\\n    string private _symbol;\\r\\n\\r\\n    // Mapping from token ID to ownership details\\r\\n    // An empty struct value does not necessarily mean the token is unowned. See _ownershipOf implementation for details.\\r\\n    mapping(uint256 => TokenOwnership) internal _ownerships;\\r\\n\\r\\n    // Mapping owner address to address data\\r\\n    mapping(address => AddressData) private _addressData;\\r\\n\\r\\n    // Mapping from token ID to approved address\\r\\n    mapping(uint256 => address) private _tokenApprovals;\\r\\n\\r\\n    // Mapping from owner to operator approvals\\r\\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\\r\\n\\r\\n    constructor(string memory name_, string memory symbol_) {\\r\\n        _name = name_;\\r\\n        _symbol = symbol_;\\r\\n        _currentIndex = _startTokenId();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * To change the starting tokenId, please override this function.\\r\\n     */\\r\\n    function _startTokenId() internal view virtual returns (uint256) {\\r\\n        return 0;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Burned tokens are calculated here, use _totalMinted() if you want to count just minted tokens.\\r\\n     */\\r\\n    function totalSupply() public view override returns (uint256) {\\r\\n        // Counter underflow is impossible as _burnCounter cannot be incremented\\r\\n        // more than _currentIndex - _startTokenId() times\\r\\n        unchecked {\\r\\n            return _currentIndex - _burnCounter - _startTokenId();\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Returns the total amount of tokens minted in the contract.\\r\\n     */\\r\\n    function _totalMinted() internal view returns (uint256) {\\r\\n        // Counter underflow is impossible as _currentIndex does not decrement,\\r\\n        // and it is initialized to _startTokenId()\\r\\n        unchecked {\\r\\n            return _currentIndex - _startTokenId();\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC165-supportsInterface}.\\r\\n     */\\r\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\\r\\n        return\\r\\n            interfaceId == type(IERC721).interfaceId ||\\r\\n            interfaceId == type(IERC721Metadata).interfaceId ||\\r\\n            super.supportsInterface(interfaceId);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC721-balanceOf}.\\r\\n     */\\r\\n    function balanceOf(address owner) public view override returns (uint256) {\\r\\n        if (owner == address(0)) revert BalanceQueryForZeroAddress();\\r\\n        return uint256(_addressData[owner].balance);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Returns the number of tokens minted by `owner`.\\r\\n     */\\r\\n    function _numberMinted(address owner) internal view returns (uint256) {\\r\\n        return uint256(_addressData[owner].numberMinted);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Returns the number of tokens burned by or on behalf of `owner`.\\r\\n     */\\r\\n    function _numberBurned(address owner) internal view returns (uint256) {\\r\\n        return uint256(_addressData[owner].numberBurned);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Returns the auxillary data for `owner`. (e.g. number of whitelist mint slots used).\\r\\n     */\\r\\n    function _getAux(address owner) internal view returns (uint64) {\\r\\n        return _addressData[owner].aux;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Sets the auxillary data for `owner`. (e.g. number of whitelist mint slots used).\\r\\n     * If there are multiple variables, please pack them into a uint64.\\r\\n     */\\r\\n    function _setAux(address owner, uint64 aux) internal {\\r\\n        _addressData[owner].aux = aux;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Gas spent here starts off proportional to the maximum mint batch size.\\r\\n     * It gradually moves to O(1) as tokens get transferred around in the collection over time.\\r\\n     */\\r\\n    function _ownershipOf(uint256 tokenId) internal view returns (TokenOwnership memory) {\\r\\n        uint256 curr = tokenId;\\r\\n\\r\\n        unchecked {\\r\\n            if (_startTokenId() <= curr) if (curr < _currentIndex) {\\r\\n                TokenOwnership memory ownership = _ownerships[curr];\\r\\n                if (!ownership.burned) {\\r\\n                    if (ownership.addr != address(0)) {\\r\\n                        return ownership;\\r\\n                    }\\r\\n                    // Invariant:\\r\\n                    // There will always be an ownership that has an address and is not burned\\r\\n                    // before an ownership that does not have an address and is not burned.\\r\\n                    // Hence, curr will not underflow.\\r\\n                    while (true) {\\r\\n                        curr--;\\r\\n                        ownership = _ownerships[curr];\\r\\n                        if (ownership.addr != address(0)) {\\r\\n                            return ownership;\\r\\n                        }\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        revert OwnerQueryForNonexistentToken();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC721-ownerOf}.\\r\\n     */\\r\\n    function ownerOf(uint256 tokenId) public view override returns (address) {\\r\\n        return _ownershipOf(tokenId).addr;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC721Metadata-name}.\\r\\n     */\\r\\n    function name() public view virtual override returns (string memory) {\\r\\n        return _name;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC721Metadata-symbol}.\\r\\n     */\\r\\n    function symbol() public view virtual override returns (string memory) {\\r\\n        return _symbol;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC721Metadata-tokenURI}.\\r\\n     */\\r\\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\\r\\n        if (!_exists(tokenId)) revert URIQueryForNonexistentToken();\\r\\n\\r\\n        string memory baseURI = _baseURI();\\r\\n        return bytes(baseURI).length != 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : '';\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\\r\\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\\r\\n     * by default, can be overriden in child contracts.\\r\\n     */\\r\\n    function _baseURI() internal view virtual returns (string memory) {\\r\\n        return '';\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC721-approve}.\\r\\n     */\\r\\n    function approve(address to, uint256 tokenId) public override {\\r\\n        address owner = ERC721A.ownerOf(tokenId);\\r\\n        if (to == owner) revert ApprovalToCurrentOwner();\\r\\n\\r\\n        if (_msgSender() != owner) if(!isApprovedForAll(owner, _msgSender())) {\\r\\n            revert ApprovalCallerNotOwnerNorApproved();\\r\\n        }\\r\\n\\r\\n        _approve(to, tokenId, owner);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC721-getApproved}.\\r\\n     */\\r\\n    function getApproved(uint256 tokenId) public view override returns (address) {\\r\\n        if (!_exists(tokenId)) revert ApprovalQueryForNonexistentToken();\\r\\n\\r\\n        return _tokenApprovals[tokenId];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC721-setApprovalForAll}.\\r\\n     */\\r\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\r\\n        if (operator == _msgSender()) revert ApproveToCaller();\\r\\n\\r\\n        _operatorApprovals[_msgSender()][operator] = approved;\\r\\n        emit ApprovalForAll(_msgSender(), operator, approved);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC721-isApprovedForAll}.\\r\\n     */\\r\\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\\r\\n        return _operatorApprovals[owner][operator];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC721-transferFrom}.\\r\\n     */\\r\\n    function transferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 tokenId\\r\\n    ) public virtual override {\\r\\n        _transfer(from, to, tokenId);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC721-safeTransferFrom}.\\r\\n     */\\r\\n    function safeTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 tokenId\\r\\n    ) public virtual override {\\r\\n        safeTransferFrom(from, to, tokenId, '');\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC721-safeTransferFrom}.\\r\\n     */\\r\\n    function safeTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 tokenId,\\r\\n        bytes memory _data\\r\\n    ) public virtual override {\\r\\n        _transfer(from, to, tokenId);\\r\\n        if (to.isContract()) if(!_checkContractOnERC721Received(from, to, tokenId, _data)) {\\r\\n            revert TransferToNonERC721ReceiverImplementer();\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns whether `tokenId` exists.\\r\\n     *\\r\\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\\r\\n     *\\r\\n     * Tokens start existing when they are minted (`_mint`),\\r\\n     */\\r\\n    function _exists(uint256 tokenId) internal view returns (bool) {\\r\\n        return _startTokenId() <= tokenId && tokenId < _currentIndex && !_ownerships[tokenId].burned;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Equivalent to `_safeMint(to, quantity, '')`.\\r\\n     */\\r\\n    function _safeMint(address to, uint256 quantity) internal {\\r\\n        _safeMint(to, quantity, '');\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Safely mints `quantity` tokens and transfers them to `to`.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - If `to` refers to a smart contract, it must implement\\r\\n     *   {IERC721Receiver-onERC721Received}, which is called for each safe transfer.\\r\\n     * - `quantity` must be greater than 0.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function _safeMint(\\r\\n        address to,\\r\\n        uint256 quantity,\\r\\n        bytes memory _data\\r\\n    ) internal {\\r\\n        uint256 startTokenId = _currentIndex;\\r\\n        if (to == address(0)) revert MintToZeroAddress();\\r\\n        if (quantity == 0) revert MintZeroQuantity();\\r\\n\\r\\n        _beforeTokenTransfers(address(0), to, startTokenId, quantity);\\r\\n\\r\\n        // Overflows are incredibly unrealistic.\\r\\n        // balance or numberMinted overflow if current value of either + quantity > 1.8e19 (2**64) - 1\\r\\n        // updatedIndex overflows if _currentIndex + quantity > 1.2e77 (2**256) - 1\\r\\n        unchecked {\\r\\n            _addressData[to].balance += uint64(quantity);\\r\\n            _addressData[to].numberMinted += uint64(quantity);\\r\\n\\r\\n            _ownerships[startTokenId].addr = to;\\r\\n            _ownerships[startTokenId].startTimestamp = uint64(block.timestamp);\\r\\n\\r\\n            uint256 updatedIndex = startTokenId;\\r\\n            uint256 end = updatedIndex + quantity;\\r\\n\\r\\n            if (to.isContract()) {\\r\\n                do {\\r\\n                    emit Transfer(address(0), to, updatedIndex);\\r\\n                    if (!_checkContractOnERC721Received(address(0), to, updatedIndex++, _data)) {\\r\\n                        revert TransferToNonERC721ReceiverImplementer();\\r\\n                    }\\r\\n                } while (updatedIndex < end);\\r\\n                // Reentrancy protection\\r\\n                if (_currentIndex != startTokenId) revert();\\r\\n            } else {\\r\\n                do {\\r\\n                    emit Transfer(address(0), to, updatedIndex++);\\r\\n                } while (updatedIndex < end);\\r\\n            }\\r\\n            _currentIndex = updatedIndex;\\r\\n        }\\r\\n        _afterTokenTransfers(address(0), to, startTokenId, quantity);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Mints `quantity` tokens and transfers them to `to`.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `to` cannot be the zero address.\\r\\n     * - `quantity` must be greater than 0.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function _mint(address to, uint256 quantity) internal {\\r\\n        uint256 startTokenId = _currentIndex;\\r\\n        if (to == address(0)) revert MintToZeroAddress();\\r\\n        if (quantity == 0) revert MintZeroQuantity();\\r\\n\\r\\n        _beforeTokenTransfers(address(0), to, startTokenId, quantity);\\r\\n\\r\\n        // Overflows are incredibly unrealistic.\\r\\n        // balance or numberMinted overflow if current value of either + quantity > 1.8e19 (2**64) - 1\\r\\n        // updatedIndex overflows if _currentIndex + quantity > 1.2e77 (2**256) - 1\\r\\n        unchecked {\\r\\n            _addressData[to].balance += uint64(quantity);\\r\\n            _addressData[to].numberMinted += uint64(quantity);\\r\\n\\r\\n            _ownerships[startTokenId].addr = to;\\r\\n            _ownerships[startTokenId].startTimestamp = uint64(block.timestamp);\\r\\n\\r\\n            uint256 updatedIndex = startTokenId;\\r\\n            uint256 end = updatedIndex + quantity;\\r\\n\\r\\n            do {\\r\\n                emit Transfer(address(0), to, updatedIndex++);\\r\\n            } while (updatedIndex < end);\\r\\n\\r\\n            _currentIndex = updatedIndex;\\r\\n        }\\r\\n        _afterTokenTransfers(address(0), to, startTokenId, quantity);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers `tokenId` from `from` to `to`.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `to` cannot be the zero address.\\r\\n     * - `tokenId` token must be owned by `from`.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function _transfer(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 tokenId\\r\\n    ) private {\\r\\n        TokenOwnership memory prevOwnership = _ownershipOf(tokenId);\\r\\n\\r\\n        if (prevOwnership.addr != from) revert TransferFromIncorrectOwner();\\r\\n\\r\\n        bool isApprovedOrOwner = (_msgSender() == from ||\\r\\n            isApprovedForAll(from, _msgSender()) ||\\r\\n            getApproved(tokenId) == _msgSender());\\r\\n\\r\\n        if (!isApprovedOrOwner) revert TransferCallerNotOwnerNorApproved();\\r\\n        if (to == address(0)) revert TransferToZeroAddress();\\r\\n\\r\\n        _beforeTokenTransfers(from, to, tokenId, 1);\\r\\n\\r\\n        // Clear approvals from the previous owner\\r\\n        _approve(address(0), tokenId, from);\\r\\n\\r\\n        // Underflow of the sender's balance is impossible because we check for\\r\\n        // ownership above and the recipient's balance can't realistically overflow.\\r\\n        // Counter overflow is incredibly unrealistic as tokenId would have to be 2**256.\\r\\n        unchecked {\\r\\n            _addressData[from].balance -= 1;\\r\\n            _addressData[to].balance += 1;\\r\\n\\r\\n            TokenOwnership storage currSlot = _ownerships[tokenId];\\r\\n            currSlot.addr = to;\\r\\n            currSlot.startTimestamp = uint64(block.timestamp);\\r\\n\\r\\n            // If the ownership slot of tokenId+1 is not explicitly set, that means the transfer initiator owns it.\\r\\n            // Set the slot of tokenId+1 explicitly in storage to maintain correctness for ownerOf(tokenId+1) calls.\\r\\n            uint256 nextTokenId = tokenId + 1;\\r\\n            TokenOwnership storage nextSlot = _ownerships[nextTokenId];\\r\\n            if (nextSlot.addr == address(0)) {\\r\\n                // This will suffice for checking _exists(nextTokenId),\\r\\n                // as a burned slot cannot contain the zero address.\\r\\n                if (nextTokenId != _currentIndex) {\\r\\n                    nextSlot.addr = from;\\r\\n                    nextSlot.startTimestamp = prevOwnership.startTimestamp;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        emit Transfer(from, to, tokenId);\\r\\n        _afterTokenTransfers(from, to, tokenId, 1);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Equivalent to `_burn(tokenId, false)`.\\r\\n     */\\r\\n    function _burn(uint256 tokenId) internal virtual {\\r\\n        _burn(tokenId, false);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Destroys `tokenId`.\\r\\n     * The approval is cleared when the token is burned.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `tokenId` must exist.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function _burn(uint256 tokenId, bool approvalCheck) internal virtual {\\r\\n        TokenOwnership memory prevOwnership = _ownershipOf(tokenId);\\r\\n\\r\\n        address from = prevOwnership.addr;\\r\\n\\r\\n        if (approvalCheck) {\\r\\n            bool isApprovedOrOwner = (_msgSender() == from ||\\r\\n                isApprovedForAll(from, _msgSender()) ||\\r\\n                getApproved(tokenId) == _msgSender());\\r\\n\\r\\n            if (!isApprovedOrOwner) revert TransferCallerNotOwnerNorApproved();\\r\\n        }\\r\\n\\r\\n        _beforeTokenTransfers(from, address(0), tokenId, 1);\\r\\n\\r\\n        // Clear approvals from the previous owner\\r\\n        _approve(address(0), tokenId, from);\\r\\n\\r\\n        // Underflow of the sender's balance is impossible because we check for\\r\\n        // ownership above and the recipient's balance can't realistically overflow.\\r\\n        // Counter overflow is incredibly unrealistic as tokenId would have to be 2**256.\\r\\n        unchecked {\\r\\n            AddressData storage addressData = _addressData[from];\\r\\n            addressData.balance -= 1;\\r\\n            addressData.numberBurned += 1;\\r\\n\\r\\n            // Keep track of who burned the token, and the timestamp of burning.\\r\\n            TokenOwnership storage currSlot = _ownerships[tokenId];\\r\\n            currSlot.addr = from;\\r\\n            currSlot.startTimestamp = uint64(block.timestamp);\\r\\n            currSlot.burned = true;\\r\\n\\r\\n            // If the ownership slot of tokenId+1 is not explicitly set, that means the burn initiator owns it.\\r\\n            // Set the slot of tokenId+1 explicitly in storage to maintain correctness for ownerOf(tokenId+1) calls.\\r\\n            uint256 nextTokenId = tokenId + 1;\\r\\n            TokenOwnership storage nextSlot = _ownerships[nextTokenId];\\r\\n            if (nextSlot.addr == address(0)) {\\r\\n                // This will suffice for checking _exists(nextTokenId),\\r\\n                // as a burned slot cannot contain the zero address.\\r\\n                if (nextTokenId != _currentIndex) {\\r\\n                    nextSlot.addr = from;\\r\\n                    nextSlot.startTimestamp = prevOwnership.startTimestamp;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        emit Transfer(from, address(0), tokenId);\\r\\n        _afterTokenTransfers(from, address(0), tokenId, 1);\\r\\n\\r\\n        // Overflow not possible, as _burnCounter cannot be exceed _currentIndex times.\\r\\n        unchecked {\\r\\n            _burnCounter++;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Approve `to` to operate on `tokenId`\\r\\n     *\\r\\n     * Emits a {Approval} event.\\r\\n     */\\r\\n    function _approve(\\r\\n        address to,\\r\\n        uint256 tokenId,\\r\\n        address owner\\r\\n    ) private {\\r\\n        _tokenApprovals[tokenId] = to;\\r\\n        emit Approval(owner, to, tokenId);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target contract.\\r\\n     *\\r\\n     * @param from address representing the previous owner of the given token ID\\r\\n     * @param to target address that will receive the tokens\\r\\n     * @param tokenId uint256 ID of the token to be transferred\\r\\n     * @param _data bytes optional data to send along with the call\\r\\n     * @return bool whether the call correctly returned the expected magic value\\r\\n     */\\r\\n    function _checkContractOnERC721Received(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 tokenId,\\r\\n        bytes memory _data\\r\\n    ) private returns (bool) {\\r\\n        try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\\r\\n            return retval == IERC721Receiver(to).onERC721Received.selector;\\r\\n        } catch (bytes memory reason) {\\r\\n            if (reason.length == 0) {\\r\\n                revert TransferToNonERC721ReceiverImplementer();\\r\\n            } else {\\r\\n                assembly {\\r\\n                    revert(add(32, reason), mload(reason))\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Hook that is called before a set of serially-ordered token ids are about to be transferred. This includes minting.\\r\\n     * And also called before burning one token.\\r\\n     *\\r\\n     * startTokenId - the first token id to be transferred\\r\\n     * quantity - the amount to be transferred\\r\\n     *\\r\\n     * Calling conditions:\\r\\n     *\\r\\n     * - When `from` and `to` are both non-zero, `from`'s `tokenId` will be\\r\\n     * transferred to `to`.\\r\\n     * - When `from` is zero, `tokenId` will be minted for `to`.\\r\\n     * - When `to` is zero, `tokenId` will be burned by `from`.\\r\\n     * - `from` and `to` are never both zero.\\r\\n     */\\r\\n    function _beforeTokenTransfers(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 startTokenId,\\r\\n        uint256 quantity\\r\\n    ) internal virtual {}\\r\\n\\r\\n    /**\\r\\n     * @dev Hook that is called after a set of serially-ordered token ids have been transferred. This includes\\r\\n     * minting.\\r\\n     * And also called after one token has been burned.\\r\\n     *\\r\\n     * startTokenId - the first token id to be transferred\\r\\n     * quantity - the amount to be transferred\\r\\n     *\\r\\n     * Calling conditions:\\r\\n     *\\r\\n     * - When `from` and `to` are both non-zero, `from`'s `tokenId` has been\\r\\n     * transferred to `to`.\\r\\n     * - When `from` is zero, `tokenId` has been minted for `to`.\\r\\n     * - When `to` is zero, `tokenId` has been burned by `from`.\\r\\n     * - `from` and `to` are never both zero.\\r\\n     */\\r\\n    function _afterTokenTransfers(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 startTokenId,\\r\\n        uint256 quantity\\r\\n    ) internal virtual {}\\r\\n}\\r\\n\\r\\n\\r\\n/** \\r\\n *  SourceUnit: c:\\\\Users\\\\chris\\\\Downloads\\\\nftProject\\\\here.sol\\r\\n*/\\r\\n\\r\\n////// SPDX-License-Identifier-FLATTEN-SUPPRESS-WARNING: MIT\\r\\npragma solidity ^0.8.12;\\r\\n\\r\\n////import \\\"erc721a/contracts/ERC721A.sol\\\";\\r\\n////import \\\"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\\\";\\r\\n////import \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\r\\n\\r\\ncontract Smowlmfer is ERC721A, Ownable {\\r\\n    uint256 public constant MAX_PER_WALLET = 4;\\r\\n    uint256 public constant MAX_SUPPLY = 1337;\\r\\n    uint256 public constant MAX_FREE_SUPPLY = 420;\\r\\n    uint256 public mintPrice = 0.01337 ether;\\r\\n    uint256 public whitelistStopTime = 0;\\r\\n\\r\\n    mapping(address => bool) public whitelistParties;\\r\\n\\r\\n    address[] public whitelist721s;\\r\\n\\r\\n    mapping(address => uint8) private _qtyMinted;\\r\\n\\r\\n    bool public mintIsActive = false;\\r\\n\\r\\n    ////////////////////////////////////////////////////////////////////////////////////\\r\\n    // this needs to be the PLACEHOLDER baseURI\\r\\n    string public baseURI =\\r\\n        \\\"ipfs://QmbqDeLtagMWhXaq4FjKe28k37SxDJ5oP2utBaixK5vJPS?filename=\\\";\\r\\n\\r\\n    ////////////////////////////////////////////////////////////////////////////////////\\r\\n\\r\\n    constructor() ERC721A(\\\"Smowlmfer\\\", \\\"SMMFR\\\") {\\r\\n        whitelistParties[0x8b1A1aF63bb9b3730f62c56bDa272BCC69dF4CC7] = true;\\r\\n        whitelistParties[0x92DF544228Ca92b8C9943BBeECFDA7D3377f6294] = true;\\r\\n        whitelistParties[0x911A6Ad1b0811A909A22A071D421998AA3CCEce8] = true;\\r\\n        whitelistParties[0x7BAce095602E2BaB41d09a26e0CBCCD13485D9eb] = true;\\r\\n        whitelistParties[0xbaDDA2e018C0D56356B90650153b9cE56A6e72ed] = true;\\r\\n        whitelistParties[0xCc48857242141CC7F4f8555f8a3d5bED03556C19] = true;\\r\\n        whitelistParties[0x721389dC4b507b4D55ac8CeDAf2F6A83cCaa4fB2] = true;\\r\\n        whitelistParties[0x809cE3401657B841bd901a7f26d4F6914AEDd7e4] = true;\\r\\n        whitelistParties[0x49Ff879D80c33ffA78238bE16ab9A143e12d470B] = true;\\r\\n        whitelistParties[0x39C44DC4cf2398281C52DC1073f97162440F39CE] = true;\\r\\n        whitelistParties[0x8442853E514D18BB76356Ea17d13448A2381E08F] = true;\\r\\n        whitelistParties[0x4a34e638835F65d1a2dF79E9AF93556DD009278a] = true;\\r\\n        whitelistParties[0x8EA5d42b5bEfc4DF7447e647B60D2396E93A4999] = true;\\r\\n        whitelistParties[0x4e5e17201f9553db36ecCA0201526D27788C3E35] = true;\\r\\n        whitelistParties[0xDceb4Fd5b8667F1CB2919a9e66A767c65435960B] = true;\\r\\n        whitelistParties[0x99c531A770FDa06dbF4e657FBF1514408951323B] = true;\\r\\n        whitelistParties[0x49a1f87C5Bcf099b78550Ec127f0d2d17697A317] = true;\\r\\n        whitelistParties[0x5886Dc12a54af415293c3861a9f87Da2d5BAb391] = true;\\r\\n        whitelistParties[0xDA1128FDd6Ff2Fd18F609F3EA9844DF0A1dB3FB3] = true;\\r\\n        whitelistParties[0x5960db0AC5DE05143D200dcFc35D3412A7ad2441] = true;\\r\\n        whitelistParties[0x721389dC4b507b4D55ac8CeDAf2F6A83cCaa4fB2] = true;\\r\\n        whitelistParties[0x7BAce095602E2BaB41d09a26e0CBCCD13485D9eb] = true;\\r\\n        whitelistParties[0xbaDDA2e018C0D56356B90650153b9cE56A6e72ed] = true;\\r\\n        whitelistParties[0x53387F537c36638B60085Bd22402c06Feb733F89] = true;\\r\\n        whitelistParties[0xC17d016b585B362915342a59aDBC228Dab917fAE] = true;\\r\\n        whitelistParties[0x0EFF59156B540867Ce74Fe972E81be4186c1734a] = true;\\r\\n        whitelistParties[0x9d7DC59D1DB46899f5CF069B7261ECF64363d4DE] = true;\\r\\n        whitelistParties[0x47b16b6D23f657a8D6de849Fe41CEe79C560a4b5] = true;\\r\\n        whitelistParties[0xA8A350D56c6F59391Bd1EeA15a10bFf4D30470c1] = true;\\r\\n        whitelistParties[0xEf2c4f533A5220c10468ad280b40978723DAfd51] = true;\\r\\n        whitelistParties[0x55902109bF1A72Bb5Fa0bF36b917f0Cd759D8Ab5] = true;\\r\\n\\r\\n        whitelist721s = [\\r\\n            0x03B8D129A8F6DC62a797b59aA5eeBB11Ad63DaDA,\\r\\n            0x79FCDEF22feeD20eDDacbB2587640e45491b757f,\\r\\n            0xBc8Af167FFAa6B780AAEB522CCaBd64C5933bf02,\\r\\n            0x0F5aC1716d088B52869A3Cfe28F10ddfcC565e94\\r\\n        ];\\r\\n    }\\r\\n\\r\\n    function mint(uint8 quantity) external payable {\\r\\n        require(\\r\\n            msg.sender == tx.origin,\\r\\n            \\\"No transaction from smart contracts!\\\"\\r\\n        );\\r\\n        require(mintIsActive, \\\"Mint must be active to mint\\\");\\r\\n        require(\\r\\n            quantity > 0 && quantity + _qtyMinted[msg.sender] <= MAX_PER_WALLET,\\r\\n            \\\"Max per wallet reached\\\"\\r\\n        );\\r\\n        require(totalSupply() + quantity <= MAX_SUPPLY, \\\"Exceeds max supply\\\");\\r\\n\\r\\n        require(msg.value >= mintPrice * quantity, \\\"not enough money\\\");\\r\\n\\r\\n        _qtyMinted[msg.sender] += quantity; //tracking minted\\r\\n        _safeMint(msg.sender, quantity);\\r\\n    }\\r\\n\\r\\n    function freeMint() external {\\r\\n        require(\\r\\n            msg.sender == tx.origin,\\r\\n            \\\"No transaction from smart contracts!\\\"\\r\\n        );\\r\\n        require(mintIsActive, \\\"Mint must be active to mint\\\");\\r\\n        require(_qtyMinted[msg.sender] == 0, \\\"already minted a token\\\");\\r\\n        require(totalSupply() < MAX_SUPPLY, \\\"Exceeds max supply\\\");\\r\\n        require(isWhitelisted(msg.sender), \\\"not on the whitelist :(\\\");\\r\\n        require(totalSupply() < MAX_FREE_SUPPLY, \\\"Exceeds max freesupply\\\");\\r\\n\\r\\n        _qtyMinted[msg.sender] += 1; //tracking minted\\r\\n        _safeMint(msg.sender, 1);\\r\\n    }\\r\\n\\r\\n    function ownerMint(uint8 quantity) external onlyOwner {\\r\\n        require(totalSupply() + quantity <= MAX_SUPPLY, \\\"Exceeds max supply\\\");\\r\\n        _safeMint(msg.sender, quantity, \\\"\\\");\\r\\n    }\\r\\n\\r\\n    function addAddressWhitelist(address addr) external onlyOwner {\\r\\n        whitelistParties[addr] = true;\\r\\n    }\\r\\n\\r\\n    function add721Whitelist(address addr) external onlyOwner {\\r\\n        whitelist721s.push(addr);\\r\\n    }\\r\\n\\r\\n    function setPrice(uint256 price) external onlyOwner {\\r\\n        mintPrice = price;\\r\\n    }\\r\\n\\r\\n    function flipSaleState() external onlyOwner {\\r\\n        mintIsActive = !mintIsActive;\\r\\n    }\\r\\n\\r\\n    function withdraw() external onlyOwner {\\r\\n        payable(owner()).transfer(address(this).balance);\\r\\n    }\\r\\n\\r\\n    function setBaseURI(string memory newBaseURI) public onlyOwner {\\r\\n        baseURI = newBaseURI;\\r\\n    }\\r\\n\\r\\n    ////////////////////////////////////////////////////////////////////////////////////\\r\\n    // need to change to the others\\r\\n    ////////////////////////////////////////////////////////////////////////////////////\\r\\n    function isWhitelisted(address addr) public view returns (bool) {\\r\\n        if (whitelistParties[addr]) {\\r\\n            return true;\\r\\n        }\\r\\n        for (uint256 i = 0; i < whitelist721s.length; i++) {\\r\\n            if (ERC721A(whitelist721s[i]).balanceOf(addr) > 0) {\\r\\n                return true;\\r\\n            }\\r\\n        }\\r\\n        if (ERC1155(0xe79c44b2dbFedbAC1dB992aad3827a3621B0813f).balanceOf(addr, 1) > 0) {\\r\\n            return true;\\r\\n        }\\r\\n        if (ERC1155(0xe79c44b2dbFedbAC1dB992aad3827a3621B0813f).balanceOf( addr, 2) > 0) {\\r\\n            return true;\\r\\n        }\\r\\n        return false;\\r\\n    }\\r\\n\\r\\n    function _baseURI() internal view override returns (string memory) {\\r\\n        return baseURI;\\r\\n    }\\r\\n}\\r\\n\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ApprovalCallerNotOwnerNorApproved\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ApprovalQueryForNonexistentToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ApprovalToCurrentOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ApproveToCaller\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BalanceQueryForZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MintToZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MintZeroQuantity\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OwnerQueryForNonexistentToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferCallerNotOwnerNorApproved\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferFromIncorrectOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferToNonERC721ReceiverImplementer\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferToZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"URIQueryForNonexistentToken\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MAX_FREE_SUPPLY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_PER_WALLET\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_SUPPLY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"add721Whitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"addAddressWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"flipSaleState\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"freeMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"isWhitelisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"quantity\",\"type\":\"uint8\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintIsActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"quantity\",\"type\":\"uint8\"}],\"name\":\"ownerMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newBaseURI\",\"type\":\"string\"}],\"name\":\"setBaseURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"setPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"whitelist721s\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelistParties\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"whitelistStopTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Smowlmfer", "CompilerVersion": "v0.8.12+commit.f00d7308", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}