{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"StateChainGateway.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"IERC20.sol\\\";\\nimport \\\"IStateChainGateway.sol\\\";\\nimport \\\"IKeyManager.sol\\\";\\nimport \\\"IFlipIssuer.sol\\\";\\nimport \\\"IFLIP.sol\\\";\\nimport \\\"AggKeyNonceConsumer.sol\\\";\\nimport \\\"GovernanceCommunityGuarded.sol\\\";\\n\\n/**\\n * @title    State Chain Gateway contract\\n * @notice   Manages the funding and redemption FLIP from/to stateChain accounts.\\n *           Accounts on the FLIP state chain basically have full control\\n *           of FLIP leaving the contract. FLIP can be added to the StateChain\\n *           account via `fundStateChainAccount` with their stateChain nodeID.\\n *\\n *           This contract also handles the minting and burning of FLIP after the\\n *           initial supply is minted during FLIP's creation. At any time, a\\n *           valid aggragate signature can be submitted to the contract which\\n *           updates the total supply by minting or burning the necessary FLIP.\\n */\\ncontract StateChainGateway is IFlipIssuer, IStateChainGateway, AggKeyNonceConsumer, GovernanceCommunityGuarded {\\n    /// @dev    The FLIP token address. To be set only once after deployment via setFlip.\\n    // solhint-disable-next-line var-name-mixedcase\\n    IFLIP private _FLIP;\\n\\n    /// @dev    The minimum amount of FLIP needed to fund an account, to prevent spamming\\n    uint256 private _minFunding;\\n    /// @dev    Holding pending redemptions for the 48h withdrawal delay\\n    mapping(bytes32 => Redemption) private _pendingRedemptions;\\n    /// @dev   Time after registerRedemption required to wait before call to executeRedemption\\n    // solhint-disable-next-line var-name-mixedcase\\n    uint48 public immutable REDEMPTION_DELAY;\\n\\n    /// @dev    The last block number in which the State Chain updated the totalSupply\\n    uint256 private _lastSupplyUpdateBlockNum = 0;\\n\\n    // Defined in IStateChainGateway, just here for convenience\\n    // struct Redemption {\\n    //     uint amount;\\n    //     address redeemAddress;\\n    //     // 48 so that 160 (from redeemAddress) + 48 + 48 is 256 they can all be packed\\n    //     // into a single 256 bit slot\\n    //     uint48 startTime;\\n    //     uint48 expiryTime;\\n    //     address executor;\\n    // }\\n\\n    constructor(\\n        IKeyManager keyManager,\\n        uint256 minFunding,\\n        uint48 redemptionDelay\\n    ) AggKeyNonceConsumer(keyManager) nzUint(redemptionDelay) {\\n        _minFunding = minFunding;\\n        REDEMPTION_DELAY = redemptionDelay;\\n    }\\n\\n    /// @dev   Get the governor address from the KeyManager. This is called by the onlyGovernor\\n    ///        modifier in the GovernanceCommunityGuarded. This logic can't be moved to the\\n    ///        GovernanceCommunityGuarded since it requires a reference to the KeyManager.\\n    function _getGovernor() internal view override returns (address) {\\n        return getKeyManager().getGovernanceKey();\\n    }\\n\\n    /// @dev   Get the community key from the KeyManager. This is called by the isCommunityKey\\n    ///        modifier in the GovernanceCommunityGuarded. This logic can't be moved to the\\n    ///        GovernanceCommunityGuarded since it requires a reference to the KeyManager.\\n    function _getCommunityKey() internal view override returns (address) {\\n        return getKeyManager().getCommunityKey();\\n    }\\n\\n    /**\\n     * @notice  Get the FLIP token address\\n     * @dev     This function and it's return value will be checked when updating the FLIP issuer.\\n     *          Do not remove nor modify this function in future versions of this contract.\\n     * @return  The address of FLIP\\n     */\\n    function getFLIP() external view override returns (IFLIP) {\\n        return _FLIP;\\n    }\\n\\n    /// @dev   Ensure that a new keyManager has the getGovernanceKey() and getCommunityKey()\\n    ///        functions implemented. These are functions required for this contract to\\n    ///        to at least be able to use the emergency mechanism.\\n    function _checkUpdateKeyManager(IKeyManager keyManager, bool omitChecks) internal view override {\\n        address newGovKey = keyManager.getGovernanceKey();\\n        address newCommKey = keyManager.getCommunityKey();\\n\\n        if (!omitChecks) {\\n            // Ensure that the keys are the same\\n            require(newGovKey == _getGovernor() && newCommKey == _getCommunityKey());\\n\\n            Key memory newAggKey = keyManager.getAggregateKey();\\n            Key memory currentAggKey = getKeyManager().getAggregateKey();\\n\\n            require(\\n                newAggKey.pubKeyX == currentAggKey.pubKeyX && newAggKey.pubKeyYParity == currentAggKey.pubKeyYParity\\n            );\\n        } else {\\n            // Check that the addresses have been initialized\\n            require(newGovKey != address(0) && newCommKey != address(0));\\n        }\\n    }\\n\\n    //////////////////////////////////////////////////////////////\\n    //                                                          //\\n    //                  State-changing functions                //\\n    //                                                          //\\n    //////////////////////////////////////////////////////////////\\n\\n    /**\\n     * @notice  Sets the FLIP address after initialization. We can't do this in the constructor\\n     *          because FLIP contract requires this contract's address on deployment for minting.\\n     *          First this contract is deployed, then the FLIP contract and finally setFLIP\\n     *          should be called. Deployed via DeployerContract.sol so it can't be frontrun.\\n     *          The FLIP address can only be set once.\\n     * @param flip FLIP token address\\n     */\\n    function setFlip(IFLIP flip) external override nzAddr(address(flip)) {\\n        require(address(_FLIP) == address(0), \\\"Gateway: Flip address already set\\\");\\n        _FLIP = flip;\\n        emit FLIPSet(address(flip));\\n    }\\n\\n    /**\\n     * @notice          Add FLIP funds to a StateChain account identified with a nodeID\\n     * @dev             Requires the funder to have called `approve` in FLIP\\n     * @param amount    The amount of FLIP tokens\\n     * @param nodeID    The nodeID of the account to fund\\n     */\\n    function fundStateChainAccount(bytes32 nodeID, uint256 amount) external override nzBytes32(nodeID) {\\n        IFLIP flip = _FLIP;\\n        require(address(flip) != address(0), \\\"Gateway: Flip not set\\\");\\n        require(amount >= _minFunding, \\\"Gateway: not enough funds\\\");\\n        // Assumption of set token allowance by the user\\n        flip.transferFrom(msg.sender, address(this), amount);\\n        emit Funded(nodeID, amount, msg.sender);\\n    }\\n\\n    /**\\n     * @notice  Redeem FLIP from the StateChain. The State Chain will determine the amount\\n     *          that can be redeemed, but a basic calculation for a validator would be:\\n     *          amount redeemable = stake + rewards - penalties.\\n     * @param sigData   Struct containing the signature data over the message\\n     *                  to verify, signed by the aggregate key.\\n     * @param nodeID    The nodeID of the account redeeming the FLIP\\n     * @param amount    The amount of funds to be locked up\\n     * @param redeemAddress    The redeemAddress who will receive the FLIP\\n     * @param expiryTime  The last valid timestamp that can execute this redemption (uint48)\\n     * @param executor    The address that can execute the redemption (zero address if anyone)\\n     */\\n    function registerRedemption(\\n        SigData calldata sigData,\\n        bytes32 nodeID,\\n        uint256 amount,\\n        address redeemAddress,\\n        uint48 expiryTime,\\n        address executor\\n    )\\n        external\\n        override\\n        onlyNotSuspended\\n        nzBytes32(nodeID)\\n        nzUint(amount)\\n        nzAddr(redeemAddress)\\n        consumesKeyNonce(\\n            sigData,\\n            keccak256(abi.encode(this.registerRedemption.selector, nodeID, amount, redeemAddress, expiryTime, executor))\\n        )\\n    {\\n        require(\\n            // Must be fresh or have been executed & deleted, or past the expiry\\n            block.timestamp > uint256(_pendingRedemptions[nodeID].expiryTime),\\n            \\\"Gateway: a pending redemption exists\\\"\\n        );\\n\\n        uint48 startTime = uint48(block.timestamp) + REDEMPTION_DELAY;\\n        require(expiryTime > startTime, \\\"Gateway: expiry time too soon\\\");\\n\\n        _pendingRedemptions[nodeID] = Redemption(amount, redeemAddress, startTime, expiryTime, executor);\\n        emit RedemptionRegistered(nodeID, amount, redeemAddress, startTime, expiryTime, executor);\\n    }\\n\\n    /**\\n     * @notice  Execute a pending redemption to get back funds. Cannot execute a pending\\n     *          redemption before 48h have passed after registering it, or after the specified\\n     *          expiry time\\n     * @dev     No need for nzUint(nodeID) since that is handled by `redemption.expiryTime > 0`\\n     * @param nodeID    The nodeID of the funder\\n     */\\n    function executeRedemption(bytes32 nodeID) external override onlyNotSuspended returns (address, uint256) {\\n        Redemption memory redemption = _pendingRedemptions[nodeID];\\n        require(\\n            block.timestamp >= redemption.startTime && redemption.expiryTime > 0,\\n            \\\"Gateway: early or already execd\\\"\\n        );\\n\\n        // Housekeeping\\n        delete _pendingRedemptions[nodeID];\\n\\n        if (block.timestamp <= redemption.expiryTime) {\\n            if (redemption.executor != address(0)) {\\n                require(msg.sender == redemption.executor, \\\"Gateway: not executor\\\");\\n            }\\n            emit RedemptionExecuted(nodeID, redemption.amount);\\n\\n            // Send the tokens\\n            _FLIP.transfer(redemption.redeemAddress, redemption.amount);\\n            return (redemption.redeemAddress, redemption.amount);\\n        } else {\\n            emit RedemptionExpired(nodeID, redemption.amount);\\n            return (redemption.redeemAddress, 0);\\n        }\\n    }\\n\\n    /**\\n     * @notice  Compares a given new FLIP supply against the old supply and mints or burns\\n     *          FLIP tokens from this contract as appropriate.\\n     *          It requires a message signed by the aggregate key.\\n     * @dev     Hardcoded to only mint and burn FLIP tokens to/from this contract.\\n     * @param sigData               Struct containing the signature data over the message\\n     *                              to verify, signed by the aggregate key.\\n     * @param newTotalSupply        new total supply of FLIP\\n     * @param stateChainBlockNumber State Chain block number for the new total supply\\n     */\\n    function updateFlipSupply(\\n        SigData calldata sigData,\\n        uint256 newTotalSupply,\\n        uint256 stateChainBlockNumber\\n    )\\n        external\\n        override\\n        onlyNotSuspended\\n        nzUint(newTotalSupply)\\n        consumesKeyNonce(\\n            sigData,\\n            keccak256(abi.encode(this.updateFlipSupply.selector, newTotalSupply, stateChainBlockNumber))\\n        )\\n    {\\n        require(stateChainBlockNumber > _lastSupplyUpdateBlockNum, \\\"Gateway: old FLIP supply update\\\");\\n        _lastSupplyUpdateBlockNum = stateChainBlockNumber;\\n        IFLIP flip = _FLIP;\\n        uint256 oldSupply = flip.totalSupply();\\n        if (newTotalSupply < oldSupply) {\\n            uint256 amount = oldSupply - newTotalSupply;\\n            flip.burn(address(this), amount);\\n        } else if (newTotalSupply > oldSupply) {\\n            uint256 amount = newTotalSupply - oldSupply;\\n            flip.mint(address(this), amount);\\n        }\\n        emit FlipSupplyUpdated(oldSupply, newTotalSupply, stateChainBlockNumber);\\n    }\\n\\n    /**\\n     * @notice  Updates the address that is allowed to issue FLIP tokens. This will be used when this\\n     *          contract needs an upgrade. A new contract will be deployed and all the FLIP will be\\n     *          transferred to it via the redemption process. Finally the right to issue FLIP will be transferred.\\n     * @dev     The new issuer must be a contract and, in a standard upgrade, it must have the reference FLIP address.\\n     *          In a special case where the check is omitted, the new issuer must be a contract, never an EOA.\\n     * @param sigData     Struct containing the signature data over the message\\n     *                    to verify, signed by the aggregate key.\\n     * @param newIssuer   New contract that will issue FLIP tokens.\\n     * @param omitChecks Allow the omission of the extra checks in a special case\\n     */\\n    function updateFlipIssuer(\\n        SigData calldata sigData,\\n        address newIssuer,\\n        bool omitChecks\\n    )\\n        external\\n        override\\n        onlyNotSuspended\\n        nzAddr(newIssuer)\\n        consumesKeyNonce(sigData, keccak256(abi.encode(this.updateFlipIssuer.selector, newIssuer, omitChecks)))\\n    {\\n        if (!omitChecks) {\\n            require(IFlipIssuer(newIssuer).getFLIP() == _FLIP, \\\"Gateway: wrong FLIP ref\\\");\\n        } else {\\n            require(newIssuer.code.length > 0);\\n        }\\n\\n        _FLIP.updateIssuer(newIssuer);\\n    }\\n\\n    /**\\n     * @notice      Set the minimum amount of funds needed for `fundStateChainAccount` to be able\\n     *              to be called. Used to prevent spamming of funding.\\n     * @param newMinFunding   The new minimum funding amount\\n     */\\n    function setMinFunding(uint256 newMinFunding) external override nzUint(newMinFunding) onlyGovernor {\\n        emit MinFundingChanged(_minFunding, newMinFunding);\\n        _minFunding = newMinFunding;\\n    }\\n\\n    /**\\n     * @notice Withdraw all FLIP to governance address in case of emergency. This withdrawal needs\\n     *         to be approved by the Community, it is a last resort. Used to rectify an emergency.\\n     *         Transfer the issuance to the governance address if this contract is the issuer.\\n     */\\n    function govWithdraw() external override onlyGovernor onlyCommunityGuardDisabled onlySuspended {\\n        IFLIP flip = _FLIP;\\n        uint256 amount = flip.balanceOf(address(this));\\n\\n        // Could use msg.sender or getGovernor() but hardcoding the get call just for extra safety\\n        address governor = getKeyManager().getGovernanceKey();\\n        flip.transfer(governor, amount);\\n        emit GovernanceWithdrawal(governor, amount);\\n\\n        // Check issuer to ensure this doesn't revert\\n        if (flip.getIssuer() == address(this)) {\\n            flip.updateIssuer(governor);\\n        }\\n    }\\n\\n    /**\\n     * @notice Update the FLIP Issuer address with the governance address in case of emergency.\\n     *         This needs to be approved by the Community, it is a last resort. Used to rectify\\n     *         an emergency.\\n     */\\n    function govUpdateFlipIssuer() external override onlyGovernor onlyCommunityGuardDisabled onlySuspended {\\n        address governor = getKeyManager().getGovernanceKey();\\n        _FLIP.updateIssuer(governor);\\n    }\\n\\n    //////////////////////////////////////////////////////////////\\n    //                                                          //\\n    //                  Non-state-changing functions            //\\n    //                                                          //\\n    //////////////////////////////////////////////////////////////\\n\\n    /**\\n     * @notice  Get the minimum amount of funds that's required for funding\\n     *          an account on the StateChain.\\n     * @return  The minimum amount (uint)\\n     */\\n    function getMinimumFunding() external view override returns (uint256) {\\n        return _minFunding;\\n    }\\n\\n    /**\\n     * @notice  Get the pending redemption for the input nodeID. If there was never\\n     *          a pending redemption for this nodeID, or it has already been executed\\n     *          (and therefore deleted), it'll return (0, 0x00..., 0, 0)\\n     * @param nodeID   The nodeID which has a pending redemption\\n     * @return         The redemption (Redemption struct)\\n     */\\n    function getPendingRedemption(bytes32 nodeID) external view override returns (Redemption memory) {\\n        return _pendingRedemptions[nodeID];\\n    }\\n\\n    /**\\n     * @notice  Get the last state chain block number of the last supply update\\n     * @return  The state chain block number of the last supply update\\n     */\\n    function getLastSupplyUpdateBlockNumber() external view override returns (uint256) {\\n        return _lastSupplyUpdateBlockNum;\\n    }\\n}\\n\"\r\n    },\r\n    \"IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"IStateChainGateway.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"IFLIP.sol\\\";\\nimport \\\"IAggKeyNonceConsumer.sol\\\";\\nimport \\\"IGovernanceCommunityGuarded.sol\\\";\\nimport \\\"IFlipIssuer.sol\\\";\\n\\n/**\\n * @title    StateChainGateway interface\\n */\\ninterface IStateChainGateway is IGovernanceCommunityGuarded, IFlipIssuer, IAggKeyNonceConsumer {\\n    event Funded(bytes32 indexed nodeID, uint256 amount, address funder);\\n    event RedemptionRegistered(\\n        bytes32 indexed nodeID,\\n        uint256 amount,\\n        address indexed redeemAddress,\\n        uint48 startTime,\\n        uint48 expiryTime,\\n        address executor\\n    );\\n    event RedemptionExecuted(bytes32 indexed nodeID, uint256 amount);\\n    event RedemptionExpired(bytes32 indexed nodeID, uint256 amount);\\n    event MinFundingChanged(uint256 oldMinFunding, uint256 newMinFunding);\\n    event GovernanceWithdrawal(address to, uint256 amount);\\n    event FLIPSet(address flip);\\n    event FlipSupplyUpdated(uint256 oldSupply, uint256 newSupply, uint256 stateChainBlockNumber);\\n\\n    struct Redemption {\\n        uint256 amount;\\n        address redeemAddress;\\n        // 48 so that 160 (from redeemAddress) + 48 + 48 is 256 they can all be packed\\n        // into a single 256 bit slot\\n        uint48 startTime;\\n        uint48 expiryTime;\\n        address executor;\\n    }\\n\\n    /**\\n     * @notice  Sets the FLIP address after initialization. We can't do this in the constructor\\n     *          because FLIP contract requires this contract's address on deployment for minting.\\n     *          First this contract is deployed, then the FLIP contract and finally setFLIP\\n     *          should be called. OnlyDeployer modifer for added security since tokens will be\\n     *          minted to this contract before calling setFLIP.\\n     * @param flip FLIP token address\\n     */\\n    function setFlip(IFLIP flip) external;\\n\\n    /**\\n     * @notice          Add FLIP funds to a StateChain account identified with a nodeID\\n     * @dev             Requires the funder to have called `approve` in FLIP\\n     * @param amount    The amount of FLIP tokens\\n     * @param nodeID    The nodeID of the account to fund\\n     */\\n    function fundStateChainAccount(bytes32 nodeID, uint256 amount) external;\\n\\n    /**\\n     * @notice  Redeem FLIP from the StateChain. The State Chain will determine the amount\\n     *          that can be redeemed, but a basic calculation for a validator would be:\\n     *          amount redeemable = stake + rewards - penalties.\\n     * @param sigData   Struct containing the signature data over the message\\n     *                  to verify, signed by the aggregate key.\\n     * @param nodeID    The nodeID of the account redeeming the FLIP\\n     * @param amount    The amount of funds to be locked up\\n     * @param redeemAddress    The redeemAddress who will receive the FLIP\\n     * @param expiryTime   The last valid timestamp that can execute this redemption (uint48)\\n     */\\n    function registerRedemption(\\n        SigData calldata sigData,\\n        bytes32 nodeID,\\n        uint256 amount,\\n        address redeemAddress,\\n        uint48 expiryTime,\\n        address executor\\n    ) external;\\n\\n    /**\\n     * @notice  Execute a pending redemption to get back funds. Cannot execute a pending\\n     *          redemption before 48h have passed after registering it, or after the specified\\n     *          expiry time\\n     * @dev     No need for nzUint(nodeID) since that is handled by `redemption.expiryTime > 0`\\n     * @param nodeID    The nodeID of the account redeeming the FLIP\\n     * @return          The address that received the FLIP and the amount\\n     */\\n    function executeRedemption(bytes32 nodeID) external returns (address, uint256);\\n\\n    /**\\n     * @notice  Compares a given new FLIP supply against the old supply and mints or burns\\n     *          FLIP tokens from this contract as appropriate.\\n     *          It requires a message signed by the aggregate key.\\n     * @param sigData    Struct containing the signature data over the message\\n     *                   to verify, signed by the aggregate key.\\n     * @param newTotalSupply        new total supply of FLIP\\n     * @param stateChainBlockNumber State Chain block number for the new total supply\\n     */\\n    function updateFlipSupply(SigData calldata sigData, uint256 newTotalSupply, uint256 stateChainBlockNumber) external;\\n\\n    /**\\n     * @notice  Updates the address that is allowed to issue FLIP tokens. This will be used when this\\n     *          contract needs an upgrade. A new contract will be deployed and all the FLIP will be\\n     *          transferred to it via the redemption process. Finally the right to issue FLIP will be transferred.\\n     * @param sigData     Struct containing the signature data over the message\\n     *                    to verify, signed by the aggregate key.\\n     * @param newIssuer   New contract that will issue FLIP tokens.\\n     * @param omitChecks Allow the omission of the extra checks in a special case\\n     */\\n    function updateFlipIssuer(SigData calldata sigData, address newIssuer, bool omitChecks) external;\\n\\n    /**\\n     * @notice      Set the minimum amount of funds needed for `fundStateChainAccount` to be able\\n     *              to be called. Used to prevent spamming of funding.\\n     * @param newMinFunding   The new minimum funding amount\\n     */\\n    function setMinFunding(uint256 newMinFunding) external;\\n\\n    /**\\n     * @notice Withdraw all FLIP to governance address in case of emergency. This withdrawal needs\\n     *         to be approved by the Community, it is a last resort. Used to rectify an emergency.\\n     *         The governance address is also updated as the issuer of FLIP.\\n     */\\n    function govWithdraw() external;\\n\\n    /**\\n     * @notice Update the FLIP Issuer address with the governance address in case of emergency.\\n     *         This needs to be approved by the Community, it is a last resort. Used to rectify\\n     *         an emergency.\\n     */\\n    function govUpdateFlipIssuer() external;\\n\\n    //////////////////////////////////////////////////////////////\\n    //                                                          //\\n    //                  Non-state-changing functions            //\\n    //                                                          //\\n    //////////////////////////////////////////////////////////////\\n\\n    /**\\n     * @notice  Get the minimum amount of funds that's required for funding\\n     *          an account on the StateChain.\\n     * @return  The minimum amount (uint)\\n     */\\n    function getMinimumFunding() external view returns (uint256);\\n\\n    /**\\n     * @notice  Get the pending redemption for the input nodeID. If there was never\\n     *          a pending redemption for this nodeID, or it has already been executed\\n     *          (and therefore deleted), it'll return (0, 0x00..., 0, 0)\\n     * @param nodeID   The nodeID which has a pending redemption\\n     * @return         The redemption (Redemption struct)\\n     */\\n    function getPendingRedemption(bytes32 nodeID) external view returns (Redemption memory);\\n\\n    /**\\n     * @notice  Get the last state chain block number that the supply was updated at\\n     * @return  The state chain block number of the last update\\n     */\\n    function getLastSupplyUpdateBlockNumber() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"IFLIP.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"IERC20.sol\\\";\\n\\n/**\\n * @title    FLIP interface for the FLIP utility token\\n */\\ninterface IFLIP is IERC20 {\\n    event IssuerUpdated(address oldIssuer, address newIssuer);\\n\\n    //////////////////////////////////////////////////////////////\\n    //                                                          //\\n    //                  State-changing functions                //\\n    //                                                          //\\n    //////////////////////////////////////////////////////////////\\n\\n    function mint(address account, uint amount) external;\\n\\n    function burn(address account, uint amount) external;\\n\\n    function updateIssuer(address newIssuer) external;\\n\\n    //////////////////////////////////////////////////////////////\\n    //                                                          //\\n    //                  Non-state-changing functions            //\\n    //                                                          //\\n    //////////////////////////////////////////////////////////////\\n\\n    function getIssuer() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"IAggKeyNonceConsumer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"IShared.sol\\\";\\nimport \\\"IKeyManager.sol\\\";\\n\\n/**\\n * @title    AggKeyNonceConsumer interface\\n */\\n\\ninterface IAggKeyNonceConsumer is IShared {\\n    event UpdatedKeyManager(address keyManager);\\n\\n    //////////////////////////////////////////////////////////////\\n    //                                                          //\\n    //                  State-changing functions                //\\n    //                                                          //\\n    //////////////////////////////////////////////////////////////\\n    /**\\n     * @notice  Update KeyManager reference. Used if KeyManager contract is updated\\n     * @param sigData    Struct containing the signature data over the message\\n     *                   to verify, signed by the aggregate key.\\n     * @param keyManager New KeyManager's address\\n     * @param omitChecks Allow the omission of the extra checks in a special case\\n     */\\n    function updateKeyManager(SigData calldata sigData, IKeyManager keyManager, bool omitChecks) external;\\n\\n    //////////////////////////////////////////////////////////////\\n    //                                                          //\\n    //                          Getters                         //\\n    //                                                          //\\n    //////////////////////////////////////////////////////////////\\n\\n    /**\\n     * @notice  Get the KeyManager address/interface that's used to validate sigs\\n     * @return  The KeyManager (IKeyManager)\\n     */\\n    function getKeyManager() external view returns (IKeyManager);\\n}\\n\"\r\n    },\r\n    \"IShared.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\nimport \\\"IERC20.sol\\\";\\n\\n/**\\n * @title    Shared interface\\n * @notice   Holds structs needed by other interfaces\\n */\\ninterface IShared {\\n    /**\\n     * @dev  SchnorrSECP256K1 requires that each key has a public key part (x coordinate),\\n     *       a parity for the y coordinate (0 if the y ordinate of the public key is even, 1\\n     *       if it's odd)\\n     */\\n    struct Key {\\n        uint256 pubKeyX;\\n        uint8 pubKeyYParity;\\n    }\\n\\n    /**\\n     * @dev  Contains a signature and the nonce used to create it. Also the recovered address\\n     *       to check that the signature is valid\\n     */\\n    struct SigData {\\n        uint256 sig;\\n        uint256 nonce;\\n        address kTimesGAddress;\\n    }\\n\\n    /**\\n     * @param token The address of the token to be transferred\\n     * @param recipient The address of the recipient of the transfer\\n     * @param amount    The amount to transfer, in wei (uint)\\n     */\\n    struct TransferParams {\\n        address token;\\n        address payable recipient;\\n        uint256 amount;\\n    }\\n\\n    /**\\n     * @param swapID    The unique identifier for this swap (bytes32), used for create2\\n     * @param token     The token to be transferred\\n     */\\n    struct DeployFetchParams {\\n        bytes32 swapID;\\n        address token;\\n    }\\n\\n    /**\\n     * @param fetchContract   The address of the deployed Deposit contract\\n     * @param token     The token to be transferred\\n     */\\n    struct FetchParams {\\n        address payable fetchContract;\\n        address token;\\n    }\\n}\\n\"\r\n    },\r\n    \"IKeyManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"IShared.sol\\\";\\n\\n/**\\n * @title    KeyManager interface\\n * @notice   The interface for functions KeyManager implements\\n */\\ninterface IKeyManager is IShared {\\n    event AggKeySetByAggKey(Key oldAggKey, Key newAggKey);\\n    event AggKeySetByGovKey(Key oldAggKey, Key newAggKey);\\n    event GovKeySetByAggKey(address oldGovKey, address newGovKey);\\n    event GovKeySetByGovKey(address oldGovKey, address newGovKey);\\n    event CommKeySetByAggKey(address oldCommKey, address newCommKey);\\n    event CommKeySetByCommKey(address oldCommKey, address newCommKey);\\n    event SignatureAccepted(SigData sigData, address signer);\\n    event GovernanceAction(bytes32 message);\\n\\n    //////////////////////////////////////////////////////////////\\n    //                                                          //\\n    //                  State-changing functions                //\\n    //                                                          //\\n    //////////////////////////////////////////////////////////////\\n\\n    function consumeKeyNonce(SigData memory sigData, bytes32 contractMsgHash) external;\\n\\n    function setAggKeyWithAggKey(SigData memory sigData, Key memory newAggKey) external;\\n\\n    function setAggKeyWithGovKey(Key memory newAggKey) external;\\n\\n    function setGovKeyWithAggKey(SigData calldata sigData, address newGovKey) external;\\n\\n    function setGovKeyWithGovKey(address newGovKey) external;\\n\\n    function setCommKeyWithAggKey(SigData calldata sigData, address newCommKey) external;\\n\\n    function setCommKeyWithCommKey(address newCommKey) external;\\n\\n    function govAction(bytes32 message) external;\\n\\n    //////////////////////////////////////////////////////////////\\n    //                                                          //\\n    //                  Non-state-changing functions            //\\n    //                                                          //\\n    //////////////////////////////////////////////////////////////\\n\\n    function getAggregateKey() external view returns (Key memory);\\n\\n    function getGovernanceKey() external view returns (address);\\n\\n    function getCommunityKey() external view returns (address);\\n\\n    function isNonceUsedByAggKey(uint256 nonce) external view returns (bool);\\n\\n    function getLastValidateTime() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"IGovernanceCommunityGuarded.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"IShared.sol\\\";\\n\\n/**\\n * @title    GovernanceCommunityGuarded interface\\n */\\n\\ninterface IGovernanceCommunityGuarded is IShared {\\n    event CommunityGuardDisabled(bool communityGuardDisabled);\\n    event Suspended(bool suspended);\\n\\n    //////////////////////////////////////////////////////////////\\n    //                                                          //\\n    //                  State-changing functions                //\\n    //                                                          //\\n    //////////////////////////////////////////////////////////////\\n    /**\\n     * @notice  Enable Community Guard\\n     */\\n\\n    function enableCommunityGuard() external;\\n\\n    /**\\n     * @notice  Disable Community Guard\\n     */\\n    function disableCommunityGuard() external;\\n\\n    /**\\n     * @notice  Can be used to suspend contract execution - only executable by\\n     *          governance and only to be used in case of emergency.\\n     */\\n    function suspend() external;\\n\\n    /**\\n     * @notice      Resume contract execution\\n     */\\n    function resume() external;\\n\\n    //////////////////////////////////////////////////////////////\\n    //                                                          //\\n    //                          Getters                         //\\n    //                                                          //\\n    //////////////////////////////////////////////////////////////\\n\\n    /**\\n     * @notice  Get the Community Key\\n     * @return  The CommunityKey\\n     */\\n    function getCommunityKey() external view returns (address);\\n\\n    /**\\n     * @notice  Get the Community Guard state\\n     * @return  The Community Guard state\\n     */\\n    function getCommunityGuardDisabled() external view returns (bool);\\n\\n    /**\\n     * @notice  Get suspended state\\n     * @return  The suspended state\\n     */\\n    function getSuspendedState() external view returns (bool);\\n\\n    /**\\n     * @notice  Get governor address\\n     * @return  The governor address\\n     */\\n    function getGovernor() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"IFlipIssuer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"IFLIP.sol\\\";\\n\\n/**\\n * @title    Flip Issuer interface\\n * @notice   This interface is required when updating the FLIP issuer.\\n *           Additionally, any contract inheriting this should implement the\\n *           mint and burn capabilities to interact with the FLIP contract.\\n */\\ninterface IFlipIssuer {\\n    /**\\n     * @notice  Get the FLIP token address\\n     * @return  The address of FLIP\\n     */\\n    function getFLIP() external view returns (IFLIP);\\n}\\n\"\r\n    },\r\n    \"AggKeyNonceConsumer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"IKeyManager.sol\\\";\\nimport \\\"IAggKeyNonceConsumer.sol\\\";\\nimport \\\"Shared.sol\\\";\\n\\n/**\\n * @title    AggKeyNonceConsumer contract\\n * @notice   Manages the reference to the KeyManager contract. The address\\n *           is set in the constructor and can only be updated with a valid\\n *           signature validated by the current KeyManager contract. This shall\\n *           be done if the KeyManager contract is updated.\\n */\\nabstract contract AggKeyNonceConsumer is Shared, IAggKeyNonceConsumer {\\n    /// @dev    The KeyManager used to checks sigs used in functions here\\n    IKeyManager private _keyManager;\\n\\n    constructor(IKeyManager keyManager) nzAddr(address(keyManager)) {\\n        _keyManager = keyManager;\\n    }\\n\\n    //////////////////////////////////////////////////////////////\\n    //                                                          //\\n    //                  State-changing functions                //\\n    //                                                          //\\n    //////////////////////////////////////////////////////////////\\n\\n    /**\\n     * @notice  Update KeyManager reference. Used if KeyManager contract is updated\\n     * @param sigData    Struct containing the signature data over the message\\n     *                   to verify, signed by the aggregate key.\\n     * @param keyManager New KeyManager's address\\n     * @param omitChecks Allow the omission of the extra checks in a special case\\n     */\\n    function updateKeyManager(\\n        SigData calldata sigData,\\n        IKeyManager keyManager,\\n        bool omitChecks\\n    )\\n        external\\n        override\\n        nzAddr(address(keyManager))\\n        consumesKeyNonce(sigData, keccak256(abi.encode(this.updateKeyManager.selector, keyManager, omitChecks)))\\n    {\\n        // Check that the new KeyManager is a contract\\n        require(address(keyManager).code.length > 0);\\n\\n        // Allow the child to check compatibility with the new KeyManager\\n        _checkUpdateKeyManager(keyManager, omitChecks);\\n\\n        _keyManager = keyManager;\\n        emit UpdatedKeyManager(address(keyManager));\\n    }\\n\\n    /// @dev   This will be called when upgrading to a new KeyManager. This allows the child's contract\\n    ///        to check its compatibility with the new KeyManager. This is to prevent the contract from\\n    //         getting bricked. There is no good way to enforce the implementation of consumeKeyNonce().\\n    function _checkUpdateKeyManager(IKeyManager keyManager, bool omitChecks) internal view virtual;\\n\\n    //////////////////////////////////////////////////////////////\\n    //                                                          //\\n    //                          Getters                         //\\n    //                                                          //\\n    //////////////////////////////////////////////////////////////\\n\\n    /**\\n     * @notice  Get the KeyManager address/interface that's used to validate sigs\\n     * @return  The KeyManager (IKeyManager)\\n     */\\n    function getKeyManager() public view override returns (IKeyManager) {\\n        return _keyManager;\\n    }\\n\\n    //////////////////////////////////////////////////////////////\\n    //                                                          //\\n    //                         Modifiers                        //\\n    //                                                          //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @dev    Calls consumeKeyNonce in _keyManager\\n    modifier consumesKeyNonce(SigData calldata sigData, bytes32 contractMsgHash) {\\n        getKeyManager().consumeKeyNonce(sigData, contractMsgHash);\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"Shared.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"IShared.sol\\\";\\n\\n/**\\n * @title    Shared contract\\n * @notice   Holds constants and modifiers that are used in multiple contracts\\n * @dev      It would be nice if this could be a library, but modifiers can't be exported :(\\n */\\n\\nabstract contract Shared is IShared {\\n    /// @dev The address used to indicate whether transfer should send native or a token\\n    address internal constant _NATIVE_ADDR = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n    address internal constant _ZERO_ADDR = address(0);\\n    bytes32 internal constant _NULL = \\\"\\\";\\n    uint256 internal constant _E_18 = 1e18;\\n\\n    /// @dev    Checks that a uint isn't zero/empty\\n    modifier nzUint(uint256 u) {\\n        require(u != 0, \\\"Shared: uint input is empty\\\");\\n        _;\\n    }\\n\\n    /// @dev    Checks that an address isn't zero/empty\\n    modifier nzAddr(address a) {\\n        require(a != _ZERO_ADDR, \\\"Shared: address input is empty\\\");\\n        _;\\n    }\\n\\n    /// @dev    Checks that a bytes32 isn't zero/empty\\n    modifier nzBytes32(bytes32 b) {\\n        require(b != _NULL, \\\"Shared: bytes32 input is empty\\\");\\n        _;\\n    }\\n\\n    /// @dev    Checks that the pubKeyX is populated\\n    modifier nzKey(Key memory key) {\\n        require(key.pubKeyX != 0, \\\"Shared: pubKeyX is empty\\\");\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"GovernanceCommunityGuarded.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"IGovernanceCommunityGuarded.sol\\\";\\nimport \\\"AggKeyNonceConsumer.sol\\\";\\nimport \\\"Shared.sol\\\";\\n\\n/**\\n * @title    GovernanceCommunityGuarded contract\\n * @notice   Allows the governor to perform certain actions for the procotol's safety in\\n *           case of emergency. The aim is to allow the governor to suspend execution of\\n *           critical functions.\\n *           Also, it allows the CommunityKey to safeguard certain functions so the\\n *           governor can execute them iff the communityKey allows it.\\n */\\nabstract contract GovernanceCommunityGuarded is Shared, IGovernanceCommunityGuarded {\\n    /// @dev    Community Guard Disabled\\n    bool private _communityGuardDisabled;\\n\\n    /// @dev    Whether execution is suspended\\n    bool private _suspended = false;\\n\\n    /**\\n     * @notice  Get the governor's address. The contracts inheriting this (StateChainGateway and Vault)\\n     *          get the governor's address from the KeyManager through the AggKeyNonceConsumer's\\n     *          inheritance. Therefore, the implementation of this function must be left\\n     *          to the children. This is not implemented as a virtual onlyGovernor modifier to force\\n     *          the children to implement this function - virtual modifiers don't enforce that.\\n     * @return  The governor's address\\n     */\\n    function _getGovernor() internal view virtual returns (address);\\n\\n    /**\\n     * @notice  Get the community's address. The contracts inheriting this (StateChainGateway and Vault)\\n     *          get the community's address from the KeyManager through the AggKeyNonceConsumer's\\n     *          inheritance. Therefore, the implementation of this function must be left\\n     *          to the children. This is not implemented as a virtual onlyCommunityKey modifier to force\\n     *          the children to implement this function - virtual modifiers don't enforce that.\\n     * @return  The community's address\\n     */\\n    function _getCommunityKey() internal view virtual returns (address);\\n\\n    //////////////////////////////////////////////////////////////\\n    //                                                          //\\n    //                  State-changing functions                //\\n    //                                                          //\\n    //////////////////////////////////////////////////////////////\\n\\n    /**\\n     * @notice  Enable Community Guard\\n     */\\n    function enableCommunityGuard() external override onlyCommunityKey onlyCommunityGuardDisabled {\\n        _communityGuardDisabled = false;\\n        emit CommunityGuardDisabled(false);\\n    }\\n\\n    /**\\n     * @notice  Disable Community Guard\\n     */\\n    function disableCommunityGuard() external override onlyCommunityKey onlyCommunityGuardEnabled {\\n        _communityGuardDisabled = true;\\n        emit CommunityGuardDisabled(true);\\n    }\\n\\n    /**\\n     * @notice Can be used to suspend contract execution - only executable by\\n     * governance and only to be used in case of emergency.\\n     */\\n    function suspend() external override onlyGovernor onlyNotSuspended {\\n        _suspended = true;\\n        emit Suspended(true);\\n    }\\n\\n    /**\\n     * @notice      Resume contract execution\\n     */\\n    function resume() external override onlyGovernor onlySuspended {\\n        _suspended = false;\\n        emit Suspended(false);\\n    }\\n\\n    //////////////////////////////////////////////////////////////\\n    //                                                          //\\n    //                          Getters                         //\\n    //                                                          //\\n    //////////////////////////////////////////////////////////////\\n\\n    /**\\n     * @notice  Get the Community Key\\n     * @return  The CommunityKey\\n     */\\n    function getCommunityKey() external view override returns (address) {\\n        return _getCommunityKey();\\n    }\\n\\n    /**\\n     * @notice  Get the Community Guard state\\n     * @return  The Community Guard state\\n     */\\n    function getCommunityGuardDisabled() external view override returns (bool) {\\n        return _communityGuardDisabled;\\n    }\\n\\n    /**\\n     * @notice  Get suspended state\\n     * @return  The suspended state\\n     */\\n    function getSuspendedState() external view override returns (bool) {\\n        return _suspended;\\n    }\\n\\n    /**\\n     * @notice  Get governor address\\n     * @return  The governor address\\n     */\\n    function getGovernor() external view override returns (address) {\\n        return _getGovernor();\\n    }\\n\\n    //////////////////////////////////////////////////////////////\\n    //                                                          //\\n    //                         Modifiers                        //\\n    //                                                          //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @dev    Check that the caller is the Community Key address.\\n    modifier onlyCommunityKey() {\\n        require(msg.sender == _getCommunityKey(), \\\"Governance: not Community Key\\\");\\n        _;\\n    }\\n\\n    /// @dev    Check that community has disabled the community guard.\\n    modifier onlyCommunityGuardDisabled() {\\n        require(_communityGuardDisabled, \\\"Governance: community guard enabled\\\");\\n        _;\\n    }\\n\\n    /// @dev    Check that community has disabled the community guard.\\n    modifier onlyCommunityGuardEnabled() {\\n        require(!_communityGuardDisabled, \\\"Governance: community guard disabled\\\");\\n        _;\\n    }\\n\\n    /// @notice Ensure that the caller is the governor address. Calls the getGovernor\\n    ///         function which is implemented by the children.\\n    modifier onlyGovernor() {\\n        require(msg.sender == _getGovernor(), \\\"Governance: not governor\\\");\\n        _;\\n    }\\n\\n    // @notice Check execution is suspended\\n    modifier onlySuspended() {\\n        require(_suspended, \\\"Governance: not suspended\\\");\\n        _;\\n    }\\n\\n    // @notice Check execution is not suspended\\n    modifier onlyNotSuspended() {\\n        require(!_suspended, \\\"Governance: suspended\\\");\\n        _;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"paris\",\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 800\r\n    },\r\n    \"libraries\": {\r\n      \"StateChainGateway.sol\": {}\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IKeyManager\",\"name\":\"keyManager\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minFunding\",\"type\":\"uint256\"},{\"internalType\":\"uint48\",\"name\":\"redemptionDelay\",\"type\":\"uint48\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"communityGuardDisabled\",\"type\":\"bool\"}],\"name\":\"CommunityGuardDisabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"flip\",\"type\":\"address\"}],\"name\":\"FLIPSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldSupply\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newSupply\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stateChainBlockNumber\",\"type\":\"uint256\"}],\"name\":\"FlipSupplyUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"nodeID\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"funder\",\"type\":\"address\"}],\"name\":\"Funded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"GovernanceWithdrawal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldMinFunding\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newMinFunding\",\"type\":\"uint256\"}],\"name\":\"MinFundingChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"nodeID\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RedemptionExecuted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"nodeID\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RedemptionExpired\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"nodeID\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"redeemAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint48\",\"name\":\"startTime\",\"type\":\"uint48\"},{\"indexed\":false,\"internalType\":\"uint48\",\"name\":\"expiryTime\",\"type\":\"uint48\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"executor\",\"type\":\"address\"}],\"name\":\"RedemptionRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"suspended\",\"type\":\"bool\"}],\"name\":\"Suspended\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"keyManager\",\"type\":\"address\"}],\"name\":\"UpdatedKeyManager\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"REDEMPTION_DELAY\",\"outputs\":[{\"internalType\":\"uint48\",\"name\":\"\",\"type\":\"uint48\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disableCommunityGuard\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enableCommunityGuard\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"nodeID\",\"type\":\"bytes32\"}],\"name\":\"executeRedemption\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"nodeID\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"fundStateChainAccount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCommunityGuardDisabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCommunityKey\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFLIP\",\"outputs\":[{\"internalType\":\"contract IFLIP\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getGovernor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getKeyManager\",\"outputs\":[{\"internalType\":\"contract IKeyManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLastSupplyUpdateBlockNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMinimumFunding\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"nodeID\",\"type\":\"bytes32\"}],\"name\":\"getPendingRedemption\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"redeemAddress\",\"type\":\"address\"},{\"internalType\":\"uint48\",\"name\":\"startTime\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"expiryTime\",\"type\":\"uint48\"},{\"internalType\":\"address\",\"name\":\"executor\",\"type\":\"address\"}],\"internalType\":\"struct IStateChainGateway.Redemption\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSuspendedState\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"govUpdateFlipIssuer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"govWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"sig\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"kTimesGAddress\",\"type\":\"address\"}],\"internalType\":\"struct IShared.SigData\",\"name\":\"sigData\",\"type\":\"tuple\"},{\"internalType\":\"bytes32\",\"name\":\"nodeID\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"redeemAddress\",\"type\":\"address\"},{\"internalType\":\"uint48\",\"name\":\"expiryTime\",\"type\":\"uint48\"},{\"internalType\":\"address\",\"name\":\"executor\",\"type\":\"address\"}],\"name\":\"registerRedemption\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"resume\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IFLIP\",\"name\":\"flip\",\"type\":\"address\"}],\"name\":\"setFlip\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newMinFunding\",\"type\":\"uint256\"}],\"name\":\"setMinFunding\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"suspend\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"sig\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"kTimesGAddress\",\"type\":\"address\"}],\"internalType\":\"struct IShared.SigData\",\"name\":\"sigData\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"newIssuer\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"omitChecks\",\"type\":\"bool\"}],\"name\":\"updateFlipIssuer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"sig\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"kTimesGAddress\",\"type\":\"address\"}],\"internalType\":\"struct IShared.SigData\",\"name\":\"sigData\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"newTotalSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stateChainBlockNumber\",\"type\":\"uint256\"}],\"name\":\"updateFlipSupply\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"sig\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"kTimesGAddress\",\"type\":\"address\"}],\"internalType\":\"struct IShared.SigData\",\"name\":\"sigData\",\"type\":\"tuple\"},{\"internalType\":\"contract IKeyManager\",\"name\":\"keyManager\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"omitChecks\",\"type\":\"bool\"}],\"name\":\"updateKeyManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "StateChainGateway", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "800", "ConstructorArguments": "000000000000000000000000cd351d3626dc244730796a3168d315168ebf08be0000000000000000000000000000000000000000000000000de0b6b3a7640000000000000000000000000000000000000000000000000000000000000002a300", "EVMVersion": "paris", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}