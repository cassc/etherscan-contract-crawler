{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/NTRewardSystem.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\r\\n\\r\\ninterface ICitizen {\\r\\n    function balanceOf(address owner) external view returns (uint256);\\r\\n}\\r\\n\\r\\ninterface IOuterCitizen {\\r\\n    function balanceOf(address owner) external view returns (uint256);\\r\\n}\\r\\n\\r\\ninterface IStakedOuterCitizen {\\r\\n    function balanceOf(address owner) external view returns (uint256);\\r\\n}\\r\\n\\r\\ninterface ILegacyOuterCitizen {\\r\\n    function balanceOf(address owner) external view returns (uint256);\\r\\n}\\r\\n\\r\\ninterface ILegacyCitizen {\\r\\n    function balanceOf(address owner) external view returns (uint256);\\r\\n}\\r\\n\\r\\ninterface IStakedCitizen {\\r\\n    function balanceOf(address owner) external view returns (uint256);\\r\\n}\\r\\n\\r\\ninterface IERC20 {\\r\\n    function owner() external view returns (address);\\r\\n\\r\\n    function balanceOf(address address_) external view returns (uint256);\\r\\n\\r\\n    function transfer(address to_, uint256 amount_) external returns (bool);\\r\\n\\r\\n    function transferFrom(address from_, address to_, uint256 amount_) external;\\r\\n\\r\\n    function approve(address spender, uint256 amount) external;\\r\\n}\\r\\n\\r\\ncontract NTRewardSystem {\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    error RecipientIsNotACitizen();\\r\\n    error ArrayLenghtsNotEqual();\\r\\n    error PercentagesMaxExceeded();\\r\\n    error NotDesignedToHandle();\\r\\n    error SplitPercentageHasToEqualOneHundred();\\r\\n    error NotAnAdmin();\\r\\n    error BlackListed();\\r\\n\\r\\n    address public vault = 0xfdAb2c282f6481010A92d20BAc46c8becd06b012;\\r\\n    ICitizen public citizenContract =\\r\\n        ICitizen(0xB9951B43802dCF3ef5b14567cb17adF367ed1c0F);\\r\\n\\r\\n    IERC20 public BYTES = IERC20(0xa19f5264F7D7Be11c451C093D8f92592820Bea86);\\r\\n\\r\\n    IOuterCitizen public outerCitizenContract =\\r\\n        IOuterCitizen(0x4481507cc228FA19D203BD42110d679571f7912E);\\r\\n\\r\\n    IStakedCitizen public stakedCitizenContract =\\r\\n        IStakedCitizen(0xd37ea75Dd3c499eDA76304f538CbF356Ed9e7Ed9);\\r\\n\\r\\n    ILegacyCitizen public legacyCitizenContract =\\r\\n        ILegacyCitizen(0xb668beB1Fa440F6cF2Da0399f8C28caB993Bdd65);\\r\\n\\r\\n    ILegacyOuterCitizen public legacyOuterCitizenContract =\\r\\n        ILegacyOuterCitizen(0x9b091d2E0Bb88acE4fe8f0faB87b93D8bA932EC4);\\r\\n\\r\\n    bool public vaultActive;\\r\\n\\r\\n    uint256 public vaultTax = 5 * 1 ether;\\r\\n\\r\\n    mapping(uint8 => uint256) private _calculateReward;\\r\\n    mapping(address => bool) private _controllers;\\r\\n    mapping(address => bool) private _blacklisted;\\r\\n\\r\\n    event BronzeRewarded(\\r\\n        address indexed sender,\\r\\n        uint256 amountInBytes,\\r\\n        address[] indexed recipient\\r\\n    );\\r\\n    event SilverRewarded(\\r\\n        address indexed sender,\\r\\n        uint256 amountInBytes,\\r\\n        address[] indexed recipient\\r\\n    );\\r\\n    event GoldRewarded(\\r\\n        address indexed sender,\\r\\n        uint256 amountInBytes,\\r\\n        address[] indexed recipient\\r\\n    );\\r\\n    event PlatinumRewarded(\\r\\n        address indexed sender,\\r\\n        uint256 amountInBytes,\\r\\n        address[] indexed recipient\\r\\n    );\\r\\n\\r\\n    event AdminAdded(address indexed msgSender, address[] indexed newAdmins);\\r\\n    event AdminRemoved(address indexed msgSender, address[] indexed retiredAdmins);\\r\\n\\r\\n    mapping(address => uint256) public userRewardsTotal;\\r\\n\\r\\n    constructor() {\\r\\n        _controllers[msg.sender] = true;\\r\\n        _calculateReward[1] = 5 * 1 ether;\\r\\n        _calculateReward[2] = 25 * 1 ether;\\r\\n        _calculateReward[3] = 50 * 1 ether;\\r\\n        _calculateReward[4] = 100 * 1 ether;\\r\\n    }\\r\\n\\r\\n    modifier onlyAdmin() {\\r\\n        if (!_controllers[msg.sender]) revert NotAnAdmin();\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function addAdmins(address[] calldata _controller) external onlyAdmin {\\r\\n        for (uint256 i = 0; i < _controller.length; i++) {\\r\\n            _controllers[_controller[i]] = true;\\r\\n        }\\r\\n        emit AdminAdded(msg.sender, _controller);\\r\\n    }\\r\\n\\r\\n    function removeAdmins(address[] calldata _controller) external onlyAdmin {\\r\\n        for (uint256 i = 0; i < _controller.length; i++) {\\r\\n            _controllers[_controller[i]] = false;\\r\\n        }\\r\\n        emit AdminRemoved(msg.sender, _controller);\\r\\n    }\\r\\n\\r\\n    function addBlacklistAddress(\\r\\n        address[] calldata _addresses\\r\\n    ) external onlyAdmin {\\r\\n        for (uint256 i = 0; i < _addresses.length; i++) {\\r\\n            _blacklisted[_addresses[i]] = true;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function removeBlacklistAddress(\\r\\n        address[] calldata _addresses\\r\\n    ) external onlyAdmin {\\r\\n        for (uint256 i = 0; i < _addresses.length; i++) {\\r\\n            _blacklisted[_addresses[i]] = false;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function setRewardForSpecificReward(\\r\\n        uint8 _typeOfReward,\\r\\n        uint256 _bytesInEther\\r\\n    ) external onlyAdmin {\\r\\n        _calculateReward[_typeOfReward] = _bytesInEther;\\r\\n    }\\r\\n\\r\\n    function setVault(address _newVault) external onlyAdmin {\\r\\n        vault = _newVault;\\r\\n    }\\r\\n\\r\\n    function setOuterCitizenContract(\\r\\n        IOuterCitizen _outerCitizenContract\\r\\n    ) external onlyAdmin {\\r\\n        outerCitizenContract = _outerCitizenContract;\\r\\n    }\\r\\n\\r\\n    function setCitizenContract(ICitizen _citizenContract) external onlyAdmin {\\r\\n        citizenContract = _citizenContract;\\r\\n    }\\r\\n\\r\\n    function setStakedCitizenContract(\\r\\n        IStakedCitizen _stakedCitizenContract\\r\\n    ) external onlyAdmin {\\r\\n        stakedCitizenContract = _stakedCitizenContract;\\r\\n    }\\r\\n\\r\\n    function setLegacyCitizenContract(\\r\\n        ILegacyCitizen _legacyCitizenContract\\r\\n    ) external onlyAdmin {\\r\\n        legacyCitizenContract = _legacyCitizenContract;\\r\\n    }\\r\\n\\r\\n    function setLegacyOuterCitizenContract(\\r\\n        ILegacyOuterCitizen _legacyOuterCitizenContract\\r\\n    ) external onlyAdmin {\\r\\n        legacyOuterCitizenContract = _legacyOuterCitizenContract;\\r\\n    }\\r\\n\\r\\n    function setBYTESContract(IERC20 _BYTES) external onlyAdmin {\\r\\n        BYTES = _BYTES;\\r\\n    }\\r\\n\\r\\n    function toggleVaultActive() external onlyAdmin {\\r\\n        vaultActive = !vaultActive;\\r\\n    }\\r\\n\\r\\n    function setVaultTax(uint256 _newTax) external onlyAdmin {\\r\\n        vaultTax = _newTax;\\r\\n    }\\r\\n\\r\\n    function isCitizen(address _recipient) private view {\\r\\n        if (\\r\\n            citizenContract.balanceOf(_recipient) == 0 &&\\r\\n            outerCitizenContract.balanceOf(_recipient) == 0 &&\\r\\n            stakedCitizenContract.balanceOf(_recipient) == 0 &&\\r\\n            legacyCitizenContract.balanceOf(_recipient) == 0 &&\\r\\n            legacyOuterCitizenContract.balanceOf(_recipient) == 0\\r\\n        ) {\\r\\n            revert RecipientIsNotACitizen();\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function rewardBytesSpecificWithCustomSplit(\\r\\n        address[] calldata _recipient,\\r\\n        uint256 _amount,\\r\\n        uint256[] calldata _split\\r\\n    ) external {\\r\\n        if (_recipient.length != _split.length) revert ArrayLenghtsNotEqual();\\r\\n\\r\\n        if (!vaultActive) {\\r\\n            if (_recipient.length == 3) {\\r\\n                isCitizen(_recipient[0]);\\r\\n                isCitizen(_recipient[1]);\\r\\n                isCitizen(_recipient[2]);\\r\\n                rewardBytesPeerToPeerHandleThreeSplit(\\r\\n                    _recipient,\\r\\n                    _amount,\\r\\n                    _split\\r\\n                );\\r\\n            } else {\\r\\n                if (_recipient.length == 2) {\\r\\n                    isCitizen(_recipient[0]);\\r\\n                    isCitizen(_recipient[1]);\\r\\n                    rewardBytesPeerToPeerHandleTwoSplit(\\r\\n                        _recipient,\\r\\n                        _amount,\\r\\n                        _split\\r\\n                    );\\r\\n                } else {\\r\\n                    if (_recipient.length != 1) revert NotDesignedToHandle();\\r\\n                    rewardBytesPeerToPeerOne(_recipient[0], _amount);\\r\\n                }\\r\\n            }\\r\\n        } else {\\r\\n            if (_recipient.length == 3) {\\r\\n                isCitizen(_recipient[0]);\\r\\n                isCitizen(_recipient[1]);\\r\\n                isCitizen(_recipient[2]);\\r\\n                rewardBytesVaultHandleThreeSplit(_recipient, _amount, _split);\\r\\n            } else {\\r\\n                if (_recipient.length == 2) {\\r\\n                    isCitizen(_recipient[0]);\\r\\n                    isCitizen(_recipient[1]);\\r\\n                    rewardBytesVaultHandleTwoSplit(_recipient, _amount, _split);\\r\\n                } else {\\r\\n                    if (_recipient.length != 1) revert NotDesignedToHandle();\\r\\n                    rewardBytesVaultOne(_recipient[0], _amount);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function rewardBytesPeerToPeerHandleTwoSplit(\\r\\n        address[] calldata _recipient,\\r\\n        uint256 _amount,\\r\\n        uint256[] calldata _split\\r\\n    ) private {\\r\\n        if (_blacklisted[msg.sender]) revert BlackListed();\\r\\n        uint256 splitAdded = _split[0] + _split[1];\\r\\n        if (splitAdded > 100 * 1 ether)\\r\\n            revert SplitPercentageHasToEqualOneHundred();\\r\\n        BYTES.transferFrom(\\r\\n            msg.sender,\\r\\n            _recipient[0],\\r\\n            _amount.mul(_split[0]).div(100 * 1 ether)\\r\\n        );\\r\\n        BYTES.transferFrom(\\r\\n            msg.sender,\\r\\n            _recipient[1],\\r\\n            _amount.mul(_split[1]).div(100 * 1 ether)\\r\\n        );\\r\\n        userRewardsTotal[_recipient[0]] += _amount.mul(_split[0]).div(\\r\\n            100 * 1 ether\\r\\n        );\\r\\n        userRewardsTotal[_recipient[1]] += _amount.mul(_split[1]).div(\\r\\n            100 * 1 ether\\r\\n        );\\r\\n        if (100 * 1 ether - splitAdded > 0) {\\r\\n            BYTES.transferFrom(\\r\\n                msg.sender,\\r\\n                _recipient[0],\\r\\n                _amount.mul((100 * 1 ether - splitAdded)).div(100 * 1 ether)\\r\\n            );\\r\\n            userRewardsTotal[_recipient[0]] += _amount\\r\\n                .mul((100 * 1 ether - splitAdded))\\r\\n                .div(100 * 1 ether);\\r\\n        }\\r\\n        emitReward(_recipient, _amount);\\r\\n    }\\r\\n\\r\\n    function rewardBytesPeerToPeerHandleThreeSplit(\\r\\n        address[] calldata _recipient,\\r\\n        uint256 _amount,\\r\\n        uint256[] calldata _split\\r\\n    ) private {\\r\\n        if (_blacklisted[msg.sender]) revert BlackListed();\\r\\n        uint256 splitAdded = _split[0] + _split[1] + _split[2];\\r\\n        if (splitAdded > 100 * 1 ether)\\r\\n            revert SplitPercentageHasToEqualOneHundred();\\r\\n        BYTES.transferFrom(\\r\\n            msg.sender,\\r\\n            _recipient[0],\\r\\n            _amount.mul(_split[0]).div(100 * 1 ether)\\r\\n        );\\r\\n        BYTES.transferFrom(\\r\\n            msg.sender,\\r\\n            _recipient[1],\\r\\n            _amount.mul(_split[1]).div(100 * 1 ether)\\r\\n        );\\r\\n        BYTES.transferFrom(\\r\\n            msg.sender,\\r\\n            _recipient[2],\\r\\n            _amount.mul(_split[2]).div(100 * 1 ether)\\r\\n        );\\r\\n\\r\\n        userRewardsTotal[_recipient[0]] += _amount.mul(_split[0]).div(\\r\\n            100 * 1 ether\\r\\n        );\\r\\n        userRewardsTotal[_recipient[1]] += _amount.mul(_split[1]).div(\\r\\n            100 * 1 ether\\r\\n        );\\r\\n        userRewardsTotal[_recipient[2]] += _amount.mul(_split[2]).div(\\r\\n            100 * 1 ether\\r\\n        );\\r\\n\\r\\n        if (100 * 1 ether - splitAdded > 0) {\\r\\n            BYTES.transferFrom(\\r\\n                msg.sender,\\r\\n                _recipient[0],\\r\\n                _amount.mul((100 * 1 ether - splitAdded)).div(100 * 1 ether)\\r\\n            );\\r\\n            userRewardsTotal[_recipient[0]] += _amount\\r\\n                .mul((100 * 1 ether - splitAdded))\\r\\n                .div(100 * 1 ether);\\r\\n        }\\r\\n\\r\\n        emitReward(_recipient, _amount);\\r\\n    }\\r\\n\\r\\n    function rewardBytesVaultHandleTwoSplit(\\r\\n        address[] calldata _recipient,\\r\\n        uint256 _amount,\\r\\n        uint256[] calldata _split\\r\\n    ) private {\\r\\n        if (_blacklisted[msg.sender]) revert BlackListed();\\r\\n        uint256 splitAdded = _split[0] + _split[1];\\r\\n        if (splitAdded > 100 * 1 ether)\\r\\n            revert SplitPercentageHasToEqualOneHundred();\\r\\n        uint256 balance = _amount;\\r\\n        uint256 executedVaultTax = balance.mul(vaultTax).div(100 * 1 ether);\\r\\n\\r\\n        BYTES.transferFrom(msg.sender, vault, executedVaultTax);\\r\\n\\r\\n        balance -= executedVaultTax;\\r\\n\\r\\n        BYTES.transferFrom(\\r\\n            msg.sender,\\r\\n            _recipient[0],\\r\\n            balance.mul(_split[0]).div(100 * 1 ether)\\r\\n        );\\r\\n        BYTES.transferFrom(\\r\\n            msg.sender,\\r\\n            _recipient[1],\\r\\n            balance.mul(_split[1]).div(100 * 1 ether)\\r\\n        );\\r\\n\\r\\n        userRewardsTotal[_recipient[0]] += balance.mul(_split[0]).div(\\r\\n            100 * 1 ether\\r\\n        );\\r\\n        userRewardsTotal[_recipient[1]] += balance.mul(_split[1]).div(\\r\\n            100 * 1 ether\\r\\n        );\\r\\n\\r\\n        if (100 * 1 ether - splitAdded > 0) {\\r\\n            BYTES.transferFrom(\\r\\n                msg.sender,\\r\\n                _recipient[0],\\r\\n                balance.mul((100 * 1 ether - splitAdded)).div(100 * 1 ether)\\r\\n            );\\r\\n            userRewardsTotal[_recipient[0]] += balance\\r\\n                .mul((100 * 1 ether - splitAdded))\\r\\n                .div(100 * 1 ether);\\r\\n        }\\r\\n\\r\\n        emitReward(_recipient, _amount);\\r\\n    }\\r\\n\\r\\n    function rewardBytesVaultHandleThreeSplit(\\r\\n        address[] calldata _recipient,\\r\\n        uint256 _amount,\\r\\n        uint256[] calldata _split\\r\\n    ) private {\\r\\n        if (_blacklisted[msg.sender]) revert BlackListed();\\r\\n        uint256 splitAdded = _split[0] + _split[1] + _split[2];\\r\\n        if (splitAdded > 100 * 1 ether)\\r\\n            revert SplitPercentageHasToEqualOneHundred();\\r\\n        uint256 balance = _amount;\\r\\n        uint256 executedVaultTax = balance.mul(vaultTax).div(100 * 1 ether);\\r\\n\\r\\n        BYTES.transferFrom(msg.sender, vault, executedVaultTax);\\r\\n\\r\\n        balance -= executedVaultTax;\\r\\n\\r\\n        BYTES.transferFrom(\\r\\n            msg.sender,\\r\\n            _recipient[0],\\r\\n            balance.mul(_split[0]).div(100 * 1 ether)\\r\\n        );\\r\\n        BYTES.transferFrom(\\r\\n            msg.sender,\\r\\n            _recipient[1],\\r\\n            balance.mul(_split[1]).div(100 * 1 ether)\\r\\n        );\\r\\n        BYTES.transferFrom(\\r\\n            msg.sender,\\r\\n            _recipient[2],\\r\\n            balance.mul(_split[2]).div(100 * 1 ether)\\r\\n        );\\r\\n\\r\\n        userRewardsTotal[_recipient[0]] += balance.mul(_split[0]).div(\\r\\n            100 * 1 ether\\r\\n        );\\r\\n        userRewardsTotal[_recipient[1]] += balance.mul(_split[1]).div(\\r\\n            100 * 1 ether\\r\\n        );\\r\\n        userRewardsTotal[_recipient[2]] += balance.mul(_split[2]).div(\\r\\n            100 * 1 ether\\r\\n        );\\r\\n\\r\\n        if (100 * 1 ether - splitAdded > 0) {\\r\\n            BYTES.transferFrom(\\r\\n                msg.sender,\\r\\n                _recipient[0],\\r\\n                balance.mul((100 * 1 ether - splitAdded)).div(100 * 1 ether)\\r\\n            );\\r\\n            userRewardsTotal[_recipient[0]] += balance\\r\\n                .mul((100 * 1 ether - splitAdded))\\r\\n                .div(100 * 1 ether);\\r\\n        }\\r\\n\\r\\n        emitReward(_recipient, _amount);\\r\\n    }\\r\\n\\r\\n    function rewardBytesSpecificWithoutCustomSplit(\\r\\n        address[] calldata _recipient,\\r\\n        uint256 _amount\\r\\n    ) external {\\r\\n        if (!vaultActive) {\\r\\n            if (_recipient.length == 3) {\\r\\n                isCitizen(_recipient[0]);\\r\\n                isCitizen(_recipient[1]);\\r\\n                isCitizen(_recipient[2]);\\r\\n                rewardBytesPeerToPeerHandleThree(_recipient, _amount);\\r\\n            } else {\\r\\n                if (_recipient.length == 2) {\\r\\n                    isCitizen(_recipient[0]);\\r\\n                    isCitizen(_recipient[1]);\\r\\n                    rewardBytesPeerToPeerHandleTwo(_recipient, _amount);\\r\\n                } else {\\r\\n                    if (_recipient.length != 1) revert NotDesignedToHandle();\\r\\n                    rewardBytesPeerToPeerOne(_recipient[0], _amount);\\r\\n                }\\r\\n            }\\r\\n        } else {\\r\\n            if (_recipient.length == 3) {\\r\\n                isCitizen(_recipient[0]);\\r\\n                isCitizen(_recipient[1]);\\r\\n                isCitizen(_recipient[2]);\\r\\n                rewardBytesVaultHandleThree(_recipient, _amount);\\r\\n            } else {\\r\\n                if (_recipient.length == 2) {\\r\\n                    isCitizen(_recipient[0]);\\r\\n                    isCitizen(_recipient[1]);\\r\\n                    rewardBytesVaultHandleTwo(_recipient, _amount);\\r\\n                } else {\\r\\n                    if (_recipient.length != 1) revert NotDesignedToHandle();\\r\\n                    rewardBytesVaultOne(_recipient[0], _amount);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function rewardBytesVaultHandleTwo(\\r\\n        address[] calldata _recipient,\\r\\n        uint256 _amount\\r\\n    ) private {\\r\\n        if (_blacklisted[msg.sender]) revert BlackListed();\\r\\n        uint256 balance = _amount;\\r\\n        uint256 executedVaultTax = balance.mul(vaultTax).div(100 * 1 ether);\\r\\n\\r\\n        BYTES.transferFrom(msg.sender, vault, executedVaultTax);\\r\\n\\r\\n        balance -= executedVaultTax;\\r\\n\\r\\n        uint256 cut = balance.div(2);\\r\\n        BYTES.transferFrom(msg.sender, _recipient[0], cut);\\r\\n        BYTES.transferFrom(msg.sender, _recipient[1], cut);\\r\\n\\r\\n        userRewardsTotal[_recipient[0]] += cut;\\r\\n        userRewardsTotal[_recipient[1]] += cut;\\r\\n\\r\\n        emitReward(_recipient, _amount);\\r\\n    }\\r\\n\\r\\n    function rewardBytesVaultHandleThree(\\r\\n        address[] calldata _recipient,\\r\\n        uint256 _amount\\r\\n    ) private {\\r\\n        if (_blacklisted[msg.sender]) revert BlackListed();\\r\\n        uint256 balance = _amount;\\r\\n        uint256 executedVaultTax = _amount.mul(vaultTax).div(100 * 1 ether);\\r\\n\\r\\n        BYTES.transferFrom(msg.sender, vault, executedVaultTax);\\r\\n\\r\\n        balance -= executedVaultTax;\\r\\n        uint256 cut = balance.div(3);\\r\\n        BYTES.transferFrom(msg.sender, _recipient[0], cut);\\r\\n        BYTES.transferFrom(msg.sender, _recipient[1], cut);\\r\\n        BYTES.transferFrom(msg.sender, _recipient[2], cut);\\r\\n\\r\\n        userRewardsTotal[_recipient[0]] += cut;\\r\\n        userRewardsTotal[_recipient[1]] += cut;\\r\\n        userRewardsTotal[_recipient[2]] += cut;\\r\\n\\r\\n        emitReward(_recipient, _amount);\\r\\n    }\\r\\n\\r\\n    function rewardBytesPeerToPeerHandleOne(\\r\\n        address[] calldata _recipient,\\r\\n        uint256 _amount\\r\\n    ) private {\\r\\n        if (_blacklisted[msg.sender]) revert BlackListed();\\r\\n        BYTES.transferFrom(msg.sender, _recipient[0], _amount);\\r\\n        userRewardsTotal[_recipient[0]] += _amount;\\r\\n\\r\\n        emitReward(_recipient, _amount);\\r\\n    }\\r\\n\\r\\n    function rewardBytesPeerToPeerHandleTwo(\\r\\n        address[] calldata _recipient,\\r\\n        uint256 _amount\\r\\n    ) private {\\r\\n        if (_blacklisted[msg.sender]) revert BlackListed();\\r\\n        uint256 cut = _amount.div(2);\\r\\n        BYTES.transferFrom(msg.sender, _recipient[0], cut);\\r\\n        BYTES.transferFrom(msg.sender, _recipient[1], cut);\\r\\n\\r\\n        userRewardsTotal[_recipient[0]] += cut;\\r\\n        userRewardsTotal[_recipient[1]] += cut;\\r\\n\\r\\n        emitReward(_recipient, _amount);\\r\\n    }\\r\\n\\r\\n    function rewardBytesPeerToPeerHandleThree(\\r\\n        address[] calldata _recipient,\\r\\n        uint256 _amount\\r\\n    ) private {\\r\\n        if (_blacklisted[msg.sender]) revert BlackListed();\\r\\n        uint256 cut = _amount.div(3);\\r\\n        BYTES.transferFrom(msg.sender, _recipient[0], cut);\\r\\n        BYTES.transferFrom(msg.sender, _recipient[1], cut);\\r\\n        BYTES.transferFrom(msg.sender, _recipient[2], cut);\\r\\n\\r\\n        userRewardsTotal[_recipient[0]] += cut;\\r\\n        userRewardsTotal[_recipient[1]] += cut;\\r\\n        userRewardsTotal[_recipient[2]] += cut;\\r\\n\\r\\n        emitReward(_recipient, _amount);\\r\\n    }\\r\\n\\r\\n    function rewardBytesPeerToPeer(\\r\\n        address[] calldata _recipient,\\r\\n        uint256 _amount,\\r\\n        uint256[] calldata _split\\r\\n    ) private {\\r\\n        if (_blacklisted[msg.sender]) revert BlackListed();\\r\\n\\r\\n        uint256 balance = _amount;\\r\\n        uint256 temp;\\r\\n        uint256 cut;\\r\\n\\r\\n        for (uint256 j = 0; j < _recipient.length; j++) {\\r\\n            isCitizen(_recipient[j]);\\r\\n            cut = balance.mul(_split[j]).div(100 * 1 ether);\\r\\n            temp += balance.mul(_split[j]).div(100 * 1 ether);\\r\\n            BYTES.transferFrom(msg.sender, _recipient[j], cut);\\r\\n            userRewardsTotal[_recipient[j]] += cut;\\r\\n        }\\r\\n        balance -= temp;\\r\\n        if (balance > 0) {\\r\\n            BYTES.transferFrom(msg.sender, _recipient[0], balance);\\r\\n            userRewardsTotal[_recipient[0]] += balance;\\r\\n        }\\r\\n        emitReward(_recipient, _amount);\\r\\n    }\\r\\n\\r\\n    function emitReward(\\r\\n        address[] calldata _recipient,\\r\\n        uint256 _amount\\r\\n    ) private {\\r\\n        uint256 calculateRewardTwo = _calculateReward[2];\\r\\n        uint256 calculateRewardThree = _calculateReward[3];\\r\\n        uint256 calculateRewardFour = _calculateReward[4];\\r\\n\\r\\n        if (_calculateReward[1] - 1 < _amount && _amount < calculateRewardTwo) {\\r\\n            emit BronzeRewarded(msg.sender, _amount, _recipient);\\r\\n        } else {\\r\\n            if (\\r\\n                calculateRewardTwo - 1 < _amount &&\\r\\n                _amount < calculateRewardThree\\r\\n            ) {\\r\\n                emit SilverRewarded(msg.sender, _amount, _recipient);\\r\\n            } else {\\r\\n                if (\\r\\n                    calculateRewardThree - 1 < _amount &&\\r\\n                    _amount < calculateRewardFour\\r\\n                ) {\\r\\n                    emit GoldRewarded(msg.sender, _amount, _recipient);\\r\\n                } else {\\r\\n                    if (calculateRewardFour - 1 < _amount) {\\r\\n                        emit PlatinumRewarded(msg.sender, _amount, _recipient);\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function rewardBytes(\\r\\n        address[] calldata _recipient,\\r\\n        uint256 _amount,\\r\\n        uint256[] calldata _split\\r\\n    ) external {\\r\\n        if (_recipient.length != _split.length) revert ArrayLenghtsNotEqual();\\r\\n        uint256 splitCheck;\\r\\n        for (uint256 i = 0; i < _recipient.length; i++) {\\r\\n            splitCheck += _split[i];\\r\\n        }\\r\\n        if (splitCheck > 100 * 1 ether) revert PercentagesMaxExceeded();\\r\\n        if (!vaultActive) {\\r\\n            rewardBytesPeerToPeer(_recipient, _amount, _split);\\r\\n        } else {\\r\\n            rewardBytesVault(_recipient, _amount, _split);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function rewardBytesVault(\\r\\n        address[] calldata _recipient,\\r\\n        uint256 _amount,\\r\\n        uint256[] calldata _split\\r\\n    ) private {\\r\\n        if (_blacklisted[msg.sender]) revert BlackListed();\\r\\n\\r\\n        uint256 balance = _amount;\\r\\n\\r\\n        uint256 executedVaultTax = balance.mul(vaultTax).div(100 * 1 ether);\\r\\n\\r\\n        BYTES.transferFrom(msg.sender, vault, executedVaultTax);\\r\\n\\r\\n        balance -= executedVaultTax;\\r\\n        uint256 temp;\\r\\n        uint256 cut;\\r\\n        for (uint256 j = 0; j < _recipient.length; j++) {\\r\\n            isCitizen(_recipient[j]);\\r\\n            cut = balance.mul(_split[j]).div(100 * 1 ether);\\r\\n            temp += cut;\\r\\n            BYTES.transferFrom(msg.sender, _recipient[j], cut);\\r\\n            userRewardsTotal[_recipient[j]] += cut;\\r\\n        }\\r\\n        balance -= temp;\\r\\n        if (balance > 0) {\\r\\n            BYTES.transferFrom(msg.sender, _recipient[0], balance);\\r\\n        }\\r\\n        emitReward(_recipient, _amount);\\r\\n    }\\r\\n\\r\\n    function rewardBytesOne(address _recipient, uint256 _amount) external {\\r\\n        if (!vaultActive) {\\r\\n            rewardBytesPeerToPeerOne(_recipient, _amount);\\r\\n        } else {\\r\\n            rewardBytesVaultOne(_recipient, _amount);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function rewardBytesPeerToPeerOne(\\r\\n        address _recipient,\\r\\n        uint256 _amount\\r\\n    ) private {\\r\\n        if (_blacklisted[msg.sender]) revert BlackListed();\\r\\n\\r\\n        isCitizen(_recipient);\\r\\n\\r\\n        BYTES.transferFrom(msg.sender, _recipient, _amount);\\r\\n\\r\\n        userRewardsTotal[_recipient] += _amount;\\r\\n\\r\\n        emitRewardOne(_recipient, _amount);\\r\\n    }\\r\\n\\r\\n    function rewardBytesVaultOne(address _recipient, uint256 _amount) private {\\r\\n        isCitizen(_recipient);\\r\\n\\r\\n        if (_blacklisted[msg.sender]) revert BlackListed();\\r\\n\\r\\n        uint256 balance = _amount;\\r\\n\\r\\n        uint256 executedVaultTax = balance.mul(vaultTax).div(100 * 1 ether);\\r\\n\\r\\n        BYTES.transferFrom(msg.sender, vault, executedVaultTax);\\r\\n\\r\\n        balance -= executedVaultTax;\\r\\n\\r\\n        BYTES.transferFrom(msg.sender, _recipient, balance);\\r\\n\\r\\n        userRewardsTotal[_recipient] += _amount;\\r\\n\\r\\n        emitRewardOne(_recipient, _amount);\\r\\n    }\\r\\n\\r\\n    function emitRewardOne(address _recipient, uint256 _amount) private {\\r\\n        address[] memory recipient = new address[](1);\\r\\n        recipient[0] = _recipient;\\r\\n        uint256 calculateRewardTwo = _calculateReward[2];\\r\\n        uint256 calculateRewardThree = _calculateReward[3];\\r\\n        uint256 calculateRewardFour = _calculateReward[4];\\r\\n\\r\\n        if (_calculateReward[1] - 1 < _amount && _amount < calculateRewardTwo) {\\r\\n            emit BronzeRewarded(msg.sender, _amount, recipient);\\r\\n        } else {\\r\\n            if (\\r\\n                calculateRewardTwo - 1 < _amount &&\\r\\n                _amount < calculateRewardThree\\r\\n            ) {\\r\\n                emit SilverRewarded(msg.sender, _amount, recipient);\\r\\n            } else {\\r\\n                if (\\r\\n                    calculateRewardThree - 1 < _amount &&\\r\\n                    _amount < calculateRewardFour\\r\\n                ) {\\r\\n                    emit GoldRewarded(msg.sender, _amount, recipient);\\r\\n                } else {\\r\\n                    if (calculateRewardFour - 1 < _amount) {\\r\\n                        emit PlatinumRewarded(msg.sender, _amount, recipient);\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function isAddressBlacklisted(\\r\\n        address _address\\r\\n    ) external view returns (bool) {\\r\\n        return _blacklisted[_address];\\r\\n    }\\r\\n\\r\\n    function whichReward(\\r\\n        uint256 _amount\\r\\n    ) external view returns (string memory) {\\r\\n        if (\\r\\n            _calculateReward[1] - 1 < _amount && _amount < _calculateReward[2]\\r\\n        ) {\\r\\n            return \\\"Bronze\\\";\\r\\n        } else {\\r\\n            if (\\r\\n                _calculateReward[2] - 1 < _amount &&\\r\\n                _amount < _calculateReward[3]\\r\\n            ) {\\r\\n                return \\\"Silver\\\";\\r\\n            } else {\\r\\n                if (\\r\\n                    _calculateReward[3] - 1 < _amount &&\\r\\n                    _amount < _calculateReward[4]\\r\\n                ) {\\r\\n                    return \\\"Gold\\\";\\r\\n                } else {\\r\\n                    if (_calculateReward[4] - 1 < _amount) {\\r\\n                        return \\\"Platinum\\\";\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ArrayLenghtsNotEqual\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BlackListed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotAnAdmin\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotDesignedToHandle\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PercentagesMaxExceeded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RecipientIsNotACitizen\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SplitPercentageHasToEqualOneHundred\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"msgSender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address[]\",\"name\":\"newAdmins\",\"type\":\"address[]\"}],\"name\":\"AdminAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"msgSender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address[]\",\"name\":\"retiredAdmins\",\"type\":\"address[]\"}],\"name\":\"AdminRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountInBytes\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address[]\",\"name\":\"recipient\",\"type\":\"address[]\"}],\"name\":\"BronzeRewarded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountInBytes\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address[]\",\"name\":\"recipient\",\"type\":\"address[]\"}],\"name\":\"GoldRewarded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountInBytes\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address[]\",\"name\":\"recipient\",\"type\":\"address[]\"}],\"name\":\"PlatinumRewarded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountInBytes\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address[]\",\"name\":\"recipient\",\"type\":\"address[]\"}],\"name\":\"SilverRewarded\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BYTES\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_controller\",\"type\":\"address[]\"}],\"name\":\"addAdmins\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_addresses\",\"type\":\"address[]\"}],\"name\":\"addBlacklistAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"citizenContract\",\"outputs\":[{\"internalType\":\"contract ICitizen\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"isAddressBlacklisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"legacyCitizenContract\",\"outputs\":[{\"internalType\":\"contract ILegacyCitizen\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"legacyOuterCitizenContract\",\"outputs\":[{\"internalType\":\"contract ILegacyOuterCitizen\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"outerCitizenContract\",\"outputs\":[{\"internalType\":\"contract IOuterCitizen\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_controller\",\"type\":\"address[]\"}],\"name\":\"removeAdmins\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_addresses\",\"type\":\"address[]\"}],\"name\":\"removeBlacklistAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_recipient\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"_split\",\"type\":\"uint256[]\"}],\"name\":\"rewardBytes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"rewardBytesOne\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_recipient\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"_split\",\"type\":\"uint256[]\"}],\"name\":\"rewardBytesSpecificWithCustomSplit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_recipient\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"rewardBytesSpecificWithoutCustomSplit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_BYTES\",\"type\":\"address\"}],\"name\":\"setBYTESContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ICitizen\",\"name\":\"_citizenContract\",\"type\":\"address\"}],\"name\":\"setCitizenContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ILegacyCitizen\",\"name\":\"_legacyCitizenContract\",\"type\":\"address\"}],\"name\":\"setLegacyCitizenContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ILegacyOuterCitizen\",\"name\":\"_legacyOuterCitizenContract\",\"type\":\"address\"}],\"name\":\"setLegacyOuterCitizenContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IOuterCitizen\",\"name\":\"_outerCitizenContract\",\"type\":\"address\"}],\"name\":\"setOuterCitizenContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_typeOfReward\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"_bytesInEther\",\"type\":\"uint256\"}],\"name\":\"setRewardForSpecificReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IStakedCitizen\",\"name\":\"_stakedCitizenContract\",\"type\":\"address\"}],\"name\":\"setStakedCitizenContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newVault\",\"type\":\"address\"}],\"name\":\"setVault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newTax\",\"type\":\"uint256\"}],\"name\":\"setVaultTax\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakedCitizenContract\",\"outputs\":[{\"internalType\":\"contract IStakedCitizen\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"toggleVaultActive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userRewardsTotal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vault\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vaultActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vaultTax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"whichReward\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "NTRewardSystem", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}