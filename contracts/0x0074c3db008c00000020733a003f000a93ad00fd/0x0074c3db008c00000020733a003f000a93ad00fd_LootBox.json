{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/beanbagfrens/LootBox.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport {ERC1155P} from \\\"ERC1155P/ERC1155P.sol\\\";\\nimport {ERC1155PSupply} from \\\"ERC1155P/extensions/ERC1155PSupply.sol\\\";\\nimport {ERC2981} from \\\"solady/src/tokens/ERC2981.sol\\\";\\nimport {OwnableRoles} from \\\"solady/src/auth/OwnableRoles.sol\\\";\\n\\ncontract LootBox is ERC1155PSupply, OwnableRoles, ERC2981 {\\n    string public baseURI;\\n\\n    constructor() ERC1155P(\\\"Beanbag Loot Box\\\", \\\"BBLB\\\") {\\n        _initializeOwner(tx.origin);\\n\\n        // Set royalty receiver to the contract creator,\\n        // at 5% (default denominator is 10000).\\n        _setDefaultRoyalty(tx.origin, 500);\\n    }\\n\\n    function _baseURI() internal view virtual override returns (string memory) {\\n        return baseURI;\\n    }\\n\\n    function setBaseURI(string calldata baseURI_) external onlyOwner {\\n        baseURI = baseURI_;\\n    }\\n\\n    /*\\n     * Minting\\n     * Minting can only be done by a designated minter\\n     */\\n    function mint(address to, uint256 id, uint256 amount) external onlyRoles(_ROLE_0) {\\n        _mint(to, id, amount, \\\"\\\");\\n    }\\n\\n    function batchMint(address to, uint256[] calldata ids, uint256[] calldata amounts)\\n        external\\n        onlyRoles(_ROLE_0)\\n    {\\n        _mintBatch(to, ids, amounts, \\\"\\\");\\n    }\\n\\n    /*\\n     * Burning\\n     * Loot boxes can only be burned by designated burner contract(s)\\n     */\\n    function burn(address from, uint256 id, uint256 amount) external onlyRoles(_ROLE_1) {\\n        if (from != msg.sender) {\\n            if (!isApprovedForAll(from, msg.sender)) {\\n                _revert(TransferCallerNotOwnerNorApproved.selector);\\n            }\\n        }\\n\\n        _burn(from, id, amount);\\n    }\\n\\n    function batchBurn(address from, uint256[] calldata ids, uint256[] calldata amounts)\\n        external\\n        onlyRoles(_ROLE_1)\\n    {\\n        if (from != msg.sender) {\\n            if (!isApprovedForAll(from, msg.sender)) {\\n                _revert(TransferCallerNotOwnerNorApproved.selector);\\n            }\\n        }\\n\\n        _burnBatch(from, ids, amounts);\\n    }\\n\\n    function supportsInterface(bytes4 interfaceId)\\n        public\\n        view\\n        virtual\\n        override(ERC1155PSupply, ERC2981)\\n        returns (bool)\\n    {\\n        return\\n            ERC1155PSupply.supportsInterface(interfaceId) || ERC2981.supportsInterface(interfaceId);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/ERC1155P/contracts/ERC1155P.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// ERC1155P Contracts v1.1\\n// Creator: 0xjustadev/0xth0mas\\n\\npragma solidity ^0.8.20;\\n\\nimport \\\"./IERC1155P.sol\\\";\\n\\n/**\\n * @dev Interface of ERC1155 token receiver.\\n */\\ninterface ERC1155P__IERC1155Receiver {\\n    function onERC1155Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        uint256 value,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n\\n    function onERC1155BatchReceived(\\n        address operator,\\n        address from,\\n        uint256[] calldata ids,\\n        uint256[] calldata values,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\\n/**\\n * @dev Interface for IERC1155MetadataURI.\\n */\\n\\ninterface ERC1155P__IERC1155MetadataURI {\\n    /**\\n     * @dev Returns the URI for token type `id`.\\n     *\\n     * If the `\\\\{id\\\\}` substring is present in the URI, it must be replaced by\\n     * clients with the actual token type ID.\\n     */\\n    function uri(uint256 id) external view returns (string memory);\\n}\\n\\n /**\\n * @title ERC1155P\\n *\\n * @dev Implementation of the basic standard multi-token.\\n * See https://eips.ethereum.org/EIPS/eip-1155 including the Metadata extension.\\n * Optimized for lower gas for users collecting multiple tokens.\\n *\\n * Assumptions:\\n * - An owner cannot have more than 2**16 - 1 of a single token\\n * - The maximum token ID cannot exceed 2**100 - 1\\n */\\nabstract contract ERC1155P is IERC1155P, ERC1155P__IERC1155MetadataURI {\\n\\n    /**\\n     * @dev MAX_ACCOUNT_TOKEN_BALANCE is 2^16-1 because token balances are\\n     *      are being packed into 16 bits within each bucket.\\n     */\\n    uint256 private constant MAX_ACCOUNT_TOKEN_BALANCE = 0xFFFF;\\n\\n    uint256 private constant BALANCE_STORAGE_OFFSET =\\n        0xE000000000000000000000000000000000000000000000000000000000000000;\\n\\n    uint256 private constant APPROVAL_STORAGE_OFFSET =\\n        0xD000000000000000000000000000000000000000000000000000000000000000;\\n\\n    /**\\n     * @dev MAX_TOKEN_ID is derived from custom storage pointer location for \\n     *      account/token balance data. Wallet address is shifted 92 bits left\\n     *      and leaves 92 bits for bucket #'s. Each bucket holds 8 token balances\\n     *      2^92*8-1 = MAX_TOKEN_ID\\n     */\\n    uint256 private constant MAX_TOKEN_ID = 0x07FFFFFFFFFFFFFFFFFFFFFFF;\\n\\n    // The `TransferSingle` event signature is given by:\\n    // `keccak256(bytes(\\\"TransferSingle(address,address,address,uint256,uint256)\\\"))`.\\n    bytes32 private constant _TRANSFER_SINGLE_EVENT_SIGNATURE =\\n        0xc3d58168c5ae7397731d063d5bbf3d657854427343f4c083240f7aacaa2d0f62;\\n    // The `TransferBatch` event signature is given by:\\n    // `keccak256(bytes(\\\"TransferBatch(address,address,address,uint256[],uint256[])\\\"))`.\\n    bytes32 private constant _TRANSFER_BATCH_EVENT_SIGNATURE =\\n        0x4a39dc06d4c0dbc64b70af90fd698a233a518aa5d07e595d983b8c0526c8f7fb;\\n    // The `ApprovalForAll` event signature is given by:\\n    // `keccak256(bytes(\\\"ApprovalForAll(address,address,bool)\\\"))`.\\n    bytes32 private constant _APPROVAL_FOR_ALL_EVENT_SIGNATURE =\\n        0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31;\\n\\n    string public name; //collection name\\n    string public symbol; //collection symbol\\n\\n    // Optional mapping for token URIs\\n    mapping(uint256 => string) private _tokenURIs;\\n\\n    /**\\n     * @dev constructor initialization of name and symbol parameters\\n     * @param _name the name to display for the collection\\n     * @param _symbol the symbol for the token collection\\n     */\\n    constructor(string memory _name, string memory _symbol) {\\n        name = _name;\\n        symbol = _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified)\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        // The interface IDs are constants representing the first 4 bytes\\n        // of the XOR of all function selectors in the interface.\\n        // See: [ERC165](https://eips.ethereum.org/EIPS/eip-165)\\n        // (e.g. `bytes4(i.functionA.selector ^ i.functionB.selector ^ ...)`)\\n        return\\n            interfaceId == 0x01ffc9a7 || // ERC165 interface ID for ERC165.\\n            interfaceId == 0xd9b67a26 || // ERC165 interface ID for ERC1155.\\n            interfaceId == 0x0e89341c; // ERC165 interface ID for ERC1155MetadataURI.\\n    }\\n    \\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function uri(uint256 id) public view virtual override returns (string memory) {\\n        string memory tokenURI = _tokenURIs[id];\\n        string memory baseURI = _baseURI();\\n\\n        return bytes(tokenURI).length > 0 ? \\n            tokenURI : \\n            bytes(baseURI).length != 0 ? string(abi.encodePacked(baseURI, _toString(id))) : '';\\n    }\\n\\n    /**\\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\\n     * by default, it can be overridden in child contracts.\\n     */\\n    function _baseURI() internal view virtual returns (string memory) {\\n        return '';\\n    }\\n\\n    /**\\n     * @dev Sets `tokenURI` as the tokenURI of `tokenId`.\\n     */\\n    function _setURI(uint256 tokenId, string calldata tokenURI) internal virtual {\\n        _tokenURIs[tokenId] = tokenURI;\\n        emit URI(uri(tokenId), tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\\n        if(account == address(0)) { _revert(BalanceQueryForZeroAddress.selector); }\\n        return getBalance(account, id);\\n    }\\n\\n    /**\\n     * @dev Gets the amount of tokens minted by an account for a given token id\\n     */\\n    function _numberMinted(address account, uint256 id) internal view returns (uint256) {\\n        if(account == address(0)) { _revert(BalanceQueryForZeroAddress.selector); }\\n        return getMinted(account, id);\\n    }\\n\\n    /**\\n     * @dev Gets the balance of an account's token id from packed token data\\n     *\\n     */\\n    function getBalance(address account, uint256 id) private view returns (uint256 _balance) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, or(BALANCE_STORAGE_OFFSET, or(shr(4, shl(96, account)), shr(3, id))))\\n            _balance := shr(shl(5, and(id, 0x07)), and(sload(keccak256(0x00, 0x20)), shl(shl(5, and(id, 0x07)), 0x0000FFFF)))\\n        }\\n    }\\n\\n    /**\\n     * @dev Sets the balance of an account's token id in packed token data\\n     *\\n     */\\n    function setBalance(address account, uint256 id, uint256 amount) private {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, or(BALANCE_STORAGE_OFFSET, or(shr(4, shl(96, account)), shr(3, id))))\\n            mstore(0x00, keccak256(0x00, 0x20))\\n            sstore(mload(0x00), or(and(not(shl(shl(5, and(id, 0x07)), 0x0000FFFF)), sload(mload(0x00))), shl(shl(5, and(id, 0x07)), amount)))\\n        }\\n    }\\n\\n    /**\\n     * @dev Gets the number minted of an account's token id from packed token data\\n     *\\n     */\\n    function getMinted(address account, uint256 id) private view returns (uint256 _minted) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, or(BALANCE_STORAGE_OFFSET, or(shr(4, shl(96, account)), shr(3, id))))\\n            _minted := shr(16, shr(shl(5, and(id, 0x07)), and(sload(keccak256(0x00, 0x20)), shl(shl(5, and(id, 0x07)), 0xFFFF0000))))\\n        }\\n    }\\n\\n    /**\\n     * @dev Sets the number minted of an account's token id in packed token data\\n     *\\n     */\\n    function setMinted(address account, uint256 id, uint256 amount) private {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, or(BALANCE_STORAGE_OFFSET, or(shr(4, shl(96, account)), shr(3, id))))\\n            mstore(0x00, keccak256(0x00, 0x20))\\n            sstore(mload(0x00), or(and(not(shl(shl(5, and(id, 0x07)), 0xFFFF0000)), sload(mload(0x00))), shl(shl(5, and(id, 0x07)), shl(16, amount))))\\n        }\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-balanceOfBatch}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(\\n        address[] calldata accounts,\\n        uint256[] calldata ids\\n    ) public view virtual override returns (uint256[] memory) {\\n        if(accounts.length != ids.length) { _revert(ArrayLengthMismatch.selector); }\\n\\n        uint256[] memory batchBalances = new uint256[](accounts.length);\\n\\n        for(uint256 i = 0; i < accounts.length;) {\\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        return batchBalances;\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool _approved) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, shr(96, shl(96, account)))\\n            mstore(0x20, or(APPROVAL_STORAGE_OFFSET, shr(96, shl(96, operator))))\\n            mstore(0x00, keccak256(0x00, 0x40))\\n            _approved := sload(mload(0x00))\\n        }\\n        return _approved; \\n    }\\n\\n    /**\\n     * @dev See {IERC1155-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) public virtual override {\\n        _safeTransferFrom(from, to, id, amount, data);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-safeBatchTransferFrom}.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes memory data\\n    ) public virtual override {\\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\\n    }\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function _safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) internal virtual {\\n        if(id > MAX_TOKEN_ID) { _revert(ExceedsMaximumTokenId.selector); }\\n        if(to == address(0)) { _revert(TransferToZeroAddress.selector); }\\n        \\n        if(from != _msgSenderERC1155P())\\n            if (!isApprovedForAll(from, _msgSenderERC1155P())) _revert(TransferCallerNotOwnerNorApproved.selector);\\n\\n        address operator = _msgSenderERC1155P();\\n\\n        _beforeTokenTransfer(operator, from, to, id, amount, data);\\n\\n        uint256 fromBalance = getBalance(from, id);\\n        if(amount > fromBalance) { _revert(TransferExceedsBalance.selector); }\\n\\n        if(from != to) {\\n            uint256 toBalance = getBalance(to, id);\\n            unchecked {\\n                fromBalance -= amount;\\n                toBalance += amount;\\n            }\\n            if(toBalance > MAX_ACCOUNT_TOKEN_BALANCE) { _revert(ExceedsMaximumBalance.selector); }\\n            setBalance(from, id, fromBalance);\\n            setBalance(to, id, toBalance);   \\n        }\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Emit the `TransferSingle` event.\\n            let memOffset := mload(0x40)\\n            mstore(memOffset, id)\\n            mstore(add(memOffset, 0x20), amount)\\n            log4(\\n                memOffset, // Start of data .\\n                0x40, // Length of data.\\n                _TRANSFER_SINGLE_EVENT_SIGNATURE, // Signature.\\n                operator, // `operator`.\\n                from, // `from`.\\n                to // `to`.\\n            )\\n        }\\n\\n        _afterTokenTransfer(operator, from, to, id, amount, data);\\n\\n        if(to.code.length != 0)\\n            if(!_checkContractOnERC1155Received(from, to, id, amount, data))  {\\n                _revert(TransferToNonERC1155ReceiverImplementer.selector);\\n            }\\n    }\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function _safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes memory data\\n    ) internal virtual {\\n        if(to == address(0)) { _revert(TransferToZeroAddress.selector); }\\n        if(ids.length != amounts.length) { _revert(ArrayLengthMismatch.selector); }\\n\\n        if(from != _msgSenderERC1155P())\\n            if (!isApprovedForAll(from, _msgSenderERC1155P())) _revert(TransferCallerNotOwnerNorApproved.selector);\\n\\n        address operator = _msgSenderERC1155P();\\n\\n        _beforeBatchTokenTransfer(operator, from, to, ids, amounts, data);\\n\\n        for (uint256 i = 0; i < ids.length;) {\\n            uint256 id = ids[i];\\n            uint256 amount = amounts[i];\\n            if(id > MAX_TOKEN_ID) { _revert(ExceedsMaximumTokenId.selector); }\\n\\n            uint256 fromBalance = getBalance(from, id);\\n            if(amount > fromBalance) { _revert(TransferExceedsBalance.selector); }\\n\\n            if(from != to) {\\n                uint256 toBalance = getBalance(to, id);\\n                unchecked {\\n                    fromBalance -= amount;\\n                    toBalance += amount;\\n                }\\n                if(toBalance > MAX_ACCOUNT_TOKEN_BALANCE) { _revert(ExceedsMaximumBalance.selector); }\\n                setBalance(from, id, fromBalance);\\n                setBalance(to, id, toBalance);\\n            }\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let memOffset := mload(0x40)\\n            mstore(memOffset, 0x40)\\n            mstore(add(memOffset,0x20), add(0x60, mul(0x20,ids.length)))\\n            mstore(add(memOffset,0x40), ids.length)\\n            calldatacopy(add(memOffset,0x60), ids.offset, mul(0x20,ids.length))\\n            mstore(add(add(memOffset,0x60),mul(0x20,ids.length)), amounts.length)\\n            calldatacopy(add(add(memOffset,0x80),mul(0x20,ids.length)), amounts.offset, mul(0x20,amounts.length))\\n            log4(\\n                memOffset, \\n                add(0x80,mul(0x40,amounts.length)),\\n                _TRANSFER_BATCH_EVENT_SIGNATURE, // Signature.\\n                operator, // `operator`.\\n                from, // `from`.\\n                to // `to`.\\n            )\\n        }\\n\\n        _afterBatchTokenTransfer(operator, from, to, ids, amounts, data);\\n\\n\\n        if(to.code.length != 0)\\n            if(!_checkContractOnERC1155BatchReceived(from, to, ids, amounts, data))  {\\n                _revert(TransferToNonERC1155ReceiverImplementer.selector);\\n            }\\n    }\\n\\n    /**\\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function _mint(address to, uint256 id, uint256 amount, bytes memory data) internal virtual {\\n        if(id > MAX_TOKEN_ID) { _revert(ExceedsMaximumTokenId.selector); }\\n        if(to == address(0)) { _revert(MintToZeroAddress.selector); }\\n        if(amount == 0) { _revert(MintZeroQuantity.selector); }\\n\\n        address operator = _msgSenderERC1155P();\\n\\n        _beforeTokenTransfer(operator, address(0), to, id, amount, data);\\n\\n        uint256 toBalanceBefore = getBalance(to, id);\\n        uint256 toBalanceAfter;\\n        unchecked {\\n            toBalanceAfter = toBalanceBefore + amount;\\n        }\\n        if(toBalanceAfter > MAX_ACCOUNT_TOKEN_BALANCE) { _revert(ExceedsMaximumBalance.selector); }\\n        if(toBalanceAfter < toBalanceBefore) { _revert(ExceedsMaximumBalance.selector); } // catches overflow\\n        setBalance(to, id, toBalanceAfter);\\n\\n        uint256 toMintedBefore = getMinted(to, id);\\n        uint256 toMintedAfter;\\n        unchecked {\\n            toMintedAfter = toMintedBefore + amount;\\n        }\\n        if(toMintedAfter > MAX_ACCOUNT_TOKEN_BALANCE) { _revert(ExceedsMaximumBalance.selector); }\\n        if(toMintedAfter < toMintedBefore) { _revert(ExceedsMaximumBalance.selector); } // catches overflow\\n        setMinted(to, id, toMintedAfter);\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Emit the `TransferSingle` event.\\n            let memOffset := mload(0x40)\\n            mstore(memOffset, id)\\n            mstore(add(memOffset, 0x20), amount)\\n            log4(\\n                memOffset, // Start of data .\\n                0x40, // Length of data.\\n                _TRANSFER_SINGLE_EVENT_SIGNATURE, // Signature.\\n                operator, // `operator`.\\n                0, // `from`.\\n                to // `to`.\\n            )\\n        }\\n\\n        _afterTokenTransfer(operator, address(0), to, id, amount, data);\\n\\n        if(to.code.length != 0)\\n            if(!_checkContractOnERC1155Received(address(0), to, id, amount, data))  {\\n                _revert(TransferToNonERC1155ReceiverImplementer.selector);\\n            }\\n    }\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function _mintBatch(\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes memory data\\n    ) internal virtual {\\n        if(to == address(0)) { _revert(MintToZeroAddress.selector); }\\n        if(ids.length != amounts.length) { _revert(ArrayLengthMismatch.selector); }\\n\\n        address operator = _msgSenderERC1155P();\\n\\n        _beforeBatchTokenTransfer(operator, address(0), to, ids, amounts, data);\\n\\n        uint256 id;\\n        uint256 amount;\\n        for (uint256 i = 0; i < ids.length;) {\\n            id = ids[i];\\n            amount = amounts[i];\\n            if(id > MAX_TOKEN_ID) { _revert(ExceedsMaximumTokenId.selector); }\\n            if(amount == 0) { _revert(MintZeroQuantity.selector); }\\n\\n            uint256 toBalanceBefore = getBalance(to, id);\\n            uint256 toBalanceAfter;\\n            unchecked {\\n                toBalanceAfter = toBalanceBefore + amount;\\n            }\\n            if(toBalanceAfter > MAX_ACCOUNT_TOKEN_BALANCE) { _revert(ExceedsMaximumBalance.selector); }\\n            if(toBalanceAfter < toBalanceBefore) { _revert(ExceedsMaximumBalance.selector); } // catches overflow\\n            setBalance(to, id, toBalanceAfter);\\n\\n            uint256 toMintedBefore = getMinted(to, id);\\n            uint256 toMintedAfter;\\n            unchecked {\\n                toMintedAfter = toMintedBefore + amount;\\n            }\\n            if(toMintedAfter > MAX_ACCOUNT_TOKEN_BALANCE) { _revert(ExceedsMaximumBalance.selector); }\\n            if(toMintedAfter < toMintedBefore) { _revert(ExceedsMaximumBalance.selector); } // catches overflow\\n            setMinted(to, id, toMintedAfter);\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let memOffset := mload(0x40)\\n            mstore(memOffset, 0x40)\\n            mstore(add(memOffset,0x20), add(0x60, mul(0x20,ids.length)))\\n            mstore(add(memOffset,0x40), ids.length)\\n            calldatacopy(add(memOffset,0x60), ids.offset, mul(0x20,ids.length))\\n            mstore(add(add(memOffset,0x60),mul(0x20,ids.length)), amounts.length)\\n            calldatacopy(add(add(memOffset,0x80),mul(0x20,ids.length)), amounts.offset, mul(0x20,amounts.length))\\n            log4(\\n                memOffset, \\n                add(0x80,mul(0x40,amounts.length)),\\n                _TRANSFER_BATCH_EVENT_SIGNATURE, // Signature.\\n                operator, // `operator`.\\n                0, // `from`.\\n                to // `to`.\\n            )\\n        }\\n\\n        _afterBatchTokenTransfer(operator, address(0), to, ids, amounts, data);\\n\\n        if(to.code.length != 0)\\n            if(!_checkContractOnERC1155BatchReceived(address(0), to, ids, amounts, data))  {\\n                _revert(TransferToNonERC1155ReceiverImplementer.selector);\\n            }\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens of token type `id` from `from`\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `from` must have at least `amount` tokens of token type `id`.\\n     */\\n    function _burn(address from, uint256 id, uint256 amount) internal virtual {\\n        if(id > MAX_TOKEN_ID) { _revert(ExceedsMaximumTokenId.selector); }\\n        if(from == address(0)) { _revert(BurnFromZeroAddress.selector); }\\n\\n        address operator = _msgSenderERC1155P();\\n\\n        _beforeTokenTransfer(operator, from, address(0), id, amount, \\\"\\\");\\n\\n        uint256 fromBalance = getBalance(from, id);\\n        if(amount > fromBalance) { _revert(BurnExceedsBalance.selector); }\\n        unchecked {\\n            fromBalance -= amount;\\n        }\\n        setBalance(from, id, fromBalance);\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Emit the `TransferSingle` event.\\n            let memOffset := mload(0x40)\\n            mstore(memOffset, id)\\n            mstore(add(memOffset, 0x20), amount)\\n            log4(\\n                memOffset, // Start of data.\\n                0x40, // Length of data.\\n                _TRANSFER_SINGLE_EVENT_SIGNATURE, // Signature.\\n                operator, // `operator`.\\n                from, // `from`.\\n                0 // `to`.\\n            )\\n        }\\n\\n        _afterTokenTransfer(operator, from, address(0), id, amount, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     */\\n    function _burnBatch(address from, uint256[] calldata ids, uint256[] calldata amounts) internal virtual {\\n        if(from == address(0)) { _revert(BurnFromZeroAddress.selector); }\\n        if(ids.length != amounts.length) { _revert(ArrayLengthMismatch.selector); }\\n\\n        address operator = _msgSenderERC1155P();\\n\\n        _beforeBatchTokenTransfer(operator, from, address(0), ids, amounts, \\\"\\\");\\n\\n        for (uint256 i = 0; i < ids.length;) {\\n            uint256 id = ids[i];\\n            uint256 amount = amounts[i];\\n            if(id > MAX_TOKEN_ID) { _revert(ExceedsMaximumTokenId.selector); }\\n\\n            uint256 fromBalance = getBalance(from, id);\\n            if(amount > fromBalance) { _revert(BurnExceedsBalance.selector); }\\n            unchecked {\\n                fromBalance -= amount;\\n            }\\n            setBalance(from, id, fromBalance);\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let memOffset := mload(0x40)\\n            mstore(memOffset, 0x40)\\n            mstore(add(memOffset,0x20), add(0x60, mul(0x20,ids.length)))\\n            mstore(add(memOffset,0x40), ids.length)\\n            calldatacopy(add(memOffset,0x60), ids.offset, mul(0x20,ids.length))\\n            mstore(add(add(memOffset,0x60),mul(0x20,ids.length)), amounts.length)\\n            calldatacopy(add(add(memOffset,0x80),mul(0x20,ids.length)), amounts.offset, mul(0x20,amounts.length))\\n            log4(\\n                memOffset, \\n                add(0x80,mul(0x40,amounts.length)),\\n                _TRANSFER_BATCH_EVENT_SIGNATURE, // Signature.\\n                operator, // `operator`.\\n                from, // `from`.\\n                0 // `to`.\\n            )\\n        }\\n\\n        _afterBatchTokenTransfer(operator, from, address(0), ids, amounts, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom}\\n     * for any token owned by the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, caller())\\n            mstore(0x20, or(APPROVAL_STORAGE_OFFSET, shr(96, shl(96, operator))))\\n            mstore(0x00, keccak256(0x00, 0x40))\\n            mstore(0x20, approved)\\n            sstore(mload(0x00), mload(0x20))\\n            log3(\\n                0x20,\\n                0x20,\\n                _APPROVAL_FOR_ALL_EVENT_SIGNATURE,\\n                caller(),\\n                shr(96, shl(96, operator))\\n            )\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any single token transfer. This includes minting\\n     * and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * of token type `id` will be  transferred to `to`.\\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\\n     * for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\\n     * will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) internal virtual {}\\n\\n    \\n\\n    /**\\n     * @dev Hook that is called before any batch token transfer. This includes minting\\n     * and burning.\\n     *\\n     * Calling conditions (for each `id` and `amount` pair):\\n     *\\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * of token type `id` will be  transferred to `to`.\\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\\n     * for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\\n     * will be burned.\\n     * - `from` and `to` are never both zero.\\n     * - `ids` and `amounts` have the same, non-zero length.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    \\n    function _beforeBatchTokenTransfer(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes memory data\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any single token transfer. This includes minting\\n     * and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * of token type `id` will be  transferred to `to`.\\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\\n     * for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\\n     * will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any batch token transfer. This includes minting\\n     * and burning.\\n     *\\n     * Calling conditions (for each `id` and `amount` pair):\\n     *\\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * of token type `id` will be  transferred to `to`.\\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\\n     * for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\\n     * will be burned.\\n     * - `from` and `to` are never both zero.\\n     * - `ids` and `amounts` have the same, non-zero length.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    \\n    function _afterBatchTokenTransfer(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes memory data\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Private function to invoke {IERC1155Receiver-onERC155Received} on a target contract.\\n     *\\n     * `from` - Previous owner of the given token ID.\\n     * `to` - Target address that will receive the token.\\n     * `id` - Token ID to be transferred.\\n     * `amount` - Balance of token to be transferred\\n     * `_data` - Optional data to send along with the call.\\n     *\\n     * Returns whether the call correctly returned the expected magic value.\\n     */\\n    function _checkContractOnERC1155Received(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory _data\\n    ) private returns (bool) {\\n        try ERC1155P__IERC1155Receiver(to).onERC1155Received(_msgSenderERC1155P(), from, id, amount, _data) returns (\\n            bytes4 retval\\n        ) {\\n            return retval == ERC1155P__IERC1155Receiver(to).onERC1155Received.selector;\\n        } catch (bytes memory reason) {\\n            if (reason.length == 0) {\\n                _revert(TransferToNonERC1155ReceiverImplementer.selector);\\n            }\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                revert(add(32, reason), mload(reason))\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Private function to invoke {IERC1155Receiver-onERC155Received} on a target contract.\\n     *\\n     * `from` - Previous owner of the given token ID.\\n     * `to` - Target address that will receive the token.\\n     * `id` - Token ID to be transferred.\\n     * `amount` - Balance of token to be transferred\\n     * `_data` - Optional data to send along with the call.\\n     *\\n     * Returns whether the call correctly returned the expected magic value.\\n     */\\n    function _checkContractOnERC1155BatchReceived(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes memory _data\\n    ) private returns (bool) {\\n        try ERC1155P__IERC1155Receiver(to).onERC1155BatchReceived(_msgSenderERC1155P(), from, ids, amounts, _data) returns (\\n            bytes4 retval\\n        ) {\\n            return retval == ERC1155P__IERC1155Receiver(to).onERC1155BatchReceived.selector;\\n        } catch (bytes memory reason) {\\n            if (reason.length == 0) {\\n                _revert(TransferToNonERC1155ReceiverImplementer.selector);\\n            }\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                revert(add(32, reason), mload(reason))\\n            }\\n        }\\n    }\\n    \\n    /**\\n     * @dev Returns the message sender (defaults to `msg.sender`).\\n     *\\n     * If you are writing GSN compatible contracts, you need to override this function.\\n     */\\n    function _msgSenderERC1155P() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    /**\\n     * @dev Converts a uint256 to its ASCII string decimal representation.\\n     */\\n    function _toString(uint256 value) internal pure virtual returns (string memory str) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // The maximum value of a uint256 contains 78 digits (1 byte per digit), but\\n            // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.\\n            // We will need 1 word for the trailing zeros padding, 1 word for the length,\\n            // and 3 words for a maximum of 78 digits. Total: 5 * 0x20 = 0xa0.\\n            let m := add(mload(0x40), 0xa0)\\n            // Update the free memory pointer to allocate.\\n            mstore(0x40, m)\\n            // Assign the `str` to the end.\\n            str := sub(m, 0x20)\\n            // Zeroize the slot after the string.\\n            mstore(str, 0)\\n\\n            // Cache the end of the memory to calculate the length later.\\n            let end := str\\n\\n            // We write the string from rightmost digit to leftmost digit.\\n            // The following is essentially a do-while loop that also handles the zero case.\\n            // prettier-ignore\\n            for { let temp := value } 1 {} {\\n                str := sub(str, 1)\\n                // Write the character to the pointer.\\n                // The ASCII index of the '0' character is 48.\\n                mstore8(str, add(48, mod(temp, 10)))\\n                // Keep dividing `temp` until zero.\\n                temp := div(temp, 10)\\n                // prettier-ignore\\n                if iszero(temp) { break }\\n            }\\n\\n            let length := sub(end, str)\\n            // Move the pointer 32 bytes leftwards to make room for the length.\\n            str := sub(str, 0x20)\\n            // Store the length.\\n            mstore(str, length)\\n        }\\n    }\\n\\n    /**\\n     * @dev For more efficient reverts.\\n     */\\n    function _revert(bytes4 errorSelector) internal pure {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, errorSelector)\\n            revert(0x00, 0x04)\\n        }\\n    }\\n}\"\r\n    },\r\n    \"lib/ERC1155P/contracts/extensions/ERC1155PSupply.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.20;\\n\\nimport \\\"../ERC1155P.sol\\\";\\n\\n/**\\n * @dev Extension of ERC1155 that adds tracking of total supply per id.\\n *\\n * Useful for scenarios where Fungible and Non-fungible tokens have to be\\n * clearly identified. Note: While a totalSupply of 1 might mean the\\n * corresponding is an NFT, there is no guarantees that no other token with the\\n * same id are not going to be minted.\\n */\\nabstract contract ERC1155PSupply is ERC1155P {\\n    /**\\n     * @dev Custom storage pointer for total token supply. Total supply is\\n     *      split into buckets of 4 tokens per bucket allowing for 64 bits\\n     *      per token. \\n     *      32 bits are used to store total supply for a max value of 0xFFFFFFFF \\n     *      (~4.3B) of a single token. \\n     *      32 bits are used to store the mint count for a token\\n     * \\n     *      The standard ERC1155P implementation allows a maximum token id\\n     *      of 0x07FFFFFFFFFFFFFFFFFFFFFFF which requires a max bucket id of\\n     *      0x1FFFFFFFFFFFFFFFFFFFFFFF. Storage slots for buckets start at\\n     *      0xF000000000000000000000000000000000000000000000000000000000000000\\n     *      and continue through\\n     *      0xF0000000000000000000000000000000000000001FFFFFFFFFFFFFFFFFFFFFFF\\n     * \\n     *      Storage pointers for ERC1155P account balances start at\\n     *      0xE000000000000000000000000000000000000000000000000000000000000000\\n     *      and continue through\\n     *      0xEFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\\n     * \\n     *      All custom pointers get hashed to avoid potential conflicts with\\n     *      standard mappings or incorrect returns on view functions.\\n     */\\n    uint256 private constant TOTAL_SUPPLY_STORAGE_OFFSET =\\n        0xF000000000000000000000000000000000000000000000000000000000000000;\\n    uint256 private constant MAX_TOTAL_SUPPLY = 0xFFFFFFFF;\\n\\n    /**\\n     * Total supply exceeds maximum.\\n     */\\n    error ExceedsMaximumTotalSupply();\\n\\n    /**\\n     * @dev Total amount of tokens with a given id.\\n     */\\n    function totalSupply(\\n        uint256 id\\n    ) public view virtual returns (uint256 _totalSupply) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, or(TOTAL_SUPPLY_STORAGE_OFFSET, shr(2, id)))\\n            _totalSupply := shr(shl(6, and(id, 0x03)), and(sload(keccak256(0x00, 0x20)), shl(shl(6, and(id, 0x03)), 0x00000000FFFFFFFF)))\\n        }\\n    }\\n\\n    /**\\n     * @dev Sets total supply in custom storage slot location\\n     */\\n    function setTotalSupply(uint256 id, uint256 amount) private {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, or(TOTAL_SUPPLY_STORAGE_OFFSET, shr(2, id)))\\n            mstore(0x00, keccak256(0x00, 0x20))\\n            sstore(mload(0x00), or(and(not(shl(shl(6, and(id, 0x03)), 0x00000000FFFFFFFF)), sload(mload(0x00))), shl(shl(6, and(id, 0x03)), amount)))\\n        }\\n    }\\n\\n    /**\\n     * @dev Total amount of tokens minted with a given id.\\n     */\\n    function totalMinted(\\n        uint256 id\\n    ) public view virtual returns (uint256 _totalMinted) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, or(TOTAL_SUPPLY_STORAGE_OFFSET, shr(2, id)))\\n            _totalMinted := shr(32, shr(shl(6, and(id, 0x03)), and(sload(keccak256(0x00, 0x20)), shl(shl(6, and(id, 0x03)), 0xFFFFFFFF00000000))))\\n        }\\n    }\\n\\n    /**\\n     * @dev Sets total minted in custom storage slot location\\n     */\\n    function setTotalMinted(uint256 id, uint256 amount) private {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, or(TOTAL_SUPPLY_STORAGE_OFFSET, shr(2, id)))\\n            mstore(0x00, keccak256(0x00, 0x20))\\n            sstore(mload(0x00), or(and(not(shl(shl(6, and(id, 0x03)), 0xFFFFFFFF00000000)), sload(mload(0x00))), shl(shl(6, and(id, 0x03)), shl(32, amount))))\\n        }\\n    }\\n\\n    /**\\n     * @dev Indicates whether any token exist with a given id, or not.\\n     */\\n    function exists(uint256 id) public view virtual returns (bool) {\\n        return this.totalSupply(id) > 0;\\n    }\\n\\n    /**\\n     * @dev See {ERC1155-_beforeTokenTransfer}.\\n     */\\n    function _beforeTokenTransfer(\\n        address,\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory\\n    ) internal virtual override {\\n        if (from == address(0)) {\\n            uint256 supply = this.totalSupply(id);\\n            uint256 minted = this.totalMinted(id);\\n            unchecked {\\n                supply += amount;\\n                minted += amount;\\n            }\\n            if (supply > MAX_TOTAL_SUPPLY || minted > MAX_TOTAL_SUPPLY) {\\n                ERC1155P._revert(ExceedsMaximumTotalSupply.selector);\\n            }\\n            setTotalSupply(id, supply);\\n            setTotalMinted(id, minted);\\n        }\\n\\n        if (to == address(0)) {\\n            uint256 supply = this.totalSupply(id);\\n            unchecked {\\n                supply -= amount;\\n            }\\n            setTotalSupply(id, supply);\\n        }\\n    }\\n\\n    /**\\n     * @dev See {ERC1155-_beforeTokenTransfer}.\\n     */\\n    function _beforeBatchTokenTransfer(\\n        address,\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes memory\\n    ) internal virtual override {\\n        if (from == address(0)) {\\n            for (uint256 i = 0; i < ids.length; ) {\\n                uint256 id = ids[i];\\n                uint256 supply = this.totalSupply(id);\\n                uint256 minted = this.totalMinted(id);\\n                unchecked {\\n                    supply += amounts[i];\\n                    minted += amounts[i];\\n                    ++i;\\n                }\\n                if (supply > MAX_TOTAL_SUPPLY || minted > MAX_TOTAL_SUPPLY) {\\n                    ERC1155P._revert(ExceedsMaximumTotalSupply.selector);\\n                }\\n                setTotalSupply(id, supply);\\n                setTotalMinted(id, minted);\\n            }\\n        }\\n\\n        if (to == address(0)) {\\n            for (uint256 i = 0; i < ids.length; ) {\\n                uint256 id = ids[i];\\n                uint256 supply = this.totalSupply(id);\\n                unchecked {\\n                    supply -= amounts[i];\\n                    ++i;\\n                }\\n                setTotalSupply(id, supply);\\n            }\\n        }\\n    }\\n\\n    function supportsInterface(\\n        bytes4 interfaceId\\n    ) public view virtual override returns (bool) {\\n        return super.supportsInterface(interfaceId);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solady/src/tokens/ERC2981.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Simple ERC2981 NFT Royalty Standard implementation.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/tokens/ERC2981.sol)\\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/common/ERC2981.sol)\\nabstract contract ERC2981 {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The royalty fee numerator exceeds the fee denominator.\\n    error RoyaltyOverflow();\\n\\n    /// @dev The royalty receiver cannot be the zero address.\\n    error RoyaltyReceiverIsZeroAddress();\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                          STORAGE                           */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The default royalty info is given by:\\n    /// ```\\n    ///     let packed := sload(_ERC2981_MASTER_SLOT_SEED)\\n    ///     let receiver := shr(96, packed)\\n    ///     let royaltyFraction := xor(packed, shl(96, receiver))\\n    /// ```\\n    ///\\n    /// The per token royalty info is given by.\\n    /// ```\\n    ///     mstore(0x00, tokenId)\\n    ///     mstore(0x20, _ERC2981_MASTER_SLOT_SEED)\\n    ///     let packed := sload(keccak256(0x00, 0x40))\\n    ///     let receiver := shr(96, packed)\\n    ///     let royaltyFraction := xor(packed, shl(96, receiver))\\n    /// ```\\n    uint256 private constant _ERC2981_MASTER_SLOT_SEED = 0xaa4ec00224afccfdb7;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                          ERC2981                           */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Checks that `_feeDenominator` is non-zero.\\n    constructor() {\\n        require(_feeDenominator() != 0, \\\"Fee denominator cannot be zero.\\\");\\n    }\\n\\n    /// @dev Returns the denominator for the royalty amount.\\n    /// Defaults to 10000, which represents fees in basis points.\\n    /// Override this function to return a custom amount if needed.\\n    function _feeDenominator() internal pure virtual returns (uint96) {\\n        return 10000;\\n    }\\n\\n    /// @dev Returns true if this contract implements the interface defined by `interfaceId`.\\n    /// See: https://eips.ethereum.org/EIPS/eip-165\\n    /// This function call must use less than 30000 gas.\\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let s := shr(224, interfaceId)\\n            // ERC165: 0x01ffc9a7, ERC2981: 0x2a55205a.\\n            result := or(eq(s, 0x01ffc9a7), eq(s, 0x2a55205a))\\n        }\\n    }\\n\\n    /// @dev Returns the `receiver` and `royaltyAmount` for `tokenId` sold at `salePrice`.\\n    function royaltyInfo(uint256 tokenId, uint256 salePrice)\\n        public\\n        view\\n        virtual\\n        returns (address receiver, uint256 royaltyAmount)\\n    {\\n        uint256 feeDenominator = _feeDenominator();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, tokenId)\\n            mstore(0x20, _ERC2981_MASTER_SLOT_SEED)\\n            let packed := sload(keccak256(0x00, 0x40))\\n            receiver := shr(96, packed)\\n            if iszero(receiver) {\\n                packed := sload(mload(0x20))\\n                receiver := shr(96, packed)\\n            }\\n            let x := salePrice\\n            let y := xor(packed, shl(96, receiver)) // `feeNumerator`.\\n            // Overflow check, equivalent to `require(y == 0 || x <= type(uint256).max / y)`.\\n            // Out-of-gas revert. Should not be triggered in practice, but included for safety.\\n            returndatacopy(returndatasize(), returndatasize(), mul(y, gt(x, div(not(0), y))))\\n            royaltyAmount := div(mul(x, y), feeDenominator)\\n        }\\n    }\\n\\n    /// @dev Sets the default royalty `receiver` and `feeNumerator`.\\n    ///\\n    /// Requirements:\\n    /// - `receiver` must not be the zero address.\\n    /// - `feeNumerator` must not be greater than the fee denominator.\\n    function _setDefaultRoyalty(address receiver, uint96 feeNumerator) internal virtual {\\n        uint256 feeDenominator = _feeDenominator();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            feeNumerator := shr(160, shl(160, feeNumerator))\\n            if gt(feeNumerator, feeDenominator) {\\n                mstore(0x00, 0x350a88b3) // `RoyaltyOverflow()`.\\n                revert(0x1c, 0x04)\\n            }\\n            let packed := shl(96, receiver)\\n            if iszero(packed) {\\n                mstore(0x00, 0xb4457eaa) // `RoyaltyReceiverIsZeroAddress()`.\\n                revert(0x1c, 0x04)\\n            }\\n            sstore(_ERC2981_MASTER_SLOT_SEED, or(packed, feeNumerator))\\n        }\\n    }\\n\\n    /// @dev Sets the default royalty `receiver` and `feeNumerator` to zero.\\n    function _deleteDefaultRoyalty() internal virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            sstore(_ERC2981_MASTER_SLOT_SEED, 0)\\n        }\\n    }\\n\\n    /// @dev Sets the royalty `receiver` and `feeNumerator` for `tokenId`.\\n    ///\\n    /// Requirements:\\n    /// - `receiver` must not be the zero address.\\n    /// - `feeNumerator` must not be greater than the fee denominator.\\n    function _setTokenRoyalty(uint256 tokenId, address receiver, uint96 feeNumerator)\\n        internal\\n        virtual\\n    {\\n        uint256 feeDenominator = _feeDenominator();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            feeNumerator := shr(160, shl(160, feeNumerator))\\n            if gt(feeNumerator, feeDenominator) {\\n                mstore(0x00, 0x350a88b3) // `RoyaltyOverflow()`.\\n                revert(0x1c, 0x04)\\n            }\\n            let packed := shl(96, receiver)\\n            if iszero(packed) {\\n                mstore(0x00, 0xb4457eaa) // `RoyaltyReceiverIsZeroAddress()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x00, tokenId)\\n            mstore(0x20, _ERC2981_MASTER_SLOT_SEED)\\n            sstore(keccak256(0x00, 0x40), or(packed, feeNumerator))\\n        }\\n    }\\n\\n    /// @dev Sets the royalty `receiver` and `feeNumerator` for `tokenId` to zero.\\n    function _resetTokenRoyalty(uint256 tokenId) internal virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, tokenId)\\n            mstore(0x20, _ERC2981_MASTER_SLOT_SEED)\\n            sstore(keccak256(0x00, 0x40), 0)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solady/src/auth/OwnableRoles.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport {Ownable} from \\\"./Ownable.sol\\\";\\n\\n/// @notice Simple single owner and multiroles authorization mixin.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/auth/Ownable.sol)\\n/// @dev While the ownable portion follows [EIP-173](https://eips.ethereum.org/EIPS/eip-173)\\n/// for compatibility, the nomenclature for the 2-step ownership handover and roles\\n/// may be unique to this codebase.\\nabstract contract OwnableRoles is Ownable {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                           EVENTS                           */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The `user`'s roles is updated to `roles`.\\n    /// Each bit of `roles` represents whether the role is set.\\n    event RolesUpdated(address indexed user, uint256 indexed roles);\\n\\n    /// @dev `keccak256(bytes(\\\"RolesUpdated(address,uint256)\\\"))`.\\n    uint256 private constant _ROLES_UPDATED_EVENT_SIGNATURE =\\n        0x715ad5ce61fc9595c7b415289d59cf203f23a94fa06f04af7e489a0a76e1fe26;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                          STORAGE                           */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The role slot of `user` is given by:\\n    /// ```\\n    ///     mstore(0x00, or(shl(96, user), _ROLE_SLOT_SEED))\\n    ///     let roleSlot := keccak256(0x00, 0x20)\\n    /// ```\\n    /// This automatically ignores the upper bits of the `user` in case\\n    /// they are not clean, as well as keep the `keccak256` under 32-bytes.\\n    ///\\n    /// Note: This is equal to `_OWNER_SLOT_NOT` in for gas efficiency.\\n    uint256 private constant _ROLE_SLOT_SEED = 0x8b78c6d8;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                     INTERNAL FUNCTIONS                     */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Overwrite the roles directly without authorization guard.\\n    function _setRoles(address user, uint256 roles) internal virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x0c, _ROLE_SLOT_SEED)\\n            mstore(0x00, user)\\n            // Store the new value.\\n            sstore(keccak256(0x0c, 0x20), roles)\\n            // Emit the {RolesUpdated} event.\\n            log3(0, 0, _ROLES_UPDATED_EVENT_SIGNATURE, shr(96, mload(0x0c)), roles)\\n        }\\n    }\\n\\n    /// @dev Updates the roles directly without authorization guard.\\n    /// If `on` is true, each set bit of `roles` will be turned on,\\n    /// otherwise, each set bit of `roles` will be turned off.\\n    function _updateRoles(address user, uint256 roles, bool on) internal virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x0c, _ROLE_SLOT_SEED)\\n            mstore(0x00, user)\\n            let roleSlot := keccak256(0x0c, 0x20)\\n            // Load the current value.\\n            let current := sload(roleSlot)\\n            // Compute the updated roles if `on` is true.\\n            let updated := or(current, roles)\\n            // Compute the updated roles if `on` is false.\\n            // Use `and` to compute the intersection of `current` and `roles`,\\n            // `xor` it with `current` to flip the bits in the intersection.\\n            if iszero(on) { updated := xor(current, and(current, roles)) }\\n            // Then, store the new value.\\n            sstore(roleSlot, updated)\\n            // Emit the {RolesUpdated} event.\\n            log3(0, 0, _ROLES_UPDATED_EVENT_SIGNATURE, shr(96, mload(0x0c)), updated)\\n        }\\n    }\\n\\n    /// @dev Grants the roles directly without authorization guard.\\n    /// Each bit of `roles` represents the role to turn on.\\n    function _grantRoles(address user, uint256 roles) internal virtual {\\n        _updateRoles(user, roles, true);\\n    }\\n\\n    /// @dev Removes the roles directly without authorization guard.\\n    /// Each bit of `roles` represents the role to turn off.\\n    function _removeRoles(address user, uint256 roles) internal virtual {\\n        _updateRoles(user, roles, false);\\n    }\\n\\n    /// @dev Throws if the sender does not have any of the `roles`.\\n    function _checkRoles(uint256 roles) internal view virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute the role slot.\\n            mstore(0x0c, _ROLE_SLOT_SEED)\\n            mstore(0x00, caller())\\n            // Load the stored value, and if the `and` intersection\\n            // of the value and `roles` is zero, revert.\\n            if iszero(and(sload(keccak256(0x0c, 0x20)), roles)) {\\n                mstore(0x00, 0x82b42900) // `Unauthorized()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Throws if the sender is not the owner,\\n    /// and does not have any of the `roles`.\\n    /// Checks for ownership first, then lazily checks for roles.\\n    function _checkOwnerOrRoles(uint256 roles) internal view virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // If the caller is not the stored owner.\\n            // Note: `_ROLE_SLOT_SEED` is equal to `_OWNER_SLOT_NOT`.\\n            if iszero(eq(caller(), sload(not(_ROLE_SLOT_SEED)))) {\\n                // Compute the role slot.\\n                mstore(0x0c, _ROLE_SLOT_SEED)\\n                mstore(0x00, caller())\\n                // Load the stored value, and if the `and` intersection\\n                // of the value and `roles` is zero, revert.\\n                if iszero(and(sload(keccak256(0x0c, 0x20)), roles)) {\\n                    mstore(0x00, 0x82b42900) // `Unauthorized()`.\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Throws if the sender does not have any of the `roles`,\\n    /// and is not the owner.\\n    /// Checks for roles first, then lazily checks for ownership.\\n    function _checkRolesOrOwner(uint256 roles) internal view virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute the role slot.\\n            mstore(0x0c, _ROLE_SLOT_SEED)\\n            mstore(0x00, caller())\\n            // Load the stored value, and if the `and` intersection\\n            // of the value and `roles` is zero, revert.\\n            if iszero(and(sload(keccak256(0x0c, 0x20)), roles)) {\\n                // If the caller is not the stored owner.\\n                // Note: `_ROLE_SLOT_SEED` is equal to `_OWNER_SLOT_NOT`.\\n                if iszero(eq(caller(), sload(not(_ROLE_SLOT_SEED)))) {\\n                    mstore(0x00, 0x82b42900) // `Unauthorized()`.\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Convenience function to return a `roles` bitmap from an array of `ordinals`.\\n    /// This is meant for frontends like Etherscan, and is therefore not fully optimized.\\n    /// Not recommended to be called on-chain.\\n    /// Made internal to conserve bytecode. Wrap it in a public function if needed.\\n    function _rolesFromOrdinals(uint8[] memory ordinals) internal pure returns (uint256 roles) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            for { let i := shl(5, mload(ordinals)) } i { i := sub(i, 0x20) } {\\n                // We don't need to mask the values of `ordinals`, as Solidity\\n                // cleans dirty upper bits when storing variables into memory.\\n                roles := or(shl(mload(add(ordinals, i)), 1), roles)\\n            }\\n        }\\n    }\\n\\n    /// @dev Convenience function to return an array of `ordinals` from the `roles` bitmap.\\n    /// This is meant for frontends like Etherscan, and is therefore not fully optimized.\\n    /// Not recommended to be called on-chain.\\n    /// Made internal to conserve bytecode. Wrap it in a public function if needed.\\n    function _ordinalsFromRoles(uint256 roles) internal pure returns (uint8[] memory ordinals) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Grab the pointer to the free memory.\\n            ordinals := mload(0x40)\\n            let ptr := add(ordinals, 0x20)\\n            let o := 0\\n            // The absence of lookup tables, De Bruijn, etc., here is intentional for\\n            // smaller bytecode, as this function is not meant to be called on-chain.\\n            for { let t := roles } 1 {} {\\n                mstore(ptr, o)\\n                // `shr` 5 is equivalent to multiplying by 0x20.\\n                // Push back into the ordinals array if the bit is set.\\n                ptr := add(ptr, shl(5, and(t, 1)))\\n                o := add(o, 1)\\n                t := shr(o, roles)\\n                if iszero(t) { break }\\n            }\\n            // Store the length of `ordinals`.\\n            mstore(ordinals, shr(5, sub(ptr, add(ordinals, 0x20))))\\n            // Allocate the memory.\\n            mstore(0x40, ptr)\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                  PUBLIC UPDATE FUNCTIONS                   */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Allows the owner to grant `user` `roles`.\\n    /// If the `user` already has a role, then it will be an no-op for the role.\\n    function grantRoles(address user, uint256 roles) public payable virtual onlyOwner {\\n        _grantRoles(user, roles);\\n    }\\n\\n    /// @dev Allows the owner to remove `user` `roles`.\\n    /// If the `user` does not have a role, then it will be an no-op for the role.\\n    function revokeRoles(address user, uint256 roles) public payable virtual onlyOwner {\\n        _removeRoles(user, roles);\\n    }\\n\\n    /// @dev Allow the caller to remove their own roles.\\n    /// If the caller does not have a role, then it will be an no-op for the role.\\n    function renounceRoles(uint256 roles) public payable virtual {\\n        _removeRoles(msg.sender, roles);\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                   PUBLIC READ FUNCTIONS                    */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns the roles of `user`.\\n    function rolesOf(address user) public view virtual returns (uint256 roles) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute the role slot.\\n            mstore(0x0c, _ROLE_SLOT_SEED)\\n            mstore(0x00, user)\\n            // Load the stored value.\\n            roles := sload(keccak256(0x0c, 0x20))\\n        }\\n    }\\n\\n    /// @dev Returns whether `user` has any of `roles`.\\n    function hasAnyRole(address user, uint256 roles) public view virtual returns (bool) {\\n        return rolesOf(user) & roles != 0;\\n    }\\n\\n    /// @dev Returns whether `user` has all of `roles`.\\n    function hasAllRoles(address user, uint256 roles) public view virtual returns (bool) {\\n        return rolesOf(user) & roles == roles;\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         MODIFIERS                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Marks a function as only callable by an account with `roles`.\\n    modifier onlyRoles(uint256 roles) virtual {\\n        _checkRoles(roles);\\n        _;\\n    }\\n\\n    /// @dev Marks a function as only callable by the owner or by an account\\n    /// with `roles`. Checks for ownership first, then lazily checks for roles.\\n    modifier onlyOwnerOrRoles(uint256 roles) virtual {\\n        _checkOwnerOrRoles(roles);\\n        _;\\n    }\\n\\n    /// @dev Marks a function as only callable by an account with `roles`\\n    /// or the owner. Checks for roles first, then lazily checks for ownership.\\n    modifier onlyRolesOrOwner(uint256 roles) virtual {\\n        _checkRolesOrOwner(roles);\\n        _;\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       ROLE CONSTANTS                       */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    // IYKYK\\n\\n    uint256 internal constant _ROLE_0 = 1 << 0;\\n    uint256 internal constant _ROLE_1 = 1 << 1;\\n    uint256 internal constant _ROLE_2 = 1 << 2;\\n    uint256 internal constant _ROLE_3 = 1 << 3;\\n    uint256 internal constant _ROLE_4 = 1 << 4;\\n    uint256 internal constant _ROLE_5 = 1 << 5;\\n    uint256 internal constant _ROLE_6 = 1 << 6;\\n    uint256 internal constant _ROLE_7 = 1 << 7;\\n    uint256 internal constant _ROLE_8 = 1 << 8;\\n    uint256 internal constant _ROLE_9 = 1 << 9;\\n    uint256 internal constant _ROLE_10 = 1 << 10;\\n    uint256 internal constant _ROLE_11 = 1 << 11;\\n    uint256 internal constant _ROLE_12 = 1 << 12;\\n    uint256 internal constant _ROLE_13 = 1 << 13;\\n    uint256 internal constant _ROLE_14 = 1 << 14;\\n    uint256 internal constant _ROLE_15 = 1 << 15;\\n    uint256 internal constant _ROLE_16 = 1 << 16;\\n    uint256 internal constant _ROLE_17 = 1 << 17;\\n    uint256 internal constant _ROLE_18 = 1 << 18;\\n    uint256 internal constant _ROLE_19 = 1 << 19;\\n    uint256 internal constant _ROLE_20 = 1 << 20;\\n    uint256 internal constant _ROLE_21 = 1 << 21;\\n    uint256 internal constant _ROLE_22 = 1 << 22;\\n    uint256 internal constant _ROLE_23 = 1 << 23;\\n    uint256 internal constant _ROLE_24 = 1 << 24;\\n    uint256 internal constant _ROLE_25 = 1 << 25;\\n    uint256 internal constant _ROLE_26 = 1 << 26;\\n    uint256 internal constant _ROLE_27 = 1 << 27;\\n    uint256 internal constant _ROLE_28 = 1 << 28;\\n    uint256 internal constant _ROLE_29 = 1 << 29;\\n    uint256 internal constant _ROLE_30 = 1 << 30;\\n    uint256 internal constant _ROLE_31 = 1 << 31;\\n    uint256 internal constant _ROLE_32 = 1 << 32;\\n    uint256 internal constant _ROLE_33 = 1 << 33;\\n    uint256 internal constant _ROLE_34 = 1 << 34;\\n    uint256 internal constant _ROLE_35 = 1 << 35;\\n    uint256 internal constant _ROLE_36 = 1 << 36;\\n    uint256 internal constant _ROLE_37 = 1 << 37;\\n    uint256 internal constant _ROLE_38 = 1 << 38;\\n    uint256 internal constant _ROLE_39 = 1 << 39;\\n    uint256 internal constant _ROLE_40 = 1 << 40;\\n    uint256 internal constant _ROLE_41 = 1 << 41;\\n    uint256 internal constant _ROLE_42 = 1 << 42;\\n    uint256 internal constant _ROLE_43 = 1 << 43;\\n    uint256 internal constant _ROLE_44 = 1 << 44;\\n    uint256 internal constant _ROLE_45 = 1 << 45;\\n    uint256 internal constant _ROLE_46 = 1 << 46;\\n    uint256 internal constant _ROLE_47 = 1 << 47;\\n    uint256 internal constant _ROLE_48 = 1 << 48;\\n    uint256 internal constant _ROLE_49 = 1 << 49;\\n    uint256 internal constant _ROLE_50 = 1 << 50;\\n    uint256 internal constant _ROLE_51 = 1 << 51;\\n    uint256 internal constant _ROLE_52 = 1 << 52;\\n    uint256 internal constant _ROLE_53 = 1 << 53;\\n    uint256 internal constant _ROLE_54 = 1 << 54;\\n    uint256 internal constant _ROLE_55 = 1 << 55;\\n    uint256 internal constant _ROLE_56 = 1 << 56;\\n    uint256 internal constant _ROLE_57 = 1 << 57;\\n    uint256 internal constant _ROLE_58 = 1 << 58;\\n    uint256 internal constant _ROLE_59 = 1 << 59;\\n    uint256 internal constant _ROLE_60 = 1 << 60;\\n    uint256 internal constant _ROLE_61 = 1 << 61;\\n    uint256 internal constant _ROLE_62 = 1 << 62;\\n    uint256 internal constant _ROLE_63 = 1 << 63;\\n    uint256 internal constant _ROLE_64 = 1 << 64;\\n    uint256 internal constant _ROLE_65 = 1 << 65;\\n    uint256 internal constant _ROLE_66 = 1 << 66;\\n    uint256 internal constant _ROLE_67 = 1 << 67;\\n    uint256 internal constant _ROLE_68 = 1 << 68;\\n    uint256 internal constant _ROLE_69 = 1 << 69;\\n    uint256 internal constant _ROLE_70 = 1 << 70;\\n    uint256 internal constant _ROLE_71 = 1 << 71;\\n    uint256 internal constant _ROLE_72 = 1 << 72;\\n    uint256 internal constant _ROLE_73 = 1 << 73;\\n    uint256 internal constant _ROLE_74 = 1 << 74;\\n    uint256 internal constant _ROLE_75 = 1 << 75;\\n    uint256 internal constant _ROLE_76 = 1 << 76;\\n    uint256 internal constant _ROLE_77 = 1 << 77;\\n    uint256 internal constant _ROLE_78 = 1 << 78;\\n    uint256 internal constant _ROLE_79 = 1 << 79;\\n    uint256 internal constant _ROLE_80 = 1 << 80;\\n    uint256 internal constant _ROLE_81 = 1 << 81;\\n    uint256 internal constant _ROLE_82 = 1 << 82;\\n    uint256 internal constant _ROLE_83 = 1 << 83;\\n    uint256 internal constant _ROLE_84 = 1 << 84;\\n    uint256 internal constant _ROLE_85 = 1 << 85;\\n    uint256 internal constant _ROLE_86 = 1 << 86;\\n    uint256 internal constant _ROLE_87 = 1 << 87;\\n    uint256 internal constant _ROLE_88 = 1 << 88;\\n    uint256 internal constant _ROLE_89 = 1 << 89;\\n    uint256 internal constant _ROLE_90 = 1 << 90;\\n    uint256 internal constant _ROLE_91 = 1 << 91;\\n    uint256 internal constant _ROLE_92 = 1 << 92;\\n    uint256 internal constant _ROLE_93 = 1 << 93;\\n    uint256 internal constant _ROLE_94 = 1 << 94;\\n    uint256 internal constant _ROLE_95 = 1 << 95;\\n    uint256 internal constant _ROLE_96 = 1 << 96;\\n    uint256 internal constant _ROLE_97 = 1 << 97;\\n    uint256 internal constant _ROLE_98 = 1 << 98;\\n    uint256 internal constant _ROLE_99 = 1 << 99;\\n    uint256 internal constant _ROLE_100 = 1 << 100;\\n    uint256 internal constant _ROLE_101 = 1 << 101;\\n    uint256 internal constant _ROLE_102 = 1 << 102;\\n    uint256 internal constant _ROLE_103 = 1 << 103;\\n    uint256 internal constant _ROLE_104 = 1 << 104;\\n    uint256 internal constant _ROLE_105 = 1 << 105;\\n    uint256 internal constant _ROLE_106 = 1 << 106;\\n    uint256 internal constant _ROLE_107 = 1 << 107;\\n    uint256 internal constant _ROLE_108 = 1 << 108;\\n    uint256 internal constant _ROLE_109 = 1 << 109;\\n    uint256 internal constant _ROLE_110 = 1 << 110;\\n    uint256 internal constant _ROLE_111 = 1 << 111;\\n    uint256 internal constant _ROLE_112 = 1 << 112;\\n    uint256 internal constant _ROLE_113 = 1 << 113;\\n    uint256 internal constant _ROLE_114 = 1 << 114;\\n    uint256 internal constant _ROLE_115 = 1 << 115;\\n    uint256 internal constant _ROLE_116 = 1 << 116;\\n    uint256 internal constant _ROLE_117 = 1 << 117;\\n    uint256 internal constant _ROLE_118 = 1 << 118;\\n    uint256 internal constant _ROLE_119 = 1 << 119;\\n    uint256 internal constant _ROLE_120 = 1 << 120;\\n    uint256 internal constant _ROLE_121 = 1 << 121;\\n    uint256 internal constant _ROLE_122 = 1 << 122;\\n    uint256 internal constant _ROLE_123 = 1 << 123;\\n    uint256 internal constant _ROLE_124 = 1 << 124;\\n    uint256 internal constant _ROLE_125 = 1 << 125;\\n    uint256 internal constant _ROLE_126 = 1 << 126;\\n    uint256 internal constant _ROLE_127 = 1 << 127;\\n    uint256 internal constant _ROLE_128 = 1 << 128;\\n    uint256 internal constant _ROLE_129 = 1 << 129;\\n    uint256 internal constant _ROLE_130 = 1 << 130;\\n    uint256 internal constant _ROLE_131 = 1 << 131;\\n    uint256 internal constant _ROLE_132 = 1 << 132;\\n    uint256 internal constant _ROLE_133 = 1 << 133;\\n    uint256 internal constant _ROLE_134 = 1 << 134;\\n    uint256 internal constant _ROLE_135 = 1 << 135;\\n    uint256 internal constant _ROLE_136 = 1 << 136;\\n    uint256 internal constant _ROLE_137 = 1 << 137;\\n    uint256 internal constant _ROLE_138 = 1 << 138;\\n    uint256 internal constant _ROLE_139 = 1 << 139;\\n    uint256 internal constant _ROLE_140 = 1 << 140;\\n    uint256 internal constant _ROLE_141 = 1 << 141;\\n    uint256 internal constant _ROLE_142 = 1 << 142;\\n    uint256 internal constant _ROLE_143 = 1 << 143;\\n    uint256 internal constant _ROLE_144 = 1 << 144;\\n    uint256 internal constant _ROLE_145 = 1 << 145;\\n    uint256 internal constant _ROLE_146 = 1 << 146;\\n    uint256 internal constant _ROLE_147 = 1 << 147;\\n    uint256 internal constant _ROLE_148 = 1 << 148;\\n    uint256 internal constant _ROLE_149 = 1 << 149;\\n    uint256 internal constant _ROLE_150 = 1 << 150;\\n    uint256 internal constant _ROLE_151 = 1 << 151;\\n    uint256 internal constant _ROLE_152 = 1 << 152;\\n    uint256 internal constant _ROLE_153 = 1 << 153;\\n    uint256 internal constant _ROLE_154 = 1 << 154;\\n    uint256 internal constant _ROLE_155 = 1 << 155;\\n    uint256 internal constant _ROLE_156 = 1 << 156;\\n    uint256 internal constant _ROLE_157 = 1 << 157;\\n    uint256 internal constant _ROLE_158 = 1 << 158;\\n    uint256 internal constant _ROLE_159 = 1 << 159;\\n    uint256 internal constant _ROLE_160 = 1 << 160;\\n    uint256 internal constant _ROLE_161 = 1 << 161;\\n    uint256 internal constant _ROLE_162 = 1 << 162;\\n    uint256 internal constant _ROLE_163 = 1 << 163;\\n    uint256 internal constant _ROLE_164 = 1 << 164;\\n    uint256 internal constant _ROLE_165 = 1 << 165;\\n    uint256 internal constant _ROLE_166 = 1 << 166;\\n    uint256 internal constant _ROLE_167 = 1 << 167;\\n    uint256 internal constant _ROLE_168 = 1 << 168;\\n    uint256 internal constant _ROLE_169 = 1 << 169;\\n    uint256 internal constant _ROLE_170 = 1 << 170;\\n    uint256 internal constant _ROLE_171 = 1 << 171;\\n    uint256 internal constant _ROLE_172 = 1 << 172;\\n    uint256 internal constant _ROLE_173 = 1 << 173;\\n    uint256 internal constant _ROLE_174 = 1 << 174;\\n    uint256 internal constant _ROLE_175 = 1 << 175;\\n    uint256 internal constant _ROLE_176 = 1 << 176;\\n    uint256 internal constant _ROLE_177 = 1 << 177;\\n    uint256 internal constant _ROLE_178 = 1 << 178;\\n    uint256 internal constant _ROLE_179 = 1 << 179;\\n    uint256 internal constant _ROLE_180 = 1 << 180;\\n    uint256 internal constant _ROLE_181 = 1 << 181;\\n    uint256 internal constant _ROLE_182 = 1 << 182;\\n    uint256 internal constant _ROLE_183 = 1 << 183;\\n    uint256 internal constant _ROLE_184 = 1 << 184;\\n    uint256 internal constant _ROLE_185 = 1 << 185;\\n    uint256 internal constant _ROLE_186 = 1 << 186;\\n    uint256 internal constant _ROLE_187 = 1 << 187;\\n    uint256 internal constant _ROLE_188 = 1 << 188;\\n    uint256 internal constant _ROLE_189 = 1 << 189;\\n    uint256 internal constant _ROLE_190 = 1 << 190;\\n    uint256 internal constant _ROLE_191 = 1 << 191;\\n    uint256 internal constant _ROLE_192 = 1 << 192;\\n    uint256 internal constant _ROLE_193 = 1 << 193;\\n    uint256 internal constant _ROLE_194 = 1 << 194;\\n    uint256 internal constant _ROLE_195 = 1 << 195;\\n    uint256 internal constant _ROLE_196 = 1 << 196;\\n    uint256 internal constant _ROLE_197 = 1 << 197;\\n    uint256 internal constant _ROLE_198 = 1 << 198;\\n    uint256 internal constant _ROLE_199 = 1 << 199;\\n    uint256 internal constant _ROLE_200 = 1 << 200;\\n    uint256 internal constant _ROLE_201 = 1 << 201;\\n    uint256 internal constant _ROLE_202 = 1 << 202;\\n    uint256 internal constant _ROLE_203 = 1 << 203;\\n    uint256 internal constant _ROLE_204 = 1 << 204;\\n    uint256 internal constant _ROLE_205 = 1 << 205;\\n    uint256 internal constant _ROLE_206 = 1 << 206;\\n    uint256 internal constant _ROLE_207 = 1 << 207;\\n    uint256 internal constant _ROLE_208 = 1 << 208;\\n    uint256 internal constant _ROLE_209 = 1 << 209;\\n    uint256 internal constant _ROLE_210 = 1 << 210;\\n    uint256 internal constant _ROLE_211 = 1 << 211;\\n    uint256 internal constant _ROLE_212 = 1 << 212;\\n    uint256 internal constant _ROLE_213 = 1 << 213;\\n    uint256 internal constant _ROLE_214 = 1 << 214;\\n    uint256 internal constant _ROLE_215 = 1 << 215;\\n    uint256 internal constant _ROLE_216 = 1 << 216;\\n    uint256 internal constant _ROLE_217 = 1 << 217;\\n    uint256 internal constant _ROLE_218 = 1 << 218;\\n    uint256 internal constant _ROLE_219 = 1 << 219;\\n    uint256 internal constant _ROLE_220 = 1 << 220;\\n    uint256 internal constant _ROLE_221 = 1 << 221;\\n    uint256 internal constant _ROLE_222 = 1 << 222;\\n    uint256 internal constant _ROLE_223 = 1 << 223;\\n    uint256 internal constant _ROLE_224 = 1 << 224;\\n    uint256 internal constant _ROLE_225 = 1 << 225;\\n    uint256 internal constant _ROLE_226 = 1 << 226;\\n    uint256 internal constant _ROLE_227 = 1 << 227;\\n    uint256 internal constant _ROLE_228 = 1 << 228;\\n    uint256 internal constant _ROLE_229 = 1 << 229;\\n    uint256 internal constant _ROLE_230 = 1 << 230;\\n    uint256 internal constant _ROLE_231 = 1 << 231;\\n    uint256 internal constant _ROLE_232 = 1 << 232;\\n    uint256 internal constant _ROLE_233 = 1 << 233;\\n    uint256 internal constant _ROLE_234 = 1 << 234;\\n    uint256 internal constant _ROLE_235 = 1 << 235;\\n    uint256 internal constant _ROLE_236 = 1 << 236;\\n    uint256 internal constant _ROLE_237 = 1 << 237;\\n    uint256 internal constant _ROLE_238 = 1 << 238;\\n    uint256 internal constant _ROLE_239 = 1 << 239;\\n    uint256 internal constant _ROLE_240 = 1 << 240;\\n    uint256 internal constant _ROLE_241 = 1 << 241;\\n    uint256 internal constant _ROLE_242 = 1 << 242;\\n    uint256 internal constant _ROLE_243 = 1 << 243;\\n    uint256 internal constant _ROLE_244 = 1 << 244;\\n    uint256 internal constant _ROLE_245 = 1 << 245;\\n    uint256 internal constant _ROLE_246 = 1 << 246;\\n    uint256 internal constant _ROLE_247 = 1 << 247;\\n    uint256 internal constant _ROLE_248 = 1 << 248;\\n    uint256 internal constant _ROLE_249 = 1 << 249;\\n    uint256 internal constant _ROLE_250 = 1 << 250;\\n    uint256 internal constant _ROLE_251 = 1 << 251;\\n    uint256 internal constant _ROLE_252 = 1 << 252;\\n    uint256 internal constant _ROLE_253 = 1 << 253;\\n    uint256 internal constant _ROLE_254 = 1 << 254;\\n    uint256 internal constant _ROLE_255 = 1 << 255;\\n}\\n\"\r\n    },\r\n    \"lib/ERC1155P/contracts/IERC1155P.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// ERC721P Contracts v1.1\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155P {\\n\\n    /**\\n     * Cannot query the balance for the zero address.\\n     */\\n    error BalanceQueryForZeroAddress();\\n\\n    /**\\n     * Arrays cannot be different lengths.\\n     */\\n    error ArrayLengthMismatch();\\n\\n    /**\\n     * Cannot burn from the zero address.\\n     */\\n    error BurnFromZeroAddress();\\n\\n    /**\\n     * Cannot mint to the zero address.\\n     */\\n    error MintToZeroAddress();\\n\\n    /**\\n     * The quantity of tokens minted must be more than zero.\\n     */\\n    error MintZeroQuantity();\\n\\n    /**\\n     * The quantity of tokens being burned is greater than account balance.\\n     */\\n    error BurnExceedsBalance();\\n\\n    /**\\n     * The quantity of tokens being transferred is greater than account balance.\\n     */\\n    error TransferExceedsBalance();\\n\\n    /**\\n     * The resulting token balance exceeds the maximum storable by ERC1155P\\n     */\\n    error ExceedsMaximumBalance();\\n\\n    /**\\n     * The caller must own the token or be an approved operator.\\n     */\\n    error TransferCallerNotOwnerNorApproved();\\n\\n    /**\\n     * Cannot safely transfer to a contract that does not implement the\\n     * ERC1155Receiver interface.\\n     */\\n    error TransferToNonERC1155ReceiverImplementer();\\n\\n    /**\\n     * Cannot transfer to the zero address.\\n     */\\n    error TransferToZeroAddress();\\n\\n    /**\\n     * Exceeds max token ID\\n     */\\n    error ExceedsMaximumTokenId();\\n    \\n    // =============================================================\\n    //                            IERC165\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified)\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\\n     */\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n    /**\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n     * transfers.\\n     */\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] values\\n    );\\n\\n    /**\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\n     * `approved`.\\n     */\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\n     *\\n     * If an {URI} event was emitted for `id`, the standard\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\n     * returned by {IERC1155MetadataURI-uri}.\\n     */\\n    event URI(string value, uint256 indexed id);\\n\\n    /**\\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(\\n        address[] calldata accounts,\\n        uint256[] calldata ids\\n    ) external view returns (uint256[] memory);\\n\\n    /**\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `operator` cannot be the caller.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) external;\\n}\"\r\n    },\r\n    \"lib/solady/src/auth/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Simple single owner authorization mixin.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/auth/Ownable.sol)\\n///\\n/// @dev Note:\\n/// This implementation does NOT auto-initialize the owner to `msg.sender`.\\n/// You MUST call the `_initializeOwner` in the constructor / initializer.\\n///\\n/// While the ownable portion follows\\n/// [EIP-173](https://eips.ethereum.org/EIPS/eip-173) for compatibility,\\n/// the nomenclature for the 2-step ownership handover may be unique to this codebase.\\nabstract contract Ownable {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The caller is not authorized to call the function.\\n    error Unauthorized();\\n\\n    /// @dev The `newOwner` cannot be the zero address.\\n    error NewOwnerIsZeroAddress();\\n\\n    /// @dev The `pendingOwner` does not have a valid handover request.\\n    error NoHandoverRequest();\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                           EVENTS                           */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The ownership is transferred from `oldOwner` to `newOwner`.\\n    /// This event is intentionally kept the same as OpenZeppelin's Ownable to be\\n    /// compatible with indexers and [EIP-173](https://eips.ethereum.org/EIPS/eip-173),\\n    /// despite it not being as lightweight as a single argument event.\\n    event OwnershipTransferred(address indexed oldOwner, address indexed newOwner);\\n\\n    /// @dev An ownership handover to `pendingOwner` has been requested.\\n    event OwnershipHandoverRequested(address indexed pendingOwner);\\n\\n    /// @dev The ownership handover to `pendingOwner` has been canceled.\\n    event OwnershipHandoverCanceled(address indexed pendingOwner);\\n\\n    /// @dev `keccak256(bytes(\\\"OwnershipTransferred(address,address)\\\"))`.\\n    uint256 private constant _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE =\\n        0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0;\\n\\n    /// @dev `keccak256(bytes(\\\"OwnershipHandoverRequested(address)\\\"))`.\\n    uint256 private constant _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE =\\n        0xdbf36a107da19e49527a7176a1babf963b4b0ff8cde35ee35d6cd8f1f9ac7e1d;\\n\\n    /// @dev `keccak256(bytes(\\\"OwnershipHandoverCanceled(address)\\\"))`.\\n    uint256 private constant _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE =\\n        0xfa7b8eab7da67f412cc9575ed43464468f9bfbae89d1675917346ca6d8fe3c92;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                          STORAGE                           */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The owner slot is given by: `not(_OWNER_SLOT_NOT)`.\\n    /// It is intentionally chosen to be a high value\\n    /// to avoid collision with lower slots.\\n    /// The choice of manual storage layout is to enable compatibility\\n    /// with both regular and upgradeable contracts.\\n    uint256 private constant _OWNER_SLOT_NOT = 0x8b78c6d8;\\n\\n    /// The ownership handover slot of `newOwner` is given by:\\n    /// ```\\n    ///     mstore(0x00, or(shl(96, user), _HANDOVER_SLOT_SEED))\\n    ///     let handoverSlot := keccak256(0x00, 0x20)\\n    /// ```\\n    /// It stores the expiry timestamp of the two-step ownership handover.\\n    uint256 private constant _HANDOVER_SLOT_SEED = 0x389a75e1;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                     INTERNAL FUNCTIONS                     */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Initializes the owner directly without authorization guard.\\n    /// This function must be called upon initialization,\\n    /// regardless of whether the contract is upgradeable or not.\\n    /// This is to enable generalization to both regular and upgradeable contracts,\\n    /// and to save gas in case the initial owner is not the caller.\\n    /// For performance reasons, this function will not check if there\\n    /// is an existing owner.\\n    function _initializeOwner(address newOwner) internal virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Clean the upper 96 bits.\\n            newOwner := shr(96, shl(96, newOwner))\\n            // Store the new value.\\n            sstore(not(_OWNER_SLOT_NOT), newOwner)\\n            // Emit the {OwnershipTransferred} event.\\n            log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, 0, newOwner)\\n        }\\n    }\\n\\n    /// @dev Sets the owner directly without authorization guard.\\n    function _setOwner(address newOwner) internal virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let ownerSlot := not(_OWNER_SLOT_NOT)\\n            // Clean the upper 96 bits.\\n            newOwner := shr(96, shl(96, newOwner))\\n            // Emit the {OwnershipTransferred} event.\\n            log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, sload(ownerSlot), newOwner)\\n            // Store the new value.\\n            sstore(ownerSlot, newOwner)\\n        }\\n    }\\n\\n    /// @dev Throws if the sender is not the owner.\\n    function _checkOwner() internal view virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // If the caller is not the stored owner, revert.\\n            if iszero(eq(caller(), sload(not(_OWNER_SLOT_NOT)))) {\\n                mstore(0x00, 0x82b42900) // `Unauthorized()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns how long a two-step ownership handover is valid for in seconds.\\n    /// Override to return a different value if needed.\\n    /// Made internal to conserve bytecode. Wrap it in a public function if needed.\\n    function _ownershipHandoverValidFor() internal view virtual returns (uint64) {\\n        return 48 * 3600;\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                  PUBLIC UPDATE FUNCTIONS                   */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Allows the owner to transfer the ownership to `newOwner`.\\n    function transferOwnership(address newOwner) public payable virtual onlyOwner {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(shl(96, newOwner)) {\\n                mstore(0x00, 0x7448fbae) // `NewOwnerIsZeroAddress()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n        _setOwner(newOwner);\\n    }\\n\\n    /// @dev Allows the owner to renounce their ownership.\\n    function renounceOwnership() public payable virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /// @dev Request a two-step ownership handover to the caller.\\n    /// The request will automatically expire in 48 hours (172800 seconds) by default.\\n    function requestOwnershipHandover() public payable virtual {\\n        unchecked {\\n            uint256 expires = block.timestamp + _ownershipHandoverValidFor();\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                // Compute and set the handover slot to `expires`.\\n                mstore(0x0c, _HANDOVER_SLOT_SEED)\\n                mstore(0x00, caller())\\n                sstore(keccak256(0x0c, 0x20), expires)\\n                // Emit the {OwnershipHandoverRequested} event.\\n                log2(0, 0, _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE, caller())\\n            }\\n        }\\n    }\\n\\n    /// @dev Cancels the two-step ownership handover to the caller, if any.\\n    function cancelOwnershipHandover() public payable virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute and set the handover slot to 0.\\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\\n            mstore(0x00, caller())\\n            sstore(keccak256(0x0c, 0x20), 0)\\n            // Emit the {OwnershipHandoverCanceled} event.\\n            log2(0, 0, _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE, caller())\\n        }\\n    }\\n\\n    /// @dev Allows the owner to complete the two-step ownership handover to `pendingOwner`.\\n    /// Reverts if there is no existing ownership handover requested by `pendingOwner`.\\n    function completeOwnershipHandover(address pendingOwner) public payable virtual onlyOwner {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute and set the handover slot to 0.\\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\\n            mstore(0x00, pendingOwner)\\n            let handoverSlot := keccak256(0x0c, 0x20)\\n            // If the handover does not exist, or has expired.\\n            if gt(timestamp(), sload(handoverSlot)) {\\n                mstore(0x00, 0x6f5e8818) // `NoHandoverRequest()`.\\n                revert(0x1c, 0x04)\\n            }\\n            // Set the handover slot to 0.\\n            sstore(handoverSlot, 0)\\n        }\\n        _setOwner(pendingOwner);\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                   PUBLIC READ FUNCTIONS                    */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns the owner of the contract.\\n    function owner() public view virtual returns (address result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := sload(not(_OWNER_SLOT_NOT))\\n        }\\n    }\\n\\n    /// @dev Returns the expiry timestamp for the two-step ownership handover to `pendingOwner`.\\n    function ownershipHandoverExpiresAt(address pendingOwner)\\n        public\\n        view\\n        virtual\\n        returns (uint256 result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute the handover slot.\\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\\n            mstore(0x00, pendingOwner)\\n            // Load the handover slot.\\n            result := sload(keccak256(0x0c, 0x20))\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         MODIFIERS                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Marks a function as only callable by the owner.\\n    modifier onlyOwner() virtual {\\n        _checkOwner();\\n        _;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ERC1155P/=lib/ERC1155P/contracts/\",\r\n      \"closedsea/=lib/closedsea/src/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"erc721a-upgradeable/=lib/closedsea/lib/erc721a-upgradeable/contracts/\",\r\n      \"erc721a/=lib/closedsea/lib/erc721a/contracts/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-contracts-upgradeable/=lib/closedsea/lib/openzeppelin-contracts-upgradeable/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"openzeppelin/=lib/openzeppelin-contracts/contracts/\",\r\n      \"operator-filter-registry/=lib/closedsea/lib/operator-filter-registry/\",\r\n      \"solady/=lib/solady/\",\r\n      \"solmate/=lib/solmate/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ArrayLengthMismatch\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BalanceQueryForZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BurnExceedsBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BurnFromZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ExceedsMaximumBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ExceedsMaximumTokenId\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ExceedsMaximumTotalSupply\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MintToZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MintZeroQuantity\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NewOwnerIsZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoHandoverRequest\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RoyaltyOverflow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RoyaltyReceiverIsZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferCallerNotOwnerNorApproved\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferExceedsBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferToNonERC1155ReceiverImplementer\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferToZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Unauthorized\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"name\":\"OwnershipHandoverCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"name\":\"OwnershipHandoverRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"roles\",\"type\":\"uint256\"}],\"name\":\"RolesUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"}],\"name\":\"TransferBatch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"TransferSingle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"value\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"URI\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"name\":\"balanceOfBatch\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"batchBurn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"batchMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cancelOwnershipHandover\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"name\":\"completeOwnershipHandover\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"exists\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"roles\",\"type\":\"uint256\"}],\"name\":\"grantRoles\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"roles\",\"type\":\"uint256\"}],\"name\":\"hasAllRoles\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"roles\",\"type\":\"uint256\"}],\"name\":\"hasAnyRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"result\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"name\":\"ownershipHandoverExpiresAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"roles\",\"type\":\"uint256\"}],\"name\":\"renounceRoles\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"requestOwnershipHandover\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"roles\",\"type\":\"uint256\"}],\"name\":\"revokeRoles\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"rolesOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"roles\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"salePrice\",\"type\":\"uint256\"}],\"name\":\"royaltyInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"royaltyAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeBatchTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"baseURI_\",\"type\":\"string\"}],\"name\":\"setBaseURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"totalMinted\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_totalMinted\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_totalSupply\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"uri\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "LootBox", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}