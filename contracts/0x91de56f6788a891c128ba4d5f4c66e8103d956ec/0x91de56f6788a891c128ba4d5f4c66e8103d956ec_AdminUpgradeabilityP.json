{"SourceCode": "{\"Address.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\n/**\\n * @title Address\\n *\\n * @dev Utility library of inline functions on addresses.\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns whether the target address is a contract.\\n     * This function will return false if invoked during the constructor of a contract, as the code is not actually\\n     * created until after the constructor finishes.\\n     *\\n     * @param account The address of the account to check\\n     * @return True if the target address is a contract, otherwise false\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        uint256 size;\\n        // XXX Currently there is no better way to check if there is a contract in an address\\n        // than to check the size of the code at that address.\\n        // See https://ethereum.stackexchange.com/a/14016/36603\\n        // for more details about how this works.\\n        // TODO Check this again before the Serenity release, because all addresses will be\\n        // contracts then.\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size \\u003e 0;\\n    }\\n}\\n\"},\"AdminUpgradeabilityProxy.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\nimport \\u0027./UpgradeabilityProxy.sol\\u0027;\\n\\n/**\\n * @title AdminUpgradeabilityProxy\\n *\\n * @dev This contract combines an upgradeability proxy with an authorization mechanism for administrative tasks.\\n * All external functions in this contract must be guarded by the `ifAdmin` modifier.\\n * See ethereum/solidity#3864 for a Solidity feature proposal that would enable this to be done automatically.\\n */\\ncontract AdminUpgradeabilityProxy is UpgradeabilityProxy {\\n    /**\\n     * @dev Event emitted whenever the administration has been transferred.\\n     *\\n     * @param previousAdmin Address of the previous admin.\\n     * @param newAdmin Address of the new admin.\\n     *\\n     */\\n    event AdminChanged(address previousAdmin, address newAdmin);\\n\\n    /**\\n     * @dev Storage slot with the admin of the contract.\\n     * This is the keccak-256 hash of \\\"infinigold.proxy.admin\\\", and is validated in the constructor.\\n     */\\n    bytes32 private constant ADMIN_SLOT = 0x0d28943014d3bfed6af9cab5e6024c23fa2da10f7a6373bcd56c37313c24d93a;\\n\\n    /**\\n     * @dev Modifier to check whether the `msg.sender` is the admin.\\n     * If it is, it will run the function. Otherwise, it will delegate the call to the implementation.\\n     */\\n    modifier ifAdmin() {\\n        if (msg.sender == _admin()) {\\n            _;\\n        } else {\\n            _fallback();\\n        }\\n    }\\n\\n    /**\\n     * @dev Contract constructor.\\n     * @dev It sets the `msg.sender` as the proxy administrator.\\n     *\\n     * @param _implementation address of the initial implementation.\\n     */\\n    constructor(address _implementation) UpgradeabilityProxy(_implementation) public {\\n        assert(ADMIN_SLOT == keccak256(\\\"infinigold.proxy.admin\\\"));\\n\\n        _setAdmin(msg.sender);\\n    }\\n\\n    /**\\n     * @return The address of the proxy admin.\\n     */\\n    function admin() external view ifAdmin returns (address) {\\n        return _admin();\\n    }\\n\\n    /**\\n     * @return The address of the implementation.\\n     */\\n    function implementation() external view ifAdmin returns (address) {\\n        return _implementation();\\n    }\\n\\n    /**\\n     * @dev Changes the admin of the proxy.\\n     * Only the current admin can call this function.\\n     *\\n     * @param newAdmin Address to transfer proxy administration to.\\n     */\\n    function changeAdmin(address newAdmin) external ifAdmin {\\n        require(newAdmin != address(0), \\\"Cannot change the admin of a proxy to the zero address\\\");\\n        emit AdminChanged(_admin(), newAdmin);\\n        _setAdmin(newAdmin);\\n    }\\n\\n    /**\\n     * @dev Upgrade the backing implementation of the proxy.\\n     * Only the admin can call this function.\\n     *\\n     * @param newImplementation Address of the new implementation.\\n     */\\n    function upgradeTo(address newImplementation) external ifAdmin {\\n        _upgradeTo(newImplementation);\\n    }\\n\\n    /**\\n     * @dev Upgrade the backing implementation of the proxy and call a function on the new implementation.\\n     * This is useful to initialize the proxied contract.\\n     *\\n     * The given `data` should include the signature and parameters of the function to be called.\\n     * See https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding\\n     *\\n     * @param newImplementation Address of the new implementation.\\n     * @param data Data to send as msg.data in the low level call.\\n     */\\n    function upgradeToAndCall(address newImplementation, bytes data) payable external ifAdmin {\\n        _upgradeTo(newImplementation);\\n        require(address(this).call.value(msg.value)(data));\\n    }\\n\\n    /**\\n     * @return The admin slot.\\n     */\\n    function _admin() internal view returns (address adm) {\\n        bytes32 slot = ADMIN_SLOT;\\n        assembly {\\n            adm := sload(slot)\\n        }\\n    }\\n\\n    /**\\n     * @dev Sets the address of the proxy admin.\\n     *\\n     * @param newAdmin Address of the new proxy admin.\\n     */\\n    function _setAdmin(address newAdmin) internal {\\n        bytes32 slot = ADMIN_SLOT;\\n\\n        assembly {\\n            sstore(slot, newAdmin)\\n        }\\n    }\\n\\n    /**\\n     * @dev Only fall back when the sender is not the admin.\\n     */\\n    function _willFallback() internal {\\n        require(msg.sender != _admin(), \\\"Cannot call fallback function from the proxy admin\\\");\\n        super._willFallback();\\n    }\\n}\"},\"Proxy.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\n/**\\n * @title Proxy\\n *\\n * @dev Implements delegation of calls to other contracts, with proper forwarding of return values and bubbling of\\n * failures.\\n * It defines a fallback function that delegates all calls to the address returned by the abstract `_implementation()`\\n * internal function.\\n */\\ncontract Proxy {\\n    /**\\n     * @dev Fallback function.\\n     * Implemented entirely in `_fallback`.\\n     */\\n    function () payable external {\\n        _fallback();\\n    }\\n\\n    /**\\n     * @return The Address of the implementation.\\n     */\\n    function _implementation() internal view returns (address);\\n\\n    /**\\n     * @dev Delegates execution to an implementation contract.\\n     * This is a low level function that doesn\\u0027t return to its internal call site.\\n     * It will return to the external caller whatever the implementation returns.\\n     *\\n     * @param implementation Address to delegate.\\n     */\\n    function _delegate(address implementation) internal {\\n        assembly {\\n            // Copy msg.data.\\n            // We take full control of memory in this inline assembly block because it will not return to Solidity code.\\n            // We overwrite the Solidity scratch pad at memory position 0.\\n            calldatacopy(0, 0, calldatasize)\\n\\n            // Call the implementation.\\n            // The out and outsize are 0 because we don\\u0027t know the size yet.\\n            let result := delegatecall(gas, implementation, 0, calldatasize, 0, 0)\\n\\n            // Copy the returned data.\\n            returndatacopy(0, 0, returndatasize)\\n\\n            switch result\\n            // delegatecall returns 0 on error.\\n            case 0 { revert(0, returndatasize) }\\n            default { return(0, returndatasize) }\\n        }\\n    }\\n\\n    /**\\n     * @dev Function that is run as the first thing in the fallback function.\\n     * Can be redefined in derived contracts to add functionality.\\n     * Redefinitions must call super._willFallback().\\n     */\\n    function _willFallback() internal {\\n    }\\n\\n    /**\\n     * @dev fallback implementation.\\n     * Extracted to enable manual triggering.\\n     */\\n    function _fallback() internal {\\n        _willFallback();\\n        _delegate(_implementation());\\n    }\\n}\"},\"UpgradeabilityProxy.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\nimport \\u0027./Proxy.sol\\u0027;\\nimport \\u0027./Address.sol\\u0027;\\n\\n/**\\n * @title UpgradeabilityProxy\\n *\\n * @dev This contract implements a proxy that allows to change the implementation address to which it will delegate.\\n * Such a change is called an implementation upgrade.\\n */\\ncontract UpgradeabilityProxy is Proxy {\\n    /**\\n     * @dev Emitted when the implementation is upgraded.\\n     *\\n     * @param implementation Address of the new implementation.\\n     */\\n    event Upgraded(address implementation);\\n\\n    /**\\n     * @dev Storage slot with the address of the current implementation.\\n     * This is the keccak-256 hash of \\\"infinigold.proxy.implementation\\\", and is validated in the constructor.\\n     */\\n    bytes32 private constant IMPLEMENTATION_SLOT = 0x17a1a1520654e435f06928e17f36680bf83a0dd9ed240ed37d78f8289a559c70;\\n\\n    /**\\n     * @dev Contract constructor.\\n     *\\n     * @param _implementation Address of the initial implementation.\\n     */\\n    constructor(address _implementation) public {\\n        assert(IMPLEMENTATION_SLOT == keccak256(\\\"infinigold.proxy.implementation\\\"));\\n\\n        _setImplementation(_implementation);\\n    }\\n\\n    /**\\n     * @dev Returns the current implementation.\\n     *\\n     * @return Address of the current implementation\\n     */\\n    function _implementation() internal view returns (address impl) {\\n        bytes32 slot = IMPLEMENTATION_SLOT;\\n        assembly {\\n            impl := sload(slot)\\n        }\\n    }\\n\\n    /**\\n     * @dev Upgrades the proxy to a new implementation.\\n     *\\n     * @param newImplementation Address of the new implementation.\\n     */\\n    function _upgradeTo(address newImplementation) internal {\\n        _setImplementation(newImplementation);\\n        emit Upgraded(newImplementation);\\n    }\\n\\n    /**\\n     * @dev Sets the implementation address of the proxy.\\n     *\\n     * @param newImplementation Address of the new implementation.\\n     */\\n    function _setImplementation(address newImplementation) private {\\n        require(Address.isContract(newImplementation), \\\"Cannot set a proxy implementation to a non-contract address\\\");\\n\\n        bytes32 slot = IMPLEMENTATION_SLOT;\\n\\n        assembly {\\n            sstore(slot, newImplementation)\\n        }\\n    }\\n}\\n\"}}", "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"newImplementation\",\"type\":\"address\"}],\"name\":\"upgradeTo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newImplementation\",\"type\":\"address\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"upgradeToAndCall\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"implementation\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"changeAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_implementation\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"previousAdmin\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"AdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"Upgraded\",\"type\":\"event\"}]", "ContractName": "AdminUpgradeabilityProxy", "CompilerVersion": "v0.4.24+commit.e67f0147", "OptimizationUsed": "1", "Runs": "2000", "ConstructorArguments": "0000000000000000000000004dd653e7db14bb7e509861eb2b8888773798aaad", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://0a1254f5499f71df0d106c57a820b5f02ac2470f6f5aeeff0bcc06cb68730a39"}