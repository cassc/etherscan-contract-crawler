{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/ProofFeeds.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: bsl-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./helpers/MerkleProof.sol\\\";\\n\\nimport \\\"./interfaces/public/IProofFeeds.sol\\\";\\nimport \\\"./interfaces/public/ICoreMultidataFeedsReader.sol\\\";\\nimport \\\"./NonProxiedOwnerMultipartyCommons.sol\\\";\\nimport \\\"./AbstractFeedsWithMetrics.sol\\\";\\n\\n\\ncontract ProofFeeds is IProofFeeds, ICoreMultidataFeedsReader, NonProxiedOwnerMultipartyCommons, AbstractFeedsWithMetrics {\\n\\n    /**\\n     * @notice Contract version, using SemVer version scheme.\\n     */\\n    string public constant override VERSION = \\\"0.1.0\\\";\\n\\n    bytes32 public constant override MERKLE_TREE_ROOT_TYPE_HASH = keccak256(\\\"MerkleTreeRoot(uint32 epoch,bytes32 root)\\\");\\n\\n    mapping(uint => uint) internal _values;\\n    mapping(uint => uint) internal _updateTSsPacked;\\n\\n    ////////////////////////\\n\\n    constructor (address sourceContractAddr_, uint sourceChainId_)\\n        NonProxiedOwnerMultipartyCommons(sourceContractAddr_, sourceChainId_) {\\n\\n    }\\n\\n    ///////////////////////\\n\\n    function requireValidProof(\\n        SignedMerkleTreeRoot calldata signedMerkleTreeRoot_,\\n        CheckedData calldata checkedData_\\n    ) public view override {\\n        require(isProofValid(signedMerkleTreeRoot_, checkedData_), \\\"MultidataFeeds: INVALID_PROOF\\\");\\n    }\\n\\n    function isProofValid(\\n        SignedMerkleTreeRoot calldata signedMerkleTreeRoot_,\\n        CheckedData calldata checkedData_\\n    ) public view override returns (bool) {\\n        return isSignedMerkleTreeRootValid(signedMerkleTreeRoot_)\\n            && isCheckedDataValid(signedMerkleTreeRoot_, checkedData_);\\n    }\\n\\n    function isSignedMerkleTreeRootValid(SignedMerkleTreeRoot calldata signedMerkleTreeRoot_) internal view returns (bool) {\\n        return isMessageSignatureValid(\\n            keccak256(\\n                abi.encode(MERKLE_TREE_ROOT_TYPE_HASH, signedMerkleTreeRoot_.epoch, signedMerkleTreeRoot_.root)\\n            ),\\n            signedMerkleTreeRoot_.v, signedMerkleTreeRoot_.r, signedMerkleTreeRoot_.s\\n        );\\n    }\\n\\n    function isCheckedDataValid(SignedMerkleTreeRoot calldata signedMerkleTreeRoot_, CheckedData calldata checkedData_) internal pure returns (bool) {\\n        bytes32 leaf = keccak256(bytes.concat(keccak256(abi.encode(\\n            signedMerkleTreeRoot_.epoch,\\n            checkedData_.metricData.name,\\n            checkedData_.metricData.value,\\n            checkedData_.metricData.updateTs\\n        ))));\\n\\n        return MerkleProof.verifyCalldata(checkedData_.merkleTreeProof, signedMerkleTreeRoot_.root, leaf);\\n    }\\n\\n    ////////////////////////////\\n\\n    function quoteMetrics(string[] calldata names) external view override returns (Quote[] memory quotes) {\\n        uint length = names.length;\\n        quotes = new Quote[](length);\\n\\n        for (uint i; i < length; i++) {\\n            (bool has, uint id) = hasMetric(names[i]);\\n            require(has, \\\"MultidataFeeds: INVALID_METRIC_NAME\\\");\\n            quotes[i] = Quote(_values[id], unpackUpdateTs(id));\\n        }\\n    }\\n\\n    function quoteMetrics(uint256[] calldata ids) external view override returns (Quote[] memory quotes) {\\n        uint length = ids.length;\\n        quotes = new Quote[](length);\\n\\n        uint metricsCount = getMetricsCount();\\n        for (uint i; i < length; i++) {\\n            uint id = ids[i];\\n            require(id < metricsCount, \\\"MultidataFeeds: INVALID_METRIC\\\");\\n            quotes[i] = Quote(_values[id], unpackUpdateTs(id));\\n        }\\n    }\\n\\n    ////////////////////////////\\n\\n    /**\\n     * @notice Upload signed value\\n     * @dev metric in this instance is created if it is not exists. Important: metric id is different from metric ids from other\\n     *      instances of ProofFeeds and MedianFeed\\n     */\\n    function setValue(SignedMerkleTreeRoot calldata signedMerkleTreeRoot_, CheckedData calldata data_) external {\\n        requireValidProof(signedMerkleTreeRoot_, data_);\\n\\n        setMetricValue(data_.metricData);\\n    }\\n\\n    /**\\n     * @notice Upload signed values\\n     * @dev metric in this instance is created if it is not exists. Important: metric id is different from metric ids from other\\n     *      instances of ProofFeeds and MedianFeed\\n     */\\n    function setValues(SignedMerkleTreeRoot calldata signedMerkleTreeRoot_, CheckedData[] calldata data_) external {\\n        require(isSignedMerkleTreeRootValid(signedMerkleTreeRoot_), \\\"MultidataFeeds: INVALID_ROOT\\\");\\n\\n        uint count = data_.length;\\n        for (uint i = 0; i < count; i++) {\\n            require(isCheckedDataValid(signedMerkleTreeRoot_, data_[i]), \\\"MultidataFeeds: INVALID_PROOF\\\");\\n\\n            setMetricValue(data_[i].metricData);\\n        }\\n    }\\n\\n    function setMetricValue(MetricData calldata metricData_) internal {\\n        (bool has, uint metricId) = hasMetric(metricData_.name);\\n        if (!has) {\\n            metricId = addMetric(Metric(metricData_.name, \\\"\\\", \\\"\\\", new string[](0)));\\n        }\\n\\n        require(metricData_.updateTs > unpackUpdateTs(metricId), \\\"MultidataFeeds: STALE_UPDATE\\\");\\n\\n        _values[metricId] = metricData_.value;\\n\\n        uint tempTsPacked = _updateTSsPacked[metricId / 8];\\n        uint shift = (metricId % 8) * 32;\\n        tempTsPacked &= ~(uint(type(uint32).max) << shift);\\n        tempTsPacked |= (uint(metricData_.updateTs) << shift);\\n        _updateTSsPacked[metricId / 8] = tempTsPacked;\\n    }\\n\\n    function unpackUpdateTs(uint metricId_) internal view returns (uint32) {\\n        return uint32(\\n            _updateTSsPacked[metricId_ / 8] >> ((metricId_ % 8) * 32)\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/helpers/MerkleProof.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.3) (utils/cryptography/MerkleProof.sol)\\n\\n// extracted from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.9.3/contracts/utils/cryptography/MerkleProof.sol\\n// unused multi methods were cut\\n// the original license https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.9.3/LICENSE\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev These functions deal with verification of Merkle Tree proofs.\\n *\\n * The tree and the proofs can be generated using our\\n * https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\\n * You will find a quickstart guide in the readme.\\n *\\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\\n * hashing, or use a hash function other than keccak256 for hashing leaves.\\n * This is because the concatenation of a sorted pair of internal nodes in\\n * the merkle tree could be reinterpreted as a leaf value.\\n * OpenZeppelin's JavaScript library generates merkle trees that are safe\\n * against this attack out of the box.\\n */\\nlibrary MerkleProof {\\n    /**\\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\\n     * defined by `root`. For this, a `proof` must be provided, containing\\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\\n     */\\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\\n        return processProof(proof, leaf) == root;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {verify}\\n     *\\n     * _Available since v4.7._\\n     */\\n    function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\\n        return processProofCalldata(proof, leaf) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\\n     * hash matches the root of the tree. When processing the proof, the pairs\\n     * of leafs & pre-images are assumed to be sorted.\\n     *\\n     * _Available since v4.4._\\n     */\\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            computedHash = _hashPair(computedHash, proof[i]);\\n        }\\n        return computedHash;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {processProof}\\n     *\\n     * _Available since v4.7._\\n     */\\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            computedHash = _hashPair(computedHash, proof[i]);\\n        }\\n        return computedHash;\\n    }\\n\\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\\n    }\\n\\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, a)\\n            mstore(0x20, b)\\n            value := keccak256(0x00, 0x40)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/public/IProofFeeds.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: bsl-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IVersioned.sol\\\";\\nimport \\\"./IProofFeedsCommons.sol\\\";\\n\\n\\ninterface IProofFeeds is IVersioned, IProofFeedsCommons {\\n\\n    struct MetricData {\\n        string name;\\n        uint256 value;\\n        uint32 updateTs;\\n    }\\n\\n    struct CheckedData {\\n        bytes32[] merkleTreeProof;\\n        MetricData metricData;\\n    }\\n\\n    function requireValidProof(\\n        SignedMerkleTreeRoot calldata signedMerkleTreeRoot_,\\n        CheckedData calldata checkedData_\\n    ) external view;\\n\\n    function isProofValid(\\n        SignedMerkleTreeRoot calldata signedMerkleTreeRoot_,\\n        CheckedData calldata checkedData_\\n    ) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/public/ICoreMultidataFeedsReader.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: bsl-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IVersioned.sol\\\";\\n\\n\\n/// @title Reader of MultidataFeeds core data.\\ninterface ICoreMultidataFeedsReader is IVersioned {\\n\\n    struct Metric {\\n        string name;    // unique, immutable in a contract\\n        string description;\\n        string currency;    // USD, ETH, PCT (for percent), BPS (for basis points), etc\\n        string[] tags;\\n    }\\n\\n    struct Quote {\\n        uint256 value;\\n        uint32 updateTS;\\n    }\\n\\n    event NewMetric(string name);\\n    event MetricInfoUpdated(string name);\\n    /// @notice updated one metric or all if metricId=type(uint256).max-1\\n    event MetricUpdated(uint indexed epochId, uint indexed metricId);\\n\\n\\n    /**\\n     * @notice Gets a list of metrics quoted by this oracle.\\n     * @return A list of metric info indexed by numerical metric ids.\\n     */\\n    function getMetrics() external view returns (Metric[] memory);\\n\\n    /// @notice Gets a count of metrics quoted by this oracle.\\n    function getMetricsCount() external view returns (uint);\\n\\n    /// @notice Gets metric info by a numerical id.\\n    function getMetric(uint256 id) external view returns (Metric memory);\\n\\n    /**\\n     * @notice Checks if a metric is quoted by this oracle.\\n     * @param name Metric codename.\\n     * @return has `true` if metric exists.\\n     * @return id Metric numerical id, set if `has` is true.\\n     */\\n    function hasMetric(string calldata name) external view returns (bool has, uint256 id);\\n\\n    /**\\n     * @notice Gets last known quotes for specified metrics.\\n     * @param names Metric codenames to query.\\n     * @return quotes Values and update timestamps for queried metrics.\\n     */\\n    function quoteMetrics(string[] calldata names) external view returns (Quote[] memory quotes);\\n\\n    /**\\n     * @notice Gets last known quotes for specified metrics by internal numerical ids.\\n     * @dev Saves one storage lookup per metric.\\n     * @param ids Numerical metric ids to query.\\n     * @return quotes Values and update timestamps for queried metrics.\\n     */\\n    function quoteMetrics(uint256[] calldata ids) external view returns (Quote[] memory quotes);\\n}\\n\"\r\n    },\r\n    \"contracts/NonProxiedOwnerMultipartyCommons.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: bsl-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\\\";\\nimport \\\"./MultipartyCommons.sol\\\";\\n\\n\\nabstract contract NonProxiedOwnerMultipartyCommons is MultipartyCommons {\\n    event MPOwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    OwnerMultisignature internal ownerMultisignature_; // informational field\\n    address internal mpOwner_;   // described by ownerMultisignature\\n\\n    constructor(address verifyingContract, uint256 chainId) MultipartyCommons(verifyingContract, chainId) {\\n        address[] memory newParticipants = new address[](1);\\n        newParticipants[0] = msg.sender;\\n        changeOwner_(msg.sender, 1, newParticipants);\\n    }\\n\\n    /**\\n     * @notice Changes multiparty owner data.\\n     * @param newOwner Address of the new mp owner.\\n     * @param quorum New quorum value.\\n     * @param newParticipants List of the new participants' addresses\\n     * @param salt Salt value\\n     * @param deadline Unix ts at which the work must be interrupted.\\n     */\\n    function changeOwner(address newOwner, uint quorum, address[] calldata newParticipants, uint salt, uint deadline)\\n        external\\n        selfCall\\n        applicable(salt, deadline)\\n    {\\n        changeOwner_(newOwner, quorum, newParticipants);\\n    }\\n\\n    /**\\n     * @notice Changes multiparty owner data. Internal\\n     * @param newOwner Address of the new mp owner.\\n     * @param quorum New quorum value.\\n     * @param newParticipants List of the new participants' addresses\\n     */\\n    function changeOwner_(address newOwner, uint quorum, address[] memory newParticipants)\\n        internal\\n    {\\n        require(newOwner != address(0), \\\"MP: ZERO_ADDRESS\\\");\\n        emit MPOwnershipTransferred(mpOwner_, newOwner);\\n        address[] memory oldParticipants = ownerMultisignature_.participants;\\n        onNewOwner(newOwner, quorum, newParticipants, oldParticipants);\\n        ownerMultisignature_.quorum = quorum;\\n        ownerMultisignature_.participants = newParticipants;\\n        mpOwner_ = newOwner;\\n    }\\n\\n    /**\\n     * @notice The new mp owner handler. Empty implementation\\n     * @param newOwner Address of the new mp owner.\\n     * @param newQuorum New quorum value.\\n     * @param newParticipants List of the new participants' addresses.\\n     * @param oldParticipants List of the old participants' addresses.\\n     */\\n    function onNewOwner(address newOwner, uint newQuorum, address[] memory newParticipants, address[] memory oldParticipants) virtual internal {}\\n\\n    // @inheritdoc IMpOwnable\\n    function ownerMultisignature() public view virtual override returns (OwnerMultisignature memory) {\\n        return ownerMultisignature_;\\n    }\\n\\n    // @inheritdoc IMpOwnable\\n    function mpOwner() public view virtual override returns (address) {\\n        return mpOwner_;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/AbstractFeedsWithMetrics.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: bsl-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./interfaces/public/ICoreMultidataFeedsReader.sol\\\";\\n\\n\\nabstract contract AbstractFeedsWithMetrics is ICoreMultidataFeedsReader {\\n\\n    Metric[] internal metrics;\\n    // Position of the metric in the `metrics` array, plus 1 because index 0\\n    // means that metric is not exists (to avoid additional checks of existence).\\n    mapping(string => uint) internal adjustedMetricId;\\n\\n    /// @inheritdoc ICoreMultidataFeedsReader\\n    function getMetrics() public view override returns (Metric[] memory) {\\n        return metrics;\\n    }\\n\\n    /// @inheritdoc ICoreMultidataFeedsReader\\n    function getMetricsCount() public view override returns (uint) {\\n        return metrics.length;\\n    }\\n\\n    /// @inheritdoc ICoreMultidataFeedsReader\\n    function getMetric(uint256 id) external view override returns (Metric memory) {\\n        require(id < metrics.length, \\\"MultidataFeeds: METRIC_NOT_FOUND\\\");\\n        return metrics[id];\\n    }\\n\\n    /// @inheritdoc ICoreMultidataFeedsReader\\n    function hasMetric(string calldata name) public view override returns (bool has, uint256 id) {\\n        uint adjustedId = adjustedMetricId[name];\\n        if (adjustedId != 0) {\\n            return (true, adjustedId - 1);\\n        }\\n\\n        return (false, 0);\\n    }\\n\\n    function addMetric(Metric memory metric_) internal returns (uint newMetricId_) {\\n        uint adjustedId = adjustedMetricId[metric_.name];\\n        require(adjustedId == 0, \\\"MultidataFeeds: METRIC_EXISTS\\\");\\n\\n        newMetricId_ = metrics.length;\\n        adjustedMetricId[metric_.name] = newMetricId_ + 1;\\n        metrics.push(metric_);\\n\\n        emit NewMetric(metric_.name);\\n    }\\n\\n    function updateMetric(Metric memory metric_) internal {\\n        uint adjustedId = adjustedMetricId[metric_.name];\\n        require(adjustedId != 0, \\\"MultidataFeeds: METRIC_NOT_FOUND\\\");\\n\\n        metrics[adjustedId-1] = metric_;\\n        emit MetricInfoUpdated(metric_.name);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/public/IVersioned.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: bsl-1.1\\n\\npragma solidity ^0.8.0;\\n\\n\\n/// @title Contract supporting versioning using SemVer version scheme.\\ninterface IVersioned {\\n    /// @notice Contract version, using SemVer version scheme.\\n    function VERSION() external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/public/IProofFeedsCommons.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: bsl-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IVersioned.sol\\\";\\n\\n\\ninterface IProofFeedsCommons {\\n\\n    struct SignedMerkleTreeRoot {\\n        uint32 epoch;\\n        uint8 v;\\n        bytes32 r;\\n        bytes32 s;\\n        bytes32 root;\\n    }\\n\\n    /// @dev must be keccak256(\\\"MerkleTreeRoot(uint32 epoch,bytes32 root)\\\")\\n    function MERKLE_TREE_ROOT_TYPE_HASH() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        // Divide the signature in r, s and v variables\\n        bytes32 r;\\n        bytes32 s;\\n        uint8 v;\\n\\n        // Check the signature length\\n        // - case 65: r,s,v signature (standard)\\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\\n        if (signature.length == 65) {\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            // solhint-disable-next-line no-inline-assembly\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n        } else if (signature.length == 64) {\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            // solhint-disable-next-line no-inline-assembly\\n            assembly {\\n                let vs := mload(add(signature, 0x40))\\n                r := mload(add(signature, 0x20))\\n                s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n                v := add(shr(255, vs), 27)\\n            }\\n        } else {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        }\\n\\n        return recover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (281): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (282): v \u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, \\\"ECDSA: invalid signature 's' value\\\");\\n        require(v == 27 || v == 28, \\\"ECDSA: invalid signature 'v' value\\\");\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        require(signer != address(0), \\\"ECDSA: invalid signature\\\");\\n\\n        return signer;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/MultipartyCommons.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: bsl-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\\\";\\nimport \\\"./interfaces/IMpOwnable.sol\\\";\\n\\n\\nabstract contract MultipartyCommons is IMpOwnable {\\n    bytes32 immutable internal VOTE_TYPE_HASH;\\n    bytes32 internal DOMAIN_SEPARATOR;\\n\\n    mapping(uint => bool) public usedSalt;\\n\\n    // Self-calls are used to engage builtin deserialization facility (abi parsing) and not parse args ourselves\\n    modifier selfCall virtual {\\n        require(msg.sender == address(this), \\\"MP: NO_ACCESS\\\");\\n        _;\\n    }\\n\\n    // Checks if a privileged call can be applied\\n    modifier applicable(uint salt, uint deadline) virtual {\\n        require(getTimeNow() <= deadline, \\\"MP: DEADLINE\\\");\\n        require(!usedSalt[salt], \\\"MP: DUPLICATE\\\");\\n        usedSalt[salt] = true;\\n        _;\\n    }\\n\\n    constructor(address verifyingContract, uint256 chainId) {\\n        require(verifyingContract != address(0) && chainId != 0, 'MP: Invalid domain parameters');\\n        VOTE_TYPE_HASH = keccak256(\\\"Vote(bytes calldata)\\\");\\n        setDomainSeparator(chainId, verifyingContract);\\n    }\\n\\n    /**\\n     * @notice DOMAIN_SEPARATOR setter.\\n     * @param chainId Chain id of the verifying contract\\n     * @param verifyingContract Address of the verifying contract\\n     */\\n    function setDomainSeparator(uint256 chainId, address verifyingContract) internal {\\n        DOMAIN_SEPARATOR = buildDomainSeparator(chainId, verifyingContract);\\n    }\\n\\n    function buildDomainSeparator(uint256 chainId, address verifyingContract) internal pure returns (bytes32) {\\n        return keccak256(\\n            abi.encode(\\n                keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                keccak256(bytes(\\\"Multidata.Multiparty.Protocol\\\")),\\n                keccak256(bytes(\\\"1\\\")),\\n                chainId,\\n                verifyingContract\\n            )\\n        );\\n    }\\n\\n    /**\\n     * @notice Performs privileged call to the contract.\\n     * @param privilegedCallData Method calldata\\n     * @param v Signature v for the call\\n     * @param r Signature r for the call\\n     * @param s Signature s for the call\\n     */\\n    function privilegedCall(bytes calldata privilegedCallData, uint8 v, bytes32 r, bytes32 s) external\\n    {\\n        checkMessageSignature(keccak256(abi.encode(VOTE_TYPE_HASH, keccak256(privilegedCallData))), v, r, s);\\n\\n        (bool success, bytes memory returnData) = address(this).call(privilegedCallData);\\n        if (!success) {\\n            revert(string(returnData));\\n        }\\n    }\\n\\n    /**\\n     * @notice Checks the message signature.\\n     * @param hashStruct Hash of a message struct\\n     * @param v V of the message signature\\n     * @param r R of the message signature\\n     * @param s S of the message signature\\n     */\\n    function checkMessageSignature(bytes32 hashStruct, uint8 v, bytes32 r, bytes32 s) internal virtual view {\\n        require(isMessageSignatureValid(hashStruct, v, r, s), \\\"MP: NO_ACCESS\\\");\\n    }\\n\\n    function isMessageSignatureValid(bytes32 hashStruct, uint8 v, bytes32 r, bytes32 s) internal virtual view returns (bool) {\\n        return ECDSA.recover(generateMessageHash(hashStruct), v, r, s) == mpOwner();\\n    }\\n\\n    function checkMessageSignatureForDomain(bytes32 domainSeparator, bytes32 hashStruct, uint8 v, bytes32 r, bytes32 s) internal virtual view {\\n        require(ECDSA.recover(generateMessageHashForDomain(domainSeparator, hashStruct), v, r, s) == mpOwner(), \\\"MP: NO_ACCESS\\\");\\n    }\\n\\n    /**\\n     * @notice Returns hash of the message for the hash of the struct.\\n     * @param hashStruct Hash of a message struct\\n     */\\n    function generateMessageHash(bytes32 hashStruct) internal view returns (bytes32) {\\n        return generateMessageHashForDomain(DOMAIN_SEPARATOR, hashStruct);\\n    }\\n\\n    function generateMessageHashForDomain(bytes32 domainSeparator, bytes32 hashStruct) internal pure returns (bytes32) {\\n        return keccak256(\\n            abi.encodePacked(\\n                \\\"\\\\x19\\\\x01\\\",\\n                domainSeparator,\\n                hashStruct\\n            )\\n        );\\n    }\\n\\n    /**\\n     * @notice Returns current chain time in unix ts.\\n     */\\n    function getTimeNow() virtual internal view returns (uint32) {\\n        return uint32(block.timestamp);\\n    }\\n\\n    // @inheritdoc IMpOwnable\\n    function ownerMultisignature() public view virtual override returns (OwnerMultisignature memory);\\n\\n    // @inheritdoc IMpOwnable\\n    function mpOwner() public view virtual override returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IMpOwnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\ninterface IMpOwnable {\\n    struct OwnerMultisignature {\\n        uint quorum;\\n        address[] participants;\\n    }\\n\\n    // @notice Returns OwnerMultisignature data\\n    function ownerMultisignature() external view returns (OwnerMultisignature memory);\\n\\n    // @notice Returns address og the multiparty owner\\n    function mpOwner() external view returns (address);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sourceContractAddr_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"sourceChainId_\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"MPOwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"name\":\"MetricInfoUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"epochId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"metricId\",\"type\":\"uint256\"}],\"name\":\"MetricUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"name\":\"NewMetric\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MERKLE_TREE_ROOT_TYPE_HASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VERSION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"quorum\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"newParticipants\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"changeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getMetric\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"currency\",\"type\":\"string\"},{\"internalType\":\"string[]\",\"name\":\"tags\",\"type\":\"string[]\"}],\"internalType\":\"struct ICoreMultidataFeedsReader.Metric\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMetrics\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"currency\",\"type\":\"string\"},{\"internalType\":\"string[]\",\"name\":\"tags\",\"type\":\"string[]\"}],\"internalType\":\"struct ICoreMultidataFeedsReader.Metric[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMetricsCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"name\":\"hasMetric\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"has\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"epoch\",\"type\":\"uint32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"}],\"internalType\":\"struct IProofFeedsCommons.SignedMerkleTreeRoot\",\"name\":\"signedMerkleTreeRoot_\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes32[]\",\"name\":\"merkleTreeProof\",\"type\":\"bytes32[]\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"updateTs\",\"type\":\"uint32\"}],\"internalType\":\"struct IProofFeeds.MetricData\",\"name\":\"metricData\",\"type\":\"tuple\"}],\"internalType\":\"struct IProofFeeds.CheckedData\",\"name\":\"checkedData_\",\"type\":\"tuple\"}],\"name\":\"isProofValid\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mpOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ownerMultisignature\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"quorum\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"participants\",\"type\":\"address[]\"}],\"internalType\":\"struct IMpOwnable.OwnerMultisignature\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"privilegedCallData\",\"type\":\"bytes\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"privilegedCall\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string[]\",\"name\":\"names\",\"type\":\"string[]\"}],\"name\":\"quoteMetrics\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"updateTS\",\"type\":\"uint32\"}],\"internalType\":\"struct ICoreMultidataFeedsReader.Quote[]\",\"name\":\"quotes\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"name\":\"quoteMetrics\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"updateTS\",\"type\":\"uint32\"}],\"internalType\":\"struct ICoreMultidataFeedsReader.Quote[]\",\"name\":\"quotes\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"epoch\",\"type\":\"uint32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"}],\"internalType\":\"struct IProofFeedsCommons.SignedMerkleTreeRoot\",\"name\":\"signedMerkleTreeRoot_\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes32[]\",\"name\":\"merkleTreeProof\",\"type\":\"bytes32[]\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"updateTs\",\"type\":\"uint32\"}],\"internalType\":\"struct IProofFeeds.MetricData\",\"name\":\"metricData\",\"type\":\"tuple\"}],\"internalType\":\"struct IProofFeeds.CheckedData\",\"name\":\"checkedData_\",\"type\":\"tuple\"}],\"name\":\"requireValidProof\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"epoch\",\"type\":\"uint32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"}],\"internalType\":\"struct IProofFeedsCommons.SignedMerkleTreeRoot\",\"name\":\"signedMerkleTreeRoot_\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes32[]\",\"name\":\"merkleTreeProof\",\"type\":\"bytes32[]\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"updateTs\",\"type\":\"uint32\"}],\"internalType\":\"struct IProofFeeds.MetricData\",\"name\":\"metricData\",\"type\":\"tuple\"}],\"internalType\":\"struct IProofFeeds.CheckedData\",\"name\":\"data_\",\"type\":\"tuple\"}],\"name\":\"setValue\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"epoch\",\"type\":\"uint32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"}],\"internalType\":\"struct IProofFeedsCommons.SignedMerkleTreeRoot\",\"name\":\"signedMerkleTreeRoot_\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes32[]\",\"name\":\"merkleTreeProof\",\"type\":\"bytes32[]\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"updateTs\",\"type\":\"uint32\"}],\"internalType\":\"struct IProofFeeds.MetricData\",\"name\":\"metricData\",\"type\":\"tuple\"}],\"internalType\":\"struct IProofFeeds.CheckedData[]\",\"name\":\"data_\",\"type\":\"tuple[]\"}],\"name\":\"setValues\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"usedSalt\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "ProofFeeds", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000d3169156b29f84f2fadde670296fdf7e9fa44f220000000000000000000000000000000000000000000000000000000000000064", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}