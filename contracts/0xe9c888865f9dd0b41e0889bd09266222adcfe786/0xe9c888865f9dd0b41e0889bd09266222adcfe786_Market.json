{"SourceCode": "pragma solidity 0.5.15;\r\n\r\n\r\ncontract IERC20 {\r\n    uint8 public decimals = 18;\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address owner) public view returns (uint256);\r\n    function transfer(address to, uint256 amount) public returns (bool);\r\n    function transferFrom(address from, address to, uint256 amount) public returns (bool);\r\n    function approve(address spender, uint256 amount) public returns (bool);\r\n    function allowance(address owner, address spender) public view returns (uint256);\r\n\r\n    // solhint-disable-next-line no-simple-event-func-name\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract IOrders {\r\n    function saveOrder(\r\n        uint256[] calldata _uints,\r\n        bytes32[] calldata _bytes32s,\r\n        Order.Types _type,\r\n        IMarket _market,\r\n        address _sender\r\n    ) external returns (bytes32 _orderId);\r\n\r\n    function removeOrder(bytes32 _orderId) external returns (bool);\r\n\r\n    function getMarket(bytes32 _orderId) public view returns (IMarket);\r\n\r\n    function getOrderType(bytes32 _orderId) public view returns (Order.Types);\r\n\r\n    function getOutcome(bytes32 _orderId) public view returns (uint256);\r\n\r\n    function getAmount(bytes32 _orderId) public view returns (uint256);\r\n\r\n    function getPrice(bytes32 _orderId) public view returns (uint256);\r\n\r\n    function getOrderCreator(bytes32 _orderId) public view returns (address);\r\n\r\n    function getOrderSharesEscrowed(bytes32 _orderId)\r\n        public\r\n        view\r\n        returns (uint256);\r\n\r\n    function getOrderMoneyEscrowed(bytes32 _orderId)\r\n        public\r\n        view\r\n        returns (uint256);\r\n\r\n    function getOrderDataForCancel(bytes32 _orderId)\r\n        public\r\n        view\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            Order.Types,\r\n            IMarket,\r\n            uint256,\r\n            address\r\n        );\r\n\r\n    function getOrderDataForLogs(bytes32 _orderId)\r\n        public\r\n        view\r\n        returns (\r\n            Order.Types,\r\n            address[] memory _addressData,\r\n            uint256[] memory _uint256Data\r\n        );\r\n\r\n    function getBetterOrderId(bytes32 _orderId) public view returns (bytes32);\r\n\r\n    function getWorseOrderId(bytes32 _orderId) public view returns (bytes32);\r\n\r\n    function getBestOrderId(\r\n        Order.Types _type,\r\n        IMarket _market,\r\n        uint256 _outcome\r\n    ) public view returns (bytes32);\r\n\r\n    function getWorstOrderId(\r\n        Order.Types _type,\r\n        IMarket _market,\r\n        uint256 _outcome\r\n    ) public view returns (bytes32);\r\n\r\n    function getLastOutcomePrice(IMarket _market, uint256 _outcome)\r\n        public\r\n        view\r\n        returns (uint256);\r\n\r\n    function getOrderId(\r\n        Order.Types _type,\r\n        IMarket _market,\r\n        uint256 _amount,\r\n        uint256 _price,\r\n        address _sender,\r\n        uint256 _blockNumber,\r\n        uint256 _outcome,\r\n        uint256 _moneyEscrowed,\r\n        uint256 _sharesEscrowed\r\n    ) public pure returns (bytes32);\r\n\r\n    function getTotalEscrowed(IMarket _market) public view returns (uint256);\r\n\r\n    function isBetterPrice(\r\n        Order.Types _type,\r\n        uint256 _price,\r\n        bytes32 _orderId\r\n    ) public view returns (bool);\r\n\r\n    function isWorsePrice(\r\n        Order.Types _type,\r\n        uint256 _price,\r\n        bytes32 _orderId\r\n    ) public view returns (bool);\r\n\r\n    function assertIsNotBetterPrice(\r\n        Order.Types _type,\r\n        uint256 _price,\r\n        bytes32 _betterOrderId\r\n    ) public view returns (bool);\r\n\r\n    function assertIsNotWorsePrice(\r\n        Order.Types _type,\r\n        uint256 _price,\r\n        bytes32 _worseOrderId\r\n    ) public returns (bool);\r\n\r\n    function recordFillOrder(\r\n        bytes32 _orderId,\r\n        uint256 _sharesFilled,\r\n        uint256 _tokensFilled,\r\n        uint256 _fill\r\n    ) external returns (bool);\r\n\r\n    function setPrice(\r\n        IMarket _market,\r\n        uint256 _outcome,\r\n        uint256 _price\r\n    ) external returns (bool);\r\n}\r\n\r\n\r\n\r\n\r\n\r\ncontract IAugurTrading {\r\n    function lookup(bytes32 _key) public view returns (address);\r\n\r\n    function logProfitLossChanged(\r\n        IMarket _market,\r\n        address _account,\r\n        uint256 _outcome,\r\n        int256 _netPosition,\r\n        uint256 _avgPrice,\r\n        int256 _realizedProfit,\r\n        int256 _frozenFunds,\r\n        int256 _realizedCost\r\n    ) public returns (bool);\r\n\r\n    function logOrderCreated(\r\n        IUniverse _universe,\r\n        bytes32 _orderId,\r\n        bytes32 _tradeGroupId\r\n    ) public returns (bool);\r\n\r\n    function logOrderCanceled(\r\n        IUniverse _universe,\r\n        IMarket _market,\r\n        address _creator,\r\n        uint256 _tokenRefund,\r\n        uint256 _sharesRefund,\r\n        bytes32 _orderId\r\n    ) public returns (bool);\r\n\r\n    function logOrderFilled(\r\n        IUniverse _universe,\r\n        address _creator,\r\n        address _filler,\r\n        uint256 _price,\r\n        uint256 _fees,\r\n        uint256 _amountFilled,\r\n        bytes32 _orderId,\r\n        bytes32 _tradeGroupId\r\n    ) public returns (bool);\r\n\r\n    function logMarketVolumeChanged(\r\n        IUniverse _universe,\r\n        address _market,\r\n        uint256 _volume,\r\n        uint256[] memory _outcomeVolumes,\r\n        uint256 _totalTrades\r\n    ) public returns (bool);\r\n\r\n    function logZeroXOrderFilled(\r\n        IUniverse _universe,\r\n        IMarket _market,\r\n        bytes32 _orderHash,\r\n        bytes32 _tradeGroupId,\r\n        uint8 _orderType,\r\n        address[] memory _addressData,\r\n        uint256[] memory _uint256Data\r\n    ) public returns (bool);\r\n\r\n    function logZeroXOrderCanceled(\r\n        address _universe,\r\n        address _market,\r\n        address _account,\r\n        uint256 _outcome,\r\n        uint256 _price,\r\n        uint256 _amount,\r\n        uint8 _type,\r\n        bytes32 _orderHash\r\n    ) public;\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title SafeMathUint256\r\n * @dev Uint256 math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMathUint256 {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function subS(uint256 a, uint256 b, string memory message) internal pure returns (uint256) {\r\n        require(b <= a, message);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n        return c;\r\n    }\r\n\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a <= b) {\r\n            return a;\r\n        } else {\r\n            return b;\r\n        }\r\n    }\r\n\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a >= b) {\r\n            return a;\r\n        } else {\r\n            return b;\r\n        }\r\n    }\r\n\r\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\r\n        if (y > 3) {\r\n            uint256 x = (y + 1) / 2;\r\n            z = y;\r\n            while (x < z) {\r\n                z = x;\r\n                x = (y / x + x) / 2;\r\n            }\r\n        } else if (y != 0) {\r\n            z = 1;\r\n        }\r\n    }\r\n\r\n    function getUint256Min() internal pure returns (uint256) {\r\n        return 0;\r\n    }\r\n\r\n    function getUint256Max() internal pure returns (uint256) {\r\n        // 2 ** 256 - 1\r\n        return 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\r\n    }\r\n\r\n    function isMultipleOf(uint256 a, uint256 b) internal pure returns (bool) {\r\n        return a % b == 0;\r\n    }\r\n\r\n    // Float [fixed point] Operations\r\n    function fxpMul(uint256 a, uint256 b, uint256 base) internal pure returns (uint256) {\r\n        return div(mul(a, b), base);\r\n    }\r\n\r\n    function fxpDiv(uint256 a, uint256 b, uint256 base) internal pure returns (uint256) {\r\n        return div(mul(a, base), b);\r\n    }\r\n}\r\n\r\n\r\n\r\ncontract ITyped {\r\n    function getTypeName() public view returns (bytes32);\r\n}\r\n/*\r\n\r\n  Copyright 2018 ZeroEx Intl.\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n\r\n*/\r\n\r\n\r\n\r\n\r\n/// @title ERC-1155 Multi Token Standard\r\n/// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1155.md\r\n/// Note: The ERC-165 identifier for this interface is 0xd9b67a26.\r\ninterface IERC1155 {\r\n\r\n    /// @dev Either TransferSingle or TransferBatch MUST emit when tokens are transferred,\r\n    ///      including zero value transfers as well as minting or burning.\r\n    /// Operator will always be msg.sender.\r\n    /// Either event from address `0x0` signifies a minting operation.\r\n    /// An event to address `0x0` signifies a burning or melting operation.\r\n    /// The total value transferred from address 0x0 minus the total value transferred to 0x0 may\r\n    /// be used by clients and exchanges to be added to the \"circulating supply\" for a given token ID.\r\n    /// To define a token ID with no initial balance, the contract SHOULD emit the TransferSingle event\r\n    /// from `0x0` to `0x0`, with the token creator as `_operator`.\r\n    event TransferSingle(\r\n        address indexed operator,\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 id,\r\n        uint256 value\r\n    );\r\n\r\n    /// @dev Either TransferSingle or TransferBatch MUST emit when tokens are transferred,\r\n    ///      including zero value transfers as well as minting or burning.\r\n    ///Operator will always be msg.sender.\r\n    /// Either event from address `0x0` signifies a minting operation.\r\n    /// An event to address `0x0` signifies a burning or melting operation.\r\n    /// The total value transferred from address 0x0 minus the total value transferred to 0x0 may\r\n    /// be used by clients and exchanges to be added to the \"circulating supply\" for a given token ID.\r\n    /// To define multiple token IDs with no initial balance, this SHOULD emit the TransferBatch event\r\n    /// from `0x0` to `0x0`, with the token creator as `_operator`.\r\n    event TransferBatch(\r\n        address indexed operator,\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256[] ids,\r\n        uint256[] values\r\n    );\r\n\r\n    /// @dev MUST emit when an approval is updated.\r\n    event ApprovalForAll(\r\n        address indexed owner,\r\n        address indexed operator,\r\n        bool approved\r\n    );\r\n\r\n    /// @dev MUST emit when the URI is updated for a token ID.\r\n    /// URIs are defined in RFC 3986.\r\n    /// The URI MUST point a JSON file that conforms to the \"ERC-1155 Metadata JSON Schema\".\r\n    event URI(\r\n        string value,\r\n        uint256 indexed id\r\n    );\r\n\r\n    /// @notice Transfers value amount of an _id from the _from address to the _to address specified.\r\n    /// @dev MUST emit TransferSingle event on success.\r\n    /// Caller must be approved to manage the _from account's tokens (see isApprovedForAll).\r\n    /// MUST throw if `_to` is the zero address.\r\n    /// MUST throw if balance of sender for token `_id` is lower than the `_value` sent.\r\n    /// MUST throw on any other error.\r\n    /// When transfer is complete, this function MUST check if `_to` is a smart contract (code size > 0).\r\n    /// If so, it MUST call `onERC1155Received` on `_to` and revert if the return value\r\n    /// is not `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`.\r\n    /// @param from    Source address\r\n    /// @param to      Target address\r\n    /// @param id      ID of the token type\r\n    /// @param value   Transfer amount\r\n    /// @param data    Additional data with no specified format, sent in call to `_to`\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        uint256 value,\r\n        bytes calldata data\r\n    )\r\n        external;\r\n\r\n    /// @notice Send multiple types of Tokens from a 3rd party in one transfer (with safety call).\r\n    /// @dev MUST emit TransferBatch event on success.\r\n    /// Caller must be approved to manage the _from account's tokens (see isApprovedForAll).\r\n    /// MUST throw if `_to` is the zero address.\r\n    /// MUST throw if length of `_ids` is not the same as length of `_values`.\r\n    ///  MUST throw if any of the balance of sender for token `_ids` is lower than the respective `_values` sent.\r\n    /// MUST throw on any other error.\r\n    /// When transfer is complete, this function MUST check if `_to` is a smart contract (code size > 0).\r\n    /// If so, it MUST call `onERC1155BatchReceived` on `_to` and revert if the return value\r\n    /// is not `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`.\r\n    /// @param from    Source addresses\r\n    /// @param to      Target addresses\r\n    /// @param ids     IDs of each token type\r\n    /// @param values  Transfer amounts per token type\r\n    /// @param data    Additional data with no specified format, sent in call to `_to`\r\n    function safeBatchTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata values,\r\n        bytes calldata data\r\n    )\r\n        external;\r\n\r\n    /// @notice Enable or disable approval for a third party (\"operator\") to manage all of the caller's tokens.\r\n    /// @dev MUST emit the ApprovalForAll event on success.\r\n    /// @param operator  Address to add to the set of authorized operators\r\n    /// @param approved  True if the operator is approved, false to revoke approval\r\n    function setApprovalForAll(address operator, bool approved) external;\r\n\r\n    /// @notice Queries the approval status of an operator for a given owner.\r\n    /// @param owner     The owner of the Tokens\r\n    /// @param operator  Address of authorized operator\r\n    /// @return           True if the operator is approved, false if not\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n\r\n    /// @notice Get the balance of an account's Tokens.\r\n    /// @param owner  The address of the token holder\r\n    /// @param id     ID of the Token\r\n    /// @return        The _owner's balance of the Token type requested\r\n    function balanceOf(address owner, uint256 id) external view returns (uint256);\r\n\r\n    /// @notice Get the total supply of a Token.\r\n    /// @param id     ID of the Token\r\n    /// @return        The total supply of the Token type requested\r\n    function totalSupply(uint256 id) external view returns (uint256);\r\n\r\n    /// @notice Get the balance of multiple account/token pairs\r\n    /// @param owners The addresses of the token holders\r\n    /// @param ids    ID of the Tokens\r\n    /// @return        The _owner's balance of the Token types requested\r\n    function balanceOfBatch(\r\n        address[] calldata owners,\r\n        uint256[] calldata ids\r\n    )\r\n        external\r\n        view\r\n        returns (uint256[] memory balances_);\r\n}\r\n\r\n\r\ncontract IOwnable {\r\n    function getOwner() public view returns (address);\r\n    function transferOwnership(address _newOwner) public returns (bool);\r\n}\r\n\r\n\r\n// import '../reporting/IMarket.sol';\r\n// import '../reporting/IDisputeWindow.sol';\r\n\r\ncontract IReportingParticipant {\r\n    function getStake() public view returns (uint256);\r\n\r\n    function getPayoutDistributionHash() public view returns (bytes32);\r\n\r\n    function liquidateLosing() public;\r\n\r\n    function redeem(address _redeemer) public returns (bool);\r\n\r\n    function isDisavowed() public view returns (bool);\r\n\r\n    function getPayoutNumerator(uint256 _outcome) public view returns (uint256);\r\n\r\n    function getPayoutNumerators() public view returns (uint256[] memory);\r\n\r\n    function getMarket() public view returns (address);\r\n\r\n    function getSize() public view returns (uint256);\r\n}\r\n\r\n\r\n// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1167.md\r\n\r\n/* Template Code for the create clone method:\r\n  function createClone(address target) internal returns (address result) {\r\n    bytes20 targetBytes = bytes20(target)${bytes == 20 ? \"\" : \"<<\" + ((20 - bytes) * 8)};\r\n    assembly {\r\n      let clone := mload(0x40)\r\n      mstore(clone, 0x${code.substring(0, 2*(cloner.labels.address + 1)).padEnd(64, '0')})\r\n      mstore(add(clone, 0x${(cloner.labels.address + 1).toString(16)}), targetBytes)\r\n      mstore(add(clone, 0x${(cloner.labels.address + bytes + 1).toString(16)}), 0x${code.substring(2*(cloner.labels.address + bytes + 1), 2*(cloner.labels.address+bytes+1) + 30).padEnd(64, '0')})\r\n      result := create(0, clone, 0x${(code.length / 2).toString(16)})\r\n    }\r\n  }\r\n*/\r\n\r\n\r\ncontract CloneFactory {\r\n    function createClone(address target) internal returns (address result) {\r\n        // convert address to bytes20 for assembly use\r\n        bytes20 targetBytes = bytes20(target);\r\n        assembly {\r\n            // allocate clone memory\r\n            let clone := mload(0x40)\r\n            // store initial portion of the delegation contract code in bytes form\r\n            mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\r\n            // store the provided address\r\n            mstore(add(clone, 0x14), targetBytes)\r\n            // store the remaining delegation contract code\r\n            mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\r\n            // create the actual delegate contract reference and return its address\r\n            result := create(0, clone, 0x37)\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\ncontract IAffiliateValidator {\r\n    function validateReference(address _account, address _referrer) external view returns (bool);\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract IInitialReporter is IReportingParticipant, IOwnable {\r\n    function initialize(\r\n        IAugur _augur,\r\n        IMarket _market,\r\n        address _designatedReporter\r\n    ) public;\r\n\r\n    function report(\r\n        address _reporter,\r\n        bytes32 _payoutDistributionHash,\r\n        uint256[] memory _payoutNumerators,\r\n        uint256 _initialReportStake\r\n    ) public;\r\n\r\n    function designatedReporterShowed() public view returns (bool);\r\n\r\n    function initialReporterWasCorrect() public view returns (bool);\r\n\r\n    function getDesignatedReporter() public view returns (address);\r\n\r\n    function getReportTimestamp() public view returns (uint256);\r\n\r\n    function migrateToNewUniverse(address _designatedReporter) public;\r\n\r\n    function returnRepFromDisavow() public;\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract IReputationToken is IERC20 {\r\n    function migrateOutByPayout(\r\n        uint256[] memory _payoutNumerators,\r\n        uint256 _attotokens\r\n    ) public returns (bool);\r\n\r\n    function migrateIn(address _reporter, uint256 _attotokens)\r\n        public\r\n        returns (bool);\r\n\r\n    function trustedReportingParticipantTransfer(\r\n        address _source,\r\n        address _destination,\r\n        uint256 _attotokens\r\n    ) public returns (bool);\r\n\r\n    function trustedMarketTransfer(\r\n        address _source,\r\n        address _destination,\r\n        uint256 _attotokens\r\n    ) public returns (bool);\r\n\r\n    function trustedUniverseTransfer(\r\n        address _source,\r\n        address _destination,\r\n        uint256 _attotokens\r\n    ) public returns (bool);\r\n\r\n    function trustedDisputeWindowTransfer(\r\n        address _source,\r\n        address _destination,\r\n        uint256 _attotokens\r\n    ) public returns (bool);\r\n\r\n    function getUniverse() public view returns (IUniverse);\r\n\r\n    function getTotalMigrated() public view returns (uint256);\r\n\r\n    function getTotalTheoreticalSupply() public view returns (uint256);\r\n\r\n    function mintForReportingParticipant(uint256 _amountMigrated)\r\n        public\r\n        returns (bool);\r\n}\r\n\r\n\r\ncontract IV2ReputationToken is IReputationToken {\r\n    function parentUniverse() external returns (IUniverse);\r\n\r\n    function burnForMarket(uint256 _amountToBurn) public returns (bool);\r\n\r\n    function mintForWarpSync(uint256 _amountToMint, address _target)\r\n        public\r\n        returns (bool);\r\n\r\n    function getLegacyRepToken() public view returns (IERC20);\r\n\r\n    function symbol() public view returns (string memory);\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract IShareToken is ITyped, IERC1155 {\r\n    function initialize(IAugur _augur) external;\r\n\r\n    function initializeMarket(\r\n        IMarket _market,\r\n        uint256 _numOutcomes,\r\n        uint256 _numTicks\r\n    ) public;\r\n\r\n    function unsafeTransferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _id,\r\n        uint256 _value\r\n    ) public;\r\n\r\n    function unsafeBatchTransferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256[] memory _ids,\r\n        uint256[] memory _values\r\n    ) public;\r\n\r\n    function claimTradingProceeds(\r\n        IMarket _market,\r\n        address _shareHolder,\r\n        bytes32 _fingerprint\r\n    ) external returns (uint256[] memory _outcomeFees);\r\n\r\n    function getMarket(uint256 _tokenId) external view returns (IMarket);\r\n\r\n    function getOutcome(uint256 _tokenId) external view returns (uint256);\r\n\r\n    function getTokenId(IMarket _market, uint256 _outcome)\r\n        public\r\n        pure\r\n        returns (uint256 _tokenId);\r\n\r\n    function getTokenIds(IMarket _market, uint256[] memory _outcomes)\r\n        public\r\n        pure\r\n        returns (uint256[] memory _tokenIds);\r\n\r\n    function buyCompleteSets(\r\n        IMarket _market,\r\n        address _account,\r\n        uint256 _amount\r\n    ) external returns (bool);\r\n\r\n    function buyCompleteSetsForTrade(\r\n        IMarket _market,\r\n        uint256 _amount,\r\n        uint256 _longOutcome,\r\n        address _longRecipient,\r\n        address _shortRecipient\r\n    ) external returns (bool);\r\n\r\n    function sellCompleteSets(\r\n        IMarket _market,\r\n        address _holder,\r\n        address _recipient,\r\n        uint256 _amount,\r\n        bytes32 _fingerprint\r\n    ) external returns (uint256 _creatorFee, uint256 _reportingFee);\r\n\r\n    function sellCompleteSetsForTrade(\r\n        IMarket _market,\r\n        uint256 _outcome,\r\n        uint256 _amount,\r\n        address _shortParticipant,\r\n        address _longParticipant,\r\n        address _shortRecipient,\r\n        address _longRecipient,\r\n        uint256 _price,\r\n        address _sourceAccount,\r\n        bytes32 _fingerprint\r\n    ) external returns (uint256 _creatorFee, uint256 _reportingFee);\r\n\r\n    function totalSupplyForMarketOutcome(IMarket _market, uint256 _outcome)\r\n        public\r\n        view\r\n        returns (uint256);\r\n\r\n    function balanceOfMarketOutcome(\r\n        IMarket _market,\r\n        uint256 _outcome,\r\n        address _account\r\n    ) public view returns (uint256);\r\n\r\n    function lowestBalanceOfMarketOutcomes(\r\n        IMarket _market,\r\n        uint256[] memory _outcomes,\r\n        address _account\r\n    ) public view returns (uint256);\r\n}\r\n\r\n\r\n\r\n\r\ncontract ICash is IERC20 {\r\n    function faucet(uint256 _amount) public returns (bool);\r\n}\r\n\r\n\r\ninterface IUniswapV2Pair {\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    function name() external pure returns (string memory);\r\n\r\n    function symbol() external pure returns (string memory);\r\n\r\n    function decimals() external pure returns (uint8);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address owner) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n\r\n    function nonces(address owner) external view returns (uint256);\r\n\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external;\r\n\r\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\r\n    event Burn(\r\n        address indexed sender,\r\n        uint256 amount0,\r\n        uint256 amount1,\r\n        address indexed to\r\n    );\r\n    event Swap(\r\n        address indexed sender,\r\n        uint256 amount0In,\r\n        uint256 amount1In,\r\n        uint256 amount0Out,\r\n        uint256 amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint256);\r\n\r\n    function factory() external view returns (address);\r\n\r\n    function token0() external view returns (address);\r\n\r\n    function token1() external view returns (address);\r\n\r\n    function getReserves()\r\n        external\r\n        view\r\n        returns (\r\n            uint112 reserve0,\r\n            uint112 reserve1,\r\n            uint32 blockTimestampLast\r\n        );\r\n\r\n    function price0CumulativeLast() external view returns (uint256);\r\n\r\n    function price1CumulativeLast() external view returns (uint256);\r\n\r\n    function kLast() external view returns (uint256);\r\n\r\n    function mint(address to) external returns (uint256 liquidity);\r\n\r\n    function burn(address to)\r\n        external\r\n        returns (uint256 amount0, uint256 amount1);\r\n\r\n    function swap(\r\n        uint256 amount0Out,\r\n        uint256 amount1Out,\r\n        address to,\r\n        bytes calldata data\r\n    ) external;\r\n\r\n    function skim(address to) external;\r\n\r\n    function sync() external;\r\n\r\n    function initialize(address, address) external;\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract IDisputeWindow is ITyped, IERC20 {\r\n    function invalidMarketsTotal() external view returns (uint256);\r\n\r\n    function validityBondTotal() external view returns (uint256);\r\n\r\n    function incorrectDesignatedReportTotal() external view returns (uint256);\r\n\r\n    function initialReportBondTotal() external view returns (uint256);\r\n\r\n    function designatedReportNoShowsTotal() external view returns (uint256);\r\n\r\n    function designatedReporterNoShowBondTotal()\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function initialize(\r\n        IAugur _augur,\r\n        IUniverse _universe,\r\n        uint256 _disputeWindowId,\r\n        bool _participationTokensEnabled,\r\n        uint256 _duration,\r\n        uint256 _startTime\r\n    ) public;\r\n\r\n    function trustedBuy(address _buyer, uint256 _attotokens)\r\n        public\r\n        returns (bool);\r\n\r\n    function getUniverse() public view returns (IUniverse);\r\n\r\n    function getReputationToken() public view returns (IReputationToken);\r\n\r\n    function getStartTime() public view returns (uint256);\r\n\r\n    function getEndTime() public view returns (uint256);\r\n\r\n    function getWindowId() public view returns (uint256);\r\n\r\n    function isActive() public view returns (bool);\r\n\r\n    function isOver() public view returns (bool);\r\n\r\n    function onMarketFinalized() public;\r\n\r\n    function redeem(address _account) public returns (bool);\r\n}\r\n\r\n\r\n\r\n\r\ncontract IDisputeCrowdsourcer is IReportingParticipant, IERC20 {\r\n    function initialize(\r\n        IAugur _augur,\r\n        IMarket market,\r\n        uint256 _size,\r\n        bytes32 _payoutDistributionHash,\r\n        uint256[] memory _payoutNumerators,\r\n        uint256 _crowdsourcerGeneration\r\n    ) public;\r\n\r\n    function contribute(\r\n        address _participant,\r\n        uint256 _amount,\r\n        bool _overload\r\n    ) public returns (uint256);\r\n\r\n    function setSize(uint256 _size) public;\r\n\r\n    function getRemainingToFill() public view returns (uint256);\r\n\r\n    function correctSize() public returns (bool);\r\n\r\n    function getCrowdsourcerGeneration() public view returns (uint256);\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n// Copyright (C) 2015 Forecast Foundation OU, full GPL notice in LICENSE\r\n\r\n// Bid / Ask actions: puts orders on the book\r\n// price is denominated by the specific market's numTicks\r\n// amount is the number of attoshares the order is for (either to buy or to sell).\r\n// price is the exact price you want to buy/sell at [which may not be the cost, for example to short a yesNo market it'll cost numTicks-price, to go long it'll cost price]\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n// CONSIDER: Is `price` the most appropriate name for the value being used? It does correspond 1:1 with the attoCASH per share, but the range might be considered unusual?\r\nlibrary Order {\r\n    using SafeMathUint256 for uint256;\r\n\r\n    enum Types {Bid, Ask}\r\n\r\n    enum TradeDirections {Long, Short}\r\n\r\n    struct Data {\r\n        // Contracts\r\n        IMarket market;\r\n        IAugur augur;\r\n        IAugurTrading augurTrading;\r\n        IShareToken shareToken;\r\n        ICash cash;\r\n        // Order\r\n        bytes32 id;\r\n        address creator;\r\n        uint256 outcome;\r\n        Order.Types orderType;\r\n        uint256 amount;\r\n        uint256 price;\r\n        uint256 sharesEscrowed;\r\n        uint256 moneyEscrowed;\r\n        bytes32 betterOrderId;\r\n        bytes32 worseOrderId;\r\n    }\r\n\r\n    function create(\r\n        IAugur _augur,\r\n        IAugurTrading _augurTrading,\r\n        address _creator,\r\n        uint256 _outcome,\r\n        Order.Types _type,\r\n        uint256 _attoshares,\r\n        uint256 _price,\r\n        IMarket _market,\r\n        bytes32 _betterOrderId,\r\n        bytes32 _worseOrderId\r\n    ) internal view returns (Data memory) {\r\n        require(\r\n            _outcome < _market.getNumberOfOutcomes(),\r\n            'Order.create: Outcome is not within market range'\r\n        );\r\n        require(_price != 0, 'Order.create: Price may not be 0');\r\n        require(\r\n            _price < _market.getNumTicks(),\r\n            'Order.create: Price is outside of market range'\r\n        );\r\n        require(_attoshares > 0, 'Order.create: Cannot use amount of 0');\r\n        require(_creator != address(0), 'Order.create: Creator is 0x0');\r\n\r\n        IShareToken _shareToken = IShareToken(_augur.lookup('ShareToken'));\r\n\r\n        return\r\n            Data({\r\n                market: _market,\r\n                augur: _augur,\r\n                augurTrading: _augurTrading,\r\n                shareToken: _shareToken,\r\n                cash: ICash(_augur.lookup('Cash')),\r\n                id: 0,\r\n                creator: _creator,\r\n                outcome: _outcome,\r\n                orderType: _type,\r\n                amount: _attoshares,\r\n                price: _price,\r\n                sharesEscrowed: 0,\r\n                moneyEscrowed: 0,\r\n                betterOrderId: _betterOrderId,\r\n                worseOrderId: _worseOrderId\r\n            });\r\n    }\r\n\r\n    //\r\n    // \"public\" functions\r\n    //\r\n\r\n    function getOrderId(Order.Data memory _orderData, IOrders _orders)\r\n        internal\r\n        view\r\n        returns (bytes32)\r\n    {\r\n        if (_orderData.id == bytes32(0)) {\r\n            bytes32 _orderId =\r\n                calculateOrderId(\r\n                    _orderData.orderType,\r\n                    _orderData.market,\r\n                    _orderData.amount,\r\n                    _orderData.price,\r\n                    _orderData.creator,\r\n                    block.number,\r\n                    _orderData.outcome,\r\n                    _orderData.moneyEscrowed,\r\n                    _orderData.sharesEscrowed\r\n                );\r\n            require(\r\n                _orders.getAmount(_orderId) == 0,\r\n                'Order.getOrderId: New order had amount. This should not be possible'\r\n            );\r\n            _orderData.id = _orderId;\r\n        }\r\n        return _orderData.id;\r\n    }\r\n\r\n    function calculateOrderId(\r\n        Order.Types _type,\r\n        IMarket _market,\r\n        uint256 _amount,\r\n        uint256 _price,\r\n        address _sender,\r\n        uint256 _blockNumber,\r\n        uint256 _outcome,\r\n        uint256 _moneyEscrowed,\r\n        uint256 _sharesEscrowed\r\n    ) internal pure returns (bytes32) {\r\n        return\r\n            sha256(\r\n                abi.encodePacked(\r\n                    _type,\r\n                    _market,\r\n                    _amount,\r\n                    _price,\r\n                    _sender,\r\n                    _blockNumber,\r\n                    _outcome,\r\n                    _moneyEscrowed,\r\n                    _sharesEscrowed\r\n                )\r\n            );\r\n    }\r\n\r\n    function getOrderTradingTypeFromMakerDirection(\r\n        Order.TradeDirections _creatorDirection\r\n    ) internal pure returns (Order.Types) {\r\n        return\r\n            (_creatorDirection == Order.TradeDirections.Long)\r\n                ? Order.Types.Bid\r\n                : Order.Types.Ask;\r\n    }\r\n\r\n    function getOrderTradingTypeFromFillerDirection(\r\n        Order.TradeDirections _fillerDirection\r\n    ) internal pure returns (Order.Types) {\r\n        return\r\n            (_fillerDirection == Order.TradeDirections.Long)\r\n                ? Order.Types.Ask\r\n                : Order.Types.Bid;\r\n    }\r\n\r\n    function saveOrder(\r\n        Order.Data memory _orderData,\r\n        bytes32 _tradeGroupId,\r\n        IOrders _orders\r\n    ) internal returns (bytes32) {\r\n        getOrderId(_orderData, _orders);\r\n        uint256[] memory _uints = new uint256[](5);\r\n        _uints[0] = _orderData.amount;\r\n        _uints[1] = _orderData.price;\r\n        _uints[2] = _orderData.outcome;\r\n        _uints[3] = _orderData.moneyEscrowed;\r\n        _uints[4] = _orderData.sharesEscrowed;\r\n        bytes32[] memory _bytes32s = new bytes32[](4);\r\n        _bytes32s[0] = _orderData.betterOrderId;\r\n        _bytes32s[1] = _orderData.worseOrderId;\r\n        _bytes32s[2] = _tradeGroupId;\r\n        _bytes32s[3] = _orderData.id;\r\n        return\r\n            _orders.saveOrder(\r\n                _uints,\r\n                _bytes32s,\r\n                _orderData.orderType,\r\n                _orderData.market,\r\n                _orderData.creator\r\n            );\r\n    }\r\n}\r\n\r\n\r\n\r\ncontract IAugur {\r\n    IUniverse public genesisUniverse;\r\n\r\n    function createChildUniverse(\r\n        bytes32 _parentPayoutDistributionHash,\r\n        uint256[] memory _parentPayoutNumerators\r\n    ) public returns (IUniverse);\r\n\r\n    function isKnownUniverse(IUniverse _universe) public view returns (bool);\r\n\r\n    function trustedCashTransfer(\r\n        address _from,\r\n        address _to,\r\n        uint256 _amount\r\n    ) public returns (bool);\r\n\r\n    function isTrustedSender(address _address) public returns (bool);\r\n\r\n    function onCategoricalMarketCreated(\r\n        uint256 _endTime,\r\n        string memory _extraInfo,\r\n        IMarket _market,\r\n        address _marketCreator,\r\n        address _designatedReporter,\r\n        uint256 _feePerCashInAttoCash,\r\n        bytes32[] memory _outcomes\r\n    ) public returns (bool);\r\n\r\n    function onYesNoMarketCreated(\r\n        uint256 _endTime,\r\n        string memory _extraInfo,\r\n        IMarket _market,\r\n        address _marketCreator,\r\n        address _designatedReporter,\r\n        uint256 _feePerCashInAttoCash\r\n    ) public returns (bool);\r\n\r\n    function onScalarMarketCreated(\r\n        uint256 _endTime,\r\n        string memory _extraInfo,\r\n        IMarket _market,\r\n        address _marketCreator,\r\n        address _designatedReporter,\r\n        uint256 _feePerCashInAttoCash,\r\n        int256[] memory _prices,\r\n        uint256 _numTicks\r\n    ) public returns (bool);\r\n\r\n    function logInitialReportSubmitted(\r\n        IUniverse _universe,\r\n        address _reporter,\r\n        address _market,\r\n        address _initialReporter,\r\n        uint256 _amountStaked,\r\n        bool _isDesignatedReporter,\r\n        uint256[] memory _payoutNumerators,\r\n        string memory _description,\r\n        uint256 _nextWindowStartTime,\r\n        uint256 _nextWindowEndTime\r\n    ) public returns (bool);\r\n\r\n    function disputeCrowdsourcerCreated(\r\n        IUniverse _universe,\r\n        address _market,\r\n        address _disputeCrowdsourcer,\r\n        uint256[] memory _payoutNumerators,\r\n        uint256 _size,\r\n        uint256 _disputeRound\r\n    ) public returns (bool);\r\n\r\n    function logDisputeCrowdsourcerContribution(\r\n        IUniverse _universe,\r\n        address _reporter,\r\n        address _market,\r\n        address _disputeCrowdsourcer,\r\n        uint256 _amountStaked,\r\n        string memory description,\r\n        uint256[] memory _payoutNumerators,\r\n        uint256 _currentStake,\r\n        uint256 _stakeRemaining,\r\n        uint256 _disputeRound\r\n    ) public returns (bool);\r\n\r\n    function logDisputeCrowdsourcerCompleted(\r\n        IUniverse _universe,\r\n        address _market,\r\n        address _disputeCrowdsourcer,\r\n        uint256[] memory _payoutNumerators,\r\n        uint256 _nextWindowStartTime,\r\n        uint256 _nextWindowEndTime,\r\n        bool _pacingOn,\r\n        uint256 _totalRepStakedInPayout,\r\n        uint256 _totalRepStakedInMarket,\r\n        uint256 _disputeRound\r\n    ) public returns (bool);\r\n\r\n    function logInitialReporterRedeemed(\r\n        IUniverse _universe,\r\n        address _reporter,\r\n        address _market,\r\n        uint256 _amountRedeemed,\r\n        uint256 _repReceived,\r\n        uint256[] memory _payoutNumerators\r\n    ) public returns (bool);\r\n\r\n    function logDisputeCrowdsourcerRedeemed(\r\n        IUniverse _universe,\r\n        address _reporter,\r\n        address _market,\r\n        uint256 _amountRedeemed,\r\n        uint256 _repReceived,\r\n        uint256[] memory _payoutNumerators\r\n    ) public returns (bool);\r\n\r\n    function logMarketFinalized(\r\n        IUniverse _universe,\r\n        uint256[] memory _winningPayoutNumerators\r\n    ) public returns (bool);\r\n\r\n    function logMarketMigrated(IMarket _market, IUniverse _originalUniverse)\r\n        public\r\n        returns (bool);\r\n\r\n    function logReportingParticipantDisavowed(\r\n        IUniverse _universe,\r\n        IMarket _market\r\n    ) public returns (bool);\r\n\r\n    function logMarketParticipantsDisavowed(IUniverse _universe)\r\n        public\r\n        returns (bool);\r\n\r\n    function logCompleteSetsPurchased(\r\n        IUniverse _universe,\r\n        IMarket _market,\r\n        address _account,\r\n        uint256 _numCompleteSets\r\n    ) public returns (bool);\r\n\r\n    function logCompleteSetsSold(\r\n        IUniverse _universe,\r\n        IMarket _market,\r\n        address _account,\r\n        uint256 _numCompleteSets,\r\n        uint256 _fees\r\n    ) public returns (bool);\r\n\r\n    function logMarketOIChanged(IUniverse _universe, IMarket _market)\r\n        public\r\n        returns (bool);\r\n\r\n    function logTradingProceedsClaimed(\r\n        IUniverse _universe,\r\n        address _sender,\r\n        address _market,\r\n        uint256 _outcome,\r\n        uint256 _numShares,\r\n        uint256 _numPayoutTokens,\r\n        uint256 _fees\r\n    ) public returns (bool);\r\n\r\n    function logUniverseForked(IMarket _forkingMarket) public returns (bool);\r\n\r\n    function logReputationTokensTransferred(\r\n        IUniverse _universe,\r\n        address _from,\r\n        address _to,\r\n        uint256 _value,\r\n        uint256 _fromBalance,\r\n        uint256 _toBalance\r\n    ) public returns (bool);\r\n\r\n    function logReputationTokensBurned(\r\n        IUniverse _universe,\r\n        address _target,\r\n        uint256 _amount,\r\n        uint256 _totalSupply,\r\n        uint256 _balance\r\n    ) public returns (bool);\r\n\r\n    function logReputationTokensMinted(\r\n        IUniverse _universe,\r\n        address _target,\r\n        uint256 _amount,\r\n        uint256 _totalSupply,\r\n        uint256 _balance\r\n    ) public returns (bool);\r\n\r\n    function logShareTokensBalanceChanged(\r\n        address _account,\r\n        IMarket _market,\r\n        uint256 _outcome,\r\n        uint256 _balance\r\n    ) public returns (bool);\r\n\r\n    function logDisputeCrowdsourcerTokensTransferred(\r\n        IUniverse _universe,\r\n        address _from,\r\n        address _to,\r\n        uint256 _value,\r\n        uint256 _fromBalance,\r\n        uint256 _toBalance\r\n    ) public returns (bool);\r\n\r\n    function logDisputeCrowdsourcerTokensBurned(\r\n        IUniverse _universe,\r\n        address _target,\r\n        uint256 _amount,\r\n        uint256 _totalSupply,\r\n        uint256 _balance\r\n    ) public returns (bool);\r\n\r\n    function logDisputeCrowdsourcerTokensMinted(\r\n        IUniverse _universe,\r\n        address _target,\r\n        uint256 _amount,\r\n        uint256 _totalSupply,\r\n        uint256 _balance\r\n    ) public returns (bool);\r\n\r\n    function logDisputeWindowCreated(\r\n        IDisputeWindow _disputeWindow,\r\n        uint256 _id,\r\n        bool _initial\r\n    ) public returns (bool);\r\n\r\n    function logParticipationTokensRedeemed(\r\n        IUniverse universe,\r\n        address _sender,\r\n        uint256 _attoParticipationTokens,\r\n        uint256 _feePayoutShare\r\n    ) public returns (bool);\r\n\r\n    function logTimestampSet(uint256 _newTimestamp) public returns (bool);\r\n\r\n    function logInitialReporterTransferred(\r\n        IUniverse _universe,\r\n        IMarket _market,\r\n        address _from,\r\n        address _to\r\n    ) public returns (bool);\r\n\r\n    function logMarketTransferred(\r\n        IUniverse _universe,\r\n        address _from,\r\n        address _to\r\n    ) public returns (bool);\r\n\r\n    function logParticipationTokensTransferred(\r\n        IUniverse _universe,\r\n        address _from,\r\n        address _to,\r\n        uint256 _value,\r\n        uint256 _fromBalance,\r\n        uint256 _toBalance\r\n    ) public returns (bool);\r\n\r\n    function logParticipationTokensBurned(\r\n        IUniverse _universe,\r\n        address _target,\r\n        uint256 _amount,\r\n        uint256 _totalSupply,\r\n        uint256 _balance\r\n    ) public returns (bool);\r\n\r\n    function logParticipationTokensMinted(\r\n        IUniverse _universe,\r\n        address _target,\r\n        uint256 _amount,\r\n        uint256 _totalSupply,\r\n        uint256 _balance\r\n    ) public returns (bool);\r\n\r\n    function logMarketRepBondTransferred(\r\n        address _universe,\r\n        address _from,\r\n        address _to\r\n    ) public returns (bool);\r\n\r\n    function logWarpSyncDataUpdated(\r\n        address _universe,\r\n        uint256 _warpSyncHash,\r\n        uint256 _marketEndTime\r\n    ) public returns (bool);\r\n\r\n    function isKnownFeeSender(address _feeSender) public view returns (bool);\r\n\r\n    function lookup(bytes32 _key) public view returns (address);\r\n\r\n    function getTimestamp() public view returns (uint256);\r\n\r\n    function getMaximumMarketEndDate() public returns (uint256);\r\n\r\n    function isKnownMarket(IMarket _market) public view returns (bool);\r\n\r\n    function derivePayoutDistributionHash(\r\n        uint256[] memory _payoutNumerators,\r\n        uint256 _numTicks,\r\n        uint256 numOutcomes\r\n    ) public view returns (bytes32);\r\n\r\n    function logValidityBondChanged(uint256 _validityBond)\r\n        public\r\n        returns (bool);\r\n\r\n    function logDesignatedReportStakeChanged(uint256 _designatedReportStake)\r\n        public\r\n        returns (bool);\r\n\r\n    function logNoShowBondChanged(uint256 _noShowBond) public returns (bool);\r\n\r\n    function logReportingFeeChanged(uint256 _reportingFee)\r\n        public\r\n        returns (bool);\r\n\r\n    function getUniverseForkIndex(IUniverse _universe)\r\n        public\r\n        view\r\n        returns (uint256);\r\n\r\n    function getMarketType(IMarket _market)\r\n        public\r\n        view\r\n        returns (IMarket.MarketType);\r\n\r\n    function getMarketOutcomes(IMarket _market)\r\n        public\r\n        view\r\n        returns (bytes32[] memory _outcomes);\r\n\r\n    ICash public cash;\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract IMarket is IOwnable {\r\n    enum MarketType {YES_NO, CATEGORICAL, SCALAR}\r\n\r\n    function initialize(\r\n        IAugur _augur,\r\n        IUniverse _universe,\r\n        uint256 _endTime,\r\n        uint256 _feePerCashInAttoCash,\r\n        IAffiliateValidator _affiliateValidator,\r\n        uint256 _affiliateFeeDivisor,\r\n        address _designatedReporterAddress,\r\n        address _creator,\r\n        uint256 _numOutcomes,\r\n        uint256 _numTicks\r\n    ) public;\r\n\r\n    function derivePayoutDistributionHash(uint256[] memory _payoutNumerators)\r\n        public\r\n        view\r\n        returns (bytes32);\r\n\r\n    function doInitialReport(\r\n        uint256[] memory _payoutNumerators,\r\n        string memory _description,\r\n        uint256 _additionalStake\r\n    ) public returns (bool);\r\n\r\n    function getUniverse() public view returns (IUniverse);\r\n\r\n    function getDisputeWindow() public view returns (IDisputeWindow);\r\n\r\n    function getNumberOfOutcomes() public view returns (uint256);\r\n\r\n    function getNumTicks() public view returns (uint256);\r\n\r\n    function getMarketCreatorSettlementFeeDivisor()\r\n        public\r\n        view\r\n        returns (uint256);\r\n\r\n    function getForkingMarket() public view returns (IMarket _market);\r\n\r\n    function getEndTime() public view returns (uint256);\r\n\r\n    function getWinningPayoutDistributionHash() public view returns (bytes32);\r\n\r\n    function getWinningPayoutNumerator(uint256 _outcome)\r\n        public\r\n        view\r\n        returns (uint256);\r\n\r\n    function getWinningReportingParticipant()\r\n        public\r\n        view\r\n        returns (IReportingParticipant);\r\n\r\n    function getReputationToken() public view returns (IV2ReputationToken);\r\n\r\n    function getFinalizationTime() public view returns (uint256);\r\n\r\n    function getInitialReporter() public view returns (IInitialReporter);\r\n\r\n    function getDesignatedReportingEndTime() public view returns (uint256);\r\n\r\n    function getValidityBondAttoCash() public view returns (uint256);\r\n\r\n    function affiliateFeeDivisor() external view returns (uint256);\r\n\r\n    function getNumParticipants() public view returns (uint256);\r\n\r\n    function getDisputePacingOn() public view returns (bool);\r\n\r\n    function deriveMarketCreatorFeeAmount(uint256 _amount)\r\n        public\r\n        view\r\n        returns (uint256);\r\n\r\n    function recordMarketCreatorFees(\r\n        uint256 _marketCreatorFees,\r\n        address _sourceAccount,\r\n        bytes32 _fingerprint\r\n    ) public returns (bool);\r\n\r\n    function isContainerForReportingParticipant(\r\n        IReportingParticipant _reportingParticipant\r\n    ) public view returns (bool);\r\n\r\n    function isFinalizedAsInvalid() public view returns (bool);\r\n\r\n    function finalize() public returns (bool);\r\n\r\n    function isFinalized() public view returns (bool);\r\n\r\n    function getOpenInterest() public view returns (uint256);\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract IUniverse {\r\n    function creationTime() external view returns (uint256);\r\n\r\n    function marketBalance(address) external view returns (uint256);\r\n\r\n    function fork() public returns (bool);\r\n\r\n    function updateForkValues() public returns (bool);\r\n\r\n    function getParentUniverse() public view returns (IUniverse);\r\n\r\n    function createChildUniverse(uint256[] memory _parentPayoutNumerators)\r\n        public\r\n        returns (IUniverse);\r\n\r\n    function getChildUniverse(bytes32 _parentPayoutDistributionHash)\r\n        public\r\n        view\r\n        returns (IUniverse);\r\n\r\n    function getReputationToken() public view returns (IV2ReputationToken);\r\n\r\n    function getForkingMarket() public view returns (IMarket);\r\n\r\n    function getForkEndTime() public view returns (uint256);\r\n\r\n    function getForkReputationGoal() public view returns (uint256);\r\n\r\n    function getParentPayoutDistributionHash() public view returns (bytes32);\r\n\r\n    function getDisputeRoundDurationInSeconds(bool _initial)\r\n        public\r\n        view\r\n        returns (uint256);\r\n\r\n    function getOrCreateDisputeWindowByTimestamp(\r\n        uint256 _timestamp,\r\n        bool _initial\r\n    ) public returns (IDisputeWindow);\r\n\r\n    function getOrCreateCurrentDisputeWindow(bool _initial)\r\n        public\r\n        returns (IDisputeWindow);\r\n\r\n    function getOrCreateNextDisputeWindow(bool _initial)\r\n        public\r\n        returns (IDisputeWindow);\r\n\r\n    function getOrCreatePreviousDisputeWindow(bool _initial)\r\n        public\r\n        returns (IDisputeWindow);\r\n\r\n    function getOpenInterestInAttoCash() public view returns (uint256);\r\n\r\n    function getTargetRepMarketCapInAttoCash() public view returns (uint256);\r\n\r\n    function getOrCacheValidityBond() public returns (uint256);\r\n\r\n    function getOrCacheDesignatedReportStake() public returns (uint256);\r\n\r\n    function getOrCacheDesignatedReportNoShowBond() public returns (uint256);\r\n\r\n    function getOrCacheMarketRepBond() public returns (uint256);\r\n\r\n    function getOrCacheReportingFeeDivisor() public returns (uint256);\r\n\r\n    function getDisputeThresholdForFork() public view returns (uint256);\r\n\r\n    function getDisputeThresholdForDisputePacing()\r\n        public\r\n        view\r\n        returns (uint256);\r\n\r\n    function getInitialReportMinValue() public view returns (uint256);\r\n\r\n    function getPayoutNumerators() public view returns (uint256[] memory);\r\n\r\n    function getReportingFeeDivisor() public view returns (uint256);\r\n\r\n    function getPayoutNumerator(uint256 _outcome) public view returns (uint256);\r\n\r\n    function getWinningChildPayoutNumerator(uint256 _outcome)\r\n        public\r\n        view\r\n        returns (uint256);\r\n\r\n    function isOpenInterestCash(address) public view returns (bool);\r\n\r\n    function isForkingMarket() public view returns (bool);\r\n\r\n    function getCurrentDisputeWindow(bool _initial)\r\n        public\r\n        view\r\n        returns (IDisputeWindow);\r\n\r\n    function getDisputeWindowStartTimeAndDuration(\r\n        uint256 _timestamp,\r\n        bool _initial\r\n    ) public view returns (uint256, uint256);\r\n\r\n    function isParentOf(IUniverse _shadyChild) public view returns (bool);\r\n\r\n    function updateTentativeWinningChildUniverse(\r\n        bytes32 _parentPayoutDistributionHash\r\n    ) public returns (bool);\r\n\r\n    function isContainerForDisputeWindow(IDisputeWindow _shadyTarget)\r\n        public\r\n        view\r\n        returns (bool);\r\n\r\n    function isContainerForMarket(IMarket _shadyTarget)\r\n        public\r\n        view\r\n        returns (bool);\r\n\r\n    function isContainerForReportingParticipant(\r\n        IReportingParticipant _reportingParticipant\r\n    ) public view returns (bool);\r\n\r\n    function migrateMarketOut(IUniverse _destinationUniverse)\r\n        public\r\n        returns (bool);\r\n\r\n    function migrateMarketIn(\r\n        IMarket _market,\r\n        uint256 _cashBalance,\r\n        uint256 _marketOI\r\n    ) public returns (bool);\r\n\r\n    function decrementOpenInterest(uint256 _amount) public returns (bool);\r\n\r\n    function decrementOpenInterestFromMarket(IMarket _market)\r\n        public\r\n        returns (bool);\r\n\r\n    function incrementOpenInterest(uint256 _amount) public returns (bool);\r\n\r\n    function getWinningChildUniverse() public view returns (IUniverse);\r\n\r\n    function isForking() public view returns (bool);\r\n\r\n    function deposit(\r\n        address _sender,\r\n        uint256 _amount,\r\n        address _market\r\n    ) public returns (bool);\r\n\r\n    function withdraw(\r\n        address _recipient,\r\n        uint256 _amount,\r\n        address _market\r\n    ) public returns (bool);\r\n\r\n    function pokeRepMarketCapInAttoCash() public returns (uint256);\r\n\r\n    function createScalarMarket(\r\n        uint256 _endTime,\r\n        uint256 _feePerCashInAttoCash,\r\n        IAffiliateValidator _affiliateValidator,\r\n        uint256 _affiliateFeeDivisor,\r\n        address _designatedReporterAddress,\r\n        int256[] memory _prices,\r\n        uint256 _numTicks,\r\n        string memory _extraInfo\r\n    ) public returns (IMarket _newMarket);\r\n\r\n    function createYesNoMarket(\r\n        uint256 _endTime,\r\n        uint256 _feePerCashInAttoCash,\r\n        IAffiliateValidator _affiliateValidator,\r\n        uint256 _affiliateFeeDivisor,\r\n        address _designatedReporterAddress,\r\n        string memory _extraInfo\r\n    ) public returns (IMarket _newMarket);\r\n\r\n    function createCategoricalMarket(\r\n        uint256 _endTime,\r\n        uint256 _feePerCashInAttoCash,\r\n        IAffiliateValidator _affiliateValidator,\r\n        uint256 _affiliateFeeDivisor,\r\n        address _designatedReporterAddress,\r\n        bytes32[] memory _outcomes,\r\n        string memory _extraInfo\r\n    ) public returns (IMarket _newMarket);\r\n\r\n    function runPeriodicals() external returns (bool);\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract IWarpSync {\r\n    function markets(address _universe) external returns (IMarket);\r\n    function notifyMarketFinalized() public;\r\n}\r\n\r\n\r\n\r\n\r\n\r\ncontract IDisputeCrowdsourcerFactory {\r\n    function createDisputeCrowdsourcer(IAugur _augur, uint256 _size, bytes32 _payoutDistributionHash, uint256[] memory _payoutNumerators, uint256 _crowdsourcerGeneration) public returns (IDisputeCrowdsourcer);\r\n}\r\n\r\n\r\n\r\n\r\ncontract IAffiliates {\r\n    function setFingerprint(bytes32 _fingerprint) external;\r\n\r\n    function setReferrer(address _referrer) external;\r\n\r\n    function getAccountFingerprint(address _account) external returns (bytes32);\r\n\r\n    function getReferrer(address _account) external returns (address);\r\n\r\n    function getAndValidateReferrer(\r\n        address _account,\r\n        IAffiliateValidator affiliateValidator\r\n    ) external returns (address);\r\n\r\n    function affiliateValidators(address _affiliateValidator)\r\n        external\r\n        returns (bool);\r\n}\r\n\r\n\r\n\r\ncontract Initializable {\r\n    bool private initialized = false;\r\n\r\n    modifier beforeInitialized {\r\n        require(!initialized);\r\n        _;\r\n    }\r\n\r\n    function endInitialization() internal beforeInitialized {\r\n        initialized = true;\r\n    }\r\n\r\n    function getInitialized() public view returns (bool) {\r\n        return initialized;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable is IOwnable {\r\n    address internal owner;\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function getOwner() public view returns (address) {\r\n        return owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param _newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address _newOwner)\r\n        public\r\n        onlyOwner\r\n        returns (bool)\r\n    {\r\n        require(_newOwner != address(0));\r\n        onTransferOwnership(owner, _newOwner);\r\n        owner = _newOwner;\r\n        return true;\r\n    }\r\n\r\n    // Subclasses of this token may want to send additional logs through the centralized Augur log emitter contract\r\n    function onTransferOwnership(address, address) internal;\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Initial Reporter Factory\r\n * @notice A Factory contract to create Initial Reporter delegate contracts\r\n * @dev Should not be used directly. Only intended to be used by Market contracts\r\n */\r\ncontract InitialReporterFactory is CloneFactory {\r\n    function createInitialReporter(IAugur _augur, address _designatedReporter) public returns (IInitialReporter) {\r\n        IMarket _market = IMarket(msg.sender);\r\n        IInitialReporter _initialReporter = IInitialReporter(createClone(_augur.lookup(\"InitialReporter\")));\r\n        _initialReporter.initialize(_augur, _market, _designatedReporter);\r\n        return _initialReporter;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\nlibrary Reporting {\r\n    uint256 private constant DESIGNATED_REPORTING_DURATION_SECONDS = 1 days;\r\n    uint256 private constant DISPUTE_ROUND_DURATION_SECONDS = 7 days;\r\n    uint256 private constant INITIAL_DISPUTE_ROUND_DURATION_SECONDS = 1 days;\r\n    uint256 private constant DISPUTE_WINDOW_BUFFER_SECONDS = 1 hours;\r\n    uint256 private constant FORK_DURATION_SECONDS = 60 days;\r\n\r\n    uint256 private constant BASE_MARKET_DURATION_MAXIMUM = 30 days; // A market of 30 day length can always be created\r\n    uint256 private constant UPGRADE_CADENCE = 365 days;\r\n    uint256 private constant INITIAL_UPGRADE_TIMESTAMP = 1627776000000; // Forever in the future\r\n\r\n    uint256 private constant INITIAL_REP_SUPPLY = 11 * 10 ** 6 * 10 ** 18; // 11 Million REP\r\n\r\n    uint256 private constant AFFILIATE_SOURCE_CUT_DIVISOR = 5; // The trader gets 20% of the affiliate fee when an affiliate fee is taken\r\n\r\n    uint256 private constant DEFAULT_VALIDITY_BOND = 10 ether; // 10 Cash (Dai)\r\n    uint256 private constant VALIDITY_BOND_FLOOR = 10 ether; // 10 Cash (Dai)\r\n    uint256 private constant DEFAULT_REPORTING_FEE_DIVISOR = 10000; // .01% fees\r\n    uint256 private constant MAXIMUM_REPORTING_FEE_DIVISOR = 10000; // Minimum .01% fees\r\n    uint256 private constant MINIMUM_REPORTING_FEE_DIVISOR = 3; // Maximum 33.3~% fees. Note than anything less than a value of 2 here will likely result in bugs such as divide by 0 cases.\r\n\r\n    uint256 private constant TARGET_INVALID_MARKETS_DIVISOR = 100; // 1% of markets are expected to be invalid\r\n    uint256 private constant TARGET_INCORRECT_DESIGNATED_REPORT_MARKETS_DIVISOR = 100; // 1% of markets are expected to have an incorrect designate report\r\n    uint256 private constant TARGET_DESIGNATED_REPORT_NO_SHOWS_DIVISOR = 20; // 5% of markets are expected to have a no show\r\n    uint256 private constant TARGET_REP_MARKET_CAP_MULTIPLIER = 5; // We multiply and divide by constants since we may want to multiply by a fractional amount\r\n\r\n    uint256 private constant FORK_THRESHOLD_DIVISOR = 40; // 2.5% of the total REP supply being filled in a single dispute bond will trigger a fork\r\n    uint256 private constant MAXIMUM_DISPUTE_ROUNDS = 20; // We ensure that after 20 rounds of disputes a fork will occur\r\n    uint256 private constant MINIMUM_SLOW_ROUNDS = 8; // We ensure that at least 8 dispute rounds take DISPUTE_ROUND_DURATION_SECONDS+ seconds to complete until the next round begins\r\n\r\n    function getDesignatedReportingDurationSeconds() internal pure returns (uint256) { return DESIGNATED_REPORTING_DURATION_SECONDS; }\r\n    function getInitialDisputeRoundDurationSeconds() internal pure returns (uint256) { return INITIAL_DISPUTE_ROUND_DURATION_SECONDS; }\r\n    function getDisputeWindowBufferSeconds() internal pure returns (uint256) { return DISPUTE_WINDOW_BUFFER_SECONDS; }\r\n    function getDisputeRoundDurationSeconds() internal pure returns (uint256) { return DISPUTE_ROUND_DURATION_SECONDS; }\r\n    function getForkDurationSeconds() internal pure returns (uint256) { return FORK_DURATION_SECONDS; }\r\n    function getBaseMarketDurationMaximum() internal pure returns (uint256) { return BASE_MARKET_DURATION_MAXIMUM; }\r\n    function getUpgradeCadence() internal pure returns (uint256) { return UPGRADE_CADENCE; }\r\n    function getInitialUpgradeTimestamp() internal pure returns (uint256) { return INITIAL_UPGRADE_TIMESTAMP; }\r\n    function getDefaultValidityBond() internal pure returns (uint256) { return DEFAULT_VALIDITY_BOND; }\r\n    function getValidityBondFloor() internal pure returns (uint256) { return VALIDITY_BOND_FLOOR; }\r\n    function getTargetInvalidMarketsDivisor() internal pure returns (uint256) { return TARGET_INVALID_MARKETS_DIVISOR; }\r\n    function getTargetIncorrectDesignatedReportMarketsDivisor() internal pure returns (uint256) { return TARGET_INCORRECT_DESIGNATED_REPORT_MARKETS_DIVISOR; }\r\n    function getTargetDesignatedReportNoShowsDivisor() internal pure returns (uint256) { return TARGET_DESIGNATED_REPORT_NO_SHOWS_DIVISOR; }\r\n    function getTargetRepMarketCapMultiplier() internal pure returns (uint256) { return TARGET_REP_MARKET_CAP_MULTIPLIER; }\r\n    function getMaximumReportingFeeDivisor() internal pure returns (uint256) { return MAXIMUM_REPORTING_FEE_DIVISOR; }\r\n    function getMinimumReportingFeeDivisor() internal pure returns (uint256) { return MINIMUM_REPORTING_FEE_DIVISOR; }\r\n    function getDefaultReportingFeeDivisor() internal pure returns (uint256) { return DEFAULT_REPORTING_FEE_DIVISOR; }\r\n    function getInitialREPSupply() internal pure returns (uint256) { return INITIAL_REP_SUPPLY; }\r\n    function getAffiliateSourceCutDivisor() internal pure returns (uint256) { return AFFILIATE_SOURCE_CUT_DIVISOR; }\r\n    function getForkThresholdDivisor() internal pure returns (uint256) { return FORK_THRESHOLD_DIVISOR; }\r\n    function getMaximumDisputeRounds() internal pure returns (uint256) { return MAXIMUM_DISPUTE_ROUNDS; }\r\n    function getMinimumSlowRounds() internal pure returns (uint256) { return MINIMUM_SLOW_ROUNDS; }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Market\r\n * @notice The contract which encapsulates event data and payout resolution for the event\r\n */\r\ncontract Market is Initializable, Ownable, IMarket {\r\n    using SafeMathUint256 for uint256;\r\n\r\n    // Constants\r\n    uint256 private constant MAX_APPROVAL_AMOUNT = 2 ** 256 - 1;\r\n    address private constant NULL_ADDRESS = address(0);\r\n\r\n    // Contract Refs\r\n    IUniverse private universe;\r\n    IDisputeWindow private disputeWindow;\r\n    IAugur public augur;\r\n    IWarpSync public warpSync;\r\n    IShareToken public shareToken;\r\n    IAffiliateValidator affiliateValidator;\r\n    IAffiliates affiliates;\r\n    ICash public cash;\r\n\r\n    // Attributes\r\n    uint256 private numTicks;\r\n    uint256 private feeDivisor;\r\n    uint256 public affiliateFeeDivisor;\r\n    uint256 private endTime;\r\n    uint256 private numOutcomes;\r\n    bytes32 private winningPayoutDistributionHash;\r\n    uint256 public validityBondAttoCash;\r\n    uint256 private finalizationTime;\r\n    uint256 public repBond;\r\n    bool private disputePacingOn;\r\n    address public repBondOwner;\r\n    uint256 public marketCreatorFeesAttoCash;\r\n    IDisputeCrowdsourcer public preemptiveDisputeCrowdsourcer;\r\n\r\n    // Collections\r\n    IReportingParticipant[] public participants;\r\n\r\n    mapping(bytes32 => address) public crowdsourcers;\r\n    uint256 public crowdsourcerGeneration;\r\n\r\n    function initialize(IAugur _augur, IUniverse _universe, uint256 _endTime, uint256 _feePerCashInAttoCash, IAffiliateValidator _affiliateValidator, uint256 _affiliateFeeDivisor, address _designatedReporterAddress, address _creator, uint256 _numOutcomes, uint256 _numTicks) public beforeInitialized {\r\n        endInitialization();\r\n        augur = _augur;\r\n        require(msg.sender == _augur.lookup(\"MarketFactory\"));\r\n        _numOutcomes += 1; // The INVALID outcome is always first\r\n        universe = _universe;\r\n        warpSync = IWarpSync(_augur.lookup(\"WarpSync\"));\r\n        require(warpSync != IWarpSync(0));\r\n        affiliateValidator = _affiliateValidator;\r\n        affiliates = IAffiliates(_augur.lookup(\"Affiliates\"));\r\n        require(affiliates != IAffiliates(0));\r\n        require(affiliateValidator == IAffiliateValidator(0) || affiliates.affiliateValidators(address(_affiliateValidator)));\r\n        cash = ICash(augur.lookup(\"Cash\"));\r\n        require(cash != ICash(0));\r\n        owner = _creator;\r\n        repBondOwner = owner;\r\n        cash.approve(address(_augur), MAX_APPROVAL_AMOUNT);\r\n        assessFees();\r\n        endTime = _endTime;\r\n        numOutcomes = _numOutcomes;\r\n        numTicks = _numTicks;\r\n        feeDivisor = _feePerCashInAttoCash == 0 ? 0 : 1 ether / _feePerCashInAttoCash;\r\n        affiliateFeeDivisor = _affiliateFeeDivisor;\r\n        InitialReporterFactory _initialReporterFactory = InitialReporterFactory(_augur.lookup(\"InitialReporterFactory\"));\r\n        participants.push(_initialReporterFactory.createInitialReporter(_augur, _designatedReporterAddress));\r\n        shareToken = IShareToken(_augur.lookup(\"ShareToken\"));\r\n        require(shareToken != IShareToken(0));\r\n    }\r\n\r\n    function assessFees() private {\r\n        repBond = universe.getOrCacheMarketRepBond();\r\n        require(getReputationToken().balanceOf(address(this)) >= repBond);\r\n        if (owner != address(warpSync)) {\r\n            validityBondAttoCash = cash.balanceOf(address(this));\r\n            require(validityBondAttoCash >= universe.getOrCacheValidityBond());\r\n            universe.deposit(address(this), validityBondAttoCash, address(this));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Do the initial report for the market.\r\n     * @param _payoutNumerators An array indicating the payout for each market outcome\r\n     * @param _description Any additional information or justification for this report\r\n     * @param _additionalStake Additional optional REP to stake in anticipation of a dispute. This REP will be held in a bond that only activates if the report is disputed\r\n     * @return Bool True\r\n     */\r\n    function doInitialReport(uint256[] memory _payoutNumerators, string memory _description, uint256 _additionalStake) public returns (bool) {\r\n        doInitialReportInternal(msg.sender, _payoutNumerators, _description);\r\n        if (_additionalStake > 0) {\r\n            contributeToTentativeInternal(msg.sender, _payoutNumerators, _additionalStake, _description);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function doInitialReportInternal(address _reporter, uint256[] memory _payoutNumerators, string memory _description) private {\r\n        require(!universe.isForking());\r\n        IInitialReporter _initialReporter = getInitialReporter();\r\n        uint256 _timestamp = augur.getTimestamp();\r\n        require(_timestamp > endTime);\r\n        uint256 _initialReportStake = distributeInitialReportingRep(_reporter, _initialReporter);\r\n        // The derive call will validate that an Invalid report is entirely paid out on the Invalid outcome\r\n        bytes32 _payoutDistributionHash = derivePayoutDistributionHash(_payoutNumerators);\r\n        disputeWindow = universe.getOrCreateNextDisputeWindow(true);\r\n        _initialReporter.report(_reporter, _payoutDistributionHash, _payoutNumerators, _initialReportStake);\r\n        augur.logInitialReportSubmitted(universe, _reporter, address(this), address(_initialReporter), _initialReportStake, _initialReporter.designatedReporterShowed(), _payoutNumerators, _description, disputeWindow.getStartTime(), disputeWindow.getEndTime());\r\n    }\r\n\r\n    function distributeInitialReportingRep(address _reporter, IInitialReporter _initialReporter) private returns (uint256) {\r\n        IV2ReputationToken _reputationToken = getReputationToken();\r\n        uint256 _initialReportStake = repBond;\r\n        repBond = 0;\r\n        // If the designated reporter showed up and is not also the rep bond owner return the rep bond to the bond owner. Otherwise it will be used as stake in the first report.\r\n        if (_reporter == _initialReporter.getDesignatedReporter() && _reporter != repBondOwner) {\r\n            require(_reputationToken.transfer(repBondOwner, _initialReportStake));\r\n            _reputationToken.trustedMarketTransfer(_reporter, address(_initialReporter), _initialReportStake);\r\n        } else {\r\n            require(_reputationToken.transfer(address(_initialReporter), _initialReportStake));\r\n        }\r\n        return _initialReportStake;\r\n    }\r\n\r\n    /**\r\n     * @notice Contribute REP to the tentative winning outcome in anticipation of a dispute\r\n     * @dev This will escrow REP in a bond which will be active immediately if the tentative outcome is successfully disputed.\r\n     * @param _payoutNumerators An array indicating the payout for each market outcome\r\n     * @param _amount The amount of REP to contribute\r\n     * @param _description Any additional information or justification for this dispute\r\n     * @return Bool True\r\n     */\r\n    function contributeToTentative(uint256[] memory _payoutNumerators, uint256 _amount, string memory _description) public returns (bool) {\r\n        contributeToTentativeInternal(msg.sender, _payoutNumerators, _amount, _description);\r\n        return true;\r\n    }\r\n\r\n    function contributeToTentativeInternal(address _sender, uint256[] memory _payoutNumerators, uint256 _amount, string memory _description) private {\r\n        require(!disputePacingOn);\r\n        // The derive call will validate that an Invalid report is entirely paid out on the Invalid outcome\r\n        bytes32 _payoutDistributionHash = derivePayoutDistributionHash(_payoutNumerators);\r\n        require(_payoutDistributionHash == getWinningReportingParticipant().getPayoutDistributionHash());\r\n        internalContribute(_sender, _payoutDistributionHash, _payoutNumerators, _amount, true, _description);\r\n    }\r\n\r\n    /**\r\n     * @notice Contribute REP to a payout other than the tenative winning outcome in order to dispute it\r\n     * @param _payoutNumerators An array indicating the payout for each market outcome\r\n     * @param _amount The amount of REP to contribute\r\n     * @param _description Any additional information or justification for this dispute\r\n     * @return Bool True\r\n     */\r\n    function contribute(uint256[] memory _payoutNumerators, uint256 _amount, string memory _description) public returns (bool) {\r\n        // The derive call will validate that an Invalid report is entirely paid out on the Invalid outcome\r\n        bytes32 _payoutDistributionHash = derivePayoutDistributionHash(_payoutNumerators);\r\n        require(_payoutDistributionHash != getWinningReportingParticipant().getPayoutDistributionHash());\r\n        internalContribute(msg.sender, _payoutDistributionHash, _payoutNumerators, _amount, false, _description);\r\n        return true;\r\n    }\r\n\r\n    function internalContribute(address _contributor, bytes32 _payoutDistributionHash, uint256[] memory _payoutNumerators, uint256 _amount, bool _overload, string memory _description) internal {\r\n        if (disputePacingOn) {\r\n            require(disputeWindow.isActive());\r\n        } else {\r\n            require(!disputeWindow.isOver());\r\n        }\r\n        // This will require that the universe is not forking\r\n        universe.updateForkValues();\r\n        IDisputeCrowdsourcer _crowdsourcer = getOrCreateDisputeCrowdsourcer(_payoutDistributionHash, _payoutNumerators, _overload);\r\n        uint256 _actualAmount = _crowdsourcer.contribute(_contributor, _amount, _overload);\r\n        uint256 _amountRemainingToFill = _overload ? 0 : _crowdsourcer.getRemainingToFill();\r\n        augur.logDisputeCrowdsourcerContribution(universe, _contributor, address(this), address(_crowdsourcer), _actualAmount, _description, _payoutNumerators, _crowdsourcer.getStake(), _amountRemainingToFill, getNumParticipants());\r\n        if (!_overload) {\r\n            if (_amountRemainingToFill == 0) {\r\n                finishedCrowdsourcingDisputeBond(_crowdsourcer);\r\n            } else {\r\n                require(_amountRemainingToFill >= getInitialReporter().getSize());\r\n            }\r\n        }\r\n    }\r\n\r\n    function finishedCrowdsourcingDisputeBond(IDisputeCrowdsourcer _crowdsourcer) private {\r\n        correctLastParticipantSize();\r\n        participants.push(_crowdsourcer);\r\n        clearCrowdsourcers(); // disavow other crowdsourcers\r\n        uint256 _crowdsourcerSize = IDisputeCrowdsourcer(_crowdsourcer).getSize();\r\n        if (_crowdsourcerSize >= universe.getDisputeThresholdForFork()) {\r\n            universe.fork();\r\n        } else {\r\n            if (_crowdsourcerSize >= universe.getDisputeThresholdForDisputePacing()) {\r\n                disputePacingOn = true;\r\n            }\r\n            disputeWindow = universe.getOrCreateNextDisputeWindow(false);\r\n        }\r\n        augur.logDisputeCrowdsourcerCompleted(\r\n            universe,\r\n            address(this),\r\n            address(_crowdsourcer),\r\n            _crowdsourcer.getPayoutNumerators(),\r\n            disputeWindow.getStartTime(),\r\n            disputeWindow.getEndTime(),\r\n            disputePacingOn,\r\n            getStakeInOutcome(_crowdsourcer.getPayoutDistributionHash()),\r\n            getParticipantStake(),\r\n            participants.length);\r\n        if (preemptiveDisputeCrowdsourcer != IDisputeCrowdsourcer(0)) {\r\n            IDisputeCrowdsourcer _newCrowdsourcer = preemptiveDisputeCrowdsourcer;\r\n            preemptiveDisputeCrowdsourcer = IDisputeCrowdsourcer(0);\r\n            bytes32 _payoutDistributionHash = _newCrowdsourcer.getPayoutDistributionHash();\r\n            // The size of any dispute bond should be (2 * ALL STAKE) - (3 * STAKE IN OUTCOME)\r\n            uint256 _correctSize = getParticipantStake().mul(2).sub(getStakeInOutcome(_payoutDistributionHash).mul(3));\r\n            _newCrowdsourcer.setSize(_correctSize);\r\n            if (_newCrowdsourcer.getStake() >= _correctSize) {\r\n                finishedCrowdsourcingDisputeBond(_newCrowdsourcer);\r\n            } else {\r\n                crowdsourcers[_payoutDistributionHash] = address(_newCrowdsourcer);\r\n            }\r\n        }\r\n    }\r\n\r\n    function correctLastParticipantSize() private {\r\n        // A dispute has occured if there is more than one completed reporting participant\r\n        if (participants.length > 1) {\r\n            IDisputeCrowdsourcer(address(getWinningReportingParticipant())).correctSize();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Finalize a market\r\n     * @return Bool True\r\n     */\r\n    function finalize() public returns (bool) {\r\n        require(!isFinalized());\r\n        uint256[] memory _winningPayoutNumerators;\r\n        if (isForkingMarket()) {\r\n            IUniverse _winningUniverse = universe.getWinningChildUniverse();\r\n            winningPayoutDistributionHash = _winningUniverse.getParentPayoutDistributionHash();\r\n            _winningPayoutNumerators = _winningUniverse.getPayoutNumerators();\r\n        } else {\r\n            require(disputeWindow.isOver());\r\n            require(!universe.isForking());\r\n            IReportingParticipant _reportingParticipant = getWinningReportingParticipant();\r\n            winningPayoutDistributionHash = _reportingParticipant.getPayoutDistributionHash();\r\n            _winningPayoutNumerators = _reportingParticipant.getPayoutNumerators();\r\n            warpSync.notifyMarketFinalized();\r\n            // Make sure the dispute window for which we record finalization is the standard cadence window and not an initial dispute window\r\n            disputeWindow = universe.getOrCreatePreviousDisputeWindow(false);\r\n            disputeWindow.onMarketFinalized();\r\n            universe.decrementOpenInterestFromMarket(this);\r\n            redistributeLosingReputation();\r\n        }\r\n        finalizationTime = augur.getTimestamp();\r\n        distributeValidityBondAndMarketCreatorFees();\r\n        augur.logMarketFinalized(universe, _winningPayoutNumerators);\r\n        return true;\r\n    }\r\n\r\n    function redistributeLosingReputation() private {\r\n        // If no disputes occurred early exit\r\n        if (participants.length == 1) {\r\n            return;\r\n        }\r\n\r\n        IReportingParticipant _reportingParticipant;\r\n\r\n        // Initial pass is to liquidate losers so we have sufficient REP to pay the winners. Participants is implicitly bounded by the floor of the initial report REP cost to be no more than 21\r\n        for (uint256 i = 0; i < participants.length; i++) {\r\n            _reportingParticipant = participants[i];\r\n            if (_reportingParticipant.getPayoutDistributionHash() != winningPayoutDistributionHash) {\r\n                _reportingParticipant.liquidateLosing();\r\n            }\r\n        }\r\n\r\n        IV2ReputationToken _reputationToken = getReputationToken();\r\n        // We burn 20% of the REP to prevent griefing attacks which rely on getting back lost REP\r\n        _reputationToken.burnForMarket(_reputationToken.balanceOf(address(this)) / 5);\r\n\r\n        // Now redistribute REP. Participants is implicitly bounded by the floor of the initial report REP cost to be no more than 21.\r\n        for (uint256 j = 0; j < participants.length; j++) {\r\n            _reportingParticipant = participants[j];\r\n            if (_reportingParticipant.getPayoutDistributionHash() == winningPayoutDistributionHash) {\r\n                // The last participant's owed REP will not actually be 40% ROI in the event it was created through pre-emptive contributions. We just give them all the remaining non burn REP\r\n                uint256 amountToTransfer = j == participants.length - 1 ? _reputationToken.balanceOf(address(this)) : _reportingParticipant.getSize().mul(2) / 5;\r\n                require(_reputationToken.transfer(address(_reportingParticipant), amountToTransfer));\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @return The amount any settlement proceeds are divided by in order to calculate the market creator fee portion\r\n     */\r\n    function getMarketCreatorSettlementFeeDivisor() public view returns (uint256) {\r\n        return feeDivisor;\r\n    }\r\n\r\n    /**\r\n     * @param _amount The total settlement proceeds of a trade or claim\r\n     * @return The amount of fees the market creator will receive\r\n     */\r\n    function deriveMarketCreatorFeeAmount(uint256 _amount) public view returns (uint256) {\r\n        return feeDivisor == 0 ? 0 : _amount / feeDivisor;\r\n    }\r\n\r\n    function recordMarketCreatorFees(uint256 _marketCreatorFees, address _sourceAccount, bytes32 _fingerprint) public returns (bool) {\r\n        require(augur.isKnownFeeSender(msg.sender));\r\n\r\n        address _affiliateAddress = affiliates.getAndValidateReferrer(_sourceAccount, affiliateValidator);\r\n        bytes32 _affiliateFingerprint = affiliates.getAccountFingerprint(_affiliateAddress);\r\n        if (_fingerprint == _affiliateFingerprint) {\r\n            // don't let affiliates refer themselves\r\n            _affiliateAddress = address(0);\r\n        }\r\n\r\n        if (_affiliateAddress != NULL_ADDRESS && affiliateFeeDivisor != 0) {\r\n            uint256 _totalAffiliateFees = _marketCreatorFees / affiliateFeeDivisor;\r\n            uint256 _sourceCut = _totalAffiliateFees / Reporting.getAffiliateSourceCutDivisor();\r\n            uint256 _affiliateFees = _totalAffiliateFees.sub(_sourceCut);\r\n            universe.withdraw(_sourceAccount, _sourceCut, address(this));\r\n            distributeAffiliateFees(_affiliateAddress, _affiliateFees);\r\n            _marketCreatorFees = _marketCreatorFees.sub(_totalAffiliateFees);\r\n        }\r\n\r\n        marketCreatorFeesAttoCash = marketCreatorFeesAttoCash.add(_marketCreatorFees);\r\n\r\n        if (isFinalized()) {\r\n            distributeMarketCreatorFees();\r\n        }\r\n    }\r\n\r\n    function distributeValidityBondAndMarketCreatorFees() private {\r\n        // If the market resolved to invalid the bond gets sent to the dispute window. Otherwise it gets returned to the market creator.\r\n        marketCreatorFeesAttoCash = validityBondAttoCash.add(marketCreatorFeesAttoCash);\r\n        distributeMarketCreatorFees();\r\n    }\r\n\r\n    function distributeMarketCreatorFees() private {\r\n        uint256 _marketCreatorFeesAttoCash = marketCreatorFeesAttoCash;\r\n        marketCreatorFeesAttoCash = 0;\r\n        if (!isFinalizedAsInvalid()) {\r\n            universe.withdraw(owner, _marketCreatorFeesAttoCash, address(this));\r\n        } else {\r\n            universe.withdraw(address(universe.getOrCreateNextDisputeWindow(false)), _marketCreatorFeesAttoCash, address(this));\r\n        }\r\n    }\r\n\r\n    function distributeAffiliateFees(address _affiliate, uint256 _affiliateBalance) private returns (bool) {\r\n        if (_affiliateBalance == 0) {\r\n            return true;\r\n        }\r\n        if (isFinalized() && isFinalizedAsInvalid()) {\r\n            universe.withdraw(address(universe.getOrCreateNextDisputeWindow(false)), _affiliateBalance, address(this));\r\n        } else {\r\n            universe.withdraw(_affiliate, _affiliateBalance, address(this));\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function getOrCreateDisputeCrowdsourcer(bytes32 _payoutDistributionHash, uint256[] memory _payoutNumerators, bool _overload) private returns (IDisputeCrowdsourcer) {\r\n        IDisputeCrowdsourcer _crowdsourcer = _overload ? preemptiveDisputeCrowdsourcer : IDisputeCrowdsourcer(getCrowdsourcer(_payoutDistributionHash));\r\n        if (_crowdsourcer == IDisputeCrowdsourcer(0)) {\r\n            IDisputeCrowdsourcerFactory _disputeCrowdsourcerFactory = IDisputeCrowdsourcerFactory(augur.lookup(\"DisputeCrowdsourcerFactory\"));\r\n            uint256 _participantStake = getParticipantStake();\r\n            if (_overload) {\r\n                // The stake of a dispute bond is (2 * ALL STAKE) - (3 * STAKE IN OUTCOME)\r\n                _participantStake = _participantStake.add(_participantStake.mul(2).sub(getHighestNonTentativeParticipantStake().mul(3)));\r\n            }\r\n            uint256 _size = _participantStake.mul(2).sub(getStakeInOutcome(_payoutDistributionHash).mul(3));\r\n            uint256 _crowdsourcerGeneration = crowdsourcerGeneration;\r\n            if (_overload) {\r\n                // If the preemptive crowdsourcer is used, it will always enter at the next generation\r\n                _crowdsourcerGeneration += 1;\r\n            }\r\n            _crowdsourcer = _disputeCrowdsourcerFactory.createDisputeCrowdsourcer(augur, _size, _payoutDistributionHash, _payoutNumerators, _crowdsourcerGeneration);\r\n            if (!_overload) {\r\n                crowdsourcers[_payoutDistributionHash] = address(_crowdsourcer);\r\n            } else {\r\n                preemptiveDisputeCrowdsourcer = _crowdsourcer;\r\n            }\r\n            augur.disputeCrowdsourcerCreated(universe, address(this), address(_crowdsourcer), _payoutNumerators, _size, getNumParticipants());\r\n        }\r\n        return _crowdsourcer;\r\n    }\r\n\r\n    /**\r\n     * @notice Migrates the market through a fork into the winning Universe\r\n     * @dev This will extract a new REP no show bond from whoever calls this and if the market is in the reporting phase will require a report be made as well\r\n     * @param _payoutNumerators An array indicating the payout for each market outcome\r\n     * @param _description Any additional information or justification for this report\r\n     * @return Bool True\r\n     */\r\n    function migrateThroughOneFork(uint256[] memory _payoutNumerators, string memory _description) public returns (bool) {\r\n        // only proceed if the forking market is finalized\r\n        IMarket _forkingMarket = universe.getForkingMarket();\r\n        require(_forkingMarket.isFinalized());\r\n        require(!isFinalized());\r\n        require(this != warpSync.markets(address(universe)));\r\n\r\n        disavowCrowdsourcers();\r\n\r\n        bytes32 _winningForkPayoutDistributionHash = _forkingMarket.getWinningPayoutDistributionHash();\r\n        IUniverse _destinationUniverse = universe.getChildUniverse(_winningForkPayoutDistributionHash);\r\n\r\n        // follow the forking market to its universe\r\n        if (disputeWindow != IDisputeWindow(0)) {\r\n            // Markets go into the standard resolution period during fork migration even if they were in the initial dispute window. We want to give some time for REP to migrate.\r\n            disputeWindow = _destinationUniverse.getOrCreateNextDisputeWindow(false);\r\n        }\r\n        universe.migrateMarketOut(_destinationUniverse);\r\n        universe = _destinationUniverse;\r\n        uint256 _numOutcomes = numOutcomes;\r\n\r\n        // Pay the REP bond.\r\n        repBond = universe.getOrCacheMarketRepBond();\r\n        repBondOwner = msg.sender;\r\n        getReputationToken().trustedMarketTransfer(repBondOwner, address(this), repBond);\r\n\r\n        // Update the Initial Reporter\r\n        IInitialReporter _initialReporter = getInitialReporter();\r\n        _initialReporter.migrateToNewUniverse(msg.sender);\r\n\r\n        // If the market is past expiration use the reporting data to make an initial report\r\n        uint256 _timestamp = augur.getTimestamp();\r\n        if (_timestamp > endTime) {\r\n            doInitialReportInternal(msg.sender, _payoutNumerators, _description);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function disavowCrowdsourcers() public returns (bool) {\r\n        IMarket _forkingMarket = getForkingMarket();\r\n        require(_forkingMarket != this);\r\n        require(_forkingMarket != IMarket(NULL_ADDRESS));\r\n        require(!isFinalized());\r\n        IInitialReporter _initialParticipant = getInitialReporter();\r\n        delete participants;\r\n        participants.push(_initialParticipant);\r\n        clearCrowdsourcers();\r\n        preemptiveDisputeCrowdsourcer = IDisputeCrowdsourcer(0);\r\n        // Send REP from the rep bond back to the address that placed it. If a report has been made tell the InitialReporter to return that REP and reset\r\n        if (repBond > 0) {\r\n            IV2ReputationToken _reputationToken = getReputationToken();\r\n            uint256 _repBond = repBond;\r\n            require(_reputationToken.transfer(repBondOwner, _repBond));\r\n            repBond = 0;\r\n        } else {\r\n            _initialParticipant.returnRepFromDisavow();\r\n        }\r\n        augur.logMarketParticipantsDisavowed(universe);\r\n        return true;\r\n    }\r\n\r\n    function clearCrowdsourcers() private {\r\n        crowdsourcerGeneration += 1;\r\n    }\r\n\r\n    function getHighestNonTentativeParticipantStake() public view returns (uint256) {\r\n        if (participants.length < 2) {\r\n            return 0;\r\n        }\r\n        bytes32 _payoutDistributionHash = participants[participants.length - 2].getPayoutDistributionHash();\r\n        return getStakeInOutcome(_payoutDistributionHash);\r\n    }\r\n\r\n    /**\r\n     * @notice Gets all REP stake in completed bonds for this market\r\n     * @return uint256 indicating sum of all stake\r\n     */\r\n    function getParticipantStake() public view returns (uint256) {\r\n        uint256 _sum;\r\n        // Participants is implicitly bounded by the floor of the initial report REP cost to be no more than 21\r\n        for (uint256 i = 0; i < participants.length; ++i) {\r\n            _sum += participants[i].getStake();\r\n        }\r\n        return _sum;\r\n    }\r\n\r\n    /**\r\n     * @param _payoutDistributionHash the payout distribution hash being checked\r\n     * @return uint256 indicating the REP stake in a single outcome for a particular payout hash\r\n     */\r\n    function getStakeInOutcome(bytes32 _payoutDistributionHash) public view returns (uint256) {\r\n        uint256 _sum;\r\n        // Participants is implicitly bounded by the floor of the initial report REP cost to be no more than 21\r\n        for (uint256 i = 0; i < participants.length; ++i) {\r\n            IReportingParticipant _reportingParticipant = participants[i];\r\n            if (_reportingParticipant.getPayoutDistributionHash() != _payoutDistributionHash) {\r\n                continue;\r\n            }\r\n            _sum = _sum.add(_reportingParticipant.getStake());\r\n        }\r\n        return _sum;\r\n    }\r\n\r\n    /**\r\n     * @return The forking market for the associated universe if one exists\r\n     */\r\n    function getForkingMarket() public view returns (IMarket) {\r\n        return universe.getForkingMarket();\r\n    }\r\n\r\n    /**\r\n     * @return The current bytes32 winning distribution hash if one exists\r\n     */\r\n    function getWinningPayoutDistributionHash() public view returns (bytes32) {\r\n        return winningPayoutDistributionHash;\r\n    }\r\n\r\n    /**\r\n     * @return Bool indicating if the market is finalized\r\n     */\r\n    function isFinalized() public view returns (bool) {\r\n        return winningPayoutDistributionHash != bytes32(0);\r\n    }\r\n\r\n    /**\r\n     * @return Time at which the event is considered ready to report on\r\n     */\r\n    function getEndTime() public view returns (uint256) {\r\n        return endTime;\r\n    }\r\n\r\n    /**\r\n     * @return Bool indicating if the market resolved as anything other than Invalid\r\n     */\r\n    function isFinalizedAsInvalid() public view returns (bool) {\r\n        require(isFinalized());\r\n        if (isForkingMarket()) {\r\n            return getWinningChildPayout(0) > 0;\r\n        }\r\n        return getWinningReportingParticipant().getPayoutNumerator(0) > 0;\r\n    }\r\n\r\n    /**\r\n     * @return The Initial Reporter contract\r\n     */\r\n    function getInitialReporter() public view returns (IInitialReporter) {\r\n        return IInitialReporter(address(participants[0]));\r\n    }\r\n\r\n    /**\r\n     * @param _payoutDistributionHash The payout distribution hash for a Dispute Crowdsourcer contract for this round of disputing\r\n     * @return The associated Dispute Crowdsourcer contract for this round of disputing\r\n     */\r\n    function getCrowdsourcer(bytes32 _payoutDistributionHash) public view returns (IDisputeCrowdsourcer) {\r\n        IDisputeCrowdsourcer _crowdsourcer = IDisputeCrowdsourcer(crowdsourcers[_payoutDistributionHash]);\r\n        if (_crowdsourcer != IDisputeCrowdsourcer(0) && _crowdsourcer.getCrowdsourcerGeneration() == crowdsourcerGeneration) {\r\n            return _crowdsourcer;\r\n        }\r\n        return IDisputeCrowdsourcer(0);\r\n    }\r\n\r\n    /**\r\n     * @return The associated Initial Reporter or a Dispute Crowdsourcer contract for the current tentative winning payout\r\n     */\r\n    function getWinningReportingParticipant() public view returns (IReportingParticipant) {\r\n        return participants[participants.length-1];\r\n    }\r\n\r\n    /**\r\n     * @param _outcome The outcome to get a payout for\r\n     * @return The payout for a particular outcome for the tentative winning payout\r\n     */\r\n    function getWinningPayoutNumerator(uint256 _outcome) public view returns (uint256) {\r\n        if (isForkingMarket()) {\r\n            return getWinningChildPayout(_outcome);\r\n        }\r\n        return getWinningReportingParticipant().getPayoutNumerator(_outcome);\r\n    }\r\n\r\n    /**\r\n     * @return The Universe associated with this Market\r\n     */\r\n    function getUniverse() public view returns (IUniverse) {\r\n        return universe;\r\n    }\r\n\r\n    /**\r\n     * @return The Dispute Window currently associated with this Market\r\n     */\r\n    function getDisputeWindow() public view returns (IDisputeWindow) {\r\n        return disputeWindow;\r\n    }\r\n\r\n    /**\r\n     * @return The time the Market was finalzied as a uint256 timestmap if the market was finalized\r\n     */\r\n    function getFinalizationTime() public view returns (uint256) {\r\n        return finalizationTime;\r\n    }\r\n\r\n    /**\r\n     * @return The REP token associated with this Market\r\n     */\r\n    function getReputationToken() public view returns (IV2ReputationToken) {\r\n        return universe.getReputationToken();\r\n    }\r\n\r\n    /**\r\n     * @return The number of outcomes (including invalid) this market has\r\n     */\r\n    function getNumberOfOutcomes() public view returns (uint256) {\r\n        return numOutcomes;\r\n    }\r\n\r\n    /**\r\n     * @return The number of ticks for this market. The number of ticks determines the possible on chain prices for Shares of the market. (e.g. A Market with 10 ticks can have prices 1-9 and a complete set will cost 10)\r\n     */\r\n    function getNumTicks() public view returns (uint256) {\r\n        return numTicks;\r\n    }\r\n\r\n    /**\r\n     * @return The uint256 timestamp for when the designated reporting period is over and anyone may report\r\n     */\r\n    function getDesignatedReportingEndTime() public view returns (uint256) {\r\n        return endTime.add(Reporting.getDesignatedReportingDurationSeconds());\r\n    }\r\n\r\n    /**\r\n     * @return The number of rounds of reporting + disputing that have occured\r\n     */\r\n    function getNumParticipants() public view returns (uint256) {\r\n        return participants.length;\r\n    }\r\n\r\n    /**\r\n     * @return The size of the validity bond\r\n     */\r\n    function getValidityBondAttoCash() public view returns (uint256) {\r\n        return validityBondAttoCash;\r\n    }\r\n\r\n    /**\r\n     * @return Bool indicating if slow dispute rounds have turned on\r\n     */\r\n    function getDisputePacingOn() public view returns (bool) {\r\n        return disputePacingOn;\r\n    }\r\n\r\n    /**\r\n     * @param _payoutNumerators array of payouts per outcome\r\n     * @return Bytes32 has of the payout for use in other functions\r\n     */\r\n    function derivePayoutDistributionHash(uint256[] memory _payoutNumerators) public view returns (bytes32) {\r\n        return augur.derivePayoutDistributionHash(_payoutNumerators, numTicks, numOutcomes);\r\n    }\r\n\r\n    function isContainerForReportingParticipant(IReportingParticipant _shadyReportingParticipant) public view returns (bool) {\r\n        require(_shadyReportingParticipant != IReportingParticipant(0));\r\n        if (address(preemptiveDisputeCrowdsourcer) == address(_shadyReportingParticipant)) {\r\n            return true;\r\n        }\r\n        if (getCrowdsourcer(_shadyReportingParticipant.getPayoutDistributionHash()) == _shadyReportingParticipant) {\r\n            return true;\r\n        }\r\n        // Participants is implicitly bounded by the floor of the initial report REP cost to be no more than 21\r\n        for (uint256 i = 0; i < participants.length; i++) {\r\n            if (_shadyReportingParticipant == participants[i]) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function onTransferOwnership(address _owner, address _newOwner) internal {\r\n        augur.logMarketTransferred(getUniverse(), _owner, _newOwner);\r\n    }\r\n\r\n    /**\r\n     * @notice Transfers ownership of the REP no-show bond\r\n     * @param _newOwner The new REP no show bond owner\r\n     * @return Bool True\r\n     */\r\n    function transferRepBondOwnership(address _newOwner) public returns (bool) {\r\n        require(_newOwner != address(0));\r\n        require(msg.sender == repBondOwner);\r\n        address _oldOwner = repBondOwner;\r\n        repBondOwner = _newOwner;\r\n        augur.logMarketRepBondTransferred(address(universe), _oldOwner, _newOwner);\r\n        return true;\r\n    }\r\n\r\n    function isForkingMarket() public view returns (bool) {\r\n        return universe.isForkingMarket();\r\n    }\r\n\r\n    function getWinningChildPayout(uint256 _outcome) public view returns (uint256) {\r\n        return universe.getWinningChildPayoutNumerator(_outcome);\r\n    }\r\n\r\n    function getOpenInterest() public view returns (uint256) {\r\n        if (isFinalized()) {\r\n            return 0;\r\n        }\r\n        return shareToken.totalSupplyForMarketOutcome(this, 0).mul(numTicks);\r\n    }\r\n}", "ABI": "[{\"constant\":true,\"inputs\":[],\"name\":\"affiliateFeeDivisor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"augur\",\"outputs\":[{\"internalType\":\"contract IAugur\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cash\",\"outputs\":[{\"internalType\":\"contract ICash\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_payoutNumerators\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_description\",\"type\":\"string\"}],\"name\":\"contribute\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_payoutNumerators\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_description\",\"type\":\"string\"}],\"name\":\"contributeToTentative\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crowdsourcerGeneration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"crowdsourcers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"deriveMarketCreatorFeeAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_payoutNumerators\",\"type\":\"uint256[]\"}],\"name\":\"derivePayoutDistributionHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"disavowCrowdsourcers\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_payoutNumerators\",\"type\":\"uint256[]\"},{\"internalType\":\"string\",\"name\":\"_description\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_additionalStake\",\"type\":\"uint256\"}],\"name\":\"doInitialReport\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalize\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_payoutDistributionHash\",\"type\":\"bytes32\"}],\"name\":\"getCrowdsourcer\",\"outputs\":[{\"internalType\":\"contract IDisputeCrowdsourcer\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getDesignatedReportingEndTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getDisputePacingOn\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getDisputeWindow\",\"outputs\":[{\"internalType\":\"contract IDisputeWindow\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getEndTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getFinalizationTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getForkingMarket\",\"outputs\":[{\"internalType\":\"contract IMarket\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getHighestNonTentativeParticipantStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getInitialReporter\",\"outputs\":[{\"internalType\":\"contract IInitialReporter\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getInitialized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMarketCreatorSettlementFeeDivisor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNumParticipants\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNumTicks\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNumberOfOutcomes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOpenInterest\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getParticipantStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getReputationToken\",\"outputs\":[{\"internalType\":\"contract IV2ReputationToken\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_payoutDistributionHash\",\"type\":\"bytes32\"}],\"name\":\"getStakeInOutcome\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getUniverse\",\"outputs\":[{\"internalType\":\"contract IUniverse\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getValidityBondAttoCash\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_outcome\",\"type\":\"uint256\"}],\"name\":\"getWinningChildPayout\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getWinningPayoutDistributionHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_outcome\",\"type\":\"uint256\"}],\"name\":\"getWinningPayoutNumerator\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getWinningReportingParticipant\",\"outputs\":[{\"internalType\":\"contract IReportingParticipant\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract IAugur\",\"name\":\"_augur\",\"type\":\"address\"},{\"internalType\":\"contract IUniverse\",\"name\":\"_universe\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_endTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_feePerCashInAttoCash\",\"type\":\"uint256\"},{\"internalType\":\"contract IAffiliateValidator\",\"name\":\"_affiliateValidator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_affiliateFeeDivisor\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_designatedReporterAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_creator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_numOutcomes\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_numTicks\",\"type\":\"uint256\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"contract IReportingParticipant\",\"name\":\"_shadyReportingParticipant\",\"type\":\"address\"}],\"name\":\"isContainerForReportingParticipant\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isFinalized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isFinalizedAsInvalid\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isForkingMarket\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"marketCreatorFeesAttoCash\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_payoutNumerators\",\"type\":\"uint256[]\"},{\"internalType\":\"string\",\"name\":\"_description\",\"type\":\"string\"}],\"name\":\"migrateThroughOneFork\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"participants\",\"outputs\":[{\"internalType\":\"contract IReportingParticipant\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"preemptiveDisputeCrowdsourcer\",\"outputs\":[{\"internalType\":\"contract IDisputeCrowdsourcer\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_marketCreatorFees\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_sourceAccount\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_fingerprint\",\"type\":\"bytes32\"}],\"name\":\"recordMarketCreatorFees\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"repBond\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"repBondOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"shareToken\",\"outputs\":[{\"internalType\":\"contract IShareToken\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferRepBondOwnership\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"validityBondAttoCash\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"warpSync\",\"outputs\":[{\"internalType\":\"contract IWarpSync\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Market", "CompilerVersion": "v0.5.15+commit.6a57276f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU LGPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://845b2958e886ffe9f95beda3e39226801a5d65a3cababd9b5ea7eb906d940390"}