{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface AggregatorV3Interface {\\n  function decimals() external view returns (uint8);\\n\\n  function description() external view returns (string memory);\\n\\n  function version() external view returns (uint256);\\n\\n  function getRoundData(uint80 _roundId)\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n  function latestRoundData()\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Returns true if the reentrancy guard is currently set to \\\"entered\\\", which indicates there is a\\n     * `nonReentrant` function in the call stack.\\n     */\\n    function _reentrancyGuardEntered() internal view returns (bool) {\\n        return _status == _ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./extensions/IERC20Metadata.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * The default value of {decimals} is 18. To change this, you should override\\n * this function so it returns a different value.\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the default value returned by this function, unless\\n     * it's overridden.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * NOTE: Does not update the allowance if the current allowance\\n     * is the maximum `uint256`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` and `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``from``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, amount);\\n        _transfer(from, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        uint256 currentAllowance = allowance(owner, spender);\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(owner, spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `from` to `to`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address from, address to, uint256 amount) internal virtual {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, amount);\\n\\n        uint256 fromBalance = _balances[from];\\n        require(fromBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[from] = fromBalance - amount;\\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\\n            // decrementing then incrementing.\\n            _balances[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        _afterTokenTransfer(from, to, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        unchecked {\\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\\n            _balances[account] += amount;\\n        }\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\\n            _totalSupply -= amount;\\n        }\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\\n     *\\n     * Does not update the allowance amount in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Might emit an {Approval} event.\\n     */\\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            require(currentAllowance >= amount, \\\"ERC20: insufficient allowance\\\");\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - amount);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../extensions/IERC20Permit.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    /**\\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 oldAllowance = token.allowance(address(this), spender);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\\n    }\\n\\n    /**\\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\\n        }\\n    }\\n\\n    /**\\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful. Compatible with tokens that require the approval to be set to\\n     * 0 before setting it to a non-zero value.\\n     */\\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\\n\\n        if (!_callOptionalReturnBool(token, approvalCall)) {\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\\n            _callOptionalReturn(token, approvalCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\\n     * Revert on invalid signature.\\n     */\\n    function safePermit(\\n        IERC20Permit token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     *\\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\\n     */\\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\\n        // and not revert is the subcall reverts.\\n\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        return\\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     *\\n     * Furthermore, `isContract` will also return true if the target contract within\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\n     * which only has an effect at the end of a transaction.\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1, \\\"Math: mulDiv overflow\\\");\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/DODOV3MM/D3Pool/D3Funding.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.16;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {SafeERC20} from \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"../lib/DecimalMath.sol\\\";\\nimport \\\"../intf/ID3Vault.sol\\\";\\nimport \\\"../../intf/ID3Oracle.sol\\\";\\nimport \\\"./D3Storage.sol\\\";\\n\\n/// @notice pool funding model, manage pool borrow/repay and maker deposi/withdraw\\ncontract D3Funding is D3Storage {\\n    using SafeERC20 for IERC20;\\n\\n    /// @notice borrow tokens from vault\\n    function borrow(address token, uint256 amount) external onlyOwner nonReentrant poolOngoing {\\n        // call vault's poolBorrow function\\n        ID3Vault(state._D3_VAULT_).poolBorrow(token, amount);\\n        // approve max, ensure vault could force liquidate\\n        uint256 allowance = IERC20(token).allowance(address(this), state._D3_VAULT_);\\n        if(allowance < type(uint256).max) {\\n            IERC20(token).forceApprove(state._D3_VAULT_, type(uint256).max);\\n        }\\n\\n        _updateReserve(token);\\n        require(checkSafe(), Errors.NOT_SAFE);\\n        require(checkBorrowSafe(), Errors.NOT_BORROW_SAFE);\\n    }\\n\\n    /// @notice repay vault with certain amount of borrowed assets \\n    function repay(address token, uint256 amount) external onlyOwner nonReentrant poolOngoing {\\n        // call vault's poolRepay\\n        ID3Vault(state._D3_VAULT_).poolRepay(token, amount);\\n\\n        _updateReserve(token);\\n        require(checkSafe(), Errors.NOT_SAFE);\\n    }\\n\\n    /// @notice repay vault all debt of this token\\n    function repayAll(address token) external onlyOwner nonReentrant poolOngoing {\\n        ID3Vault(state._D3_VAULT_).poolRepayAll(token);\\n\\n        _updateReserve(token);\\n        require(checkSafe(), Errors.NOT_SAFE);\\n\\n    }\\n\\n    /// @notice used through liquidation\\n    function updateReserveByVault(address token) external onlyVault {\\n        uint256 allowance = IERC20(token).allowance(address(this), state._D3_VAULT_);\\n        if(allowance < type(uint256).max) {\\n            IERC20(token).forceApprove(state._D3_VAULT_, type(uint256).max);\\n        }\\n        _updateReserve(token);\\n    }\\n\\n    /// @notice maker deposit, anyone could deposit but only maker could withdraw\\n    function makerDeposit(address token) external nonReentrant poolOngoing {\\n        require(ID3Oracle(state._ORACLE_).isFeasible(token), Errors.TOKEN_NOT_FEASIBLE);\\n        if (!state.hasDepositedToken[token]) {\\n            state.hasDepositedToken[token] = true;\\n            state.depositedTokenList.push(token);\\n        }\\n        // transfer in from proxies\\n        uint256 tokenInAmount = IERC20(token).balanceOf(address(this)) - state.balances[token];\\n        _updateReserve(token);\\n        // if token in tokenlist, approve max, ensure vault could force liquidate\\n        uint256 allowance = IERC20(token).allowance(address(this), state._D3_VAULT_);\\n        if(_checkTokenInTokenlist(token) && allowance < type(uint256).max) {\\n            IERC20(token).forceApprove(state._D3_VAULT_, type(uint256).max);\\n        }\\n        require(checkSafe(), Errors.NOT_SAFE);\\n\\n        emit MakerDeposit(token, tokenInAmount);\\n    }\\n\\n    function makerWithdraw(address to, address token, uint256 amount) external onlyOwner nonReentrant poolOngoing {\\n        IERC20(token).safeTransfer(to, amount);\\n\\n        _updateReserve(token);\\n        require(checkSafe(), Errors.NOT_SAFE);\\n        require(checkBorrowSafe(), Errors.NOT_BORROW_SAFE);\\n\\n        emit MakerWithdraw(to, token, amount);\\n    }\\n\\n    // below IM: not safe!\\n    function checkSafe() public view returns (bool) {\\n        return ID3Vault(state._D3_VAULT_).checkSafe(address(this));\\n    }\\n\\n    // check when borrowing asset\\n    function checkBorrowSafe() public view returns (bool) {\\n        return ID3Vault(state._D3_VAULT_).checkBorrowSafe(address(this));\\n    }\\n\\n    // blow MM: dangerous!\\n    function checkCanBeLiquidated() public view returns (bool) {\\n        return ID3Vault(state._D3_VAULT_).checkCanBeLiquidated(address(this));\\n    }\\n\\n    function startLiquidation() external onlyVault {\\n        isInLiquidation = true;\\n    }\\n\\n    function finishLiquidation() external onlyVault {\\n        isInLiquidation = false;\\n    }\\n\\n    function _updateReserve(address token) internal {\\n        state.balances[token] = IERC20(token).balanceOf(address(this));\\n    }\\n\\n    function _checkTokenInTokenlist(address token) internal view returns(bool){\\n        return ID3Vault(state._D3_VAULT_).tokens(token); \\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/DODOV3MM/D3Pool/D3Maker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.16;\\n\\nimport \\\"../lib/MakerTypes.sol\\\";\\nimport \\\"../lib/Types.sol\\\";\\nimport \\\"../lib/InitializableOwnable.sol\\\";\\nimport \\\"../lib/Errors.sol\\\";\\nimport {ID3MM} from \\\"../intf/ID3MM.sol\\\";\\n\\n/// @notice D3Maker is a dependent price controll model. Maker could set token price and other price \\n/// parameters to control swap. The key part is MakerState(in D3Maker) and flag(in D3MM) parameter. MakerState \\n/// contains token price, amount and swap fee. Specially for token price, which is supposed to be set frequently,\\n/// we use one slot to compress 3 token price with dependent price array. Flags in D3MM decide whether this token's \\n/// cumulative volumn change, which means resetting integral start point. Every function should reset cumulative\\n/// volumn.\\n/// @dev maker could not delete token function\\ncontract D3Maker is InitializableOwnable {\\n    MakerTypes.MakerState internal state;\\n    address public _POOL_;\\n    address[] internal poolTokenlist;\\n\\n    // ============== Event =============\\n    // use operatorIndex to distinct different setting, 1 = setMaxInterval  2 = setTokensPrice, 3 = setNSPriceSlot,\\n    // 4 = setStablePriceSlot, 5 = setTokensAmounts, 6 = setTokensKs\\n    event SetPoolInfo(uint256 indexed operatorIndex);\\n    event SetNewToken(address indexed token);\\n\\n    // ============== init =============\\n    function init(address owner, address pool, uint256 maxInterval) external {\\n        initOwner(owner);\\n        _POOL_ = pool;\\n        state.heartBeat.maxInterval = maxInterval;\\n    }\\n\\n    // ============= Read for tokenMMInfo =================\\n    function getTokenMMInfoForPool(address token)\\n        external\\n        view\\n        returns (Types.TokenMMInfo memory tokenMMInfo, uint256 tokenIndex)\\n    {\\n        if (state.tokenMMInfoMap[token].amountInfo == 0) {\\n            // invalid token\\n            return (tokenMMInfo, 0);\\n        }\\n        // get mtFee\\n        uint256 mtFeeRate = ID3MM(_POOL_).getFeeRate(token);\\n        // deal with priceInfo\\n        uint80 priceInfo = getOneTokenPriceSet(token);\\n        (\\n            tokenMMInfo.askUpPrice,\\n            tokenMMInfo.askDownPrice,\\n            tokenMMInfo.bidUpPrice,\\n            tokenMMInfo.bidDownPrice,\\n            tokenMMInfo.swapFeeRate\\n        ) = MakerTypes.parseAllPrice(priceInfo, mtFeeRate);\\n        // lpfee add mtFee\\n        tokenMMInfo.mtFeeRate = mtFeeRate;\\n        uint64 amountInfo = state.tokenMMInfoMap[token].amountInfo;\\n        tokenMMInfo.askAmount = MakerTypes.parseAskAmount(amountInfo);\\n        tokenMMInfo.bidAmount = MakerTypes.parseBidAmount(amountInfo);\\n        tokenMMInfo.kAsk = MakerTypes.parseK(state.tokenMMInfoMap[token].kAsk);\\n        tokenMMInfo.kBid = MakerTypes.parseK(state.tokenMMInfoMap[token].kBid);\\n        tokenIndex = uint256(getOneTokenOriginIndex(token));\\n    }\\n\\n    // ================== Read parameters ==============\\n\\n    /// @notice give one token's address, give back token's priceInfo\\n    function getOneTokenPriceSet(address token) public view returns (uint80 priceSet) {\\n        require(state.priceListInfo.tokenIndexMap[token] > 0, Errors.INVALID_TOKEN);\\n        uint256 tokenOriIndex = state.priceListInfo.tokenIndexMap[token] - 1;\\n        uint256 tokenIndex = (tokenOriIndex / 2);\\n        uint256 tokenIndexInnerSlot = tokenIndex % MakerTypes.PRICE_QUANTITY_IN_ONE_SLOT;\\n\\n        uint256 curAllPrices = tokenOriIndex % 2 == 1\\n            ? state.priceListInfo.tokenPriceNS[tokenIndex / MakerTypes.PRICE_QUANTITY_IN_ONE_SLOT]\\n            : state.priceListInfo.tokenPriceStable[tokenIndex / MakerTypes.PRICE_QUANTITY_IN_ONE_SLOT];\\n        curAllPrices = curAllPrices >> (MakerTypes.ONE_PRICE_BIT * tokenIndexInnerSlot);\\n        priceSet = uint80(curAllPrices & ((2 ** (MakerTypes.ONE_PRICE_BIT)) - 1));\\n    }\\n\\n    /// @notice get one token index. odd for none-stable, even for stable,  true index = (tokenIndex[address] - 1) / 2\\n    function getOneTokenOriginIndex(address token) public view returns (int256) {\\n        //require(state.priceListInfo.tokenIndexMap[token] > 0, Errors.INVALID_TOKEN);\\n        return int256(state.priceListInfo.tokenIndexMap[token]) - 1;\\n    }\\n\\n    /// @notice get all stable token Info\\n    /// @return numberOfStable stable tokens' quantity\\n    /// @return tokenPriceStable stable tokens' price slot array. each data contains up to 3 token prices\\n    function getStableTokenInfo()\\n        external\\n        view\\n        returns (uint256 numberOfStable, uint256[] memory tokenPriceStable, uint256 curFlag)\\n    {\\n        numberOfStable = state.priceListInfo.numberOfStable;\\n        tokenPriceStable = state.priceListInfo.tokenPriceStable;\\n        curFlag = ID3MM(_POOL_).allFlag();\\n    }\\n\\n    /// @notice get all non-stable token Info\\n    /// @return number stable tokens' quantity\\n    /// @return tokenPrices stable tokens' price slot array. each data contains up to 3 token prices\\n    function getNSTokenInfo() external view returns (uint256 number, uint256[] memory tokenPrices, uint256 curFlag) {\\n        number = state.priceListInfo.numberOfNS;\\n        tokenPrices = state.priceListInfo.tokenPriceNS;\\n        curFlag = ID3MM(_POOL_).allFlag();\\n    }\\n\\n    /// @notice used for construct several price in one price slot\\n    /// @param priceSlot origin price slot\\n    /// @param slotInnerIndex token index in slot\\n    /// @param priceSet the token info needed to update\\n    function stickPrice(\\n        uint256 priceSlot,\\n        uint256 slotInnerIndex,\\n        uint256 priceSet\\n    ) public pure returns (uint256 newPriceSlot) {\\n        uint256 leftPriceSet = priceSlot >> ((slotInnerIndex + 1) * MakerTypes.ONE_PRICE_BIT);\\n        uint256 rightPriceSet = priceSlot & ((2 ** (slotInnerIndex * MakerTypes.ONE_PRICE_BIT)) - 1);\\n        newPriceSlot = (leftPriceSet << ((slotInnerIndex + 1) * MakerTypes.ONE_PRICE_BIT))\\n            + (priceSet << (slotInnerIndex * MakerTypes.ONE_PRICE_BIT)) + rightPriceSet;\\n    }\\n\\n    function checkHeartbeat() public view returns (bool) {\\n        if (block.timestamp - state.heartBeat.lastHeartBeat <= state.heartBeat.maxInterval) {\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    function getPoolTokenListFromMaker() external view returns(address[] memory tokenlist) {\\n        return poolTokenlist;\\n    }\\n\\n    // ============= Set params ===========\\n\\n    /// @notice maker could use multicall to set different params in one tx.\\n    function multicall(bytes[] calldata data) external returns (bytes[] memory results) {\\n        results = new bytes[](data.length);\\n        for (uint256 i = 0; i < data.length; i++) {\\n            (bool success, bytes memory result) = address(this).delegatecall(data[i]);\\n\\n            if (!success) {\\n                assembly {\\n                    revert(add(result, 32), mload(result))\\n                }\\n            }\\n\\n            results[i] = result;\\n        }\\n    }\\n\\n    /// @notice maker set a new token info\\n    /// @param token token's address\\n    /// @param priceSet packed price, [mid price(16) | mid price decimal(8) | fee rate(16) | ask up rate (16) | bid down rate(16)]\\n    /// @param amountSet describe ask and bid amount and K, [ask amounts(16) | ask amounts decimal(8) | bid amounts(16) | bid amounts decimal(8) ] = one slot could contains 4 token info\\n    /// @param stableOrNot describe this token is stable or not, true = stable coin\\n    /// @param kAsk k of ask curve\\n    /// @param kBid k of bid curve\\n    function setNewToken(\\n        address token,\\n        bool stableOrNot,\\n        uint80 priceSet,\\n        uint64 amountSet,\\n        uint16 kAsk,\\n        uint16 kBid\\n    ) external onlyOwner {\\n        require(state.priceListInfo.tokenIndexMap[token] == 0, Errors.HAVE_SET_TOKEN_INFO);\\n        // check amount\\n        require(kAsk >= 0 && kAsk <= 10000, Errors.K_LIMIT);\\n        require(kBid >= 0 && kBid <= 10000, Errors.K_LIMIT);\\n        poolTokenlist.push(token);\\n\\n        // set new token info\\n        state.tokenMMInfoMap[token].priceInfo = priceSet;\\n        state.tokenMMInfoMap[token].amountInfo = amountSet;\\n        state.tokenMMInfoMap[token].kAsk = kAsk;\\n        state.tokenMMInfoMap[token].kBid = kBid;\\n        state.heartBeat.lastHeartBeat = block.timestamp;\\n\\n        // set token price index\\n        uint256 tokenIndex;\\n        if (stableOrNot) {\\n            // is stable\\n            tokenIndex = state.priceListInfo.numberOfStable * 2;\\n            uint256 innerSlotIndex = state.priceListInfo.numberOfStable % MakerTypes.PRICE_QUANTITY_IN_ONE_SLOT;\\n            uint256 slotIndex = state.priceListInfo.numberOfStable / MakerTypes.PRICE_QUANTITY_IN_ONE_SLOT;\\n            if (innerSlotIndex == 0) {\\n                state.priceListInfo.tokenPriceStable.push(priceSet);\\n            } else {\\n                state.priceListInfo.tokenPriceStable[slotIndex] = (\\n                    uint256(priceSet) << (MakerTypes.ONE_PRICE_BIT * innerSlotIndex)\\n                ) + state.priceListInfo.tokenPriceStable[slotIndex];\\n            }\\n            state.priceListInfo.numberOfStable++;\\n        } else {\\n            tokenIndex = state.priceListInfo.numberOfNS * 2 + 1;\\n            uint256 innerSlotIndex = state.priceListInfo.numberOfNS % MakerTypes.PRICE_QUANTITY_IN_ONE_SLOT;\\n            uint256 slotIndex = state.priceListInfo.numberOfNS / MakerTypes.PRICE_QUANTITY_IN_ONE_SLOT;\\n            if (innerSlotIndex == 0) {\\n                state.priceListInfo.tokenPriceNS.push(priceSet);\\n            } else {\\n                state.priceListInfo.tokenPriceNS[slotIndex] = (\\n                    uint256(priceSet) << (MakerTypes.ONE_PRICE_BIT * innerSlotIndex)\\n                ) + state.priceListInfo.tokenPriceNS[slotIndex];\\n            }\\n            state.priceListInfo.numberOfNS++;\\n        }\\n        // to avoid reset the same token, tokenIndexMap record index from 1, but actualIndex = tokenIndex[address] - 1\\n        state.priceListInfo.tokenIndexMap[token] = tokenIndex + 1;\\n        state.tokenMMInfoMap[token].tokenIndex = uint16(tokenIndex);\\n\\n        emit SetNewToken(token);\\n    }\\n\\n    /// @notice set token prices\\n    /// @param tokens token address set\\n    /// @param tokenPrices token prices set, each number pack one token all price.Each format is the same with priceSet\\n    /// [mid price(16) | mid price decimal(8) | fee rate(16) | ask up rate (16) | bid down rate(16)] = one slot could contains 3 token info\\n    function setTokensPrice(\\n        address[] calldata tokens,\\n        uint80[] calldata tokenPrices\\n    ) external onlyOwner {\\n        require(tokens.length == tokenPrices.length, Errors.PRICES_LENGTH_NOT_MATCH);\\n        uint256[] memory haveWrittenToken = new uint256[](tokens.length);\\n        uint256 curFlag = ID3MM(_POOL_).allFlag();\\n\\n        for (uint256 i = 0; i < tokens.length; ++i) {\\n            if (haveWrittenToken[i] == 1) continue;\\n\\n            haveWrittenToken[i] = 1;\\n            address curToken = tokens[i];\\n            uint80 curTokenPriceSet = tokenPrices[i];\\n            //_checkUpAndDownPrice(curTokenPriceSet);\\n\\n            {\\n                uint256 tokenIndex = state.priceListInfo.tokenIndexMap[curToken] - 1;\\n                curFlag = curFlag & ~(1 << tokenIndex);\\n            }\\n\\n            // get slot price\\n            uint256 curTokenIndex = (state.priceListInfo.tokenIndexMap[curToken] - 1) / 2;\\n            uint256 slotIndex = curTokenIndex / MakerTypes.PRICE_QUANTITY_IN_ONE_SLOT;\\n            uint256 priceInfoSet = (state.priceListInfo.tokenIndexMap[curToken] - 1) % 2 == 1\\n                ? state.priceListInfo.tokenPriceNS[slotIndex]\\n                : state.priceListInfo.tokenPriceStable[slotIndex];\\n\\n            priceInfoSet = stickPrice(\\n                priceInfoSet, curTokenIndex % MakerTypes.PRICE_QUANTITY_IN_ONE_SLOT, uint256(curTokenPriceSet)\\n            );\\n\\n            // find one slot token\\n            for (uint256 j = i + 1; j < tokens.length; ++j) {\\n                address tokenJ = tokens[j];\\n                uint256 tokenJOriIndex = (state.priceListInfo.tokenIndexMap[tokenJ] - 1);\\n                if (\\n                    haveWrittenToken[j] == 1 // have written\\n                        || (state.priceListInfo.tokenIndexMap[curToken] - 1) % 2 != tokenJOriIndex % 2 // not the same stable type\\n                        || tokenJOriIndex / 2 / MakerTypes.PRICE_QUANTITY_IN_ONE_SLOT != slotIndex\\n                ) {\\n                    // not one slot\\n                    continue;\\n                }\\n                //_checkUpAndDownPrice(tokenPrices[j]);\\n                priceInfoSet = stickPrice(\\n                    priceInfoSet, (tokenJOriIndex / 2) % MakerTypes.PRICE_QUANTITY_IN_ONE_SLOT, uint256(tokenPrices[j])\\n                );\\n\\n                haveWrittenToken[j] = 1;\\n                {\\n                    uint256 tokenIndex = state.priceListInfo.tokenIndexMap[tokenJ] - 1;\\n                    curFlag = curFlag & ~(1 << tokenIndex);\\n                }\\n            }\\n\\n            if ((state.priceListInfo.tokenIndexMap[curToken] - 1) % 2 == 1) {\\n                state.priceListInfo.tokenPriceNS[slotIndex] = priceInfoSet;\\n            } else {\\n                state.priceListInfo.tokenPriceStable[slotIndex] = priceInfoSet;\\n            }\\n        }\\n        state.heartBeat.lastHeartBeat = block.timestamp;\\n        ID3MM(_POOL_).setNewAllFlag(curFlag);\\n\\n        emit SetPoolInfo(2);\\n    }\\n\\n    /// @notice user set PriceListInfo.tokenPriceNS price info, only for none-stable coin\\n    /// @param slotIndex tokenPriceNS index\\n    /// @param priceSlots tokenPriceNS price info, every data has packed all 3 token price info\\n    /// @param newAllFlag maker update token cumulative status,\\n    /// for allFlag, tokenOriIndex represent bit index in allFlag. eg: tokenA has origin index 3, that means (allFlag >> 3) & 1 = token3's flag\\n    /// flag = 0 means to reset cumulative. flag = 1 means not to reset cumulative.\\n    /// @dev maker should be responsible for data availability\\n    function setNSPriceSlot(\\n        uint256[] calldata slotIndex,\\n        uint256[] calldata priceSlots,\\n        uint256 newAllFlag\\n    ) external onlyOwner {\\n        require(slotIndex.length == priceSlots.length, Errors.PRICE_SLOT_LENGTH_NOT_MATCH);\\n        for (uint256 i = 0; i < slotIndex.length; ++i) {\\n            state.priceListInfo.tokenPriceNS[slotIndex[i]] = priceSlots[i];\\n        }\\n        ID3MM(_POOL_).setNewAllFlag(newAllFlag);\\n        state.heartBeat.lastHeartBeat = block.timestamp;\\n\\n        emit SetPoolInfo(3);\\n    }\\n\\n    /// @notice user set PriceListInfo.tokenPriceStable price info, only for stable coin\\n    /// @param slotIndex tokenPriceStable index\\n    /// @param priceSlots tokenPriceStable price info, every data has packed all 3 token price info\\n    /// @param newAllFlag maker update token cumulative status,\\n    /// for allFlag, tokenOriIndex represent bit index in allFlag. eg: tokenA has origin index 3, that means (allFlag >> 3) & 1 = token3's flag\\n    /// flag = 0 means to reset cumulative. flag = 1 means not to reset cumulative.\\n    /// @dev maker should be responsible for data availability\\n    function setStablePriceSlot(\\n        uint256[] calldata slotIndex,\\n        uint256[] calldata priceSlots,\\n        uint256 newAllFlag\\n    ) external onlyOwner {\\n        require(slotIndex.length == priceSlots.length, Errors.PRICE_SLOT_LENGTH_NOT_MATCH);\\n        for (uint256 i = 0; i < slotIndex.length; ++i) {\\n            state.priceListInfo.tokenPriceStable[slotIndex[i]] = priceSlots[i];\\n        }\\n        ID3MM(_POOL_).setNewAllFlag(newAllFlag);\\n        state.heartBeat.lastHeartBeat = block.timestamp;\\n\\n        emit SetPoolInfo(4);\\n    }\\n\\n    /// @notice set token Amounts\\n    /// @param tokens token address set\\n    /// @param tokenAmounts token amounts set, each number pack one token all amounts.Each format is the same with amountSetAndK\\n    /// [ask amounts(16) | ask amounts decimal(8) | bid amounts(16) | bid amounts decimal(8) ]\\n    function setTokensAmounts(\\n        address[] calldata tokens,\\n        uint64[] calldata tokenAmounts\\n    ) external onlyOwner {\\n        require(tokens.length == tokenAmounts.length, Errors.AMOUNTS_LENGTH_NOT_MATCH);\\n        uint256 curFlag = ID3MM(_POOL_).allFlag();\\n        for (uint256 i = 0; i < tokens.length; ++i) {\\n            address curToken = tokens[i];\\n            uint64 curTokenAmountSet = tokenAmounts[i];\\n\\n            state.tokenMMInfoMap[curToken].amountInfo = curTokenAmountSet;\\n            {\\n                uint256 tokenIndex = state.priceListInfo.tokenIndexMap[curToken] - 1;\\n                curFlag = curFlag & ~(1 << tokenIndex);\\n            }\\n        }\\n        state.heartBeat.lastHeartBeat = block.timestamp;\\n        ID3MM(_POOL_).setNewAllFlag(curFlag);\\n\\n        emit SetPoolInfo(5);\\n    }\\n\\n    /// @notice set token Ks\\n    /// @param tokens token address set\\n    /// @param tokenKs token k_ask and k_bid, structure like [kAsk(16) | kBid(16)]\\n    function setTokensKs(address[] calldata tokens, uint32[] calldata tokenKs) external onlyOwner {\\n        require(tokens.length == tokenKs.length, Errors.K_LENGTH_NOT_MATCH);\\n        uint256 curFlag = ID3MM(_POOL_).allFlag();\\n        for (uint256 i = 0; i < tokens.length; ++i) {\\n            address curToken = tokens[i];\\n            uint32 curTokenK = tokenKs[i];\\n            uint16 kAsk = uint16(curTokenK >> 16);\\n            uint16 kBid = uint16(curTokenK & 0xffff);\\n\\n            require(kAsk >= 0 && kAsk <= 10000, Errors.K_LIMIT);\\n            require(kBid >= 0 && kBid <= 10000, Errors.K_LIMIT);\\n\\n            state.tokenMMInfoMap[curToken].kAsk = kAsk;\\n            state.tokenMMInfoMap[curToken].kBid = kBid;\\n\\n            {\\n                uint256 tokenIndex = state.priceListInfo.tokenIndexMap[curToken] - 1;\\n                curFlag = curFlag & ~(1 << tokenIndex);\\n            }\\n        }\\n        state.heartBeat.lastHeartBeat = block.timestamp;\\n        ID3MM(_POOL_).setNewAllFlag(curFlag);\\n\\n        emit SetPoolInfo(6);\\n    }\\n\\n    /// @notice set acceptable setting interval, if setting gap > maxInterval, swap will revert.\\n    function setHeartbeat(uint256 newMaxInterval) public onlyOwner {\\n        state.heartBeat.maxInterval = newMaxInterval;\\n\\n        emit SetPoolInfo(1);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/DODOV3MM/D3Pool/D3MM.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.16;\\n\\nimport {D3Trading} from \\\"./D3Trading.sol\\\";\\nimport {IFeeRateModel} from \\\"../../intf/IFeeRateModel.sol\\\";\\nimport {ID3Maker} from \\\"../intf/ID3Maker.sol\\\";\\n\\ncontract D3MM is D3Trading {\\n    /// @notice init D3MM pool\\n    function init(\\n        address creator,\\n        address maker,\\n        address vault,\\n        address oracle,\\n        address feeRateModel,\\n        address maintainer\\n    ) external {\\n        initOwner(creator);\\n        state._CREATOR_ = creator;\\n        state._D3_VAULT_ = vault;\\n        state._ORACLE_ = oracle;\\n        state._MAKER_ = maker;\\n        state._FEE_RATE_MODEL_ = feeRateModel;\\n        state._MAINTAINER_ = maintainer;\\n    }\\n\\n    // ============= Set ====================\\n    function setNewMaker(address newMaker) external onlyOwner {\\n        state._MAKER_ = newMaker;\\n        allFlag = 0;\\n    }\\n\\n    // ============= View =================\\n    function _CREATOR_() external view returns(address) {\\n        return state._CREATOR_;\\n    }\\n\\n    function getFeeRate(address token) external view returns(uint256 feeRate) {\\n        return IFeeRateModel(state._FEE_RATE_MODEL_).getFeeRate(token);\\n    }\\n\\n    function getPoolTokenlist() external view returns(address[] memory) {\\n        return ID3Maker(state._MAKER_).getPoolTokenListFromMaker();\\n    }\\n\\n    function getDepositedTokenList() external view returns (address[] memory) {\\n        return state.depositedTokenList;\\n    }\\n\\n    /// @notice get basic pool info\\n    function getD3MMInfo() external view returns (address vault, address oracle, address maker, address feeRateModel, address maintainer) {\\n        vault = state._D3_VAULT_;\\n        oracle = state._ORACLE_;\\n        maker = state._MAKER_;\\n        feeRateModel = state._FEE_RATE_MODEL_;\\n        maintainer = state._MAINTAINER_;\\n    }\\n\\n    /// @notice get a token's reserve in pool\\n    function getTokenReserve(address token) external view returns (uint256) {\\n        return state.balances[token];\\n    }\\n\\n    /// @notice get D3MM contract version\\n    function version() external pure virtual returns (string memory) {\\n        return \\\"D3MM 1.0.0\\\";\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/DODOV3MM/D3Pool/D3Storage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.16;\\n\\nimport \\\"../lib/Types.sol\\\";\\nimport \\\"../lib/Errors.sol\\\";\\nimport \\\"../lib/InitializableOwnable.sol\\\";\\nimport {ReentrancyGuard} from \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\n\\ncontract D3Storage is ReentrancyGuard, InitializableOwnable {\\n    Types.D3MMState internal state;\\n    // record all token flag\\n    // for allFlag, tokenOriIndex represent bit index in allFlag. eg: tokenA has origin index 3, that means (allFlag >> 3) & 1 = token3's flag\\n    // flag = 0 means to reset cumulative. flag = 1 means not to reset cumulative.\\n    uint256 public allFlag;\\n    // cumulative records\\n    mapping(address => Types.TokenCumulative) public tokenCumMap;\\n    bool public isInLiquidation;\\n\\n    // ============= Events ==========\\n    event MakerDeposit(address indexed token, uint256 amount);\\n    event MakerWithdraw(address indexed to, address indexed token, uint256 amount);\\n\\n    // sellOrNot = 0 means sell, 1 means buy.\\n    event Swap(\\n        address to,\\n        address fromToken,\\n        address toToken,\\n        uint256 payFromAmount,\\n        uint256 receiveToAmount,\\n        uint256 swapFee,\\n        uint256 mtFee,\\n        uint256 sellOrNot\\n    );\\n\\n    modifier poolOngoing() {\\n        require(isInLiquidation == false, Errors.POOL_NOT_ONGOING);\\n        _;\\n    }\\n\\n    modifier onlyVault() {\\n        require(msg.sender == state._D3_VAULT_, Errors.NOT_VAULT);\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/DODOV3MM/D3Pool/D3Trading.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.16;\\n\\nimport \\\"../lib/PMMRangeOrder.sol\\\";\\nimport \\\"../lib/Errors.sol\\\";\\nimport {IDODOSwapCallback} from \\\"../intf/IDODOSwapCallback.sol\\\";\\nimport {ID3Maker} from \\\"../intf/ID3Maker.sol\\\";\\nimport {ID3Vault} from \\\"../intf/ID3Vault.sol\\\";\\nimport {D3Funding} from \\\"./D3Funding.sol\\\";\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {IERC20Metadata} from \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\nimport {SafeERC20} from \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\n\\ncontract D3Trading is D3Funding {\\n    using SafeERC20 for IERC20;\\n\\n    modifier onlyMaker() {\\n        require(msg.sender == state._MAKER_, \\\"not maker\\\");\\n        _;\\n    }\\n\\n    // =============== Read ===============\\n\\n    /// @notice for external users to read tokenMMInfo\\n    function getTokenMMPriceInfoForRead(\\n        address token\\n    )\\n        external\\n        view\\n        returns (uint256 askDownPrice, uint256 askUpPrice, uint256 bidDownPrice, uint256 bidUpPrice, uint256 swapFee)\\n    {\\n        (Types.TokenMMInfo memory tokenMMInfo, ) =\\n            ID3Maker(state._MAKER_).getTokenMMInfoForPool(token);\\n\\n        askDownPrice = tokenMMInfo.askDownPrice;\\n        askUpPrice = tokenMMInfo.askUpPrice;\\n        bidDownPrice = tokenMMInfo.bidDownPrice;\\n        bidUpPrice = tokenMMInfo.bidUpPrice;\\n        swapFee = tokenMMInfo.swapFeeRate;\\n    }\\n\\n    function getTokenMMOtherInfoForRead(\\n        address token\\n    )\\n        external\\n        view\\n        returns (\\n            uint256 askAmount,\\n            uint256 bidAmount,\\n            uint256 kAsk,\\n            uint256 kBid,\\n            uint256 cumulativeAsk,\\n            uint256 cumulativeBid\\n        )\\n    {\\n        (Types.TokenMMInfo memory tokenMMInfo, uint256 tokenIndex) =\\n            ID3Maker(state._MAKER_).getTokenMMInfoForPool(token);\\n        cumulativeAsk = allFlag >> (tokenIndex) & 1 == 0 ? 0 : tokenCumMap[token].cumulativeAsk;\\n        cumulativeBid = allFlag >> (tokenIndex) & 1 == 0 ? 0 : tokenCumMap[token].cumulativeBid;\\n\\n        bidAmount = tokenMMInfo.bidAmount;\\n        askAmount = tokenMMInfo.askAmount;\\n        kAsk = tokenMMInfo.kAsk;\\n        kBid = tokenMMInfo.kBid;\\n    }\\n\\n    // ============ Swap =============\\n    /// @notice get swap status for internal swap\\n    function getRangeOrderState(\\n        address fromToken,\\n        address toToken\\n    ) public view returns (Types.RangeOrderState memory roState) {\\n        roState.oracle = state._ORACLE_;\\n        uint256 fromTokenIndex;\\n        uint256 toTokenIndex;\\n        (roState.fromTokenMMInfo, fromTokenIndex) = ID3Maker(state._MAKER_).getTokenMMInfoForPool(fromToken);\\n        (roState.toTokenMMInfo, toTokenIndex) = ID3Maker(state._MAKER_).getTokenMMInfoForPool(toToken);\\n\\n        // deal with update flag\\n\\n        roState.fromTokenMMInfo.cumulativeAsk =\\n            allFlag >> (fromTokenIndex) & 1 == 0 ? 0 : tokenCumMap[fromToken].cumulativeAsk;\\n        roState.fromTokenMMInfo.cumulativeBid =\\n            allFlag >> (fromTokenIndex) & 1 == 0 ? 0 : tokenCumMap[fromToken].cumulativeBid;\\n        roState.toTokenMMInfo.cumulativeAsk =\\n            allFlag >> (toTokenIndex) & 1 == 0 ? 0 : tokenCumMap[toToken].cumulativeAsk;\\n        roState.toTokenMMInfo.cumulativeBid =\\n            allFlag >> (toTokenIndex) & 1 == 0 ? 0 : tokenCumMap[toToken].cumulativeBid;\\n    }\\n\\n    /// @notice user sell a certain amount of fromToken,  get toToken\\n    function sellToken(\\n        address to,\\n        address fromToken,\\n        address toToken,\\n        uint256 fromAmount,\\n        uint256 minReceiveAmount,\\n        bytes calldata data\\n    ) external poolOngoing nonReentrant returns (uint256) {\\n        require(ID3Maker(state._MAKER_).checkHeartbeat(), Errors.HEARTBEAT_CHECK_FAIL);\\n\\n        _updateCumulative(fromToken);\\n        _updateCumulative(toToken);\\n\\n        (uint256 payFromAmount, uint256 receiveToAmount, uint256 vusdAmount, uint256 swapFee, uint256 mtFee) =\\n            querySellTokens(fromToken, toToken, fromAmount);\\n        require(receiveToAmount >= minReceiveAmount, Errors.MINRES_NOT_ENOUGH);\\n\\n        _transferOut(to, toToken, receiveToAmount);\\n\\n        // external call & swap callback\\n        IDODOSwapCallback(msg.sender).d3MMSwapCallBack(fromToken, fromAmount, data);\\n        // transfer mtFee to maintainer\\n        _transferOut(state._MAINTAINER_, toToken, mtFee);\\n\\n        require(\\n            IERC20(fromToken).balanceOf(address(this)) - state.balances[fromToken] >= fromAmount,\\n            Errors.FROMAMOUNT_NOT_ENOUGH\\n        );\\n\\n        // record swap\\n        uint256 toTokenDec = IERC20Metadata(toToken).decimals();\\n        _recordSwap(fromToken, toToken, vusdAmount, Types.parseRealAmount(receiveToAmount + swapFee, toTokenDec));\\n        require(checkSafe(), Errors.BELOW_IM_RATIO);\\n\\n        emit Swap(to, fromToken, toToken, payFromAmount, receiveToAmount, swapFee, mtFee, 0);\\n        return receiveToAmount;\\n    }\\n\\n    /// @notice user ask for a certain amount of toToken, fromToken's amount will be determined by toToken's amount\\n    function buyToken(\\n        address to,\\n        address fromToken,\\n        address toToken,\\n        uint256 quoteAmount,\\n        uint256 maxPayAmount,\\n        bytes calldata data\\n    ) external poolOngoing nonReentrant returns (uint256) {\\n        require(ID3Maker(state._MAKER_).checkHeartbeat(), Errors.HEARTBEAT_CHECK_FAIL);\\n\\n        _updateCumulative(fromToken);\\n        _updateCumulative(toToken);\\n\\n        // query amount and transfer out\\n        (uint256 payFromAmount, uint256 receiveToAmount, uint256 vusdAmount, uint256 swapFee, uint256 mtFee) =\\n            queryBuyTokens(fromToken, toToken, quoteAmount);\\n        require(payFromAmount <= maxPayAmount, Errors.MAXPAY_NOT_ENOUGH);\\n\\n        _transferOut(to, toToken, receiveToAmount);\\n\\n        // external call & swap callback\\n        IDODOSwapCallback(msg.sender).d3MMSwapCallBack(fromToken, payFromAmount, data);\\n        // transfer mtFee to maintainer\\n        _transferOut(state._MAINTAINER_, toToken, mtFee);\\n\\n        require(\\n            IERC20(fromToken).balanceOf(address(this)) - state.balances[fromToken] >= payFromAmount,\\n            Errors.FROMAMOUNT_NOT_ENOUGH\\n        );\\n\\n        // record swap\\n        uint256 toTokenDec = IERC20Metadata(toToken).decimals();\\n        _recordSwap(fromToken, toToken, vusdAmount, Types.parseRealAmount(receiveToAmount + swapFee, toTokenDec));\\n        require(checkSafe(), Errors.BELOW_IM_RATIO);\\n\\n        emit Swap(to, fromToken, toToken, payFromAmount, receiveToAmount, swapFee, mtFee, 1);\\n        return payFromAmount;\\n    }\\n\\n    /// @notice user could query sellToken result deducted swapFee, assign fromAmount\\n    /// @return payFromAmount fromToken's amount = fromAmount\\n    /// @return receiveToAmount toToken's amount\\n    /// @return vusdAmount fromToken bid vusd\\n    /// @return swapFee dodo takes the fee\\n    function querySellTokens(\\n        address fromToken,\\n        address toToken,\\n        uint256 fromAmount\\n    ) public view returns (uint256 payFromAmount, uint256 receiveToAmount, uint256 vusdAmount, uint256 swapFee, uint256 mtFee) {\\n        require(fromAmount > 1000, Errors.AMOUNT_TOO_SMALL);\\n        Types.RangeOrderState memory D3State = getRangeOrderState(fromToken, toToken);\\n\\n        {\\n        uint256 fromTokenDec = IERC20Metadata(fromToken).decimals();\\n        uint256 toTokenDec = IERC20Metadata(toToken).decimals();\\n        uint256 fromAmountWithDec18 = Types.parseRealAmount(fromAmount, fromTokenDec);\\n        uint256 receiveToAmountWithDec18;\\n        ( , receiveToAmountWithDec18, vusdAmount) =\\n            PMMRangeOrder.querySellTokens(D3State, fromToken, toToken, fromAmountWithDec18);\\n\\n        receiveToAmount = Types.parseDec18Amount(receiveToAmountWithDec18, toTokenDec);\\n        payFromAmount = fromAmount;\\n        }\\n\\n        receiveToAmount = receiveToAmount > state.balances[toToken] ? state.balances[toToken] : receiveToAmount;\\n\\n        uint256 swapFeeRate = D3State.fromTokenMMInfo.swapFeeRate +  D3State.toTokenMMInfo.swapFeeRate;\\n        swapFee = DecimalMath.mulFloor(receiveToAmount, swapFeeRate);\\n        uint256 mtFeeRate = D3State.fromTokenMMInfo.mtFeeRate +  D3State.toTokenMMInfo.mtFeeRate;\\n        mtFee = DecimalMath.mulFloor(receiveToAmount, mtFeeRate);\\n\\n        return (payFromAmount, receiveToAmount - swapFee, vusdAmount, swapFee, mtFee);\\n    }\\n\\n    /// @notice user could query sellToken result deducted swapFee, assign toAmount\\n    /// @return payFromAmount fromToken's amount\\n    /// @return receiveToAmount toToken's amount = toAmount\\n    /// @return vusdAmount fromToken bid vusd\\n    /// @return swapFee dodo takes the fee\\n    function queryBuyTokens(\\n        address fromToken,\\n        address toToken,\\n        uint256 toAmount\\n    ) public view returns (uint256 payFromAmount, uint256 receiveToAmount, uint256 vusdAmount, uint256 swapFee, uint256 mtFee) {\\n        require(toAmount > 1000, Errors.AMOUNT_TOO_SMALL);\\n        Types.RangeOrderState memory D3State = getRangeOrderState(fromToken, toToken);\\n\\n        // query amount and transfer out\\n        uint256 toAmountWithFee;\\n        {\\n        uint256 swapFeeRate = D3State.fromTokenMMInfo.swapFeeRate +  D3State.toTokenMMInfo.swapFeeRate;\\n        swapFee = DecimalMath.mulFloor(toAmount, swapFeeRate);\\n        uint256 mtFeeRate = D3State.fromTokenMMInfo.mtFeeRate +  D3State.toTokenMMInfo.mtFeeRate;\\n        mtFee = DecimalMath.mulFloor(toAmount, mtFeeRate);\\n        toAmountWithFee = toAmount + swapFee;\\n        }\\n\\n        require(toAmountWithFee <= state.balances[toToken], Errors.BALANCE_NOT_ENOUGH);\\n\\n        uint256 fromTokenDec = IERC20Metadata(fromToken).decimals();\\n        uint256 toTokenDec = IERC20Metadata(toToken).decimals();\\n        uint256 toFeeAmountWithDec18 = Types.parseRealAmount(toAmountWithFee, toTokenDec);\\n        uint256 payFromAmountWithDec18;\\n        (payFromAmountWithDec18, , vusdAmount) =\\n            PMMRangeOrder.queryBuyTokens(D3State, fromToken, toToken, toFeeAmountWithDec18);\\n        payFromAmount = Types.parseDec18Amount(payFromAmountWithDec18, fromTokenDec);\\n        if(payFromAmount == 0) {\\n            payFromAmount = 1;\\n        }\\n\\n        return (payFromAmount, toAmount, vusdAmount, swapFee, mtFee);\\n    }\\n\\n    // ================ internal ==========================\\n\\n    function _recordSwap(address fromToken, address toToken, uint256 fromAmount, uint256 toAmount) internal {\\n        tokenCumMap[fromToken].cumulativeBid += fromAmount;\\n        tokenCumMap[toToken].cumulativeAsk += toAmount;\\n\\n        _updateReserve(fromToken);\\n        _updateReserve(toToken);\\n    }\\n\\n    function _updateCumulative(address token) internal {\\n        uint256 tokenIndex = uint256(ID3Maker(state._MAKER_).getOneTokenOriginIndex(token));\\n        uint256 tokenFlag = (allFlag >> tokenIndex) & 1;\\n        if (tokenFlag == 0) {\\n            tokenCumMap[token].cumulativeAsk = 0;\\n            tokenCumMap[token].cumulativeBid = 0;\\n            allFlag |= (1 << tokenIndex);\\n        }\\n    }\\n\\n    function _transferOut(address to, address token, uint256 amount) internal {\\n        IERC20(token).safeTransfer(to, amount);\\n    }\\n\\n    // ================ call by maker ==========================\\n    function setNewAllFlag(uint256 newFlag) external onlyMaker {\\n        allFlag = newFlag;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/DODOV3MM/D3Vault/D3Vault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.16;\\n\\nimport \\\"./D3VaultFunding.sol\\\";\\nimport \\\"./D3VaultLiquidation.sol\\\";\\n\\ncontract D3Vault is D3VaultFunding, D3VaultLiquidation {\\n    using SafeERC20 for IERC20;\\n    using DecimalMath for uint256;\\n\\n    // ---------- Setting ----------\\n\\n    function addD3PoolByFactory(address pool) external onlyFactory {\\n        require(allPoolAddrMap[pool] == false, Errors.POOL_ALREADY_ADDED);\\n        allPoolAddrMap[pool] = true;\\n        address creator = ID3MM(pool)._CREATOR_();\\n        creatorPoolMap[creator].push(pool);\\n        emit AddPool(pool);\\n    }\\n\\n    function addD3Pool(address pool) external onlyOwner {\\n        require(allPoolAddrMap[pool] == false, Errors.POOL_ALREADY_ADDED);\\n        allPoolAddrMap[pool] = true;\\n        address creator = ID3MM(pool)._CREATOR_();\\n        creatorPoolMap[creator].push(pool);\\n        emit AddPool(pool);\\n    }\\n\\n    // ================= Remove Pool Steps ===================\\n\\n    /// @notice When removing a pool\\n    /// @notice if the pool has enough assets to repay all borrows, we can just repay:\\n    /// @notice removeD3Pool() -> pendingRemovePoolRepayAll(token) -> finishPoolRemove()\\n    /// @notice if not, should go through liquidation process by DODO before repaying token:\\n    /// @notice removeD3Pool() -> liquidateByDODO() -> pendingRemovePoolRepayAll(token) -> finishPoolRemove()\\n    /// @notice if the pool has bad debt, then should go through normal liquidation process instead of repaying token\\n    /// @notice startLiquidation() -> liquidateByDODO() -> finishLiquidation()\\n    /// @notice if the pool doesn't have borrows, we just need two steps:\\n    /// @notice removeD3Pool() -> finishPoolRemove()\\n    function removeD3Pool(address pool) external onlyOwner {\\n        require(_PENDING_REMOVE_POOL_ == address(0), Errors.HAS_POOL_PENDING_REMOVE);\\n        require(allPoolAddrMap[pool] == true, Errors.POOL_NOT_ADDED);\\n        ID3MM(pool).startLiquidation();\\n\\n        allPoolAddrMap[pool] = false;\\n        _PENDING_REMOVE_POOL_ = pool;\\n        address creator = ID3MM(pool)._CREATOR_();\\n        address[] memory poolList = creatorPoolMap[creator];\\n        for (uint256 i = 0; i < poolList.length; i++) {\\n            if (poolList[i] == pool) {\\n                poolList[i] = poolList[poolList.length - 1];\\n                creatorPoolMap[creator] = poolList;\\n                creatorPoolMap[creator].pop();\\n                break;\\n            }\\n        }\\n    }\\n\\n    function pendingRemovePoolRepayAll(address token) external onlyOwner {\\n        _poolRepayAll(_PENDING_REMOVE_POOL_, token);\\n        ID3MM(_PENDING_REMOVE_POOL_).updateReserveByVault(token);\\n    }\\n\\n    function finishPoolRemove() external onlyOwner {\\n        ID3MM(_PENDING_REMOVE_POOL_).finishLiquidation();\\n        emit RemovePool(_PENDING_REMOVE_POOL_);\\n        _PENDING_REMOVE_POOL_ = address(0);\\n    }\\n\\n    // ====================================================\\n\\n    function setCloneFactory(address cloneFactory) external onlyOwner {\\n        _CLONE_FACTORY_ = cloneFactory;\\n    }\\n\\n    function setNewD3Factory(address newFactory) external onlyOwner {\\n        _D3_FACTORY_ = newFactory;\\n        emit SetD3Factory(newFactory);\\n    }\\n\\n    function setNewD3UserQuota(address newQuota) external onlyOwner {\\n        _USER_QUOTA_ = newQuota;\\n        emit SetD3UserQuota(newQuota);\\n    }\\n\\n    function setNewD3PoolQuota(address newQuota) external onlyOwner {\\n        _POOL_QUOTA_ = newQuota;\\n        emit SetD3PoolQuota(newQuota);\\n    }\\n\\n    function setNewOracle(address newOracle) external onlyOwner {\\n        _ORACLE_ = newOracle;\\n        emit SetOracle(newOracle);\\n    }\\n\\n    function setNewRateManager(address newRateManager) external onlyOwner {\\n        _RATE_MANAGER_ = newRateManager;\\n        emit SetRateManager(newRateManager);\\n    }\\n\\n    function setMaintainer(address maintainer) external onlyOwner {\\n        _MAINTAINER_ = maintainer;\\n        emit SetMaintainer(maintainer);\\n    }\\n\\n    function setIM(uint256 newIM) external onlyOwner {\\n        IM = newIM;\\n        emit SetIM(newIM);\\n    }\\n\\n    function setMM(uint256 newMM) external onlyOwner {\\n        MM = newMM;\\n        emit SetMM(newMM);\\n    }\\n\\n    function setDiscount(uint256 discount) external onlyOwner {\\n        DISCOUNT = discount;\\n        emit SetDiscount(discount);\\n    }\\n\\n    function setDTokenTemplate(address dTokenTemplate) external onlyOwner {\\n        _D3TOKEN_LOGIC_ = dTokenTemplate;\\n        emit SetDTokenTemplate(dTokenTemplate);\\n    }\\n\\n    function addRouter(address router) external onlyOwner {\\n        allowedRouter[router] = true;\\n        emit AddRouter(router);\\n    }\\n\\n    function removeRouter(address router) external onlyOwner {\\n        allowedRouter[router] = false;\\n        emit RemoveRouter(router);\\n    }\\n\\n    function addLiquidator(address liquidator) external onlyOwner {\\n        allowedLiquidator[liquidator] = true;\\n        emit AddLiquidator(liquidator);\\n    }\\n\\n    function removeLiquidator(address liquidator) external onlyOwner {\\n        allowedLiquidator[liquidator] = false;\\n        emit RemoveLiquidator(liquidator);\\n    }\\n\\n    function addNewToken(\\n        address token,\\n        uint256 maxDeposit,\\n        uint256 maxCollateral,\\n        uint256 collateralWeight,\\n        uint256 debtWeight,\\n        uint256 reserveFactor\\n    ) external onlyOwner {\\n        require(!tokens[token], Errors.TOKEN_ALREADY_EXIST);\\n        require(collateralWeight < 1e18 && debtWeight > 1e18, Errors.WRONG_WEIGHT);\\n        require(reserveFactor < 1e18, Errors.WRONG_RESERVE_FACTOR);\\n        tokens[token] = true;\\n        tokenList.push(token);\\n        address dToken = createDToken(token);\\n        AssetInfo storage info = assetInfo[token];\\n        info.dToken = dToken;\\n        info.reserveFactor = reserveFactor;\\n        info.borrowIndex = 1e18;\\n        info.accrualTime = block.timestamp;\\n        info.maxDepositAmount = maxDeposit;\\n        info.maxCollateralAmount = maxCollateral;\\n        info.collateralWeight = collateralWeight;\\n        info.debtWeight = debtWeight;\\n        emit AddToken(token);\\n    }\\n\\n    function createDToken(address token) internal returns (address) {\\n        address d3Token = ICloneFactory(_CLONE_FACTORY_).clone(_D3TOKEN_LOGIC_);\\n        IDToken(d3Token).init(token, address(this));\\n        return d3Token;\\n    }\\n\\n    function setToken(\\n        address token,\\n        uint256 maxDeposit,\\n        uint256 maxCollateral,\\n        uint256 collateralWeight,\\n        uint256 debtWeight,\\n        uint256 reserveFactor\\n    ) external onlyOwner {\\n        require(tokens[token], Errors.TOKEN_NOT_EXIST);\\n        require(collateralWeight < 1e18 && debtWeight > 1e18, Errors.WRONG_WEIGHT);\\n        require(reserveFactor < 1e18, Errors.WRONG_RESERVE_FACTOR);\\n        AssetInfo storage info = assetInfo[token];\\n        info.maxDepositAmount = maxDeposit;\\n        info.maxCollateralAmount = maxCollateral;\\n        info.collateralWeight = collateralWeight;\\n        info.debtWeight = debtWeight;\\n        info.reserveFactor = reserveFactor;\\n        emit SetToken(token);\\n    }\\n\\n    function withdrawReserves(address token, uint256 amount) external nonReentrant allowedToken(token) onlyOwner {\\n        require(_MAINTAINER_ != address(0), Errors.MAINTAINER_NOT_SET);\\n        accrueInterest(token);\\n        AssetInfo storage info = assetInfo[token];\\n        uint256 totalReserves = info.totalReserves;\\n        uint256 withdrawnReserves = info.withdrawnReserves;\\n        require(amount <= totalReserves - withdrawnReserves, Errors.WITHDRAW_AMOUNT_EXCEED);\\n        info.withdrawnReserves = info.withdrawnReserves + amount;\\n        info.balance = info.balance - amount;\\n        IERC20(token).safeTransfer(_MAINTAINER_, amount);\\n        emit WithdrawReserves(token, amount);\\n    }\\n\\n    /// @notice If someone directly transfer large amounts of a token into vault, may block the userDeposit() function\\n    /// @notice Owner can use this function to transfer out the token to unblock deposition.\\n    // function withdrawLeft(address token) external nonReentrant allowedToken(token) onlyOwner {\\n    //     require(_MAINTAINER_ != address(0), Errors.MAINTAINER_NOT_SET);\\n    //     AssetInfo storage info = assetInfo[token];\\n    //     uint256 balance = IERC20(token).balanceOf(address(this));\\n    //     if (balance > info.balance) {\\n    //         IERC20(token).safeTransfer(_MAINTAINER_, balance - info.balance);\\n    //     }\\n    // }\\n\\n    // ---------- View ----------\\n\\n    function getAssetInfo(address token)\\n        external\\n        view\\n        returns (\\n            address dToken,\\n            uint256 totalBorrows,\\n            uint256 totalReserves,\\n            uint256 reserveFactor,\\n            uint256 borrowIndex,\\n            uint256 accrualTime,\\n            uint256 maxDepositAmount,\\n            uint256 collateralWeight,\\n            uint256 debtWeight,\\n            uint256 withdrawnReserves,\\n            uint256 balance\\n        )\\n    {\\n        AssetInfo storage info = assetInfo[token];\\n        balance = info.balance;\\n        dToken = info.dToken;\\n        totalBorrows = info.totalBorrows;\\n        totalReserves = info.totalReserves;\\n        reserveFactor = info.reserveFactor;\\n        borrowIndex = info.borrowIndex;\\n        accrualTime = info.accrualTime;\\n        maxDepositAmount = info.maxDepositAmount;\\n        collateralWeight = info.collateralWeight;\\n        debtWeight = info.debtWeight;\\n        withdrawnReserves = info.withdrawnReserves;\\n    }\\n\\n    function getIMMM() external view returns (uint256, uint256) {\\n        return (IM, MM);\\n    }\\n\\n    function getTokenList() external view returns (address[] memory) {\\n        return tokenList;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/DODOV3MM/D3Vault/D3VaultFunding.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.16;\\n\\nimport {ICloneFactory} from \\\"../lib/CloneFactory.sol\\\";\\nimport \\\"./D3VaultStorage.sol\\\";\\nimport \\\"../../intf/ID3Oracle.sol\\\";\\nimport \\\"../intf/ID3UserQuota.sol\\\";\\nimport \\\"../intf/ID3PoolQuota.sol\\\";\\nimport \\\"../intf/ID3MM.sol\\\";\\nimport \\\"../intf/IDToken.sol\\\";\\nimport \\\"../intf/ID3RateManager.sol\\\";\\n\\n/// @title D3VaultFunding\\n/// @notice This contract defines the fund management of D3Vault.\\n/// @notice Users (LP) deposit funds into vault to earn interests; D3Pools borrows funds from vault to make market.\\n/// @notice Part of the borrow interests will become the reserve fund.\\n/// @notice The borrow interest rate is dynamicly changing with fund utilization ratio, and is caculated by D3RateManager.\\n/// @notice The fund utilization ratio is defined as U = borrows / (cash + borrows - reserves)\\n/// @notice Users who deposit funds into vault will receive certain amounts of corresponding dToken. The amount is calculated by the exchange rate.\\n/// @notice The exchange rate between dToken and underlying token is defined as exchangeRate = (cash + totalBorrows -reserves) / dTokenSupply\\n/// @notice As time passes, totalBorrows will increase, so does the dToken exchangeRate. That's how users earn interests with dToken.\\ncontract D3VaultFunding is D3VaultStorage {\\n    using SafeERC20 for IERC20;\\n    using DecimalMath for uint256;\\n\\n    // ---------- LP user Fund ----------\\n\\n    /// @notice user should transfer token to vault before call this function\\n    function userDeposit(address user, address token) external nonReentrant allowedToken(token) returns(uint256 dTokenAmount) {\\n        accrueInterest(token);\\n\\n        AssetInfo storage info = assetInfo[token];\\n        uint256 realBalance = IERC20(token).balanceOf(address(this));\\n        uint256 amount = realBalance  - info.balance;\\n        require(ID3UserQuota(_USER_QUOTA_).checkQuota(user, token, amount), Errors.EXCEED_QUOTA);\\n        uint256 exchangeRate = _getExchangeRate(token);\\n        uint256 totalDToken = IDToken(info.dToken).totalSupply();\\n        require(totalDToken.mul(exchangeRate) + amount <= info.maxDepositAmount, Errors.EXCEED_MAX_DEPOSIT_AMOUNT);\\n        dTokenAmount = amount.div(exchangeRate);\\n\\n        IDToken(info.dToken).mint(user, dTokenAmount);\\n        info.balance = realBalance;\\n\\n        emit UserDeposit(user, token, amount, dTokenAmount);\\n    }\\n\\n    /// @param to who receive tokens\\n    /// @param user who pay dTokens\\n    /// @param token original token address\\n    /// @param dTokenAmount dtoken the token record amount\\n    function userWithdraw(address to, address user, address token, uint256 dTokenAmount) external nonReentrant allowedToken(token) returns(uint256 amount) {\\n        accrueInterest(token);\\n        AssetInfo storage info = assetInfo[token];\\n        require(dTokenAmount <= IDToken(info.dToken).balanceOf(msg.sender), Errors.DTOKEN_BALANCE_NOT_ENOUGH);\\n\\n        amount = dTokenAmount.mul(_getExchangeRate(token));\\n        IDToken(info.dToken).burn(msg.sender, dTokenAmount);\\n        IERC20(token).safeTransfer(to, amount);\\n        info.balance = info.balance - amount;\\n\\n        // used for calculate user withdraw amount\\n        // this function could be called from d3Proxy, so we need \\\"user\\\" param\\n        // In the meantime, some users may hope to use this function directly,\\n        // to prevent these users fill \\\"user\\\" param with wrong addresses,\\n        // we use \\\"msg.sender\\\" param to check.\\n        emit UserWithdraw(msg.sender, user, token, amount, dTokenAmount);\\n    }\\n\\n    // ---------- Pool Fund ----------\\n    function poolBorrow(address token, uint256 amount) external nonReentrant allowedToken(token) onlyPool {\\n        uint256 quota = ID3PoolQuota(_POOL_QUOTA_).getPoolQuota(msg.sender, token);\\n        accrueInterest(token);\\n\\n        AssetInfo storage info = assetInfo[token];\\n        BorrowRecord storage record = info.borrowRecord[msg.sender];\\n        uint256 usedQuota = _borrowAmount(record.amount, record.interestIndex, info.borrowIndex); // borrowAmount = record.amount * newIndex / oldIndex\\n        require(amount + usedQuota <= quota, Errors.EXCEED_QUOTA);\\n        require(amount <= info.balance - (info.totalReserves - info.withdrawnReserves), Errors.AMOUNT_EXCEED_VAULT_BALANCE);\\n\\n        uint256 interests = usedQuota - record.amount;\\n\\n        record.amount = usedQuota + amount;\\n        record.interestIndex = info.borrowIndex;\\n        info.totalBorrows = info.totalBorrows + amount;\\n        info.balance = info.balance - amount; \\n        IERC20(token).safeTransfer(msg.sender, amount);\\n\\n        emit PoolBorrow(msg.sender, token, amount, interests);\\n    }\\n\\n    function poolRepay(address token, uint256 amount) external nonReentrant allowedToken(token) onlyPool {\\n        require(!ID3MM(msg.sender).isInLiquidation(), Errors.ALREADY_IN_LIQUIDATION);\\n\\n        accrueInterest(token);\\n\\n        AssetInfo storage info = assetInfo[token];\\n        BorrowRecord storage record = info.borrowRecord[msg.sender];\\n        uint256 borrows = _borrowAmount(record.amount, record.interestIndex, info.borrowIndex); // borrowAmount = record.amount * newIndex / oldIndex\\n        require(amount <= borrows, Errors.AMOUNT_EXCEED);\\n\\n        uint256 interests = borrows - record.amount;\\n\\n        record.amount = borrows - amount;\\n        record.interestIndex = info.borrowIndex;\\n        if (info.totalBorrows < amount) {\\n            info.totalBorrows = 0;\\n        } else {\\n            info.totalBorrows = info.totalBorrows - amount;\\n        }\\n        info.balance = info.balance + amount;\\n        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\\n\\n        emit PoolRepay(msg.sender, token, amount, interests);\\n    }\\n\\n    function poolRepayAll(address token) external nonReentrant allowedToken(token) onlyPool {\\n        require(!ID3MM(msg.sender).isInLiquidation(), Errors.ALREADY_IN_LIQUIDATION);\\n        _poolRepayAll(msg.sender, token);\\n    }\\n\\n    function _poolRepayAll(address pool, address token) internal {\\n        accrueInterest(token);\\n\\n        AssetInfo storage info = assetInfo[token];\\n        BorrowRecord storage record = info.borrowRecord[pool];\\n        uint256 amount = _borrowAmount(record.amount, record.interestIndex, info.borrowIndex); // borrowAmount = record.amount * newIndex / oldIndex\\n\\n        uint256 interests = amount - record.amount;\\n\\n        record.amount = 0;\\n        record.interestIndex = info.borrowIndex;\\n        if (info.totalBorrows < amount) {\\n            info.totalBorrows = 0;\\n        } else {\\n            info.totalBorrows = info.totalBorrows - amount;\\n        }\\n        info.balance = info.balance + amount;\\n        IERC20(token).safeTransferFrom(pool, address(this), amount);\\n\\n        emit PoolRepay(pool, token, amount, interests);\\n    }\\n\\n    // ---------- Interest ----------\\n\\n    /// @notice Accrue interest for a token\\n    /// @notice Step1: get time past\\n    /// @notice Step2: get borrow rate\\n    /// @notice Step3: calculate compound interest rate during the past time\\n    /// @notice Step4: calculate increased borrows, reserves\\n    /// @notice Step5: update borrows, reserves, accrual time, borrowIndex\\n    /// @notice borrowIndex is the accrual interest rate\\n    function accrueInterestForRead(address token) public view returns(uint256 totalBorrowsNew, uint256 totalReservesNew, uint256 borrowIndexNew, uint256 accrualTime) {\\n        AssetInfo storage info = assetInfo[token];\\n\\n        uint256 currentTime = block.timestamp;\\n        uint256 deltaTime = currentTime - info.accrualTime;\\n        if (deltaTime == 0) return(info.totalBorrows, info.totalReserves, info.borrowIndex, currentTime);\\n\\n        uint256 borrowsPrior = info.totalBorrows;\\n        uint256 reservesPrior = info.totalReserves;\\n        uint256 borrowIndexPrior = info.borrowIndex;\\n\\n        uint256 borrowRate = ID3RateManager(_RATE_MANAGER_).getBorrowRate(token, getUtilizationRatio(token));\\n        uint256 borrowRatePerSecond = borrowRate / SECONDS_PER_YEAR;\\n        uint256 compoundInterestRate = getCompoundInterestRate(borrowRatePerSecond, deltaTime);\\n        totalBorrowsNew = borrowsPrior.mul(compoundInterestRate);\\n        totalReservesNew = reservesPrior + (totalBorrowsNew - borrowsPrior).mul(info.reserveFactor);\\n        borrowIndexNew = borrowIndexPrior.mul(compoundInterestRate);\\n\\n        accrualTime = currentTime;\\n    }\\n\\n    /// @notice Accrue interest for a token, change storage\\n    function accrueInterest(address token) public {\\n        (assetInfo[token].totalBorrows, assetInfo[token].totalReserves, assetInfo[token].borrowIndex, assetInfo[token].accrualTime) =\\n        accrueInterestForRead(token);\\n    }\\n\\n    function accrueInterests() public {\\n        for (uint256 i; i < tokenList.length; i++) {\\n            address token = tokenList[i];\\n            accrueInterest(token);\\n        }\\n    }\\n\\n    /// @dev r: interest rate per second (decimals 18)\\n    /// @dev t: total time in seconds\\n    /// @dev (1+r)^t = 1 + rt + t*(t-1)*r^2/2! + t*(t-1)*(t-2)*r^3/3! + ... + t*(t-1)...*(t-n+1)*r^n/n!\\n    function getCompoundInterestRate(uint256 r, uint256 t) public pure returns (uint256) {\\n        if (t < 1) {\\n            return 1e18;\\n        } else if (t < 2) {\\n            return 1e18 + r * t;\\n        } else {\\n            return 1e18 + r * t + r.powFloor(2) * t * (t - 1) / 2;\\n        }\\n    }\\n\\n    // ----------- View ----------\\n\\n    function getPoolLeftQuota(address pool, address token) public view returns(uint256 leftQuota) {\\n        uint256 quota = ID3PoolQuota(_POOL_QUOTA_).getPoolQuota(pool, token);\\n        uint256 oldInterestIndex = assetInfo[token].borrowRecord[pool].interestIndex;\\n        ( , ,uint256 currentInterestIndex, ) = accrueInterestForRead(token);\\n        uint256 usedQuota = _borrowAmount(assetInfo[token].borrowRecord[pool].amount, oldInterestIndex, currentInterestIndex); // borrowAmount = record.amount * newIndex / oldIndex\\n        leftQuota = quota > usedQuota ? quota - usedQuota : 0;\\n    }\\n\\n    /// @notice U = borrows / (cash + borrows - reserves)\\n    function getUtilizationRatio(address token) public view returns (uint256) {\\n        uint256 borrows = getTotalBorrows(token);\\n        uint256 cash = getCash(token);\\n        uint256 reserves = getReservesInVault(token);\\n        if (borrows == 0) return 0;\\n        if (cash + borrows <= reserves) return 1e18;    // Utilization Ratio is 100%\\n        return borrows.div(cash + borrows - reserves);\\n    }\\n\\n    function getBorrowRate(address token) public view returns (uint256 rate) {\\n        rate = ID3RateManager(_RATE_MANAGER_).getBorrowRate(token, getUtilizationRatio(token));\\n    }\\n\\n    function getCash(address token) public view returns (uint256) {\\n        return assetInfo[token].balance;\\n    }\\n\\n    function getTotalBorrows(address token) public view returns (uint256) {\\n        return assetInfo[token].totalBorrows;\\n    }\\n\\n    function getReservesInVault(address token) public view returns (uint256) {\\n        AssetInfo storage info = assetInfo[token];\\n        return info.totalReserves - info.withdrawnReserves;\\n    }\\n\\n    /// @notice exchangeRate = (cash + totalBorrows -reserves) / dTokenSupply\\n    /// @notice Make sure accrueInterests or accrueInterest(token) is called before\\n    function _getExchangeRate(address token) internal view returns (uint256) {\\n        AssetInfo storage info = assetInfo[token];\\n        uint256 cash = getCash(token);\\n        uint256 dTokenSupply = IERC20(info.dToken).totalSupply();\\n        if (dTokenSupply == 0) { return 1e18; }\\n        return (cash + info.totalBorrows - (info.totalReserves - info.withdrawnReserves)).div(dTokenSupply);\\n    } \\n\\n    /// @notice Make sure accrueInterests or accrueInterest(token) is called before\\n    function _getBalanceAndBorrows(address pool, address token) internal view returns (uint256, uint256) {\\n        AssetInfo storage info = assetInfo[token];\\n        BorrowRecord storage record = info.borrowRecord[pool];\\n\\n        uint256 balance = ID3MM(pool).getTokenReserve(token);\\n        uint256 borrows = _borrowAmount(record.amount, record.interestIndex, info.borrowIndex); // borrowAmount = record.amount * newIndex / oldIndex\\n\\n        return (balance, borrows);\\n    }\\n\\n    /// @notice Make sure accrueInterests() is called before calling this function\\n    function _getTotalDebtValue(address pool) internal view returns (uint256 totalDebt) {\\n        for (uint256 i = 0; i < tokenList.length; i++) {\\n            address token = tokenList[i];\\n            AssetInfo storage info = assetInfo[token];\\n            BorrowRecord memory record = info.borrowRecord[pool];\\n            uint256 borrows = _borrowAmount(record.amount, record.interestIndex, info.borrowIndex); // borrowAmount = record.amount * newIndex / oldIndex\\n            uint256 price = ID3Oracle(_ORACLE_).getPrice(token);\\n            totalDebt += borrows.mul(price);\\n        }\\n    }\\n\\n    function getTotalAssetsValue(address pool) public view returns (uint256 totalValue) {\\n        for (uint256 i = 0; i < tokenList.length; i++) {\\n            address token = tokenList[i];\\n            uint256 price = ID3Oracle(_ORACLE_).getPrice(token);\\n            totalValue += DecimalMath.mul(ID3MM(pool).getTokenReserve(token), price);\\n        }\\n    }\\n\\n    /// @notice Make sure accrueInterests() is called before\\n    /// @notice net = balance - borrowed\\n    /// @notice collateral = sum(min(positive net, maxCollateralAmount\uff09* weight * price)\\n    /// @notice debt = sum(negative net * weight * price)\\n    /// @notice collateralRatio = collateral / debt\\n    function _getCollateralRatio(address pool) internal view returns (uint256) {\\n        uint256 collateral = 0;\\n        uint256 debt = 0;\\n        for (uint256 i; i < tokenList.length; i++) {\\n            address token = tokenList[i];\\n            AssetInfo storage info = assetInfo[token];\\n\\n            (uint256 balance, uint256 borrows) = _getBalanceAndBorrows(pool, token);\\n            uint256 price = ID3Oracle(_ORACLE_).getPrice(token);\\n            if (balance >= borrows) {\\n                collateral += min(balance - borrows, info.maxCollateralAmount).mul(info.collateralWeight).mul(price);\\n            } else {\\n                debt += (borrows - balance).mul(info.debtWeight).mul(price);\\n            }\\n        }\\n        return _ratioDiv(collateral, debt);\\n    }\\n\\n    function checkSafe(address pool) public view returns (bool) {\\n        return getCollateralRatio(pool) >  1e18 + IM;\\n    }\\n\\n    function checkBorrowSafe(address pool) public view returns (bool) {\\n        return getCollateralRatioBorrow(pool) > IM;\\n    }\\n\\n    function checkCanBeLiquidated(address pool) public view returns (bool) {\\n        return getCollateralRatio(pool) < 1e18 + MM;\\n    }\\n\\n    function checkCanBeLiquidatedAfterAccrue(address pool) public view returns (bool) {\\n        return _getCollateralRatio(pool) < 1e18 + MM;\\n    }\\n\\n    function checkBadDebt(address pool) public view returns (bool) {\\n        uint256 totalAssetValue = getTotalAssetsValue(pool);\\n        uint256 totalDebtValue = getTotalDebtValue(pool);\\n        return totalAssetValue < totalDebtValue;\\n    }\\n\\n    function checkBadDebtAfterAccrue(address pool) public view returns (bool) {\\n        uint256 totalAssetValue = getTotalAssetsValue(pool);\\n        uint256 totalDebtValue = _getTotalDebtValue(pool);\\n        return totalAssetValue < totalDebtValue;\\n    }\\n\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a <= b ? a : b;\\n    }\\n\\n    function _ratioDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0 && b == 0) {\\n            return 1e18;\\n        } else if (a == 0 && b != 0) {\\n            return 0;\\n        } else if (a != 0 && b == 0) {\\n            return type(uint256).max;\\n        } else {\\n            return a.div(b);\\n        }\\n    }\\n\\n    function _borrowAmount(uint256 amount, uint256 oldIndex, uint256 newIndex) internal pure returns (uint256) {\\n        if (oldIndex == 0) { oldIndex = 1e18; }\\n        if (oldIndex > newIndex) { oldIndex = newIndex; }\\n        return amount * newIndex / oldIndex;\\n    }\\n\\n    // ======================= Read Only =======================\\n\\n    function getExchangeRate(address token) public view returns(uint256 exchangeRate) {\\n        (uint256 totalBorrows, uint256 totalReserves, ,) = accrueInterestForRead(token);\\n        uint256 cash = getCash(token);\\n        uint256 dTokenSupply = IERC20(assetInfo[token].dToken).totalSupply();\\n        if (dTokenSupply == 0) { return 1e18; }\\n        exchangeRate = (cash + totalBorrows - (totalReserves - assetInfo[token].withdrawnReserves)).div(dTokenSupply);\\n    }\\n\\n    function getLatestBorrowIndex(address token) public view returns (uint256 borrowIndex) {\\n        AssetInfo storage info = assetInfo[token];\\n        uint256 deltaTime = block.timestamp - info.accrualTime;\\n        uint256 borrowRate = getBorrowRate(token);\\n        uint256 borrowRatePerSecond = borrowRate / SECONDS_PER_YEAR;\\n        uint256 compoundInterestRate = getCompoundInterestRate(borrowRatePerSecond, deltaTime);\\n        borrowIndex = info.borrowIndex.mul(compoundInterestRate);\\n    }\\n\\n    function getPoolBorrowAmount(address pool, address token) public view returns (uint256 amount) {\\n        BorrowRecord storage record = assetInfo[token].borrowRecord[pool];\\n        uint256 borrowIndex = getLatestBorrowIndex(token);\\n        amount = _borrowAmount(record.amount, record.interestIndex, borrowIndex); // borrowAmount = record.amount * newIndex / oldIndex\\n    }\\n\\n    function getTotalDebtValue(address pool) public view returns (uint256 totalDebt) {\\n        for (uint256 i = 0; i < tokenList.length; i++) {\\n            address token = tokenList[i];\\n            uint256 borrowAmount = getPoolBorrowAmount(pool, token);\\n            uint256 price = ID3Oracle(_ORACLE_).getPrice(token);\\n            totalDebt += borrowAmount.mul(price);\\n        }\\n    }\\n\\n    function getBalanceAndBorrows(address pool, address token) public view returns (uint256, uint256) {\\n        uint256 balance = ID3MM(pool).getTokenReserve(token);\\n        uint256 borrows = getPoolBorrowAmount(pool, token);\\n        return (balance, borrows);\\n    }\\n\\n    function getCollateralRatio(address pool) public view returns (uint256) {\\n        uint256 collateral = 0;\\n        uint256 debt = 0;\\n        for (uint256 i; i < tokenList.length; i++) {\\n            address token = tokenList[i];\\n            AssetInfo storage info = assetInfo[token];\\n\\n            (uint256 balance, uint256 borrows) = getBalanceAndBorrows(pool, token);\\n            uint256 price = ID3Oracle(_ORACLE_).getPrice(token);\\n            \\n            if (balance >= borrows) {\\n                collateral += min(balance - borrows, info.maxCollateralAmount).mul(info.collateralWeight).mul(price);\\n            } else {\\n                debt += (borrows - balance).mul(info.debtWeight).mul(price);\\n            }\\n        }\\n        return _ratioDiv(collateral, debt);\\n    }\\n    \\n    /// @notice collateralRatioBorrow = \u2211[min(maxCollateralAmount\uff0cbalance - borrows\uff09] / \u2211borrows\\n    function getCollateralRatioBorrow(address pool) public view returns (uint256) {\\n        uint256 balanceSumPositive = 0;\\n        uint256 balanceSumNegative = 0;\\n        uint256 borrowedSum = 0;\\n        for (uint256 i; i < tokenList.length; i++) {\\n            address token = tokenList[i];\\n\\n            (uint256 balance, uint256 borrows) = getBalanceAndBorrows(pool, token);\\n            uint256 price = ID3Oracle(_ORACLE_).getPrice(token);\\n\\n            if (balance >= borrows) {\\n                balanceSumPositive += min(balance - borrows, assetInfo[token].maxCollateralAmount).mul(price);\\n            } else {\\n                balanceSumNegative += (borrows - balance).mul(price);\\n            }\\n\\n            borrowedSum += borrows.mul(price);\\n        }\\n        \\n        uint256 balanceSum = balanceSumPositive < balanceSumNegative ? 0 : balanceSumPositive - balanceSumNegative;\\n        return _ratioDiv(balanceSum, borrowedSum);\\n    }\\n\\n    function getCumulativeBorrowRate(address pool, address token) external view returns (uint256 cumulativeRate, uint256 currentAmount) {\\n        BorrowRecord storage record = assetInfo[token].borrowRecord[pool];\\n        uint256 borrowIndex = getLatestBorrowIndex(token);\\n        cumulativeRate = borrowIndex.div(record.interestIndex == 0 ? 1e18 : record.interestIndex);\\n        currentAmount = record.amount;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/DODOV3MM/D3Vault/D3VaultLiquidation.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.16;\\n\\nimport \\\"./D3VaultFunding.sol\\\";\\n\\ncontract D3VaultLiquidation is D3VaultFunding {\\n    using SafeERC20 for IERC20;\\n    using DecimalMath for uint256;\\n\\n    function isPositiveNetWorthAsset(address pool, address token) internal view returns (bool) {\\n        (uint256 balance, uint256 borrows) = _getBalanceAndBorrows(pool, token);\\n        return balance >= borrows;\\n    }\\n\\n    function getPositiveNetWorthAsset(address pool, address token) internal view returns (uint256) {\\n        (uint256 balance, uint256 borrows) = _getBalanceAndBorrows(pool, token);\\n        if (balance > borrows) {\\n            return balance - borrows;\\n        } else {\\n            return 0;\\n        }\\n    }\\n\\n    /// @notice public liquidate function, repay pool negative worth token and get collateral tokens with discount\\n    /// @param pool pool address, must be in belowMM\\n    /// @param collateral pool collateral, any positive worth token pool has\\n    /// @param collateralAmount collateral amount liquidator claim\\n    /// @param debt pool debt, any negative worth token pool has\\n    /// @param debtToCover debt amount liquidator repay\\n    function liquidate(\\n        address pool,\\n        address collateral,\\n        uint256 collateralAmount,\\n        address debt,\\n        uint256 debtToCover\\n    ) external nonReentrant {\\n        accrueInterests();\\n\\n        require(!ID3MM(pool).isInLiquidation(), Errors.ALREADY_IN_LIQUIDATION);\\n        require(!checkBadDebtAfterAccrue(pool), Errors.HAS_BAD_DEBT);\\n        require(checkCanBeLiquidatedAfterAccrue(pool), Errors.CANNOT_BE_LIQUIDATED);\\n        require(isPositiveNetWorthAsset(pool, collateral), Errors.INVALID_COLLATERAL_TOKEN);\\n        require(!isPositiveNetWorthAsset(pool, debt), Errors.INVALID_DEBT_TOKEN);\\n        require(getPositiveNetWorthAsset(pool, collateral) >= collateralAmount, Errors.COLLATERAL_AMOUNT_EXCEED);\\n        \\n        uint256 collateralTokenPrice = ID3Oracle(_ORACLE_).getPrice(collateral);\\n        uint256 debtTokenPrice = ID3Oracle(_ORACLE_).getPrice(debt);\\n        uint256 collateralAmountMax = debtToCover.mul(debtTokenPrice).div(collateralTokenPrice.mul(DISCOUNT));\\n        require(collateralAmount <= collateralAmountMax, Errors.COLLATERAL_AMOUNT_EXCEED);\\n\\n        AssetInfo storage info = assetInfo[debt];\\n        BorrowRecord storage record = info.borrowRecord[pool];\\n        uint256 borrows = _borrowAmount(record.amount, record.interestIndex, info.borrowIndex); // borrowAmount = record.amount * newIndex / oldIndex\\n        require(debtToCover <= borrows, Errors.DEBT_TO_COVER_EXCEED);\\n        IERC20(debt).safeTransferFrom(msg.sender, address(this), debtToCover);\\n        \\n        if (info.totalBorrows < debtToCover) {\\n            info.totalBorrows = 0;\\n        } else {\\n            info.totalBorrows = info.totalBorrows - debtToCover;\\n        }\\n        info.balance = info.balance + debtToCover;\\n\\n        record.amount = borrows - debtToCover;\\n        record.interestIndex = info.borrowIndex;\\n        IERC20(collateral).safeTransferFrom(pool, msg.sender, collateralAmount);\\n        ID3MM(pool).updateReserveByVault(collateral);\\n        \\n        emit Liquidate(pool, collateral, collateralAmount, debt, debtToCover);\\n    }\\n\\n    // ---------- Liquidate by DODO team ----------\\n    /// @notice if occuring bad debt, dodo team will start liquidation to balance debt\\n    function startLiquidation(address pool) external onlyLiquidator nonReentrant {\\n        accrueInterests();\\n\\n        require(!ID3MM(pool).isInLiquidation(), Errors.ALREADY_IN_LIQUIDATION);\\n        require(checkCanBeLiquidatedAfterAccrue(pool), Errors.CANNOT_BE_LIQUIDATED);\\n        ID3MM(pool).startLiquidation();\\n\\n        uint256 totalAssetValue = getTotalAssetsValue(pool);\\n        uint256 totalDebtValue = _getTotalDebtValue(pool);\\n        require(totalAssetValue < totalDebtValue, Errors.NO_BAD_DEBT);\\n\\n        uint256 ratio = totalAssetValue.div(totalDebtValue);\\n\\n        for (uint256 i; i < tokenList.length; i++) {\\n            address token = tokenList[i];\\n            AssetInfo storage info = assetInfo[token];\\n            BorrowRecord storage record = info.borrowRecord[pool];\\n            uint256 debt = _borrowAmount(record.amount, record.interestIndex, info.borrowIndex).mul(ratio); // borrowAmount = record.amount * newIndex / oldIndex\\n            liquidationTarget[pool][token] = debt;\\n        }\\n        emit StartLiquidation(pool);\\n    }\\n\\n    function liquidateByDODO(\\n        address pool,\\n        LiquidationOrder calldata order,\\n        bytes calldata routeData,\\n        address router\\n    ) external onlyLiquidator onlyRouter(router) nonReentrant {\\n        require(ID3MM(pool).isInLiquidation(), Errors.NOT_IN_LIQUIDATION);\\n\\n        uint256 toTokenReserve = IERC20(order.toToken).balanceOf(address(this));\\n        uint256 fromTokenValue = DecimalMath.mul(ID3Oracle(_ORACLE_).getPrice(order.fromToken), order.fromAmount);\\n\\n        // swap using Route\\n        {\\n            IERC20(order.fromToken).safeTransferFrom(pool, router, order.fromAmount);\\n            (bool success, bytes memory data) = router.call(routeData);\\n            if (!success) {\\n                assembly {\\n                    revert(add(data, 32), mload(data))\\n                }\\n            }\\n        }\\n\\n        // the transferred-in toToken USD value should not be less than 95% of the transferred-out fromToken\\n        uint256 receivedToToken = IERC20(order.toToken).balanceOf(address(this)) - toTokenReserve;\\n        uint256 toTokenValue = DecimalMath.mul(ID3Oracle(_ORACLE_).getPrice(order.toToken), receivedToToken);\\n\\n        require(toTokenValue >= fromTokenValue.mul(DISCOUNT), Errors.EXCEED_DISCOUNT);\\n        IERC20(order.toToken).safeTransfer(pool, receivedToToken);\\n        ID3MM(pool).updateReserveByVault(order.fromToken);\\n        ID3MM(pool).updateReserveByVault(order.toToken);\\n    }\\n\\n    function finishLiquidation(address pool) external onlyLiquidator nonReentrant {\\n        require(ID3MM(pool).isInLiquidation(), Errors.NOT_IN_LIQUIDATION);\\n        accrueInterests();\\n\\n        bool hasPositiveBalance;\\n        bool hasNegativeBalance;\\n        for (uint256 i; i < tokenList.length; i++) {\\n            address token = tokenList[i];\\n            AssetInfo storage info = assetInfo[token];\\n            uint256 balance = IERC20(token).balanceOf(pool);\\n            uint256 debt = liquidationTarget[pool][token];\\n            int256 difference = int256(balance) - int256(debt);\\n            if (difference > 0) {\\n                require(!hasNegativeBalance, Errors.LIQUIDATION_NOT_DONE);\\n                hasPositiveBalance = true;\\n            } else if (difference < 0) {\\n                require(!hasPositiveBalance, Errors.LIQUIDATION_NOT_DONE);\\n                hasNegativeBalance = true;\\n                debt = balance; // if balance is less than target amount, just repay with balance\\n            }\\n\\n            BorrowRecord storage record = info.borrowRecord[pool];\\n            uint256 borrows = record.amount;\\n            if (borrows == 0) continue;\\n\\n            // note: During liquidation process, the pool's debt will slightly increase due to the generated interests. \\n            // The liquidation process will not repay the interests. Thus all dToken holders will share the loss equally.\\n            uint256 realDebt = _borrowAmount(borrows, record.interestIndex, info.borrowIndex); // borrowAmount = record.amount * newIndex / oldIndex\\n            IERC20(token).safeTransferFrom(pool, address(this), debt);\\n            ID3MM(pool).updateReserveByVault(token);\\n\\n            if (info.totalBorrows < realDebt) {\\n                info.totalBorrows = 0;\\n            } else {\\n                info.totalBorrows = info.totalBorrows - realDebt;\\n            }\\n            info.balance = info.balance + debt;\\n            record.amount = 0;\\n        }\\n\\n        ID3MM(pool).finishLiquidation();\\n        emit FinishLiquidation(pool);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/DODOV3MM/D3Vault/D3VaultStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.16;\\n\\nimport {ReentrancyGuard} from \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {SafeERC20} from \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport {Ownable} from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"../lib/DecimalMath.sol\\\";\\nimport \\\"./Errors.sol\\\";\\n\\nstruct LiquidationOrder {\\n    address fromToken;\\n    address toToken;\\n    uint256 fromAmount;\\n}\\n\\ncontract D3VaultStorage is ReentrancyGuard, Ownable {\\n    address public _D3_FACTORY_;\\n    address public _D3TOKEN_LOGIC_;\\n    address public _CLONE_FACTORY_;\\n    address public _USER_QUOTA_;\\n    address public _POOL_QUOTA_;\\n    address public _ORACLE_;\\n    address public _RATE_MANAGER_;\\n    address public _MAINTAINER_;\\n    address public _PENDING_REMOVE_POOL_;\\n    address[] public tokenList;\\n    uint256 public IM; // 1e18 = 100%\\n    uint256 public MM; // 1e18 = 100%\\n    uint256 public DISCOUNT = 95e16; // 95%\\n    uint256 internal constant SECONDS_PER_YEAR = 31536000;\\n\\n    mapping(address => uint256) public accrualTimestampMap;\\n    mapping(address => bool) public allPoolAddrMap;\\n    mapping(address => address[]) public creatorPoolMap; // user => pool[]\\n    mapping(address => bool) public tokens;\\n    mapping(address => AssetInfo) public assetInfo;\\n    mapping(address => bool) public allowedRouter;\\n    mapping(address => bool) public allowedLiquidator;\\n    mapping(address => mapping(address => uint256)) public liquidationTarget; // pool => (token => amount)\\n\\n    struct AssetInfo {\\n        address dToken;\\n        uint256 balance;\\n        // borrow info\\n        uint256 totalBorrows;\\n        uint256 borrowIndex;\\n        uint256 accrualTime;\\n        // reserve info\\n        uint256 totalReserves;\\n        uint256 withdrawnReserves;\\n        uint256 reserveFactor;\\n        // other info\\n        uint256 maxDepositAmount;\\n        uint256 maxCollateralAmount; // the max amount of token that a pool can use as collateral\\n        uint256 collateralWeight; // 1e18 = 100%; collateralWeight < 1e18\\n        uint256 debtWeight; // 1e18 = 100%; debtWeight > 1e18\\n        mapping(address => BorrowRecord) borrowRecord; // pool address => BorrowRecord\\n    }\\n\\n    struct BorrowRecord {\\n        uint256 amount;\\n        uint256 interestIndex;\\n    }\\n\\n    event PoolBorrow(address indexed pool, address indexed token, uint256 amount, uint256 interests);\\n    event PoolRepay(address indexed pool, address indexed token, uint256 amount, uint256 interests);\\n    event UserDeposit(address indexed user, address indexed token, uint256 amount, uint256 dTokenAmount);\\n    event UserWithdraw(address indexed msgSender, address indexed user, address indexed token, uint256 amount, uint256 dTokenAmount);\\n    event AddPool(address pool);\\n    event RemovePool(address pool);\\n\\n    event SetCloneFactory(address cloneFactory);\\n    event SetD3Factory(address factory);\\n    event SetD3UserQuota(address userQuota);\\n    event SetD3PoolQuota(address poolQuota);\\n    event SetOracle(address oracle);\\n    event SetRateManager(address rateManager);\\n    event SetMaintainer(address maintainer);\\n    event SetIM(uint256 IM);\\n    event SetMM(uint256 MM);\\n    event SetDiscount(uint256 discount);\\n    event SetDTokenTemplate(address template);\\n    \\n    event AddRouter(address router);\\n    event RemoveRouter(address router);\\n    \\n    event AddLiquidator(address liquidator);\\n    event RemoveLiquidator(address liquidator);\\n    \\n    event AddToken(address token);\\n    event SetToken(address token);\\n\\n    event Liquidate(address indexed pool, address indexed collateral, uint256 collateralAmount, address indexed debt, uint256 debtAmount);\\n    event StartLiquidation(address pool);\\n    event FinishLiquidation(address pool);\\n\\n    event WithdrawReserves(address indexed token, uint256 amount);\\n\\n    modifier onlyLiquidator() {\\n        require(allowedLiquidator[msg.sender], Errors.NOT_ALLOWED_LIQUIDATOR);\\n        _;\\n    }\\n\\n    modifier onlyRouter(address router) {\\n        require(allowedRouter[router], Errors.NOT_ALLOWED_ROUTER);\\n        _;\\n    }\\n\\n    modifier onlyPool() {\\n        require(allPoolAddrMap[msg.sender], Errors.NOT_D3POOL);\\n        _;\\n    }\\n\\n    modifier allowedToken(address token) {\\n        require(tokens[token], Errors.NOT_ALLOWED_TOKEN);\\n        _;\\n    }\\n\\n    modifier onlyFactory() {\\n        require(msg.sender == _D3_FACTORY_, Errors.NOT_D3_FACTORY);\\n        _;\\n    }\\n\\n    modifier onlyRemovingPool() {\\n        require(msg.sender == _PENDING_REMOVE_POOL_, Errors.NOT_PENDING_REMOVE_POOL);\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/DODOV3MM/D3Vault/Errors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.16;\\n\\nlibrary Errors {\\n    string public constant POOL_ALREADY_ADDED = \\\"D3VAULT_POOL_ALREADY_ADDED\\\";\\n    string public constant POOL_NOT_ADDED = \\\"D3VAULT_POOL_NOT_ADDED\\\";\\n    string public constant HAS_POOL_PENDING_REMOVE = \\\"D3VAULT_HAS_POOL_PENDING_REMOVE\\\";\\n    string public constant AMOUNT_EXCEED_VAULT_BALANCE = \\\"D3VAULT_AMOUNT_EXCEED_VAULT_BALANCE\\\";\\n    string public constant NOT_ALLOWED_ROUTER = \\\"D3VAULT_NOT_ALLOWED_ROUTER\\\";\\n    string public constant NOT_ALLOWED_LIQUIDATOR = \\\"D3VAULT_NOT_ALLOWED_LIQUIDATOR\\\";\\n    string public constant NOT_PENDING_REMOVE_POOL = \\\"D3VAULT_NOT_PENDING_REMOVE_POOL\\\";\\n    string public constant NOT_D3POOL = \\\"D3VAULT_NOT_D3POOL\\\";\\n    string public constant NOT_ALLOWED_TOKEN = \\\"D3VAULT_NOT_ALLOWED_TOKEN\\\";\\n    string public constant NOT_D3_FACTORY = \\\"D3VAULT_NOT_D3_FACTORY\\\";\\n    string public constant TOKEN_ALREADY_EXIST = \\\"D3VAULT_TOKEN_ALREADY_EXIST\\\";\\n    string public constant TOKEN_NOT_EXIST = \\\"D3VAULT_TOKEN_NOT_EXIST\\\";\\n    string public constant WRONG_WEIGHT = \\\"D3VAULT_WRONG_WEIGHT\\\";\\n    string public constant WRONG_RESERVE_FACTOR = \\\"D3VAULT_RESERVE_FACTOR\\\";\\n    string public constant WITHDRAW_AMOUNT_EXCEED = \\\"D3VAULT_WITHDRAW_AMOUNT_EXCEED\\\";\\n    string public constant MAINTAINER_NOT_SET = \\\"D3VAULT_MAINTAINER_NOT_SET\\\";\\n\\n    // ---------- funding ----------\\n    string public constant EXCEED_QUOTA = \\\"D3VAULT_EXCEED_QUOTA\\\";\\n    string public constant EXCEED_MAX_DEPOSIT_AMOUNT = \\\"D3VAULT_EXCEED_MAX_DEPOSIT_AMOUNT\\\";\\n    string public constant DTOKEN_BALANCE_NOT_ENOUGH = \\\"D3TOKEN_BALANCE_NOT_ENOUGH\\\";\\n    string public constant POOL_NOT_SAFE = \\\"D3VAULT_POOL_NOT_SAFE\\\";\\n    string public constant NOT_ENOUGH_COLLATERAL_FOR_BORROW = \\\"D3VAULT_NOT_ENOUGH_COLLATERAL_FOR_BORROW\\\";\\n    string public constant AMOUNT_EXCEED = \\\"D3VAULT_AMOUNT_EXCEED\\\";\\n    string public constant NOT_RATE_MANAGER = \\\"D3VAULT_NOT_RATE_MANAGER\\\";\\n\\n    // ---------- liquidation ----------\\n    string public constant COLLATERAL_AMOUNT_EXCEED = \\\"D3VAULT_COLLATERAL_AMOUNT_EXCEED\\\";\\n    string public constant CANNOT_BE_LIQUIDATED = \\\"D3VAULT_CANNOT_BE_LIQUIDATED\\\";\\n    string public constant INVALID_COLLATERAL_TOKEN = \\\"D3VAULT_INVALID_COLLATERAL_TOKEN\\\";\\n    string public constant INVALID_DEBT_TOKEN = \\\"D3VAULT_INVALID_DEBT_TOKEN\\\";\\n    string public constant DEBT_TO_COVER_EXCEED = \\\"D3VAULT_DEBT_TO_COVER_EXCEED\\\";\\n    string public constant ALREADY_IN_LIQUIDATION = \\\"D3VAULT_ALREADY_IN_LIQUIDATION\\\";\\n    string public constant STILL_UNDER_MM = \\\"D3VAULT_STILL_UNDER_MM\\\";\\n    string public constant NO_BAD_DEBT = \\\"D3VAULT_NO_BAD_DEBT\\\";\\n    string public constant NOT_IN_LIQUIDATION = \\\"D3VAULT_NOT_IN_LIQUIDATION\\\";\\n    string public constant EXCEED_DISCOUNT = \\\"D3VAULT_EXCEED_DISCOUNT\\\";\\n    string public constant LIQUIDATION_NOT_DONE = \\\"D3VAULT_LIQUIDATION_NOT_DONE\\\";\\n    string public constant HAS_BAD_DEBT = \\\"D3VAULT_HAS_BAD_DEBT\\\";\\n}\\n\"\r\n    },\r\n    \"contracts/DODOV3MM/D3Vault/periphery/D3PoolQuota.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.16;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\ncontract D3PoolQuota is Ownable {\\n    // token => bool\\n    mapping(address => bool) public isUsingQuota;\\n    // token => bool\\n    mapping(address => bool) public hasDefaultQuota;\\n    // token => quota\\n    mapping(address => uint256) public defaultQuota;\\n    // token => (pool => quota)\\n    mapping(address => mapping(address => uint256)) public poolQuota;\\n\\n    /// @notice Set pool quota\\n    /// @param token The token address\\n    /// @param pools The list of pool addresses\\n    /// @param quotas The list of quota corresponding to the pool list\\n    function setPoolQuota(address token, address[] calldata pools, uint256[] calldata quotas) external onlyOwner {\\n        require(pools.length == quotas.length, \\\"PARAMS_LENGTH_NOT_MATCH\\\");\\n        for (uint256 i = 0; i < pools.length; i++) {\\n            poolQuota[token][pools[i]] = quotas[i];\\n        }\\n    }\\n\\n    /// @notice Enable quota for a token\\n    function enableQuota(address token, bool status) external onlyOwner {\\n        isUsingQuota[token] = status;\\n    }\\n\\n    /// @notice Enable default quota for a token\\n    function enableDefaultQuota(address token, bool status) external onlyOwner {\\n        hasDefaultQuota[token] = status;\\n    }\\n\\n    /// @notice Set default quota for a token\\n    /// @notice Default quota means every pool has the same quota\\n    function setDefaultQuota(address token, uint256 amount) external onlyOwner {\\n        defaultQuota[token] = amount;\\n    }\\n\\n    /// @notice Get the pool quota for a token\\n    function getPoolQuota(address pool, address token) external view returns (uint256) {\\n        if (isUsingQuota[token]) {\\n            if (hasDefaultQuota[token]) {\\n                return defaultQuota[token];\\n            } else {\\n                return poolQuota[token][pool];\\n            }\\n        } else {\\n            return type(uint256).max;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/DODOV3MM/D3Vault/periphery/D3RateManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.16;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"../../lib/DecimalMath.sol\\\";\\nimport \\\"../../intf/ID3Vault.sol\\\";\\n/// @title RateManager\\n/// @notice  This contract is responsible for calculating the borrowing interest rate.\\ncontract D3RateManager is Ownable {\\n    using DecimalMath for uint256;\\n\\n    struct RateStrategy {\\n        uint256 baseRate; // 1e18 = 100%\\n        uint256 slope1; // 1e18 = 100%;\\n        uint256 slope2; // 1e18 = 100%;\\n        uint256 optimalUsage; // 1e18 = 100%\\n    }\\n\\n    mapping(address => RateStrategy) public rateStrategyMap; // token => RateStrategy\\n    mapping(address => uint256) public tokenTypeMap; // 1: stable; 2: volatile\\n\\n    /// @notice  Set stable interest rate curve parameters. \\n    /// @param token Token address\\n    /// @param baseRate Initial interest rate.\\n    /// @param slope1 Initial segment interest rate.\\n    /// @param slope2 Second segment interest rate.\\n    /// @param optimalUsage Boundary between the first segment interest rate and the second segment interest rate.\\n    function setStableCurve(\\n        address token,\\n        uint256 baseRate,\\n        uint256 slope1,\\n        uint256 slope2,\\n        uint256 optimalUsage\\n    ) external onlyOwner {\\n        rateStrategyMap[token] = RateStrategy(baseRate, slope1, slope2, optimalUsage);\\n        tokenTypeMap[token] = 1;\\n    }\\n\\n    /// @notice  Set volatile interest rate curve parameters. \\n    /// @param token Token address\\n    /// @param baseRate Initial interest rate.\\n    /// @param slope1 Initial segment interest rate.\\n    /// @param slope2 Second segment interest rate.\\n    /// @param optimalUsage Boundary between the first segment interest rate and the second segment interest rate.\\n    function setVolatileCurve(\\n        address token,\\n        uint256 baseRate,\\n        uint256 slope1,\\n        uint256 slope2,\\n        uint256 optimalUsage\\n    ) external onlyOwner {\\n        rateStrategyMap[token] = RateStrategy(baseRate, slope1, slope2, optimalUsage);\\n        tokenTypeMap[token] = 2;\\n    }\\n\\n    /// @notice  Set token new type \\n    function setTokenType(address token, uint256 tokenType) external onlyOwner {\\n        tokenTypeMap[token] = tokenType;\\n    }\\n    /// @notice  Get the borrowing interest rate for the token.\\n    /// @param token Token address\\n    /// @param utilizationRatio Token utilization rate.\\n    function getBorrowRate(address token, uint256 utilizationRatio) public view returns (uint256 rate) {\\n        RateStrategy memory s = rateStrategyMap[token];\\n        if (utilizationRatio <= s.optimalUsage) {\\n            rate = s.baseRate + utilizationRatio.mul(s.slope1);\\n        } else {\\n            rate = s.baseRate + s.optimalUsage.mul(s.slope1) + (utilizationRatio - s.optimalUsage).mul(s.slope2);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/DODOV3MM/D3Vault/periphery/D3Token.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.16;\\n\\nimport \\\"../../lib/InitializableOwnable.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\n\\n/// @title D3Token\\n/// @notice When LP deposit token into D3MM pool, they receive certain amount of corresponding D3Token.\\n/// @notice D3Token acts as an interest bearing LP token.\\ncontract D3Token is InitializableOwnable, ERC20(\\\"DODOV3 Token\\\", \\\"D3Token\\\") {\\n    address public originToken;\\n    string private _symbol;\\n    string private _name;\\n\\n    // ============ Events ============\\n\\n    event Mint(address indexed user, uint256 value);\\n\\n    event Burn(address indexed user, uint256 value);\\n\\n    // ============ Functions ============\\n\\n    function init(address token, address pool) external {\\n        initOwner(pool);\\n        originToken = token;\\n        _symbol = string.concat(\\\"d3\\\", IERC20Metadata(token).symbol());\\n        _name = string.concat(_symbol, \\\"_\\\", addressToShortString(pool));\\n    }\\n\\n    function symbol() public view override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    function name() public view override returns (string memory) {\\n        return _name;\\n    }\\n\\n    function decimals() public view override returns (uint8) {\\n        return IERC20Metadata(originToken).decimals();\\n    }\\n\\n    /// @dev Transfer token for a specified address\\n    /// @param to The address to transfer to.\\n    /// @param amount The amount to be transferred.\\n    function transfer(address to, uint256 amount) public override returns (bool) {\\n        address owner = _msgSender();\\n        require(amount <= balanceOf(owner), \\\"BALANCE_NOT_ENOUGH\\\");\\n        _transfer(owner, to, amount);\\n        return true;\\n    }\\n\\n    /// @dev Transfer tokens from one address to another\\n    /// @param from address The address which you want to send tokens from\\n    /// @param to address The address which you want to transfer to\\n    /// @param amount uint256 the amount of tokens to be transferred\\n    function transferFrom(address from, address to, uint256 amount) public override returns (bool) {\\n        require(amount <= balanceOf(from), \\\"BALANCE_NOT_ENOUGH\\\");\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, amount);\\n        _transfer(from, to, amount);\\n        return true;\\n    }\\n\\n    /// @notice Mint certain amount of token for user\\n    function mint(address user, uint256 value) external onlyOwner {\\n        _mint(user, value);\\n        emit Mint(user, value);\\n    }\\n\\n    /// @notice Burn certain amount of token on user account\\n    function burn(address user, uint256 value) external onlyOwner {\\n        _burn(user, value);\\n        emit Burn(user, value);\\n    }\\n\\n    /// @notice Convert the address to a shorter string\\n    function addressToShortString(address _addr) public pure returns (string memory) {\\n        bytes32 value = bytes32(uint256(uint160(_addr)));\\n        bytes memory alphabet = \\\"0123456789abcdef\\\";\\n\\n        bytes memory str = new bytes(8);\\n        for (uint256 i = 0; i < 4; i++) {\\n            str[i * 2] = alphabet[uint8(value[i + 12] >> 4)];\\n            str[1 + i * 2] = alphabet[uint8(value[i + 12] & 0x0f)];\\n        }\\n        return string(str);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/DODOV3MM/D3Vault/periphery/D3UserQuota.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.16;\\n\\nimport {Ownable} from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport {IERC20} from \\\"../../../intf/IERC20.sol\\\";\\nimport {ID3UserQuota} from \\\"../../intf/ID3UserQuota.sol\\\";\\nimport {ID3Vault} from \\\"../../intf/ID3Vault.sol\\\";\\nimport \\\"../../../intf/ID3Oracle.sol\\\";\\nimport \\\"../../lib/DecimalMath.sol\\\";\\n\\n/// @title UserQuota\\n/// @notice This contract is used to set/get user's quota, i.e., determine the amount of token user can deposit into the pool.\\ncontract D3UserQuota is Ownable, ID3UserQuota {\\n    using DecimalMath for uint256;\\n\\n    // only user who holds vToken can deposit money\\n    address public _vTOKEN_;\\n    // tiers based on the amount of vToken user holds\\n    mapping(address => uint256[]) public vTokenTiers;\\n    // token => [quota on each tier]\\n    mapping(address => uint256[]) public quotaOnTiers;\\n    // token => bool, if false, a token is not using quota, can deposit unlimit amount\\n    mapping(address => bool) public isUsingQuota;\\n    // token => bool, if true, using global quota instead of vToken quota\\n    mapping(address => bool) public isGlobalQuota;\\n    // token => quota\\n    mapping(address => uint256) public globalQuota;\\n\\n    ID3Vault public d3Vault;\\n\\n    constructor(address vToken, address d3VaultAddress) {\\n        _vTOKEN_ = vToken;\\n        d3Vault = ID3Vault(d3VaultAddress);\\n    }\\n\\n    /// @notice Enable quota for a token\\n    function enableQuota(address token, bool status) external onlyOwner {\\n        isUsingQuota[token] = status;\\n    }\\n\\n    /// @notice Enable global quota for a token\\n    function enableGlobalQuota(address token, bool status) external onlyOwner {\\n        isGlobalQuota[token] = status;\\n    }\\n\\n    /// @notice Set global quota for a token\\n    /// @notice Global quota means every user has the same quota, no matter how many vToken they hold\\n    function setGlobalQuota(address token, uint256 amount) external onlyOwner {\\n        globalQuota[token] = amount;\\n    }\\n\\n    // @notice Set vToken address\\n    function setVToken(address vToken) external onlyOwner {\\n        _vTOKEN_ = vToken;\\n    }\\n\\n    /// @notice Set the amount of tokens held and their corresponding quotas\\n    /// @notice for example, tiers = [100, 200, 300, 400], amounts = [1000, 4000, 6000, 10000]\\n    /// @notice user who holds 100 vToken, can deposit 1000 token\\n    /// @notice user who holds 200 vToken, can deposit 4000 token\\n    /// @notice user who holds 300 vToken, can deposit 6000 token\\n    /// @notice user who holds 400 vToken, can deposit 10000 token\\n    function setTiers(address token, uint256[] calldata tiers, uint256[] calldata amounts) external onlyOwner {\\n        require(tiers.length > 0 && tiers.length == amounts.length, \\\"D3UserQuota: length not match\\\");\\n        vTokenTiers[token] = tiers;\\n        quotaOnTiers[token] = amounts;\\n    }\\n\\n    /// @notice Get the user quota based on tier\\n    function getTierQuota(address user, address token) public view returns (uint256 quota) {\\n        uint256 vTokenBalance = IERC20(_vTOKEN_).balanceOf(user);\\n        uint256[] memory tiers = vTokenTiers[token];\\n        uint256[] memory amounts = quotaOnTiers[token];\\n        for (uint256 i = 0; i < tiers.length; i++) {\\n            if (vTokenBalance < tiers[i]) {\\n                return quota = amounts[i];\\n            }\\n        }\\n        quota = amounts[amounts.length - 1];\\n    }\\n\\n    /// @notice Get the used quota\\n    function getUsedQuota(address user, address token) public view returns (uint256) {\\n        (address dToken,,,,,,,,,,) = d3Vault.getAssetInfo(token);\\n        uint256 dTokenBalance = IERC20(dToken).balanceOf(user);\\n        uint256 exchangeRate = d3Vault.getExchangeRate(token);\\n        return dTokenBalance.mul(exchangeRate);\\n    }\\n\\n    /// @notice Get the user quota for a token\\n    function getUserQuota(address user, address token) public view returns (uint256) {\\n        uint256 usedQuota = getUsedQuota(user, token);\\n        if (isUsingQuota[token]) {\\n            if (isGlobalQuota[token]) {\\n                return globalQuota[token] - usedQuota;\\n            } else {\\n                return getTierQuota(user, token) - usedQuota;\\n            }\\n        } else {\\n            return type(uint256).max;\\n        }\\n    }\\n\\n    /// @notice Check if the quantity of tokens deposited by the user is allowed.\\n    function checkQuota(address user, address token, uint256 amount) public view returns (bool) {\\n        return (amount <= getUserQuota(user, token));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/DODOV3MM/intf/ID3Factory.sol\": {\r\n      \"content\": \"/*\\n\\n    Copyright 2020 DODO ZOO.\\n    SPDX-License-Identifier: Apache-2.0\\n\\n*/\\n\\npragma solidity 0.8.16;\\n\\ninterface ID3Factory {\\n    function breedD3Pool(address poolCreator, address maker, uint256 poolType) external returns (address newPool);\\n}\\n\"\r\n    },\r\n    \"contracts/DODOV3MM/intf/ID3Maker.sol\": {\r\n      \"content\": \"/*\\n\\n    Copyright 2020 DODO ZOO.\\n    SPDX-License-Identifier: Apache-2.0\\n\\n*/\\n\\npragma solidity 0.8.16;\\n\\nimport \\\"../lib/Types.sol\\\";\\n\\ninterface ID3Maker {\\n    function init(address, address, uint256) external;\\n    function getTokenMMInfoForPool(address token)\\n        external\\n        view\\n        returns (Types.TokenMMInfo memory tokenMMInfo, uint256 tokenIndex);\\n    function checkHeartbeat() external view returns (bool);\\n    function getOneTokenOriginIndex(address token) external view returns (int256);\\n    function getPoolTokenListFromMaker() external view returns(address[] memory tokenlist);\\n}\\n\"\r\n    },\r\n    \"contracts/DODOV3MM/intf/ID3MM.sol\": {\r\n      \"content\": \"/*\\n\\n    Copyright 2020 DODO ZOO.\\n    SPDX-License-Identifier: Apache-2.0\\n\\n*/\\n\\npragma solidity 0.8.16;\\n\\ninterface ID3MM {\\n    function _CREATOR_() external view returns(address);\\n    function getFeeRate(address) external view returns(uint256);\\n    function allFlag() external view returns(uint256);\\n    function checkSafe() external view returns (bool);\\n    function checkBorrowSafe() external view returns (bool);\\n    function startLiquidation() external;\\n    function finishLiquidation() external;\\n    function isInLiquidation() external view returns (bool);\\n    function updateReserveByVault(address) external;\\n    function setNewAllFlag(uint256) external;\\n\\n    function init(\\n        address creator,\\n        address maker,\\n        address vault,\\n        address oracle,\\n        address feeRateModel,\\n        address maintainer\\n    ) external;\\n\\n    function sellToken(\\n        address to,\\n        address fromToken,\\n        address toToken,\\n        uint256 fromAmount,\\n        uint256 minReceiveAmount,\\n        bytes calldata data\\n    ) external returns (uint256);\\n\\n    function buyToken(\\n        address to,\\n        address fromToken,\\n        address toToken,\\n        uint256 quoteAmount,\\n        uint256 maxPayAmount,\\n        bytes calldata data\\n    ) external returns (uint256);\\n\\n    function lpDeposit(address lp, address token) external;\\n    function makerDeposit(address token) external;\\n    function getTokenReserve(address token) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/DODOV3MM/intf/ID3PoolQuota.sol\": {\r\n      \"content\": \"/*\\n\\n    Copyright 2020 DODO ZOO.\\n    SPDX-License-Identifier: Apache-2.0\\n\\n*/\\n\\npragma solidity 0.8.16;\\n\\ninterface ID3PoolQuota {\\n    function getPoolQuota(address pool, address token) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/DODOV3MM/intf/ID3RateManager.sol\": {\r\n      \"content\": \"/*\\n\\n    Copyright 2020 DODO ZOO.\\n    SPDX-License-Identifier: Apache-2.0\\n\\n*/\\n\\npragma solidity 0.8.16;\\n\\ninterface ID3RateManager {\\n    function getBorrowRate(address token, uint256 utilizationRatio) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/DODOV3MM/intf/ID3Token.sol\": {\r\n      \"content\": \"/*\\n\\n    Copyright 2020 DODO ZOO.\\n    SPDX-License-Identifier: Apache-2.0\\n\\n*/\\n\\npragma solidity 0.8.16;\\n\\ninterface ID3Token {\\n    function init(address, address) external;\\n    function mint(address, uint256) external;\\n    function burn(address, uint256) external;\\n    function balanceOf(address) external view returns (uint256);\\n    function totalSupply() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/DODOV3MM/intf/ID3UserQuota.sol\": {\r\n      \"content\": \"/*\\n\\n    Copyright 2020 DODO ZOO.\\n    SPDX-License-Identifier: Apache-2.0\\n\\n*/\\n\\npragma solidity 0.8.16;\\n\\ninterface ID3UserQuota {\\n    function getUserQuota(address user, address token) external view returns (uint256);\\n    function checkQuota(address user, address token, uint256 amount) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/DODOV3MM/intf/ID3Vault.sol\": {\r\n      \"content\": \"/*\\n\\n    Copyright 2020 DODO ZOO.\\n    SPDX-License-Identifier: Apache-2.0\\n\\n*/\\n\\npragma solidity 0.8.16;\\n\\ninterface ID3Vault {\\n    function tokens(address) external view returns(bool);\\n    function _ORACLE_() external view returns (address);\\n    function allPoolAddrMap(address) external view returns (bool);\\n    function poolBorrow(address token, uint256 amount) external;\\n    function poolRepay(address token, uint256 bTokenAmount) external;\\n    function poolRepayAll(address token) external;\\n    function poolBorrowLpFee(address token, uint256 amount) external;\\n    function getBorrowed(address pool, address token) external view returns (uint256);\\n    function getAssetInfo(address token)\\n        external\\n        view\\n        returns (\\n            address dToken,\\n            uint256 totalBorrows,\\n            uint256 totalReserves,\\n            uint256 reserveFactor,\\n            uint256 borrowIndex,\\n            uint256 accrualTime,\\n            uint256 maxDepositAmount,\\n            uint256 collateralWeight,\\n            uint256 debtWeight,\\n            uint256 withdrawnReserves,\\n            uint256 balance\\n        );\\n    function getIMMM() external view returns (uint256, uint256);\\n    function getUtilizationRate(address token) external view returns (uint256);\\n    function checkSafe(address pool) external view returns (bool);\\n    function checkCanBeLiquidated(address pool) external view returns (bool);\\n    function checkBorrowSafe(address pool) external view returns (bool);\\n    function allowedLiquidator(address liquidator) external view returns (bool);\\n    function getTotalDebtValue(address pool) external view returns (uint256);\\n    function getTotalAssetsValue(address pool) external view returns (uint256);\\n    function getTokenList() external view returns (address[] memory);\\n    function addD3PoolByFactory(address) external;\\n\\n    function userDeposit(address user, address token) external returns(uint256);\\n    function userWithdraw(address to, address user, address token, uint256 dTokenAmount) external returns (uint256);\\n\\n    function getExchangeRate(address token) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/DODOV3MM/intf/IDODOLiquidator.sol\": {\r\n      \"content\": \"/*\\n\\n    Copyright 2020 DODO ZOO.\\n    SPDX-License-Identifier: Apache-2.0\\n\\n*/\\n\\npragma solidity ^0.8.16;\\n\\ninterface IDODOLiquidator {\\n    function liquidate(\\n        address sender,\\n        address[] calldata tokens,\\n        uint256[] calldata balances,\\n        uint256[] calldata debts\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/DODOV3MM/intf/IDODOSwapCallback.sol\": {\r\n      \"content\": \"/*\\n    Copyright 2020 DODO ZOO.\\n    SPDX-License-Identifier: Apache-2.0\\n*/\\n\\npragma solidity 0.8.16;\\npragma experimental ABIEncoderV2;\\n\\ninterface IDODOSwapCallback {\\n    function d3MMSwapCallBack(address token, uint256 value, bytes calldata data) external;\\n}\\n\"\r\n    },\r\n    \"contracts/DODOV3MM/intf/IDToken.sol\": {\r\n      \"content\": \"/*\\n\\n    Copyright 2020 DODO ZOO.\\n    SPDX-License-Identifier: Apache-2.0\\n\\n*/\\n\\npragma solidity 0.8.16;\\n\\ninterface IDToken {\\n    function totalSupply() external view returns (uint256);\\n    function balanceOf(address account) external view returns (uint256);\\n    function mint(address account, uint256 amount) external;\\n    function burn(address account, uint256 amount) external;\\n    function init(address token, address owner) external;\\n}\\n\"\r\n    },\r\n    \"contracts/DODOV3MM/lib/CloneFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.16;\\n\\ninterface ICloneFactory {\\n    function clone(address prototype) external returns (address proxy);\\n}\\n\\n// introduction of proxy mode design: https://docs.openzeppelin.com/upgrades/2.8/\\n// minimum implementation of transparent proxy: https://eips.ethereum.org/EIPS/eip-1167\\n\\ncontract CloneFactory is ICloneFactory {\\n    function clone(address prototype) external override returns (address proxy) {\\n        bytes20 targetBytes = bytes20(prototype);\\n        assembly {\\n            let clone := mload(0x40)\\n            mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(clone, 0x14), targetBytes)\\n            mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\\n            proxy := create(0, clone, 0x37)\\n        }\\n        return proxy;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/DODOV3MM/lib/DecimalMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.16;\\npragma experimental ABIEncoderV2;\\n\\nimport {Math} from \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\n\\n/**\\n * @title DecimalMath\\n * @author DODO Breeder\\n *\\n * @notice Functions for fixed point number with 18 decimals\\n */\\n\\nlibrary DecimalMath {\\n    uint256 internal constant ONE = 10 ** 18;\\n    uint256 internal constant ONE2 = 10 ** 36;\\n\\n    function mul(uint256 target, uint256 d) internal pure returns (uint256) {\\n        return target * d / (10 ** 18);\\n    }\\n\\n    function mulFloor(uint256 target, uint256 d) internal pure returns (uint256) {\\n        return target * d / (10 ** 18);\\n    }\\n\\n    function mulCeil(uint256 target, uint256 d) internal pure returns (uint256) {\\n        return _divCeil(target * d, 10 ** 18);\\n    }\\n\\n    function div(uint256 target, uint256 d) internal pure returns (uint256) {\\n        return target * (10 ** 18) / d;\\n    }\\n\\n    function divFloor(uint256 target, uint256 d) internal pure returns (uint256) {\\n        return target * (10 ** 18) / d;\\n    }\\n\\n    function divCeil(uint256 target, uint256 d) internal pure returns (uint256) {\\n        return _divCeil(target * (10 ** 18), d);\\n    }\\n\\n    function reciprocalFloor(uint256 target) internal pure returns (uint256) {\\n        return uint256(10 ** 36) / target;\\n    }\\n\\n    function reciprocalCeil(uint256 target) internal pure returns (uint256) {\\n        return _divCeil(uint256(10 ** 36), target);\\n    }\\n\\n    function sqrt(uint256 target) internal pure returns (uint256) {\\n        return Math.sqrt(target * ONE);\\n    }\\n\\n    function powFloor(uint256 target, uint256 e) internal pure returns (uint256) {\\n        if (e == 0) {\\n            return 10 ** 18;\\n        } else if (e == 1) {\\n            return target;\\n        } else {\\n            uint256 p = powFloor(target, e / 2);\\n            p = p * p / (10 ** 18);\\n            if (e % 2 == 1) {\\n                p = p * target / (10 ** 18);\\n            }\\n            return p;\\n        }\\n    }\\n\\n    function _divCeil(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 quotient = a / b;\\n        uint256 remainder = a - quotient * b;\\n        if (remainder > 0) {\\n            return quotient + 1;\\n        } else {\\n            return quotient;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/DODOV3MM/lib/DODOMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.16;\\npragma experimental ABIEncoderV2;\\n\\nimport {DecimalMath} from \\\"./DecimalMath.sol\\\";\\nimport {Math} from \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\n\\n/**\\n * @title DODOMath\\n * @author DODO Breeder\\n *\\n * @notice Functions for complex calculating. Including ONE Integration and TWO Quadratic solutions\\n */\\nlibrary DODOMath {\\n    /*\\n        Integrate dodo curve from V1 to V2\\n        require V0>=V1>=V2>0\\n        res = (1-k)i(V1-V2)+ikV0*V0(1/V2-1/V1)\\n        let V1-V2=delta\\n        res = i*delta*(1-k+k(V0^2/V1/V2))\\n\\n        i is the price of V-res trading pair\\n\\n        support k=1 & k=0 case\\n\\n        [round down]\\n    */\\n    function _GeneralIntegrate(\\n        uint256 V0,\\n        uint256 V1,\\n        uint256 V2,\\n        uint256 i,\\n        uint256 k\\n    ) internal pure returns (uint256) {\\n        require(V0 > 0, \\\"TARGET_IS_ZERO\\\");\\n        uint256 fairAmount = i * (V1 - V2); // i*delta\\n        if (k == 0) {\\n            return fairAmount / DecimalMath.ONE;\\n        }\\n        uint256 V0V0V1V2 = DecimalMath.divFloor(V0 * V0 / V1, V2);\\n        uint256 penalty = DecimalMath.mulFloor(k, V0V0V1V2); // k(V0^2/V1/V2)\\n        return (DecimalMath.ONE - k + penalty) * fairAmount / DecimalMath.ONE2;\\n    }\\n\\n    /*\\n        Follow the integration expression above, we have:\\n        i*deltaB = (Q2-Q1)*(1-k+kQ0^2/Q1/Q2)\\n        Given Q1 and deltaB, solve Q2\\n        This is a quadratic function and the standard version is\\n        aQ2^2 + bQ2 + c = 0, where\\n        a=1-k\\n        -b=(1-k)Q1-kQ0^2/Q1+i*deltaB\\n        c=-kQ0^2 \\n        and Q2=(-b+sqrt(b^2+4(1-k)kQ0^2))/2(1-k)\\n        note: another root is negative, abondan\\n\\n        if deltaBSig=true, then Q2>Q1, user sell Q and receive B\\n        if deltaBSig=false, then Q2<Q1, user sell B and receive Q\\n        return |Q1-Q2|\\n\\n        as we only support sell amount as delta, the deltaB is always negative\\n        the input ideltaB is actually -ideltaB in the equation\\n\\n        i is the price of delta-V trading pair\\n\\n        support k=1 & k=0 case\\n\\n        [round down]\\n    */\\n    function _SolveQuadraticFunctionForTrade(\\n        uint256 V0,\\n        uint256 V1,\\n        uint256 delta,\\n        uint256 i,\\n        uint256 k\\n    ) internal pure returns (uint256) {\\n        require(V0 > 0, \\\"TARGET_IS_ZERO\\\");\\n        if (delta == 0) {\\n            return 0;\\n        }\\n\\n        if (k == 0) {\\n            // why v1\\n            return DecimalMath.mulFloor(i, delta) > V1 ? V1 : DecimalMath.mulFloor(i, delta);\\n        }\\n\\n        if (k == DecimalMath.ONE) {\\n            // if k==1\\n            // Q2=Q1/(1+ideltaBQ1/Q0/Q0)\\n            // temp = ideltaBQ1/Q0/Q0\\n            // Q2 = Q1/(1+temp)\\n            // Q1-Q2 = Q1*(1-1/(1+temp)) = Q1*(temp/(1+temp))\\n            // uint256 temp = i.mul(delta).mul(V1).div(V0.mul(V0));\\n            uint256 temp;\\n            uint256 idelta = i * (delta);\\n            if (idelta == 0) {\\n                temp = 0;\\n            } else if ((idelta * V1) / idelta == V1) {\\n                temp = (idelta * V1) / (V0 * (V0));\\n            } else {\\n                temp = delta * (V1) / (V0) * (i) / (V0);\\n            }\\n            return V1 * (temp) / (temp + (DecimalMath.ONE));\\n        }\\n\\n        // calculate -b value and sig\\n        // b = kQ0^2/Q1-i*deltaB-(1-k)Q1\\n        // part1 = (1-k)Q1 >=0\\n        // part2 = kQ0^2/Q1-i*deltaB >=0\\n        // bAbs = abs(part1-part2)\\n        // if part1>part2 => b is negative => bSig is false\\n        // if part2>part1 => b is positive => bSig is true\\n        uint256 part2 = k * (V0) / (V1) * (V0) + (i * (delta)); // kQ0^2/Q1-i*deltaB\\n        uint256 bAbs = (DecimalMath.ONE - k) * (V1); // (1-k)Q1\\n\\n        bool bSig;\\n        if (bAbs >= part2) {\\n            bAbs = bAbs - part2;\\n            bSig = false;\\n        } else {\\n            bAbs = part2 - bAbs;\\n            bSig = true;\\n        }\\n        bAbs = bAbs / (DecimalMath.ONE);\\n\\n        // calculate sqrt\\n        uint256 squareRoot = DecimalMath.mulFloor((DecimalMath.ONE - k) * (4), DecimalMath.mulFloor(k, V0) * (V0)); // 4(1-k)kQ0^2\\n        squareRoot = Math.sqrt((bAbs * bAbs) + squareRoot); // sqrt(b*b+4(1-k)kQ0*Q0)\\n\\n        // final res\\n        uint256 denominator = (DecimalMath.ONE - k) * 2; // 2(1-k)\\n        uint256 numerator;\\n        if (bSig) {\\n            numerator = squareRoot - bAbs;\\n        } else {\\n            numerator = bAbs + squareRoot;\\n        }\\n\\n        uint256 V2 = DecimalMath.divCeil(numerator, denominator);\\n        if (V2 > V1) {\\n            return 0;\\n        } else {\\n            return V1 - V2;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/DODOV3MM/lib/Errors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.16;\\n\\nlibrary Errors {\\n    // ============= pool funding state =================\\n    string public constant NOT_SAFE = \\\"D3MM_NOT_SAFE\\\";\\n    string public constant NOT_BORROW_SAFE = \\\"D3MM_NOT_BORROW_SAFE\\\";\\n    string public constant NOT_VAULT = \\\"D3MM_NOT_VAULT\\\";\\n    string public constant NOT_IN_LIQUIDATION = \\\"D3MM_NOT_IN_LIQUIDATION\\\";\\n    string public constant POOL_NOT_ONGOING = \\\"D3MM_POOL_NOT_ONGOING\\\";\\n    string public constant TOKEN_NOT_FEASIBLE = \\\"D3MM_TOKEN_NOT_FEASIBLE\\\";\\n\\n    // ============== pool trade =======================\\n    string public constant BALANCE_NOT_ENOUGH = \\\"D3MM_BALANCE_NOT_ENOUGH\\\";\\n    string public constant AMOUNT_TOO_SMALL = \\\"D3MM_AMOUNT_TOO_SMALL\\\";\\n    string public constant FROMAMOUNT_NOT_ENOUGH = \\\"D3MM_FROMAMOUNT_NOT_ENOUGH\\\";\\n    string public constant MINRES_NOT_ENOUGH = \\\"D3MM_MINRESERVE_NOT_ENOUGH\\\";\\n    string public constant MAXPAY_NOT_ENOUGH = \\\"D3MM_MAXPAYAMOUNT_NOT_ENOUGH\\\";\\n    string public constant BELOW_IM_RATIO = \\\"D3MM_BELOW_IM_RATIO\\\";\\n    string public constant HEARTBEAT_CHECK_FAIL = \\\"D3MM_HEARTBEAT_CHECK_FAIL\\\";\\n\\n    // =============== d3 maker =========================\\n    string public constant K_LIMIT = \\\"D3MAKER_K_LIMIT_ERROR\\\";\\n    string public constant PRICE_UP_BELOW_PRICE_DOWN = \\\"D3MAKER_PRICE_UP_BELOW_PRICE_DOWN\\\";\\n    string public constant HAVE_SET_TOKEN_INFO = \\\"D3MAKER_HAVE_SET_TOKEN_INFO\\\";\\n    string public constant K_LENGTH_NOT_MATCH = \\\"D3MAKER_K_LENGTH_NOT_MATCH\\\";\\n    string public constant AMOUNTS_LENGTH_NOT_MATCH = \\\"D3MAKER_AMOUNTS_LENGTH_NOT_MATCH\\\";\\n    string public constant PRICES_LENGTH_NOT_MATCH = \\\"D3MAKER_PRICES_LENGTH_NOT_MATCH\\\";\\n    string public constant PRICE_SLOT_LENGTH_NOT_MATCH = \\\"D3MAKER_PRICE_SLOT_LENGTH_NOT_MATCH\\\";\\n    string public constant INVALID_TOKEN = \\\"D3MAKER_INVALID_TOKEN\\\";\\n\\n    // =============== pmmRangeOrder ====================\\n    string public constant RO_ORACLE_PROTECTION = \\\"PMMRO_ORACLE_PRICE_PROTECTION\\\";\\n    string public constant RO_VAULT_RESERVE = \\\"PMMRO_VAULT_RESERVE_NOT_ENOUGH\\\";\\n    string public constant RO_AMOUNT_ZERO = \\\"PMMRO_AMOUNT_ZERO\\\";\\n    string public constant RO_PRICE_ZERO = \\\"PMMRO_PRICE_ZERO\\\";\\n    string public constant RO_PRICE_DIFF_TOO_SMALL = \\\"PMMRO_PRICE_DIFF_TOO_SMALL\\\";\\n\\n    \\n}\\n\"\r\n    },\r\n    \"contracts/DODOV3MM/lib/InitializableOwnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.16;\\n\\n/**\\n * @title Ownable\\n * @author DODO Breeder\\n * @notice Ownership related functions\\n */\\ncontract InitializableOwnable {\\n    address public _OWNER_;\\n    address public _NEW_OWNER_;\\n    bool internal _INITIALIZED_;\\n\\n    // ============ Events ============\\n\\n    event OwnershipTransferPrepared(address indexed previousOwner, address indexed newOwner);\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    // ============ Modifiers ============\\n\\n    modifier notInitialized() {\\n        require(!_INITIALIZED_, \\\"DODO_INITIALIZED\\\");\\n        _;\\n    }\\n\\n    modifier onlyOwner() {\\n        require(msg.sender == _OWNER_, \\\"NOT_OWNER\\\");\\n        _;\\n    }\\n\\n    // ============ Functions ============\\n\\n    function initOwner(address newOwner) public notInitialized {\\n        _INITIALIZED_ = true;\\n        _OWNER_ = newOwner;\\n    }\\n\\n    function transferOwnership(address newOwner) public onlyOwner {\\n        emit OwnershipTransferPrepared(_OWNER_, newOwner);\\n        _NEW_OWNER_ = newOwner;\\n    }\\n\\n    function claimOwnership() public {\\n        require(msg.sender == _NEW_OWNER_, \\\"INVALID_CLAIM\\\");\\n        emit OwnershipTransferred(_OWNER_, _NEW_OWNER_);\\n        _OWNER_ = _NEW_OWNER_;\\n        _NEW_OWNER_ = address(0);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/DODOV3MM/lib/MakerTypes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.16;\\n\\nimport {DecimalMath} from \\\"./DecimalMath.sol\\\";\\n\\nlibrary MakerTypes {\\n    struct MakerState {\\n        HeartBeat heartBeat;\\n        // price list to package prices in one slot\\n        PriceListInfo priceListInfo;\\n        // =============== Swap Storage =================\\n        mapping(address => TokenMMInfoWithoutCum) tokenMMInfoMap;\\n    }\\n\\n    struct TokenMMInfoWithoutCum {\\n        // [mid price(16) | mid price decimal(8) | fee rate(16) | ask up rate (16) | bid down rate(16)]\\n        // midprice unit is 1e18\\n        // all rate unit is 10000\\n        uint80 priceInfo;\\n        // [ask amounts(16) | ask amounts decimal(8) | bid amounts(16) | bid amounts decimal(8) ]\\n        uint64 amountInfo;\\n        // k is [0, 10000]\\n        uint16 kAsk;\\n        uint16 kBid;\\n        uint16 tokenIndex;\\n    }\\n\\n    // package three token price in one slot\\n    struct PriceListInfo {\\n        // to avoid reset the same token, tokenIndexMap record index from 1, but actualIndex = tokenIndex[address] - 1\\n        // odd for none-stable, even for stable,  true index = actualIndex / 2 = (tokenIndex[address] - 1) / 2\\n        mapping(address => uint256) tokenIndexMap;\\n        uint256 numberOfNS; // quantity of not stable token\\n        uint256 numberOfStable; // quantity of stable token\\n        // [mid price(16) | mid price decimal(8) | fee rate(16) | ask up rate (16) | bid down rate(16)] = 72 bit\\n        // one slot contain = 72 * 3, 3 token price\\n        // [2 | 1 | 0]\\n        uint256[] tokenPriceNS; // not stable token price\\n        uint256[] tokenPriceStable; // stable token price\\n    }\\n\\n    struct HeartBeat {\\n        uint256 lastHeartBeat;\\n        uint256 maxInterval;\\n    }\\n\\n    uint16 internal constant ONE_PRICE_BIT = 72;\\n    uint256 internal constant PRICE_QUANTITY_IN_ONE_SLOT = 3;\\n    uint16 internal constant ONE_AMOUNT_BIT = 24;\\n    uint256 internal constant ONE = 10 ** 18;\\n\\n    // [ask amounts(16) | ask amounts decimal(8) | bid amounts(16) | bid amounts decimal(8) ]\\n    function parseAskAmount(uint64 amountInfo) internal pure returns (uint256 amountWithDecimal) {\\n        uint256 askAmount = (amountInfo >> (ONE_AMOUNT_BIT + 8)) & 0xffff;\\n        uint256 askAmountDecimal = (amountInfo >> ONE_AMOUNT_BIT) & 255;\\n        amountWithDecimal = askAmount * (10 ** askAmountDecimal);\\n    }\\n\\n    // [ask amounts(16) | ask amounts decimal(8) | bid amounts(16) | bid amounts decimal(8) ]\\n    function parseBidAmount(uint64 amountInfo) internal pure returns (uint256 amountWithDecimal) {\\n        uint256 bidAmount = (amountInfo >> 8) & 0xffff;\\n        uint256 bidAmountDecimal = amountInfo & 255;\\n        amountWithDecimal = bidAmount * (10 ** bidAmountDecimal);\\n    }\\n\\n    function parseAllPrice(uint80 priceInfo, uint256 mtFeeRate)\\n        internal\\n        pure\\n        returns (uint256 askUpPrice, uint256 askDownPrice, uint256 bidUpPrice, uint256 bidDownPrice, uint256 swapFee)\\n    {\\n        {\\n        uint256 midPrice = (priceInfo >> 56) & 0xffff;\\n        uint256 midPriceDecimal = (priceInfo >> 48) & 255;\\n        uint256 midPriceWithDecimal = midPrice * (10 ** midPriceDecimal);\\n\\n        uint256 swapFeeRate = (priceInfo >> 32) & 0xffff;\\n        uint256 askUpRate = (priceInfo >> 16) & 0xffff;\\n        uint256 bidDownRate = priceInfo & 0xffff;\\n\\n        // swap fee rate standarlize\\n        swapFee = swapFeeRate * (10 ** 14) + mtFeeRate;\\n        uint256 swapFeeSpread = DecimalMath.mul(midPriceWithDecimal, swapFee);\\n\\n        // ask price standarlize\\n        askDownPrice = midPriceWithDecimal + swapFeeSpread;\\n        askUpPrice = midPriceWithDecimal + midPriceWithDecimal * askUpRate / (10 ** 4);\\n        require(askDownPrice <= askUpPrice, \\\"ask price invalid\\\");\\n\\n        // bid price standarlize\\n        uint reversalBidUp = midPriceWithDecimal - swapFeeSpread;\\n        uint reversalBidDown = midPriceWithDecimal - midPriceWithDecimal * bidDownRate / (10 ** 4);\\n        require(reversalBidDown <= reversalBidUp, \\\"bid price invalid\\\");\\n        bidDownPrice = DecimalMath.reciprocalCeil(reversalBidUp);\\n        bidUpPrice = DecimalMath.reciprocalCeil(reversalBidDown);\\n        }\\n    }\\n\\n    function parseK(uint16 originK) internal pure returns (uint256) {\\n        return uint256(originK) * (10 ** 14);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/DODOV3MM/lib/PMMPricing.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.16;\\n\\nimport {DecimalMath} from \\\"contracts/DODOV3MM/lib/DecimalMath.sol\\\";\\nimport {DODOMath} from \\\"contracts/DODOV3MM/lib/DODOMath.sol\\\";\\n\\n/**\\n * @title PMMPricing\\n * @author DODO Breeder\\n *\\n * @notice DODO Pricing model\\n */\\nlibrary PMMPricing {\\n    struct PMMState {\\n        uint256 i;\\n        uint256 K;\\n        uint256 B;\\n        uint256 B0;\\n        uint256 BMaxAmount;\\n        uint256 BLeft;\\n    }\\n\\n    function _queryBuyBaseToken(PMMState memory state, uint256 amount) internal pure returns (uint256 payQuote) {\\n        payQuote = _BuyBaseToken(state, amount, state.B, state.B0);\\n    }\\n\\n    function _querySellQuoteToken(\\n        PMMState memory state,\\n        uint256 payQuoteAmount\\n    ) internal pure returns (uint256 receiveBaseAmount) {\\n        receiveBaseAmount = _SellQuoteToken(state, payQuoteAmount);\\n    }\\n\\n    // ============ R > 1 cases ============\\n\\n    function _BuyBaseToken(\\n        PMMState memory state,\\n        uint256 amount,\\n        uint256 baseBalance,\\n        uint256 targetBaseAmount\\n    ) internal pure returns (uint256 payQuoteToken) {\\n        require(amount < baseBalance, \\\"DODOstate.BNOT_ENOUGH\\\");\\n        uint256 B2 = baseBalance - amount;\\n        return DODOMath._GeneralIntegrate(targetBaseAmount, baseBalance, B2, state.i, state.K);\\n    }\\n\\n    function _SellQuoteToken(\\n        PMMState memory state,\\n        uint256 payQuoteAmount\\n    ) internal pure returns (uint256 receiveBaseToken) {\\n        return DODOMath._SolveQuadraticFunctionForTrade(\\n            state.B0, state.B, payQuoteAmount, DecimalMath.reciprocalFloor(state.i), state.K\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/DODOV3MM/lib/PMMRangeOrder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.16;\\n\\nimport \\\"./PMMPricing.sol\\\";\\nimport \\\"./Errors.sol\\\";\\nimport \\\"./Types.sol\\\";\\nimport {ID3Oracle} from \\\"contracts/intf/ID3Oracle.sol\\\";\\n\\nlibrary PMMRangeOrder {\\n    uint256 internal constant ONE = 10 ** 18;\\n\\n    // use fromToken bid curve and toToken ask curve\\n    function querySellTokens(\\n        Types.RangeOrderState memory roState,\\n        address fromToken,\\n        address toToken,\\n        uint256 fromTokenAmount\\n    ) internal view returns (uint256 fromAmount, uint256 receiveToToken, uint256 vusdAmount) {\\n        // contruct fromToken state and swap to vUSD\\n        uint256 receiveVUSD;\\n        {\\n            PMMPricing.PMMState memory fromTokenState = _contructTokenState(roState, true, false);\\n            receiveVUSD = PMMPricing._querySellQuoteToken(fromTokenState, fromTokenAmount);\\n\\n            receiveVUSD = receiveVUSD > fromTokenState.BLeft ? fromTokenState.BLeft : receiveVUSD;\\n        }\\n\\n        // construct toToken state and swap from vUSD to toToken\\n        {\\n            PMMPricing.PMMState memory toTokenState = _contructTokenState(roState, false, true);\\n            receiveToToken = PMMPricing._querySellQuoteToken(toTokenState, receiveVUSD);\\n\\n            receiveToToken = receiveToToken > toTokenState.BLeft ? toTokenState.BLeft : receiveToToken;\\n        }\\n\\n        // oracle protect\\n        {\\n            uint256 oracleToAmount = ID3Oracle(roState.oracle).getMaxReceive(fromToken, toToken, fromTokenAmount);\\n            require(oracleToAmount >= receiveToToken, Errors.RO_ORACLE_PROTECTION);\\n        }\\n        return (fromTokenAmount, receiveToToken, receiveVUSD);\\n    }\\n\\n    // use fromToken bid curve and toToken ask curve\\n    function queryBuyTokens(\\n        Types.RangeOrderState memory roState,\\n        address fromToken,\\n        address toToken,\\n        uint256 toTokenAmount\\n    ) internal view returns (uint256 payFromToken, uint256 toAmount, uint256 vusdAmount) {\\n        // contruct fromToken to vUSD\\n        uint256 payVUSD;\\n        {\\n            PMMPricing.PMMState memory toTokenState = _contructTokenState(roState, false, true);\\n            require(\\n                toTokenAmount <= toTokenState.BMaxAmount - roState.toTokenMMInfo.cumulativeAsk, Errors.RO_VAULT_RESERVE\\n            );\\n            payVUSD = PMMPricing._queryBuyBaseToken(toTokenState, toTokenAmount);\\n        }\\n\\n        // construct vUSD to toToken\\n        {\\n            PMMPricing.PMMState memory fromTokenState = _contructTokenState(roState, true, false);\\n            payFromToken = PMMPricing._queryBuyBaseToken(fromTokenState, payVUSD);\\n        }\\n\\n        // oracle protect\\n        {\\n            uint256 oracleToAmount = ID3Oracle(roState.oracle).getMaxReceive(fromToken, toToken, payFromToken);\\n            require(oracleToAmount >= toTokenAmount, Errors.RO_ORACLE_PROTECTION);\\n        }\\n\\n        return (payFromToken, toTokenAmount, payVUSD);\\n    }\\n\\n    // ========= internal ==========\\n    function _contructTokenState(\\n        Types.RangeOrderState memory roState,\\n        bool fromTokenOrNot,\\n        bool askOrNot\\n    ) internal pure returns (PMMPricing.PMMState memory tokenState) {\\n        Types.TokenMMInfo memory tokenMMInfo = fromTokenOrNot ? roState.fromTokenMMInfo : roState.toTokenMMInfo;\\n\\n        // bMax,k\\n        tokenState.BMaxAmount = askOrNot ? tokenMMInfo.askAmount : tokenMMInfo.bidAmount;\\n\\n        // amount = 0 protection\\n        require(tokenState.BMaxAmount > 0, Errors.RO_AMOUNT_ZERO);\\n        tokenState.K = askOrNot ? tokenMMInfo.kAsk : tokenMMInfo.kBid;\\n\\n        // i, B0\\n        uint256 upPrice;\\n        (tokenState.i, upPrice) = askOrNot\\n            ? (tokenMMInfo.askDownPrice, tokenMMInfo.askUpPrice)\\n            : (tokenMMInfo.bidDownPrice, tokenMMInfo.bidUpPrice);\\n        // price = 0 protection\\n        require(tokenState.i > 0, Errors.RO_PRICE_ZERO);\\n        tokenState.B0 = _calB0WithPriceLimit(upPrice, tokenState.K, tokenState.i, tokenState.BMaxAmount);\\n        // B\\n        tokenState.B = askOrNot ? tokenState.B0 - tokenMMInfo.cumulativeAsk : tokenState.B0 - tokenMMInfo.cumulativeBid;\\n\\n        // BLeft\\n        tokenState.BLeft = askOrNot\\n            ? tokenState.BMaxAmount - tokenMMInfo.cumulativeAsk\\n            : tokenState.BMaxAmount - tokenMMInfo.cumulativeBid;\\n\\n        return tokenState;\\n    }\\n\\n    // P_up = i(1 - k + k*(B0 / B0 - amount)^2), record amount = A\\n    // (P_up + i*k - i) / i*k = (B0 / (B0 - A))^2\\n    // B0 = A + A / (sqrt((P_up + i*k - i) / i*k) - 1)\\n    // i = priceDown\\n    function _calB0WithPriceLimit(\\n        uint256 priceUp,\\n        uint256 k,\\n        uint256 i,\\n        uint256 amount\\n    ) internal pure returns (uint256 baseTarget) {\\n        // (P_up + i*k - i)\\n        // temp1 = PriceUp + DecimalMath.mul(i, k) - i\\n        // temp1 price\\n\\n        // i*k\\n        // temp2 = DecimalMath.mul(i, k)\\n        // temp2 price\\n\\n        // (P_up + i*k - i)/i*k\\n        // temp3 = DecimalMath(temp1, temp2)\\n        // temp3 ONE\\n\\n        // temp4 = sqrt(temp3 * ONE)\\n        // temp4 ONE\\n\\n        // temp5 = temp4 - ONE\\n        // temp5 ONE\\n\\n        // B0 = amount + DecimalMath.div(amount, temp5)\\n        // B0 amount\\n        if (k == 0) {\\n            baseTarget = amount;\\n        } else {\\n            uint256 temp1 = priceUp * ONE + i * k - i * ONE;\\n            uint256 temp2 = i * k;\\n            uint256 temp3 = DecimalMath.div(temp1, temp2);\\n            uint256 temp5 = DecimalMath.sqrt(temp3) - ONE;\\n            require(temp5 > 0, Errors.RO_PRICE_DIFF_TOO_SMALL);\\n            baseTarget = amount + DecimalMath.div(amount, temp5);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/DODOV3MM/lib/Types.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.16;\\n\\nlibrary Types {\\n    struct D3MMState {\\n        // the D3vault contract\\n        address _D3_VAULT_;\\n        // the creator of pool\\n        address _CREATOR_;\\n        // maker contract address\\n        address _MAKER_;\\n        address _ORACLE_;\\n        address _FEE_RATE_MODEL_;\\n        address _MAINTAINER_;\\n        // token balance\\n        mapping(address => uint256) balances;\\n        // the tokens have been deposited into pool\\n        address[] depositedTokenList;\\n        // record if a token has been deposited before\\n        mapping(address => bool) hasDepositedToken;\\n    }\\n\\n    struct TokenCumulative {\\n        uint256 cumulativeAsk;\\n        uint256 cumulativeBid;\\n    }\\n\\n    struct TokenMMInfo {\\n        // ask price with decimal\\n        uint256 askDownPrice;\\n        uint256 askUpPrice;\\n        // bid price with decimal\\n        uint256 bidDownPrice;\\n        uint256 bidUpPrice;\\n        uint256 askAmount;\\n        uint256 bidAmount;\\n        // k, unit is 1e18\\n        uint256 kAsk;\\n        uint256 kBid;\\n        // cumulative\\n        uint256 cumulativeAsk;\\n        uint256 cumulativeBid;\\n        // swap fee, unit is 1e18\\n        uint256 swapFeeRate;\\n        uint256 mtFeeRate;\\n    }\\n\\n    struct RangeOrderState {\\n        address oracle;\\n        TokenMMInfo fromTokenMMInfo;\\n        TokenMMInfo toTokenMMInfo;\\n    }\\n\\n    function parseRealAmount(uint256 realAmount, uint256 tokenDec) internal pure returns(uint256 amountWithDec18) {\\n        if(tokenDec < 18) {\\n            uint256 fixDec = 18 - tokenDec;\\n            amountWithDec18 = realAmount * (10 ** fixDec);\\n        } else if(tokenDec == 18) {\\n            amountWithDec18 = realAmount;\\n        } else {\\n            uint256 fixDec = tokenDec - 18;\\n            amountWithDec18 = realAmount / (10 ** fixDec);\\n        }\\n    }\\n\\n    function parseDec18Amount(uint256 amountWithDec18, uint256 tokenDec) internal pure returns(uint256 realAmount) {\\n        if(tokenDec < 18) {\\n            uint256 fixDec = 18 - tokenDec;\\n            realAmount = amountWithDec18 / (10 ** fixDec);\\n        } else if(tokenDec == 18) {\\n            realAmount = amountWithDec18;\\n        } else {\\n            uint256 fixDec = tokenDec - 18;\\n            realAmount = amountWithDec18 * (10 ** fixDec);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/DODOV3MM/periphery/D3MMFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.16;\\n\\nimport {ID3MM} from \\\"../intf/ID3MM.sol\\\";\\nimport {ID3Maker} from \\\"../intf/ID3Maker.sol\\\";\\nimport {ID3Vault} from \\\"../intf/ID3Vault.sol\\\";\\nimport {InitializableOwnable} from \\\"../lib/InitializableOwnable.sol\\\";\\nimport {ICloneFactory} from \\\"../lib/CloneFactory.sol\\\";\\n\\n/**\\n * @title D3MMFactory\\n * @author DODO Breeder\\n * @notice This factory contract is used to create/register D3MM pools.\\n */\\ncontract D3MMFactory is InitializableOwnable {\\n    // different index means different tmeplate, 0 is for normal d3 pool.\\n    mapping(uint256 => address) public _D3POOL_TEMPS;\\n    mapping(uint256 => address) public _D3MAKER_TEMPS_;\\n    address public _CLONE_FACTORY_;\\n    address public _ORACLE_;\\n    ID3Vault public d3Vault;\\n    address public _FEE_RATE_MODEL_;\\n    address public _MAINTAINER_;\\n\\n    // ============ Events ============\\n\\n    event D3Birth(address newD3, address creator);\\n    event AddRouter(address router);\\n    event RemoveRouter(address router);\\n\\n    // ============ Constructor Function ============\\n\\n    constructor(\\n        address owner,\\n        address[] memory d3Temps,\\n        address[] memory d3MakerTemps,\\n        address cloneFactory,\\n        address d3VaultAddress,\\n        address oracleAddress,\\n        address feeRateModel,\\n        address maintainer\\n    ) {\\n        require(d3MakerTemps.length == d3Temps.length, \\\"temps not match\\\");\\n\\n        for (uint256 i = 0; i < d3Temps.length; i++) {\\n            _D3POOL_TEMPS[i] = d3Temps[i];\\n            _D3MAKER_TEMPS_[i] = d3MakerTemps[i];\\n        }\\n        _CLONE_FACTORY_ = cloneFactory;\\n        _ORACLE_ = oracleAddress;\\n        d3Vault = ID3Vault(d3VaultAddress);\\n        _FEE_RATE_MODEL_ = feeRateModel;\\n        _MAINTAINER_ = maintainer;\\n        initOwner(owner);\\n    }\\n\\n    // ============ Admin Function ============\\n\\n    /// @notice Set new D3MM template\\n    function setD3Temp(uint256 poolType, address newTemp) public onlyOwner {\\n        _D3POOL_TEMPS[poolType] = newTemp;\\n    }\\n    /// @notice Set new D3Maker template\\n    function setD3MakerTemp(uint256 poolType, address newMakerTemp) public onlyOwner {\\n        _D3MAKER_TEMPS_[poolType] = newMakerTemp;\\n    }\\n\\n    /// @notice Set new CloneFactory contract address\\n    function setCloneFactory(address cloneFactory) external onlyOwner {\\n        _CLONE_FACTORY_ = cloneFactory;\\n    }\\n\\n    /// @notice Set new oracle\\n    function setOracle(address oracle) external onlyOwner {\\n        _ORACLE_ = oracle;\\n    }\\n    /// @notice Set new maintainer\\n    function setMaintainer(address maintainer) external onlyOwner {\\n        _MAINTAINER_ = maintainer;\\n    }\\n    /// @notice Set new feeRateModel\\n    function setFeeRate(address feeRateModel) external onlyOwner {\\n        _FEE_RATE_MODEL_ = feeRateModel;\\n    }\\n\\n    // ============ Breed DODO Function ============\\n\\n    /// @notice Create new D3MM pool and maker, and register to vault\\n    /// @param poolCreator Pool owner\\n    /// @param maker Maker owner\\n    /// @param maxInterval Maximum interval for heartbeat detection.\\n    /// @param poolType Pool template type.\\n    /// @return newPool New pool address\\n    function breedD3Pool(\\n        address poolCreator,\\n        address maker,\\n        uint256 maxInterval,\\n        uint256 poolType\\n    ) external onlyOwner returns (address newPool) {\\n        address newMaker = ICloneFactory(_CLONE_FACTORY_).clone(_D3MAKER_TEMPS_[poolType]);\\n        newPool = ICloneFactory(_CLONE_FACTORY_).clone(_D3POOL_TEMPS[poolType]);\\n\\n        ID3MM(newPool).init(\\n            poolCreator,\\n            newMaker,\\n            address(d3Vault),\\n            _ORACLE_,\\n            _FEE_RATE_MODEL_,\\n            _MAINTAINER_\\n        );\\n        \\n        ID3Maker(newMaker).init(maker, newPool, maxInterval);\\n\\n        d3Vault.addD3PoolByFactory(newPool);\\n\\n        emit D3Birth(newPool, poolCreator);\\n        return newPool;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/DODOV3MM/periphery/D3MMLiquidationRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.16;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {SafeERC20} from \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\n\\ncontract D3MMLiquidationRouter {\\n    using SafeERC20 for IERC20;\\n\\n    address public immutable _DODO_APPROVE_;\\n\\n    constructor(address dodoApprove) {\\n        _DODO_APPROVE_ = dodoApprove;\\n    }\\n\\n    struct LiquidationOrder {\\n        address fromToken;\\n        address toToken;\\n        uint256 fromAmount;\\n    }\\n\\n    /// @notice D3MM call this function to do liquidation swap\\n    /// @param order The liquidation order\\n    /// @param router The router contract address\\n    /// @param routeData The data will be parsed to router call\\n    function D3Callee(LiquidationOrder calldata order, address router, bytes calldata routeData) external {\\n        IERC20(order.fromToken).forceApprove(_DODO_APPROVE_, type(uint256).max);\\n        (bool success, bytes memory data) = router.call(routeData);\\n        if (!success) {\\n            assembly {\\n                revert(add(data, 32), mload(data))\\n            }\\n        }\\n        IERC20(order.toToken).safeTransfer(msg.sender, IERC20(order.toToken).balanceOf(address(this)));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/DODOV3MM/periphery/D3Oracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.16;\\n\\nimport {InitializableOwnable} from \\\"../lib/InitializableOwnable.sol\\\";\\nimport {ID3Oracle} from \\\"../../intf/ID3Oracle.sol\\\";\\nimport \\\"../lib/DecimalMath.sol\\\";\\nimport \\\"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\\\";\\n\\nstruct PriceSource {\\n    address oracle;\\n    bool isWhitelisted;\\n    uint256 priceTolerance;\\n    uint8 priceDecimal;\\n    uint8 tokenDecimal;\\n    uint256 heartBeat;\\n}\\n\\ncontract D3Oracle is ID3Oracle, InitializableOwnable {\\n    // originToken => priceSource\\n    mapping(address => PriceSource) public priceSources;\\n    address public sequencerFeed;\\n\\n    uint256 private constant GRACE_PERIOD_TIME = 3600;\\n\\n    error SequencerDown();\\n    error GracePeriodNotOver();\\n\\n    /// @notice Onwer is set in constructor\\n    constructor() {\\n        initOwner(msg.sender);\\n    }\\n\\n    /// @notice Set sequencer feed address\\n    /// @notice For non-L2 network, should be address(0)\\n    /// @notice For a list of available Sequencer Uptime Feed proxy addresses, \\n    /// @notice see: https://docs.chain.link/docs/data-feeds/l2-sequencer-feeds\\n    function setSequencer(address addr) external onlyOwner {\\n        sequencerFeed = addr;\\n    }\\n\\n    /// @notice Set the price source for a token\\n    /// @param token The token address\\n    /// @param source The price source for the token\\n    function setPriceSource(address token, PriceSource calldata source) external onlyOwner {\\n        priceSources[token] = source;\\n        require(source.priceTolerance <= DecimalMath.ONE && source.priceTolerance >= 1e10, \\\"INVALID_PRICE_TOLERANCE\\\");\\n    }\\n\\n    /// @notice Enable or disable oracle for a token\\n    /// @dev Owner could stop oracle feed price in emergency\\n    /// @param token The token address\\n    /// @param isAvailable Whether the oracle is available for the token\\n    function setTokenOracleFeasible(address token, bool isAvailable) external onlyOwner {\\n        priceSources[token].isWhitelisted = isAvailable;\\n    }\\n\\n    /// @notice Get the price for a token\\n    /// @dev The price definition is: how much virtual USD the token values if token amount is 1e18.\\n    /// @dev Example 1: if the token decimals is 18, and worth 2 USD, then price is 2e18.\\n    /// @dev Example 2: if the token decimals is 8, and worth 2 USD, then price is 2e28.\\n    /// @param token The token address\\n    function getPrice(address token) public view override returns (uint256) {\\n        uint256 price = getPriceFromFeed(token);\\n        return price * 10 ** (36 - priceSources[token].priceDecimal - priceSources[token].tokenDecimal);\\n    }\\n\\n    /// @notice Return the original price from price feed\\n    /// @notice For example, if WBTC price is 30000e8, return (30000e8, 8)\\n    function getOriginalPrice(address token) public view override returns (uint256, uint8) {\\n        uint256 price = getPriceFromFeed(token);\\n        uint8 priceDecimal = priceSources[token].priceDecimal;\\n        return (price, priceDecimal);\\n    }\\n\\n    /// @notice If the price decimals is not 18, parse it to 18\\n    /// @notice For example, if WBTC price is 30000e8, return 30000e18\\n    function getDec18Price(address token) public view override returns (uint256) {\\n        uint256 price = getPriceFromFeed(token);\\n        return price * 10 ** (18 - priceSources[token].priceDecimal);\\n    }\\n\\n    /// @notice Return if oracle is feasible for a token\\n    /// @param token The token address\\n    function isFeasible(address token) external view override returns (bool) {\\n        return priceSources[token].isWhitelisted;\\n    }\\n\\n    /// @notice Given certain amount of fromToken, get the max return amount of toToken\\n    /// @param fromToken The from token address\\n    /// @param toToken The to token address\\n    /// @param fromAmount The from token amount\\n    /// @dev This function is only used in PMMRangeOrder, which assumes both tokens have 18 decimals.\\n    /// @dev PMMRangeOrder will parse token amount if the decimals is not 18\\n    /// @dev Do not use this function in other place. If use, make sure both tokens' decimals are 18\\n    function getMaxReceive(address fromToken, address toToken, uint256 fromAmount) external view returns (uint256) {\\n        uint256 fromTlr = priceSources[fromToken].priceTolerance;\\n        uint256 toTlr = priceSources[toToken].priceTolerance;\\n\\n        return DecimalMath.div((fromAmount * getDec18Price(fromToken)) / getDec18Price(toToken), DecimalMath.mul(fromTlr, toTlr));\\n    }\\n\\n    function getPriceFromFeed(address token) internal view returns (uint256) {\\n        checkSequencerActive();\\n        require(priceSources[token].isWhitelisted, \\\"INVALID_TOKEN\\\");\\n        AggregatorV3Interface priceFeed = AggregatorV3Interface(priceSources[token].oracle);\\n        (uint80 roundID, int256 price,, uint256 updatedAt, uint80 answeredInRound) = priceFeed.latestRoundData();\\n        require(price > 0, \\\"Chainlink: Incorrect Price\\\");\\n        require(block.timestamp - updatedAt < priceSources[token].heartBeat, \\\"Chainlink: Stale Price\\\");\\n        require(answeredInRound >= roundID, \\\"Chainlink: Stale Price\\\");\\n        return uint256(price);\\n    }\\n\\n    function checkSequencerActive() internal view {\\n        // for non-L2 network, sequencerFeed should be set to address(0)\\n        if (sequencerFeed == address(0)) return;\\n        (, int256 answer, uint256 startedAt, ,) = AggregatorV3Interface(sequencerFeed).latestRoundData();\\n        // Answer == 0: Sequencer is up\\n        // Answer == 1: Sequencer is down\\n        if (answer == 1) revert SequencerDown();\\n        // Make sure the grace period has passed after the\\n        // sequencer is back up.\\n        if (block.timestamp - startedAt <= GRACE_PERIOD_TIME) revert GracePeriodNotOver();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/DODOV3MM/periphery/D3Proxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.16;\\n\\nimport \\\"../lib/PMMRangeOrder.sol\\\";\\nimport \\\"../lib/Errors.sol\\\";\\nimport {ID3MM} from \\\"../intf/ID3MM.sol\\\";\\nimport {ID3Factory} from \\\"../intf/ID3Factory.sol\\\";\\nimport {IWETH} from \\\"contracts/intf/IWETH.sol\\\";\\nimport {IDODOSwapCallback} from \\\"../intf/IDODOSwapCallback.sol\\\";\\nimport {IDODOApproveProxy} from \\\"contracts/intf/IDODOApproveProxy.sol\\\";\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {SafeERC20} from \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport {ID3Vault} from \\\"../intf/ID3Vault.sol\\\";\\n\\ncontract D3Proxy is IDODOSwapCallback {\\n    using SafeERC20 for IERC20;\\n\\n    address public immutable _DODO_APPROVE_PROXY_;\\n    address public immutable _WETH_;\\n    address public immutable _D3_VAULT_;\\n    address public immutable _ETH_ADDRESS_ = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n\\n    struct SwapCallbackData {\\n        bytes data;\\n        address payer;\\n    }\\n\\n    // ============ Modifiers ============\\n\\n    modifier judgeExpired(uint256 deadLine) {\\n        require(deadLine >= block.timestamp, \\\"D3PROXY_EXPIRED\\\");\\n        _;\\n    }\\n\\n    // ============ Constructor ============\\n\\n    constructor(address approveProxy, address weth, address d3Vault) {\\n        _DODO_APPROVE_PROXY_ = approveProxy;\\n        _WETH_ = weth;\\n        _D3_VAULT_ = d3Vault;\\n    }\\n\\n    // ======================================\\n\\n    fallback() external payable {}\\n\\n    receive() external payable {\\n        require(msg.sender == _WETH_, \\\"D3PROXY_NOT_WETH9\\\");\\n    }\\n\\n    // ======================================\\n\\n    /// @notice Call multiple functions in the current contract and return the data from all of them if they all succeed\\n    /// @param data The encoded function data for each of the calls to make to this contract\\n    /// @return results The results from each of the calls passed in via data\\n    function multicall(bytes[] calldata data) public payable returns (bytes[] memory results) {\\n        results = new bytes[](data.length);\\n        for (uint256 i = 0; i < data.length; i++) {\\n            (bool success, bytes memory result) = address(this).delegatecall(data[i]);\\n\\n            if (!success) {\\n                assembly {\\n                    revert(add(result, 32), mload(result))\\n                }\\n            }\\n\\n            results[i] = result;\\n        }\\n    }\\n\\n    /// @notice Sell certain amount of tokens, i.e., fromToken amount is known\\n    /// @param pool The address of the pool to which you want to sell tokens\\n    /// @param to The address to receive the return back token\\n    /// @param fromToken The address of the fromToken\\n    /// @param toToken The address of the toToken\\n    /// @param fromAmount The amount of the fromToken you want to sell\\n    /// @param minReceiveAmount The minimal amount you expect to receive\\n    /// @param data Any data to be passed through to the callback\\n    /// @param deadLine The transaction should be processed before the deadline\\n    function sellTokens(\\n        address pool,\\n        address to,\\n        address fromToken,\\n        address toToken,\\n        uint256 fromAmount,\\n        uint256 minReceiveAmount,\\n        bytes calldata data,\\n        uint256 deadLine\\n    ) public payable judgeExpired(deadLine) returns (uint256 receiveToAmount) {\\n        SwapCallbackData memory swapData;\\n        swapData.data = data;\\n        swapData.payer = msg.sender;\\n\\n        if (fromToken == _ETH_ADDRESS_) {\\n            require(msg.value == fromAmount, \\\"D3PROXY_VALUE_INVALID\\\");\\n            receiveToAmount = ID3MM(pool).sellToken(to, _WETH_, toToken, fromAmount, minReceiveAmount, abi.encode(swapData));\\n        } else if (toToken == _ETH_ADDRESS_) {\\n            receiveToAmount =\\n                ID3MM(pool).sellToken(address(this), fromToken, _WETH_, fromAmount, minReceiveAmount, abi.encode(swapData));\\n            _withdrawWETH(to, receiveToAmount);\\n            // multicall withdraw weth to user\\n        } else {\\n            receiveToAmount = ID3MM(pool).sellToken(to, fromToken, toToken, fromAmount, minReceiveAmount, abi.encode(swapData));\\n        }\\n    }\\n\\n    /// @notice Buy certain amount of tokens, i.e., toToken amount is known\\n    /// @param pool The address of the pool to which you want to sell tokens\\n    /// @param to The address to receive the return back token\\n    /// @param fromToken The address of the fromToken\\n    /// @param toToken The address of the toToken\\n    /// @param quoteAmount The amount of the toToken you want to buy\\n    /// @param maxPayAmount The maximum amount of fromToken you would like to pay\\n    /// @param data Any data to be passed through to the callback\\n    /// @param deadLine The transaction should be processed before the deadline\\n    function buyTokens(\\n        address pool,\\n        address to,\\n        address fromToken,\\n        address toToken,\\n        uint256 quoteAmount,\\n        uint256 maxPayAmount,\\n        bytes calldata data,\\n        uint256 deadLine\\n    ) public payable judgeExpired(deadLine) returns (uint256 payFromAmount) {\\n        SwapCallbackData memory swapData;\\n        swapData.data = data;\\n        swapData.payer = msg.sender;\\n\\n        if (fromToken == _ETH_ADDRESS_) {\\n            payFromAmount = ID3MM(pool).buyToken(to, _WETH_, toToken, quoteAmount, maxPayAmount, abi.encode(swapData));\\n            // multicall refund eth to user\\n        } else if (toToken == _ETH_ADDRESS_) {\\n            payFromAmount = ID3MM(pool).buyToken(address(this), fromToken, _WETH_, quoteAmount, maxPayAmount, abi.encode(swapData));\\n            _withdrawWETH(to, quoteAmount);\\n            // multicall withdraw weth to user\\n        } else {\\n            payFromAmount = ID3MM(pool).buyToken(to, fromToken, toToken, quoteAmount, maxPayAmount, abi.encode(swapData));\\n        }\\n    }\\n\\n    /// @notice This callback is used to deposit token into D3MM\\n    /// @param token The address of token\\n    /// @param value The amount of token need to deposit to D3MM\\n    /// @param _data Any data to be passed through to the callback\\n    function d3MMSwapCallBack(address token, uint256 value, bytes calldata _data) external override {\\n        require(ID3Vault(_D3_VAULT_).allPoolAddrMap(msg.sender), \\\"D3PROXY_CALLBACK_INVALID\\\");\\n        SwapCallbackData memory decodeData;\\n        decodeData = abi.decode(_data, (SwapCallbackData));\\n        _deposit(decodeData.payer, msg.sender, token, value);\\n    }\\n\\n    /// @notice LP deposit token into pool\\n    /// @param user the one who own dtokens\\n    /// @param  token The address of token\\n    /// @param amount The amount of token\\n    function userDeposit(address user, address token, uint256 amount, uint256 minDtokenAmount) external payable {\\n        uint256 dTokenAmount;\\n        if (token == _ETH_ADDRESS_) {\\n            require(msg.value == amount, \\\"D3PROXY_PAYMENT_NOT_MATCH\\\");\\n            _deposit(msg.sender, _D3_VAULT_, _WETH_, amount);\\n            dTokenAmount = ID3Vault(_D3_VAULT_).userDeposit(user, _WETH_);\\n        } else {\\n            _deposit(msg.sender, _D3_VAULT_, token, amount);\\n            dTokenAmount = ID3Vault(_D3_VAULT_).userDeposit(user, token);\\n        }\\n        require(dTokenAmount >= minDtokenAmount, \\\"D3PROXY_MIN_DTOKEN_AMOUNT_FAIL\\\");\\n    }\\n\\n    function userWithdraw(address to, address token, uint256 dTokenAmount, uint256 minReceiveAmount) external payable returns(uint256 amount){\\n        if (token != _ETH_ADDRESS_) {\\n            (address dToken,,,,,,,,,,) = ID3Vault(_D3_VAULT_).getAssetInfo(token);\\n            _deposit(msg.sender, address(this), dToken, dTokenAmount);\\n            amount = ID3Vault(_D3_VAULT_).userWithdraw(to, msg.sender, token, dTokenAmount);    \\n        } else {\\n            (address dToken,,,,,,,,,,) = ID3Vault(_D3_VAULT_).getAssetInfo(_WETH_);\\n            _deposit(msg.sender, address(this), dToken, dTokenAmount);\\n            amount = ID3Vault(_D3_VAULT_).userWithdraw(address(this), msg.sender, _WETH_, dTokenAmount);\\n            _withdrawWETH(to, amount);\\n        }\\n        require(amount >= minReceiveAmount, \\\"D3PROXY_MIN_RECEIVE_FAIL\\\");\\n    }\\n\\n    /// @notice Pool owner deposit token into pool\\n    /// @param pool The address of pool\\n    /// @param  token The address of token\\n    /// @param amount The amount of token\\n    function makerDeposit(address pool, address token, uint256 amount) external payable {\\n        if (token == _ETH_ADDRESS_) {\\n            require(msg.value == amount, \\\"D3PROXY_PAYMENT_NOT_MATCH\\\");\\n            _deposit(msg.sender, pool, _WETH_, amount);\\n            ID3MM(pool).makerDeposit(_WETH_);\\n        } else{\\n            _deposit(msg.sender, pool, token, amount);\\n            ID3MM(pool).makerDeposit(token);\\n        }\\n    }\\n\\n\\n    // ======= external refund =======\\n\\n    /// @dev when fromToken = ETH and call buyTokens, call this function to refund user's eth\\n    function refundETH() external payable {\\n        if (address(this).balance > 0) {\\n            _safeTransferETH(msg.sender, address(this).balance);\\n        }\\n    }\\n\\n    /// @dev when toToken == eth, call this function to get eth\\n    /// @param to The account address to receive ETH\\n    /// @param minAmount The minimum amount to withdraw\\n    function withdrawWETH(address to, uint256 minAmount) external payable {\\n        uint256 withdrawAmount = IWETH(_WETH_).balanceOf(address(this));\\n        require(withdrawAmount >= minAmount, \\\"D3PROXY_WETH_NOT_ENOUGH\\\");\\n\\n        _withdrawWETH(to, withdrawAmount);\\n    }\\n\\n    // ======= internal =======\\n\\n    /// @notice Before the first pool swap, contract call _deposit to get ERC20 token through DODOApprove / transfer ETH to WETH\\n    /// @dev ETH transfer is allowed\\n    /// @param from The address which will transfer token out\\n    /// @param to The address which will receive the token\\n    /// @param token The token address\\n    /// @param value The token amount\\n    function _deposit(address from, address to, address token, uint256 value) internal {\\n        if (token == _WETH_ && address(this).balance >= value) {\\n            // pay with WETH9\\n            IWETH(_WETH_).deposit{value: value}(); // wrap only what is needed to pay\\n            IWETH(_WETH_).transfer(to, value);\\n        } else {\\n            // pull payment\\n            IDODOApproveProxy(_DODO_APPROVE_PROXY_).claimTokens(token, from, to, value);\\n        }\\n    }\\n\\n    /// @dev Withdraw ETH from WETH\\n    /// @param to The account address to receive ETH\\n    /// @param withdrawAmount The amount to withdraw\\n    function _withdrawWETH(address to, uint256 withdrawAmount) internal {\\n        IWETH(_WETH_).withdraw(withdrawAmount);\\n        _safeTransferETH(to, withdrawAmount);\\n    }\\n\\n    /// @notice Transfers ETH to the recipient address\\n    /// @dev Fails with `ETH_TRANSFER_FAIL`\\n    /// @param to The destination of the transfer\\n    /// @param value The value to be transferred\\n    function _safeTransferETH(address to, uint256 value) internal {\\n        (bool success,) = to.call{value: value}(new bytes(0));\\n        require(success, \\\"D3PROXY_ETH_TRANSFER_FAIL\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/intf/ID3Oracle.sol\": {\r\n      \"content\": \"/*\\n\\n    Copyright 2020 DODO ZOO.\\n    SPDX-License-Identifier: Apache-2.0\\n\\n*/\\n\\npragma solidity 0.8.16;\\n\\ninterface ID3Oracle {\\n    function getMaxReceive(address fromToken, address toToken, uint256 fromAmount) external view returns (uint256);\\n    function getPrice(address base) external view returns (uint256);\\n    function getDec18Price(address base) external view returns(uint256);\\n    function getOriginalPrice(address base) external view returns (uint256 price, uint8 priceDecimal);\\n    function isFeasible(address base) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/intf/IDODOApprove.sol\": {\r\n      \"content\": \"/*\\n\\n    Copyright 2020 DODO ZOO.\\n    SPDX-License-Identifier: Apache-2.0\\n\\n*/\\n\\npragma solidity 0.8.16;\\n\\ninterface IDODOApprove {\\n    function claimTokens(address token, address who, address dest, uint256 amount) external;\\n    function getDODOProxy() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/intf/IDODOApproveProxy.sol\": {\r\n      \"content\": \"/*\\n\\n    Copyright 2020 DODO ZOO.\\n    SPDX-License-Identifier: Apache-2.0\\n\\n*/\\n\\npragma solidity 0.8.16;\\n\\ninterface IDODOApproveProxy {\\n    function isAllowedProxy(address _proxy) external view returns (bool);\\n    function claimTokens(address token,address who,address dest,uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/intf/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity 0.8.16;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals.\\n     */\\n    function decimals() external view returns (uint8);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/intf/IFeeRateModel.sol\": {\r\n      \"content\": \"/*\\n\\n    Copyright 2020 DODO ZOO.\\n    SPDX-License-Identifier: Apache-2.0\\n\\n*/\\n\\npragma solidity 0.8.16;\\n\\ninterface IFeeRateModel {\\n    function getFeeRate(address token) external view returns (uint256);\\n}\"\r\n    },\r\n    \"contracts/intf/IWETH.sol\": {\r\n      \"content\": \"/*\\n\\n    Copyright 2020 DODO ZOO.\\n    SPDX-License-Identifier: Apache-2.0\\n\\n*/\\n\\npragma solidity 0.8.16;\\n\\ninterface IWETH {\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    function transferFrom(address src, address dst, uint256 wad) external returns (bool);\\n\\n    function deposit() external payable;\\n\\n    function withdraw(uint256 wad) external;\\n}\\n\"\r\n    },\r\n    \"contracts/mock/D3FeeRateModel.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.16;\\n\\nimport {IFeeRateModel} from \\\"../intf/IFeeRateModel.sol\\\";\\nimport \\\"../DODOV3MM/lib/InitializableOwnable.sol\\\";\\n\\ncontract D3FeeRateModel is IFeeRateModel, InitializableOwnable {\\n    mapping(address => bool) public isUsedFeeRate;\\n    mapping(address => uint256) public feeRateMap;\\n    uint256 public defaultFeeRate; \\n\\n    function init(address owner, uint256 _feeRate) public {\\n        initOwner(owner);\\n        defaultFeeRate = _feeRate;\\n    }\\n\\n    function setDefaultFeeRate(uint256 newFeeRate) public onlyOwner {\\n        defaultFeeRate = newFeeRate;\\n    }\\n\\n    function setIsUseFeeRate(address token, bool isUse) public onlyOwner {\\n        isUsedFeeRate[token] = isUse;\\n    }\\n\\n    function setTokenFeeRate(address token, uint256 tokenFeeRate) public onlyOwner {\\n        feeRateMap[token] = tokenFeeRate;\\n    }\\n\\n    function getFeeRate(address token) external view returns(uint256 feerate) {\\n        return isUsedFeeRate[token] ? feeRateMap[token] : defaultFeeRate;\\n    }\\n}\"\r\n    },\r\n    \"contracts/mock/DODOApprove.sol\": {\r\n      \"content\": \"/*\\n\\n    Copyright 2020 DODO ZOO.\\n    SPDX-License-Identifier: Apache-2.0\\n\\n*/\\n\\npragma solidity 0.8.16;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {SafeERC20} from \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport {InitializableOwnable} from \\\"contracts/DODOV3MM/lib/InitializableOwnable.sol\\\";\\n\\n/**\\n * @title DODOApprove\\n * @author DODO Breeder\\n *\\n * @notice Handle authorizations in DODO platform\\n */\\ncontract DODOApprove is InitializableOwnable {\\n    using SafeERC20 for IERC20;\\n\\n    // ============ Storage ============\\n    uint256 private constant _TIMELOCK_DURATION_ = 3 days;\\n    uint256 private constant _TIMELOCK_EMERGENCY_DURATION_ = 24 hours;\\n    uint256 public _TIMELOCK_;\\n    address public _PENDING_DODO_PROXY_;\\n    address public _DODO_PROXY_;\\n\\n    // ============ Events ============\\n\\n    event SetDODOProxy(address indexed oldProxy, address indexed newProxy);\\n\\n    // ============ Modifiers ============\\n    modifier notLocked() {\\n        require(_TIMELOCK_ <= block.timestamp, \\\"SetProxy is timelocked\\\");\\n        _;\\n    }\\n\\n    function init(address owner, address initProxyAddress) external {\\n        initOwner(owner);\\n        _DODO_PROXY_ = initProxyAddress;\\n    }\\n\\n    function unlockSetProxy(address newDodoProxy) public onlyOwner {\\n        if (_DODO_PROXY_ == address(0)) {\\n            _TIMELOCK_ = block.timestamp + _TIMELOCK_EMERGENCY_DURATION_;\\n        } else {\\n            _TIMELOCK_ = block.timestamp + _TIMELOCK_DURATION_;\\n        }\\n        _PENDING_DODO_PROXY_ = newDodoProxy;\\n    }\\n\\n    function lockSetProxy() public onlyOwner {\\n        _PENDING_DODO_PROXY_ = address(0);\\n        _TIMELOCK_ = 0;\\n    }\\n\\n    function setDODOProxy() external onlyOwner notLocked {\\n        emit SetDODOProxy(_DODO_PROXY_, _PENDING_DODO_PROXY_);\\n        _DODO_PROXY_ = _PENDING_DODO_PROXY_;\\n        lockSetProxy();\\n    }\\n\\n    function claimTokens(address token, address who, address dest, uint256 amount) external {\\n        require(msg.sender == _DODO_PROXY_, \\\"DODOApprove:Access restricted\\\");\\n        if (amount > 0) {\\n            IERC20(token).safeTransferFrom(who, dest, amount);\\n        }\\n    }\\n\\n    function getDODOProxy() public view returns (address) {\\n        return _DODO_PROXY_;\\n    }\\n\\n    // Make forge coverage ignore\\n    function testSuccess() public {}\\n}\\n\"\r\n    },\r\n    \"contracts/mock/DODOApproveProxy.sol\": {\r\n      \"content\": \"/*\\n\\n    Copyright 2020 DODO ZOO.\\n    SPDX-License-Identifier: Apache-2.0\\n\\n*/\\n\\npragma solidity 0.8.16;\\npragma experimental ABIEncoderV2;\\n\\nimport {IDODOApprove} from \\\"contracts/intf/IDODOApprove.sol\\\";\\nimport {InitializableOwnable} from \\\"contracts/DODOV3MM/lib/InitializableOwnable.sol\\\";\\n\\n/**\\n * @title DODOApproveProxy\\n * @author DODO Breeder\\n *\\n * @notice Allow different version dodoproxy to claim from DODOApprove\\n */\\ncontract DODOApproveProxy is InitializableOwnable {\\n    // ============ Storage ============\\n    uint256 private constant _TIMELOCK_DURATION_ = 3;\\n    mapping(address => bool) public _IS_ALLOWED_PROXY_;\\n    uint256 public _TIMELOCK_;\\n    address public _PENDING_ADD_DODO_PROXY_;\\n    address public immutable _DODO_APPROVE_;\\n\\n    // ============ Modifiers ============\\n    modifier notLocked() {\\n        require(_TIMELOCK_ <= block.timestamp, \\\"SetProxy is timelocked\\\");\\n        _;\\n    }\\n\\n    constructor(address dodoApporve) {\\n        _DODO_APPROVE_ = dodoApporve;\\n    }\\n\\n    function init(address owner, address[] memory proxies) external {\\n        initOwner(owner);\\n        for (uint256 i = 0; i < proxies.length; i++) {\\n            _IS_ALLOWED_PROXY_[proxies[i]] = true;\\n        }\\n    }\\n\\n    function unlockAddProxy(address newDodoProxy) public onlyOwner {\\n        _TIMELOCK_ = block.timestamp + _TIMELOCK_DURATION_;\\n        _PENDING_ADD_DODO_PROXY_ = newDodoProxy;\\n    }\\n\\n    function lockAddProxy() public onlyOwner {\\n        _PENDING_ADD_DODO_PROXY_ = address(0);\\n        _TIMELOCK_ = 0;\\n    }\\n\\n    function addDODOProxy() external onlyOwner notLocked {\\n        _IS_ALLOWED_PROXY_[_PENDING_ADD_DODO_PROXY_] = true;\\n        lockAddProxy();\\n    }\\n\\n    function removeDODOProxy(address oldDodoProxy) public onlyOwner {\\n        _IS_ALLOWED_PROXY_[oldDodoProxy] = false;\\n    }\\n\\n    function claimTokens(address token, address who, address dest, uint256 amount) external {\\n        require(_IS_ALLOWED_PROXY_[msg.sender], \\\"NOT_ALLOWED_PROXY\\\");\\n        IDODOApprove(_DODO_APPROVE_).claimTokens(token, who, dest, amount);\\n    }\\n\\n    function isAllowedProxy(address _proxy) external view returns (bool) {\\n        return _IS_ALLOWED_PROXY_[_proxy];\\n    }\\n\\n    // Make forge coverage ignore\\n    function testSuccess() public {}\\n}\\n\"\r\n    },\r\n    \"contracts/mock/MockChainlinkPriceFeed.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.16;\\n\\nimport \\\"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\\\";\\n\\ncontract MockChainlinkPriceFeed is AggregatorV3Interface {\\n    string public description;\\n    uint8 public decimals;\\n    uint256 public version = 1;\\n    int256 public price;\\n    uint80 public round;\\n    uint256 public startTime;\\n    uint256 public updateTime;\\n\\n    constructor(string memory _description, uint8 _decimals) {\\n        description = _description;\\n        decimals = _decimals;\\n        startTime = block.timestamp;\\n    }\\n\\n    function feedData(int256 _price) public {\\n        price = _price;\\n        round += 1;\\n        updateTime = block.timestamp;\\n    }\\n\\n    function getRoundData(uint80 _roundId)\\n        external\\n        view\\n        returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound)\\n    {\\n        require(_roundId <= round, \\\"wrong round id\\\");\\n        roundId = _roundId;\\n        answer = price;\\n        startedAt = startTime;\\n        updatedAt = updateTime;\\n        answeredInRound = _roundId;\\n    }\\n\\n    function latestRoundData()\\n        external\\n        view\\n        returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound)\\n    {\\n        roundId = round;\\n        answer = price;\\n        startedAt = startTime;\\n        updatedAt = block.timestamp;\\n        answeredInRound = round;\\n    }\\n\\n    // Make forge coverage ignore\\n    function testSuccess() public {}\\n}\\n\"\r\n    },\r\n    \"contracts/mock/MockChainlinkPriceFeed2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.16;\\n\\nimport \\\"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\\\";\\n\\n// This mock can return price based on block.timestamp\\ncontract MockChainlinkPriceFeed2 is AggregatorV3Interface {\\n    string public description;\\n    uint8 public decimals;\\n    uint256 public version = 1;\\n    int256 public price = 1e8; // default decimals is 8\\n    uint80 public round;\\n    uint256 public startTime;\\n    uint256 public updateTime;\\n\\n    constructor(string memory _description, uint8 _decimals) {\\n        description = _description;\\n        decimals = _decimals;\\n        startTime = block.timestamp;\\n    }\\n\\n    function feedData(int256 _price) public {\\n        price = _price;\\n        round += 1;\\n        updateTime = block.timestamp;\\n    }\\n\\n    function getRoundData(uint80 _roundId)\\n        external\\n        view\\n        returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound)\\n    {\\n        require(_roundId <= round, \\\"wrong round id\\\");\\n        roundId = _roundId;\\n        answer = price;\\n        startedAt = startTime;\\n        updatedAt = updateTime;\\n        answeredInRound = _roundId;\\n    }\\n\\n    function latestRoundData()\\n        external\\n        view\\n        returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound)\\n    {\\n        roundId = round;\\n        answer = price * (int256(block.timestamp) % 10000); // price will change based on timestamp\\n        startedAt = startTime;\\n        updatedAt = updateTime;\\n        answeredInRound = round;\\n    }\\n\\n    // Make forge coverage ignore\\n    function testSuccess() public {}\\n}\\n\"\r\n    },\r\n    \"contracts/mock/MockChainlinkPriceFeed3.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.16;\\n\\nimport \\\"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\\\";\\nimport {Ownable} from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\ncontract MockChainlinkPriceFeed3 is AggregatorV3Interface, Ownable {\\n    string public description;\\n    uint8 public decimals;\\n    uint256 public version = 1;\\n    int256 public price;\\n    uint80 public round;\\n    uint256 public startTime;\\n    uint256 public updateTime;\\n\\n    constructor(string memory _description, uint8 _decimals) {\\n        description = _description;\\n        decimals = _decimals;\\n        startTime = block.timestamp;\\n    }\\n\\n    function feedData(int256 _price) public {\\n        price = _price;\\n        round += 1;\\n        updateTime = block.timestamp;\\n    }\\n\\n    function getRoundData(uint80 _roundId)\\n        external\\n        view\\n        returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound)\\n    {\\n        require(_roundId <= round, \\\"wrong round id\\\");\\n        roundId = _roundId;\\n        answer = price;\\n        startedAt = startTime;\\n        updatedAt = updateTime;\\n        answeredInRound = _roundId;\\n    }\\n\\n    function latestRoundData()\\n        external\\n        view\\n        returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound)\\n    {\\n        roundId = round;\\n        answer = price;\\n        startedAt = startTime;\\n        updatedAt = updateTime;\\n        answeredInRound = round;\\n    }\\n\\n    // Make forge coverage ignore\\n    function testSuccess() public {}\\n}\\n\"\r\n    },\r\n    \"contracts/mock/MockD3MM.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\nimport \\\"contracts/DODOV3MM/D3Pool/D3MM.sol\\\";\\nimport \\\"contracts/DODOV3MM/intf/ID3Maker.sol\\\";\\n\\npragma solidity 0.8.16;\\n\\ncontract MockD3MM is D3MM {\\n    function updateReserve(address token) external {\\n        _updateReserve(token);\\n    }\\n\\n    function setAllFlagByAnyone(uint256 newFlag) external {\\n        allFlag = newFlag;\\n    }\\n\\n    function getTokenFlag(address token) external view returns (uint256){\\n        (, uint256 tokenIndex) = ID3Maker(state._MAKER_).getTokenMMInfoForPool(token);\\n        return (allFlag >> (tokenIndex) & 1);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/mock/MockD3MMFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\nimport \\\"contracts/DODOV3MM/periphery/D3MMFactory.sol\\\";\\n\\npragma solidity 0.8.16;\\n\\ncontract MockD3MMFactory is D3MMFactory {\\n    constructor(\\n        address owner,\\n        address[] memory d3Temps,\\n        address[] memory d3MakerTemps,\\n        address cloneFactory,\\n        address d3VaultAddress,\\n        address oracleAddress,\\n        address feeRateModel,\\n        address maintainer\\n    ) D3MMFactory(\\n        owner,\\n        d3Temps,\\n        d3MakerTemps,\\n        cloneFactory,\\n        d3VaultAddress,\\n        oracleAddress,\\n        feeRateModel,\\n        maintainer\\n    ) {}\\n\\n    function addD3Pool(address pool) public {\\n        d3Vault.addD3PoolByFactory(pool);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/mock/MockD3Oracle.sol\": {\r\n      \"content\": \"/*\\n\\n    Copyright 2021 DODO ZOO.\\n    SPDX-License-Identifier: Apache-2.0\\n\\n*/\\n\\npragma solidity 0.8.16;\\n\\nimport {InitializableOwnable} from \\\"../DODOV3MM/lib/InitializableOwnable.sol\\\";\\nimport {ID3Oracle} from \\\"../intf/ID3Oracle.sol\\\";\\nimport \\\"../DODOV3MM/lib/DecimalMath.sol\\\";\\nimport \\\"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\\\";\\n\\nstruct PriceSource {\\n    uint256 price; // price in USD\\n    bool isWhitelisted;\\n    uint256 priceTolerance;\\n    uint8 priceDecimal;\\n}\\n\\ncontract MockD3Oracle is ID3Oracle, InitializableOwnable {\\n    // originToken => priceSource\\n    mapping(address => PriceSource) public priceSources;\\n\\n    function setPriceSource(address token, PriceSource calldata source) external onlyOwner {\\n        priceSources[token] = source;\\n        require(source.priceTolerance <= DecimalMath.ONE, \\\"INVALID_PRICE_TOLERANCE\\\");\\n    }\\n\\n    // return 1e18 decimal\\n    function getPrice(address token) public view override returns (uint256) {\\n        return priceSources[token].price;\\n    }\\n\\n    function getDec18Price(address token) public view override returns (uint256) {\\n        return priceSources[token].price;\\n    }\\n\\n    function isFeasible(address token) external view override returns (bool) {\\n        return priceSources[token].isWhitelisted;\\n    }\\n\\n    // given the amount of fromToken, how much toToken can return at most\\n    function getMaxReceive(address fromToken, address toToken, uint256 fromAmount) external view returns (uint256) {\\n        uint256 fromTlr = priceSources[fromToken].priceTolerance;\\n        uint256 toTlr = priceSources[toToken].priceTolerance;\\n\\n        return DecimalMath.div((fromAmount * getDec18Price(fromToken)) / getDec18Price(toToken), DecimalMath.mul(fromTlr, toTlr));\\n    }\\n\\n    function getOriginalPrice(address token) public view override returns (uint256 price, uint8 priceDecimal) {\\n        return (getPrice(token), 8);\\n    }\\n\\n    function testSuccess() public {}\\n}\\n\"\r\n    },\r\n    \"contracts/mock/MockD3Pool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.16;\\n\\ncontract MockD3Pool {\\n    address public _CREATOR_;\\n    uint256 public allFlag;\\n    \\n    constructor() {\\n        _CREATOR_ = msg.sender;\\n    }\\n\\n    function setNewAllFlag(uint256 newFlag) public {\\n        allFlag = newFlag;\\n    }\\n\\n    function getFeeRate(address token) public pure returns(uint256){\\n        return 2 * (10 ** 14);\\n    }\\n\\n    function testSuccess() public {}\\n}\\n\"\r\n    },\r\n    \"contracts/mock/MockD3Proxy.sol\": {\r\n      \"content\": \"/*\\n\\n    Copyright 2022 DODO ZOO.\\n    SPDX-License-Identifier: Apache-2.0\\n\\n*/\\n\\npragma solidity 0.8.16;\\n\\nimport \\\"contracts/DODOV3MM/lib/PMMRangeOrder.sol\\\";\\nimport {ID3MM} from \\\"contracts/DODOV3MM/intf/ID3MM.sol\\\";\\nimport {IWETH} from \\\"contracts/intf/IWETH.sol\\\";\\nimport {IDODOSwapCallback} from \\\"contracts/DODOV3MM/intf/IDODOSwapCallback.sol\\\";\\nimport {IDODOApproveProxy} from \\\"contracts/intf/IDODOApproveProxy.sol\\\";\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {SafeERC20} from \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\n\\ncontract MockFailD3Proxy is IDODOSwapCallback {\\n    using SafeERC20 for IERC20;\\n\\n    address immutable public _DODO_APPROVE_PROXY_;\\n    address immutable public _WETH_;\\n    address immutable public _ETH_ADDRESS_ = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n\\n    struct SwapCallbackData {\\n        bytes data;\\n        address payer;\\n    }\\n\\n    // ============ Modifiers ============\\n\\n    modifier judgeExpired(uint256 deadLine) {\\n        require(deadLine >= block.timestamp, \\\"DODORouteProxy: EXPIRED\\\");\\n        _;\\n    }\\n\\n    // ============ Constructor ============\\n    \\n    constructor(address approveProxy, address weth) {\\n        _DODO_APPROVE_PROXY_ = approveProxy;\\n        _WETH_ = weth;\\n    }\\n\\n    function sellTokens(\\n        address pool,\\n        address to,\\n        address fromToken,\\n        address toToken,\\n        uint256 fromAmount,\\n        uint256 minReceiveAmount,\\n        bytes calldata data,\\n        uint256 deadLine\\n    ) public payable judgeExpired(deadLine) returns(uint256 receiveToAmount) {\\n        receiveToAmount = ID3MM(pool).sellToken(to, fromToken, toToken, fromAmount, minReceiveAmount, data);\\n    }\\n\\n    function buyTokens(\\n        address pool,\\n        address to,\\n        address fromToken,\\n        address toToken,\\n        uint256 quoteAmount,\\n        uint256 maxPayAmount,\\n        bytes calldata data,\\n        uint256 deadLine\\n    ) public payable judgeExpired(deadLine) returns(uint256 payFromAmount) {\\n        payFromAmount = ID3MM(pool).buyToken(to, fromToken, toToken, quoteAmount, maxPayAmount, data);\\n    }\\n\\n    function d3MMSwapCallBack(\\n        address token,\\n        uint256 /* value */,\\n        bytes calldata _data\\n    ) external override {\\n        SwapCallbackData memory decodeData;\\n        decodeData = abi.decode(_data, (SwapCallbackData));\\n        _deposit(decodeData.payer, msg.sender, token, 1000);\\n    }\\n\\n    // ======= internal =======\\n\\n    /// @notice before the first pool swap, contract call _deposit to get ERC20 token through DODOApprove/transfer ETH to WETH\\n    function _deposit(\\n        address from,\\n        address to,\\n        address token,\\n        uint256 value\\n    ) internal {\\n        if (token == _WETH_ && address(this).balance >= value) {\\n            // pay with WETH9\\n            IWETH(_WETH_).deposit{value: value}(); // wrap only what is needed to pay\\n            IWETH(_WETH_).transfer(to, value);\\n        } else if (from == address(this)) {\\n            // pay with tokens already in the contract (for the exact input multihop case)\\n            SafeERC20.safeTransfer(IERC20(token), to, value);\\n        } else {\\n            // pull payment\\n            IDODOApproveProxy(_DODO_APPROVE_PROXY_).claimTokens(token, from, to, value);\\n        }\\n    }\\n\\n    function testSuccess() public {}\\n}\"\r\n    },\r\n    \"contracts/mock/MockD3UserQuota.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.16;\\n\\nimport \\\"contracts/DODOV3MM/intf/ID3UserQuota.sol\\\";\\n\\ncontract MockD3UserQuota is ID3UserQuota {\\n    mapping(address => mapping(address => uint256)) internal quota; // user => (token => amount)\\n\\n    function setUserQuota(address user, address token, uint256 amount) external {\\n        quota[user][token] = amount;\\n    }\\n\\n    function getUserQuota(address user, address token) external view returns (uint256) {\\n        return quota[user][token];\\n    }\\n\\n    function checkQuota(address user, address token, uint256 amount) external view returns (bool) {\\n        return amount <= quota[user][token];\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/mock/MockERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.16;\\n\\ncontract MockERC20 {\\n    string public name;\\n    string public symbol;\\n    uint8 public decimals;\\n\\n    mapping(address => uint256) internal balances;\\n    mapping(address => mapping(address => uint256)) internal allowed;\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    constructor(string memory _name, string memory _symbol, uint8 _decimals) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n    }\\n\\n    function transfer(address to, uint256 amount) public returns (bool) {\\n        require(to != address(0), \\\"TO_ADDRESS_IS_EMPTY\\\");\\n        require(amount <= balances[msg.sender], \\\"BALANCE_NOT_ENOUGH\\\");\\n\\n        balances[msg.sender] = balances[msg.sender] - amount;\\n        balances[to] = balances[to] + amount;\\n        emit Transfer(msg.sender, to, amount);\\n        return true;\\n    }\\n\\n    function balanceOf(address owner) public view returns (uint256 balance) {\\n        return balances[owner];\\n    }\\n\\n    function transferFrom(address from, address to, uint256 amount) public returns (bool) {\\n        require(to != address(0), \\\"TO_ADDRESS_IS_EMPTY\\\");\\n        require(amount <= balances[from], \\\"BALANCE_NOT_ENOUGH\\\");\\n        require(amount <= allowed[from][msg.sender], \\\"ALLOWANCE_NOT_ENOUGH\\\");\\n\\n        balances[from] = balances[from] - amount;\\n        balances[to] = balances[to] + amount;\\n        allowed[from][msg.sender] = allowed[from][msg.sender] - amount;\\n        emit Transfer(from, to, amount);\\n        return true;\\n    }\\n\\n    function approve(address spender, uint256 amount) public returns (bool) {\\n        allowed[msg.sender][spender] = amount;\\n        emit Approval(msg.sender, spender, amount);\\n        return true;\\n    }\\n\\n    function allowance(address owner, address spender) public view returns (uint256) {\\n        return allowed[owner][spender];\\n    }\\n\\n    function mint(address account, uint256 amount) external {\\n        balances[account] = balances[account] + amount;\\n    }\\n\\n    function burn(address account, uint256 amount) external {\\n        if (balances[account] < amount) {\\n            balances[account] = 0;\\n        } else {\\n            balances[account] = balances[account] - amount;\\n        }\\n    }\\n\\n    // comment this function out because Ethersjs cannot tell two functions with same name\\n    // function mint(uint256 amount) external {\\n    //     balances[msg.sender] = balances[msg.sender] + amount;\\n    // }\\n\\n    // Make forge coverage ignore\\n    function testSuccess() public {}\\n}\\n\"\r\n    },\r\n    \"contracts/mock/MockFeeRateModel.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.16;\\n\\nimport {IFeeRateModel} from \\\"../intf/IFeeRateModel.sol\\\";\\nimport \\\"../DODOV3MM/lib/InitializableOwnable.sol\\\";\\n\\ncontract MockFeeRateModel is IFeeRateModel, InitializableOwnable {\\n    mapping(address => bool) public isUsedFeeRate;\\n    mapping(address => uint256) public feeRateMap;\\n    uint256 public defaultFeeRate; \\n\\n    function init(address owner, uint256 _feeRate) public {\\n        initOwner(owner);\\n        defaultFeeRate = _feeRate;\\n    }\\n\\n    function setDefaultFeeRate(uint256 newFeeRate) public onlyOwner {\\n        defaultFeeRate = newFeeRate;\\n    }\\n\\n    function setIsUseFeeRate(address token, bool isUse) public onlyOwner {\\n        isUsedFeeRate[token] = isUse;\\n    }\\n\\n    function setTokenFeeRate(address token, uint256 tokenFeeRate) public onlyOwner {\\n        feeRateMap[token] = tokenFeeRate;\\n    }\\n\\n    function getFeeRate(address token) external view returns(uint256 feerate) {\\n        return isUsedFeeRate[token] ? feeRateMap[token] : defaultFeeRate;\\n    }\\n\\n    function testSuccess() public {}\\n}\"\r\n    },\r\n    \"contracts/mock/MockRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.16;\\n\\nimport \\\"contracts/intf/ID3Oracle.sol\\\";\\nimport \\\"./MockERC20.sol\\\";\\n\\ncontract MockRouter {\\n    address public oracle;\\n    bool public enable = true;\\n    uint256 public slippage = 100;\\n\\n    constructor(address _oracle) {\\n        oracle = _oracle;\\n    }\\n\\n    function enableRouter() public {\\n        enable = true;\\n    }\\n\\n    function disableRouter() public {\\n        enable = false;\\n    }\\n\\n    function setSlippage(uint256 s) public {\\n        slippage = s;\\n    }\\n\\n    function swap(address fromToken, address toToken, uint256 fromAmount) public {\\n        require(enable, \\\"router not available\\\");\\n        uint256 fromTokenPrice = ID3Oracle(oracle).getPrice(fromToken);\\n        uint256 toTokenPrice = ID3Oracle(oracle).getPrice(toToken);\\n        uint256 toAmount = (fromAmount * fromTokenPrice) / toTokenPrice;\\n        toAmount = toAmount * slippage / 100;\\n        MockERC20(toToken).transfer(msg.sender, toAmount);\\n    }\\n\\n    // Make forge coverage ignore\\n    function testSuccess() public {}\\n}\\n\"\r\n    },\r\n    \"contracts/mock/WETH9.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.16;\\n\\ncontract WETH9 {\\n    string public name = \\\"Wrapped Ether\\\";\\n    string public symbol = \\\"WETH\\\";\\n    uint8 public decimals = 18;\\n\\n    event Approval(address indexed src, address indexed guy, uint256 wad);\\n    event Transfer(address indexed src, address indexed dst, uint256 wad);\\n    event Deposit(address indexed dst, uint256 wad);\\n    event Withdrawal(address indexed src, uint256 wad);\\n\\n    mapping(address => uint256) public balanceOf;\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    fallback() external payable {\\n        deposit();\\n    }\\n\\n    receive() external payable {\\n        deposit();\\n    }\\n\\n    function deposit() public payable {\\n        balanceOf[msg.sender] += msg.value;\\n        emit Deposit(msg.sender, msg.value);\\n    }\\n\\n    function withdraw(uint256 wad) public {\\n        require(balanceOf[msg.sender] >= wad);\\n        balanceOf[msg.sender] -= wad;\\n        payable(msg.sender).transfer(wad);\\n        emit Withdrawal(msg.sender, wad);\\n    }\\n\\n    function totalSupply() public view returns (uint256) {\\n        return address(this).balance;\\n    }\\n\\n    function approve(address guy, uint256 wad) public returns (bool) {\\n        allowance[msg.sender][guy] = wad;\\n        emit Approval(msg.sender, guy, wad);\\n        return true;\\n    }\\n\\n    function transfer(address dst, uint256 wad) public returns (bool) {\\n        return transferFrom(msg.sender, dst, wad);\\n    }\\n\\n    function transferFrom(address src, address dst, uint256 wad) public returns (bool) {\\n        require(balanceOf[src] >= wad);\\n\\n        if (src != msg.sender && allowance[src][msg.sender] != type(uint256).max) {\\n            require(allowance[src][msg.sender] >= wad);\\n            allowance[src][msg.sender] -= wad;\\n        }\\n\\n        balanceOf[src] -= wad;\\n        balanceOf[dst] += wad;\\n\\n        emit Transfer(src, dst, wad);\\n\\n        return true;\\n    }\\n\\n    function testSuccess() public {}\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"MakerDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"MakerWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferPrepared\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"fromToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"toToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"payFromAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"receiveToAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"swapFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mtFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sellOrNot\",\"type\":\"uint256\"}],\"name\":\"Swap\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_CREATOR_\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_NEW_OWNER_\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_OWNER_\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allFlag\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"borrow\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"fromToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"toToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"quoteAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPayAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"buyToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"checkBorrowSafe\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"checkCanBeLiquidated\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"checkSafe\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"finishLiquidation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getD3MMInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"oracle\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"maker\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"feeRateModel\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"maintainer\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDepositedTokenList\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getFeeRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"feeRate\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPoolTokenlist\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"fromToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"toToken\",\"type\":\"address\"}],\"name\":\"getRangeOrderState\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"oracle\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"askDownPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"askUpPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bidDownPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bidUpPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"askAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bidAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"kAsk\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"kBid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cumulativeAsk\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cumulativeBid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swapFeeRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mtFeeRate\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.TokenMMInfo\",\"name\":\"fromTokenMMInfo\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"askDownPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"askUpPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bidDownPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bidUpPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"askAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bidAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"kAsk\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"kBid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cumulativeAsk\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cumulativeBid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swapFeeRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mtFeeRate\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.TokenMMInfo\",\"name\":\"toTokenMMInfo\",\"type\":\"tuple\"}],\"internalType\":\"struct Types.RangeOrderState\",\"name\":\"roState\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getTokenMMOtherInfoForRead\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"askAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bidAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"kAsk\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"kBid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cumulativeAsk\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cumulativeBid\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getTokenMMPriceInfoForRead\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"askDownPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"askUpPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bidDownPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bidUpPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swapFee\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getTokenReserve\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"maker\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"oracle\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"feeRateModel\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"maintainer\",\"type\":\"address\"}],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"initOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isInLiquidation\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"makerDeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"makerWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"fromToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"toToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"toAmount\",\"type\":\"uint256\"}],\"name\":\"queryBuyTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"payFromAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"receiveToAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vusdAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swapFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mtFee\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"fromToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"toToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fromAmount\",\"type\":\"uint256\"}],\"name\":\"querySellTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"payFromAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"receiveToAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vusdAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swapFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mtFee\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"repay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"repayAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"fromToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"toToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fromAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minReceiveAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"sellToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newFlag\",\"type\":\"uint256\"}],\"name\":\"setNewAllFlag\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newMaker\",\"type\":\"address\"}],\"name\":\"setNewMaker\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startLiquidation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenCumMap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"cumulativeAsk\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cumulativeBid\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"updateReserveByVault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]", "ContractName": "D3MM", "CompilerVersion": "v0.8.16+commit.07a7930e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}