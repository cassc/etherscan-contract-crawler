{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/modules/ERC1155Module.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\\\";\\n\\nimport \\\"./IModule.sol\\\";\\nimport \\\"../Utils.sol\\\";\\n\\n/// @title Cyan Wallet ERC1155 Module - A Cyan wallet's ERC1155 token handling module.\\n/// @author Bulgantamir Gankhuyag - <bulgaa@usecyan.com>\\n/// @author Naranbayar Uuganbayar - <naba@usecyan.com>\\ncontract ERC1155Module is IModule {\\n    // keccak256(\\\"wallet.ERC1155Module.lockedERC1155\\\")\\n    bytes32 private constant LOCKER_SLOT = 0xdcc609ac7fc3b6a216ce1445788736c9dbe88a58b25a13af71623e6da931efa0;\\n\\n    bytes4 private constant ERC1155_SAFE_TRANSFER_FROM = IERC1155.safeTransferFrom.selector;\\n    bytes4 private constant ERC1155_SAFE_BATCH_TRANSFER_FROM = IERC1155.safeBatchTransferFrom.selector;\\n\\n    event IncreaseLockedERC1155Token(address collection, uint256 tokenId, uint256 amount);\\n    event DecreaseLockedERC1155Token(address collection, uint256 tokenId, uint256 amount);\\n\\n    /// @notice Increases locked ERC1155 tokens.\\n    /// @param collection Token address.\\n    /// @param tokenId ID of the token.\\n    /// @param amount Token amount to be locked.\\n    function increaseLockedERC1155Token(\\n        address collection,\\n        uint256 tokenId,\\n        uint256 amount\\n    ) external {\\n        require(_isAvailable(collection, tokenId, amount), \\\"Cannot perform this action on locked token.\\\");\\n        _getLockedTokens()[collection][tokenId] += amount;\\n        emit IncreaseLockedERC1155Token(collection, tokenId, amount);\\n    }\\n\\n    /// @notice Decrease locked ERC1155 tokens.\\n    /// @param collection Token address.\\n    /// @param tokenId ID of the token.\\n    /// @param amount Token amount to be unlocked.\\n    function decreaseLockedERC1155Token(\\n        address collection,\\n        uint256 tokenId,\\n        uint256 amount\\n    ) external {\\n        require(getLockedAmount(collection, tokenId) >= amount, \\\"Amount must not be greater than locked amount.\\\");\\n        _getLockedTokens()[collection][tokenId] -= amount;\\n        emit DecreaseLockedERC1155Token(collection, tokenId, amount);\\n    }\\n\\n    /// @inheritdoc IModule\\n    function handleTransaction(\\n        address to,\\n        uint256 value,\\n        bytes calldata data\\n    ) external payable override returns (bytes memory) {\\n        bytes4 funcHash = Utils.parseFunctionSelector(data);\\n        if (funcHash == ERC1155_SAFE_TRANSFER_FROM) {\\n            (, , uint256 tokenId, uint256 amount, ) = abi.decode(data[4:], (address, address, uint256, uint256, bytes));\\n            require(_isAvailable(to, tokenId, amount), \\\"Cannot perform this action on locked token.\\\");\\n        }\\n\\n        if (funcHash == ERC1155_SAFE_BATCH_TRANSFER_FROM) {\\n            (, , uint256[] memory ids, uint256[] memory amounts, ) = abi.decode(\\n                data[4:],\\n                (address, address, uint256[], uint256[], bytes)\\n            );\\n            require(ids.length == amounts.length, \\\"IDs and amounts length mismatch\\\");\\n\\n            for (uint256 i = 0; i < ids.length; i++) {\\n                require(_isAvailable(to, ids[i], amounts[i]), \\\"Cannot perform this action on locked token.\\\");\\n            }\\n        }\\n        return Utils._execute(to, value, data);\\n    }\\n\\n    /// @notice Allows operators to get the defaulted tokens.\\n    ///     Note: Can only transfer if token is locked.\\n    /// @param collection Collection address.\\n    /// @param tokenId Token ID.\\n    /// @param amount Amount.\\n    /// @param to Receiver address.\\n    function transferDefaultedERC1155(\\n        address collection,\\n        uint256 tokenId,\\n        uint256 amount,\\n        address to\\n    ) external returns (bytes memory) {\\n        require(getLockedAmount(collection, tokenId) >= amount, \\\"Cannot perform this action on non-locked token.\\\");\\n        _getLockedTokens()[collection][tokenId] -= amount;\\n\\n        bytes memory data = abi.encodeWithSelector(\\n            ERC1155_SAFE_TRANSFER_FROM,\\n            address(this),\\n            to,\\n            tokenId,\\n            amount,\\n            \\\"0x\\\"\\n        );\\n        return Utils._execute(collection, 0, data);\\n    }\\n\\n    /// @notice Returns locked amount of the token.\\n    /// @param collection Collection address.\\n    /// @param tokenId Token ID.\\n    /// @return amount Locked amount.\\n    function getLockedAmount(address collection, uint256 tokenId) public view returns (uint256) {\\n        return _getLockedTokens()[collection][tokenId];\\n    }\\n\\n    /// @dev Returns the map of the locked tokens.\\n    /// @return result Map of the locked tokens.\\n    ///     Note: Collection address => Token ID => Locked amount\\n    function _getLockedTokens() internal pure returns (mapping(address => mapping(uint256 => uint256)) storage result) {\\n        assembly {\\n            result.slot := LOCKER_SLOT\\n        }\\n    }\\n\\n    /// @dev Checks the amount of non-locked tokens available in the wallet.\\n    /// @param collection Address of the collection.\\n    /// @param tokenId Token ID.\\n    /// @param amount Requesting amount.\\n    /// @return Boolean to give truthy if requested amount of non-locked tokens are available.\\n    function _isAvailable(\\n        address collection,\\n        uint256 tokenId,\\n        uint256 amount\\n    ) internal view returns (bool) {\\n        uint256 balance = IERC1155(collection).balanceOf(address(this), tokenId);\\n        uint256 lockedAmount = getLockedAmount(collection, tokenId);\\n\\n        return lockedAmount + amount <= balance;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Utils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\nlibrary Utils {\\n    /// @notice Executes a transaction to the given address.\\n    /// @param to Target address.\\n    /// @param value Native token value to be sent to the address.\\n    /// @param data Data to be sent to the address.\\n    /// @return result Result of the transaciton.\\n    function _execute(\\n        address to,\\n        uint256 value,\\n        bytes memory data\\n    ) internal returns (bytes memory result) {\\n        assembly {\\n            let success := call(gas(), to, value, add(data, 0x20), mload(data), 0, 0)\\n\\n            mstore(result, returndatasize())\\n            returndatacopy(add(result, 0x20), 0, returndatasize())\\n\\n            if eq(success, 0) {\\n                revert(add(result, 0x20), returndatasize())\\n            }\\n        }\\n    }\\n\\n    /// @notice Recover signer address from signature.\\n    /// @param signedHash Arbitrary length data signed on the behalf of the wallet.\\n    /// @param signature Signature byte array associated with signedHash.\\n    /// @return Recovered signer address.\\n    function recoverSigner(bytes32 signedHash, bytes memory signature) internal pure returns (address) {\\n        uint8 v;\\n        bytes32 r;\\n        bytes32 s;\\n        // we jump 32 (0x20) as the first slot of bytes contains the length\\n        // we jump 65 (0x41) per signature\\n        // for v we load 32 bytes ending with v (the first 31 come from s) then apply a mask\\n        assembly {\\n            r := mload(add(signature, 0x20))\\n            s := mload(add(signature, 0x40))\\n            v := byte(0, mload(add(signature, 0x60)))\\n        }\\n        require(v == 27 || v == 28, \\\"Bad v value in signature.\\\");\\n\\n        address recoveredAddress = ecrecover(signedHash, v, r, s);\\n        require(recoveredAddress != address(0), \\\"ecrecover returned 0.\\\");\\n        return recoveredAddress;\\n    }\\n\\n    /// @notice Helper method to parse the function selector from data.\\n    /// @param data Any data to be parsed, mostly calldata of transaction.\\n    /// @return result Parsed function sighash.\\n    function parseFunctionSelector(bytes memory data) internal pure returns (bytes4 result) {\\n        require(data.length >= 4, \\\"Invalid data.\\\");\\n        assembly {\\n            result := mload(add(data, 0x20))\\n        }\\n    }\\n\\n    /// @notice Parse uint256 from given data.\\n    /// @param data Any data to be parsed, mostly calldata of transaction.\\n    /// @param position Position in the data.\\n    /// @return result Uint256 parsed from given data.\\n    function getUint256At(bytes memory data, uint8 position) internal pure returns (uint256 result) {\\n        assembly {\\n            result := mload(add(data, add(position, 0x20)))\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/modules/IModule.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\ninterface IModule {\\n    /// @notice Executes given transaction data to given address.\\n    /// @param to Target contract address.\\n    /// @param value Value of the given transaction.\\n    /// @param data Calldata of the transaction.\\n    /// @return Result of the execution.\\n    function handleTransaction(\\n        address to,\\n        uint256 value,\\n        bytes calldata data\\n    ) external payable returns (bytes memory);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/IERC1155.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155 is IERC165 {\\n    /**\\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\\n     */\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n    /**\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n     * transfers.\\n     */\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] values\\n    );\\n\\n    /**\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\n     * `approved`.\\n     */\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\n     *\\n     * If an {URI} event was emitted for `id`, the standard\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\n     * returned by {IERC1155MetadataURI-uri}.\\n     */\\n    event URI(string value, uint256 indexed id);\\n\\n    /**\\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\\n        external\\n        view\\n        returns (uint256[] memory);\\n\\n    /**\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `operator` cannot be the caller.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 500\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DecreaseLockedERC1155Token\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"IncreaseLockedERC1155Token\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"decreaseLockedERC1155Token\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getLockedAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"handleTransaction\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"increaseLockedERC1155Token\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"transferDefaultedERC1155\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "ERC1155Module", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "500", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}