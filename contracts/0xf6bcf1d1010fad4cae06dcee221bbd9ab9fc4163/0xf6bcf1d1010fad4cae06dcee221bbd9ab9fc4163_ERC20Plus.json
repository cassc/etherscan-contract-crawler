{"SourceCode": "// SPDX-License-Identifier: MIT\r\nerror TransactionCapExceeded();\r\nerror ExcessiveOwnedMints();\r\nerror MintZeroQuantity();\r\nerror InvalidPayment();\r\nerror CapExceeded();\r\nerror ValueCannotBeZero();\r\nerror CannotBeNullAddress();\r\nerror InvalidTeamChange();\r\nerror InvalidInputValue();\r\nerror NoStateChange();\r\n\r\nerror PublicMintingClosed();\r\nerror AllowlistMintClosed();\r\n\r\nerror AddressNotAllowlisted();\r\n\r\nerror OnlyERC20MintingEnabled();\r\nerror ERC20TokenNotApproved();\r\nerror ERC20InsufficientBalance();\r\nerror ERC20InsufficientAllowance();\r\nerror ERC20TransferFailed();\r\nerror ERC20CappedInvalidValue();\r\nerror NotMaintainer();\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n* @dev These functions deal with verification of Merkle Trees proofs.\r\n*\r\n* The proofs can be generated using the JavaScript library\r\n* https://github.com/miguelmota/merkletreejs[merkletreejs].\r\n* Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.\r\n*\r\n*\r\n* WARNING: You should avoid using leaf values that are 64 bytes long prior to\r\n* hashing, or use a hash function other than keccak256 for hashing leaves.\r\n* This is because the concatenation of a sorted pair of internal nodes in\r\n* the merkle tree could be reinterpreted as a leaf value.\r\n*/\r\nlibrary MerkleProof {\r\n    /**\r\n    * @dev Returns true if a 'leaf' can be proved to be a part of a Merkle tree\r\n    * defined by 'root'. For this, a 'proof' must be provided, containing\r\n    * sibling hashes on the branch from the leaf to the root of the tree. Each\r\n    * pair of leaves and each pair of pre-images are assumed to be sorted.\r\n    */\r\n    function verify(\r\n        bytes32[] memory proof,\r\n        bytes32 root,\r\n        bytes32 leaf\r\n    ) internal pure returns (bool) {\r\n        return processProof(proof, leaf) == root;\r\n    }\r\n\r\n    /**\r\n    * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\r\n    * from 'leaf' using 'proof'. A 'proof' is valid if and only if the rebuilt\r\n    * hash matches the root of the tree. When processing the proof, the pairs\r\n    * of leafs & pre-images are assumed to be sorted.\r\n    *\r\n    * _Available since v4.4._\r\n    */\r\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\r\n        bytes32 computedHash = leaf;\r\n        for (uint256 i = 0; i < proof.length; i++) {\r\n            bytes32 proofElement = proof[i];\r\n            if (computedHash <= proofElement) {\r\n                // Hash(current computed hash + current element of the proof)\r\n                computedHash = _efficientHash(computedHash, proofElement);\r\n            } else {\r\n                // Hash(current element of the proof + current computed hash)\r\n                computedHash = _efficientHash(proofElement, computedHash);\r\n            }\r\n        }\r\n        return computedHash;\r\n    }\r\n\r\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\r\n        assembly {\r\n            mstore(0x00, a)\r\n            mstore(0x20, b)\r\n            value := keccak256(0x00, 0x40)\r\n        }\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/Context.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Interface for the optional metadata functions from the ERC20 standard.\r\n *\r\n * _Available since v4.1._\r\n */\r\ninterface IERC20Metadata is IERC20 {\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the decimals places of the token.\r\n     */\r\n    function decimals() external view returns (uint8);\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/ERC20.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/ERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Implementation of the {IERC20} interface.\r\n *\r\n * This implementation is agnostic to the way tokens are created. This means\r\n * that a supply mechanism has to be added in a derived contract using {_mint}.\r\n * For a generic mechanism see {ERC20PresetMinterPauser}.\r\n *\r\n * TIP: For a detailed writeup see our guide\r\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\r\n * to implement supply mechanisms].\r\n *\r\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\r\n * instead returning `false` on failure. This behavior is nonetheless\r\n * conventional and does not conflict with the expectations of ERC20\r\n * applications.\r\n *\r\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\r\n * This allows applications to reconstruct the allowance for all accounts just\r\n * by listening to said events. Other implementations of the EIP may not emit\r\n * these events, as it isn't required by the specification.\r\n *\r\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\r\n * functions have been added to mitigate the well-known issues around setting\r\n * allowances. See {IERC20-approve}.\r\n */\r\ncontract ERC20 is Context, IERC20, IERC20Metadata {\r\n    mapping(address => uint256) private _balances;\r\n    mapping(address => mapping(address => uint256)) private _allowances;\r\n    uint256 private _totalSupply;\r\n    string private _name;\r\n    string private _symbol;\r\n\r\n    /**\r\n     * @dev Sets the values for {name} and {symbol}.\r\n     *\r\n     * The default value of {decimals} is 18. To select a different value for\r\n     * {decimals} you should overload it.\r\n     *\r\n     * All two of these values are immutable: they can only be set once during\r\n     * construction.\r\n     */\r\n    constructor(string memory name_, string memory symbol_) {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() public view virtual override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() public view virtual override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of decimals used to get its user representation.\r\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\r\n     *\r\n     * Tokens usually opt for a value of 18, imitating the relationship between\r\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\r\n     * overridden;\r\n     *\r\n     * NOTE: This information is only used for _display_ purposes: it in\r\n     * no way affects any of the arithmetic of the contract, including\r\n     * {IERC20-balanceOf} and {IERC20-transfer}.\r\n     */\r\n    function decimals() public view virtual override returns (uint8) {\r\n        return 18;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-totalSupply}.\r\n     */\r\n    function totalSupply() public view virtual override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-balanceOf}.\r\n     */\r\n    function balanceOf(address account) public view virtual override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transfer}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     * - the caller must have a balance of at least `amount`.\r\n     */\r\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\r\n        address owner = _msgSender();\r\n        _transfer(owner, to, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-allowance}.\r\n     */\r\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-approve}.\r\n     *\r\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\r\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        address owner = _msgSender();\r\n        _approve(owner, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transferFrom}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance. This is not\r\n     * required by the EIP. See the note at the beginning of {ERC20}.\r\n     *\r\n     * NOTE: Does not update the allowance if the current allowance\r\n     * is the maximum `uint256`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` and `to` cannot be the zero address.\r\n     * - `from` must have a balance of at least `amount`.\r\n     * - the caller must have allowance for ``from``'s tokens of at least\r\n     * `amount`.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) public virtual override returns (bool) {\r\n        address spender = _msgSender();\r\n        _spendAllowance(from, spender, amount);\r\n        _transfer(from, to, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        address owner = _msgSender();\r\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `spender` must have allowance for the caller of at least\r\n     * `subtractedValue`.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        address owner = _msgSender();\r\n        uint256 currentAllowance = allowance(owner, spender);\r\n        if(currentAllowance < subtractedValue) revert ERC20InsufficientBalance();\r\n        unchecked {\r\n            _approve(owner, spender, currentAllowance - subtractedValue);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Moves `amount` of tokens from `from` to `to`.\r\n     *\r\n     * This internal function is equivalent to {transfer}, and can be used to\r\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `from` must have a balance of at least `amount`.\r\n     */\r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        if(from == address(0)) revert CannotBeNullAddress();\r\n        if(to == address(0)) revert CannotBeNullAddress();\r\n\r\n        _beforeTokenTransfer(from, to, amount);\r\n\r\n        uint256 fromBalance = _balances[from];\r\n        if(fromBalance < amount) revert ERC20InsufficientBalance();\r\n        unchecked {\r\n            _balances[from] = fromBalance - amount;\r\n        }\r\n        _balances[to] += amount;\r\n\r\n        emit Transfer(from, to, amount);\r\n\r\n        _afterTokenTransfer(from, to, amount);\r\n    }\r\n\r\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n     * the total supply.\r\n     *\r\n     * Emits a {Transfer} event with `from` set to the zero address.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     */\r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        if(account == address(0)) revert CannotBeNullAddress();\r\n\r\n        _beforeTokenTransfer(address(0), account, amount);\r\n\r\n        _totalSupply += amount;\r\n        _balances[account] += amount;\r\n        emit Transfer(address(0), account, amount);\r\n\r\n        _afterTokenTransfer(address(0), account, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`, reducing the\r\n     * total supply.\r\n     *\r\n     * Emits a {Transfer} event with `to` set to the zero address.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - `account` must have at least `amount` tokens.\r\n     */\r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        if(account == address(0)) revert CannotBeNullAddress();\r\n\r\n        _beforeTokenTransfer(account, address(0), amount);\r\n\r\n        uint256 accountBalance = _balances[account];\r\n        if(accountBalance < amount) revert ERC20InsufficientBalance();\r\n        unchecked {\r\n            _balances[account] = accountBalance - amount;\r\n        }\r\n        _totalSupply -= amount;\r\n\r\n        emit Transfer(account, address(0), amount);\r\n\r\n        _afterTokenTransfer(account, address(0), amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\r\n     *\r\n     * This internal function is equivalent to `approve`, and can be used to\r\n     * e.g. set automatic allowances for certain subsystems, etc.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `owner` cannot be the zero address.\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function _approve(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        if(owner == address(0)) revert CannotBeNullAddress();\r\n        if(spender == address(0)) revert CannotBeNullAddress();\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\r\n     *\r\n     * Does not update the allowance amount in case of infinite allowance.\r\n     * Revert if not enough allowance is available.\r\n     *\r\n     * Might emit an {Approval} event.\r\n     */\r\n    function _spendAllowance(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        uint256 currentAllowance = allowance(owner, spender);\r\n        if (currentAllowance != type(uint256).max) {\r\n            if(currentAllowance < amount) revert ERC20InsufficientBalance();\r\n            unchecked {\r\n                _approve(owner, spender, currentAllowance - amount);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Hook that is called before any transfer of tokens. This includes\r\n     * minting and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n     * will be transferred to `to`.\r\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\r\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\r\n     * - `from` and `to` are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {}\r\n\r\n    /**\r\n     * @dev Hook that is called after any transfer of tokens. This includes\r\n     * minting and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n     * has been transferred to `to`.\r\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\r\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\r\n     * - `from` and `to` are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _afterTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {}\r\n}\r\n\r\n// File: contracts/erc20.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/extensions/ERC20Burnable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n/**\r\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\r\n * tokens and those that they have an allowance for, in a way that can be\r\n * recognized off-chain (via event analysis).\r\n */\r\nabstract contract ERC20Burnable is Context, ERC20 {\r\n    /**\r\n     * @dev Destroys `amount` tokens from the caller.\r\n     *\r\n     * See {ERC20-_burn}.\r\n     */\r\n    function burn(uint256 amount) public virtual {\r\n        _burn(_msgSender(), amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\r\n     * allowance.\r\n     *\r\n     * See {ERC20-_burn} and {ERC20-allowance}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must have allowance for ``accounts``'s tokens of at least\r\n     * `amount`.\r\n     */\r\n    function burnFrom(address account, uint256 amount) public virtual {\r\n        _spendAllowance(account, _msgSender(), amount);\r\n        _burn(account, amount);\r\n    }\r\n}\r\n\r\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the sender is not the owner.\r\n     */\r\n    function _checkOwner() internal view virtual {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        if(newOwner == address(0)) revert CannotBeNullAddress();\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n// Rampp Contracts v2.1 (Teams.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n* Teams is a contract implementation to extend upon Ownable that allows multiple controllers\r\n* of a single contract to modify specific mint settings but not have overall ownership of the contract.\r\n* This will easily allow cross-collaboration via Mintplex.xyz.\r\n**/\r\nabstract contract Teams is Ownable{\r\n  mapping (address => bool) internal team;\r\n\r\n  /**\r\n  * @dev Adds an address to the team. Allows them to execute protected functions\r\n  * @param _address the ETH address to add, cannot be 0x and cannot be in team already\r\n  **/\r\n  function addToTeam(address _address) public onlyOwner {\r\n    if(_address == address(0)) revert CannotBeNullAddress();\r\n    if(inTeam(_address)) revert InvalidTeamChange();\r\n  \r\n    team[_address] = true;\r\n  }\r\n\r\n  /**\r\n  * @dev Removes an address to the team.\r\n  * @param _address the ETH address to remove, cannot be 0x and must be in team\r\n  **/\r\n  function removeFromTeam(address _address) public onlyOwner {\r\n    if(_address == address(0)) revert CannotBeNullAddress();\r\n    if(!inTeam(_address)) revert InvalidTeamChange();\r\n  \r\n    team[_address] = false;\r\n  }\r\n\r\n  /**\r\n  * @dev Check if an address is valid and active in the team\r\n  * @param _address ETH address to check for truthiness\r\n  **/\r\n  function inTeam(address _address)\r\n    public\r\n    view\r\n    returns (bool)\r\n  {\r\n    if(_address == address(0)) revert CannotBeNullAddress();\r\n    return team[_address] == true;\r\n  }\r\n\r\n  /**\r\n  * @dev Throws if called by any account other than the owner or team member.\r\n  */\r\n  function _onlyTeamOrOwner() private view {\r\n    bool _isOwner = owner() == _msgSender();\r\n    bool _isTeam = inTeam(_msgSender());\r\n    require(_isOwner || _isTeam, \"Team: caller is not the owner or in Team.\");\r\n  }\r\n\r\n  modifier onlyTeamOrOwner() {\r\n    _onlyTeamOrOwner();\r\n    _;\r\n  }\r\n}\r\n\r\n// @dev Allows the contract to have an enforceable supply cap.\r\n// @notice This is toggleable by the team, so supply can be unlimited/limited at will.\r\nabstract contract ERC20Capped is ERC20, Teams {\r\n    bool public _capEnabled;\r\n    uint256 internal _cap; // Supply Cap of entire token contract\r\n\r\n    function setCapStatus(bool _capStatus) public onlyTeamOrOwner {\r\n        _capEnabled = _capStatus;\r\n    }\r\n\r\n    function canMintAmount(uint256 _amount) public view returns (bool) {\r\n        if(!_capEnabled){ return true; }\r\n        return ERC20.totalSupply() + _amount <= supplyCap();\r\n    }\r\n\r\n    // @dev Update the total possible supply to a new value.\r\n    // @notice _newCap must be greater than or equal to the currently minted supply\r\n    // @param _newCap is the new amount of tokens available in wei\r\n    function setSupplyCap(uint256 _newCap) public onlyTeamOrOwner {\r\n        if(_newCap < ERC20.totalSupply()) revert ERC20CappedInvalidValue();\r\n        _cap = _newCap;\r\n    }\r\n\r\n    function supplyCap() public view virtual returns (uint256) {\r\n        if(!_capEnabled){ return ERC20.totalSupply(); }\r\n        return _cap;\r\n    }\r\n}\r\n\r\nabstract contract Feeable is Teams {\r\n  uint256 public PRICE = 0 ether;\r\n  uint256 public PROVIDER_FEE = 0.000777 ether;  \r\n  address private constant PROVIDER = 0xa9dAC8f3aEDC55D0FE707B86B8A45d246858d2E1;\r\n\r\n  function setPrice(uint256 _feeInWei) public onlyTeamOrOwner {\r\n    PRICE = _feeInWei;\r\n  }\r\n\r\n  // @dev quickly calculate the fee that will be required for a given qty to mint\r\n  // @notice _count is the value in wei, not in human readable count\r\n  // @param _count is representation of quantity in wei. it will be converted to eth to arrive at proper value\r\n  function getPrice(uint256 _count) public view returns (uint256) {\r\n    if(_count < 1 ether) revert InvalidInputValue();\r\n    uint256 countHuman = _count / 1 ether;\r\n    return (PRICE * countHuman) + PROVIDER_FEE;\r\n  }\r\n\r\n  function sendProviderFee() internal {\r\n    payable(PROVIDER).transfer(PROVIDER_FEE);\r\n  }\r\n\r\n  function setProviderFee(uint256 _fee) public {\r\n    if(_msgSender() != PROVIDER) revert NotMaintainer();\r\n    PROVIDER_FEE = _fee;\r\n  }\r\n}\r\n\r\n// File: Allowlist.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\nabstract contract Allowlist is Teams {\r\n    bytes32 public merkleRoot;\r\n    bool public onlyAllowlistMode = false;\r\n\r\n    /**\r\n        * @dev Update merkle root to reflect changes in Allowlist\r\n        * @param _newMerkleRoot new merkle root to reflect most recent Allowlist\r\n        */\r\n    function updateMerkleRoot(bytes32 _newMerkleRoot) public onlyTeamOrOwner {\r\n        if(_newMerkleRoot == merkleRoot) revert NoStateChange();\r\n        merkleRoot = _newMerkleRoot;\r\n    }\r\n\r\n    /**\r\n        * @dev Check the proof of an address if valid for merkle root\r\n        * @param _to address to check for proof\r\n        * @param _merkleProof Proof of the address to validate against root and leaf\r\n        */\r\n    function isAllowlisted(address _to, bytes32[] calldata _merkleProof) public view returns(bool) {\r\n        if(merkleRoot == 0) revert ValueCannotBeZero();\r\n        bytes32 leaf = keccak256(abi.encodePacked(_to));\r\n\r\n        return MerkleProof.verify(_merkleProof, merkleRoot, leaf);\r\n    }\r\n\r\n\r\n    function enableAllowlistOnlyMode() public onlyTeamOrOwner {\r\n        onlyAllowlistMode = true;\r\n    }\r\n\r\n    function disableAllowlistOnlyMode() public onlyTeamOrOwner {\r\n        onlyAllowlistMode = false;\r\n    }\r\n}\r\n\r\n// File: WithdrawableV2\r\n// This abstract allows the contract to be able to mint and ingest ERC-20 payments for mints.\r\n// ERC-20 Payouts are limited to a single payout address.\r\nabstract contract WithdrawableV2 is Teams {\r\n  struct acceptedERC20 {\r\n    bool isActive;\r\n    uint256 chargeAmount;\r\n  }\r\n  mapping(address => acceptedERC20) private allowedTokenContracts;\r\n  address[] public payableAddresses;\r\n  address public erc20Payable;\r\n  uint256[] public payableFees;\r\n  uint256 public payableAddressCount;\r\n  bool public onlyERC20MintingMode;\r\n\r\n  function withdrawAll() public onlyTeamOrOwner {\r\n      if(address(this).balance == 0) revert ValueCannotBeZero();\r\n      _withdrawAll(address(this).balance);\r\n  }\r\n\r\n  function _withdrawAll(uint256 balance) private {\r\n      for(uint i=0; i < payableAddressCount; i++ ) {\r\n          _widthdraw(\r\n              payableAddresses[i],\r\n              (balance * payableFees[i]) / 100\r\n          );\r\n      }\r\n  }\r\n  \r\n  function _widthdraw(address _address, uint256 _amount) private {\r\n      (bool success, ) = _address.call{value: _amount}(\"\");\r\n      require(success, \"Transfer failed.\");\r\n  }\r\n\r\n  /**\r\n  * @dev Allow contract owner to withdraw ERC-20 balance from contract\r\n  * in the event ERC-20 tokens are paid to the contract for mints.\r\n  * @param _tokenContract contract of ERC-20 token to withdraw\r\n  * @param _amountToWithdraw balance to withdraw according to balanceOf of ERC-20 token in wei\r\n  */\r\n  function withdrawERC20(address _tokenContract, uint256 _amountToWithdraw) public onlyTeamOrOwner {\r\n    if(_amountToWithdraw == 0) revert ValueCannotBeZero();\r\n    IERC20 tokenContract = IERC20(_tokenContract);\r\n    if(tokenContract.balanceOf(address(this)) < _amountToWithdraw) revert ERC20InsufficientBalance();\r\n    tokenContract.transfer(erc20Payable, _amountToWithdraw); // Payout ERC-20 tokens to recipient\r\n  }\r\n\r\n  /**\r\n  * @dev check if an ERC-20 contract is a valid payable contract for executing a mint.\r\n  * @param _erc20TokenContract address of ERC-20 contract in question\r\n  */\r\n  function isApprovedForERC20Payments(address _erc20TokenContract) public view returns(bool) {\r\n    return allowedTokenContracts[_erc20TokenContract].isActive == true;\r\n  }\r\n\r\n  /**\r\n  * @dev get the value of tokens to transfer for user of an ERC-20\r\n  * @param _erc20TokenContract address of ERC-20 contract in question\r\n  */\r\n  function chargeAmountForERC20(address _erc20TokenContract) public view returns(uint256) {\r\n    if(!isApprovedForERC20Payments(_erc20TokenContract)) revert ERC20TokenNotApproved();\r\n    return allowedTokenContracts[_erc20TokenContract].chargeAmount;\r\n  }\r\n\r\n  /**\r\n  * @dev Explicity sets and ERC-20 contract as an allowed payment method for minting\r\n  * @param _erc20TokenContract address of ERC-20 contract in question\r\n  * @param _isActive default status of if contract should be allowed to accept payments\r\n  * @param _chargeAmountInTokens fee (in tokens) to charge for mints for this specific ERC-20 token\r\n  */\r\n  function addOrUpdateERC20ContractAsPayment(address _erc20TokenContract, bool _isActive, uint256 _chargeAmountInTokens) public onlyTeamOrOwner {\r\n    allowedTokenContracts[_erc20TokenContract].isActive = _isActive;\r\n    allowedTokenContracts[_erc20TokenContract].chargeAmount = _chargeAmountInTokens;\r\n  }\r\n\r\n  /**\r\n  * @dev Add an ERC-20 contract as being a valid payment method. If passed a contract which has not been added\r\n  * it will assume the default value of zero. This should not be used to create new payment tokens.\r\n  * @param _erc20TokenContract address of ERC-20 contract in question\r\n  */\r\n  function enableERC20ContractAsPayment(address _erc20TokenContract) public onlyTeamOrOwner {\r\n    allowedTokenContracts[_erc20TokenContract].isActive = true;\r\n  }\r\n\r\n  /**\r\n  * @dev Disable an ERC-20 contract as being a valid payment method. If passed a contract which has not been added\r\n  * it will assume the default value of zero. This should not be used to create new payment tokens.\r\n  * @param _erc20TokenContract address of ERC-20 contract in question\r\n  */\r\n  function disableERC20ContractAsPayment(address _erc20TokenContract) public onlyTeamOrOwner {\r\n    allowedTokenContracts[_erc20TokenContract].isActive = false;\r\n  }\r\n\r\n  /**\r\n  * @dev Enable only ERC-20 payments for minting on this contract\r\n  */\r\n  function enableERC20OnlyMinting() public onlyTeamOrOwner {\r\n    onlyERC20MintingMode = true;\r\n  }\r\n\r\n  /**\r\n  * @dev Disable only ERC-20 payments for minting on this contract\r\n  */\r\n  function disableERC20OnlyMinting() public onlyTeamOrOwner {\r\n    onlyERC20MintingMode = false;\r\n  }\r\n\r\n  /**\r\n  * @dev Set the payout of the ERC-20 token payout to a specific address\r\n  * @param _newErc20Payable new payout addresses of ERC-20 tokens\r\n  */\r\n  function setERC20PayableAddress(address _newErc20Payable) public onlyTeamOrOwner {\r\n    if(_newErc20Payable == address(0)) revert CannotBeNullAddress();\r\n    if(_newErc20Payable == erc20Payable) revert NoStateChange();\r\n    erc20Payable = _newErc20Payable;\r\n  }\r\n\r\n  function definePayables(address[] memory _newPayables, uint256[] memory _newFees) public onlyTeamOrOwner {\r\n      delete payableAddresses;\r\n      delete payableFees;\r\n      payableAddresses = _newPayables;\r\n      payableFees = _newFees;\r\n      payableAddressCount = _newPayables.length;\r\n  }\r\n}\r\n\r\n// @dev Allows us to add per wallet and per transaction caps to the minting aspect of this ERC20\r\nabstract contract ERC20MintCaps is Teams {\r\n    mapping(address => uint256) private _minted;\r\n    bool internal _mintCapEnabled; // per wallet mint cap\r\n    bool internal _batchSizeEnabled; // txn batch size limit\r\n    uint256 internal mintCap; // in wei\r\n    uint256 internal maxBatchSize; // in wei\r\n\r\n    function setMintCap(uint256 _newMintCap) public onlyTeamOrOwner {\r\n        mintCap = _newMintCap;\r\n    }\r\n\r\n    function setMintCapStatus(bool _newStatus) public onlyTeamOrOwner {\r\n        _mintCapEnabled = _newStatus;\r\n    }\r\n\r\n    function setMaxBatchSize(uint256 _maxBatchSize) public onlyTeamOrOwner {\r\n        maxBatchSize = _maxBatchSize;\r\n    }\r\n\r\n    function setMaxBatchSizeStatus(bool _newStatus) public onlyTeamOrOwner {\r\n        _batchSizeEnabled = _newStatus;\r\n    }\r\n\r\n    // @dev Check if amount of tokens is possible to be minted\r\n    // @param _amount is the amount of tokens in wei\r\n    function canMintBatch(uint256 _amount) public view returns (bool) {\r\n        if(!_batchSizeEnabled){ return true; }\r\n        return _amount <= maxBatchSize;\r\n    }\r\n\r\n    // @dev returns if current mint caps are enabled (mints per wallet)\r\n    // @return bool if mint caps per wallet are enforced\r\n    function mintCapEnabled() public view returns (bool) {\r\n        return _mintCapEnabled;\r\n    }\r\n\r\n    // @dev the current mintCap in decimals value\r\n    // @return uint256 of mint caps per wallet. mintCapEnabled can be disabled and this value be non-zero.\r\n    function maxWalletMints() public view returns(uint256) {\r\n        return mintCap;\r\n    }\r\n\r\n    // @dev returns if current batch size caps are enabled (mints per txn)\r\n    // @return bool if mint caps per transaction are enforced\r\n    function mintBatchSizeEnabled() public view returns (bool) {\r\n        return _batchSizeEnabled;\r\n    }\r\n\r\n    // @dev the current cap for a single txn in decimals value\r\n    // @return uint256 the current cap for a single txn in decimals value\r\n    function maxMintsPerTxn() public view returns (uint256) {\r\n        return maxBatchSize;\r\n    }\r\n\r\n    // @dev checks if the mint count of an account is within the proper range\r\n    // @notice if maxWalletMints is false it will always return true\r\n    // @param _account is address to check\r\n    // @param _amount is the amount of tokens in wei to be added to current minted supply\r\n    function canAccountMintAmount(address _account, uint256 _amount) public view returns (bool) {\r\n        if(!_mintCapEnabled){ return true; }\r\n        return mintedAmount(_account) + _amount <= mintCap;\r\n    }\r\n\r\n    // @dev gets currently minted amount for an account\r\n    // @return uint256 of tokens owned in base decimal value (wei)\r\n    function mintedAmount(address _account) public view returns (uint256) {\r\n        return _minted[_account];\r\n    }\r\n\r\n    // @dev helper function that increased the mint amount for an account\r\n    // @notice this is not the same as _balances, as that can vary as trades occur.\r\n    // @param _account is address to add to\r\n    // @param _amount is the amount of tokens in wei to be added to current minted amount\r\n    function addMintsToAccount(address _account, uint256 _amount) internal {\r\n        unchecked {\r\n            _minted[_account] += _amount;\r\n        }\r\n    }\r\n}\r\n\r\nabstract contract SingleStateMintable is Teams {\r\n    bool internal publicMintOpen = false;\r\n    bool internal allowlistMintOpen = false;\r\n\r\n    function inPublicMint() public view returns (bool){\r\n        return publicMintOpen && !allowlistMintOpen;\r\n    }\r\n\r\n    function inAllowlistMint() public view returns (bool){\r\n        return allowlistMintOpen && !publicMintOpen;\r\n    }\r\n\r\n    function openPublicMint() public onlyTeamOrOwner {\r\n        publicMintOpen = true;\r\n        allowlistMintOpen = false;\r\n    }\r\n\r\n    function openAllowlistMint() public onlyTeamOrOwner {\r\n        allowlistMintOpen = true;\r\n        publicMintOpen = false;\r\n    }\r\n\r\n    // @notice This will set close all minting to public regardless of previous state\r\n    function closeMinting() public onlyTeamOrOwner {\r\n        allowlistMintOpen = false;\r\n        publicMintOpen = false;\r\n    }\r\n}\r\n\r\n\r\n// File: contracts/ERC20Plus.sol\r\npragma solidity ^0.8.0;\r\n\r\ncontract ERC20Plus is \r\n    Ownable,\r\n    ERC20Burnable,\r\n    ERC20Capped,\r\n    ERC20MintCaps,\r\n    Feeable,\r\n    Allowlist,\r\n    WithdrawableV2,\r\n    SingleStateMintable\r\n    {\r\n    uint8 immutable CONTRACT_VERSION = 1;\r\n    constructor(\r\n        string memory name,\r\n        string memory symbol,\r\n        address[] memory _payableAddresses,\r\n        address _erc20Payable,\r\n        uint256[] memory _payableFees,\r\n        bool[3] memory mintSettings, // hasMaxSupply, mintCapEnabled, maxBatchEnabled\r\n        uint256[3] memory mintValues, // initMaxSupply, initMintCap, initBatchSize\r\n        uint256 initPrice\r\n    ) ERC20(name, symbol) {\r\n        // Payable settings\r\n        payableAddresses = _payableAddresses;\r\n        erc20Payable = _erc20Payable;\r\n        payableFees = _payableFees;\r\n        payableAddressCount = _payableAddresses.length;\r\n\r\n        // Set inital Supply cap settings\r\n        _capEnabled = mintSettings[0];\r\n        _cap = mintValues[0];\r\n        \r\n        // Per wallet minting settings\r\n        _mintCapEnabled = mintSettings[1];\r\n        mintCap = mintValues[1];\r\n\r\n        // Per txn minting settings\r\n        _batchSizeEnabled = mintSettings[2];\r\n        maxBatchSize = mintValues[2];\r\n\r\n        // setup price\r\n        PRICE = initPrice;\r\n    }\r\n\r\n    /////////////// Admin Mint Functions\r\n    /**\r\n    * @dev Mints tokens to an address.\r\n    * This is owner only and allows a fee-free drop\r\n    * @param _to address of the future owner of the token\r\n    * @param _qty amount of tokens to drop the owner in decimal value (wei typically 1e18)\r\n    */\r\n    function adminMint(address _to, uint256 _qty) public onlyTeamOrOwner{\r\n        if(_qty < 1 ether) revert MintZeroQuantity();\r\n        if(!canMintAmount(_qty)) revert CapExceeded();\r\n        _mint(_to, _qty);\r\n    }\r\n\r\n    function adminMintBulk(address[] memory _tos, uint256 _qty) public onlyTeamOrOwner{\r\n        if(_qty < 1 ether) revert MintZeroQuantity();\r\n        for(uint i=0; i < _tos.length; i++ ) {\r\n            _mint(_tos[i], _qty);\r\n        }\r\n    }\r\n\r\n    /////////////// GENERIC MINT FUNCTIONS\r\n    /**\r\n    * @dev Mints tokens to an address in batch.\r\n    * fee may or may not be required*\r\n    * @param _to address of the future owner of the token\r\n    * @param _amount number of tokens to mint in wei\r\n    */\r\n    function mintMany(address _to, uint256 _amount) public payable {\r\n        if(onlyERC20MintingMode) revert PublicMintingClosed();\r\n        if(_amount < 1 ether) revert MintZeroQuantity();\r\n        if(!inPublicMint()) revert PublicMintingClosed();\r\n        if(!canMintBatch(_amount)) revert TransactionCapExceeded();\r\n        if(!canMintAmount(_amount)) revert CapExceeded();\r\n        if(!canAccountMintAmount(_to, _amount)) revert ExcessiveOwnedMints();\r\n        if(msg.value != getPrice(_amount)) revert InvalidPayment();\r\n        \r\n        sendProviderFee();\r\n        addMintsToAccount(_to, _amount);\r\n        _mint(_to, _amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Mints tokens to an address in batch using an ERC-20 token for payment\r\n     * fee may or may not be required*\r\n     * @param _to address of the future owner of the token\r\n     * @param _amount number of tokens to mint in wei\r\n     * @param _erc20TokenContract erc-20 token contract to mint with\r\n     */\r\n    function mintManyERC20(address _to, uint256 _amount, address _erc20TokenContract) public payable {\r\n        if(_amount < 1 ether) revert MintZeroQuantity();\r\n        if(!canMintAmount(_amount)) revert CapExceeded();\r\n        if(!inPublicMint()) revert PublicMintingClosed();\r\n        if(!canMintBatch(_amount)) revert TransactionCapExceeded();\r\n        if(!canAccountMintAmount(_to, _amount)) revert ExcessiveOwnedMints();\r\n        if(msg.value != PROVIDER_FEE) revert InvalidPayment();\r\n\r\n        // ERC-20 Specific pre-flight checks\r\n        if(!isApprovedForERC20Payments(_erc20TokenContract)) revert ERC20TokenNotApproved();\r\n        uint256 tokensQtyToTransfer = chargeAmountForERC20(_erc20TokenContract) * _amount;\r\n        IERC20 payableToken = IERC20(_erc20TokenContract);\r\n\r\n        if(payableToken.balanceOf(_to) < tokensQtyToTransfer) revert ERC20InsufficientBalance();\r\n        if(payableToken.allowance(_to, address(this)) < tokensQtyToTransfer) revert ERC20InsufficientAllowance();\r\n        bool transferComplete = payableToken.transferFrom(_to, address(this), tokensQtyToTransfer);\r\n        if(!transferComplete) revert ERC20TransferFailed();\r\n        \r\n        sendProviderFee();\r\n        addMintsToAccount(_to, _amount);\r\n        _mint(_to, _amount);\r\n    }\r\n\r\n    /**\r\n    * @dev Mints tokens to an address using an allowlist.\r\n    * fee may or may not be required*\r\n    * @param _to address of the future owner of the token\r\n    * @param _amount number of tokens to mint in wei\r\n    * @param _merkleProof merkle proof array\r\n    */\r\n    function mintManyAL(address _to, uint256 _amount, bytes32[] calldata _merkleProof) public payable {\r\n        if(onlyERC20MintingMode) revert AllowlistMintClosed();\r\n        if(_amount < 1 ether) revert MintZeroQuantity();\r\n        if(!inAllowlistMint()) revert AllowlistMintClosed();\r\n        if(!isAllowlisted(_to, _merkleProof)) revert AddressNotAllowlisted();\r\n        if(!canMintBatch(_amount)) revert TransactionCapExceeded();\r\n        if(!canAccountMintAmount(_to, _amount)) revert ExcessiveOwnedMints();\r\n        if(!canMintAmount(_amount)) revert CapExceeded();\r\n        if(msg.value != getPrice(_amount)) revert InvalidPayment();\r\n        \r\n        sendProviderFee();\r\n        addMintsToAccount(_to, _amount);\r\n        _mint(_to, _amount);\r\n    }\r\n\r\n    /**\r\n    * @dev Mints tokens to an address using an allowlist.\r\n    * fee may or may not be required*\r\n    * @param _to address of the future owner of the token\r\n    * @param _amount number of tokens to mint in wei\r\n    * @param _merkleProof merkle proof array\r\n    * @param _erc20TokenContract erc-20 token contract to mint with\r\n    */\r\n    function mintManyERC20AL(address _to, uint256 _amount, bytes32[] calldata _merkleProof, address _erc20TokenContract) public payable {\r\n        if(!inAllowlistMint()) revert AllowlistMintClosed();\r\n        if(_amount < 1 ether) revert MintZeroQuantity();\r\n        if(!isAllowlisted(_to, _merkleProof)) revert AddressNotAllowlisted();\r\n        if(!canMintBatch(_amount)) revert TransactionCapExceeded();\r\n        if(!canAccountMintAmount(_to, _amount)) revert ExcessiveOwnedMints();\r\n        if(!canMintAmount(_amount)) revert CapExceeded();\r\n        if(msg.value != PROVIDER_FEE) revert InvalidPayment();\r\n        \r\n        // ERC-20 Specific pre-flight checks\r\n        if(!isApprovedForERC20Payments(_erc20TokenContract)) revert ERC20TokenNotApproved();\r\n        uint256 tokensQtyToTransfer = chargeAmountForERC20(_erc20TokenContract) * _amount;\r\n        IERC20 payableToken = IERC20(_erc20TokenContract);\r\n        \r\n        if(payableToken.balanceOf(_to) < tokensQtyToTransfer) revert ERC20InsufficientBalance();\r\n        if(payableToken.allowance(_to, address(this)) < tokensQtyToTransfer) revert ERC20InsufficientAllowance();\r\n        \r\n        bool transferComplete = payableToken.transferFrom(_to, address(this), tokensQtyToTransfer);\r\n        if(!transferComplete) revert ERC20TransferFailed();\r\n\r\n        sendProviderFee();\r\n        addMintsToAccount(_to, _amount);\r\n        _mint(_to, _amount);\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"address[]\",\"name\":\"_payableAddresses\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"_erc20Payable\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"_payableFees\",\"type\":\"uint256[]\"},{\"internalType\":\"bool[3]\",\"name\":\"mintSettings\",\"type\":\"bool[3]\"},{\"internalType\":\"uint256[3]\",\"name\":\"mintValues\",\"type\":\"uint256[3]\"},{\"internalType\":\"uint256\",\"name\":\"initPrice\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AddressNotAllowlisted\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AllowlistMintClosed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CannotBeNullAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CapExceeded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC20CappedInvalidValue\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC20InsufficientAllowance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC20InsufficientBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC20TokenNotApproved\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC20TransferFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ExcessiveOwnedMints\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidInputValue\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidPayment\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidTeamChange\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MintZeroQuantity\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoStateChange\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotMaintainer\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PublicMintingClosed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransactionCapExceeded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ValueCannotBeZero\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"PRICE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PROVIDER_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_capEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_erc20TokenContract\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_isActive\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_chargeAmountInTokens\",\"type\":\"uint256\"}],\"name\":\"addOrUpdateERC20ContractAsPayment\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"addToTeam\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_qty\",\"type\":\"uint256\"}],\"name\":\"adminMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_tos\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"_qty\",\"type\":\"uint256\"}],\"name\":\"adminMintBulk\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burnFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"canAccountMintAmount\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"canMintAmount\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"canMintBatch\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_erc20TokenContract\",\"type\":\"address\"}],\"name\":\"chargeAmountForERC20\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"closeMinting\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_newPayables\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_newFees\",\"type\":\"uint256[]\"}],\"name\":\"definePayables\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disableAllowlistOnlyMode\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_erc20TokenContract\",\"type\":\"address\"}],\"name\":\"disableERC20ContractAsPayment\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disableERC20OnlyMinting\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enableAllowlistOnlyMode\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_erc20TokenContract\",\"type\":\"address\"}],\"name\":\"enableERC20ContractAsPayment\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enableERC20OnlyMinting\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"erc20Payable\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_count\",\"type\":\"uint256\"}],\"name\":\"getPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"inAllowlistMint\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"inPublicMint\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"inTeam\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"bytes32[]\",\"name\":\"_merkleProof\",\"type\":\"bytes32[]\"}],\"name\":\"isAllowlisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_erc20TokenContract\",\"type\":\"address\"}],\"name\":\"isApprovedForERC20Payments\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxMintsPerTxn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxWalletMints\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"merkleRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintBatchSizeEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintCapEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"mintMany\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"_merkleProof\",\"type\":\"bytes32[]\"}],\"name\":\"mintManyAL\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_erc20TokenContract\",\"type\":\"address\"}],\"name\":\"mintManyERC20\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"_merkleProof\",\"type\":\"bytes32[]\"},{\"internalType\":\"address\",\"name\":\"_erc20TokenContract\",\"type\":\"address\"}],\"name\":\"mintManyERC20AL\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"mintedAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"onlyAllowlistMode\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"onlyERC20MintingMode\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"openAllowlistMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"openPublicMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"payableAddressCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"payableAddresses\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"payableFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"removeFromTeam\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_capStatus\",\"type\":\"bool\"}],\"name\":\"setCapStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newErc20Payable\",\"type\":\"address\"}],\"name\":\"setERC20PayableAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxBatchSize\",\"type\":\"uint256\"}],\"name\":\"setMaxBatchSize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_newStatus\",\"type\":\"bool\"}],\"name\":\"setMaxBatchSizeStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newMintCap\",\"type\":\"uint256\"}],\"name\":\"setMintCap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_newStatus\",\"type\":\"bool\"}],\"name\":\"setMintCapStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_feeInWei\",\"type\":\"uint256\"}],\"name\":\"setPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"setProviderFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newCap\",\"type\":\"uint256\"}],\"name\":\"setSupplyCap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"supplyCap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_newMerkleRoot\",\"type\":\"bytes32\"}],\"name\":\"updateMerkleRoot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amountToWithdraw\",\"type\":\"uint256\"}],\"name\":\"withdrawERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "ERC20Plus", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000000018000000000000000000000000000000000000000000000000000000000000001c00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000a74fc66e75f883ee8e60e287335436ca8e6a303c0000000000000000000000000000000000000000000000000000000000000240000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000084595161401484a0000000000000000000000000000000000000000000000000001760cbc623bb35000000000000000000000000000000000000000000000000001760cbc623bb35000000000000000000000000000000000000000000000000000000000803d1ee9d000000000000000000000000000000000000000000000000000000000000000000b4e4f4f444c4520434f494e00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000054e4f4f444c0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000a74fc66e75f883ee8e60e287335436ca8e6a303c00000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000064", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://9af33394c65b1c033c9856392d32857f08225a976a16f5f311f0a5ea6cb47368"}