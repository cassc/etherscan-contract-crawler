{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/libraries/FeeLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\n// external libraries\\nimport {FixedPointMathLib} from \\\"solmate/utils/FixedPointMathLib.sol\\\";\\n\\n// interfaces\\nimport {IOracle} from \\\"grappa/interfaces/IOracle.sol\\\";\\n\\nimport \\\"../config/constants.sol\\\";\\nimport \\\"../config/errors.sol\\\";\\nimport \\\"../config/types.sol\\\";\\n\\nlibrary FeeLib {\\n    using FixedPointMathLib for uint256;\\n\\n    /**\\n     * @notice Calculates the management and performance fee for the current round\\n     * @param vaultDetails VaultDetails struct\\n     * @param managementFee charged at each round\\n     * @param performanceFee charged if the vault performs\\n     * @return totalFees all fees taken in round\\n     * @return balances is the asset balances at the start of the next round\\n     */\\n    function processFees(VaultDetails calldata vaultDetails, uint256 managementFee, uint256 performanceFee)\\n        external\\n        pure\\n        returns (uint256[] memory totalFees, uint256[] memory balances)\\n    {\\n        uint256 collateralCount = vaultDetails.currentBalances.length;\\n\\n        totalFees = new uint256[](collateralCount);\\n        balances = new uint256[](collateralCount);\\n\\n        for (uint256 i; i < collateralCount;) {\\n            uint256 lockedBalanceSansPending;\\n            uint256 managementFeeInAsset;\\n            uint256 performanceFeeInAsset;\\n\\n            balances[i] = vaultDetails.currentBalances[i];\\n\\n            // primary asset amount used to calculating the amount of secondary assets deposited in the round\\n            uint256 pendingBalance =\\n                vaultDetails.startingBalances[i].mulDivDown(vaultDetails.totalPending, vaultDetails.startingBalances[0]);\\n\\n            // At round 1, currentBalance == totalPending so we do not take fee on the first round\\n            if (balances[i] > pendingBalance) {\\n                lockedBalanceSansPending = balances[i] - pendingBalance;\\n            }\\n\\n            managementFeeInAsset = lockedBalanceSansPending.mulDivDown(managementFee, 100 * PERCENT_MULTIPLIER);\\n\\n            // Performance fee charged ONLY if difference between starting balance(s) and ending\\n            // balance(s) (excluding pending depositing) is positive\\n            // If the balance is negative, the the round did not profit.\\n            if (lockedBalanceSansPending > vaultDetails.startingBalances[i]) {\\n                if (performanceFee > 0) {\\n                    uint256 performanceAmount = lockedBalanceSansPending - vaultDetails.startingBalances[i];\\n\\n                    performanceFeeInAsset = performanceAmount.mulDivDown(performanceFee, 100 * PERCENT_MULTIPLIER);\\n                }\\n            }\\n\\n            totalFees[i] = managementFeeInAsset + performanceFeeInAsset;\\n\\n            // deducting fees from current balances\\n            balances[i] -= totalFees[i];\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates Net Asset Value of the vault and pending deposits\\n     * @dev prices are based on expiry, if rolling close then spot is used\\n     * @param details NAVDetails struct\\n     * @return totalNav of all the assets\\n     * @return pendingNAV of just the pending assets\\n     * @return prices of the different assets\\n     */\\n    function calculateNAVs(NAVDetails calldata details)\\n        external\\n        view\\n        returns (uint256 totalNav, uint256 pendingNAV, uint256[] memory prices)\\n    {\\n        IOracle oracle = IOracle(details.oracleAddr);\\n\\n        uint256 collateralCount = details.collaterals.length;\\n\\n        prices = new uint256[](collateralCount);\\n\\n        // primary asset that all other assets will be quotes in\\n        address quote = details.collaterals[0].addr;\\n\\n        for (uint256 i; i < collateralCount;) {\\n            prices[i] = UNIT;\\n\\n            // if collateral is primary asset, leave price as 1 (scale 1e6)\\n            if (i > 0) prices[i] = _getPrice(oracle, details.collaterals[i].addr, quote, details.expiry);\\n\\n            // sum of all asset(s) value\\n            totalNav += details.currentBalances[i].mulDivDown(prices[i], 10 ** details.collaterals[i].decimals);\\n\\n            // calculated pending deposit based on the primary asset\\n            uint256 pendingBalance = details.totalPending.mulDivDown(details.startingBalances[i], details.startingBalances[0]);\\n\\n            // sum of pending assets value\\n            pendingNAV += pendingBalance.mulDivDown(prices[i], 10 ** details.collaterals[i].decimals);\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice calculates relative Net Asset Value based on the primary asset and a rounds starting balance(s)\\n     * @dev used in pending deposits per account\\n     */\\n    function calculateRelativeNAV(\\n        Collateral[] memory collaterals,\\n        uint256[] memory startingBalances,\\n        uint256[] memory collateralPrices,\\n        uint256 primaryDeposited\\n    ) external pure returns (uint256 nav) {\\n        // primary asset amount used to calculating the amount of secondary assets deposited in the round\\n        uint256 primaryTotal = startingBalances[0];\\n\\n        for (uint256 i; i < collaterals.length;) {\\n            uint256 balance = startingBalances[i].mulDivDown(primaryDeposited, primaryTotal);\\n\\n            nav += balance.mulDivDown(collateralPrices[i], 10 ** collaterals[i].decimals);\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    function navToShares(uint256 nav, uint256 navPerShare) internal pure returns (uint256) {\\n        // If this throws, it means that vault's roundPricePerShare[currentRound] has not been set yet\\n        // which should never happen.\\n        // Has to be larger than 1 because `1` is used in `initRoundPricePerShares` to prevent cold writes.\\n        if (navPerShare <= PLACEHOLDER_UINT) revert FL_NPSLow();\\n\\n        return nav.mulDivDown(UNIT, navPerShare);\\n    }\\n\\n    function pricePerShare(uint256 totalSupply, uint256 totalNAV, uint256 pendingNAV) internal pure returns (uint256) {\\n        return totalSupply > 0 ? (totalNAV - pendingNAV).mulDivDown(UNIT, totalSupply) : UNIT;\\n    }\\n\\n    /**\\n     * @notice get spot price of base, denominated in quote.\\n     * @dev used in Net Asset Value calculations\\n     * @dev\\n     * @param oracle abstracted chainlink oracle\\n     * @param base base asset. for ETH/USD price, ETH is the base asset\\n     * @param quote quote asset. for ETH/USD price, USD is the quote asset\\n     * @param expiry price at a given timestamp\\n     * @return price with 6 decimals\\n     */\\n    function _getPrice(IOracle oracle, address base, address quote, uint256 expiry) internal view returns (uint256 price) {\\n        // if timestamp is the placeholder (1) or zero then get the spot\\n        if (expiry <= PLACEHOLDER_UINT) price = oracle.getSpotPrice(base, quote);\\n        else (price,) = oracle.getPriceAtExpiry(base, quote, expiry);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/utils/FixedPointMathLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Arithmetic library with operations for fixed-point numbers.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)\\n/// @author Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)\\nlibrary FixedPointMathLib {\\n    /*//////////////////////////////////////////////////////////////\\n                    SIMPLIFIED FIXED POINT OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal constant MAX_UINT256 = 2**256 - 1;\\n\\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\\n\\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\\n    }\\n\\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\\n    }\\n\\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\\n    }\\n\\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                    LOW LEVEL FIXED POINT OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function mulDivDown(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))\\n            if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {\\n                revert(0, 0)\\n            }\\n\\n            // Divide x * y by the denominator.\\n            z := div(mul(x, y), denominator)\\n        }\\n    }\\n\\n    function mulDivUp(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))\\n            if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {\\n                revert(0, 0)\\n            }\\n\\n            // If x * y modulo the denominator is strictly greater than 0,\\n            // 1 is added to round up the division of x * y by the denominator.\\n            z := add(gt(mod(mul(x, y), denominator), 0), div(mul(x, y), denominator))\\n        }\\n    }\\n\\n    function rpow(\\n        uint256 x,\\n        uint256 n,\\n        uint256 scalar\\n    ) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            switch x\\n            case 0 {\\n                switch n\\n                case 0 {\\n                    // 0 ** 0 = 1\\n                    z := scalar\\n                }\\n                default {\\n                    // 0 ** n = 0\\n                    z := 0\\n                }\\n            }\\n            default {\\n                switch mod(n, 2)\\n                case 0 {\\n                    // If n is even, store scalar in z for now.\\n                    z := scalar\\n                }\\n                default {\\n                    // If n is odd, store x in z for now.\\n                    z := x\\n                }\\n\\n                // Shifting right by 1 is like dividing by 2.\\n                let half := shr(1, scalar)\\n\\n                for {\\n                    // Shift n right by 1 before looping to halve it.\\n                    n := shr(1, n)\\n                } n {\\n                    // Shift n right by 1 each iteration to halve it.\\n                    n := shr(1, n)\\n                } {\\n                    // Revert immediately if x ** 2 would overflow.\\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\\n                    if shr(128, x) {\\n                        revert(0, 0)\\n                    }\\n\\n                    // Store x squared.\\n                    let xx := mul(x, x)\\n\\n                    // Round to the nearest number.\\n                    let xxRound := add(xx, half)\\n\\n                    // Revert if xx + half overflowed.\\n                    if lt(xxRound, xx) {\\n                        revert(0, 0)\\n                    }\\n\\n                    // Set x to scaled xxRound.\\n                    x := div(xxRound, scalar)\\n\\n                    // If n is even:\\n                    if mod(n, 2) {\\n                        // Compute z * x.\\n                        let zx := mul(z, x)\\n\\n                        // If z * x overflowed:\\n                        if iszero(eq(div(zx, x), z)) {\\n                            // Revert if x is non-zero.\\n                            if iszero(iszero(x)) {\\n                                revert(0, 0)\\n                            }\\n                        }\\n\\n                        // Round to the nearest number.\\n                        let zxRound := add(zx, half)\\n\\n                        // Revert if zx + half overflowed.\\n                        if lt(zxRound, zx) {\\n                            revert(0, 0)\\n                        }\\n\\n                        // Return properly scaled zxRound.\\n                        z := div(zxRound, scalar)\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        GENERAL NUMBER UTILITIES\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let y := x // We start y at x, which will help us make our initial estimate.\\n\\n            z := 181 // The \\\"correct\\\" value is 1, but this saves a multiplication later.\\n\\n            // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad\\n            // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.\\n\\n            // We check y >= 2^(k + 8) but shift right by k bits\\n            // each branch to ensure that if x >= 256, then y >= 256.\\n            if iszero(lt(y, 0x10000000000000000000000000000000000)) {\\n                y := shr(128, y)\\n                z := shl(64, z)\\n            }\\n            if iszero(lt(y, 0x1000000000000000000)) {\\n                y := shr(64, y)\\n                z := shl(32, z)\\n            }\\n            if iszero(lt(y, 0x10000000000)) {\\n                y := shr(32, y)\\n                z := shl(16, z)\\n            }\\n            if iszero(lt(y, 0x1000000)) {\\n                y := shr(16, y)\\n                z := shl(8, z)\\n            }\\n\\n            // Goal was to get z*z*y within a small factor of x. More iterations could\\n            // get y in a tighter range. Currently, we will have y in [256, 256*2^16).\\n            // We ensured y >= 256 so that the relative difference between y and y+1 is small.\\n            // That's not possible if x < 256 but we can just verify those cases exhaustively.\\n\\n            // Now, z*z*y <= x < z*z*(y+1), and y <= 2^(16+8), and either y >= 256, or x < 256.\\n            // Correctness can be checked exhaustively for x < 256, so we assume y >= 256.\\n            // Then z*sqrt(y) is within sqrt(257)/sqrt(256) of sqrt(x), or about 20bps.\\n\\n            // For s in the range [1/256, 256], the estimate f(s) = (181/1024) * (s+1) is in the range\\n            // (1/2.84 * sqrt(s), 2.84 * sqrt(s)), with largest error when s = 1 and when s = 256 or 1/256.\\n\\n            // Since y is in [256, 256*2^16), let a = y/65536, so that a is in [1/256, 256). Then we can estimate\\n            // sqrt(y) using sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2^18.\\n\\n            // There is no overflow risk here since y < 2^136 after the first branch above.\\n            z := shr(18, mul(z, add(y, 65536))) // A mul() is saved from starting z at 181.\\n\\n            // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n\\n            // If x+1 is a perfect square, the Babylonian method cycles between\\n            // floor(sqrt(x)) and ceil(sqrt(x)). This statement ensures we return floor.\\n            // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division\\n            // Since the ceil is rare, we save gas on the assignment and repeat division in the rare case.\\n            // If you don't care whether the floor or ceil square root is returned, you can remove this statement.\\n            z := sub(z, lt(div(x, z), z))\\n        }\\n    }\\n\\n    function unsafeMod(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Mod x by y. Note this will return\\n            // 0 instead of reverting if y is zero.\\n            z := mod(x, y)\\n        }\\n    }\\n\\n    function unsafeDiv(uint256 x, uint256 y) internal pure returns (uint256 r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Divide x by y. Note this will return\\n            // 0 instead of reverting if y is zero.\\n            r := div(x, y)\\n        }\\n    }\\n\\n    function unsafeDivUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Add 1 to x * y if x % y > 0. Note this will\\n            // return 0 instead of reverting if y is zero.\\n            z := add(gt(mod(x, y), 0), div(x, y))\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/cross-margin-engine/lib/core-cash/src/interfaces/IOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IOracle {\\n    /**\\n     * @notice  get spot price of _base, denominated in _quote.\\n     * @param _base base asset. for ETH/USD price, ETH is the base asset\\n     * @param _quote quote asset. for ETH/USD price, USD is the quote asset\\n     * @return price with 6 decimals\\n     */\\n    function getSpotPrice(address _base, address _quote) external view returns (uint256);\\n\\n    /**\\n     * @dev get expiry price of underlying, denominated in strike asset.\\n     * @param _base base asset. for ETH/USD price, ETH is the base asset\\n     * @param _quote quote asset. for ETH/USD price, USD is the quote asset\\n     * @param _expiry expiry timestamp\\n     *\\n     * @return price with 6 decimals\\n     */\\n    function getPriceAtExpiry(address _base, address _quote, uint256 _expiry)\\n        external\\n        view\\n        returns (uint256 price, bool isFinalized);\\n\\n    /**\\n     * @dev return the maximum dispute period for the oracle\\n     * @dev this will only be checked during oracle registration, as a soft constraint on integrating oracles.\\n     */\\n    function maxDisputePeriod() external view returns (uint256 disputePeriod);\\n}\\n\"\r\n    },\r\n    \"src/config/constants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\n///@dev unit scaled used to convert amounts.\\nuint256 constant UNIT = 10 ** 6;\\n\\n// Placeholder uint value to prevent cold writes\\nuint256 constant PLACEHOLDER_UINT = 1;\\n\\n// Fees are 18-decimal places. For example: 20 * 10**18 = 20%\\nuint256 constant PERCENT_MULTIPLIER = 10 ** 18;\\n\\nuint32 constant SECONDS_PER_DAY = 86400;\\nuint32 constant DAYS_PER_YEAR = 365;\\n\"\r\n    },\r\n    \"src/config/errors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\n// common\\nerror Unauthorized();\\nerror Overflow();\\nerror BadAddress();\\nerror NotImplemented();\\n\\n// BaseVault\\nerror BV_ActiveRound();\\nerror BV_BadCollateral();\\nerror BV_BadExpiry();\\nerror BV_BadLevRatio();\\nerror BV_ExpiryMismatch();\\nerror BV_MarginEngineMismatch();\\nerror BV_RoundClosed();\\nerror BV_BadFee();\\nerror BV_BadRoundConfig();\\nerror BV_BadPPS();\\nerror BV_BadSB();\\nerror BV_BadCP();\\nerror BV_BadRatios();\\n\\n// Registrar\\nerror REG_BadAmount();\\nerror REG_BadRound();\\nerror REG_BadNumShares();\\nerror REG_BadDepositAmount();\\nerror REG_ExceedsAvailable();\\n\\n// OptionsVault\\nerror OV_ActiveRound();\\nerror OV_BadRound();\\nerror OV_BadCollateral();\\nerror OV_BadPremium();\\nerror OV_RoundClosed();\\nerror OV_NoCollateral();\\nerror OV_OptionNotExpired();\\nerror OV_NoCollateralPending();\\n\\n// PhysicalOptionVault\\nerror POV_CannotRequestWithdraw();\\nerror POV_NotExercised();\\nerror POV_OptionNotExpired();\\nerror POV_VaultExercised();\\nerror POV_BadExerciseWindow();\\n\\n// Fee Utils\\nerror FL_NPSLow();\\n\\n// Vault Utils\\nerror VL_DifferentLengths();\\nerror VL_ExceedsSurplus();\\nerror VL_BadOwnerAddress();\\nerror VL_BadManagerAddress();\\nerror VL_BadFeeAddress();\\nerror VL_BadOracleAddress();\\nerror VL_BadPauserAddress();\\nerror VL_BadFee();\\nerror VL_BadCollateral();\\nerror VL_BadCollateralAddress();\\nerror VL_BadDuration();\\n\\n// StructureLib\\nerror SL_BadExpiryDate();\\n\\n// Vault Pauser\\nerror VP_VaultNotPermissioned();\\nerror VP_PositionPaused();\\nerror VP_Overflow();\\nerror VP_CustomerNotPermissioned();\\nerror VP_RoundOpen();\\n\\n// Vault Share\\nerror VS_SupplyExceeded();\\n\\n// Whitelist Manager\\nerror WL_BadRole();\\nerror WL_Paused();\\n\"\r\n    },\r\n    \"src/config/types.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\n/**\\n * @notice Initialization parameters for the vault.\\n * @param _owner is the owner of the vault with critical permissions\\n * @param _manager is the address that is responsible for advancing the vault\\n * @param _feeRecipient is the address to receive vault performance and management fees\\n * @param _oracle is used to calculate NAV\\n * @param _whitelist is used to check address access permissions\\n * @param _managementFee is the management fee pct.\\n * @param _performanceFee is the performance fee pct.\\n * @param _pauser is where withdrawn collateral exists waiting for client to withdraw\\n * @param _collateralRatios is the array of round starting balances to set the initial collateral ratios\\n * @param _collaterals is the assets used in the vault\\n * @param _roundConfig sets the duration and expiration of options\\n * @param _vaultParams set vaultParam struct\\n */\\nstruct InitParams {\\n    address _owner;\\n    address _manager;\\n    address _feeRecipient;\\n    address _oracle;\\n    address _whitelist;\\n    uint256 _managementFee;\\n    uint256 _performanceFee;\\n    address _pauser;\\n    uint256[] _collateralRatios;\\n    Collateral[] _collaterals;\\n    RoundConfig _roundConfig;\\n}\\n\\nstruct Collateral {\\n    // Grappa asset Id\\n    uint8 id;\\n    // ERC20 token address for the required collateral\\n    address addr;\\n    // the amount of decimals or token\\n    uint8 decimals;\\n}\\n\\nstruct VaultState {\\n    // 32 byte slot 1\\n    // Round represents the number of periods elapsed. There's a hard limit of 4,294,967,295 rounds\\n    uint32 round;\\n    // Amount that is currently locked for selling options\\n    uint96 lockedAmount;\\n    // Amount that was locked for selling options in the previous round\\n    // used for calculating performance fee deduction\\n    uint96 lastLockedAmount;\\n    // 32 byte slot 2\\n    // Stores the total tally of how much of `asset` there is\\n    // to be used to mint vault tokens\\n    uint96 totalPending;\\n    // store the number of shares queued for withdraw this round\\n    // zero'ed out at the start of each round, pauser withdraws all queued shares.\\n    uint128 queuedWithdrawShares;\\n}\\n\\nstruct DepositReceipt {\\n    // Round represents the number of periods elapsed. There's a hard limit of 4,294,967,295 rounds\\n    uint32 round;\\n    // Deposit amount, max 79,228,162,514 or 79 Billion ETH deposit\\n    uint96 amount;\\n    // Unredeemed shares balance\\n    uint128 unredeemedShares;\\n}\\n\\nstruct RoundConfig {\\n    // the duration of the option\\n    uint32 duration;\\n    // day of the week the option should expire. 0-8, 0 is sunday, 7 is sunday, 8 is wild\\n    uint8 dayOfWeek;\\n    // hour of the day the option should expire. 0 is midnight\\n    uint8 hourOfDay;\\n}\\n\\n// Used for fee calculations at the end of a round\\nstruct VaultDetails {\\n    // Collaterals of the vault\\n    Collateral[] collaterals;\\n    // Collateral balances at the start of the round\\n    uint256[] startingBalances;\\n    // current balances\\n    uint256[] currentBalances;\\n    // Total pending primary asset\\n    uint256 totalPending;\\n}\\n\\n// Used when rolling funds into a new round\\nstruct NAVDetails {\\n    // Collaterals of the vault\\n    Collateral[] collaterals;\\n    // Collateral balances at the start of the round\\n    uint256[] startingBalances;\\n    // Current collateral balances\\n    uint256[] currentBalances;\\n    // Used to calculate NAV\\n    address oracleAddr;\\n    // Expiry of the round\\n    uint256 expiry;\\n    // Pending deposits\\n    uint256 totalPending;\\n}\\n\\n/**\\n * @dev Position struct\\n * @param tokenId option token id\\n * @param amount number option tokens\\n */\\nstruct Position {\\n    uint256 tokenId;\\n    uint64 amount;\\n}\\n\\n/**\\n * @dev struct representing the current balance for a given collateral\\n * @param collateralId asset id\\n * @param amount amount the asset\\n */\\nstruct Balance {\\n    uint8 collateralId;\\n    uint80 amount;\\n}\\n\\n/**\\n * @dev ActionArgs and BatchExecute are a local definition of the structs defined in:\\n *       - https://github.com/grappafinance/core-cash/blob/master/src/config/types.sol\\n *       - https://github.com/grappafinance/core-physical/blob/master/src/config/types.sol\\n *     they are provided to avoid the need of having separate logic for interacting with the cash settled an\\n *     physically settled margin engines and consolidate them in a single interface\\n */\\n\\n/**\\n * @notice The action type for the execute function\\n * @dev    unitary representation of the ActionArgs struct from the core physical and cash engines\\n */\\nstruct ActionArgs {\\n    // action type represented as uint8 (see enum ActionType)\\n    uint8 action;\\n    // data payload for the action\\n    bytes data;\\n}\\n\\n/**\\n * @notice The batch action type for the execute function\\n * @dev    unitary representation of the BatchExecute struct from the core physical and cash engines\\n */\\nstruct BatchExecute {\\n    // address of the account to execute the batch\\n    address subAccount;\\n    // array of actions to execute\\n    ActionArgs[] actions;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"array-lib/=lib/array-lib/src/\",\r\n      \"cm-cash-engine/=lib/cross-margin-engine/src/settled-cash/\",\r\n      \"cm-physical-engine/=lib/cross-margin-engine/src/settled-physical/\",\r\n      \"core-cash/=lib/cross-margin-engine/lib/core-cash/\",\r\n      \"core-physical/=lib/cross-margin-engine/lib/core-physical/\",\r\n      \"cross-margin-engine/=lib/cross-margin-engine/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"grappa-test/=lib/cross-margin-engine/lib/core-cash/test/\",\r\n      \"grappa/=lib/cross-margin-engine/lib/core-cash/src/\",\r\n      \"openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"openzeppelin-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/\",\r\n      \"openzeppelin/=lib/openzeppelin-contracts/contracts/\",\r\n      \"pomace-test/=lib/cross-margin-engine/lib/core-physical/test/\",\r\n      \"pomace/=lib/cross-margin-engine/lib/core-physical/src/\",\r\n      \"solmate/=lib/solmate/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {\r\n      \"src/libraries/FeeLib.sol\": {\r\n        \"FeeLib\": \"0xff9681e29b585abb82d6db0d99c80ae3accbc67e\"\r\n      },\r\n      \"src/libraries/StructureLib.sol\": {\r\n        \"StructureLib\": \"0x65d3f8fa8e598c827a29173cb38d17e08fb7f3e2\"\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"uint8\",\"name\":\"id\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"}],\"internalType\":\"struct Collateral[]\",\"name\":\"collaterals\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256[]\",\"name\":\"startingBalances\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"currentBalances\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"oracleAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalPending\",\"type\":\"uint256\"}],\"internalType\":\"struct NAVDetails\",\"name\":\"details\",\"type\":\"tuple\"}],\"name\":\"calculateNAVs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalNav\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pendingNAV\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"prices\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint8\",\"name\":\"id\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"}],\"internalType\":\"struct Collateral[]\",\"name\":\"collaterals\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256[]\",\"name\":\"startingBalances\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"collateralPrices\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"primaryDeposited\",\"type\":\"uint256\"}],\"name\":\"calculateRelativeNAV\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"nav\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"uint8\",\"name\":\"id\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"}],\"internalType\":\"struct Collateral[]\",\"name\":\"collaterals\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256[]\",\"name\":\"startingBalances\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"currentBalances\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"totalPending\",\"type\":\"uint256\"}],\"internalType\":\"struct VaultDetails\",\"name\":\"vaultDetails\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"managementFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"performanceFee\",\"type\":\"uint256\"}],\"name\":\"processFees\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"totalFees\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"balances\",\"type\":\"uint256[]\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]", "ContractName": "FeeLib", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "london", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}