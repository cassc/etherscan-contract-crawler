{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@gearbox-protocol/core-v2/contracts/credit/CreditFacade.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n// Gearbox Protocol. Generalized leverage for DeFi protocols\\n// (c) Gearbox Holdings, 2022\\npragma solidity ^0.8.10;\\n\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport { Address } from \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport { EnumerableSet } from \\\"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\\\";\\nimport { ReentrancyGuard } from \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\nimport { SafeCast } from \\\"@openzeppelin/contracts/utils/math/SafeCast.sol\\\";\\n\\n//  DATA\\nimport { MultiCall } from \\\"../libraries/MultiCall.sol\\\";\\nimport { Balance } from \\\"../libraries/Balances.sol\\\";\\n\\n/// INTERFACES\\nimport { ICreditFacade, ICreditFacadeExtended } from \\\"../interfaces/ICreditFacade.sol\\\";\\nimport { ICreditManagerV2, ClosureAction } from \\\"../interfaces/ICreditManagerV2.sol\\\";\\nimport { IPriceOracleV2 } from \\\"../interfaces/IPriceOracle.sol\\\";\\nimport { IDegenNFT } from \\\"../interfaces/IDegenNFT.sol\\\";\\nimport { IWETH } from \\\"../interfaces/external/IWETH.sol\\\";\\nimport { IBlacklistHelper } from \\\"../interfaces/IBlacklistHelper.sol\\\";\\nimport { IPausable } from \\\"../interfaces/IPausable.sol\\\";\\n\\n// CONSTANTS\\n\\nimport { LEVERAGE_DECIMALS } from \\\"../libraries/Constants.sol\\\";\\nimport { PERCENTAGE_FACTOR } from \\\"../libraries/PercentageMath.sol\\\";\\n\\n// EXCEPTIONS\\nimport { ZeroAddressException } from \\\"../interfaces/IErrors.sol\\\";\\n\\nstruct Params {\\n    /// @dev Maximal amount of new debt that can be taken per block\\n    uint128 maxBorrowedAmountPerBlock;\\n    /// @dev True if increasing debt is forbidden\\n    bool isIncreaseDebtForbidden;\\n    /// @dev Timestamp of the next expiration (for expirable Credit Facades only)\\n    uint40 expirationDate;\\n    /// @dev Liquidation discount applied to totalValue for emergency liquidator\\n    uint16 emergencyLiquidationDiscount;\\n}\\n\\nstruct Limits {\\n    /// @dev Minimal borrowed amount per credit account\\n    uint128 minBorrowedAmount;\\n    /// @dev Maximum borrowed amount per credit account\\n    uint128 maxBorrowedAmount;\\n}\\n\\nstruct CumulativeLossParams {\\n    /// @dev Current cumulative loss from all bad debt liquidations\\n    uint128 currentCumulativeLoss;\\n    /// @dev Max cumulative loss accrued before the system is paused\\n    uint128 maxCumulativeLoss;\\n}\\n\\nstruct TotalDebt {\\n    /// @dev Current total borrowing\\n    uint128 currentTotalDebt;\\n    /// @dev Total borrowing limit\\n    uint128 totalDebtLimit;\\n}\\n\\n/// @title CreditFacade\\n/// @notice User interface for interacting with Credit Manager\\n/// @dev Direct interaction with the Credit Manager is forbidden, but Credit Facade provides all the needed\\n///      account management functions: open / close / liquidate / addCollateral / manageDebt / multicall.\\n///      The latter allows to perform multiple actions within a single transaction, followed by a single\\n///      collateral check in the end.\\ncontract CreditFacade is ICreditFacade, ReentrancyGuard {\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n    using Address for address;\\n    using SafeCast for uint256;\\n\\n    /// @dev Credit Manager connected to this Credit Facade\\n    ICreditManagerV2 public immutable creditManager;\\n\\n    /// @dev Whether the whitelisted mode is active\\n    bool public immutable whitelisted;\\n\\n    /// @dev Whether the Credit Manager's underlying has blacklisting\\n    bool public immutable isBlacklistableUnderlying;\\n\\n    /// @dev Whether the Credit Facade implements expirable logic\\n    bool public immutable expirable;\\n\\n    /// @dev Keeps frequently accessed parameters for storage access optimization\\n    Params public override params;\\n\\n    /// @dev Keeps borrowing limits together for storage access optimization\\n    Limits public override limits;\\n\\n    /// @dev Keeps parameters that are used to pause the system after too much bad debt over a short period\\n    CumulativeLossParams public override lossParams;\\n\\n    TotalDebt public override totalDebt;\\n\\n    /// @dev Address of the underlying token\\n    address public immutable underlying;\\n\\n    /// @dev A map that stores whether a user allows a transfer of an account from another user to themselves\\n    mapping(address => mapping(address => bool))\\n        public\\n        override transfersAllowed;\\n\\n    /// @dev Address of WETH\\n    address public immutable wethAddress;\\n\\n    /// @dev Address of the DegenNFT that gatekeeps account openings in whitelisted mode\\n    address public immutable override degenNFT;\\n\\n    /// @dev Address of the BlacklistHelper if underlying is blacklistable, otherwise address(0)\\n    address public immutable override blacklistHelper;\\n\\n    /// @dev Address of the pool connected to the Credit Manager\\n    address public immutable pool;\\n\\n    /// @dev Stores in a compressed state the last block where borrowing happened and the total amount borrowed in that block\\n    uint256 internal totalBorrowedInBlock;\\n\\n    /// @dev Contract version\\n    uint256 public constant override version = 2_20;\\n\\n    /// @dev Restricts actions for users with opened credit accounts only\\n    modifier creditConfiguratorOnly() {\\n        if (msg.sender != creditManager.creditConfigurator())\\n            revert CreditConfiguratorOnlyException();\\n\\n        _;\\n    }\\n\\n    /// @dev Initializes creditFacade and connects it with CreditManager\\n    /// @param _creditManager address of Credit Manager\\n    /// @param _degenNFT address of the DegenNFT or address(0) if whitelisted mode is not used\\n    /// @param _blacklistHelper address of the funds recovery contract for blacklistable underlyings.\\n    ///                         Must be address(0) is the underlying is not blacklistable\\n    /// @param _expirable Whether the CreditFacade can expire and implements expiration-related logic\\n    constructor(\\n        address _creditManager,\\n        address _degenNFT,\\n        address _blacklistHelper,\\n        bool _expirable\\n    ) {\\n        // Additional check that _creditManager is not address(0)\\n        if (_creditManager == address(0)) revert ZeroAddressException(); // F:[FA-1]\\n\\n        creditManager = ICreditManagerV2(_creditManager); // F:[FA-1A]\\n        underlying = ICreditManagerV2(_creditManager).underlying(); // F:[FA-1A]\\n        wethAddress = ICreditManagerV2(_creditManager).wethAddress(); // F:[FA-1A]\\n        pool = ICreditManagerV2(_creditManager).pool();\\n\\n        degenNFT = _degenNFT; // F:[FA-1A]\\n        whitelisted = _degenNFT != address(0); // F:[FA-1A]\\n\\n        blacklistHelper = _blacklistHelper;\\n        isBlacklistableUnderlying = _blacklistHelper != address(0);\\n        if (_blacklistHelper != address(0)) {\\n            emit BlacklistHelperSet(_blacklistHelper);\\n        }\\n\\n        expirable = _expirable;\\n\\n        totalDebt.totalDebtLimit = type(uint128).max;\\n    }\\n\\n    // Notice: ETH interactions\\n    // CreditFacade implements a new flow for interacting with WETH compared to V1.\\n    // During all actions, any sent ETH value is automatically wrapped into WETH and\\n    // sent back to the message sender. This makes the protocol's behavior regarding\\n    // ETH more flexible and consistent, since there is no need to pre-wrap WETH before\\n    // interacting with the protocol, and no need to compute how much unused ETH has to be sent back.\\n\\n    /// @dev Opens credit account, borrows funds from the pool and pulls collateral\\n    /// without any additional action.\\n    /// - Performs sanity checks to determine whether opening an account is allowed\\n    /// - Wraps ETH to WETH and sends it msg. sender is value > 0\\n    /// - Requests CreditManager to open a Credit Account with a specified borrowed amount\\n    /// - Transfers collateral in the underlying asset from the user\\n    /// - Emits OpenCreditAccount event\\n    ///\\n    /// More info: https://dev.gearbox.fi/developers/credit/credit_manager#open-credit-account\\n    ///\\n    /// @param amount The amount of collateral provided by the borrower\\n    /// @param onBehalfOf The address to open an account for. Transfers to it have to be allowed if\\n    /// msg.sender != obBehalfOf\\n    /// @param leverageFactor Percentage of the user's own funds to borrow. 100 is equal to 100% - borrows the same amount\\n    /// as the user's own collateral, equivalent to 2x leverage.\\n    /// @param referralCode Referral code that is used for potential rewards. 0 if no referral code provided.\\n    function openCreditAccount(\\n        uint256 amount,\\n        address onBehalfOf,\\n        uint16 leverageFactor,\\n        uint16 referralCode\\n    ) external payable override nonReentrant {\\n        uint256 borrowedAmount = (amount * leverageFactor) / LEVERAGE_DECIMALS; // F:[FA-5]\\n\\n        // Checks whether the new borrowed amount does not violate the block limit\\n        _checkAndUpdateBorrowedBlockLimit(borrowedAmount); // F:[FA-11A]\\n\\n        // Checks that the borrowed amount is within the borrowing limits\\n        _revertIfOutOfBorrowedLimits(borrowedAmount); // F:[FA-11B]\\n\\n        // Checks that the msg.sender can open an account for onBehalfOf\\n        _revertIfOpenCreditAccountNotAllowed(onBehalfOf); // F:[FA-4A, 4B, 57]\\n\\n        // Wraps ETH and sends it back to msg.sender\\n        _wrapETH(); // F:[FA-3A]\\n\\n        // Checks that the total debt limit is not exceeded and increases total debt\\n        _checkAndUpdateTotalDebt(borrowedAmount, true); // F: [FA-11C]\\n\\n        // Gets the LT of the underlying\\n        (, uint256 ltu) = creditManager.collateralTokens(0); // F:[FA-6]\\n\\n        // In order for the account to pass the health check after opening,\\n        // the inequality \\\"(amount + borrowedAmount) * LTU > borrowedAmount\\\" must hold\\n        // this can be transformed into \\\"amount * LTU > borrowedAmount * (1 - LTU)\\\"\\n        if (amount * ltu <= borrowedAmount * (PERCENTAGE_FACTOR - ltu))\\n            revert NotEnoughCollateralException(); // F:[FA-6]\\n\\n        // Opens credit accnount and borrows funds from the pool\\n        // Returns the new credit account's address\\n        address creditAccount = creditManager.openCreditAccount(\\n            borrowedAmount,\\n            onBehalfOf\\n        ); // F:[FA-5]\\n\\n        // Emits openCreditAccount event before adding collateral, so that order of events is correct\\n        emit OpenCreditAccount(\\n            onBehalfOf,\\n            creditAccount,\\n            borrowedAmount,\\n            referralCode\\n        ); // F:[FA-5]\\n\\n        // Transfers collateral from the user to the new Credit Account\\n        addCollateral(onBehalfOf, creditAccount, underlying, amount); // F:[FA-5]\\n    }\\n\\n    /// @dev Opens a Credit Account and runs a batch of operations in a multicall\\n    /// - Opens credit account with the desired borrowed amount\\n    /// - Executes all operations in a multicall\\n    /// - Checks that the new account has enough collateral\\n    /// - Emits OpenCreditAccount event\\n    ///\\n    /// @param borrowedAmount Debt size\\n    /// @param onBehalfOf The address to open an account for. Transfers to it have to be allowed if\\n    /// msg.sender != onBehalfOf\\n    /// @param calls The array of MultiCall structs encoding the required operations. Generally must have\\n    /// at least a call to addCollateral, as otherwise the health check at the end will fail.\\n    /// @param referralCode Referral code which is used for potential rewards. 0 if no referral code provided\\n    function openCreditAccountMulticall(\\n        uint256 borrowedAmount,\\n        address onBehalfOf,\\n        MultiCall[] calldata calls,\\n        uint16 referralCode\\n    ) external payable override nonReentrant {\\n        // Checks whether the new borrowed amount does not violate the block limit\\n        _checkAndUpdateBorrowedBlockLimit(borrowedAmount); // F:[FA-11]\\n\\n        // Checks that the msg.sender can open an account for onBehalfOf\\n        _revertIfOpenCreditAccountNotAllowed(onBehalfOf); // F:[FA-4A, 4B, 57]\\n\\n        // Checks that the borrowed amount is within the borrowing limits\\n        _revertIfOutOfBorrowedLimits(borrowedAmount); // F:[FA-11B]\\n\\n        // Wraps ETH and sends it back to msg.sender address\\n        _wrapETH(); // F:[FA-3B]\\n\\n        // Checks that the total debt limit is not exceeded and increases total debt\\n        _checkAndUpdateTotalDebt(borrowedAmount, true); // F: [FA-11C]\\n\\n        // Requests the Credit Manager to open a Credit Account\\n        address creditAccount = creditManager.openCreditAccount(\\n            borrowedAmount,\\n            onBehalfOf\\n        ); // F:[FA-8]\\n\\n        // emits a new event\\n        emit OpenCreditAccount(\\n            onBehalfOf,\\n            creditAccount,\\n            borrowedAmount,\\n            referralCode\\n        ); // F:[FA-8]\\n\\n        // F:[FA-10]: no free flashloans through opening a Credit Account\\n        // and immediately decreasing debt\\n        if (calls.length != 0)\\n            _multicall(calls, onBehalfOf, creditAccount, false, true); // F:[FA-8]\\n\\n        // Checks that the new credit account has enough collateral to cover the debt\\n        creditManager.fullCollateralCheck(creditAccount); // F:[FA-8, 9]\\n    }\\n\\n    /// @dev A version of `closeCreditAccount` with `convertWETH` parameter that is ignored.\\n    ///      Used for backward compatibility.\\n    function closeCreditAccount(\\n        address to,\\n        uint256 skipTokenMask,\\n        bool,\\n        MultiCall[] calldata calls\\n    ) external payable override nonReentrant {\\n        _closeCreditAccount(to, skipTokenMask, calls);\\n    }\\n\\n    /// @dev Runs a batch of transactions within a multicall and closes the account\\n    /// - Wraps ETH to WETH and sends it msg.sender if value > 0\\n    /// - Executes the multicall - the main purpose of a multicall when closing is to convert all assets to underlying\\n    /// in order to pay the debt.\\n    /// - Closes credit account:\\n    ///    + Checks the underlying balance: if it is greater than the amount paid to the pool, transfers the underlying\\n    ///      from the Credit Account and proceeds. If not, tries to transfer the shortfall from msg.sender.\\n    ///    + Transfers all enabled assets with non-zero balances to the \\\"to\\\" address, unless they are marked\\n    ///      to be skipped in skipTokenMask\\n    /// - Emits a CloseCreditAccount event\\n    ///\\n    /// @param to Address to send funds to during account closing\\n    /// @param skipTokenMask Uint-encoded bit mask where 1's mark tokens that shouldn't be transferred\\n    /// @param calls The array of MultiCall structs encoding the operations to execute before closing the account.\\n    function closeCreditAccount(\\n        address to,\\n        uint256 skipTokenMask,\\n        MultiCall[] calldata calls\\n    ) external payable override nonReentrant {\\n        _closeCreditAccount(to, skipTokenMask, calls);\\n    }\\n\\n    /// @dev IMPLEMENTATION: closeCreditAccount\\n    function _closeCreditAccount(\\n        address to,\\n        uint256 skipTokenMask,\\n        MultiCall[] calldata calls\\n    ) internal {\\n        // Check for existing CA\\n        address creditAccount = creditManager.getCreditAccountOrRevert(\\n            msg.sender\\n        ); // F:[FA-2]\\n\\n        // Wraps ETH and sends it back to msg.sender\\n        _wrapETH(); // F:[FA-3C]\\n\\n        // [FA-13]: Calls to CreditFacade are forbidden during closure\\n        if (calls.length != 0)\\n            _multicall(calls, msg.sender, creditAccount, true, false); // F:[FA-2, 12, 13]\\n\\n        uint256 availableLiquidityBefore = _getAvailableLiquidity();\\n        (\\n            uint256 borrowedAmount,\\n            uint256 borrowAmountWithInterest,\\n\\n        ) = creditManager.calcCreditAccountAccruedInterest(creditAccount);\\n\\n        // Requests the Credit manager to close the Credit Account\\n        creditManager.closeCreditAccount(\\n            msg.sender,\\n            ClosureAction.CLOSE_ACCOUNT,\\n            0,\\n            msg.sender,\\n            to,\\n            skipTokenMask,\\n            false\\n        ); // F:[FA-2, 12]\\n\\n        uint256 availableLiquidityAfter = _getAvailableLiquidity();\\n\\n        if (\\n            availableLiquidityAfter <\\n            availableLiquidityBefore + borrowAmountWithInterest\\n        ) {\\n            revert LiquiditySanityCheckException();\\n        }\\n\\n        // Decreases the total debt\\n        _checkAndUpdateTotalDebt(borrowedAmount, false);\\n\\n        // Emits a CloseCreditAccount event\\n        emit CloseCreditAccount(msg.sender, to); // F:[FA-12]\\n    }\\n\\n    /// @dev Runs a batch of transactions within a multicall and liquidates the account\\n    /// - Computes the total value and checks that hf < 1. An account can't be liquidated when hf >= 1.\\n    ///   Total value has to be computed before the multicall, otherwise the liquidator would be able\\n    ///   to manipulate it.\\n    /// - Wraps ETH to WETH and sends it to msg.sender (liquidator) if value > 0\\n    /// - Executes the multicall - the main purpose of a multicall when liquidating is to convert all assets to underlying\\n    ///   in order to pay the debt.\\n    /// - Liquidate credit account:\\n    ///    + Computes the amount that needs to be paid to the pool. If totalValue * liquidationDiscount < borrow + interest + fees,\\n    ///      only totalValue * liquidationDiscount has to be paid. Since liquidationDiscount < 1, the liquidator can take\\n    ///      totalValue * (1 - liquidationDiscount) as premium. Also computes the remaining funds to be sent to borrower\\n    ///      as totalValue * liquidationDiscount - amountToPool.\\n    ///    + If borrower happens to be blacklisted in the underlying asset, sends funds to the blacklist helper\\n    ///      and marks them as claimable by the borrower.\\n    ///    + Checks the underlying balance: if it is greater than amountToPool + remainingFunds, transfers the underlying\\n    ///      from the Credit Account and proceeds. If not, tries to transfer the shortfall from the liquidator.\\n    ///    + Transfers all enabled assets with non-zero balances to the \\\"to\\\" address, unless they are marked\\n    ///      to be skipped in skipTokenMask. If the liquidator is confident that all assets were converted\\n    ///      during the multicall, they can set the mask to uint256.max - 1, to only transfer the underlying\\n    /// - Emits LiquidateCreditAccount event\\n    ///\\n    /// @param to Address to send funds to after liquidation\\n    /// @param skipTokenMask Uint-encoded bit mask where 1's mark tokens that shouldn't be transferred\\n    /// @param calls The array of MultiCall structs encoding the operations to execute before liquidating the account.\\n    function liquidateCreditAccount(\\n        address borrower,\\n        address to,\\n        uint256 skipTokenMask,\\n        MultiCall[] calldata calls\\n    ) external payable override nonReentrant {\\n        _liquidateCreditAccount(borrower, to, skipTokenMask, calls);\\n    }\\n\\n    /// @dev A version of `liquidateCreditAccount` with `convertWETH` parameter that is ignored.\\n    ///      Used for backward compatibility.\\n    function liquidateCreditAccount(\\n        address borrower,\\n        address to,\\n        uint256 skipTokenMask,\\n        bool,\\n        MultiCall[] calldata calls\\n    ) external payable override nonReentrant {\\n        _liquidateCreditAccount(borrower, to, skipTokenMask, calls);\\n    }\\n\\n    /// @dev IMPLEMENTATION: liquidateCreditAccount\\n    function _liquidateCreditAccount(\\n        address borrower,\\n        address to,\\n        uint256 skipTokenMask,\\n        MultiCall[] calldata calls\\n    ) internal {\\n        // Checks that the CA exists to revert early for late liquidations and save gas\\n        address creditAccount = creditManager.getCreditAccountOrRevert(\\n            borrower\\n        ); // F:[FA-2]\\n\\n        // Checks that the to address is not zero\\n        if (to == address(0)) revert ZeroAddressException(); // F:[FA-16A]\\n\\n        // Checks that the account hf < 1 and computes the totalValue\\n        // before the multicall\\n        (bool isLiquidatable, uint256 totalValue) = _isAccountLiquidatable(\\n            creditAccount\\n        ); // F:[FA-14]\\n\\n        // An account can't be liquidated if hf >= 1\\n        if (!isLiquidatable)\\n            revert CantLiquidateWithSuchHealthFactorException(); // F:[FA-14]\\n\\n        // Wraps ETH and sends it back to msg.sender\\n        _wrapETH(); // F:[FA-3D]\\n\\n        // Checks if the liquidation is done while the contract is paused\\n        bool emergencyLiquidation = _checkIfEmergencyLiquidator(true);\\n\\n        if (calls.length != 0)\\n            _multicall(calls, borrower, creditAccount, true, false); // F:[FA-15]\\n\\n        if (emergencyLiquidation) {\\n            totalValue =\\n                (totalValue * params.emergencyLiquidationDiscount) /\\n                PERCENTAGE_FACTOR;\\n            _checkIfEmergencyLiquidator(false);\\n        }\\n\\n        uint256 remainingFunds = _closeLiquidatedAccount(\\n            totalValue,\\n            creditAccount,\\n            borrower,\\n            to,\\n            skipTokenMask,\\n            false\\n        );\\n\\n        emit LiquidateCreditAccount(borrower, msg.sender, to, remainingFunds); // F:[FA-15]\\n    }\\n\\n    /// @dev Runs a batch of transactions within a multicall and liquidates the account when\\n    /// this Credit Facade is expired\\n    /// The general flow of liquidation is nearly the same as normal liquidations, with two main differences:\\n    ///     - An account can be liquidated on an expired Credit Facade even with hf > 1. However,\\n    ///       no accounts can be liquidated through this function if the Credit Facade is not expired.\\n    ///     - Liquidation premiums and fees for liquidating expired accounts are reduced.\\n    /// It is still possible to normally liquidate an underwater Credit Account, even when the Credit Facade\\n    /// is expired.\\n    /// @param to Address to send funds to after liquidation\\n    /// @param skipTokenMask Uint-encoded bit mask where 1's mark tokens that shouldn't be transferred\\n    /// @param calls The array of MultiCall structs encoding the operations to execute before liquidating the account.\\n    /// @notice See more at https://dev.gearbox.fi/docs/documentation/credit/liquidation#liquidating-accounts-by-expiration\\n    function liquidateExpiredCreditAccount(\\n        address borrower,\\n        address to,\\n        uint256 skipTokenMask,\\n        MultiCall[] calldata calls\\n    ) external payable override nonReentrant {\\n        _liquidateExpiredCreditAccount(borrower, to, skipTokenMask, calls);\\n    }\\n\\n    /// @dev A version of `liquidateExpiredCreditAccount` with `convertWETH` parameter that is ignored.\\n    ///      Used for backward compatibility.\\n    function liquidateExpiredCreditAccount(\\n        address borrower,\\n        address to,\\n        uint256 skipTokenMask,\\n        bool,\\n        MultiCall[] calldata calls\\n    ) external payable override nonReentrant {\\n        _liquidateExpiredCreditAccount(borrower, to, skipTokenMask, calls);\\n    }\\n\\n    /// @dev IMPLEMENTATION: liquidateExpiredCreditAccount\\n    function _liquidateExpiredCreditAccount(\\n        address borrower,\\n        address to,\\n        uint256 skipTokenMask,\\n        MultiCall[] calldata calls\\n    ) internal {\\n        // Checks that the CA exists to revert early for late liquidations and save gas\\n        address creditAccount = creditManager.getCreditAccountOrRevert(\\n            borrower\\n        );\\n\\n        // Checks that the to address is not zero\\n        if (to == address(0)) revert ZeroAddressException();\\n\\n        // Checks that this Credit Facade is expired and reverts if not\\n        if (!_isExpired()) {\\n            revert CantLiquidateNonExpiredException(); // F: [FA-47,48]\\n        }\\n\\n        // Calculates the total value of an account\\n        (uint256 totalValue, ) = calcTotalValue(creditAccount);\\n\\n        // Wraps ETH and sends it back to msg.sender address\\n        _wrapETH();\\n\\n        // Checks if the liquidation is done while the contract is paused\\n        bool emergencyLiquidation = _checkIfEmergencyLiquidator(true);\\n\\n        if (calls.length != 0)\\n            _multicall(calls, borrower, creditAccount, true, false); // F:[FA-49]\\n\\n        if (emergencyLiquidation) {\\n            totalValue =\\n                (totalValue * params.emergencyLiquidationDiscount) /\\n                PERCENTAGE_FACTOR;\\n            _checkIfEmergencyLiquidator(false);\\n        }\\n\\n        uint256 remainingFunds = _closeLiquidatedAccount(\\n            totalValue,\\n            creditAccount,\\n            borrower,\\n            to,\\n            skipTokenMask,\\n            true\\n        );\\n\\n        // Emits event\\n        emit LiquidateExpiredCreditAccount(\\n            borrower,\\n            msg.sender,\\n            to,\\n            remainingFunds\\n        ); // F:[FA-49]\\n    }\\n\\n    /// @dev Closes a liquidated credit account, possibly expired\\n    function _closeLiquidatedAccount(\\n        uint256 totalValue,\\n        address creditAccount,\\n        address borrower,\\n        address to,\\n        uint256 skipTokenMask,\\n        bool expired\\n    ) internal returns (uint256 remainingFunds) {\\n        uint256 helperBalance = _isBlacklisted(borrower);\\n        // If the borrower is blacklisted, transfer the account to a special recovery contract,\\n        // so that the attempt to transfer remaining funds to a blacklisted borrower does not\\n        // break the liquidation. The borrower can retrieve the funds from the recovery contract afterwards.\\n        if (helperBalance > 0) {\\n            creditManager.transferAccountOwnership(borrower, blacklistHelper); // F:[FA-56]\\n        }\\n\\n        uint256 availableLiquidityBefore = _getAvailableLiquidity();\\n\\n        (\\n            uint256 borrowedAmount,\\n            uint256 borrowAmountWithInterest,\\n\\n        ) = creditManager.calcCreditAccountAccruedInterest(creditAccount);\\n\\n        // Liquidates the CA and sends the remaining funds to the borrower or blacklist helper\\n        remainingFunds = creditManager.closeCreditAccount(\\n            helperBalance > 0 ? blacklistHelper : borrower,\\n            expired\\n                ? ClosureAction.LIQUIDATE_EXPIRED_ACCOUNT\\n                : ClosureAction.LIQUIDATE_ACCOUNT,\\n            totalValue,\\n            msg.sender,\\n            to,\\n            skipTokenMask,\\n            false\\n        ); // F:[FA-15,49]\\n\\n        uint256 availableLiquidityAfter = _getAvailableLiquidity();\\n\\n        uint256 loss = availableLiquidityAfter <\\n            availableLiquidityBefore + borrowAmountWithInterest\\n            ? availableLiquidityBefore +\\n                borrowAmountWithInterest -\\n                availableLiquidityAfter\\n            : 0;\\n\\n        if (loss > 0) {\\n            params.isIncreaseDebtForbidden = true; // F: [FA-15A]\\n\\n            lossParams.currentCumulativeLoss += loss.toUint128();\\n            if (\\n                lossParams.currentCumulativeLoss > lossParams.maxCumulativeLoss\\n            ) {\\n                _pauseCreditManager(); // F: [FA-15B]\\n            }\\n            emit IncurLossOnLiquidation(loss);\\n        }\\n\\n        // Decreases the total debt\\n        _checkAndUpdateTotalDebt(borrowedAmount, false);\\n\\n        /// Credit Facade increases borrower's claimable balance in BlacklistHelper, so the\\n        /// borrower can recover funds to a different address\\n        if (helperBalance > 0 && remainingFunds > 1) {\\n            _increaseClaimableBalance(borrower, helperBalance);\\n        }\\n    }\\n\\n    /// @dev Checks whether borrower is blacklisted in the underlying token and, if so,\\n    ///      returns non-zero value equal to blacklist helper's balance of underlying\\n    //       Zero return value always indicates that borrower is not blacklisted\\n    function _isBlacklisted(address borrower)\\n        internal\\n        view\\n        returns (uint256 helperBalance)\\n    {\\n        if (\\n            isBlacklistableUnderlying &&\\n            IBlacklistHelper(blacklistHelper).isBlacklisted(\\n                underlying,\\n                borrower\\n            ) // F:[FA-56]\\n        ) {\\n            // can't realistically overflow\\n            unchecked {\\n                helperBalance =\\n                    IERC20(underlying).balanceOf(blacklistHelper) +\\n                    1;\\n            }\\n        }\\n    }\\n\\n    /// @dev Checks if blacklist helper's balance of underlying increased after liquidation\\n    ///      and, if so, increases the borrower's claimable balance by the difference\\n    ///      Not relying on `remainingFunds` to support fee-on-transfer tokens\\n    function _increaseClaimableBalance(\\n        address borrower,\\n        uint256 helperBalanceBefore\\n    ) internal {\\n        uint256 helperBalance = IERC20(underlying).balanceOf(blacklistHelper);\\n        if (helperBalance > helperBalanceBefore) {\\n            uint256 amount;\\n            unchecked {\\n                amount = helperBalance - helperBalanceBefore + 1;\\n            }\\n            IBlacklistHelper(blacklistHelper).addClaimable(\\n                underlying,\\n                borrower,\\n                amount\\n            ); // F:[FA-56]\\n            emit UnderlyingSentToBlacklistHelper(borrower, amount); // F:[FA-56]\\n        }\\n    }\\n\\n    /// @dev Increases debt for a Credit Account\\n    /// @param borrower Owner of the account\\n    /// @param creditAccount CA to increase debt for\\n    /// @param amount Amount to borrow\\n    function _increaseDebt(\\n        address borrower,\\n        address creditAccount,\\n        uint256 amount\\n    ) internal {\\n        // It is forbidden to take new debt if increaseDebtForbidden mode is enabled\\n        if (params.isIncreaseDebtForbidden) {\\n            revert IncreaseDebtForbiddenException();\\n        } // F:[FA-18C]\\n\\n        // Checks that the borrowed amount does not violate the per block limit\\n        _checkAndUpdateBorrowedBlockLimit(amount); // F:[FA-18A]\\n\\n        // Checks that there are no forbidden tokens, as borrowing\\n        // is prohibited when forbidden tokens are enabled on the account\\n        _checkForbiddenTokens(creditAccount);\\n\\n        // Checks that the total debt limit is not exceeded and increases total debt\\n        _checkAndUpdateTotalDebt(amount, true); // F: [FA-11C]\\n\\n        // Requests the Credit Manager to borrow additional funds from the pool\\n        uint256 newBorrowedAmount = creditManager.manageDebt(\\n            creditAccount,\\n            amount,\\n            true\\n        ); // F:[FA-17]\\n\\n        // Checks that the new total borrowed amount is within bounds\\n        _revertIfOutOfBorrowedLimits(newBorrowedAmount); // F:[FA-18B]\\n\\n        // Emits event\\n        emit IncreaseBorrowedAmount(borrower, amount); // F:[FA-17]\\n    }\\n\\n    /// @dev Checks that there are no intersections between the user's enabled tokens\\n    /// and the set of forbidden tokens\\n    /// @notice The main purpose of forbidding tokens is to prevent exposing\\n    /// pool funds to dangerous or exploited collateral, without immediately\\n    /// liquidating accounts that hold the forbidden token\\n    /// There are two ways pool funds can be exposed:\\n    ///     - The CA owner tries to swap borrowed funds to the forbidden asset:\\n    ///       this will be blocked by checkAndEnableToken, which is invoked for tokenOut\\n    ///       after every operation;\\n    ///     - The CA owner with an already enabled forbidden token transfers it\\n    ///       to the account - they can't use addCollateral / enableToken due to checkAndEnableToken,\\n    ///       but can transfer the token directly when it is enabled and it will be counted in the collateral -\\n    ///       an borrows against it. This check is used to prevent this.\\n    /// If the owner has a forbidden token and want to take more debt, they must first\\n    /// dispose of the token and disable it.\\n    function _checkForbiddenTokens(address creditAccount) internal view {\\n        uint256 enabledTokenMask = creditManager.enabledTokensMap(\\n            creditAccount\\n        );\\n        uint256 forbiddenTokenMask = creditManager.forbiddenTokenMask();\\n\\n        if (enabledTokenMask & forbiddenTokenMask > 0) {\\n            revert ActionProhibitedWithForbiddenTokensException();\\n        }\\n    }\\n\\n    /// @dev Decreases debt for a Credit Account\\n    /// @param borrower Owner of the account\\n    /// @param creditAccount Account to decrease debt for\\n    /// @param amount Amount to repay\\n    function _decreaseDebt(\\n        address borrower,\\n        address creditAccount,\\n        uint256 amount\\n    ) internal {\\n        (uint256 borrowedAmountBefore, , ) = creditManager\\n            .calcCreditAccountAccruedInterest(creditAccount);\\n\\n        // Requests the creditManager to reduce the borrowed sum by amount\\n        uint256 newBorrowedAmount = creditManager.manageDebt(\\n            creditAccount,\\n            amount,\\n            false\\n        ); // F:[FA-19]\\n\\n        // Checks that the new borrowed amount is within limits\\n        _revertIfOutOfBorrowedLimits(newBorrowedAmount); // F:[FA-20]\\n\\n        // Decreases total debt\\n        // Since part of the amount can be used to repay interest,\\n        // we need to compute the difference between the old and new borrowed amount\\n        _checkAndUpdateTotalDebt(\\n            borrowedAmountBefore - newBorrowedAmount,\\n            false\\n        );\\n\\n        // Emits an event\\n        emit DecreaseBorrowedAmount(borrower, amount); // F:[FA-19]\\n    }\\n\\n    /// @dev Adds collateral to borrower's credit account\\n    /// @param onBehalfOf Address of the borrower whose account is funded\\n    /// @param token Address of a collateral token\\n    /// @param amount Amount to add\\n    function addCollateral(\\n        address onBehalfOf,\\n        address token,\\n        uint256 amount\\n    ) external payable override nonReentrant {\\n        // Wraps ETH and sends it back to msg.sender\\n        _wrapETH(); // F:[FA-3E]\\n\\n        // Checks that onBehalfOf has an account\\n        address creditAccount = creditManager.getCreditAccountOrRevert(\\n            onBehalfOf\\n        ); // F:[FA-2]\\n\\n        addCollateral(onBehalfOf, creditAccount, token, amount);\\n\\n        // Since this action can enable new tokens, Credit Manager\\n        // needs to check that the max enabled token limit is not\\n        // breached\\n        creditManager.checkAndOptimizeEnabledTokens(creditAccount); // F: [FA-21C]\\n    }\\n\\n    function addCollateral(\\n        address onBehalfOf,\\n        address creditAccount,\\n        address token,\\n        uint256 amount\\n    ) internal {\\n        // Checks that msg.sender can transfer funds to onBehalfOf's account\\n        // This is done to prevent malicious actors sending bad collateral\\n        // to users\\n        // mgs.sender can only add collateral if transfer are approved\\n        // from itself to onBehalfOf\\n        _revertIfActionOnAccountNotAllowed(onBehalfOf); // F: [FA-21A]\\n\\n        // Requests Credit Manager to transfer collateral to the Credit Account\\n        creditManager.addCollateral(msg.sender, creditAccount, token, amount); // F:[FA-21]\\n\\n        // Emits event\\n        emit AddCollateral(onBehalfOf, token, amount); // F:[FA-21]\\n    }\\n\\n    /// @dev Executes a batch of transactions within a Multicall, to manage an existing account\\n    ///  - Wraps ETH and sends it back to msg.sender, if value > 0\\n    ///  - Executes the Multicall\\n    ///  - Performs a fullCollateralCheck to verify that hf > 1 after all actions\\n    /// @param calls The array of MultiCall structs encoding the operations to execute.\\n    function multicall(MultiCall[] calldata calls)\\n        external\\n        payable\\n        override\\n        nonReentrant\\n    {\\n        // Checks that msg.sender has an account\\n        address creditAccount = creditManager.getCreditAccountOrRevert(\\n            msg.sender\\n        );\\n\\n        // Wraps ETH and sends it back to msg.sender\\n        _wrapETH(); // F:[FA-3F]\\n\\n        if (calls.length != 0) {\\n            _multicall(calls, msg.sender, creditAccount, false, false);\\n\\n            // Performs a fullCollateralCheck\\n            // During a multicall, all intermediary health checks are skipped,\\n            // as one fullCollateralCheck at the end is sufficient\\n            creditManager.fullCollateralCheck(creditAccount);\\n        }\\n    }\\n\\n    /// @dev IMPLEMENTATION: multicall\\n    /// - Transfers ownership from  borrower to this contract, as most adapter and Credit Manager functions retrieve\\n    ///   the Credit Account by msg.sender\\n    /// - Executes the provided list of calls:\\n    ///   + if targetContract == address(this), parses call data in the struct and calls the appropriate function (see _processCreditFacadeMulticall below)\\n    ///   + if targetContract == adapter, calls the adapter with call data as provided.\\n    /// @param borrower Owner of the Credit Account\\n    /// @param creditAccount Credit Account address\\n    /// @param isClosure Whether the multicall is being invoked during a closure action. Calls to Credit Facade are forbidden inside\\n    ///                  multicalls on closure.\\n    /// @param increaseDebtWasCalled True if debt was increased before or during the multicall. Used to prevent free flashloans by\\n    ///                  increasing and decreasing debt within a single multicall.\\n    function _multicall(\\n        MultiCall[] calldata calls,\\n        address borrower,\\n        address creditAccount,\\n        bool isClosure,\\n        bool increaseDebtWasCalled\\n    ) internal {\\n        // Takes ownership of the Credit Account\\n        creditManager.transferAccountOwnership(borrower, address(this)); // F:[FA-26]\\n\\n        // Emits event for multicall start - used in analytics to track actions within multicalls\\n        emit MultiCallStarted(borrower); // F:[FA-26]\\n\\n        // Declares the expectedBalances array, which can later be used for slippage control\\n        Balance[] memory expectedBalances;\\n\\n        uint256 len = calls.length; // F:[FA-26]\\n        for (uint256 i = 0; i < len; ) {\\n            MultiCall calldata mcall = calls[i]; // F:[FA-26]\\n\\n            // Reverts of calldata has less than 4 bytes\\n            if (mcall.callData.length < 4) revert IncorrectCallDataException(); // F:[FA-22]\\n\\n            if (mcall.target == address(this)) {\\n                // No internal calls on closure except slippage control, to avoid loss manipulation\\n                if (isClosure) {\\n                    bytes4 method = bytes4(mcall.callData);\\n                    if (\\n                        method !=\\n                        ICreditFacadeExtended.revertIfReceivedLessThan.selector\\n                    ) revert ForbiddenDuringClosureException(); // F:[FA-13]\\n                }\\n\\n                //\\n                // CREDIT FACADE\\n                //\\n\\n                // increaseDebtWasCalled and expectedBalances are parameters that persist throughout multicall,\\n                // therefore they are passed to the internal function processor, which returns updated values\\n                (\\n                    increaseDebtWasCalled,\\n                    expectedBalances\\n                ) = _processCreditFacadeMulticall(\\n                    borrower,\\n                    creditAccount,\\n                    mcall.callData,\\n                    increaseDebtWasCalled,\\n                    expectedBalances\\n                );\\n            } else {\\n                //\\n                // ADAPTERS\\n                //\\n\\n                // Checks that the target is an allowed adapter and not CreditManager\\n                // As CreditFacade has powerful permissions in CreditManagers,\\n                // functionCall to it is strictly forbidden, even if\\n                // the Configurator adds it as an adapter\\n                if (\\n                    creditManager.adapterToContract(mcall.target) ==\\n                    address(0) ||\\n                    mcall.target == address(creditManager)\\n                ) revert TargetContractNotAllowedException(); // F:[FA-24]\\n\\n                // Makes a call\\n                mcall.target.functionCall(mcall.callData); // F:[FA-29]\\n            }\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        // If expectedBalances was set by calling revertIfGetLessThan,\\n        // checks that actual token balances are not less than expected balances\\n        if (expectedBalances.length != 0)\\n            _compareBalances(expectedBalances, creditAccount);\\n\\n        // Emits event for multicall end - used in analytics to track actions within multicalls\\n        emit MultiCallFinished(); // F:[FA-27,27,29]\\n\\n        // Returns ownership back to the borrower\\n        creditManager.transferAccountOwnership(address(this), borrower); // F:[FA-27,27,29]\\n    }\\n\\n    /// @dev Internal function for processing calls to Credit Facade within the multicall\\n    /// @param borrower Original owner of the Credit Account\\n    /// @param creditAccount Credit Account address\\n    /// @param callData Call data of the currently processed call\\n    /// @param increaseDebtWasCalledBefore Whether debt was increased before entering the function\\n    /// @param expectedBalances Array of expected balances before entering the function\\n    function _processCreditFacadeMulticall(\\n        address borrower,\\n        address creditAccount,\\n        bytes calldata callData,\\n        bool increaseDebtWasCalledBefore,\\n        Balance[] memory expectedBalancesBefore\\n    )\\n        internal\\n        returns (bool increaseDebtWasCalled, Balance[] memory expectedBalances)\\n    {\\n        increaseDebtWasCalled = increaseDebtWasCalledBefore;\\n        expectedBalances = expectedBalancesBefore;\\n\\n        bytes4 method = bytes4(callData);\\n\\n        //\\n        // REVERT_IF_GET_LESS_THAN\\n        //\\n\\n        // This is an extension function that instructs CreditFacade to check token balances at the end\\n        // Used to control slippage after the entire sequence of operations, since tracking slippage\\n        // On each operation is not ideal\\n        if (method == ICreditFacadeExtended.revertIfReceivedLessThan.selector) {\\n            // Method can only be called once since the provided Balance array\\n            // contains deltas that are added to the current balances\\n            // Calling this function again could potentially override old values\\n            // and cause confusion, especially if called later in the MultiCall\\n            if (expectedBalances.length != 0)\\n                revert ExpectedBalancesAlreadySetException(); // F:[FA-45A]\\n\\n            // Retrieves the balance list from calldata\\n            expectedBalances = abi.decode(callData[4:], (Balance[])); // F:[FA-45]\\n\\n            // Sets expected balances to currentBalance + delta\\n            expectedBalances = _storeBalances(expectedBalances, creditAccount); // F:[FA-45]\\n        }\\n        //\\n        // ADD COLLATERAL\\n        //\\n        else if (method == ICreditFacadeExtended.addCollateral.selector) {\\n            // Parses parameters from calldata\\n            (address token, uint256 amount) = abi.decode(\\n                callData[4:],\\n                (address, uint256)\\n            ); // F:[FA-26, 27]\\n\\n            // In case onBehalfOf isn't the owner of the currently processed account,\\n            // retrieves onBehalfOf's account\\n            addCollateral(msg.sender, creditAccount, token, amount); // F:[FA-26, 27]\\n        }\\n        //\\n        // INCREASE DEBT\\n        //\\n        else if (method == ICreditFacadeExtended.increaseDebt.selector) {\\n            // Sets increaseDebtWasCalled to prevent debt reductions afterwards,\\n            // as that could be used to get free flash loans\\n            increaseDebtWasCalled = true; // F:[FA-28]\\n\\n            // Parses parameters from calldata\\n            uint256 amount = abi.decode(callData[4:], (uint256)); // F:[FA-26]\\n            _increaseDebt(borrower, creditAccount, amount); // F:[FA-26]\\n        }\\n        //\\n        // DECREASE DEBT\\n        //\\n        else if (method == ICreditFacadeExtended.decreaseDebt.selector) {\\n            // it's forbidden to call decreaseDebt after increaseDebt, in the same multicall\\n            if (increaseDebtWasCalled)\\n                revert IncreaseAndDecreaseForbiddenInOneCallException(); // F:[FA-28]\\n\\n            // Parses parameters from calldata\\n            uint256 amount = abi.decode(callData[4:], (uint256)); // F:[FA-27]\\n\\n            _decreaseDebt(borrower, creditAccount, amount); // F:[FA-27]\\n        }\\n        //\\n        // ENABLE TOKEN\\n        //\\n        else if (method == ICreditFacadeExtended.enableToken.selector) {\\n            // Parses token\\n            address token = abi.decode(callData[4:], (address)); // F: [FA-53]\\n\\n            // Executes enableToken for creditAccount\\n            _enableToken(borrower, creditAccount, token); // F: [FA-53]\\n        }\\n        //\\n        // DISABLE TOKEN\\n        //\\n        // This is an extenstion method used to disable tokens on a Credit Account\\n        // Can be used to remove troublesome tokens (e.g., forbidden tokens) from an account\\n        else if (method == ICreditFacadeExtended.disableToken.selector) {\\n            // Parses token\\n            address token = abi.decode(callData[4:], (address)); // F: [FA-54]\\n\\n            // Executes disableToken for creditAccount\\n            _disableToken(borrower, creditAccount, token); // F: [FA-54]\\n        } else {\\n            // Reverts if the passed selector is unrecognized\\n            revert UnknownMethodException(); // F:[FA-23]\\n        }\\n    }\\n\\n    /// @dev Adds expected deltas to current balances on a Credit account and returns the result\\n    /// @param expected Expected changes to existing balances\\n    /// @param creditAccount Credit Account to compute balances for\\n    function _storeBalances(Balance[] memory expected, address creditAccount)\\n        internal\\n        view\\n        returns (Balance[] memory)\\n    {\\n        uint256 len = expected.length; // F:[FA-45]\\n        for (uint256 i = 0; i < len; ) {\\n            expected[i].balance += IERC20(expected[i].token).balanceOf(\\n                creditAccount\\n            ); // F:[FA-45]\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        return expected; // F:[FA-45]\\n    }\\n\\n    /// @dev Compares current balances to previously saved expected balances.\\n    /// Reverts if at least one balance is lower than expected\\n    /// @param expected Expected balances after all operations\\n    /// @param creditAccount Credit Account to check\\n    function _compareBalances(Balance[] memory expected, address creditAccount)\\n        internal\\n        view\\n    {\\n        uint256 len = expected.length; // F:[FA-45]\\n        for (uint256 i = 0; i < len; ) {\\n            if (\\n                IERC20(expected[i].token).balanceOf(creditAccount) <\\n                expected[i].balance\\n            ) revert BalanceLessThanMinimumDesiredException(expected[i].token); // F:[FA-45]\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /// @dev Transfers credit account to another user\\n    /// By default, this action is forbidden, and the user has to approve transfers from sender to itself\\n    /// by calling approveAccountTransfer.\\n    /// This is done to prevent malicious actors from transferring compromised accounts to other users.\\n    /// @param to Address to transfer the account to\\n    function transferAccountOwnership(address to)\\n        external\\n        override\\n        nonReentrant\\n    {\\n        // In whitelisted mode only select addresses can have Credit Accounts\\n        // So this action is prohibited\\n        if (whitelisted) revert NotAllowedInWhitelistedMode(); // F:[FA-32]\\n\\n        address creditAccount = creditManager.getCreditAccountOrRevert(\\n            msg.sender\\n        ); // F:[FA-2]\\n\\n        // Checks that transfer is allowed\\n        if (!transfersAllowed[msg.sender][to])\\n            revert AccountTransferNotAllowedException(); // F:[FA-33]\\n\\n        /// Checks that the account hf > 1, as it is forbidden to transfer\\n        /// accounts that are liquidatable\\n        (bool isLiquidatable, ) = _isAccountLiquidatable(creditAccount); // F:[FA-34]\\n\\n        if (isLiquidatable) revert CantTransferLiquidatableAccountException(); // F:[FA-34]\\n\\n        // Requests the Credit Manager to transfer the account\\n        creditManager.transferAccountOwnership(msg.sender, to); // F:[FA-35]\\n\\n        // Emits event\\n        emit TransferAccount(msg.sender, to); // F:[FA-35]\\n    }\\n\\n    /// @dev Verifies that the msg.sender can open an account for onBehalfOf\\n    /// -  For expirable Credit Facade, expiration date must not be reached\\n    /// -  For whitelisted mode, msg.sender must open the account for themselves\\n    ///    and have at least one DegenNFT to burn\\n    /// -  Otherwise, checks that account transfers from msg.sender to onBehalfOf\\n    ///    are approved\\n    /// @param onBehalfOf Account which would own credit account\\n    function _revertIfOpenCreditAccountNotAllowed(address onBehalfOf) internal {\\n        // Opening new Credit Accounts is prohibited in increaseDebtForbidden mode\\n        if (params.isIncreaseDebtForbidden)\\n            revert IncreaseDebtForbiddenException(); // F:[FA-7]\\n\\n        // Checks that this CreditFacade is not expired\\n        if (_isExpired()) {\\n            revert OpenAccountNotAllowedAfterExpirationException(); // F: [FA-46]\\n        }\\n\\n        // Checks that the borrower is not blacklisted, if the underlying is blacklistable\\n        if (_isBlacklisted(onBehalfOf) != 0) {\\n            revert NotAllowedForBlacklistedAddressException(); // F:[FA-57]\\n        }\\n\\n        // F:[FA-5] covers case when degenNFT == address(0)\\n        if (degenNFT != address(0)) {\\n            // F:[FA-4B]\\n\\n            // In whitelisted mode, users can only open an account by burning a DegenNFT\\n            // And opening an account for another address is forbidden\\n            if (whitelisted && msg.sender != onBehalfOf)\\n                revert NotAllowedInWhitelistedMode(); // F:[FA-4B]\\n\\n            IDegenNFT(degenNFT).burn(onBehalfOf, 1); // F:[FA-4B]\\n        }\\n\\n        _revertIfActionOnAccountNotAllowed(onBehalfOf);\\n    }\\n\\n    /// @dev Checks if the message sender is allowed to do an action on a CA\\n    /// @param onBehalfOf The account which owns the target CA\\n    function _revertIfActionOnAccountNotAllowed(address onBehalfOf)\\n        internal\\n        view\\n    {\\n        // msg.sender must either be the account owner themselves,\\n        // or be approved for transfers\\n        if (\\n            msg.sender != onBehalfOf &&\\n            !transfersAllowed[msg.sender][onBehalfOf]\\n        ) revert AccountTransferNotAllowedException(); // F:[FA-04C]\\n    }\\n\\n    /// @dev Checks that the per-block borrow limit was not violated and updates the\\n    /// amount borrowed in current block\\n    function _checkAndUpdateBorrowedBlockLimit(uint256 amount) internal {\\n        // Skipped in whitelisted mode, since there is a strict limit on the number\\n        // of credit accounts that can be opened, which implies a limit on borrowing\\n        if (!whitelisted) {\\n            uint256 _limitPerBlock = params.maxBorrowedAmountPerBlock; // F:[FA-18]\\n\\n            // If the limit is unit128.max, the check is disabled\\n            // F:[FA-36] test case when _limitPerBlock == type(uint128).max\\n            if (_limitPerBlock != type(uint128).max) {\\n                (\\n                    uint64 lastBlock,\\n                    uint128 lastLimit\\n                ) = getTotalBorrowedInBlock(); // F:[FA-18, 37]\\n\\n                uint256 newLimit = (lastBlock == block.number)\\n                    ? amount + lastLimit // F:[FA-37]\\n                    : amount; // F:[FA-18, 37]\\n\\n                if (newLimit > _limitPerBlock)\\n                    revert BorrowedBlockLimitException(); // F:[FA-18]\\n\\n                _updateTotalBorrowedInBlock(newLimit.toUint128()); // F:[FA-37]\\n            }\\n        }\\n    }\\n\\n    /// @dev Checks that the borrowed principal is within borrowing limits\\n    /// @param borrowedAmount The current principal of a Credit Account\\n    function _revertIfOutOfBorrowedLimits(uint256 borrowedAmount)\\n        internal\\n        view\\n    {\\n        // Checks that amount is in limits\\n        if (\\n            borrowedAmount < uint256(limits.minBorrowedAmount) ||\\n            borrowedAmount > uint256(limits.maxBorrowedAmount)\\n        ) revert BorrowAmountOutOfLimitsException(); // F:\\n    }\\n\\n    function _checkIfEmergencyLiquidator(bool state) internal returns (bool) {\\n        return creditManager.checkEmergencyPausable(msg.sender, state);\\n    }\\n\\n    /// @dev Updates total debt and checks that it does not exceed the limit\\n    function _checkAndUpdateTotalDebt(uint256 delta, bool isIncrease) internal {\\n        if (delta > 0) {\\n            TotalDebt memory td = totalDebt;\\n\\n            if (isIncrease) {\\n                td.currentTotalDebt += delta.toUint128();\\n                if (td.currentTotalDebt > td.totalDebtLimit) {\\n                    revert BorrowAmountOutOfLimitsException();\\n                }\\n            } else {\\n                td.currentTotalDebt -= delta.toUint128();\\n            }\\n\\n            totalDebt = td;\\n        }\\n    }\\n\\n    /// @dev Returns the last block where debt was taken,\\n    ///      and the total amount borrowed in that block\\n    function getTotalBorrowedInBlock()\\n        public\\n        view\\n        returns (uint64 blockLastUpdate, uint128 borrowedInBlock)\\n    {\\n        blockLastUpdate = uint64(totalBorrowedInBlock >> 128); // F:[FA-37]\\n        borrowedInBlock = uint128(totalBorrowedInBlock & type(uint128).max); // F:[FA-37]\\n    }\\n\\n    /// @dev Saves the total amount borrowed in the current block for future checks\\n    /// @param borrowedInBlock Updated total borrowed amount\\n    function _updateTotalBorrowedInBlock(uint128 borrowedInBlock) internal {\\n        totalBorrowedInBlock = uint256(block.number << 128) | borrowedInBlock; // F:[FA-37]\\n    }\\n\\n    /// @dev Approves account transfer from another user to msg.sender\\n    /// @param from Address for which account transfers are allowed/forbidden\\n    /// @param state True is transfer is allowed, false if forbidden\\n    function approveAccountTransfer(address from, bool state)\\n        external\\n        override\\n        nonReentrant\\n    {\\n        transfersAllowed[from][msg.sender] = state; // F:[FA-38]\\n\\n        // Emits event\\n        emit TransferAccountAllowed(from, msg.sender, state); // F:[FA-38]\\n    }\\n\\n    /// @dev Enables token in enabledTokenMask for a Credit Account\\n    /// @param creditAccount Account for which the token is enabled\\n    /// @param token Collateral token to enabled\\n    function _enableToken(\\n        address borrower,\\n        address creditAccount,\\n        address token\\n    ) internal {\\n        // Will revert if the token is not known or forbidden,\\n        // If the token is disabled, adds the respective bit to the mask, otherwise does nothing\\n        creditManager.checkAndEnableToken(creditAccount, token); // F:[FA-39]\\n\\n        // Emits event\\n        emit TokenEnabled(borrower, token);\\n    }\\n\\n    /// @dev Disable a token for a Credit Account\\n    /// @param borrower Owner of the account\\n    /// @param token Token to disable\\n    function _disableToken(\\n        address borrower,\\n        address creditAccount,\\n        address token\\n    ) internal {\\n        // If the token is enabled, removes a respective bit from the mask,\\n        // otherwise does nothing\\n        if (creditManager.disableToken(creditAccount, token)) {\\n            // Emits event\\n            emit TokenDisabled(borrower, token);\\n        } // F: [FA-54]\\n    }\\n\\n    /// @dev Pauses the Credit Manager\\n    function _pauseCreditManager() internal {\\n        IPausable(address(creditManager)).pause();\\n    }\\n\\n    //\\n    // GETTERS\\n    //\\n\\n    /// @dev Returns true if token is a collateral token and is not forbidden,\\n    /// otherwise returns false\\n    /// @param token Token to check\\n    function isTokenAllowed(address token)\\n        public\\n        view\\n        override\\n        returns (bool allowed)\\n    {\\n        uint256 tokenMask = creditManager.tokenMasksMap(token); // F:[FA-40]\\n        allowed =\\n            (tokenMask != 0) &&\\n            (creditManager.forbiddenTokenMask() & tokenMask == 0); // F:[FA-40]\\n    }\\n\\n    /// @dev Calculates total value for provided Credit Account in underlying\\n    /// More: https://dev.gearbox.fi/developers/credit/economy#totalUSD-value\\n    ///\\n    /// @param creditAccount Credit Account address\\n    /// @return total Total value in underlying\\n    /// @return twv Total weighted (discounted by liquidation thresholds) value in underlying\\n    function calcTotalValue(address creditAccount)\\n        public\\n        view\\n        override\\n        returns (uint256 total, uint256 twv)\\n    {\\n        IPriceOracleV2 priceOracle = IPriceOracleV2(\\n            creditManager.priceOracle()\\n        ); // F:[FA-41]\\n\\n        (uint256 totalUSD, uint256 twvUSD) = _calcTotalValueUSD(\\n            priceOracle,\\n            creditAccount\\n        );\\n        total = priceOracle.convertFromUSD(totalUSD, underlying); // F:[FA-41]\\n        twv =\\n            priceOracle.convertFromUSD(twvUSD, underlying) /\\n            PERCENTAGE_FACTOR; // F:[FA-41]\\n    }\\n\\n    /// @dev Calculates total value for provided Credit Account in USD\\n    /// @param priceOracle Oracle used to convert assets to USD\\n    /// @param creditAccount Address of the Credit Account\\n    /// @return totalUSD Total value of the account in USD\\n    /// @return twvUSD Total weighted (discounted by liquidation thresholds) value in USD\\n    function _calcTotalValueUSD(\\n        IPriceOracleV2 priceOracle,\\n        address creditAccount\\n    ) internal view returns (uint256 totalUSD, uint256 twvUSD) {\\n        uint256 tokenMask = 1;\\n        uint256 enabledTokensMask = creditManager.enabledTokensMap(\\n            creditAccount\\n        ); // F:[FA-41]\\n\\n        while (tokenMask <= enabledTokensMask) {\\n            if (enabledTokensMask & tokenMask != 0) {\\n                (address token, uint16 liquidationThreshold) = creditManager\\n                    .collateralTokensByMask(tokenMask);\\n                uint256 balance = IERC20(token).balanceOf(creditAccount); // F:[FA-41]\\n\\n                if (balance > 1) {\\n                    uint256 value = priceOracle.convertToUSD(balance, token); // F:[FA-41]\\n\\n                    unchecked {\\n                        totalUSD += value; // F:[FA-41]\\n                    }\\n                    twvUSD += value * liquidationThreshold; // F:[FA-41]\\n                }\\n            } // T:[FA-41]\\n\\n            tokenMask = tokenMask << 1; // F:[FA-41]\\n        }\\n    }\\n\\n    /**\\n     * @dev Calculates health factor for the credit account\\n     *\\n     *          sum(asset[i] * liquidation threshold[i])\\n     *   Hf = --------------------------------------------\\n     *         borrowed amount + interest accrued + fees\\n     *\\n     *\\n     * More info: https://dev.gearbox.fi/developers/credit/economy#health-factor\\n     *\\n     * @param creditAccount Credit account address\\n     * @return hf = Health factor in bp (see PERCENTAGE FACTOR in PercentageMath.sol)\\n     */\\n    function calcCreditAccountHealthFactor(address creditAccount)\\n        public\\n        view\\n        override\\n        returns (uint256 hf)\\n    {\\n        (, uint256 twv) = calcTotalValue(creditAccount); // F:[FA-42]\\n        (, , uint256 borrowAmountWithInterestAndFees) = creditManager\\n            .calcCreditAccountAccruedInterest(creditAccount); // F:[FA-42]\\n        hf = (twv * PERCENTAGE_FACTOR) / borrowAmountWithInterestAndFees; // F:[FA-42]\\n    }\\n\\n    /// @dev Returns true if the borrower has an open Credit Account\\n    /// @param borrower Borrower address\\n    function hasOpenedCreditAccount(address borrower)\\n        public\\n        view\\n        override\\n        returns (bool)\\n    {\\n        return creditManager.creditAccounts(borrower) != address(0); // F:[FA-43]\\n    }\\n\\n    /// @dev Wraps ETH into WETH and sends it back to msg.sender\\n    function _wrapETH() internal {\\n        if (msg.value > 0) {\\n            IWETH(wethAddress).deposit{ value: msg.value }(); // F:[FA-3]\\n            IWETH(wethAddress).transfer(msg.sender, msg.value); // F:[FA-3]\\n        }\\n    }\\n\\n    /// @dev Checks if account is liquidatable (i.e., hf < 1)\\n    /// @param creditAccount Address of credit account to check\\n    /// @return isLiquidatable True if account can be liquidated\\n    /// @return totalValue Total value of the Credit Account in underlying\\n    function _isAccountLiquidatable(address creditAccount)\\n        internal\\n        view\\n        returns (bool isLiquidatable, uint256 totalValue)\\n    {\\n        IPriceOracleV2 priceOracle = IPriceOracleV2(\\n            creditManager.priceOracle()\\n        ); // F:[FA-14]\\n\\n        (uint256 totalUSD, uint256 twvUSD) = _calcTotalValueUSD(\\n            priceOracle,\\n            creditAccount\\n        );\\n\\n        // Computes total value in underlying\\n        totalValue = priceOracle.convertFromUSD(totalUSD, underlying); // F:[FA-14]\\n\\n        (, , uint256 borrowAmountWithInterestAndFees) = creditManager\\n            .calcCreditAccountAccruedInterest(creditAccount); // F:[FA-14]\\n\\n        // borrowAmountPlusInterestRateUSD x 10000 to be compared with USD values multiplied by LTs\\n        uint256 borrowAmountPlusInterestRateUSD = priceOracle.convertToUSD(\\n            borrowAmountWithInterestAndFees,\\n            underlying\\n        ) * PERCENTAGE_FACTOR;\\n\\n        // Checks that current Hf < 1\\n        isLiquidatable = twvUSD < borrowAmountPlusInterestRateUSD;\\n    }\\n\\n    /// @dev Returns whether the Credit Facade is expired\\n    function _isExpired() internal view returns (bool isExpired) {\\n        isExpired = (expirable) && (block.timestamp >= params.expirationDate); // F: [FA-46,47,48]\\n    }\\n\\n    /// @dev Returns the current available liquidity of the pool\\n    function _getAvailableLiquidity() internal view returns (uint256) {\\n        return IERC20(underlying).balanceOf(pool);\\n    }\\n\\n    //\\n    // CONFIGURATION\\n    //\\n\\n    /// @dev Sets the increaseDebtForbidden mode\\n    /// @notice increaseDebtForbidden can be used to secure pool funds\\n    /// without pausing the entire system. E.g., if a bug is reported\\n    /// that can potentially lead to loss of funds, but there is no\\n    /// immediate threat, new borrowing can be stopped, while other\\n    /// functionality (trading, closing/liquidating accounts) is retained\\n    function setIncreaseDebtForbidden(bool _mode)\\n        external\\n        creditConfiguratorOnly // F:[FA-44]\\n    {\\n        params.isIncreaseDebtForbidden = _mode;\\n    }\\n\\n    /// @dev Sets borrowing limit per single block\\n    /// @notice Borrowing limit per block in conjunction with\\n    /// the monitoring system serves to minimize loss from hacks\\n    /// While an attacker would be able to steal, in worst case,\\n    /// up to (limitPerBlock * n blocks) of funds, the monitoring\\n    /// system would pause the contracts after detecting suspicious\\n    /// activity\\n    function setLimitPerBlock(uint128 newLimit)\\n        external\\n        creditConfiguratorOnly // F:[FA-44]\\n    {\\n        params.maxBorrowedAmountPerBlock = newLimit;\\n    }\\n\\n    /// @dev Sets the total debt limit and the current total debt value (used for Credit Facade migration)\\n    function setTotalDebtParams(uint128 newCurrentTotalDebt, uint128 newLimit)\\n        external\\n        creditConfiguratorOnly\\n    {\\n        totalDebt.currentTotalDebt = newCurrentTotalDebt;\\n        totalDebt.totalDebtLimit = newLimit;\\n    }\\n\\n    /// @dev Sets Credit Facade expiration date\\n    /// @notice See more at https://dev.gearbox.fi/docs/documentation/credit/liquidation#liquidating-accounts-by-expiration\\n    function setExpirationDate(uint40 newExpirationDate)\\n        external\\n        creditConfiguratorOnly\\n    {\\n        if (!expirable) {\\n            revert NotAllowedWhenNotExpirableException();\\n        }\\n        params.expirationDate = newExpirationDate;\\n    }\\n\\n    /// @dev Sets borrowing limits per single Credit Account\\n    /// @param _minBorrowedAmount The minimal borrowed amount per Credit Account. Minimal amount can be relevant\\n    /// for liquidations, since very small amounts will make liquidations unprofitable for liquidators\\n    /// @param _maxBorrowedAmount The maximal borrowed amount per Credit Account. Used to limit exposure per a single\\n    /// credit account - especially relevant in whitelisted mode.\\n    function setCreditAccountLimits(\\n        uint128 _minBorrowedAmount,\\n        uint128 _maxBorrowedAmount\\n    ) external creditConfiguratorOnly {\\n        limits.minBorrowedAmount = _minBorrowedAmount; // F:\\n        limits.maxBorrowedAmount = _maxBorrowedAmount; // F:\\n    }\\n\\n    /// @dev Sets the max cumulative loss that can be accrued before pausing the Credit Manager\\n    function setMaxCumulativeLoss(uint128 _maxCumulativeLoss)\\n        external\\n        creditConfiguratorOnly\\n    {\\n        lossParams.maxCumulativeLoss = _maxCumulativeLoss;\\n    }\\n\\n    /// @dev Resets the current cumulative loss value\\n    function resetCumulativeLoss() external creditConfiguratorOnly {\\n        lossParams.currentCumulativeLoss = 0;\\n    }\\n\\n    /// @dev Sets the new emergency liquidation discount value\\n    function setEmergencyLiquidationDiscount(uint16 newDiscount)\\n        external\\n        creditConfiguratorOnly\\n    {\\n        params.emergencyLiquidationDiscount = newDiscount;\\n    }\\n}\\n\"\r\n    },\r\n    \"@gearbox-protocol/core-v2/contracts/interfaces/external/IWETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.7.4;\\n\\ninterface IWETH {\\n    /// @dev Deposits native ETH into the contract and mints WETH\\n    function deposit() external payable;\\n\\n    /// @dev Transfers WETH to another account\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /// @dev Burns WETH from msg.sender and send back native ETH\\n    function withdraw(uint256) external;\\n}\\n\"\r\n    },\r\n    \"@gearbox-protocol/core-v2/contracts/interfaces/IBlacklistHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Gearbox Protocol. Generalized leverage for DeFi protocols\\n// (c) Gearbox Holdings, 2022\\npragma solidity ^0.8.10;\\n\\nimport { IVersion } from \\\"./IVersion.sol\\\";\\n\\ninterface IBlacklistHelperEvents {\\n    /// @dev Emitted when a borrower's claimable balance is increased\\n    event ClaimableAdded(\\n        address indexed underlying,\\n        address indexed holder,\\n        uint256 amount\\n    );\\n\\n    /// @dev Emitted when a borrower claims their tokens\\n    event Claimed(\\n        address indexed underlying,\\n        address indexed holder,\\n        address to,\\n        uint256 amount\\n    );\\n\\n    /// @dev Emitted when a Credit Facade is added to BlacklistHelper\\n    event CreditFacadeAdded(address indexed creditFacade);\\n\\n    /// @dev Emitted when a Credit Facade is removed from BlacklistHelper\\n    event CreditFacadeRemoved(address indexed creditFacade);\\n}\\n\\ninterface IBlacklistHelperExceptions {\\n    /// @dev Thrown when an access-restricted function is called by non-CreditFacade\\n    error CreditFacadeOnlyException();\\n\\n    /// @dev Thrown when attempting to add a Credit Facade that has non-blacklistable underlying\\n    error CreditFacadeNonBlacklistable();\\n\\n    /// @dev Thrown when attempting to claim funds without having anything claimable\\n    error NothingToClaimException();\\n}\\n\\ninterface IBlacklistHelper is\\n    IBlacklistHelperEvents,\\n    IBlacklistHelperExceptions,\\n    IVersion\\n{\\n    /// @dev Returns whether the account is blacklisted for a particular underlying\\n    /// @param underlying Underlying token to check\\n    /// @param account Account to check\\n    function isBlacklisted(address underlying, address account)\\n        external\\n        view\\n        returns (bool);\\n\\n    /// @dev Transfers the sender's claimable balance of underlying to the specified address\\n    /// @param underlying Underlying to transfer\\n    /// @param to Recipient address\\n    function claim(address underlying, address to) external;\\n\\n    /// @dev Increases the underlying balance available to claim by the account\\n    /// @param underlying Underlying to increase claimable for\\n    /// @param holder Account to increase claimable for\\n    /// @param amount Amount to increase claimable claimable for\\n    function addClaimable(\\n        address underlying,\\n        address holder,\\n        uint256 amount\\n    ) external;\\n\\n    /// @dev Returns the amount claimable by an account\\n    /// @param underlying Underlying to get the amount for\\n    /// @param holder Acccount to get the amount for\\n    function claimable(address underlying, address holder)\\n        external\\n        view\\n        returns (uint256);\\n}\\n\"\r\n    },\r\n    \"@gearbox-protocol/core-v2/contracts/interfaces/ICreditFacade.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Gearbox Protocol. Generalized leverage for DeFi protocols\\n// (c) Gearbox Holdings, 2022\\npragma solidity ^0.8.10;\\n\\nimport { Balance } from \\\"../libraries/Balances.sol\\\";\\nimport { MultiCall } from \\\"../libraries/MultiCall.sol\\\";\\nimport { ICreditManagerV2, ICreditManagerV2Exceptions } from \\\"./ICreditManagerV2.sol\\\";\\nimport { IVersion } from \\\"./IVersion.sol\\\";\\n\\ninterface ICreditFacadeExtended {\\n    /// @dev Stores expected balances (computed as current balance + passed delta)\\n    ///      and compare with actual balances at the end of a multicall, reverts\\n    ///      if at least one is less than expected\\n    /// @param expected Array of expected balance changes\\n    /// @notice This is an extenstion function that does not exist in the Credit Facade\\n    ///         itself and can only be used within a multicall\\n    function revertIfReceivedLessThan(Balance[] memory expected) external;\\n\\n    /// @dev Enables token in enabledTokenMask for the Credit Account of msg.sender\\n    /// @param token Address of token to enable\\n    function enableToken(address token) external;\\n\\n    /// @dev Disables a token on the caller's Credit Account\\n    /// @param token Token to disable\\n    /// @notice This is an extenstion function that does not exist in the Credit Facade\\n    ///         itself and can only be used within a multicall\\n    function disableToken(address token) external;\\n\\n    /// @dev Adds collateral to borrower's credit account\\n    /// @param token Address of a collateral token\\n    /// @param amount Amount to add\\n    function addCollateral(address token, uint256 amount) external payable;\\n\\n    /// @dev Increases debt for msg.sender's Credit Account\\n    /// - Borrows the requested amount from the pool\\n    /// - Updates the CA's borrowAmount / cumulativeIndexOpen\\n    ///   to correctly compute interest going forward\\n    /// - Performs a full collateral check\\n    ///\\n    /// @param amount Amount to borrow\\n    function increaseDebt(uint256 amount) external;\\n\\n    /// @dev Decrease debt\\n    /// - Decreases the debt by paying the requested amount + accrued interest + fees back to the pool\\n    /// - It's also include to this payment interest accrued at the moment and fees\\n    /// - Updates cunulativeIndex to cumulativeIndex now\\n    ///\\n    /// @param amount Amount to increase borrowed amount\\n    function decreaseDebt(uint256 amount) external;\\n}\\n\\ninterface ICreditFacadeEvents {\\n    /// @dev Emits when Blacklist Helper is set for the Credit Facade upon creation\\n    event BlacklistHelperSet(address indexed blacklistHelper);\\n\\n    /// @dev Emits when a new Credit Account is opened through the\\n    ///      Credit Facade\\n    event OpenCreditAccount(\\n        address indexed onBehalfOf,\\n        address indexed creditAccount,\\n        uint256 borrowAmount,\\n        uint16 referralCode\\n    );\\n\\n    /// @dev Emits when the account owner closes their CA normally\\n    event CloseCreditAccount(address indexed borrower, address indexed to);\\n\\n    /// @dev Emits when a Credit Account is liquidated due to low health factor\\n    event LiquidateCreditAccount(\\n        address indexed borrower,\\n        address indexed liquidator,\\n        address indexed to,\\n        uint256 remainingFunds\\n    );\\n\\n    /// @dev Emits when a Credit Account is liquidated due to expiry\\n    event LiquidateExpiredCreditAccount(\\n        address indexed borrower,\\n        address indexed liquidator,\\n        address indexed to,\\n        uint256 remainingFunds\\n    );\\n\\n    /// @dev Emits when remaining funds in underlying currency are sent to\\n    ///      the blacklist helper upon blacklisted borrower liquidation\\n    event UnderlyingSentToBlacklistHelper(\\n        address indexed borrower,\\n        uint256 amount\\n    );\\n\\n    /// @dev Emits when the account owner increases CA's debt\\n    event IncreaseBorrowedAmount(address indexed borrower, uint256 amount);\\n\\n    /// @dev Emits when the account owner reduces CA's debt\\n    event DecreaseBorrowedAmount(address indexed borrower, uint256 amount);\\n\\n    /// @dev Emits when the account owner add new collateral to a CA\\n    event AddCollateral(\\n        address indexed onBehalfOf,\\n        address indexed token,\\n        uint256 value\\n    );\\n\\n    /// @dev Emits when a multicall is started\\n    event MultiCallStarted(address indexed borrower);\\n\\n    /// @dev Emits when a multicall is finished\\n    event MultiCallFinished();\\n\\n    /// @dev Emits when Credit Account ownership is transferred\\n    event TransferAccount(address indexed oldOwner, address indexed newOwner);\\n\\n    /// @dev Emits when the user changes approval for account transfers to itself from another address\\n    event TransferAccountAllowed(\\n        address indexed from,\\n        address indexed to,\\n        bool state\\n    );\\n\\n    /// @dev Emits when the account owner enables a token on their CA\\n    event TokenEnabled(address indexed borrower, address indexed token);\\n\\n    /// @dev Emits when the account owner disables a token on their CA\\n    event TokenDisabled(address indexed borrower, address indexed token);\\n\\n    /// @dev Emits when pool incurs loss on account liquidation and facade forbids borrowing\\n    event IncurLossOnLiquidation(uint256 loss);\\n}\\n\\ninterface ICreditFacadeExceptions is ICreditManagerV2Exceptions {\\n    /// @dev Thrown if the CreditFacade is not expirable, and an aciton is attempted that\\n    ///      requires expirability\\n    error NotAllowedWhenNotExpirableException();\\n\\n    /// @dev Thrown if whitelisted mode is enabled, and an action is attempted that is\\n    ///      not allowed in whitelisted mode\\n    error NotAllowedInWhitelistedMode();\\n\\n    /// @dev Thrown if a user attempts to transfer a CA to an address that didn't allow it\\n    error AccountTransferNotAllowedException();\\n\\n    /// @dev Thrown if a liquidator tries to liquidate an account with a health factor above 1\\n    error CantLiquidateWithSuchHealthFactorException();\\n\\n    /// @dev Thrown if a liquidator tries to liquidate an account by expiry while a Credit Facade is not expired\\n    error CantLiquidateNonExpiredException();\\n\\n    /// @dev Thrown if call data passed to a multicall is too short\\n    error IncorrectCallDataException();\\n\\n    /// @dev Thrown inside account closure multicall if the borrower attempts an action that is forbidden on closing\\n    ///      an account\\n    error ForbiddenDuringClosureException();\\n\\n    /// @dev Thrown if debt increase and decrease are subsequently attempted in one multicall\\n    error IncreaseAndDecreaseForbiddenInOneCallException();\\n\\n    /// @dev Thrown if a selector that doesn't match any allowed function is passed to the Credit Facade\\n    ///      during a multicall\\n    error UnknownMethodException();\\n\\n    /// @dev Thrown if a user tries to open an account or increase debt with increaseDebtForbidden mode on\\n    error IncreaseDebtForbiddenException();\\n\\n    /// @dev Thrown if the account owner tries to transfer an unhealthy account\\n    error CantTransferLiquidatableAccountException();\\n\\n    /// @dev Thrown if too much new debt was taken within a single block\\n    error BorrowedBlockLimitException();\\n\\n    /// @dev Thrown if the new debt principal for a CA falls outside of borrowing limits\\n    error BorrowAmountOutOfLimitsException();\\n\\n    /// @dev Thrown if one of the balances on a Credit Account is less than expected\\n    ///      at the end of a multicall, if revertIfReceivedLessThan was called\\n    error BalanceLessThanMinimumDesiredException(address);\\n\\n    /// @dev Thrown if a user attempts to open an account on a Credit Facade that has expired\\n    error OpenAccountNotAllowedAfterExpirationException();\\n\\n    /// @dev Thrown if expected balances are attempted to be set through revertIfReceivedLessThan twice\\n    error ExpectedBalancesAlreadySetException();\\n\\n    /// @dev Thrown if a Credit Account has enabled forbidden tokens and the owner attempts to perform an action\\n    ///      that is not allowed with any forbidden tokens enabled\\n    error ActionProhibitedWithForbiddenTokensException();\\n\\n    /// @dev Thrown when attempting to perform an action on behalf of a borrower\\n    ///      that is blacklisted in the underlying token\\n    error NotAllowedForBlacklistedAddressException();\\n\\n    /// @dev Thrown when the pool receives less funds than borrowAmountWithInterest on account closure\\n    error LiquiditySanityCheckException();\\n}\\n\\ninterface ICreditFacade is\\n    ICreditFacadeEvents,\\n    ICreditFacadeExceptions,\\n    IVersion\\n{\\n    //\\n    // CREDIT ACCOUNT MANAGEMENT\\n    //\\n\\n    /// @dev Opens credit account, borrows funds from the pool and pulls collateral\\n    /// without any additional action.\\n    /// @param amount The amount of collateral provided by the borrower\\n    /// @param onBehalfOf The address to open an account for. Transfers to it have to be allowed if\\n    /// msg.sender != obBehalfOf\\n    /// @param leverageFactor Percentage of the user's own funds to borrow. 100 is equal to 100% - borrows the same amount\\n    /// as the user's own collateral, equivalent to 2x leverage.\\n    /// @param referralCode Referral code that is used for potential rewards. 0 if no referral code provided.\\n    function openCreditAccount(\\n        uint256 amount,\\n        address onBehalfOf,\\n        uint16 leverageFactor,\\n        uint16 referralCode\\n    ) external payable;\\n\\n    /// @dev Opens a Credit Account and runs a batch of operations in a multicall\\n    /// @param borrowedAmount Debt size\\n    /// @param onBehalfOf The address to open an account for. Transfers to it have to be allowed if\\n    /// msg.sender != obBehalfOf\\n    /// @param calls The array of MultiCall structs encoding the required operations. Generally must have\\n    /// at least a call to addCollateral, as otherwise the health check at the end will fail.\\n    /// @param referralCode Referral code which is used for potential rewards. 0 if no referral code provided\\n    function openCreditAccountMulticall(\\n        uint256 borrowedAmount,\\n        address onBehalfOf,\\n        MultiCall[] calldata calls,\\n        uint16 referralCode\\n    ) external payable;\\n\\n    /// @dev Runs a batch of transactions within a multicall and closes the account\\n    /// - Wraps ETH to WETH and sends it msg.sender if value > 0\\n    /// - Executes the multicall - the main purpose of a multicall when closing is to convert all assets to underlying\\n    /// in order to pay the debt.\\n    /// - Closes credit account:\\n    ///    + Checks the underlying balance: if it is greater than the amount paid to the pool, transfers the underlying\\n    ///      from the Credit Account and proceeds. If not, tries to transfer the shortfall from msg.sender.\\n    ///    + Transfers all enabled assets with non-zero balances to the \\\"to\\\" address, unless they are marked\\n    ///      to be skipped in skipTokenMask\\n    /// - Emits a CloseCreditAccount event\\n    ///\\n    /// @param to Address to send funds to during account closing\\n    /// @param skipTokenMask Uint-encoded bit mask where 1's mark tokens that shouldn't be transferred\\n    /// @param calls The array of MultiCall structs encoding the operations to execute before closing the account.\\n    function closeCreditAccount(\\n        address to,\\n        uint256 skipTokenMask,\\n        MultiCall[] calldata calls\\n    ) external payable;\\n\\n    /// @dev A version of `closeCreditAccount` with `convertWETH` parameter that is ignored.\\n    ///      Used for backward compatibility.\\n    function closeCreditAccount(\\n        address to,\\n        uint256 skipTokenMask,\\n        bool convertWETH,\\n        MultiCall[] calldata calls\\n    ) external payable;\\n\\n    /// @dev Runs a batch of transactions within a multicall and liquidates the account\\n    /// - Computes the total value and checks that hf < 1. An account can't be liquidated when hf >= 1.\\n    ///   Total value has to be computed before the multicall, otherwise the liquidator would be able\\n    ///   to manipulate it.\\n    /// - Wraps ETH to WETH and sends it to msg.sender (liquidator) if value > 0\\n    /// - Executes the multicall - the main purpose of a multicall when liquidating is to convert all assets to underlying\\n    ///   in order to pay the debt.\\n    /// - Liquidate credit account:\\n    ///    + Computes the amount that needs to be paid to the pool. If totalValue * liquidationDiscount < borrow + interest + fees,\\n    ///      only totalValue * liquidationDiscount has to be paid. Since liquidationDiscount < 1, the liquidator can take\\n    ///      totalValue * (1 - liquidationDiscount) as premium. Also computes the remaining funds to be sent to borrower\\n    ///      as totalValue * liquidationDiscount - amountToPool.\\n    ///    + Checks the underlying balance: if it is greater than amountToPool + remainingFunds, transfers the underlying\\n    ///      from the Credit Account and proceeds. If not, tries to transfer the shortfall from the liquidator.\\n    ///    + Transfers all enabled assets with non-zero balances to the \\\"to\\\" address, unless they are marked\\n    ///      to be skipped in skipTokenMask. If the liquidator is confident that all assets were converted\\n    ///      during the multicall, they can set the mask to uint256.max - 1, to only transfer the underlying\\n    /// - Emits LiquidateCreditAccount event\\n    ///\\n    /// @param to Address to send funds to after liquidation\\n    /// @param skipTokenMask Uint-encoded bit mask where 1's mark tokens that shouldn't be transferred\\n    /// @param calls The array of MultiCall structs encoding the operations to execute before liquidating the account.\\n    function liquidateCreditAccount(\\n        address borrower,\\n        address to,\\n        uint256 skipTokenMask,\\n        MultiCall[] calldata calls\\n    ) external payable;\\n\\n    /// @dev A version of `liquidateCreditAccount` with `convertWETH` parameter that is ignored.\\n    ///      Used for backward compatibility.\\n    function liquidateCreditAccount(\\n        address borrower,\\n        address to,\\n        uint256 skipTokenMask,\\n        bool convertWETH,\\n        MultiCall[] calldata calls\\n    ) external payable;\\n\\n    /// @dev Runs a batch of transactions within a multicall and liquidates the account when\\n    /// this Credit Facade is expired\\n    /// The general flow of liquidation is nearly the same as normal liquidations, with two main differences:\\n    ///     - An account can be liquidated on an expired Credit Facade even with hf > 1. However,\\n    ///       no accounts can be liquidated through this function if the Credit Facade is not expired.\\n    ///     - Liquidation premiums and fees for liquidating expired accounts are reduced.\\n    /// It is still possible to normally liquidate an underwater Credit Account, even when the Credit Facade\\n    /// is expired.\\n    /// @param to Address to send funds to after liquidation\\n    /// @param skipTokenMask Uint-encoded bit mask where 1's mark tokens that shouldn't be transferred\\n    /// @param calls The array of MultiCall structs encoding the operations to execute before liquidating the account.\\n    /// @notice See more at https://dev.gearbox.fi/docs/documentation/credit/liquidation#liquidating-accounts-by-expiration\\n    function liquidateExpiredCreditAccount(\\n        address borrower,\\n        address to,\\n        uint256 skipTokenMask,\\n        MultiCall[] calldata calls\\n    ) external payable;\\n\\n    /// @dev A version of `liquidateExpiredCreditAccount` with `convertWETH` parameter that is ignored.\\n    ///      Used for backward compatibility.\\n    function liquidateExpiredCreditAccount(\\n        address borrower,\\n        address to,\\n        uint256 skipTokenMask,\\n        bool convertWETH,\\n        MultiCall[] calldata calls\\n    ) external payable;\\n\\n    /// @dev Adds collateral to borrower's credit account\\n    /// @param onBehalfOf Address of the borrower whose account is funded\\n    /// @param token Address of a collateral token\\n    /// @param amount Amount to add\\n    function addCollateral(\\n        address onBehalfOf,\\n        address token,\\n        uint256 amount\\n    ) external payable;\\n\\n    /// @dev Executes a batch of transactions within a Multicall, to manage an existing account\\n    ///  - Wraps ETH and sends it back to msg.sender, if value > 0\\n    ///  - Executes the Multicall\\n    ///  - Performs a fullCollateralCheck to verify that hf > 1 after all actions\\n    /// @param calls The array of MultiCall structs encoding the operations to execute.\\n    function multicall(MultiCall[] calldata calls) external payable;\\n\\n    /// @dev Returns true if the borrower has an open Credit Account\\n    /// @param borrower Borrower address\\n    function hasOpenedCreditAccount(address borrower)\\n        external\\n        view\\n        returns (bool);\\n\\n    /// @dev Approves account transfer from another user to msg.sender\\n    /// @param from Address for which account transfers are allowed/forbidden\\n    /// @param state True is transfer is allowed, false if forbidden\\n    function approveAccountTransfer(address from, bool state) external;\\n\\n    /// @dev Transfers credit account to another user\\n    /// By default, this action is forbidden, and the user has to approve transfers from sender to itself\\n    /// by calling approveAccountTransfer.\\n    /// This is done to prevent malicious actors from transferring compromised accounts to other users.\\n    /// @param to Address to transfer the account to\\n    function transferAccountOwnership(address to) external;\\n\\n    //\\n    // GETTERS\\n    //\\n\\n    /// @dev Calculates total value for provided Credit Account in underlying\\n    ///\\n    /// @param creditAccount Credit Account address\\n    /// @return total Total value in underlying\\n    /// @return twv Total weighted (discounted by liquidation thresholds) value in underlying\\n    function calcTotalValue(address creditAccount)\\n        external\\n        view\\n        returns (uint256 total, uint256 twv);\\n\\n    /**\\n     * @dev Calculates health factor for the credit account\\n     *\\n     *          sum(asset[i] * liquidation threshold[i])\\n     *   Hf = --------------------------------------------\\n     *         borrowed amount + interest accrued + fees\\n     *\\n     *\\n     * More info: https://dev.gearbox.fi/developers/credit/economy#health-factor\\n     *\\n     * @param creditAccount Credit account address\\n     * @return hf = Health factor in bp (see PERCENTAGE FACTOR in PercentageMath.sol)\\n     */\\n    function calcCreditAccountHealthFactor(address creditAccount)\\n        external\\n        view\\n        returns (uint256 hf);\\n\\n    /// @dev Returns true if token is a collateral token and is not forbidden,\\n    /// otherwise returns false\\n    /// @param token Token to check\\n    function isTokenAllowed(address token) external view returns (bool);\\n\\n    /// @dev Returns the CreditManager connected to this Credit Facade\\n    function creditManager() external view returns (ICreditManagerV2);\\n\\n    /// @dev Returns true if 'from' is allowed to transfer Credit Accounts to 'to'\\n    /// @param from Sender address to check allowance for\\n    /// @param to Receiver address to check allowance for\\n    function transfersAllowed(address from, address to)\\n        external\\n        view\\n        returns (bool);\\n\\n    /// @return maxBorrowedAmountPerBlock Maximal amount of new debt that can be taken per block\\n    /// @return isIncreaseDebtForbidden True if increasing debt is forbidden\\n    /// @return expirationDate Timestamp of the next expiration (for expirable Credit Facades only)\\n    /// @return emergencyLiquidationDiscount Premium for liquidations when the system is paused\\n    function params()\\n        external\\n        view\\n        returns (\\n            uint128 maxBorrowedAmountPerBlock,\\n            bool isIncreaseDebtForbidden,\\n            uint40 expirationDate,\\n            uint16 emergencyLiquidationDiscount\\n        );\\n\\n    /// @return minBorrowedAmount Minimal borrowed amount per credit account\\n    /// @return maxBorrowedAmount Maximal borrowed amount per credit account\\n    function limits()\\n        external\\n        view\\n        returns (uint128 minBorrowedAmount, uint128 maxBorrowedAmount);\\n\\n    function lossParams()\\n        external\\n        view\\n        returns (uint128 currentCumulativeLoss, uint128 maxCumulativeLoss);\\n\\n    function totalDebt()\\n        external\\n        view\\n        returns (uint128 currentTotalDebt, uint128 totalDebtLimit);\\n\\n    /// @dev Address of the DegenNFT that gatekeeps account openings in whitelisted mode\\n    function degenNFT() external view returns (address);\\n\\n    /// @dev Address of the underlying asset\\n    function underlying() external view returns (address);\\n\\n    /// @dev Address of the blacklist helper or address(0), if underlying is not blacklistable\\n    function blacklistHelper() external view returns (address);\\n\\n    /// @dev Whether the underlying of connected Credit Manager is blacklistable\\n    function isBlacklistableUnderlying() external view returns (bool);\\n}\\n\\ninterface ICreditFacadeV2 {\\n    /// @return maxBorrowedAmountPerBlock Maximal amount of new debt that can be taken per block\\n    /// @return isIncreaseDebtForbidden True if increasing debt is forbidden\\n    /// @return expirationDate Timestamp of the next expiration (for expirable Credit Facades only)\\n    function params()\\n        external\\n        view\\n        returns (\\n            uint128 maxBorrowedAmountPerBlock,\\n            bool isIncreaseDebtForbidden,\\n            uint40 expirationDate\\n        );\\n}\\n\"\r\n    },\r\n    \"@gearbox-protocol/core-v2/contracts/interfaces/ICreditManagerV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Gearbox Protocol. Generalized leverage for DeFi protocols\\n// (c) Gearbox Holdings, 2022\\npragma solidity ^0.8.10;\\n\\nimport { IPriceOracleV2 } from \\\"./IPriceOracle.sol\\\";\\nimport { IVersion } from \\\"./IVersion.sol\\\";\\n\\nenum ClosureAction {\\n    CLOSE_ACCOUNT,\\n    LIQUIDATE_ACCOUNT,\\n    LIQUIDATE_EXPIRED_ACCOUNT,\\n    LIQUIDATE_PAUSED\\n}\\n\\ninterface ICreditManagerV2Events {\\n    /// @dev Emits when a call to an external contract is made through the Credit Manager\\n    event ExecuteOrder(address indexed borrower, address indexed target);\\n\\n    /// @dev Emits when a configurator is upgraded\\n    event NewConfigurator(address indexed newConfigurator);\\n}\\n\\ninterface ICreditManagerV2Exceptions {\\n    /// @dev Thrown if an access-restricted function is called by an address that is not\\n    ///      the connected Credit Facade, or an allowed adapter\\n    error AdaptersOrCreditFacadeOnlyException();\\n\\n    /// @dev Thrown if an access-restricted function is called by an address that is not\\n    ///      the connected Credit Facade\\n    error CreditFacadeOnlyException();\\n\\n    /// @dev Thrown if an access-restricted function is called by an address that is not\\n    ///      the connected Credit Configurator\\n    error CreditConfiguratorOnlyException();\\n\\n    /// @dev Thrown on attempting to open a Credit Account for or transfer a Credit Account\\n    ///      to the zero address or an address that already owns a Credit Account\\n    error ZeroAddressOrUserAlreadyHasAccountException();\\n\\n    /// @dev Thrown on attempting to execute an order to an address that is not an allowed\\n    ///      target contract\\n    error TargetContractNotAllowedException();\\n\\n    /// @dev Thrown on failing a full collateral check after an operation\\n    error NotEnoughCollateralException();\\n\\n    /// @dev Thrown on attempting to receive a token that is not a collateral token\\n    ///      or was forbidden\\n    error TokenNotAllowedException();\\n\\n    /// @dev Thrown if an attempt to approve a collateral token to a target contract failed\\n    error AllowanceFailedException();\\n\\n    /// @dev Thrown on attempting to perform an action for an address that owns no Credit Account\\n    error HasNoOpenedAccountException();\\n\\n    /// @dev Thrown on attempting to add a token that is already in a collateral list\\n    error TokenAlreadyAddedException();\\n\\n    /// @dev Thrown on configurator attempting to add more than 256 collateral tokens\\n    error TooManyTokensException();\\n\\n    /// @dev Thrown if more than the maximal number of tokens were enabled on a Credit Account,\\n    ///      and there are not enough unused token to disable\\n    error TooManyEnabledTokensException();\\n\\n    /// @dev Thrown when a reentrancy into the contract is attempted\\n    error ReentrancyLockException();\\n}\\n\\n/// @notice All Credit Manager functions are access-restricted and can only be called\\n///         by the Credit Facade or allowed adapters. Users are not allowed to\\n///         interact with the Credit Manager directly\\ninterface ICreditManagerV2 is\\n    ICreditManagerV2Events,\\n    ICreditManagerV2Exceptions,\\n    IVersion\\n{\\n    //\\n    // CREDIT ACCOUNT MANAGEMENT\\n    //\\n\\n    ///  @dev Opens credit account and borrows funds from the pool.\\n    /// - Takes Credit Account from the factory;\\n    /// - Requests the pool to lend underlying to the Credit Account\\n    ///\\n    /// @param borrowedAmount Amount to be borrowed by the Credit Account\\n    /// @param onBehalfOf The owner of the newly opened Credit Account\\n    function openCreditAccount(uint256 borrowedAmount, address onBehalfOf)\\n        external\\n        returns (address);\\n\\n    ///  @dev Closes a Credit Account - covers both normal closure and liquidation\\n    /// - Checks whether the contract is paused, and, if so, if the payer is an emergency liquidator.\\n    ///   Only emergency liquidators are able to liquidate account while the CM is paused.\\n    ///   Emergency liquidations do not pay a liquidator premium or liquidation fees.\\n    /// - Calculates payments to various recipients on closure:\\n    ///    + Computes amountToPool, which is the amount to be sent back to the pool.\\n    ///      This includes the principal, interest and fees, but can't be more than\\n    ///      total position value\\n    ///    + Computes remainingFunds during liquidations - these are leftover funds\\n    ///      after paying the pool and the liquidator, and are sent to the borrower\\n    ///    + Computes protocol profit, which includes interest and liquidation fees\\n    ///    + Computes loss if the totalValue is less than borrow amount + interest\\n    /// - Checks the underlying token balance:\\n    ///    + if it is larger than amountToPool, then the pool is paid fully from funds on the Credit Account\\n    ///    + else tries to transfer the shortfall from the payer - either the borrower during closure, or liquidator during liquidation\\n    /// - Send assets to the \\\"to\\\" address, as long as they are not included into skipTokenMask\\n    /// - If convertWETH is true, the function converts WETH into ETH before sending\\n    /// - Returns the Credit Account back to factory\\n    ///\\n    /// @param borrower Borrower address\\n    /// @param closureActionType Whether the account is closed, liquidated or liquidated due to expiry\\n    /// @param totalValue Portfolio value for liqution, 0 for ordinary closure\\n    /// @param payer Address which would be charged if credit account has not enough funds to cover amountToPool\\n    /// @param to Address to which the leftover funds will be sent\\n    /// @param skipTokenMask Tokenmask contains 1 for tokens which needed to be skipped for sending\\n    /// @param convertWETH If true converts WETH to ETH\\n    function closeCreditAccount(\\n        address borrower,\\n        ClosureAction closureActionType,\\n        uint256 totalValue,\\n        address payer,\\n        address to,\\n        uint256 skipTokenMask,\\n        bool convertWETH\\n    ) external returns (uint256 remainingFunds);\\n\\n    /// @dev Manages debt size for borrower:\\n    ///\\n    /// - Increase debt:\\n    ///   + Increases debt by transferring funds from the pool to the credit account\\n    ///   + Updates the cumulative index to keep interest the same. Since interest\\n    ///     is always computed dynamically as borrowedAmount * (cumulativeIndexNew / cumulativeIndexOpen - 1),\\n    ///     cumulativeIndexOpen needs to be updated, as the borrow amount has changed\\n    ///\\n    /// - Decrease debt:\\n    ///   + Repays debt partially + all interest and fees accrued thus far\\n    ///   + Updates cunulativeIndex to cumulativeIndex now\\n    ///\\n    /// @param creditAccount Address of the Credit Account to change debt for\\n    /// @param amount Amount to increase / decrease the principal by\\n    /// @param increase True to increase principal, false to decrease\\n    /// @return newBorrowedAmount The new debt principal\\n    function manageDebt(\\n        address creditAccount,\\n        uint256 amount,\\n        bool increase\\n    ) external returns (uint256 newBorrowedAmount);\\n\\n    /// @dev Adds collateral to borrower's credit account\\n    /// @param payer Address of the account which will be charged to provide additional collateral\\n    /// @param creditAccount Address of the Credit Account\\n    /// @param token Collateral token to add\\n    /// @param amount Amount to add\\n    function addCollateral(\\n        address payer,\\n        address creditAccount,\\n        address token,\\n        uint256 amount\\n    ) external;\\n\\n    /// @dev Transfers Credit Account ownership to another address\\n    /// @param from Address of previous owner\\n    /// @param to Address of new owner\\n    function transferAccountOwnership(address from, address to) external;\\n\\n    /// @dev Requests the Credit Account to approve a collateral token to another contract.\\n    /// @param borrower Borrower's address\\n    /// @param targetContract Spender to change allowance for\\n    /// @param token Collateral token to approve\\n    /// @param amount New allowance amount\\n    function approveCreditAccount(\\n        address borrower,\\n        address targetContract,\\n        address token,\\n        uint256 amount\\n    ) external;\\n\\n    /// @dev Requests a Credit Account to make a low-level call with provided data\\n    /// This is the intended pathway for state-changing interactions with 3rd-party protocols\\n    /// @param borrower Borrower's address\\n    /// @param targetContract Contract to be called\\n    /// @param data Data to pass with the call\\n    function executeOrder(\\n        address borrower,\\n        address targetContract,\\n        bytes memory data\\n    ) external returns (bytes memory);\\n\\n    //\\n    // COLLATERAL VALIDITY AND ACCOUNT HEALTH CHECKS\\n    //\\n\\n    /// @dev Enables a token on a Credit Account, including it\\n    /// into account health and total value calculations\\n    /// @param creditAccount Address of a Credit Account to enable the token for\\n    /// @param token Address of the token to be enabled\\n    function checkAndEnableToken(address creditAccount, address token) external;\\n\\n    /// @dev Optimized health check for individual swap-like operations.\\n    /// @notice Fast health check assumes that only two tokens (input and output)\\n    ///         participate in the operation and computes a % change in weighted value between\\n    ///         inbound and outbound collateral. The cumulative negative change across several\\n    ///         swaps in sequence cannot be larger than feeLiquidation (a fee that the\\n    ///         protocol is ready to waive if needed). Since this records a % change\\n    ///         between just two tokens, the corresponding % change in TWV will always be smaller,\\n    ///         which makes this check safe.\\n    ///         More details at https://dev.gearbox.fi/docs/documentation/risk/fast-collateral-check#fast-check-protection\\n    /// @param creditAccount Address of the Credit Account\\n    /// @param tokenIn Address of the token spent by the swap\\n    /// @param tokenOut Address of the token received from the swap\\n    /// @param balanceInBefore Balance of tokenIn before the operation\\n    /// @param balanceOutBefore Balance of tokenOut before the operation\\n    function fastCollateralCheck(\\n        address creditAccount,\\n        address tokenIn,\\n        address tokenOut,\\n        uint256 balanceInBefore,\\n        uint256 balanceOutBefore\\n    ) external;\\n\\n    /// @dev Performs a full health check on an account, summing up\\n    /// value of all enabled collateral tokens\\n    /// @param creditAccount Address of the Credit Account to check\\n    function fullCollateralCheck(address creditAccount) external;\\n\\n    /// @dev Checks that the number of enabled tokens on a Credit Account\\n    ///      does not violate the maximal enabled token limit and tries\\n    ///      to disable unused tokens if it does\\n    /// @param creditAccount Account to check enabled tokens for\\n    function checkAndOptimizeEnabledTokens(address creditAccount) external;\\n\\n    /// @dev Disables a token on a credit account\\n    /// @notice Usually called by adapters to disable spent tokens during a multicall,\\n    ///         but can also be called separately from the Credit Facade to remove\\n    ///         unwanted tokens\\n    /// @return True if token mask was change otherwise False\\n    function disableToken(address creditAccount, address token)\\n        external\\n        returns (bool);\\n\\n    //\\n    // GETTERS\\n    //\\n\\n    /// @dev Returns the address of a borrower's Credit Account, or reverts if there is none.\\n    /// @param borrower Borrower's address\\n    function getCreditAccountOrRevert(address borrower)\\n        external\\n        view\\n        returns (address);\\n\\n    /// @dev Computes amounts that must be sent to various addresses before closing an account\\n    /// @param totalValue Credit Accounts total value in underlying\\n    /// @param closureActionType Type of account closure\\n    ///        * CLOSE_ACCOUNT: The account is healthy and is closed normally\\n    ///        * LIQUIDATE_ACCOUNT: The account is unhealthy and is being liquidated to avoid bad debt\\n    ///        * LIQUIDATE_EXPIRED_ACCOUNT: The account has expired and is being liquidated (lowered liquidation premium)\\n    ///        * LIQUIDATE_PAUSED: The account is liquidated while the system is paused due to emergency (no liquidation premium)\\n    /// @param borrowedAmount Credit Account's debt principal\\n    /// @param borrowedAmountWithInterest Credit Account's debt principal + interest\\n    /// @return amountToPool Amount of underlying to be sent to the pool\\n    /// @return remainingFunds Amount of underlying to be sent to the borrower (only applicable to liquidations)\\n    /// @return profit Protocol's profit from fees (if any)\\n    /// @return loss Protocol's loss from bad debt (if any)\\n    function calcClosePayments(\\n        uint256 totalValue,\\n        ClosureAction closureActionType,\\n        uint256 borrowedAmount,\\n        uint256 borrowedAmountWithInterest\\n    )\\n        external\\n        view\\n        returns (\\n            uint256 amountToPool,\\n            uint256 remainingFunds,\\n            uint256 profit,\\n            uint256 loss\\n        );\\n\\n    /// @dev Calculates the debt accrued by a Credit Account\\n    /// @param creditAccount Address of the Credit Account\\n    /// @return borrowedAmount The debt principal\\n    /// @return borrowedAmountWithInterest The debt principal + accrued interest\\n    /// @return borrowedAmountWithInterestAndFees The debt principal + accrued interest and protocol fees\\n    function calcCreditAccountAccruedInterest(address creditAccount)\\n        external\\n        view\\n        returns (\\n            uint256 borrowedAmount,\\n            uint256 borrowedAmountWithInterest,\\n            uint256 borrowedAmountWithInterestAndFees\\n        );\\n\\n    /// @dev Maps Credit Accounts to bit masks encoding their enabled token sets\\n    /// Only enabled tokens are counted as collateral for the Credit Account\\n    /// @notice An enabled token mask encodes an enabled token by setting\\n    ///         the bit at the position equal to token's index to 1\\n    function enabledTokensMap(address creditAccount)\\n        external\\n        view\\n        returns (uint256);\\n\\n    /// @dev Maps the Credit Account to its current percentage drop across all swaps since\\n    ///      the last full check, in RAY format\\n    function cumulativeDropAtFastCheckRAY(address creditAccount)\\n        external\\n        view\\n        returns (uint256);\\n\\n    /// @dev Returns the collateral token at requested index and its liquidation threshold\\n    /// @param id The index of token to return\\n    function collateralTokens(uint256 id)\\n        external\\n        view\\n        returns (address token, uint16 liquidationThreshold);\\n\\n    /// @dev Returns the collateral token with requested mask and its liquidationThreshold\\n    /// @param tokenMask Token mask corresponding to the token\\n    function collateralTokensByMask(uint256 tokenMask)\\n        external\\n        view\\n        returns (address token, uint16 liquidationThreshold);\\n\\n    /// @dev Total number of known collateral tokens.\\n    function collateralTokensCount() external view returns (uint256);\\n\\n    /// @dev Returns the mask for the provided token\\n    /// @param token Token to returns the mask for\\n    function tokenMasksMap(address token) external view returns (uint256);\\n\\n    /// @dev Bit mask encoding a set of forbidden tokens\\n    function forbiddenTokenMask() external view returns (uint256);\\n\\n    /// @dev Maps allowed adapters to their respective target contracts.\\n    function adapterToContract(address adapter) external view returns (address);\\n\\n    /// @dev Maps 3rd party contracts to their respective adapters\\n    function contractToAdapter(address targetContract)\\n        external\\n        view\\n        returns (address);\\n\\n    /// @dev Address of the underlying asset\\n    function underlying() external view returns (address);\\n\\n    /// @dev Address of the connected pool\\n    function pool() external view returns (address);\\n\\n    /// @dev Address of the connected pool\\n    /// @notice [DEPRECATED]: use pool() instead.\\n    function poolService() external view returns (address);\\n\\n    /// @dev A map from borrower addresses to Credit Account addresses\\n    function creditAccounts(address borrower) external view returns (address);\\n\\n    /// @dev Address of the connected Credit Configurator\\n    function creditConfigurator() external view returns (address);\\n\\n    /// @dev Address of WETH\\n    function wethAddress() external view returns (address);\\n\\n    /// @dev Returns the liquidation threshold for the provided token\\n    /// @param token Token to retrieve the LT for\\n    function liquidationThresholds(address token)\\n        external\\n        view\\n        returns (uint16);\\n\\n    /// @dev The maximal number of enabled tokens on a single Credit Account\\n    function maxAllowedEnabledTokenLength() external view returns (uint8);\\n\\n    /// @dev Maps addresses to their status as emergency liquidator.\\n    /// @notice Emergency liquidators are trusted addresses\\n    /// that are able to liquidate positions while the contracts are paused,\\n    /// e.g. when there is a risk of bad debt while an exploit is being patched.\\n    /// In the interest of fairness, emergency liquidators do not receive a premium\\n    /// And are compensated by the Gearbox DAO separately.\\n    function canLiquidateWhilePaused(address) external view returns (bool);\\n\\n    /// @dev Returns the fee parameters of the Credit Manager\\n    /// @return feeInterest Percentage of interest taken by the protocol as profit\\n    /// @return feeLiquidation Percentage of account value taken by the protocol as profit\\n    ///         during unhealthy account liquidations\\n    /// @return liquidationDiscount Multiplier that reduces the effective totalValue during unhealthy account liquidations,\\n    ///         allowing the liquidator to take the unaccounted for remainder as premium. Equal to (1 - liquidationPremium)\\n    /// @return feeLiquidationExpired Percentage of account value taken by the protocol as profit\\n    ///         during expired account liquidations\\n    /// @return liquidationDiscountExpired Multiplier that reduces the effective totalValue during expired account liquidations,\\n    ///         allowing the liquidator to take the unaccounted for remainder as premium. Equal to (1 - liquidationPremiumExpired)\\n    function fees()\\n        external\\n        view\\n        returns (\\n            uint16 feeInterest,\\n            uint16 feeLiquidation,\\n            uint16 liquidationDiscount,\\n            uint16 feeLiquidationExpired,\\n            uint16 liquidationDiscountExpired\\n        );\\n\\n    /// @dev Address of the connected Credit Facade\\n    function creditFacade() external view returns (address);\\n\\n    /// @dev Address of the connected Price Oracle\\n    function priceOracle() external view returns (IPriceOracleV2);\\n\\n    /// @dev Address of the universal adapter\\n    function universalAdapter() external view returns (address);\\n\\n    /// @dev Contract's version\\n    function version() external view returns (uint256);\\n\\n    /// @dev Paused() state\\n    function checkEmergencyPausable(address caller, bool state)\\n        external\\n        returns (bool);\\n}\\n\"\r\n    },\r\n    \"@gearbox-protocol/core-v2/contracts/interfaces/IDegenNFT.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Gearbox Protocol. Generalized leverage for DeFi protocols\\n// (c) Gearbox Holdings, 2022\\npragma solidity ^0.8.10;\\nimport { IVersion } from \\\"./IVersion.sol\\\";\\nimport { IERC721Metadata } from \\\"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\\\";\\n\\ninterface IDegenNFTExceptions {\\n    /// @dev Thrown if an access-restricted function was called by non-CreditFacade\\n    error CreditFacadeOrConfiguratorOnlyException();\\n\\n    /// @dev Thrown if an access-restricted function was called by non-minter\\n    error MinterOnlyException();\\n\\n    /// @dev Thrown if trying to add a burner address that is not a correct Credit Facade\\n    error InvalidCreditFacadeException();\\n\\n    /// @dev Thrown if the account's balance is not sufficient for an action (usually a burn)\\n    error InsufficientBalanceException();\\n}\\n\\ninterface IDegenNFTEvents {\\n    /// @dev Minted when new minter set\\n    event NewMinterSet(address indexed);\\n\\n    /// @dev Minted each time when new credit facade added\\n    event NewCreditFacadeAdded(address indexed);\\n\\n    /// @dev Minted each time when new credit facade added\\n    event NewCreditFacadeRemoved(address indexed);\\n}\\n\\ninterface IDegenNFT is\\n    IDegenNFTExceptions,\\n    IDegenNFTEvents,\\n    IVersion,\\n    IERC721Metadata\\n{\\n    /// @dev address of the current minter\\n    function minter() external view returns (address);\\n\\n    /// @dev Stores the total number of tokens on holder accounts\\n    function totalSupply() external view returns (uint256);\\n\\n    /// @dev Stores the base URI for NFT metadata\\n    function baseURI() external view returns (string memory);\\n\\n    /// @dev Mints a specified amount of tokens to the address\\n    /// @param to Address the tokens are minted to\\n    /// @param amount The number of tokens to mint\\n    function mint(address to, uint256 amount) external;\\n\\n    /// @dev Burns a number of tokens from a specified address\\n    /// @param from The address a token will be burnt from\\n    /// @param amount The number of tokens to burn\\n    function burn(address from, uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"@gearbox-protocol/core-v2/contracts/interfaces/IErrors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Gearbox Protocol. Generalized leverage for DeFi protocols\\n// (c) Gearbox Holdings, 2022\\npragma solidity ^0.8.10;\\n\\n/// @dev Common contract exceptions\\n\\n/// @dev Thrown on attempting to set an important address to zero address\\nerror ZeroAddressException();\\n\\n/// @dev Thrown on attempting to call a non-implemented function\\nerror NotImplementedException();\\n\\n/// @dev Thrown on attempting to set an EOA as an important contract in the system\\nerror AddressIsNotContractException(address);\\n\\n/// @dev Thrown on attempting to use a non-ERC20 contract or an EOA as a token\\nerror IncorrectTokenContractException();\\n\\n/// @dev Thrown on attempting to set a token price feed to an address that is not a\\n///      correct price feed\\nerror IncorrectPriceFeedException();\\n\\n/// @dev Thrown on attempting to call an access restricted function as a non-Configurator\\nerror CallerNotConfiguratorException();\\n\\n/// @dev Thrown on attempting to call an access restricted function as a non-Configurator\\nerror CallerNotControllerException();\\n\\n/// @dev Thrown on attempting to pause a contract as a non-Pausable admin\\nerror CallerNotPausableAdminException();\\n\\n/// @dev Thrown on attempting to pause a contract as a non-Unpausable admin\\nerror CallerNotUnPausableAdminException();\\n\"\r\n    },\r\n    \"@gearbox-protocol/core-v2/contracts/interfaces/IPausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Gearbox Protocol. Generalized leverage for DeFi protocols\\n// (c) Gearbox Holdings, 2022\\npragma solidity ^0.8.10;\\n\\ninterface IPausable {\\n    function pause() external;\\n}\\n\"\r\n    },\r\n    \"@gearbox-protocol/core-v2/contracts/interfaces/IPriceOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Gearbox Protocol. Generalized leverage for DeFi protocols\\n// (c) Gearbox Holdings, 2022\\npragma solidity ^0.8.10;\\nimport { IVersion } from \\\"./IVersion.sol\\\";\\n\\ninterface IPriceOracleV2Events {\\n    /// @dev Emits when a new price feed is added\\n    event NewPriceFeed(address indexed token, address indexed priceFeed);\\n}\\n\\ninterface IPriceOracleV2Exceptions {\\n    /// @dev Thrown if a price feed returns 0\\n    error ZeroPriceException();\\n\\n    /// @dev Thrown if the last recorded result was not updated in the last round\\n    error ChainPriceStaleException();\\n\\n    /// @dev Thrown on attempting to get a result for a token that does not have a price feed\\n    error PriceOracleNotExistsException();\\n}\\n\\n/// @title Price oracle interface\\ninterface IPriceOracleV2 is\\n    IPriceOracleV2Events,\\n    IPriceOracleV2Exceptions,\\n    IVersion\\n{\\n    /// @dev Converts a quantity of an asset to USD (decimals = 8).\\n    /// @param amount Amount to convert\\n    /// @param token Address of the token to be converted\\n    function convertToUSD(uint256 amount, address token)\\n        external\\n        view\\n        returns (uint256);\\n\\n    /// @dev Converts a quantity of USD (decimals = 8) to an equivalent amount of an asset\\n    /// @param amount Amount to convert\\n    /// @param token Address of the token converted to\\n    function convertFromUSD(uint256 amount, address token)\\n        external\\n        view\\n        returns (uint256);\\n\\n    /// @dev Converts one asset into another\\n    ///\\n    /// @param amount Amount to convert\\n    /// @param tokenFrom Address of the token to convert from\\n    /// @param tokenTo Address of the token to convert to\\n    function convert(\\n        uint256 amount,\\n        address tokenFrom,\\n        address tokenTo\\n    ) external view returns (uint256);\\n\\n    /// @dev Returns collateral values for two tokens, required for a fast check\\n    /// @param amountFrom Amount of the outbound token\\n    /// @param tokenFrom Address of the outbound token\\n    /// @param amountTo Amount of the inbound token\\n    /// @param tokenTo Address of the inbound token\\n    /// @return collateralFrom Value of the outbound token amount in USD\\n    /// @return collateralTo Value of the inbound token amount in USD\\n    function fastCheck(\\n        uint256 amountFrom,\\n        address tokenFrom,\\n        uint256 amountTo,\\n        address tokenTo\\n    ) external view returns (uint256 collateralFrom, uint256 collateralTo);\\n\\n    /// @dev Returns token's price in USD (8 decimals)\\n    /// @param token The token to compute the price for\\n    function getPrice(address token) external view returns (uint256);\\n\\n    /// @dev Returns the price feed address for the passed token\\n    /// @param token Token to get the price feed for\\n    function priceFeeds(address token)\\n        external\\n        view\\n        returns (address priceFeed);\\n\\n    /// @dev Returns the price feed for the passed token,\\n    ///      with additional parameters\\n    /// @param token Token to get the price feed for\\n    function priceFeedsWithFlags(address token)\\n        external\\n        view\\n        returns (\\n            address priceFeed,\\n            bool skipCheck,\\n            uint256 decimals\\n        );\\n}\\n\\ninterface IPriceOracleV2Ext is IPriceOracleV2 {\\n    /// @dev Sets a price feed if it doesn't exist, or updates an existing one\\n    /// @param token Address of the token to set the price feed for\\n    /// @param priceFeed Address of a USD price feed adhering to Chainlink's interface\\n    function addPriceFeed(address token, address priceFeed) external;\\n}\\n\"\r\n    },\r\n    \"@gearbox-protocol/core-v2/contracts/interfaces/IVersion.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Gearbox Protocol. Generalized leverage for DeFi protocols\\n// (c) Gearbox Holdings, 2022\\npragma solidity ^0.8.10;\\n\\n/// @title IVersion\\n/// @dev Declares a version function which returns the contract's version\\ninterface IVersion {\\n    /// @dev Returns contract version\\n    function version() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"@gearbox-protocol/core-v2/contracts/libraries/Balances.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Gearbox Protocol. Generalized leverage for DeFi protocols\\n// (c) Gearbox Holdings, 2022\\npragma solidity ^0.8.10;\\n\\nstruct Balance {\\n    address token;\\n    uint256 balance;\\n}\\n\\nlibrary BalanceOps {\\n    error UnknownToken(address);\\n\\n    function copyBalance(Balance memory b)\\n        internal\\n        pure\\n        returns (Balance memory)\\n    {\\n        return Balance({ token: b.token, balance: b.balance });\\n    }\\n\\n    function addBalance(\\n        Balance[] memory b,\\n        address token,\\n        uint256 amount\\n    ) internal pure {\\n        b[getIndex(b, token)].balance += amount;\\n    }\\n\\n    function subBalance(\\n        Balance[] memory b,\\n        address token,\\n        uint256 amount\\n    ) internal pure {\\n        b[getIndex(b, token)].balance -= amount;\\n    }\\n\\n    function getBalance(Balance[] memory b, address token)\\n        internal\\n        pure\\n        returns (uint256 amount)\\n    {\\n        return b[getIndex(b, token)].balance;\\n    }\\n\\n    function setBalance(\\n        Balance[] memory b,\\n        address token,\\n        uint256 amount\\n    ) internal pure {\\n        b[getIndex(b, token)].balance = amount;\\n    }\\n\\n    function getIndex(Balance[] memory b, address token)\\n        internal\\n        pure\\n        returns (uint256 index)\\n    {\\n        for (uint256 i; i < b.length; ) {\\n            if (b[i].token == token) {\\n                return i;\\n            }\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        revert UnknownToken(token);\\n    }\\n\\n    function copy(Balance[] memory b, uint256 len)\\n        internal\\n        pure\\n        returns (Balance[] memory res)\\n    {\\n        res = new Balance[](len);\\n        for (uint256 i; i < len; ) {\\n            res[i] = copyBalance(b[i]);\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    function clone(Balance[] memory b)\\n        internal\\n        pure\\n        returns (Balance[] memory)\\n    {\\n        return copy(b, b.length);\\n    }\\n\\n    function getModifiedAfterSwap(\\n        Balance[] memory b,\\n        address tokenFrom,\\n        uint256 amountFrom,\\n        address tokenTo,\\n        uint256 amountTo\\n    ) internal pure returns (Balance[] memory res) {\\n        res = copy(b, b.length);\\n        setBalance(res, tokenFrom, getBalance(b, tokenFrom) - amountFrom);\\n        setBalance(res, tokenTo, getBalance(b, tokenTo) + amountTo);\\n    }\\n}\\n\"\r\n    },\r\n    \"@gearbox-protocol/core-v2/contracts/libraries/Constants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Gearbox Protocol. Generalized leverage for DeFi protocols\\n// (c) Gearbox Holdings, 2022\\npragma solidity ^0.8.10;\\n\\n// Denominations\\n\\nuint256 constant WAD = 1e18;\\nuint256 constant RAY = 1e27;\\nuint16 constant PERCENTAGE_FACTOR = 1e4; //percentage plus two decimals\\n\\n// 25% of type(uint256).max\\nuint256 constant ALLOWANCE_THRESHOLD = type(uint96).max >> 3;\\n\\n// FEE = 50%\\nuint16 constant DEFAULT_FEE_INTEREST = 50_00; // 50%\\n\\n// LIQUIDATION_FEE 1.5%\\nuint16 constant DEFAULT_FEE_LIQUIDATION = 1_50; // 1.5%\\n\\n// LIQUIDATION PREMIUM 4%\\nuint16 constant DEFAULT_LIQUIDATION_PREMIUM = 4_00; // 4%\\n\\n// LIQUIDATION_FEE_EXPIRED 2%\\nuint16 constant DEFAULT_FEE_LIQUIDATION_EXPIRED = 1_00; // 2%\\n\\n// LIQUIDATION PREMIUM EXPIRED 2%\\nuint16 constant DEFAULT_LIQUIDATION_PREMIUM_EXPIRED = 2_00; // 2%\\n\\n// DEFAULT PROPORTION OF MAX BORROWED PER BLOCK TO MAX BORROWED PER ACCOUNT\\nuint16 constant DEFAULT_LIMIT_PER_BLOCK_MULTIPLIER = 2;\\n\\n// Seconds in a year\\nuint256 constant SECONDS_PER_YEAR = 365 days;\\nuint256 constant SECONDS_PER_ONE_AND_HALF_YEAR = (SECONDS_PER_YEAR * 3) / 2;\\n\\n// OPERATIONS\\n\\n// Leverage decimals - 100 is equal to 2x leverage (100% * collateral amount + 100% * borrowed amount)\\nuint8 constant LEVERAGE_DECIMALS = 100;\\n\\n// Maximum withdraw fee for pool in PERCENTAGE_FACTOR format\\nuint8 constant MAX_WITHDRAW_FEE = 100;\\n\\nuint256 constant EXACT_INPUT = 1;\\nuint256 constant EXACT_OUTPUT = 2;\\n\\naddress constant UNIVERSAL_CONTRACT = 0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC;\\n\"\r\n    },\r\n    \"@gearbox-protocol/core-v2/contracts/libraries/Errors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Gearbox Protocol. Generalized leverage for DeFi protocols\\n// (c) Gearbox Holdings, 2022\\npragma solidity ^0.8.10;\\n\\n/// @title Errors library\\nlibrary Errors {\\n    //\\n    // COMMON\\n    //\\n    string public constant ZERO_ADDRESS_IS_NOT_ALLOWED = \\\"Z0\\\";\\n    string public constant NOT_IMPLEMENTED = \\\"NI\\\";\\n    string public constant INCORRECT_PATH_LENGTH = \\\"PL\\\";\\n    string public constant INCORRECT_ARRAY_LENGTH = \\\"CR\\\";\\n    string public constant REGISTERED_CREDIT_ACCOUNT_MANAGERS_ONLY = \\\"CP\\\";\\n    string public constant REGISTERED_POOLS_ONLY = \\\"RP\\\";\\n    string public constant INCORRECT_PARAMETER = \\\"IP\\\";\\n\\n    //\\n    // MATH\\n    //\\n    string public constant MATH_MULTIPLICATION_OVERFLOW = \\\"M1\\\";\\n    string public constant MATH_ADDITION_OVERFLOW = \\\"M2\\\";\\n    string public constant MATH_DIVISION_BY_ZERO = \\\"M3\\\";\\n\\n    //\\n    // POOL\\n    //\\n    string public constant POOL_CONNECTED_CREDIT_MANAGERS_ONLY = \\\"PS0\\\";\\n    string public constant POOL_INCOMPATIBLE_CREDIT_ACCOUNT_MANAGER = \\\"PS1\\\";\\n    string public constant POOL_MORE_THAN_EXPECTED_LIQUIDITY_LIMIT = \\\"PS2\\\";\\n    string public constant POOL_INCORRECT_WITHDRAW_FEE = \\\"PS3\\\";\\n    string public constant POOL_CANT_ADD_CREDIT_MANAGER_TWICE = \\\"PS4\\\";\\n\\n    //\\n    // ACCOUNT FACTORY\\n    //\\n    string public constant AF_CANT_CLOSE_CREDIT_ACCOUNT_IN_THE_SAME_BLOCK =\\n        \\\"AF1\\\";\\n    string public constant AF_MINING_IS_FINISHED = \\\"AF2\\\";\\n    string public constant AF_CREDIT_ACCOUNT_NOT_IN_STOCK = \\\"AF3\\\";\\n    string public constant AF_EXTERNAL_ACCOUNTS_ARE_FORBIDDEN = \\\"AF4\\\";\\n\\n    //\\n    // ADDRESS PROVIDER\\n    //\\n    string public constant AS_ADDRESS_NOT_FOUND = \\\"AP1\\\";\\n\\n    //\\n    // CONTRACTS REGISTER\\n    //\\n    string public constant CR_POOL_ALREADY_ADDED = \\\"CR1\\\";\\n    string public constant CR_CREDIT_MANAGER_ALREADY_ADDED = \\\"CR2\\\";\\n\\n    //\\n    // CREDIT ACCOUNT\\n    //\\n    string public constant CA_CONNECTED_CREDIT_MANAGER_ONLY = \\\"CA1\\\";\\n    string public constant CA_FACTORY_ONLY = \\\"CA2\\\";\\n\\n    //\\n    // ACL\\n    //\\n    string public constant ACL_CALLER_NOT_PAUSABLE_ADMIN = \\\"ACL1\\\";\\n    string public constant ACL_CALLER_NOT_CONFIGURATOR = \\\"ACL2\\\";\\n\\n    //\\n    // WETH GATEWAY\\n    //\\n    string public constant WG_DESTINATION_IS_NOT_WETH_COMPATIBLE = \\\"WG1\\\";\\n    string public constant WG_RECEIVE_IS_NOT_ALLOWED = \\\"WG2\\\";\\n    string public constant WG_NOT_ENOUGH_FUNDS = \\\"WG3\\\";\\n\\n    //\\n    // TOKEN DISTRIBUTOR\\n    //\\n    string public constant TD_WALLET_IS_ALREADY_CONNECTED_TO_VC = \\\"TD1\\\";\\n    string public constant TD_INCORRECT_WEIGHTS = \\\"TD2\\\";\\n    string public constant TD_NON_ZERO_BALANCE_AFTER_DISTRIBUTION = \\\"TD3\\\";\\n    string public constant TD_CONTRIBUTOR_IS_NOT_REGISTERED = \\\"TD4\\\";\\n}\\n\"\r\n    },\r\n    \"@gearbox-protocol/core-v2/contracts/libraries/MultiCall.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.10;\\n\\nstruct MultiCall {\\n    address target;\\n    bytes callData;\\n}\\n\\nlibrary MultiCallOps {\\n    function copyMulticall(MultiCall memory call)\\n        internal\\n        pure\\n        returns (MultiCall memory)\\n    {\\n        return MultiCall({ target: call.target, callData: call.callData });\\n    }\\n\\n    function trim(MultiCall[] memory calls)\\n        internal\\n        pure\\n        returns (MultiCall[] memory trimmed)\\n    {\\n        uint256 len = calls.length;\\n\\n        if (len == 0) return calls;\\n\\n        uint256 foundLen;\\n        while (calls[foundLen].target != address(0)) {\\n            unchecked {\\n                ++foundLen;\\n                if (foundLen == len) return calls;\\n            }\\n        }\\n\\n        if (foundLen > 0) return copy(calls, foundLen);\\n    }\\n\\n    function copy(MultiCall[] memory calls, uint256 len)\\n        internal\\n        pure\\n        returns (MultiCall[] memory res)\\n    {\\n        res = new MultiCall[](len);\\n        for (uint256 i; i < len; ) {\\n            res[i] = copyMulticall(calls[i]);\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    function clone(MultiCall[] memory calls)\\n        internal\\n        pure\\n        returns (MultiCall[] memory res)\\n    {\\n        return copy(calls, calls.length);\\n    }\\n\\n    function append(MultiCall[] memory calls, MultiCall memory newCall)\\n        internal\\n        pure\\n        returns (MultiCall[] memory res)\\n    {\\n        uint256 len = calls.length;\\n        res = new MultiCall[](len + 1);\\n        for (uint256 i; i < len; ) {\\n            res[i] = copyMulticall(calls[i]);\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        res[len] = copyMulticall(newCall);\\n    }\\n\\n    function prepend(MultiCall[] memory calls, MultiCall memory newCall)\\n        internal\\n        pure\\n        returns (MultiCall[] memory res)\\n    {\\n        uint256 len = calls.length;\\n        res = new MultiCall[](len + 1);\\n        res[0] = copyMulticall(newCall);\\n\\n        for (uint256 i = 1; i < len + 1; ) {\\n            res[i] = copyMulticall(calls[i]);\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    function concat(MultiCall[] memory calls1, MultiCall[] memory calls2)\\n        internal\\n        pure\\n        returns (MultiCall[] memory res)\\n    {\\n        uint256 len1 = calls1.length;\\n        uint256 lenTotal = len1 + calls2.length;\\n\\n        if (lenTotal == calls1.length) return clone(calls1);\\n        if (lenTotal == calls2.length) return clone(calls2);\\n\\n        res = new MultiCall[](lenTotal);\\n\\n        for (uint256 i; i < lenTotal; ) {\\n            res[i] = (i < len1)\\n                ? copyMulticall(calls1[i])\\n                : copyMulticall(calls2[i - len1]);\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@gearbox-protocol/core-v2/contracts/libraries/PercentageMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity ^0.8.10;\\n\\nimport { Errors } from \\\"./Errors.sol\\\";\\nimport { PERCENTAGE_FACTOR } from \\\"./Constants.sol\\\";\\n\\nuint256 constant HALF_PERCENT = PERCENTAGE_FACTOR / 2;\\n\\n/**\\n * @title PercentageMath library\\n * @author Aave\\n * @notice Provides functions to perform percentage calculations\\n * @dev Percentages are defined by default with 2 decimals of precision (100.00). The precision is indicated by PERCENTAGE_FACTOR\\n * @dev Operations are rounded half up\\n **/\\n\\nlibrary PercentageMath {\\n    /**\\n     * @dev Executes a percentage multiplication\\n     * @param value The value of which the percentage needs to be calculated\\n     * @param percentage The percentage of the value to be calculated\\n     * @return The percentage of value\\n     **/\\n    function percentMul(uint256 value, uint256 percentage)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        if (value == 0 || percentage == 0) {\\n            return 0; // T:[PM-1]\\n        }\\n\\n        //        require(\\n        //            value <= (type(uint256).max - HALF_PERCENT) / percentage,\\n        //            Errors.MATH_MULTIPLICATION_OVERFLOW\\n        //        ); // T:[PM-1]\\n\\n        return (value * percentage + HALF_PERCENT) / PERCENTAGE_FACTOR; // T:[PM-1]\\n    }\\n\\n    /**\\n     * @dev Executes a percentage division\\n     * @param value The value of which the percentage needs to be calculated\\n     * @param percentage The percentage of the value to be calculated\\n     * @return The value divided the percentage\\n     **/\\n    function percentDiv(uint256 value, uint256 percentage)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        require(percentage != 0, Errors.MATH_DIVISION_BY_ZERO); // T:[PM-2]\\n        uint256 halfPercentage = percentage / 2; // T:[PM-2]\\n\\n        //        require(\\n        //            value <= (type(uint256).max - halfPercentage) / PERCENTAGE_FACTOR,\\n        //            Errors.MATH_MULTIPLICATION_OVERFLOW\\n        //        ); // T:[PM-2]\\n\\n        return (value * PERCENTAGE_FACTOR + halfPercentage) / percentage;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Metadata is IERC721 {\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SafeCast.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SafeCast.sol)\\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n *\\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\\n * all math on `uint256` and `int256` and then downcasting.\\n */\\nlibrary SafeCast {\\n    /**\\n     * @dev Returns the downcasted uint248 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint248).\\n     *\\n     * Counterpart to Solidity's `uint248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint248(uint256 value) internal pure returns (uint248) {\\n        require(value <= type(uint248).max, \\\"SafeCast: value doesn't fit in 248 bits\\\");\\n        return uint248(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint240 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint240).\\n     *\\n     * Counterpart to Solidity's `uint240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint240(uint256 value) internal pure returns (uint240) {\\n        require(value <= type(uint240).max, \\\"SafeCast: value doesn't fit in 240 bits\\\");\\n        return uint240(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint232 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint232).\\n     *\\n     * Counterpart to Solidity's `uint232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint232(uint256 value) internal pure returns (uint232) {\\n        require(value <= type(uint232).max, \\\"SafeCast: value doesn't fit in 232 bits\\\");\\n        return uint232(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint224 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint224).\\n     *\\n     * Counterpart to Solidity's `uint224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     *\\n     * _Available since v4.2._\\n     */\\n    function toUint224(uint256 value) internal pure returns (uint224) {\\n        require(value <= type(uint224).max, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n        return uint224(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint216 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint216).\\n     *\\n     * Counterpart to Solidity's `uint216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint216(uint256 value) internal pure returns (uint216) {\\n        require(value <= type(uint216).max, \\\"SafeCast: value doesn't fit in 216 bits\\\");\\n        return uint216(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint208 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint208).\\n     *\\n     * Counterpart to Solidity's `uint208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint208(uint256 value) internal pure returns (uint208) {\\n        require(value <= type(uint208).max, \\\"SafeCast: value doesn't fit in 208 bits\\\");\\n        return uint208(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint200 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint200).\\n     *\\n     * Counterpart to Solidity's `uint200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint200(uint256 value) internal pure returns (uint200) {\\n        require(value <= type(uint200).max, \\\"SafeCast: value doesn't fit in 200 bits\\\");\\n        return uint200(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint192 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint192).\\n     *\\n     * Counterpart to Solidity's `uint192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint192(uint256 value) internal pure returns (uint192) {\\n        require(value <= type(uint192).max, \\\"SafeCast: value doesn't fit in 192 bits\\\");\\n        return uint192(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint184 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint184).\\n     *\\n     * Counterpart to Solidity's `uint184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint184(uint256 value) internal pure returns (uint184) {\\n        require(value <= type(uint184).max, \\\"SafeCast: value doesn't fit in 184 bits\\\");\\n        return uint184(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint176 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint176).\\n     *\\n     * Counterpart to Solidity's `uint176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint176(uint256 value) internal pure returns (uint176) {\\n        require(value <= type(uint176).max, \\\"SafeCast: value doesn't fit in 176 bits\\\");\\n        return uint176(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint168 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint168).\\n     *\\n     * Counterpart to Solidity's `uint168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint168(uint256 value) internal pure returns (uint168) {\\n        require(value <= type(uint168).max, \\\"SafeCast: value doesn't fit in 168 bits\\\");\\n        return uint168(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint160 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint160).\\n     *\\n     * Counterpart to Solidity's `uint160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint160(uint256 value) internal pure returns (uint160) {\\n        require(value <= type(uint160).max, \\\"SafeCast: value doesn't fit in 160 bits\\\");\\n        return uint160(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint152 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint152).\\n     *\\n     * Counterpart to Solidity's `uint152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint152(uint256 value) internal pure returns (uint152) {\\n        require(value <= type(uint152).max, \\\"SafeCast: value doesn't fit in 152 bits\\\");\\n        return uint152(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint144 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint144).\\n     *\\n     * Counterpart to Solidity's `uint144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint144(uint256 value) internal pure returns (uint144) {\\n        require(value <= type(uint144).max, \\\"SafeCast: value doesn't fit in 144 bits\\\");\\n        return uint144(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint136 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint136).\\n     *\\n     * Counterpart to Solidity's `uint136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint136(uint256 value) internal pure returns (uint136) {\\n        require(value <= type(uint136).max, \\\"SafeCast: value doesn't fit in 136 bits\\\");\\n        return uint136(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity's `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        require(value <= type(uint128).max, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n        return uint128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint120 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint120).\\n     *\\n     * Counterpart to Solidity's `uint120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint120(uint256 value) internal pure returns (uint120) {\\n        require(value <= type(uint120).max, \\\"SafeCast: value doesn't fit in 120 bits\\\");\\n        return uint120(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint112 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint112).\\n     *\\n     * Counterpart to Solidity's `uint112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint112(uint256 value) internal pure returns (uint112) {\\n        require(value <= type(uint112).max, \\\"SafeCast: value doesn't fit in 112 bits\\\");\\n        return uint112(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint104 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint104).\\n     *\\n     * Counterpart to Solidity's `uint104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint104(uint256 value) internal pure returns (uint104) {\\n        require(value <= type(uint104).max, \\\"SafeCast: value doesn't fit in 104 bits\\\");\\n        return uint104(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint96 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint96).\\n     *\\n     * Counterpart to Solidity's `uint96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     *\\n     * _Available since v4.2._\\n     */\\n    function toUint96(uint256 value) internal pure returns (uint96) {\\n        require(value <= type(uint96).max, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n        return uint96(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint88 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint88).\\n     *\\n     * Counterpart to Solidity's `uint88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint88(uint256 value) internal pure returns (uint88) {\\n        require(value <= type(uint88).max, \\\"SafeCast: value doesn't fit in 88 bits\\\");\\n        return uint88(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint80 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint80).\\n     *\\n     * Counterpart to Solidity's `uint80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint80(uint256 value) internal pure returns (uint80) {\\n        require(value <= type(uint80).max, \\\"SafeCast: value doesn't fit in 80 bits\\\");\\n        return uint80(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint72 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint72).\\n     *\\n     * Counterpart to Solidity's `uint72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint72(uint256 value) internal pure returns (uint72) {\\n        require(value <= type(uint72).max, \\\"SafeCast: value doesn't fit in 72 bits\\\");\\n        return uint72(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint64).\\n     *\\n     * Counterpart to Solidity's `uint64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        require(value <= type(uint64).max, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n        return uint64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint56 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint56).\\n     *\\n     * Counterpart to Solidity's `uint56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint56(uint256 value) internal pure returns (uint56) {\\n        require(value <= type(uint56).max, \\\"SafeCast: value doesn't fit in 56 bits\\\");\\n        return uint56(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint48 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint48).\\n     *\\n     * Counterpart to Solidity's `uint48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint48(uint256 value) internal pure returns (uint48) {\\n        require(value <= type(uint48).max, \\\"SafeCast: value doesn't fit in 48 bits\\\");\\n        return uint48(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint40 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint40).\\n     *\\n     * Counterpart to Solidity's `uint40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint40(uint256 value) internal pure returns (uint40) {\\n        require(value <= type(uint40).max, \\\"SafeCast: value doesn't fit in 40 bits\\\");\\n        return uint40(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint32).\\n     *\\n     * Counterpart to Solidity's `uint32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\n        require(value <= type(uint32).max, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n        return uint32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint24 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint24).\\n     *\\n     * Counterpart to Solidity's `uint24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint24(uint256 value) internal pure returns (uint24) {\\n        require(value <= type(uint24).max, \\\"SafeCast: value doesn't fit in 24 bits\\\");\\n        return uint24(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint16).\\n     *\\n     * Counterpart to Solidity's `uint16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\n        require(value <= type(uint16).max, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n        return uint16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint8).\\n     *\\n     * Counterpart to Solidity's `uint8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\n        require(value <= type(uint8).max, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n        return uint8(value);\\n    }\\n\\n    /**\\n     * @dev Converts a signed int256 into an unsigned uint256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be greater than or equal to 0.\\n     *\\n     * _Available since v3.0._\\n     */\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        require(value >= 0, \\\"SafeCast: value must be positive\\\");\\n        return uint256(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int248 from int256, reverting on\\n     * overflow (when the input is less than smallest int248 or\\n     * greater than largest int248).\\n     *\\n     * Counterpart to Solidity's `int248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\\n        downcasted = int248(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 248 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int240 from int256, reverting on\\n     * overflow (when the input is less than smallest int240 or\\n     * greater than largest int240).\\n     *\\n     * Counterpart to Solidity's `int240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\\n        downcasted = int240(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 240 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int232 from int256, reverting on\\n     * overflow (when the input is less than smallest int232 or\\n     * greater than largest int232).\\n     *\\n     * Counterpart to Solidity's `int232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\\n        downcasted = int232(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 232 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int224 from int256, reverting on\\n     * overflow (when the input is less than smallest int224 or\\n     * greater than largest int224).\\n     *\\n     * Counterpart to Solidity's `int224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\\n        downcasted = int224(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int216 from int256, reverting on\\n     * overflow (when the input is less than smallest int216 or\\n     * greater than largest int216).\\n     *\\n     * Counterpart to Solidity's `int216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\\n        downcasted = int216(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 216 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int208 from int256, reverting on\\n     * overflow (when the input is less than smallest int208 or\\n     * greater than largest int208).\\n     *\\n     * Counterpart to Solidity's `int208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\\n        downcasted = int208(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 208 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int200 from int256, reverting on\\n     * overflow (when the input is less than smallest int200 or\\n     * greater than largest int200).\\n     *\\n     * Counterpart to Solidity's `int200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\\n        downcasted = int200(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 200 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int192 from int256, reverting on\\n     * overflow (when the input is less than smallest int192 or\\n     * greater than largest int192).\\n     *\\n     * Counterpart to Solidity's `int192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\\n        downcasted = int192(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 192 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int184 from int256, reverting on\\n     * overflow (when the input is less than smallest int184 or\\n     * greater than largest int184).\\n     *\\n     * Counterpart to Solidity's `int184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\\n        downcasted = int184(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 184 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int176 from int256, reverting on\\n     * overflow (when the input is less than smallest int176 or\\n     * greater than largest int176).\\n     *\\n     * Counterpart to Solidity's `int176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\\n        downcasted = int176(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 176 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int168 from int256, reverting on\\n     * overflow (when the input is less than smallest int168 or\\n     * greater than largest int168).\\n     *\\n     * Counterpart to Solidity's `int168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\\n        downcasted = int168(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 168 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int160 from int256, reverting on\\n     * overflow (when the input is less than smallest int160 or\\n     * greater than largest int160).\\n     *\\n     * Counterpart to Solidity's `int160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\\n        downcasted = int160(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 160 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int152 from int256, reverting on\\n     * overflow (when the input is less than smallest int152 or\\n     * greater than largest int152).\\n     *\\n     * Counterpart to Solidity's `int152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\\n        downcasted = int152(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 152 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int144 from int256, reverting on\\n     * overflow (when the input is less than smallest int144 or\\n     * greater than largest int144).\\n     *\\n     * Counterpart to Solidity's `int144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\\n        downcasted = int144(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 144 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int136 from int256, reverting on\\n     * overflow (when the input is less than smallest int136 or\\n     * greater than largest int136).\\n     *\\n     * Counterpart to Solidity's `int136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\\n        downcasted = int136(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 136 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int128 from int256, reverting on\\n     * overflow (when the input is less than smallest int128 or\\n     * greater than largest int128).\\n     *\\n     * Counterpart to Solidity's `int128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\\n        downcasted = int128(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int120 from int256, reverting on\\n     * overflow (when the input is less than smallest int120 or\\n     * greater than largest int120).\\n     *\\n     * Counterpart to Solidity's `int120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\\n        downcasted = int120(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 120 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int112 from int256, reverting on\\n     * overflow (when the input is less than smallest int112 or\\n     * greater than largest int112).\\n     *\\n     * Counterpart to Solidity's `int112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\\n        downcasted = int112(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 112 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int104 from int256, reverting on\\n     * overflow (when the input is less than smallest int104 or\\n     * greater than largest int104).\\n     *\\n     * Counterpart to Solidity's `int104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\\n        downcasted = int104(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 104 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int96 from int256, reverting on\\n     * overflow (when the input is less than smallest int96 or\\n     * greater than largest int96).\\n     *\\n     * Counterpart to Solidity's `int96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\\n        downcasted = int96(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int88 from int256, reverting on\\n     * overflow (when the input is less than smallest int88 or\\n     * greater than largest int88).\\n     *\\n     * Counterpart to Solidity's `int88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\\n        downcasted = int88(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 88 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int80 from int256, reverting on\\n     * overflow (when the input is less than smallest int80 or\\n     * greater than largest int80).\\n     *\\n     * Counterpart to Solidity's `int80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\\n        downcasted = int80(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 80 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int72 from int256, reverting on\\n     * overflow (when the input is less than smallest int72 or\\n     * greater than largest int72).\\n     *\\n     * Counterpart to Solidity's `int72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\\n        downcasted = int72(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 72 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int64 from int256, reverting on\\n     * overflow (when the input is less than smallest int64 or\\n     * greater than largest int64).\\n     *\\n     * Counterpart to Solidity's `int64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\\n        downcasted = int64(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int56 from int256, reverting on\\n     * overflow (when the input is less than smallest int56 or\\n     * greater than largest int56).\\n     *\\n     * Counterpart to Solidity's `int56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\\n        downcasted = int56(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 56 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int48 from int256, reverting on\\n     * overflow (when the input is less than smallest int48 or\\n     * greater than largest int48).\\n     *\\n     * Counterpart to Solidity's `int48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\\n        downcasted = int48(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 48 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int40 from int256, reverting on\\n     * overflow (when the input is less than smallest int40 or\\n     * greater than largest int40).\\n     *\\n     * Counterpart to Solidity's `int40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\\n        downcasted = int40(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 40 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int32 from int256, reverting on\\n     * overflow (when the input is less than smallest int32 or\\n     * greater than largest int32).\\n     *\\n     * Counterpart to Solidity's `int32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\\n        downcasted = int32(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int24 from int256, reverting on\\n     * overflow (when the input is less than smallest int24 or\\n     * greater than largest int24).\\n     *\\n     * Counterpart to Solidity's `int24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\\n        downcasted = int24(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 24 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int16 from int256, reverting on\\n     * overflow (when the input is less than smallest int16 or\\n     * greater than largest int16).\\n     *\\n     * Counterpart to Solidity's `int16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\\n        downcasted = int16(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int8 from int256, reverting on\\n     * overflow (when the input is less than smallest int8 or\\n     * greater than largest int8).\\n     *\\n     * Counterpart to Solidity's `int8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\\n        downcasted = int8(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Converts an unsigned uint256 into a signed int256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be less than or equal to maxInt256.\\n     *\\n     * _Available since v3.0._\\n     */\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\\n        require(value <= uint256(type(int256).max), \\\"SafeCast: value doesn't fit in an int256\\\");\\n        return int256(value);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/structs/EnumerableSet.sol)\\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n *\\n * [WARNING]\\n * ====\\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\\n * unusable.\\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\\n *\\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\\n * array of EnumerableSet.\\n * ====\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping(bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) {\\n            // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            if (lastIndex != toDeleteIndex) {\\n                bytes32 lastValue = set._values[lastIndex];\\n\\n                // Move the last value to the index where the value to delete is\\n                set._values[toDeleteIndex] = lastValue;\\n                // Update the index for the moved value\\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\\n            }\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        return set._values[index];\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function _values(Set storage set) private view returns (bytes32[] memory) {\\n        return set._values;\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        bytes32[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(AddressSet storage set) internal view returns (address[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        address[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        uint256[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 2000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_creditManager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_degenNFT\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_blacklistHelper\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_expirable\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AccountTransferNotAllowedException\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ActionProhibitedWithForbiddenTokensException\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AdaptersOrCreditFacadeOnlyException\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AllowanceFailedException\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"BalanceLessThanMinimumDesiredException\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BorrowAmountOutOfLimitsException\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BorrowedBlockLimitException\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CantLiquidateNonExpiredException\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CantLiquidateWithSuchHealthFactorException\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CantTransferLiquidatableAccountException\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CreditConfiguratorOnlyException\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CreditFacadeOnlyException\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ExpectedBalancesAlreadySetException\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ForbiddenDuringClosureException\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"HasNoOpenedAccountException\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"IncorrectCallDataException\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"IncreaseAndDecreaseForbiddenInOneCallException\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"IncreaseDebtForbiddenException\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LiquiditySanityCheckException\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotAllowedForBlacklistedAddressException\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotAllowedInWhitelistedMode\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotAllowedWhenNotExpirableException\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotEnoughCollateralException\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OpenAccountNotAllowedAfterExpirationException\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ReentrancyLockException\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TargetContractNotAllowedException\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TokenAlreadyAddedException\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TokenNotAllowedException\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TooManyEnabledTokensException\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TooManyTokensException\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnknownMethodException\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroAddressException\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroAddressOrUserAlreadyHasAccountException\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"onBehalfOf\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"AddCollateral\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"blacklistHelper\",\"type\":\"address\"}],\"name\":\"BlacklistHelperSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"CloseCreditAccount\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DecreaseBorrowedAmount\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"IncreaseBorrowedAmount\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"loss\",\"type\":\"uint256\"}],\"name\":\"IncurLossOnLiquidation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"liquidator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"remainingFunds\",\"type\":\"uint256\"}],\"name\":\"LiquidateCreditAccount\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"liquidator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"remainingFunds\",\"type\":\"uint256\"}],\"name\":\"LiquidateExpiredCreditAccount\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"MultiCallFinished\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"}],\"name\":\"MultiCallStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"onBehalfOf\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"creditAccount\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"borrowAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"referralCode\",\"type\":\"uint16\"}],\"name\":\"OpenCreditAccount\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"TokenDisabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"TokenEnabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"TransferAccount\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"TransferAccountAllowed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"UnderlyingSentToBlacklistHelper\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"onBehalfOf\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"addCollateral\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"approveAccountTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"blacklistHelper\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"creditAccount\",\"type\":\"address\"}],\"name\":\"calcCreditAccountHealthFactor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"hf\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"creditAccount\",\"type\":\"address\"}],\"name\":\"calcTotalValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"twv\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"skipTokenMask\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"}],\"internalType\":\"struct MultiCall[]\",\"name\":\"calls\",\"type\":\"tuple[]\"}],\"name\":\"closeCreditAccount\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"skipTokenMask\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"}],\"internalType\":\"struct MultiCall[]\",\"name\":\"calls\",\"type\":\"tuple[]\"}],\"name\":\"closeCreditAccount\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"creditManager\",\"outputs\":[{\"internalType\":\"contract ICreditManagerV2\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"degenNFT\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"expirable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalBorrowedInBlock\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"blockLastUpdate\",\"type\":\"uint64\"},{\"internalType\":\"uint128\",\"name\":\"borrowedInBlock\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"}],\"name\":\"hasOpenedCreditAccount\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isBlacklistableUnderlying\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"isTokenAllowed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"allowed\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"limits\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"minBorrowedAmount\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"maxBorrowedAmount\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"skipTokenMask\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"}],\"internalType\":\"struct MultiCall[]\",\"name\":\"calls\",\"type\":\"tuple[]\"}],\"name\":\"liquidateCreditAccount\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"skipTokenMask\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"}],\"internalType\":\"struct MultiCall[]\",\"name\":\"calls\",\"type\":\"tuple[]\"}],\"name\":\"liquidateCreditAccount\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"skipTokenMask\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"}],\"internalType\":\"struct MultiCall[]\",\"name\":\"calls\",\"type\":\"tuple[]\"}],\"name\":\"liquidateExpiredCreditAccount\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"skipTokenMask\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"}],\"internalType\":\"struct MultiCall[]\",\"name\":\"calls\",\"type\":\"tuple[]\"}],\"name\":\"liquidateExpiredCreditAccount\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lossParams\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"currentCumulativeLoss\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"maxCumulativeLoss\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"}],\"internalType\":\"struct MultiCall[]\",\"name\":\"calls\",\"type\":\"tuple[]\"}],\"name\":\"multicall\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"onBehalfOf\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"leverageFactor\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"referralCode\",\"type\":\"uint16\"}],\"name\":\"openCreditAccount\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"borrowedAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"onBehalfOf\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"}],\"internalType\":\"struct MultiCall[]\",\"name\":\"calls\",\"type\":\"tuple[]\"},{\"internalType\":\"uint16\",\"name\":\"referralCode\",\"type\":\"uint16\"}],\"name\":\"openCreditAccountMulticall\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"params\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"maxBorrowedAmountPerBlock\",\"type\":\"uint128\"},{\"internalType\":\"bool\",\"name\":\"isIncreaseDebtForbidden\",\"type\":\"bool\"},{\"internalType\":\"uint40\",\"name\":\"expirationDate\",\"type\":\"uint40\"},{\"internalType\":\"uint16\",\"name\":\"emergencyLiquidationDiscount\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"resetCumulativeLoss\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"_minBorrowedAmount\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"_maxBorrowedAmount\",\"type\":\"uint128\"}],\"name\":\"setCreditAccountLimits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"newDiscount\",\"type\":\"uint16\"}],\"name\":\"setEmergencyLiquidationDiscount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint40\",\"name\":\"newExpirationDate\",\"type\":\"uint40\"}],\"name\":\"setExpirationDate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_mode\",\"type\":\"bool\"}],\"name\":\"setIncreaseDebtForbidden\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"newLimit\",\"type\":\"uint128\"}],\"name\":\"setLimitPerBlock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"_maxCumulativeLoss\",\"type\":\"uint128\"}],\"name\":\"setMaxCumulativeLoss\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"newCurrentTotalDebt\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"newLimit\",\"type\":\"uint128\"}],\"name\":\"setTotalDebtParams\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalDebt\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"currentTotalDebt\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"totalDebtLimit\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"transferAccountOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"transfersAllowed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"underlying\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wethAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"whitelisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "CreditFacade", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "2000", "ConstructorArguments": "000000000000000000000000672461bfc20dd783444a830ad4c38b345ab6e2f7000000000000000000000000b829a5b349b01fc71afe46e50dd6ec0222a6e59900000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}