{"SourceCode": "// SPDX-License-Identifier: MIT\r\n// If you think you may have found a vulnerability\r\n// File: @opengsn/contracts/src/interfaces/IRelayRecipient.sol\r\n\r\n\r\npragma solidity >=0.6.0;\r\n\r\n/**\r\n * a contract must implement this interface in order to support relayed transaction.\r\n * It is better to inherit the BaseRelayRecipient as its implementation.\r\n */\r\nabstract contract IRelayRecipient {\r\n\r\n    /**\r\n     * return if the forwarder is trusted to forward relayed transactions to us.\r\n     * the forwarder is required to verify the sender's signature, and verify\r\n     * the call is not a replay.\r\n     */\r\n    function isTrustedForwarder(address forwarder) public virtual view returns(bool);\r\n\r\n    /**\r\n     * return the sender of this call.\r\n     * if the call came through our trusted forwarder, then the real sender is appended as the last 20 bytes\r\n     * of the msg.data.\r\n     * otherwise, return `msg.sender`\r\n     * should be used in the contract anywhere instead of msg.sender\r\n     */\r\n    function _msgSender() internal virtual view returns (address);\r\n\r\n    /**\r\n     * return the msg.data of this call.\r\n     * if the call came through our trusted forwarder, then the real sender was appended as the last 20 bytes\r\n     * of the msg.data - so this method will strip those 20 bytes off.\r\n     * otherwise (if the call was made directly and not through the forwarder), return `msg.data`\r\n     * should be used in the contract instead of msg.data, where this difference matters.\r\n     */\r\n    function _msgData() internal virtual view returns (bytes calldata);\r\n\r\n    function versionRecipient() external virtual view returns (string memory);\r\n}\r\n\r\n// File: @opengsn/contracts/src/BaseRelayRecipient.sol\r\n\r\n\r\n// solhint-disable no-inline-assembly\r\npragma solidity >=0.6.9;\r\n\r\n\r\n/**\r\n * A base contract to be inherited by any contract that want to receive relayed transactions\r\n * A subclass must use \"_msgSender()\" instead of \"msg.sender\"\r\n */\r\nabstract contract BaseRelayRecipient is IRelayRecipient {\r\n\r\n    /*\r\n     * Forwarder singleton we accept calls from\r\n     */\r\n    address private _trustedForwarder;\r\n\r\n    function trustedForwarder() public virtual view returns (address){\r\n        return _trustedForwarder;\r\n    }\r\n\r\n    function _setTrustedForwarder(address _forwarder) internal {\r\n        _trustedForwarder = _forwarder;\r\n    }\r\n\r\n    function isTrustedForwarder(address forwarder) public virtual override view returns(bool) {\r\n        return forwarder == _trustedForwarder;\r\n    }\r\n\r\n    /**\r\n     * return the sender of this call.\r\n     * if the call came through our trusted forwarder, return the original sender.\r\n     * otherwise, return `msg.sender`.\r\n     * should be used in the contract anywhere instead of msg.sender\r\n     */\r\n    function _msgSender() internal override virtual view returns (address ret) {\r\n        if (msg.data.length >= 20 && isTrustedForwarder(msg.sender)) {\r\n            // At this point we know that the sender is a trusted forwarder,\r\n            // so we trust that the last bytes of msg.data are the verified sender address.\r\n            // extract sender address from the end of msg.data\r\n            assembly {\r\n                ret := shr(96,calldataload(sub(calldatasize(),20)))\r\n            }\r\n        } else {\r\n            ret = msg.sender;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * return the msg.data of this call.\r\n     * if the call came through our trusted forwarder, then the real sender was appended as the last 20 bytes\r\n     * of the msg.data - so this method will strip those 20 bytes off.\r\n     * otherwise (if the call was made directly and not through the forwarder), return `msg.data`\r\n     * should be used in the contract instead of msg.data, where this difference matters.\r\n     */\r\n    function _msgData() internal override virtual view returns (bytes calldata ret) {\r\n        if (msg.data.length >= 20 && isTrustedForwarder(msg.sender)) {\r\n            return msg.data[0:msg.data.length-20];\r\n        } else {\r\n            return msg.data;\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/lib/RelayRecipient.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n// import \"@opengsn/gsn/contracts/BaseRelayRecipient.sol\";\r\n\r\n\r\ncontract RelayRecipient is BaseRelayRecipient {\r\n    function versionRecipient() external pure override returns (string memory) {\r\n        return \"1.0.0-beta.1/charged-particles.relay.recipient\";\r\n    }\r\n}\r\n\r\n// File: contracts/lib/TokenInfo.sol\r\n\r\n\r\n\r\n// TokenInfo.sol -- Part of the Charged Particles Protocol\r\n// Copyright (c) 2021 Firma Lux, Inc. <https://charged.fi>\r\n//\r\n// Permission is hereby granted, free of charge, to any person obtaining a copy\r\n// of this software and associated documentation files (the \"Software\"), to deal\r\n// in the Software without restriction, including without limitation the rights\r\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n// copies of the Software, and to permit persons to whom the Software is\r\n// furnished to do so, subject to the following conditions:\r\n//\r\n// The above copyright notice and this permission notice shall be included in all\r\n// copies or substantial portions of the Software.\r\n//\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n// FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE\r\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n// SOFTWARE.\r\n\r\npragma solidity ^0.8.0;\r\n\r\nlibrary TokenInfo {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     * @dev Taken from OpenZeppelin library\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            codehash := extcodehash(account)\r\n        }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     * @dev Taken from OpenZeppelin library\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(\r\n        address payable recipient,\r\n        uint256 amount,\r\n        uint256 gasLimit\r\n    ) internal {\r\n        require(\r\n            address(this).balance >= amount,\r\n            \"TokenInfo: insufficient balance\"\r\n        );\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = (gasLimit > 0)\r\n            ? recipient.call{value: amount, gas: gasLimit}(\"\")\r\n            : recipient.call{value: amount}(\"\");\r\n        require(\r\n            success,\r\n            \"TokenInfo: unable to send value, recipient may have reverted\"\r\n        );\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721Receiver.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title ERC721 token receiver interface\r\n * @dev Interface for any contract that wants to support safeTransfers\r\n * from ERC721 asset contracts.\r\n */\r\ninterface IERC721Receiver {\r\n    /**\r\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\r\n     * by `operator` from `from`, this function is called.\r\n     *\r\n     * It must return its Solidity selector to confirm the token transfer.\r\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\r\n     *\r\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\r\n     */\r\n    function onERC721Received(\r\n        address operator,\r\n        address from,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}\r\n\r\n// File: contracts/interfaces/ISignatureVerifier.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface ISignatureVerifier {\r\n    function verify(\r\n        address _signer,\r\n        address _to,\r\n        uint256 _amount,\r\n        uint256 _nonce,\r\n        bytes memory signature\r\n    ) external pure returns (bool);\r\n}\r\n\r\n// File: contracts/interfaces/IChargedParticles.sol\r\n\r\n\r\n\r\n// IChargedParticles.sol -- Part of the Charged Particles Protocol\r\n// Copyright (c) 2021 Firma Lux, Inc. <https://charged.fi>\r\n//\r\n// Permission is hereby granted, free of charge, to any person obtaining a copy\r\n// of this software and associated documentation files (the \"Software\"), to deal\r\n// in the Software without restriction, including without limitation the rights\r\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n// copies of the Software, and to permit persons to whom the Software is\r\n// furnished to do so, subject to the following conditions:\r\n//\r\n// The above copyright notice and this permission notice shall be included in all\r\n// copies or substantial portions of the Software.\r\n//\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n// FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE\r\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n// SOFTWARE.\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @notice Interface for Charged Particles\r\n */\r\ninterface IChargedParticles {\r\n    /***********************************|\r\n    |             Public API            |\r\n    |__________________________________*/\r\n\r\n    function getStateAddress() external view returns (address stateAddress);\r\n\r\n    function getSettingsAddress()\r\n        external\r\n        view\r\n        returns (address settingsAddress);\r\n\r\n    function getManagersAddress()\r\n        external\r\n        view\r\n        returns (address managersAddress);\r\n\r\n    function getFeesForDeposit(uint256 assetAmount)\r\n        external\r\n        view\r\n        returns (uint256 protocolFee);\r\n\r\n    function baseParticleMass(\r\n        address contractAddress,\r\n        uint256 tokenId,\r\n        string calldata walletManagerId,\r\n        address assetToken\r\n    ) external returns (uint256);\r\n\r\n    function currentParticleCharge(\r\n        address contractAddress,\r\n        uint256 tokenId,\r\n        string calldata walletManagerId,\r\n        address assetToken\r\n    ) external returns (uint256);\r\n\r\n    function currentParticleKinetics(\r\n        address contractAddress,\r\n        uint256 tokenId,\r\n        string calldata walletManagerId,\r\n        address assetToken\r\n    ) external returns (uint256);\r\n\r\n    function currentParticleCovalentBonds(\r\n        address contractAddress,\r\n        uint256 tokenId,\r\n        string calldata basketManagerId\r\n    ) external view returns (uint256);\r\n\r\n    /***********************************|\r\n    |        Particle Mechanics         |\r\n    |__________________________________*/\r\n\r\n    function energizeParticle(\r\n        address contractAddress,\r\n        uint256 tokenId,\r\n        string calldata walletManagerId,\r\n        address assetToken,\r\n        uint256 assetAmount,\r\n        address referrer\r\n    ) external returns (uint256 yieldTokensAmount);\r\n\r\n    function dischargeParticle(\r\n        address receiver,\r\n        address contractAddress,\r\n        uint256 tokenId,\r\n        string calldata walletManagerId,\r\n        address assetToken\r\n    ) external returns (uint256 creatorAmount, uint256 receiverAmount);\r\n\r\n    function dischargeParticleAmount(\r\n        address receiver,\r\n        address contractAddress,\r\n        uint256 tokenId,\r\n        string calldata walletManagerId,\r\n        address assetToken,\r\n        uint256 assetAmount\r\n    ) external returns (uint256 creatorAmount, uint256 receiverAmount);\r\n\r\n    function dischargeParticleForCreator(\r\n        address receiver,\r\n        address contractAddress,\r\n        uint256 tokenId,\r\n        string calldata walletManagerId,\r\n        address assetToken,\r\n        uint256 assetAmount\r\n    ) external returns (uint256 receiverAmount);\r\n\r\n    function releaseParticle(\r\n        address receiver,\r\n        address contractAddress,\r\n        uint256 tokenId,\r\n        string calldata walletManagerId,\r\n        address assetToken\r\n    ) external returns (uint256 creatorAmount, uint256 receiverAmount);\r\n\r\n    function releaseParticleAmount(\r\n        address receiver,\r\n        address contractAddress,\r\n        uint256 tokenId,\r\n        string calldata walletManagerId,\r\n        address assetToken,\r\n        uint256 assetAmount\r\n    ) external returns (uint256 creatorAmount, uint256 receiverAmount);\r\n\r\n    function covalentBond(\r\n        address contractAddress,\r\n        uint256 tokenId,\r\n        string calldata basketManagerId,\r\n        address nftTokenAddress,\r\n        uint256 nftTokenId\r\n    ) external returns (bool success);\r\n\r\n    function breakCovalentBond(\r\n        address receiver,\r\n        address contractAddress,\r\n        uint256 tokenId,\r\n        string calldata basketManagerId,\r\n        address nftTokenAddress,\r\n        uint256 nftTokenId\r\n    ) external returns (bool success);\r\n\r\n    /***********************************|\r\n    |          Particle Events          |\r\n    |__________________________________*/\r\n\r\n    event Initialized(address indexed initiator);\r\n    event ControllerSet(address indexed controllerAddress, string controllerId);\r\n    event DepositFeeSet(uint256 depositFee);\r\n    event ProtocolFeesCollected(\r\n        address indexed assetToken,\r\n        uint256 depositAmount,\r\n        uint256 feesCollected\r\n    );\r\n}\r\n\r\n// File: contracts/interfaces/IChargedState.sol\r\n\r\n\r\n\r\n// IChargedSettings.sol -- Part of the Charged Particles Protocol\r\n// Copyright (c) 2021 Firma Lux, Inc. <https://charged.fi>\r\n//\r\n// Permission is hereby granted, free of charge, to any person obtaining a copy\r\n// of this software and associated documentation files (the \"Software\"), to deal\r\n// in the Software without restriction, including without limitation the rights\r\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n// copies of the Software, and to permit persons to whom the Software is\r\n// furnished to do so, subject to the following conditions:\r\n//\r\n// The above copyright notice and this permission notice shall be included in all\r\n// copies or substantial portions of the Software.\r\n//\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n// FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE\r\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n// SOFTWARE.\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @notice Interface for Charged State\r\n */\r\ninterface IChargedState {\r\n    /***********************************|\r\n    |      Only NFT Owner/Operator      |\r\n    |__________________________________*/\r\n\r\n    function setDischargeApproval(\r\n        address contractAddress,\r\n        uint256 tokenId,\r\n        address operator\r\n    ) external;\r\n\r\n    function setReleaseApproval(\r\n        address contractAddress,\r\n        uint256 tokenId,\r\n        address operator\r\n    ) external;\r\n\r\n    function setBreakBondApproval(\r\n        address contractAddress,\r\n        uint256 tokenId,\r\n        address operator\r\n    ) external;\r\n\r\n    function setTimelockApproval(\r\n        address contractAddress,\r\n        uint256 tokenId,\r\n        address operator\r\n    ) external;\r\n\r\n    function setApprovalForAll(\r\n        address contractAddress,\r\n        uint256 tokenId,\r\n        address operator\r\n    ) external;\r\n\r\n    function setPermsForRestrictCharge(\r\n        address contractAddress,\r\n        uint256 tokenId,\r\n        bool state\r\n    ) external;\r\n\r\n    function setPermsForAllowDischarge(\r\n        address contractAddress,\r\n        uint256 tokenId,\r\n        bool state\r\n    ) external;\r\n\r\n    function setPermsForAllowRelease(\r\n        address contractAddress,\r\n        uint256 tokenId,\r\n        bool state\r\n    ) external;\r\n\r\n    function setPermsForRestrictBond(\r\n        address contractAddress,\r\n        uint256 tokenId,\r\n        bool state\r\n    ) external;\r\n\r\n    function setPermsForAllowBreakBond(\r\n        address contractAddress,\r\n        uint256 tokenId,\r\n        bool state\r\n    ) external;\r\n\r\n    function setDischargeTimelock(\r\n        address contractAddress,\r\n        uint256 tokenId,\r\n        uint256 unlockBlock\r\n    ) external;\r\n\r\n    function setReleaseTimelock(\r\n        address contractAddress,\r\n        uint256 tokenId,\r\n        uint256 unlockBlock\r\n    ) external;\r\n\r\n    function setBreakBondTimelock(\r\n        address contractAddress,\r\n        uint256 tokenId,\r\n        uint256 unlockBlock\r\n    ) external;\r\n\r\n    /***********************************|\r\n    |         Only NFT Contract         |\r\n    |__________________________________*/\r\n\r\n    function setTemporaryLock(\r\n        address contractAddress,\r\n        uint256 tokenId,\r\n        bool isLocked\r\n    ) external;\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/introspection/IERC165.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC1155/IERC1155.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/IERC1155.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\r\n *\r\n * _Available since v3.1._\r\n */\r\ninterface IERC1155 is IERC165 {\r\n    /**\r\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\r\n     */\r\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\r\n\r\n    /**\r\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\r\n     * transfers.\r\n     */\r\n    event TransferBatch(\r\n        address indexed operator,\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256[] ids,\r\n        uint256[] values\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\r\n     * `approved`.\r\n     */\r\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\r\n     *\r\n     * If an {URI} event was emitted for `id`, the standard\r\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\r\n     * returned by {IERC1155MetadataURI-uri}.\r\n     */\r\n    event URI(string value, uint256 indexed id);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     */\r\n    function balanceOf(address account, uint256 id) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `accounts` and `ids` must have the same length.\r\n     */\r\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\r\n        external\r\n        view\r\n        returns (uint256[] memory);\r\n\r\n    /**\r\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `operator` cannot be the caller.\r\n     */\r\n    function setApprovalForAll(address operator, bool approved) external;\r\n\r\n    /**\r\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\r\n     *\r\n     * See {setApprovalForAll}.\r\n     */\r\n    function isApprovedForAll(address account, address operator) external view returns (bool);\r\n\r\n    /**\r\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\r\n     *\r\n     * Emits a {TransferSingle} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\r\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\r\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\r\n     * acceptance magic value.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes calldata data\r\n    ) external;\r\n\r\n    /**\r\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\r\n     *\r\n     * Emits a {TransferBatch} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `ids` and `amounts` must have the same length.\r\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\r\n     * acceptance magic value.\r\n     */\r\n    function safeBatchTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata amounts,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/introspection/ERC165.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Implementation of the {IERC165} interface.\r\n *\r\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\r\n * for the additional interface id that will be supported. For example:\r\n *\r\n * ```solidity\r\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\r\n * }\r\n * ```\r\n *\r\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\r\n */\r\nabstract contract ERC165 is IERC165 {\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n        return interfaceId == type(IERC165).interfaceId;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC721/IERC721.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Required interface of an ERC721 compliant contract.\r\n */\r\ninterface IERC721 is IERC165 {\r\n    /**\r\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\r\n     */\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\r\n     */\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Returns the number of tokens in ``owner``'s account.\r\n     */\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    /**\r\n     * @dev Returns the owner of the `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\r\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\r\n     * The approval is cleared when the token is transferred.\r\n     *\r\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The caller must own the token or be an approved operator.\r\n     * - `tokenId` must exist.\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address to, uint256 tokenId) external;\r\n\r\n    /**\r\n     * @dev Returns the account approved for `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function getApproved(uint256 tokenId) external view returns (address operator);\r\n\r\n    /**\r\n     * @dev Approve or remove `operator` as an operator for the caller.\r\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The `operator` cannot be the caller.\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     */\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n\r\n    /**\r\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\r\n     *\r\n     * See {setApprovalForAll}\r\n     */\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\r\n * @dev See https://eips.ethereum.org/EIPS/eip-721\r\n */\r\ninterface IERC721Metadata is IERC721 {\r\n    /**\r\n     * @dev Returns the token collection name.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the token collection symbol.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\r\n     */\r\n    function tokenURI(uint256 tokenId) external view returns (string memory);\r\n}\r\n\r\n// File: contracts/interfaces/IERC721Consumable.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/// @title ERC-721 Consumer Role extension\r\n///  Note: the ERC-165 identifier for this interface is 0x953c8dfa\r\ninterface IERC721Consumable is IERC721 {\r\n    /// @notice Emitted when `owner` changes the `consumer` of an NFT\r\n    /// The zero address for consumer indicates that there is no consumer address\r\n    /// When a Transfer event emits, this also indicates that the consumer address\r\n    /// for that NFT (if any) is set to none\r\n    event ConsumerChanged(\r\n        address indexed owner,\r\n        address indexed consumer,\r\n        uint256 indexed tokenId\r\n    );\r\n\r\n    /// @notice Get the consumer address of an NFT\r\n    /// @dev The zero address indicates that there is no consumer\r\n    /// Throws if `_tokenId` is not a valid NFT\r\n    /// @param _tokenId The NFT to get the consumer address for\r\n    /// @return The consumer address for this NFT, or the zero address if there is none\r\n    function consumerOf(uint256 _tokenId) external view returns (address);\r\n\r\n    /// @notice Change or reaffirm the consumer address for an NFT\r\n    /// @dev The zero address indicates there is no consumer address\r\n    /// Throws unless `msg.sender` is the current NFT owner, an authorised\r\n    /// operator of the current owner or approved address\r\n    /// Throws if `_tokenId` is not valid NFT\r\n    /// @param _consumer The new consumer of the NFT\r\n    function changeConsumer(address _consumer, uint256 _tokenId) external;\r\n}\r\n\r\n// File: contracts/interfaces/IParticlon.sol\r\n\r\n\r\n\r\n// Particlon.sol -- Part of the Charged Particles Protocol\r\n// Copyright (c) 2021 Firma Lux, Inc. <https://charged.fi>\r\n//\r\n// Permission is hereby granted, free of charge, to any person obtaining a copy\r\n// of this software and associated documentation files (the \"Software\"), to deal\r\n// in the Software without restriction, including without limitation the rights\r\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n// copies of the Software, and to permit persons to whom the Software is\r\n// furnished to do so, subject to the following conditions:\r\n//\r\n// The above copyright notice and this permission notice shall be included in all\r\n// copies or substantial portions of the Software.\r\n//\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n// FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE\r\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n// SOFTWARE.\r\n\r\npragma solidity ^0.8.0;\r\n\r\n// pragma experimental ABIEncoderV2;\r\n\r\n// import \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n// import \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\r\n// import \"@openzeppelin/contracts/access/Ownable.sol\";\r\n// import \"@openzeppelin/contracts/utils/Counters.sol\";\r\n// import \"@openzeppelin/contracts/utils/Address.sol\";\r\n// import \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\r\n\r\n// import \"./BlackholePrevention.sol\";\r\n// import \"./RelayRecipient.sol\";\r\n\r\n\r\ninterface IParticlon is IERC721 {\r\n    enum EMintPhase {\r\n        CLOSED,\r\n        CLAIM,\r\n        WHITELIST,\r\n        PUBLIC\r\n    }\r\n    /// @notice Andy was here\r\n    event NewBaseURI(string indexed _uri);\r\n    event NewSignerAddress(address indexed signer);\r\n    event NewMintPhase(EMintPhase indexed mintPhase);\r\n    event NewMintPrice(uint256 price);\r\n\r\n    event AssetTokenSet(address indexed assetToken);\r\n    event ChargedStateSet(address indexed chargedState);\r\n    event ChargedSettingsSet(address indexed chargedSettings);\r\n    event ChargedParticlesSet(address indexed chargedParticles);\r\n\r\n    event SalePriceSet(uint256 indexed tokenId, uint256 salePrice);\r\n    event CreatorRoyaltiesSet(uint256 indexed tokenId, uint256 royaltiesPct);\r\n    event ParticlonSold(\r\n        uint256 indexed tokenId,\r\n        address indexed oldOwner,\r\n        address indexed newOwner,\r\n        uint256 salePrice,\r\n        address creator,\r\n        uint256 creatorRoyalties\r\n    );\r\n    event RoyaltiesClaimed(address indexed receiver, uint256 amountClaimed);\r\n\r\n    /***********************************|\r\n    |              Public               |\r\n    |__________________________________*/\r\n\r\n    function creatorOf(uint256 tokenId) external view returns (address);\r\n\r\n    function getSalePrice(uint256 tokenId) external view returns (uint256);\r\n\r\n    function getLastSellPrice(uint256 tokenId) external view returns (uint256);\r\n\r\n    function getCreatorRoyalties(address account)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function getCreatorRoyaltiesPct(uint256 tokenId)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function getCreatorRoyaltiesReceiver(uint256 tokenId)\r\n        external\r\n        view\r\n        returns (address);\r\n\r\n    function buyParticlon(uint256 tokenId, uint256 gasLimit)\r\n        external\r\n        payable\r\n        returns (bool);\r\n\r\n    function claimCreatorRoyalties() external returns (uint256);\r\n\r\n    // function createParticlonForSale(\r\n    //     address creator,\r\n    //     address receiver,\r\n    //     // string memory tokenMetaUri,\r\n    //     uint256 royaltiesPercent,\r\n    //     uint256 salePrice\r\n    // ) external returns (uint256 newTokenId);\r\n\r\n    function mint(uint256 amount) external payable returns (bool);\r\n\r\n    function mintWhitelist(\r\n        uint256 amountMint,\r\n        uint256 amountAllowed,\r\n        uint256 nonce,\r\n        bytes calldata signature\r\n    ) external payable returns (bool);\r\n\r\n    function mintFree(\r\n        uint256 amountMint,\r\n        uint256 amountAllowed,\r\n        uint256 nonce,\r\n        bytes calldata signature\r\n    ) external returns (bool);\r\n\r\n    // function batchParticlonsForSale(\r\n    //     address creator,\r\n    //     uint256 annuityPercent,\r\n    //     uint256 royaltiesPercent,\r\n    //     uint256[] calldata salePrices\r\n    // ) external;\r\n\r\n    // function createParticlonsForSale(\r\n    //     address creator,\r\n    //     address receiver,\r\n    //     uint256 royaltiesPercent,\r\n    //     // string[] calldata tokenMetaUris,\r\n    //     uint256[] calldata salePrices\r\n    // ) external returns (bool);\r\n\r\n    // Andy was here\r\n\r\n    /***********************************|\r\n    |     Only Token Creator/Owner      |\r\n    |__________________________________*/\r\n\r\n    function setSalePrice(uint256 tokenId, uint256 salePrice) external;\r\n\r\n    function setRoyaltiesPct(uint256 tokenId, uint256 royaltiesPct) external;\r\n\r\n    function setCreatorRoyaltiesReceiver(uint256 tokenId, address receiver)\r\n        external;\r\n}\r\n\r\n// File: @openzeppelin/contracts/security/ReentrancyGuard.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and making it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/Strings.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev String operations.\r\n */\r\nlibrary Strings {\r\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\r\n     */\r\n    function toString(uint256 value) internal pure returns (string memory) {\r\n        // Inspired by OraclizeAPI's implementation - MIT licence\r\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\r\n\r\n        if (value == 0) {\r\n            return \"0\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 digits;\r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n        bytes memory buffer = new bytes(digits);\r\n        while (value != 0) {\r\n            digits -= 1;\r\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\r\n            value /= 10;\r\n        }\r\n        return string(buffer);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\r\n     */\r\n    function toHexString(uint256 value) internal pure returns (string memory) {\r\n        if (value == 0) {\r\n            return \"0x00\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 length = 0;\r\n        while (temp != 0) {\r\n            length++;\r\n            temp >>= 8;\r\n        }\r\n        return toHexString(value, length);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\r\n     */\r\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\r\n        bytes memory buffer = new bytes(2 * length + 2);\r\n        buffer[0] = \"0\";\r\n        buffer[1] = \"x\";\r\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\r\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\r\n            value >>= 4;\r\n        }\r\n        require(value == 0, \"Strings: hex length insufficient\");\r\n        return string(buffer);\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/Address.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\r\n\r\npragma solidity ^0.8.1;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\r\n     *\r\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\r\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\r\n     * constructor.\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize/address.code.length, which returns 0\r\n        // for contracts in construction, since the code is only stored at the end\r\n        // of the constructor execution.\r\n\r\n        return account.code.length > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain `call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\r\n     * revert reason using the provided one.\r\n     *\r\n     * _Available since v4.3._\r\n     */\r\n    function verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/Context.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: contracts/lib/ERC721A.sol\r\n\r\n\r\n// Creator: Chiru Labs\r\n\r\npragma solidity ^0.8.4;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nerror ApprovalCallerNotOwnerNorApproved();\r\nerror ApprovalQueryForNonexistentToken();\r\nerror ApproveToCaller();\r\nerror ApprovalToCurrentOwner();\r\nerror BalanceQueryForZeroAddress();\r\nerror MintToZeroAddress();\r\nerror MintZeroQuantity();\r\nerror OwnerQueryForNonexistentToken();\r\nerror TransferCallerNotOwnerNorApproved();\r\nerror TransferFromIncorrectOwner();\r\nerror TransferToNonERC721ReceiverImplementer();\r\nerror TransferToZeroAddress();\r\nerror URIQueryForNonexistentToken();\r\n\r\n/**\r\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\r\n * the Metadata extension. Built to optimize for lower gas during batch mints.\r\n *\r\n * Assumes serials are sequentially minted starting at _startTokenId() (defaults to 0, e.g. 0, 1, 2, 3..).\r\n *\r\n * Assumes that an owner cannot have more than 2**64 - 1 (max value of uint64) of supply.\r\n *\r\n * Assumes that the maximum token id cannot exceed 2**256 - 1 (max value of uint256).\r\n */\r\ncontract ERC721A is Context, ERC165, IERC721, IERC721Metadata {\r\n    using Address for address;\r\n    using Strings for uint256;\r\n\r\n    // Compiler will pack this into a single 256bit word.\r\n    struct TokenOwnership {\r\n        // The address of the owner.\r\n        address addr;\r\n        // Keeps track of the start time of ownership with minimal overhead for tokenomics.\r\n        uint64 startTimestamp;\r\n        // Whether the token has been burned.\r\n        bool burned;\r\n    }\r\n\r\n    // Compiler will pack this into a single 256bit word.\r\n    struct AddressData {\r\n        // Realistically, 2**64-1 is more than enough.\r\n        uint64 balance;\r\n        // Keeps track of mint count with minimal overhead for tokenomics.\r\n        uint64 numberMinted;\r\n        // Keeps track of burn count with minimal overhead for tokenomics.\r\n        uint64 numberBurned;\r\n        // For miscellaneous variable(s) pertaining to the address\r\n        // (e.g. number of whitelist mint slots used).\r\n        // If there are multiple variables, please pack them into a uint64.\r\n        uint64 aux;\r\n    }\r\n\r\n    // The tokenId of the next token to be minted.\r\n    uint256 internal _currentIndex;\r\n\r\n    // The number of tokens burned.\r\n    uint256 internal _burnCounter;\r\n\r\n    // Token name\r\n    string private _name;\r\n\r\n    // Token symbol\r\n    string private _symbol;\r\n\r\n    // Mapping from token ID to ownership details\r\n    // An empty struct value does not necessarily mean the token is unowned. See _ownershipOf implementation for details.\r\n    mapping(uint256 => TokenOwnership) internal _ownerships;\r\n\r\n    // Mapping owner address to address data\r\n    mapping(address => AddressData) private _addressData;\r\n\r\n    // Mapping from token ID to approved address\r\n    mapping(uint256 => address) private _tokenApprovals;\r\n\r\n    // Mapping from owner to operator approvals\r\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\r\n\r\n    constructor(string memory name_, string memory symbol_) {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n        _currentIndex = _startTokenId();\r\n    }\r\n\r\n    /**\r\n     * To change the starting tokenId, please override this function.\r\n     */\r\n    function _startTokenId() internal view virtual returns (uint256) {\r\n        return 1;\r\n    }\r\n\r\n    /**\r\n     * @dev Burned tokens are calculated here, use _totalMinted() if you want to count just minted tokens.\r\n     */\r\n    function totalSupply() public view returns (uint256) {\r\n        // Counter underflow is impossible as _burnCounter cannot be incremented\r\n        // more than _currentIndex - _startTokenId() times\r\n        unchecked {\r\n            return _currentIndex - _burnCounter - _startTokenId();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the total amount of tokens minted in the contract.\r\n     */\r\n    function _totalMinted() internal view returns (uint256) {\r\n        // Counter underflow is impossible as _currentIndex does not decrement,\r\n        // and it is initialized to _startTokenId()\r\n        unchecked {\r\n            return _currentIndex - _startTokenId();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId)\r\n        public\r\n        view\r\n        virtual\r\n        override(ERC165, IERC165)\r\n        returns (bool)\r\n    {\r\n        return\r\n            interfaceId == type(IERC721).interfaceId ||\r\n            interfaceId == type(IERC721Metadata).interfaceId ||\r\n            super.supportsInterface(interfaceId);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-balanceOf}.\r\n     */\r\n    function balanceOf(address owner) public view override returns (uint256) {\r\n        if (owner == address(0)) revert BalanceQueryForZeroAddress();\r\n        return uint256(_addressData[owner].balance);\r\n    }\r\n\r\n    /**\r\n     * Returns the number of tokens minted by `owner`.\r\n     */\r\n    function _numberMinted(address owner) internal view returns (uint256) {\r\n        return uint256(_addressData[owner].numberMinted);\r\n    }\r\n\r\n    /**\r\n     * Returns the number of tokens burned by or on behalf of `owner`.\r\n     */\r\n    function _numberBurned(address owner) internal view returns (uint256) {\r\n        return uint256(_addressData[owner].numberBurned);\r\n    }\r\n\r\n    /**\r\n     * Returns the auxillary data for `owner`. (e.g. number of whitelist mint slots used).\r\n     */\r\n    function _getAux(address owner) internal view returns (uint64) {\r\n        return _addressData[owner].aux;\r\n    }\r\n\r\n    /**\r\n     * Sets the auxillary data for `owner`. (e.g. number of whitelist mint slots used).\r\n     * If there are multiple variables, please pack them into a uint64.\r\n     */\r\n    function _setAux(address owner, uint64 aux) internal {\r\n        _addressData[owner].aux = aux;\r\n    }\r\n\r\n    /**\r\n     * Gas spent here starts off proportional to the maximum mint batch size.\r\n     * It gradually moves to O(1) as tokens get transferred around in the collection over time.\r\n     */\r\n    function _ownershipOf(uint256 tokenId)\r\n        internal\r\n        view\r\n        returns (TokenOwnership memory)\r\n    {\r\n        uint256 curr = tokenId;\r\n\r\n        unchecked {\r\n            if (_startTokenId() <= curr && curr < _currentIndex) {\r\n                TokenOwnership memory ownership = _ownerships[curr];\r\n                if (!ownership.burned) {\r\n                    if (ownership.addr != address(0)) {\r\n                        return ownership;\r\n                    }\r\n                    // Invariant:\r\n                    // There will always be an ownership that has an address and is not burned\r\n                    // before an ownership that does not have an address and is not burned.\r\n                    // Hence, curr will not underflow.\r\n                    while (true) {\r\n                        curr--;\r\n                        ownership = _ownerships[curr];\r\n                        if (ownership.addr != address(0)) {\r\n                            return ownership;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        revert OwnerQueryForNonexistentToken();\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-ownerOf}.\r\n     */\r\n    function ownerOf(uint256 tokenId) public view override returns (address) {\r\n        return _ownershipOf(tokenId).addr;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721Metadata-name}.\r\n     */\r\n    function name() public view virtual override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721Metadata-symbol}.\r\n     */\r\n    function symbol() public view virtual override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721Metadata-tokenURI}.\r\n     */\r\n    function tokenURI(uint256 tokenId)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (string memory)\r\n    {\r\n        if (!_exists(tokenId)) revert URIQueryForNonexistentToken();\r\n\r\n        string memory baseURI = _baseURI();\r\n        return\r\n            bytes(baseURI).length != 0\r\n                ? string(abi.encodePacked(baseURI, tokenId.toString()))\r\n                : \"\";\r\n    }\r\n\r\n    /**\r\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\r\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\r\n     * by default, can be overriden in child contracts.\r\n     */\r\n    function _baseURI() internal view virtual returns (string memory) {\r\n        return \"\";\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-approve}.\r\n     */\r\n    function approve(address to, uint256 tokenId) public override {\r\n        address owner = ERC721A.ownerOf(tokenId);\r\n        if (to == owner) revert ApprovalToCurrentOwner();\r\n\r\n        if (_msgSender() != owner && !isApprovedForAll(owner, _msgSender())) {\r\n            revert ApprovalCallerNotOwnerNorApproved();\r\n        }\r\n\r\n        _approve(to, tokenId, owner);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-getApproved}.\r\n     */\r\n    function getApproved(uint256 tokenId)\r\n        public\r\n        view\r\n        override\r\n        returns (address)\r\n    {\r\n        if (!_exists(tokenId)) revert ApprovalQueryForNonexistentToken();\r\n\r\n        return _tokenApprovals[tokenId];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-setApprovalForAll}.\r\n     */\r\n    function setApprovalForAll(address operator, bool approved)\r\n        public\r\n        virtual\r\n        override\r\n    {\r\n        if (operator == _msgSender()) revert ApproveToCaller();\r\n\r\n        _operatorApprovals[_msgSender()][operator] = approved;\r\n        emit ApprovalForAll(_msgSender(), operator, approved);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-isApprovedForAll}.\r\n     */\r\n    function isApprovedForAll(address owner, address operator)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (bool)\r\n    {\r\n        return _operatorApprovals[owner][operator];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-transferFrom}.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) public virtual override {\r\n        _transfer(from, to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-safeTransferFrom}.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) public virtual override {\r\n        safeTransferFrom(from, to, tokenId, \"\");\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-safeTransferFrom}.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory _data\r\n    ) public virtual override {\r\n        _transfer(from, to, tokenId);\r\n        if (\r\n            to.isContract() &&\r\n            !_checkContractOnERC721Received(from, to, tokenId, _data)\r\n        ) {\r\n            revert TransferToNonERC721ReceiverImplementer();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether `tokenId` exists.\r\n     *\r\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\r\n     *\r\n     * Tokens start existing when they are minted (`_mint`),\r\n     */\r\n    function _exists(uint256 tokenId) internal view returns (bool) {\r\n        return\r\n            _startTokenId() <= tokenId &&\r\n            tokenId < _currentIndex &&\r\n            !_ownerships[tokenId].burned;\r\n    }\r\n\r\n    function _safeMint(address to, uint256 quantity) internal {\r\n        _safeMint(to, quantity, \"\");\r\n    }\r\n\r\n    /**\r\n     * @dev Safely mints `quantity` tokens and transfers them to `to`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called for each safe transfer.\r\n     * - `quantity` must be greater than 0.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function _safeMint(\r\n        address to,\r\n        uint256 quantity,\r\n        bytes memory _data\r\n    ) internal {\r\n        _mint(to, quantity, _data, true);\r\n    }\r\n\r\n    /**\r\n     * @dev Mints `quantity` tokens and transfers them to `to`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     * - `quantity` must be greater than 0.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function _mint(\r\n        address to,\r\n        uint256 quantity,\r\n        bytes memory _data,\r\n        bool safe\r\n    ) internal {\r\n        uint256 startTokenId = _currentIndex;\r\n        if (to == address(0)) revert MintToZeroAddress();\r\n        if (quantity == 0) revert MintZeroQuantity();\r\n\r\n        _beforeTokenTransfers(address(0), to, startTokenId, quantity);\r\n\r\n        // Overflows are incredibly unrealistic.\r\n        // balance or numberMinted overflow if current value of either + quantity > 1.8e19 (2**64) - 1\r\n        // updatedIndex overflows if _currentIndex + quantity > 1.2e77 (2**256) - 1\r\n        unchecked {\r\n            _addressData[to].balance += uint64(quantity);\r\n            _addressData[to].numberMinted += uint64(quantity);\r\n\r\n            _ownerships[startTokenId].addr = to;\r\n            _ownerships[startTokenId].startTimestamp = uint64(block.timestamp);\r\n\r\n            uint256 updatedIndex = startTokenId;\r\n            uint256 end = updatedIndex + quantity;\r\n\r\n            if (safe && to.isContract()) {\r\n                do {\r\n                    emit Transfer(address(0), to, updatedIndex);\r\n                    if (\r\n                        !_checkContractOnERC721Received(\r\n                            address(0),\r\n                            to,\r\n                            updatedIndex++,\r\n                            _data\r\n                        )\r\n                    ) {\r\n                        revert TransferToNonERC721ReceiverImplementer();\r\n                    }\r\n                } while (updatedIndex != end);\r\n                // Reentrancy protection\r\n                if (_currentIndex != startTokenId) revert();\r\n            } else {\r\n                do {\r\n                    emit Transfer(address(0), to, updatedIndex++);\r\n                } while (updatedIndex != end);\r\n            }\r\n            _currentIndex = updatedIndex;\r\n        }\r\n        _afterTokenTransfers(address(0), to, startTokenId, quantity);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers `tokenId` from `from` to `to`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must be owned by `from`.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) internal virtual {\r\n        /// @dev Andy was here, made it internal virtual to work with Charged Particles\r\n        TokenOwnership memory prevOwnership = _ownershipOf(tokenId);\r\n\r\n        if (prevOwnership.addr != from) revert TransferFromIncorrectOwner();\r\n\r\n        bool isApprovedOrOwner = (_msgSender() == from ||\r\n            isApprovedForAll(from, _msgSender()) ||\r\n            getApproved(tokenId) == _msgSender());\r\n\r\n        if (!isApprovedOrOwner) revert TransferCallerNotOwnerNorApproved();\r\n        if (to == address(0)) revert TransferToZeroAddress();\r\n\r\n        _beforeTokenTransfers(from, to, tokenId, 1);\r\n\r\n        // Clear approvals from the previous owner\r\n        _approve(address(0), tokenId, from);\r\n\r\n        // Underflow of the sender's balance is impossible because we check for\r\n        // ownership above and the recipient's balance can't realistically overflow.\r\n        // Counter overflow is incredibly unrealistic as tokenId would have to be 2**256.\r\n        unchecked {\r\n            _addressData[from].balance -= 1;\r\n            _addressData[to].balance += 1;\r\n\r\n            TokenOwnership storage currSlot = _ownerships[tokenId];\r\n            currSlot.addr = to;\r\n            currSlot.startTimestamp = uint64(block.timestamp);\r\n\r\n            // If the ownership slot of tokenId+1 is not explicitly set, that means the transfer initiator owns it.\r\n            // Set the slot of tokenId+1 explicitly in storage to maintain correctness for ownerOf(tokenId+1) calls.\r\n            uint256 nextTokenId = tokenId + 1;\r\n            TokenOwnership storage nextSlot = _ownerships[nextTokenId];\r\n            if (nextSlot.addr == address(0)) {\r\n                // This will suffice for checking _exists(nextTokenId),\r\n                // as a burned slot cannot contain the zero address.\r\n                if (nextTokenId != _currentIndex) {\r\n                    nextSlot.addr = from;\r\n                    nextSlot.startTimestamp = prevOwnership.startTimestamp;\r\n                }\r\n            }\r\n        }\r\n\r\n        emit Transfer(from, to, tokenId);\r\n        _afterTokenTransfers(from, to, tokenId, 1);\r\n    }\r\n\r\n    /**\r\n     * @dev This is equivalent to _burn(tokenId, false)\r\n     */\r\n    function _burn(uint256 tokenId) internal virtual {\r\n        _burn(tokenId, false);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `tokenId`.\r\n     * The approval is cleared when the token is burned.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function _burn(uint256 tokenId, bool approvalCheck) internal virtual {\r\n        TokenOwnership memory prevOwnership = _ownershipOf(tokenId);\r\n\r\n        address from = prevOwnership.addr;\r\n\r\n        if (approvalCheck) {\r\n            bool isApprovedOrOwner = (_msgSender() == from ||\r\n                isApprovedForAll(from, _msgSender()) ||\r\n                getApproved(tokenId) == _msgSender());\r\n\r\n            if (!isApprovedOrOwner) revert TransferCallerNotOwnerNorApproved();\r\n        }\r\n\r\n        _beforeTokenTransfers(from, address(0), tokenId, 1);\r\n\r\n        // Clear approvals from the previous owner\r\n        _approve(address(0), tokenId, from);\r\n\r\n        // Underflow of the sender's balance is impossible because we check for\r\n        // ownership above and the recipient's balance can't realistically overflow.\r\n        // Counter overflow is incredibly unrealistic as tokenId would have to be 2**256.\r\n        unchecked {\r\n            AddressData storage addressData = _addressData[from];\r\n            addressData.balance -= 1;\r\n            addressData.numberBurned += 1;\r\n\r\n            // Keep track of who burned the token, and the timestamp of burning.\r\n            TokenOwnership storage currSlot = _ownerships[tokenId];\r\n            currSlot.addr = from;\r\n            currSlot.startTimestamp = uint64(block.timestamp);\r\n            currSlot.burned = true;\r\n\r\n            // If the ownership slot of tokenId+1 is not explicitly set, that means the burn initiator owns it.\r\n            // Set the slot of tokenId+1 explicitly in storage to maintain correctness for ownerOf(tokenId+1) calls.\r\n            uint256 nextTokenId = tokenId + 1;\r\n            TokenOwnership storage nextSlot = _ownerships[nextTokenId];\r\n            if (nextSlot.addr == address(0)) {\r\n                // This will suffice for checking _exists(nextTokenId),\r\n                // as a burned slot cannot contain the zero address.\r\n                if (nextTokenId != _currentIndex) {\r\n                    nextSlot.addr = from;\r\n                    nextSlot.startTimestamp = prevOwnership.startTimestamp;\r\n                }\r\n            }\r\n        }\r\n\r\n        emit Transfer(from, address(0), tokenId);\r\n        _afterTokenTransfers(from, address(0), tokenId, 1);\r\n\r\n        // Overflow not possible, as _burnCounter cannot be exceed _currentIndex times.\r\n        unchecked {\r\n            _burnCounter++;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Approve `to` to operate on `tokenId`\r\n     *\r\n     * Emits a {Approval} event.\r\n     */\r\n    function _approve(\r\n        address to,\r\n        uint256 tokenId,\r\n        address owner\r\n    ) private {\r\n        _tokenApprovals[tokenId] = to;\r\n        emit Approval(owner, to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target contract.\r\n     *\r\n     * @param from address representing the previous owner of the given token ID\r\n     * @param to target address that will receive the tokens\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     * @param _data bytes optional data to send along with the call\r\n     * @return bool whether the call correctly returned the expected magic value\r\n     */\r\n    function _checkContractOnERC721Received(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory _data\r\n    ) private returns (bool) {\r\n        try\r\n            IERC721Receiver(to).onERC721Received(\r\n                _msgSender(),\r\n                from,\r\n                tokenId,\r\n                _data\r\n            )\r\n        returns (bytes4 retval) {\r\n            return retval == IERC721Receiver(to).onERC721Received.selector;\r\n        } catch (bytes memory reason) {\r\n            if (reason.length == 0) {\r\n                revert TransferToNonERC721ReceiverImplementer();\r\n            } else {\r\n                assembly {\r\n                    revert(add(32, reason), mload(reason))\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Hook that is called before a set of serially-ordered token ids are about to be transferred. This includes minting.\r\n     * And also called before burning one token.\r\n     *\r\n     * startTokenId - the first token id to be transferred\r\n     * quantity - the amount to be transferred\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - When `from` and `to` are both non-zero, `from`'s `tokenId` will be\r\n     * transferred to `to`.\r\n     * - When `from` is zero, `tokenId` will be minted for `to`.\r\n     * - When `to` is zero, `tokenId` will be burned by `from`.\r\n     * - `from` and `to` are never both zero.\r\n     */\r\n    function _beforeTokenTransfers(\r\n        address from,\r\n        address to,\r\n        uint256 startTokenId,\r\n        uint256 quantity\r\n    ) internal virtual {}\r\n\r\n    /**\r\n     * @dev Hook that is called after a set of serially-ordered token ids have been transferred. This includes\r\n     * minting.\r\n     * And also called after one token has been burned.\r\n     *\r\n     * startTokenId - the first token id to be transferred\r\n     * quantity - the amount to be transferred\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - When `from` and `to` are both non-zero, `from`'s `tokenId` has been\r\n     * transferred to `to`.\r\n     * - When `from` is zero, `tokenId` has been minted for `to`.\r\n     * - When `to` is zero, `tokenId` has been burned by `from`.\r\n     * - `from` and `to` are never both zero.\r\n     */\r\n    function _afterTokenTransfers(\r\n        address from,\r\n        address to,\r\n        uint256 startTokenId,\r\n        uint256 quantity\r\n    ) internal virtual {}\r\n}\r\n\r\n// File: @openzeppelin/contracts/security/Pausable.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Contract module which allows children to implement an emergency stop\r\n * mechanism that can be triggered by an authorized account.\r\n *\r\n * This module is used through inheritance. It will make available the\r\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\r\n * the functions of your contract. Note that they will not be pausable by\r\n * simply including this module, only once the modifiers are put in place.\r\n */\r\nabstract contract Pausable is Context {\r\n    /**\r\n     * @dev Emitted when the pause is triggered by `account`.\r\n     */\r\n    event Paused(address account);\r\n\r\n    /**\r\n     * @dev Emitted when the pause is lifted by `account`.\r\n     */\r\n    event Unpaused(address account);\r\n\r\n    bool private _paused;\r\n\r\n    /**\r\n     * @dev Initializes the contract in unpaused state.\r\n     */\r\n    constructor() {\r\n        _paused = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the contract is paused, and false otherwise.\r\n     */\r\n    function paused() public view virtual returns (bool) {\r\n        return _paused;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is not paused.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must not be paused.\r\n     */\r\n    modifier whenNotPaused() {\r\n        require(!paused(), \"Pausable: paused\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is paused.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must be paused.\r\n     */\r\n    modifier whenPaused() {\r\n        require(paused(), \"Pausable: not paused\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Triggers stopped state.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must not be paused.\r\n     */\r\n    function _pause() internal virtual whenNotPaused {\r\n        _paused = true;\r\n        emit Paused(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns to normal state.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must be paused.\r\n     */\r\n    function _unpause() internal virtual whenPaused {\r\n        _paused = false;\r\n        emit Unpaused(_msgSender());\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/access/Ownable.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using Address for address;\r\n\r\n    function safeTransfer(\r\n        IERC20 token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        IERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Deprecated. This function has issues similar to the ones found in\r\n     * {IERC20-approve}, and its usage is discouraged.\r\n     *\r\n     * Whenever possible, use {safeIncreaseAllowance} and\r\n     * {safeDecreaseAllowance} instead.\r\n     */\r\n    function safeApprove(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        require(\r\n            (value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        unchecked {\r\n            uint256 oldAllowance = token.allowance(address(this), spender);\r\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\r\n            uint256 newAllowance = oldAllowance - value;\r\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0) {\r\n            // Return data is optional\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/lib/BlackholePrevention.sol\r\n\r\n\r\n\r\n// BlackholePrevention.sol -- Part of the Charged Particles Protocol\r\n// Copyright (c) 2021 Firma Lux, Inc. <https://charged.fi>\r\n//\r\n// Permission is hereby granted, free of charge, to any person obtaining a copy\r\n// of this software and associated documentation files (the \"Software\"), to deal\r\n// in the Software without restriction, including without limitation the rights\r\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n// copies of the Software, and to permit persons to whom the Software is\r\n// furnished to do so, subject to the following conditions:\r\n//\r\n// The above copyright notice and this permission notice shall be included in all\r\n// copies or substantial portions of the Software.\r\n//\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n// FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE\r\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n// SOFTWARE.\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @notice Prevents ETH or Tokens from getting stuck in a contract by allowing\r\n *  the Owner/DAO to pull them out on behalf of a user\r\n * This is only meant to contracts that are not expected to hold tokens, but do handle transferring them.\r\n */\r\ncontract BlackholePrevention {\r\n    using Address for address payable;\r\n    using SafeERC20 for IERC20;\r\n\r\n    event WithdrawStuckEther(address indexed receiver, uint256 amount);\r\n    event WithdrawStuckERC20(\r\n        address indexed receiver,\r\n        address indexed tokenAddress,\r\n        uint256 amount\r\n    );\r\n    event WithdrawStuckERC721(\r\n        address indexed receiver,\r\n        address indexed tokenAddress,\r\n        uint256 indexed tokenId\r\n    );\r\n    event WithdrawStuckERC1155(\r\n        address indexed receiver,\r\n        address indexed tokenAddress,\r\n        uint256 indexed tokenId,\r\n        uint256 amount\r\n    );\r\n\r\n    function _withdrawEther(address payable receiver, uint256 amount)\r\n        internal\r\n        virtual\r\n    {\r\n        require(receiver != address(0x0), \"BHP:E-403\");\r\n        if (address(this).balance >= amount) {\r\n            receiver.sendValue(amount);\r\n            emit WithdrawStuckEther(receiver, amount);\r\n        }\r\n    }\r\n\r\n    function _withdrawERC20(\r\n        address payable receiver,\r\n        address tokenAddress,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(receiver != address(0x0), \"BHP:E-403\");\r\n        if (IERC20(tokenAddress).balanceOf(address(this)) >= amount) {\r\n            IERC20(tokenAddress).safeTransfer(receiver, amount);\r\n            emit WithdrawStuckERC20(receiver, tokenAddress, amount);\r\n        }\r\n    }\r\n\r\n    function _withdrawERC721(\r\n        address payable receiver,\r\n        address tokenAddress,\r\n        uint256 tokenId\r\n    ) internal virtual {\r\n        require(receiver != address(0x0), \"BHP:E-403\");\r\n        if (IERC721(tokenAddress).ownerOf(tokenId) == address(this)) {\r\n            IERC721(tokenAddress).transferFrom(\r\n                address(this),\r\n                receiver,\r\n                tokenId\r\n            );\r\n            emit WithdrawStuckERC721(receiver, tokenAddress, tokenId);\r\n        }\r\n    }\r\n\r\n    function _withdrawERC1155(\r\n        address payable receiver,\r\n        address tokenAddress,\r\n        uint256 tokenId,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(receiver != address(0x0), \"BHP:E-403\");\r\n        if (\r\n            IERC1155(tokenAddress).balanceOf(address(this), tokenId) >= amount\r\n        ) {\r\n            IERC1155(tokenAddress).safeTransferFrom(\r\n                address(this),\r\n                receiver,\r\n                tokenId,\r\n                amount,\r\n                \"\"\r\n            );\r\n            emit WithdrawStuckERC1155(receiver, tokenAddress, tokenId, amount);\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/Particlon.sol\r\n\r\n\r\n\r\n// ParticlonB.sol -- Part of the Charged Particles Protocol\r\n// Copyright (c) 2021 Firma Lux, Inc. <https://charged.fi>\r\n//\r\n// Permission is hereby granted, free of charge, to any person obtaining a copy\r\n// of this software and associated documentation files (the \"Software\"), to deal\r\n// in the Software without restriction, including without limitation the rights\r\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n// copies of the Software, and to permit persons to whom the Software is\r\n// furnished to do so, subject to the following conditions:\r\n//\r\n// The above copyright notice and this permission notice shall be included in all\r\n// copies or substantial portions of the Software.\r\n//\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n// FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE\r\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n// SOFTWARE.\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract Particlon is\r\n    IParticlon,\r\n    ERC721A,\r\n    IERC721Consumable,\r\n    Ownable,\r\n    Pausable,\r\n    RelayRecipient,\r\n    ReentrancyGuard,\r\n    BlackholePrevention\r\n{\r\n    // using SafeMath for uint256; // not needed since solidity 0.8\r\n    using TokenInfo for address payable;\r\n    using Strings for uint256;\r\n\r\n    /// @dev In case we want to revoke the consumer part\r\n    bool internal _revokeConsumerOnTransfer;\r\n\r\n    /// @notice Address used to generate cryptographic signatures for whitelisted addresses\r\n    address internal _signer = 0xE8cF9826C7702411bb916c447D759E0E631d2e68;\r\n\r\n    uint256 internal _nonceClaim = 69;\r\n    uint256 internal _nonceWL = 420;\r\n\r\n    uint256 public constant MAX_SUPPLY = 10069;\r\n    uint256 public constant INITIAL_PRICE = 0.15 ether;\r\n\r\n    uint256 internal constant PERCENTAGE_SCALE = 1e4; // 10000  (100%)\r\n    uint256 internal constant MAX_ROYALTIES = 8e3; // 8000   (80%)\r\n\r\n    // Charged Particles V1 mainnet\r\n\r\n    IChargedState internal _chargedState =\r\n        IChargedState(0xB29256073C63960daAa398f1227D0adBC574341C);\r\n    // IChargedSettings internal _chargedSettings;\r\n    IChargedParticles internal _chargedParticles =\r\n        IChargedParticles(0xaB1a1410EA40930755C1330Cc0fB3367897C8c41);\r\n\r\n    /// @notice This needs to be set using the setAssetToken in order to get approved\r\n    address internal _assetToken;\r\n\r\n    // This right here drops the size so it doesn't break the limitation\r\n    // Enable optimization also has to be tured on!\r\n    ISignatureVerifier internal constant _signatureVerifier =\r\n        ISignatureVerifier(0x47a0915747565E8264296457b894068fe5CA9186);\r\n\r\n    uint256 internal _mintPrice;\r\n\r\n    string internal _baseUri =\r\n        \"ipfs://QmQrdG1cESrBenNUaTmxckFm4gJwgLdkqTGxNLuh4t5vo8/\";\r\n\r\n    // Mapping from token ID to consumer address\r\n    mapping(uint256 => address) _tokenConsumers;\r\n\r\n    mapping(uint256 => address) internal _tokenCreator;\r\n    mapping(uint256 => uint256) internal _tokenCreatorRoyaltiesPct;\r\n    mapping(uint256 => address) internal _tokenCreatorRoyaltiesRedirect;\r\n    mapping(address => uint256) internal _tokenCreatorClaimableRoyalties;\r\n\r\n    mapping(uint256 => uint256) internal _tokenSalePrice;\r\n    mapping(uint256 => uint256) internal _tokenLastSellPrice;\r\n\r\n    /// @notice Adhere to limits per whitelisted wallet for claim mint phase\r\n    mapping(address => uint256) internal _mintPassMinted;\r\n\r\n    /// @notice Adhere to limits per whitelisted wallet for whitelist mint phase\r\n    mapping(address => uint256) internal _whitelistedAddressMinted;\r\n\r\n    /// @notice set to CLOSED by default\r\n    EMintPhase public mintPhase;\r\n\r\n    /***********************************|\r\n    |          Initialization           |\r\n    |__________________________________*/\r\n\r\n    constructor() ERC721A(\"Particlon\", \"PART\") {\r\n        _mintPrice = INITIAL_PRICE;\r\n    }\r\n\r\n    /***********************************|\r\n    |              Public               |\r\n    |__________________________________*/\r\n\r\n    // Define an \"onlyOwner\" switch\r\n    function setRevokeConsumerOnTransfer(bool state) external onlyOwner {\r\n        _revokeConsumerOnTransfer = state;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId)\r\n        public\r\n        view\r\n        override(IERC165, ERC721A)\r\n        returns (bool)\r\n    {\r\n        return\r\n            interfaceId == type(IERC721Consumable).interfaceId ||\r\n            super.supportsInterface(interfaceId);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721Consumable-consumerOf}\r\n     */\r\n    function consumerOf(uint256 _tokenId) external view returns (address) {\r\n        require(\r\n            _exists(_tokenId),\r\n            \"ERC721Consumable: consumer query for nonexistent token\"\r\n        );\r\n        return _tokenConsumers[_tokenId];\r\n    }\r\n\r\n    function creatorOf(uint256 tokenId)\r\n        external\r\n        view\r\n        override\r\n        returns (address)\r\n    {\r\n        return _tokenCreator[tokenId];\r\n    }\r\n\r\n    function getSalePrice(uint256 tokenId)\r\n        external\r\n        view\r\n        override\r\n        returns (uint256)\r\n    {\r\n        return _tokenSalePrice[tokenId];\r\n    }\r\n\r\n    function getLastSellPrice(uint256 tokenId)\r\n        external\r\n        view\r\n        override\r\n        returns (uint256)\r\n    {\r\n        return _tokenLastSellPrice[tokenId];\r\n    }\r\n\r\n    function getCreatorRoyalties(address account)\r\n        external\r\n        view\r\n        override\r\n        returns (uint256)\r\n    {\r\n        return _tokenCreatorClaimableRoyalties[account];\r\n    }\r\n\r\n    function getCreatorRoyaltiesPct(uint256 tokenId)\r\n        external\r\n        view\r\n        override\r\n        returns (uint256)\r\n    {\r\n        return _tokenCreatorRoyaltiesPct[tokenId];\r\n    }\r\n\r\n    function getCreatorRoyaltiesReceiver(uint256 tokenId)\r\n        external\r\n        view\r\n        override\r\n        returns (address)\r\n    {\r\n        return _creatorRoyaltiesReceiver(tokenId);\r\n    }\r\n\r\n    function claimCreatorRoyalties()\r\n        external\r\n        override\r\n        nonReentrant\r\n        whenNotPaused\r\n        returns (uint256)\r\n    {\r\n        return _claimCreatorRoyalties(_msgSender());\r\n    }\r\n\r\n    /***********************************|\r\n    |      Create Multiple Particlons   |\r\n    |__________________________________*/\r\n\r\n    /// @notice Andy was here\r\n    function mint(uint256 amount)\r\n        external\r\n        payable\r\n        override\r\n        nonReentrant\r\n        whenNotPaused\r\n        notBeforePhase(EMintPhase.PUBLIC)\r\n        whenRemainingSupply\r\n        requirePayment(amount)\r\n        returns (bool)\r\n    {\r\n        // They may have minted 10, but if only 2 remain in supply, then they will only get 2, so only pay for 2\r\n        uint256 actualPrice = _mintAmount(amount, _msgSender());\r\n        _refundOverpayment(actualPrice, 0); // dont worry about gasLimit here as the \"minter\" could only hook themselves\r\n        return true;\r\n    }\r\n\r\n    /// @notice Andy was here\r\n    function mintWhitelist(\r\n        uint256 amountMint,\r\n        uint256 amountAllowed,\r\n        uint256 nonce,\r\n        bytes calldata signature\r\n    )\r\n        external\r\n        payable\r\n        override\r\n        nonReentrant\r\n        whenNotPaused\r\n        notBeforePhase(EMintPhase.WHITELIST)\r\n        whenRemainingSupply\r\n        requirePayment(amountMint)\r\n        requireWhitelist(amountMint, amountAllowed, nonce, signature)\r\n        returns (bool)\r\n    {\r\n        // They may have been whitelisted to mint 10, but if only 2 remain in supply, then they will only get 2, so only pay for 2\r\n        uint256 actualPrice = _mintAmount(amountMint, _msgSender());\r\n        _refundOverpayment(actualPrice, 0);\r\n        return true;\r\n    }\r\n\r\n    function mintFree(\r\n        uint256 amountMint,\r\n        uint256 amountAllowed,\r\n        uint256 nonce,\r\n        bytes calldata signature\r\n    )\r\n        external\r\n        override\r\n        whenNotPaused\r\n        notBeforePhase(EMintPhase.CLAIM)\r\n        whenRemainingSupply\r\n        requirePass(amountMint, amountAllowed, nonce, signature)\r\n        returns (bool)\r\n    {\r\n        // They may have been whitelisted to mint 10, but if only 2 remain in supply, then they will only get 2\r\n        _mintAmount(amountMint, _msgSender());\r\n        return true;\r\n    }\r\n\r\n    /***********************************|\r\n    |           Buy Particlons          |\r\n    |__________________________________*/\r\n\r\n    function buyParticlon(uint256 tokenId, uint256 gasLimit)\r\n        external\r\n        payable\r\n        override\r\n        nonReentrant\r\n        whenNotPaused\r\n        returns (bool)\r\n    {\r\n        _buyParticlon(tokenId, gasLimit);\r\n        return true;\r\n    }\r\n\r\n    /***********************************|\r\n    |     Only Token Creator/Owner      |\r\n    |__________________________________*/\r\n\r\n    function setSalePrice(uint256 tokenId, uint256 salePrice)\r\n        external\r\n        override\r\n        whenNotPaused\r\n        onlyTokenOwnerOrApproved(tokenId)\r\n    {\r\n        _setSalePrice(tokenId, salePrice);\r\n    }\r\n\r\n    function setRoyaltiesPct(uint256 tokenId, uint256 royaltiesPct)\r\n        external\r\n        override\r\n        whenNotPaused\r\n        onlyTokenCreator(tokenId)\r\n        onlyTokenOwnerOrApproved(tokenId)\r\n    {\r\n        _setRoyaltiesPct(tokenId, royaltiesPct);\r\n    }\r\n\r\n    function setCreatorRoyaltiesReceiver(uint256 tokenId, address receiver)\r\n        external\r\n        override\r\n        whenNotPaused\r\n        onlyTokenCreator(tokenId)\r\n    {\r\n        _tokenCreatorRoyaltiesRedirect[tokenId] = receiver;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721Consumable-changeConsumer}\r\n     */\r\n    function changeConsumer(address _consumer, uint256 _tokenId) external {\r\n        address owner = this.ownerOf(_tokenId);\r\n        require(\r\n            _msgSender() == owner ||\r\n                _msgSender() == getApproved(_tokenId) ||\r\n                isApprovedForAll(owner, _msgSender()),\r\n            \"ERC721Consumable: changeConsumer caller is not owner nor approved\"\r\n        );\r\n        _changeConsumer(owner, _consumer, _tokenId);\r\n    }\r\n\r\n    /***********************************|\r\n    |          Only Admin/DAO           |\r\n    |__________________________________*/\r\n\r\n    // Andy was here (Andy is everywhere)\r\n\r\n    function setSignerAddress(address signer) external onlyOwner {\r\n        _signer = signer;\r\n        emit NewSignerAddress(signer);\r\n    }\r\n\r\n    // In case we need to \"undo\" a signature/prevent it from being used,\r\n    // This is easier than changing the signer\r\n    // we would also need to remake all unused signatures\r\n    function setNonces(uint256 nonceClaim, uint256 nonceWL) external onlyOwner {\r\n        _nonceClaim = nonceClaim;\r\n        _nonceWL = nonceWL;\r\n    }\r\n\r\n    function setAssetToken(address assetToken) external onlyOwner {\r\n        _assetToken = assetToken;\r\n        // Need to Approve Charged Particles to transfer Assets from Particlon\r\n        IERC20(assetToken).approve(\r\n            address(_chargedParticles),\r\n            type(uint256).max\r\n        );\r\n        emit AssetTokenSet(assetToken);\r\n    }\r\n\r\n    function setMintPrice(uint256 price) external onlyOwner {\r\n        _mintPrice = price;\r\n        emit NewMintPrice(price);\r\n    }\r\n\r\n    /// @notice This is needed for the reveal\r\n    function setURI(string memory uri) external onlyOwner {\r\n        _baseUri = uri;\r\n        emit NewBaseURI(uri);\r\n    }\r\n\r\n    function setMintPhase(EMintPhase _mintPhase) external onlyOwner {\r\n        mintPhase = _mintPhase;\r\n        emit NewMintPhase(_mintPhase);\r\n    }\r\n\r\n    function setPausedState(bool state) external onlyOwner {\r\n        state ? _pause() : _unpause(); // these emit events\r\n    }\r\n\r\n    /**\r\n     * @dev Setup the ChargedParticles Interface\r\n     */\r\n    function setChargedParticles(address chargedParticles) external onlyOwner {\r\n        _chargedParticles = IChargedParticles(chargedParticles);\r\n        emit ChargedParticlesSet(chargedParticles);\r\n    }\r\n\r\n    /// @dev Setup the Charged-State Controller\r\n    function setChargedState(address stateController) external onlyOwner {\r\n        _chargedState = IChargedState(stateController);\r\n        emit ChargedStateSet(stateController);\r\n    }\r\n\r\n    /// @dev Setup the Charged-Settings Controller\r\n    // function setChargedSettings(address settings) external onlyOwner {\r\n    //     _chargedSettings = IChargedSettings(settings);\r\n    //     emit ChargedSettingsSet(settings);\r\n    // }\r\n\r\n    function setTrustedForwarder(address _trustedForwarder) external onlyOwner {\r\n        _setTrustedForwarder(_trustedForwarder); // Andy was here, trustedForwarder is already defined in opengsn/contracts/src/BaseRelayRecipient.sol\r\n    }\r\n\r\n    /***********************************|\r\n    |          Only Admin/DAO           |\r\n    |      (blackhole prevention)       |\r\n    |__________________________________*/\r\n\r\n    function withdrawEther(address payable receiver, uint256 amount)\r\n        external\r\n        onlyOwner\r\n    {\r\n        _withdrawEther(receiver, amount);\r\n    }\r\n\r\n    function withdrawERC20(\r\n        address payable receiver,\r\n        address tokenAddress,\r\n        uint256 amount\r\n    ) external onlyOwner {\r\n        _withdrawERC20(receiver, tokenAddress, amount);\r\n    }\r\n\r\n    function withdrawERC721(\r\n        address payable receiver,\r\n        address tokenAddress,\r\n        uint256 tokenId\r\n    ) external onlyOwner {\r\n        _withdrawERC721(receiver, tokenAddress, tokenId);\r\n    }\r\n\r\n    /***********************************|\r\n    |         Private Functions         |\r\n    |__________________________________*/\r\n\r\n    function _baseURI() internal view override returns (string memory) {\r\n        return _baseUri;\r\n    }\r\n\r\n    function _mintAmount(uint256 amount, address creator)\r\n        internal\r\n        returns (uint256 actualPrice)\r\n    {\r\n        uint256 newTokenId = totalSupply();\r\n        // newTokenId is equal to the supply at this stage\r\n        if (newTokenId + amount > MAX_SUPPLY) {\r\n            amount = MAX_SUPPLY - newTokenId;\r\n        }\r\n        // totalSupply += amount;\r\n\r\n        // _safeMint's second argument now takes in a quantity, not a tokenId.\r\n        _safeMint(creator, amount);\r\n        actualPrice = amount * _mintPrice; // Charge people for the ACTUAL amount minted;\r\n\r\n        uint256 assetAmount;\r\n        newTokenId++;\r\n        for (uint256 i; i < amount; i++) {\r\n            // Set the first minters as the creators\r\n            _tokenCreator[newTokenId + i] = creator;\r\n            assetAmount += _getAssetAmount(newTokenId + i);\r\n            // _chargeParticlon(newTokenId, \"generic\", assetAmount);\r\n        }\r\n        // Put all ERC20 tokens into the first Particlon to save a lot of gas\r\n        _chargeParticlon(newTokenId, \"generic\", assetAmount);\r\n    }\r\n\r\n    /**\r\n     * @dev Changes the consumer\r\n     * Requirement: `tokenId` must exist\r\n     */\r\n    function _changeConsumer(\r\n        address _owner,\r\n        address _consumer,\r\n        uint256 _tokenId\r\n    ) internal {\r\n        _tokenConsumers[_tokenId] = _consumer;\r\n        emit ConsumerChanged(_owner, _consumer, _tokenId);\r\n    }\r\n\r\n    function _beforeTokenTransfers(\r\n        address _from,\r\n        address _to,\r\n        uint256 _startTokenId,\r\n        uint256 _quantity\r\n    ) internal virtual override(ERC721A) {\r\n        if (_from == address(0)) {\r\n            return;\r\n        }\r\n        super._beforeTokenTransfers(_from, _to, _startTokenId, _quantity);\r\n\r\n        require(!paused(), \"ERC721Pausable: token transfer while paused\");\r\n\r\n        if (_revokeConsumerOnTransfer) {\r\n            /// @notice quantity is always one in this case\r\n            _changeConsumer(_from, address(0), _startTokenId);\r\n        }\r\n    }\r\n\r\n    function _setSalePrice(uint256 tokenId, uint256 salePrice) internal {\r\n        _tokenSalePrice[tokenId] = salePrice;\r\n\r\n        // Temp-Lock/Unlock NFT\r\n        //  prevents front-running the sale and draining the value of the NFT just before sale\r\n        _chargedState.setTemporaryLock(address(this), tokenId, (salePrice > 0));\r\n\r\n        emit SalePriceSet(tokenId, salePrice);\r\n    }\r\n\r\n    function _setRoyaltiesPct(uint256 tokenId, uint256 royaltiesPct) internal {\r\n        require(royaltiesPct <= MAX_ROYALTIES, \"PRT:E-421\"); // Andy was here\r\n        _tokenCreatorRoyaltiesPct[tokenId] = royaltiesPct;\r\n        emit CreatorRoyaltiesSet(tokenId, royaltiesPct);\r\n    }\r\n\r\n    function _creatorRoyaltiesReceiver(uint256 tokenId)\r\n        internal\r\n        view\r\n        returns (address)\r\n    {\r\n        address receiver = _tokenCreatorRoyaltiesRedirect[tokenId];\r\n        if (receiver == address(0x0)) {\r\n            receiver = _tokenCreator[tokenId];\r\n        }\r\n        return receiver;\r\n    }\r\n\r\n    /// @notice The tokens from a batch are being nested into the first NFT minted in that batch\r\n    function _getAssetAmount(uint256 tokenId) internal pure returns (uint256) {\r\n        if (tokenId == MAX_SUPPLY) {\r\n            return 1596 * 10**18;\r\n        } else if (tokenId > 9000) {\r\n            return 1403 * 10**18;\r\n        } else if (tokenId > 6000) {\r\n            return 1000 * 10**18;\r\n        } else if (tokenId > 3000) {\r\n            return 1500 * 10**18;\r\n        } else if (tokenId > 1000) {\r\n            return 1750 * 10**18;\r\n        }\r\n        return 2500 * 10**18;\r\n    }\r\n\r\n    function _chargeParticlon(\r\n        uint256 tokenId,\r\n        string memory walletManagerId,\r\n        uint256 assetAmount\r\n    ) internal {\r\n        address _self = address(this);\r\n        _chargedParticles.energizeParticle(\r\n            _self,\r\n            tokenId,\r\n            walletManagerId,\r\n            _assetToken,\r\n            assetAmount,\r\n            _self\r\n        );\r\n    }\r\n\r\n    function _buyParticlon(uint256 _tokenId, uint256 _gasLimit)\r\n        internal\r\n        returns (\r\n            address contractAddress,\r\n            uint256 tokenId,\r\n            address oldOwner,\r\n            address newOwner,\r\n            uint256 salePrice,\r\n            address royaltiesReceiver,\r\n            uint256 creatorAmount\r\n        )\r\n    {\r\n        contractAddress = address(this);\r\n        tokenId = _tokenId;\r\n        salePrice = _tokenSalePrice[_tokenId];\r\n        require(salePrice > 0, \"PRT:E-416\");\r\n        require(msg.value >= salePrice, \"PRT:E-414\");\r\n\r\n        uint256 ownerAmount = salePrice;\r\n        // creatorAmount;\r\n        oldOwner = ownerOf(_tokenId);\r\n        newOwner = _msgSender();\r\n\r\n        // Creator Royalties\r\n        royaltiesReceiver = _creatorRoyaltiesReceiver(_tokenId);\r\n        uint256 royaltiesPct = _tokenCreatorRoyaltiesPct[_tokenId];\r\n        uint256 lastSellPrice = _tokenLastSellPrice[_tokenId];\r\n        if (\r\n            royaltiesPct > 0 && lastSellPrice > 0 && salePrice > lastSellPrice\r\n        ) {\r\n            creatorAmount =\r\n                ((salePrice - lastSellPrice) * royaltiesPct) /\r\n                PERCENTAGE_SCALE;\r\n            ownerAmount -= creatorAmount;\r\n        }\r\n        _tokenLastSellPrice[_tokenId] = salePrice;\r\n\r\n        // Reserve Royalties for Creator\r\n        if (creatorAmount > 0) {\r\n            _tokenCreatorClaimableRoyalties[royaltiesReceiver] += creatorAmount;\r\n        }\r\n\r\n        // Transfer Token\r\n        _transfer(oldOwner, newOwner, _tokenId);\r\n\r\n        emit ParticlonSold(\r\n            _tokenId,\r\n            oldOwner,\r\n            newOwner,\r\n            salePrice,\r\n            royaltiesReceiver,\r\n            creatorAmount\r\n        );\r\n\r\n        // Transfer Payment\r\n        if (ownerAmount > 0) {\r\n            payable(oldOwner).sendValue(ownerAmount, _gasLimit);\r\n        }\r\n        _refundOverpayment(salePrice, _gasLimit);\r\n    }\r\n\r\n    /**\r\n     * @dev Pays out the Creator Royalties of the calling account\r\n     * @param receiver  The receiver of the claimable royalties\r\n     * @return          The amount of Creator Royalties claimed\r\n     */\r\n    function _claimCreatorRoyalties(address receiver)\r\n        internal\r\n        returns (uint256)\r\n    {\r\n        uint256 claimableAmount = _tokenCreatorClaimableRoyalties[receiver];\r\n        require(claimableAmount > 0, \"PRT:E-411\");\r\n\r\n        delete _tokenCreatorClaimableRoyalties[receiver];\r\n        payable(receiver).sendValue(claimableAmount, 0);\r\n\r\n        emit RoyaltiesClaimed(receiver, claimableAmount);\r\n\r\n        // Andy was here\r\n        return claimableAmount;\r\n    }\r\n\r\n    function _refundOverpayment(uint256 threshold, uint256 gasLimit) internal {\r\n        // Andy was here, removed SafeMath\r\n        uint256 overage = msg.value - threshold;\r\n        if (overage > 0) {\r\n            payable(_msgSender()).sendValue(overage, gasLimit);\r\n        }\r\n    }\r\n\r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) internal override {\r\n        // Unlock NFT\r\n        _tokenSalePrice[tokenId] = 0; // Andy was here\r\n        _chargedState.setTemporaryLock(address(this), tokenId, false);\r\n\r\n        super._transfer(from, to, tokenId);\r\n    }\r\n\r\n    /***********************************|\r\n    |          GSN/MetaTx Relay         |\r\n    |__________________________________*/\r\n\r\n    /// @dev See {BaseRelayRecipient-_msgSender}.\r\n    /// Andy: removed payable\r\n    function _msgSender()\r\n        internal\r\n        view\r\n        override(BaseRelayRecipient, Context)\r\n        returns (address)\r\n    {\r\n        return BaseRelayRecipient._msgSender();\r\n    }\r\n\r\n    /// @dev See {BaseRelayRecipient-_msgData}.\r\n    function _msgData()\r\n        internal\r\n        view\r\n        override(BaseRelayRecipient, Context)\r\n        returns (bytes memory)\r\n    {\r\n        return BaseRelayRecipient._msgData();\r\n    }\r\n\r\n    /// @dev This is missing from ERC721A for some reason.\r\n    function _isApprovedOrOwner(address spender, uint256 tokenId)\r\n        internal\r\n        view\r\n        virtual\r\n        returns (bool)\r\n    {\r\n        require(\r\n            _exists(tokenId),\r\n            \"ERC721: operator query for nonexistent token\"\r\n        );\r\n        address owner = ownerOf(tokenId);\r\n        return (spender == owner ||\r\n            isApprovedForAll(owner, spender) ||\r\n            getApproved(tokenId) == spender);\r\n    }\r\n\r\n    /***********************************|\r\n    |             Modifiers             |\r\n    |__________________________________*/\r\n\r\n    // Andy was here\r\n    modifier notBeforePhase(EMintPhase _mintPhase) {\r\n        require(mintPhase >= _mintPhase, \"MINT PHASE ERR\");\r\n        _;\r\n    }\r\n\r\n    modifier whenRemainingSupply() {\r\n        require(totalSupply() <= MAX_SUPPLY, \"SUPPLY LIMIT\");\r\n        _;\r\n    }\r\n\r\n    modifier requirePayment(uint256 amount) {\r\n        uint256 fullPrice = amount * _mintPrice;\r\n        require(msg.value >= fullPrice, \"LOW ETH\");\r\n        _;\r\n    }\r\n\r\n    modifier requireWhitelist(\r\n        uint256 amountMint,\r\n        uint256 amountAllowed,\r\n        uint256 nonce,\r\n        bytes calldata signature\r\n    ) {\r\n        require(amountMint <= amountAllowed, \"AMOUNT ERR\");\r\n        require(nonce == _nonceWL, \"NONCE ERR\");\r\n        require(\r\n            _signatureVerifier.verify(\r\n                _signer,\r\n                _msgSender(),\r\n                amountAllowed,\r\n                nonce, // prevent WL signatures being used for claiming\r\n                signature\r\n            ),\r\n            \"SIGNATURE ERR\"\r\n        );\r\n        require(\r\n            _whitelistedAddressMinted[_msgSender()] + amountMint <=\r\n                amountAllowed,\r\n            \"CLAIM ERR\"\r\n        );\r\n        _whitelistedAddressMinted[_msgSender()] += amountMint;\r\n        _;\r\n    }\r\n\r\n    /// @notice A snapshot is taken before the mint (mint pass NFT count is taken into consideration)\r\n    modifier requirePass(\r\n        uint256 amountMint,\r\n        uint256 amountAllowed,\r\n        uint256 nonce,\r\n        bytes calldata signature\r\n    ) {\r\n        require(amountMint <= amountAllowed, \"AMOUNT ERR\");\r\n        require(nonce == _nonceClaim, \"NONCE ERR\");\r\n        require(\r\n            _signatureVerifier.verify(\r\n                _signer,\r\n                _msgSender(),\r\n                amountAllowed,\r\n                nonce,\r\n                signature\r\n            ),\r\n            \"SIGNATURE ERR\"\r\n        );\r\n        require(\r\n            _mintPassMinted[_msgSender()] + amountMint <= amountAllowed,\r\n            \"CLAIM ERR\"\r\n        );\r\n        _mintPassMinted[_msgSender()] += amountMint;\r\n        _;\r\n    }\r\n\r\n    modifier onlyTokenOwnerOrApproved(uint256 tokenId) {\r\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"PRT:E-105\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyTokenCreator(uint256 tokenId) {\r\n        require(_tokenCreator[tokenId] == _msgSender(), \"PRT:E-104\");\r\n        _;\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ApprovalCallerNotOwnerNorApproved\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ApprovalQueryForNonexistentToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ApprovalToCurrentOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ApproveToCaller\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BalanceQueryForZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MintToZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MintZeroQuantity\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OwnerQueryForNonexistentToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferCallerNotOwnerNorApproved\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferFromIncorrectOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferToNonERC721ReceiverImplementer\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferToZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"URIQueryForNonexistentToken\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"assetToken\",\"type\":\"address\"}],\"name\":\"AssetTokenSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"chargedParticles\",\"type\":\"address\"}],\"name\":\"ChargedParticlesSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"chargedSettings\",\"type\":\"address\"}],\"name\":\"ChargedSettingsSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"chargedState\",\"type\":\"address\"}],\"name\":\"ChargedStateSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"consumer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ConsumerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"royaltiesPct\",\"type\":\"uint256\"}],\"name\":\"CreatorRoyaltiesSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"string\",\"name\":\"_uri\",\"type\":\"string\"}],\"name\":\"NewBaseURI\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"enum IParticlon.EMintPhase\",\"name\":\"mintPhase\",\"type\":\"uint8\"}],\"name\":\"NewMintPhase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"NewMintPrice\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"}],\"name\":\"NewSignerAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"salePrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"creatorRoyalties\",\"type\":\"uint256\"}],\"name\":\"ParticlonSold\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountClaimed\",\"type\":\"uint256\"}],\"name\":\"RoyaltiesClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"salePrice\",\"type\":\"uint256\"}],\"name\":\"SalePriceSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawStuckERC1155\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawStuckERC20\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"WithdrawStuckERC721\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawStuckEther\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"INITIAL_PRICE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_SUPPLY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"}],\"name\":\"buyParticlon\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_consumer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"changeConsumer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimCreatorRoyalties\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"consumerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"creatorOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getCreatorRoyalties\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getCreatorRoyaltiesPct\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getCreatorRoyaltiesReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getLastSellPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getSalePrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"forwarder\",\"type\":\"address\"}],\"name\":\"isTrustedForwarder\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountMint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountAllowed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"mintFree\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintPhase\",\"outputs\":[{\"internalType\":\"enum IParticlon.EMintPhase\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountMint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountAllowed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"mintWhitelist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"assetToken\",\"type\":\"address\"}],\"name\":\"setAssetToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"chargedParticles\",\"type\":\"address\"}],\"name\":\"setChargedParticles\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"stateController\",\"type\":\"address\"}],\"name\":\"setChargedState\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"setCreatorRoyaltiesReceiver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum IParticlon.EMintPhase\",\"name\":\"_mintPhase\",\"type\":\"uint8\"}],\"name\":\"setMintPhase\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"setMintPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"nonceClaim\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonceWL\",\"type\":\"uint256\"}],\"name\":\"setNonces\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"setPausedState\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"setRevokeConsumerOnTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"royaltiesPct\",\"type\":\"uint256\"}],\"name\":\"setRoyaltiesPct\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"salePrice\",\"type\":\"uint256\"}],\"name\":\"setSalePrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"}],\"name\":\"setSignerAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_trustedForwarder\",\"type\":\"address\"}],\"name\":\"setTrustedForwarder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"}],\"name\":\"setURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"trustedForwarder\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"versionRecipient\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"withdrawERC721\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawEther\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Particlon", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://ca5d34997d0bcb7d02d6521d8dba33d9fdfbb35791cf0bb0142a9c4543586c1a"}