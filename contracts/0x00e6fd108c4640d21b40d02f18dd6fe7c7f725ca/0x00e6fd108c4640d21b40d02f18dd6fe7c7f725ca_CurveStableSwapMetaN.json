{"SourceCode": "# pragma version 0.3.10\r\n# pragma optimize codesize\r\n# pragma evm-version shanghai\r\n\"\"\"\r\n@title CurveStableSwapMetaNG\r\n@author Curve.Fi\r\n@license Copyright (c) Curve.Fi, 2020-2023 - all rights reserved\r\n@notice Stableswap Metapool implementation for 2 coins. Supports pegged assets.\r\n@dev Metapools are pools where the coin on index 1 is a liquidity pool token\r\n     of another pool. This exposes methods such as exchange_underlying, which\r\n     exchanges token 0 <> token b1, b2, .. bn, where b is base pool and bn is the\r\n     nth coin index of the base pool.\r\n     CAUTION: Does not work if base pool is an NG pool. Use a different metapool\r\n              implementation index in the factory.\r\n     Asset Types:\r\n        0. Standard ERC20 token with no additional features.\r\n                          Note: Users are advised to do careful due-diligence on\r\n                                ERC20 tokens that they interact with, as this\r\n                                contract cannot differentiate between harmless and\r\n                                malicious ERC20 tokens.\r\n        1. Oracle - token with rate oracle (e.g. wstETH)\r\n                    Note: Oracles may be controlled externally by an EOA. Users\r\n                          are advised to proceed with caution.\r\n        2. Rebasing - token with rebase (e.g. stETH).\r\n                      Note: Users and Integrators are advised to understand how\r\n                            the AMM contract works with rebasing balances.\r\n        3. ERC4626 - token with convertToAssets method (e.g. sDAI).\r\n                     Note: Some ERC4626 implementations may be susceptible to\r\n                           Donation/Inflation attacks. Users are advised to\r\n                           proceed with caution.\r\n        NOTE: Pool Cannot support tokens with multiple asset types: e.g. ERC4626\r\n              with fees are not supported.\r\n     Supports:\r\n        1. ERC20 support for return True/revert, return True/False, return None\r\n        2. ERC20 tokens can have arbitrary decimals (<=18).\r\n        3. ERC20 tokens that rebase (either positive or fee on transfer)\r\n        4. ERC20 tokens that have a rate oracle (e.g. wstETH, cbETH, sDAI, etc.)\r\n           Note: Oracle precision _must_ be 10**18.\r\n        5. ERC4626 tokens with arbitrary precision (<=18) of Vault token and underlying\r\n           asset.\r\n     Additional features include:\r\n        1. Adds oracles based on AMM State Price (and _not_ last traded price).\r\n           State prices are calculated _after_ liquidity operations, using bonding\r\n           curve math.\r\n        2. Adds an exponential moving average oracle for D.\r\n        3. `exchange_received`: swaps that expect an ERC20 transfer to have occurred\r\n           prior to executing the swap.\r\n           Note: a. If pool contains rebasing tokens and one of the `asset_types` is 2 (Rebasing)\r\n                    then calling `exchange_received` will REVERT.\r\n                 b. If pool contains rebasing token and `asset_types` does not contain 2 (Rebasing)\r\n                    then this is an incorrect implementation and rebases can be\r\n                    stolen.\r\n        4. Adds `get_dx`, `get_dx_underlying`: Similar to `get_dy` which returns an expected output\r\n           of coin[j] for given `dx` amount of coin[i], `get_dx` returns expected\r\n           input of coin[i] for an output amount of coin[j].\r\n        5. Fees are dynamic: AMM will charge a higher fee if pool depegs. This can cause very\r\n                             slight discrepancies between calculated fees and realised fees.\r\n\"\"\"\r\n\r\nfrom vyper.interfaces import ERC20\r\nfrom vyper.interfaces import ERC20Detailed\r\nfrom vyper.interfaces import ERC4626\r\n\r\nimplements: ERC20\r\n\r\n# ------------------------------- Interfaces ---------------------------------\r\n\r\ninterface Factory:\r\n    def fee_receiver() -> address: view\r\n    def admin() -> address: view\r\n    def views_implementation() -> address: view\r\n\r\ninterface ERC1271:\r\n    def isValidSignature(_hash: bytes32, _signature: Bytes[65]) -> bytes32: view\r\n\r\ninterface StableSwapViews:\r\n    def get_dx(i: int128, j: int128, dy: uint256, pool: address) -> uint256: view\r\n    def get_dy(i: int128, j: int128, dx: uint256, pool: address) -> uint256: view\r\n    def get_dx_underlying(i: int128, j: int128, dy: uint256, pool: address) -> uint256: view\r\n    def get_dy_underlying(i: int128, j: int128, dx: uint256, pool: address) -> uint256: view\r\n    def dynamic_fee(i: int128, j: int128, pool: address) -> uint256: view\r\n    def calc_token_amount(\r\n        _amounts: DynArray[uint256, MAX_COINS],\r\n        _is_deposit: bool,\r\n        _pool: address\r\n    ) -> uint256: view\r\n\r\ninterface StableSwap2:\r\n    def add_liquidity(amounts: uint256[2], min_mint_amount: uint256): nonpayable\r\n\r\ninterface StableSwap3:\r\n    def add_liquidity(amounts: uint256[3], min_mint_amount: uint256): nonpayable\r\n\r\ninterface StableSwapNG:\r\n    def add_liquidity(\r\n        amounts: DynArray[uint256, MAX_COINS],\r\n        min_mint_amount: uint256\r\n    ) -> uint256: nonpayable\r\n\r\ninterface StableSwap:\r\n    def remove_liquidity_one_coin(_token_amount: uint256, i: int128, min_amount: uint256): nonpayable\r\n    def exchange(i: int128, j: int128, dx: uint256, min_dy: uint256): nonpayable\r\n    def get_virtual_price() -> uint256: view\r\n\r\ninterface Math:\r\n    def get_y(\r\n        i: int128,\r\n        j: int128,\r\n        x: uint256,\r\n        xp: DynArray[uint256, MAX_COINS],\r\n        _amp: uint256,\r\n        _D: uint256,\r\n        _n_coins: uint256\r\n    ) -> uint256: view\r\n    def get_y_D(\r\n        A: uint256,\r\n        i: int128,\r\n        xp: DynArray[uint256, MAX_COINS],\r\n        D: uint256,\r\n        _n_coins: uint256\r\n    ) -> uint256: view\r\n    def get_D(\r\n        _xp: DynArray[uint256, MAX_COINS],\r\n        _amp: uint256,\r\n        _n_coins: uint256\r\n    ) -> uint256: view\r\n    def exp(x: int256) -> uint256: view\r\n\r\n# --------------------------------- Events -----------------------------------\r\n\r\nevent Transfer:\r\n    sender: indexed(address)\r\n    receiver: indexed(address)\r\n    value: uint256\r\n\r\nevent Approval:\r\n    owner: indexed(address)\r\n    spender: indexed(address)\r\n    value: uint256\r\n\r\nevent TokenExchange:\r\n    buyer: indexed(address)\r\n    sold_id: int128\r\n    tokens_sold: uint256\r\n    bought_id: int128\r\n    tokens_bought: uint256\r\n\r\nevent TokenExchangeUnderlying:\r\n    buyer: indexed(address)\r\n    sold_id: int128\r\n    tokens_sold: uint256\r\n    bought_id: int128\r\n    tokens_bought: uint256\r\n\r\nevent AddLiquidity:\r\n    provider: indexed(address)\r\n    token_amounts: DynArray[uint256, MAX_COINS]\r\n    fees: DynArray[uint256, MAX_COINS]\r\n    invariant: uint256\r\n    token_supply: uint256\r\n\r\nevent RemoveLiquidity:\r\n    provider: indexed(address)\r\n    token_amounts: DynArray[uint256, MAX_COINS]\r\n    fees: DynArray[uint256, MAX_COINS]\r\n    token_supply: uint256\r\n\r\nevent RemoveLiquidityOne:\r\n    provider: indexed(address)\r\n    token_id: int128\r\n    token_amount: uint256\r\n    coin_amount: uint256\r\n    token_supply: uint256\r\n\r\nevent RemoveLiquidityImbalance:\r\n    provider: indexed(address)\r\n    token_amounts: DynArray[uint256, MAX_COINS]\r\n    fees: DynArray[uint256, MAX_COINS]\r\n    invariant: uint256\r\n    token_supply: uint256\r\n\r\nevent RampA:\r\n    old_A: uint256\r\n    new_A: uint256\r\n    initial_time: uint256\r\n    future_time: uint256\r\n\r\nevent StopRampA:\r\n    A: uint256\r\n    t: uint256\r\n\r\nevent ApplyNewFee:\r\n    fee: uint256\r\n    offpeg_fee_multiplier: uint256\r\n\r\nevent SetNewMATime:\r\n    ma_exp_time: uint256\r\n    D_ma_time: uint256\r\n\r\n\r\nMAX_COINS: constant(uint256) = 8  # max coins is 8 in the factory\r\nMAX_COINS_128: constant(int128) = 8\r\nMAX_METAPOOL_COIN_INDEX: constant(int128) = 1\r\n\r\n# ---------------------------- Pool Variables --------------------------------\r\n\r\nN_COINS: public(constant(uint256)) = 2\r\nN_COINS_128: constant(int128) = 2\r\nPRECISION: constant(uint256) = 10 ** 18\r\n\r\nBASE_POOL: public(immutable(address))\r\nBASE_POOL_IS_NG: immutable(bool)\r\nBASE_N_COINS: public(immutable(uint256))\r\nBASE_COINS: public(immutable(DynArray[address, MAX_COINS]))\r\n\r\nmath: immutable(Math)\r\nfactory: immutable(Factory)\r\ncoins: public(immutable(DynArray[address, MAX_COINS]))\r\nasset_type: immutable(uint8)\r\npool_contains_rebasing_tokens: immutable(bool)\r\nstored_balances: uint256[N_COINS]\r\n\r\n# Fee specific vars\r\nFEE_DENOMINATOR: constant(uint256) = 10 ** 10\r\nfee: public(uint256)  # fee * 1e10\r\noffpeg_fee_multiplier: public(uint256)  # * 1e10\r\nadmin_fee: public(constant(uint256)) = 5000000000\r\nMAX_FEE: constant(uint256) = 5 * 10 ** 9\r\n\r\n# ---------------------- Pool Amplification Parameters -----------------------\r\n\r\nA_PRECISION: constant(uint256) = 100\r\nMAX_A: constant(uint256) = 10 ** 6\r\nMAX_A_CHANGE: constant(uint256) = 10\r\n\r\ninitial_A: public(uint256)\r\nfuture_A: public(uint256)\r\ninitial_A_time: public(uint256)\r\nfuture_A_time: public(uint256)\r\n\r\n# ---------------------------- Admin Variables -------------------------------\r\n\r\nMIN_RAMP_TIME: constant(uint256) = 86400\r\nadmin_balances: public(DynArray[uint256, MAX_COINS])\r\n\r\n# ----------------------- Oracle Specific vars -------------------------------\r\n\r\nrate_multiplier: immutable(uint256)\r\n# [bytes4 method_id][bytes8 <empty>][bytes20 oracle]\r\nrate_oracle: immutable(uint256)  # this is the rate oracle for the token at 0th index\r\n\r\n# For ERC4626 tokens, we need:\r\ncall_amount: immutable(uint256)\r\nscale_factor: immutable(uint256)\r\n\r\nlast_prices_packed: uint256                       #  packing: last_price, ma_price\r\nlast_D_packed: uint256                            #  packing: last_D, ma_D\r\nma_exp_time: public(uint256)\r\nD_ma_time: public(uint256)\r\nma_last_time: public(uint256)                     # packing: ma_last_time_p, ma_last_time_D\r\n\r\n# shift(2**32 - 1, 224)\r\nORACLE_BIT_MASK: constant(uint256) = (2**32 - 1) * 256**28\r\n\r\n# --------------------------- ERC20 Specific Vars ----------------------------\r\n\r\nname: public(immutable(String[64]))\r\nsymbol: public(immutable(String[32]))\r\ndecimals: public(constant(uint8)) = 18\r\nversion: public(constant(String[8])) = \"v7.0.0\"\r\n\r\nbalanceOf: public(HashMap[address, uint256])\r\nallowance: public(HashMap[address, HashMap[address, uint256]])\r\ntotal_supply: uint256\r\nnonces: public(HashMap[address, uint256])\r\n\r\n# keccak256(\"isValidSignature(bytes32,bytes)\")[:4] << 224\r\nERC1271_MAGIC_VAL: constant(bytes32) = 0x1626ba7e00000000000000000000000000000000000000000000000000000000\r\nEIP712_TYPEHASH: constant(bytes32) = keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract,bytes32 salt)\")\r\nEIP2612_TYPEHASH: constant(bytes32) = keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\")\r\n\r\nVERSION_HASH: constant(bytes32) = keccak256(version)\r\nNAME_HASH: immutable(bytes32)\r\nCACHED_CHAIN_ID: immutable(uint256)\r\nsalt: public(immutable(bytes32))\r\nCACHED_DOMAIN_SEPARATOR: immutable(bytes32)\r\n\r\n\r\n# ------------------------------ AMM Setup -----------------------------------\r\n\r\n\r\n@external\r\ndef __init__(\r\n    _name: String[32],\r\n    _symbol: String[10],\r\n    _A: uint256,\r\n    _fee: uint256,\r\n    _offpeg_fee_multiplier: uint256,\r\n    _ma_exp_time: uint256,\r\n    _math_implementation: address,\r\n    _base_pool: address,\r\n    _coins: DynArray[address, MAX_COINS],\r\n    _base_coins: DynArray[address, MAX_COINS],\r\n    _rate_multipliers: DynArray[uint256, MAX_COINS],\r\n    _asset_types: DynArray[uint8, MAX_COINS],\r\n    _method_ids: DynArray[bytes4, MAX_COINS],\r\n    _oracles: DynArray[address, MAX_COINS],\r\n):\r\n    \"\"\"\r\n    @notice Initialize the pool contract\r\n    @param _name Name of the new plain pool.\r\n    @param _symbol Symbol for the new plain pool.\r\n    @param _A Amplification co-efficient - a lower value here means\r\n              less tolerance for imbalance within the pool's assets.\r\n              Suggested values include:\r\n               * Uncollateralized algorithmic stablecoins: 5-10\r\n               * Non-redeemable, collateralized assets: 100\r\n               * Redeemable assets: 200-400\r\n    @param _fee Trade fee, given as an integer with 1e10 precision. The\r\n                the maximum is 1% (100000000).\r\n                50% of the fee is distributed to veCRV holders.\r\n    @param _offpeg_fee_multiplier A multiplier that determines how much to increase\r\n                                  Fees by when assets in the AMM depeg. Example: 20000000000\r\n    @param _ma_exp_time Averaging window of oracle. Set as time_in_seconds / ln(2)\r\n                        Example: for 10 minute EMA, _ma_exp_time is 600 / ln(2) ~= 866\r\n    @param _math_implementation Contract containing Math methods\r\n    @param _base_pool The underlying AMM of the LP token _coins[0] is paired against\r\n    @param _coins List of addresses of the coins being used in the pool. For metapool this is\r\n                  the coin (say LUSD) vs (say) 3crv as: [LUSD, 3CRV]. Length is always 2.\r\n    @param _base_coins coins in the underlying base pool.\r\n    @param _rate_multipliers Rate multipliers of the individual coins. For Metapools it is:\r\n                              [10 ** (36 - _coins[0].decimals()), 10 ** 18].\r\n    @param _asset_types Array of uint8 representing tokens in pool\r\n    @param _method_ids Array of first four bytes of the Keccak-256 hash of the function signatures\r\n                       of the oracle addresses that gives rate oracles.\r\n                       Calculated as: keccak(text=event_signature.replace(\" \", \"\"))[:4]\r\n    @param _oracles Array of rate oracle addresses.\r\n    \"\"\"\r\n    # The following reverts if BASE_POOL is an NG implementaion.\r\n    BASE_POOL_IS_NG = raw_call(_base_pool, method_id(\"D_ma_time()\"), revert_on_failure=False)\r\n\r\n    if not BASE_POOL_IS_NG:\r\n        assert len(_base_coins) <= 3  # dev: implementation does not support old gen base pool with more than 3 coins\r\n\r\n    math = Math(_math_implementation)\r\n    BASE_POOL = _base_pool\r\n    BASE_COINS = _base_coins\r\n    BASE_N_COINS = len(_base_coins)\r\n    coins = _coins  # <---------------- coins[1] is always base pool LP token.\r\n\r\n    asset_type = _asset_types[0]\r\n    pool_contains_rebasing_tokens = asset_type == 2\r\n    rate_multiplier = _rate_multipliers[0]\r\n\r\n    for i in range(MAX_COINS):\r\n        if i < BASE_N_COINS:\r\n            # Approval needed for add_liquidity operation on base pool in\r\n            # _exchange_underlying:\r\n            assert ERC20(_base_coins[i]).approve(\r\n                BASE_POOL,\r\n                max_value(uint256),\r\n                default_return_value = True\r\n            )\r\n\r\n    # For ERC4626 tokens:\r\n    if asset_type == 3:\r\n        # In Vyper 0.3.10, if immutables are not set, because of an if-statement,\r\n        # it is by default set to 0; this is fine in the case of these two\r\n        # immutables, since they are only used if asset_types[0] == 3.\r\n        call_amount = 10**convert(ERC20Detailed(_coins[0]).decimals(), uint256)\r\n        scale_factor = 10**(18 - convert(ERC20Detailed(ERC4626(_coins[0]).asset()).decimals(), uint256))\r\n\r\n    # ----------------- Parameters independent of pool type ------------------\r\n\r\n    factory = Factory(msg.sender)\r\n\r\n    A: uint256 = unsafe_mul(_A, A_PRECISION)\r\n    self.initial_A = A\r\n    self.future_A = A\r\n    self.fee = _fee\r\n    self.offpeg_fee_multiplier = _offpeg_fee_multiplier\r\n\r\n    assert _ma_exp_time != 0\r\n    self.ma_exp_time = _ma_exp_time\r\n    self.D_ma_time = 62324  # <--------- 12 hours default on contract start.\r\n    self.ma_last_time = self.pack_2(block.timestamp, block.timestamp)\r\n\r\n    self.last_prices_packed = self.pack_2(10**18, 10**18)\r\n    self.admin_balances = [0, 0]\r\n    self.stored_balances = [0, 0]\r\n\r\n    rate_oracle = convert(_method_ids[0], uint256) * 2**224 | convert(_oracles[0], uint256)\r\n\r\n    # --------------------------- ERC20 stuff ----------------------------\r\n\r\n    name = _name\r\n    symbol = _symbol\r\n\r\n    # EIP712 related params -----------------\r\n    NAME_HASH = keccak256(name)\r\n    salt = block.prevhash\r\n    CACHED_CHAIN_ID = chain.id\r\n    CACHED_DOMAIN_SEPARATOR = keccak256(\r\n        _abi_encode(\r\n            EIP712_TYPEHASH,\r\n            NAME_HASH,\r\n            VERSION_HASH,\r\n            chain.id,\r\n            self,\r\n            salt,\r\n        )\r\n    )\r\n\r\n    # ------------------------ Fire a transfer event -------------------------\r\n\r\n    log Transfer(empty(address), msg.sender, 0)\r\n\r\n\r\n# ------------------ Token transfers in and out of the AMM -------------------\r\n\r\n\r\n@internal\r\ndef _transfer_in(\r\n    coin_metapool_idx: int128,\r\n    coin_basepool_idx: int128,\r\n    dx: uint256,\r\n    sender: address,\r\n    expect_optimistic_transfer: bool,\r\n    is_base_pool_swap: bool = False,\r\n) -> uint256:\r\n    \"\"\"\r\n    @notice Contains all logic to handle ERC20 token transfers.\r\n    @param coin_metapool_idx metapool index of input coin\r\n    @param coin_basepool_idx basepool index of input coin\r\n    @param dx amount of `_coin` to transfer into the pool.\r\n    @param sender address to transfer `_coin` from.\r\n    @param expect_optimistic_transfer True if contract expects an optimistic coin transfer\r\n    @param is_base_pool_swap Default is set to False.\r\n    @return amount of coins received\r\n    \"\"\"\r\n    _input_coin: ERC20 = ERC20(coins[coin_metapool_idx])\r\n    _input_coin_is_in_base_pool: bool = False\r\n\r\n    # Check if _transfer_in is being called by _exchange_underlying:\r\n    if coin_basepool_idx >= 0 and coin_metapool_idx == 1:\r\n\r\n        _input_coin = ERC20(BASE_COINS[coin_basepool_idx])\r\n        _input_coin_is_in_base_pool = True\r\n\r\n    _dx: uint256 = _input_coin.balanceOf(self)\r\n\r\n    # ------------------------- Handle Transfers -----------------------------\r\n\r\n    if expect_optimistic_transfer:\r\n\r\n        if not _input_coin_is_in_base_pool:\r\n            _dx = _dx - self.stored_balances[coin_metapool_idx]\r\n            assert _dx >= dx  # dev: pool did not receive tokens for swap\r\n\r\n    else:\r\n\r\n        assert dx > 0  # dev : do not transferFrom 0 tokens into the pool\r\n        assert _input_coin.transferFrom(\r\n            sender,\r\n            self,\r\n            dx,\r\n            default_return_value=True\r\n        )\r\n        _dx = _input_coin.balanceOf(self) - _dx\r\n\r\n    # ------------ Check if liquidity needs to be added somewhere ------------\r\n\r\n    if _input_coin_is_in_base_pool:\r\n        if is_base_pool_swap:\r\n            return _dx  # <----- _exchange_underlying: all input goes to swap.\r\n            # So, we will not increment self.stored_balances for metapool_idx.\r\n\r\n        # Swap involves base <> meta pool interaction. Add incoming base pool\r\n        # token to the base pool, mint _dx base pool LP token (idx 1) and add\r\n        # that to self.stored_balances and return that instead.\r\n        _dx = self._meta_add_liquidity(_dx, coin_basepool_idx)\r\n\r\n    # ----------------------- Update Stored Balances -------------------------\r\n\r\n    self.stored_balances[coin_metapool_idx] += _dx\r\n\r\n    return _dx\r\n\r\n\r\n@internal\r\ndef _transfer_out(\r\n    _coin_idx: int128, _amount: uint256, receiver: address\r\n):\r\n    \"\"\"\r\n    @notice Transfer a single token from the pool to receiver.\r\n    @dev This function is called by `remove_liquidity` and\r\n         `remove_liquidity_one_coin`, `_exchange`, `_withdraw_admin_fees` and\r\n         `remove_liquidity_imbalance` methods.\r\n    @param _coin_idx Index of the token to transfer out\r\n    @param _amount Amount of token to transfer out\r\n    @param receiver Address to send the tokens to\r\n    \"\"\"\r\n    assert receiver != empty(address)  # dev: do not send tokens to zero_address\r\n\r\n    if not pool_contains_rebasing_tokens:\r\n\r\n        # we need not cache balanceOf pool before swap out\r\n        self.stored_balances[_coin_idx] -= _amount\r\n        assert ERC20(coins[_coin_idx]).transfer(\r\n            receiver, _amount, default_return_value=True\r\n        )\r\n\r\n    else:\r\n\r\n        # cache balances pre and post to account for fee on transfers etc.\r\n        coin_balance: uint256 = ERC20(coins[_coin_idx]).balanceOf(self)\r\n        assert ERC20(coins[_coin_idx]).transfer(\r\n            receiver, _amount, default_return_value=True\r\n        )\r\n        self.stored_balances[_coin_idx] = coin_balance - _amount\r\n\r\n\r\n# -------------------------- AMM Special Methods -----------------------------\r\n\r\n\r\n@view\r\n@internal\r\ndef _stored_rates() -> uint256[N_COINS]:\r\n    \"\"\"\r\n    @notice Gets rate multipliers for each coin.\r\n    @dev If the coin has a rate oracle that has been properly initialised,\r\n         this method queries that rate by static-calling an external\r\n         contract.\r\n    \"\"\"\r\n    rates: uint256[N_COINS] = [rate_multiplier, StableSwap(BASE_POOL).get_virtual_price()]\r\n\r\n    if asset_type == 1 and not rate_oracle == 0:\r\n\r\n        # NOTE: fetched_rate is assumed to be 10**18 precision\r\n        oracle_response: Bytes[32] = raw_call(\r\n            convert(rate_oracle % 2**160, address),\r\n            _abi_encode(rate_oracle & ORACLE_BIT_MASK),\r\n            max_outsize=32,\r\n            is_static_call=True,\r\n        )\r\n        assert len(oracle_response) == 32\r\n        fetched_rate: uint256 = convert(oracle_response, uint256)\r\n\r\n        # rates[0] * fetched_rate / PRECISION\r\n        rates[0] = unsafe_div(rates[0] * fetched_rate, PRECISION)\r\n\r\n    elif asset_type == 3:  # ERC4626\r\n\r\n        # rates[0] * fetched_rate / PRECISION\r\n        rates[0] = unsafe_div(\r\n            rates[0] * ERC4626(coins[0]).convertToAssets(call_amount) * scale_factor,\r\n            PRECISION\r\n        )  # 1e18 precision\r\n\r\n    return rates\r\n\r\n\r\n@view\r\n@internal\r\ndef _balances() -> uint256[N_COINS]:\r\n    \"\"\"\r\n    @notice Calculates the pool's balances _excluding_ the admin's balances.\r\n    @dev If the pool contains rebasing tokens, this method ensures LPs keep all\r\n         rebases and admin only claims swap fees. This also means that, since\r\n         admin's balances are stored in an array and not inferred from read balances,\r\n         the fees in the rebasing token that the admin collects is immune to\r\n         slashing events.\r\n    \"\"\"\r\n    result: uint256[N_COINS] = empty(uint256[N_COINS])\r\n    admin_balances: DynArray[uint256, MAX_COINS] = self.admin_balances\r\n    for i in range(N_COINS_128):\r\n\r\n        if pool_contains_rebasing_tokens:\r\n            # Read balances by gulping to account for rebases\r\n            result[i] = ERC20(coins[i]).balanceOf(self) - admin_balances[i]\r\n        else:\r\n            # Use cached balances\r\n            result[i] = self.stored_balances[i] - admin_balances[i]\r\n\r\n    return result\r\n\r\n\r\n# -------------------------- AMM Main Functions ------------------------------\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef exchange(\r\n    i: int128,\r\n    j: int128,\r\n    _dx: uint256,\r\n    _min_dy: uint256,\r\n    _receiver: address = msg.sender,\r\n) -> uint256:\r\n    \"\"\"\r\n    @notice Perform an exchange between two coins\r\n    @dev Index values can be found via the `coins` public getter method\r\n    @param i Index value for the coin to send\r\n    @param j Index value of the coin to receive\r\n    @param _dx Amount of `i` being exchanged\r\n    @param _min_dy Minimum amount of `j` to receive\r\n    @param _receiver Address that receives `j`\r\n    @return Actual amount of `j` received\r\n    \"\"\"\r\n    return self._exchange(\r\n        msg.sender,\r\n        i,\r\n        j,\r\n        _dx,\r\n        _min_dy,\r\n        _receiver,\r\n        False\r\n    )\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef exchange_received(\r\n    i: int128,\r\n    j: int128,\r\n    _dx: uint256,\r\n    _min_dy: uint256,\r\n    _receiver: address = msg.sender,\r\n) -> uint256:\r\n    \"\"\"\r\n    @notice Perform an exchange between two coins without transferring token in\r\n    @dev The contract swaps tokens based on a change in balance of coin[i]. The\r\n         dx = ERC20(coin[i]).balanceOf(self) - self.stored_balances[i]. Users of\r\n         this method are dex aggregators, arbitrageurs, or other users who do not\r\n         wish to grant approvals to the contract: they would instead send tokens\r\n         directly to the contract and call `exchange_received`.\r\n         Note: This is disabled if pool contains rebasing tokens.\r\n    @param i Index value for the coin to send\r\n    @param j Index value of the coin to receive\r\n    @param _dx Amount of `i` being exchanged\r\n    @param _min_dy Minimum amount of `j` to receive\r\n    @param _receiver Address that receives `j`\r\n    @return Actual amount of `j` received\r\n    \"\"\"\r\n    assert not pool_contains_rebasing_tokens  # dev: exchange_received not supported if pool contains rebasing tokens\r\n    return self._exchange(\r\n        msg.sender,\r\n        i,\r\n        j,\r\n        _dx,\r\n        _min_dy,\r\n        _receiver,\r\n        True,  # <--------------------------------------- swap optimistically.\r\n    )\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef exchange_underlying(\r\n    i: int128,\r\n    j: int128,\r\n    _dx: uint256,\r\n    _min_dy: uint256,\r\n    _receiver: address = msg.sender,\r\n) -> uint256:\r\n    \"\"\"\r\n    @notice Perform an exchange between two underlying coins\r\n    @param i Index value for the underlying coin to send\r\n    @param j Index value of the underlying coin to receive\r\n    @param _dx Amount of `i` being exchanged\r\n    @param _min_dy Minimum amount of `j` to receive\r\n    @param _receiver Address that receives `j`\r\n    @return Actual amount of `j` received\r\n    \"\"\"\r\n    assert _receiver != empty(address)  # dev: do not send tokens to zero_address\r\n\r\n    rates: uint256[N_COINS] = self._stored_rates()\r\n    old_balances: uint256[N_COINS] = self._balances()\r\n    xp: uint256[N_COINS]  = self._xp_mem(rates, old_balances)\r\n\r\n    dy: uint256 = 0\r\n    base_i: int128 = 0\r\n    base_j: int128 = 0\r\n    meta_i: int128 = 0\r\n    meta_j: int128 = 0\r\n    x: uint256 = 0\r\n    output_coin: address = empty(address)\r\n\r\n    # ------------------------ Determine coin indices ------------------------\r\n\r\n    # Get input coin indices:\r\n    if i > 0:\r\n        base_i = i - MAX_METAPOOL_COIN_INDEX\r\n        meta_i = 1\r\n\r\n    # Get output coin and indices:\r\n    if j == 0:\r\n        output_coin = coins[0]\r\n    else:\r\n        base_j = j - MAX_METAPOOL_COIN_INDEX\r\n        meta_j = 1\r\n        output_coin = BASE_COINS[base_j]\r\n\r\n    # --------------------------- Do Transfer in -----------------------------\r\n\r\n    # If incoming coin is supposed to go to the base pool, the _transfer_in\r\n    # method will add_liquidity in the base pool and return dx_w_fee LP tokens\r\n    dx_w_fee: uint256 =  self._transfer_in(\r\n        meta_i,\r\n        base_i,\r\n        _dx,\r\n        msg.sender,\r\n        False,\r\n        (i > 0 and j > 0),  # <--- if True: do not add liquidity to base pool.\r\n    )\r\n\r\n    # ------------------------------- Exchange -------------------------------\r\n\r\n    if i == 0 or j == 0:  # meta swap\r\n\r\n        x = xp[meta_i] + unsafe_div(dx_w_fee * rates[meta_i], PRECISION)\r\n        dy = self.__exchange(x, xp, rates, meta_i, meta_j)\r\n\r\n        # Adjust stored balances of meta-level tokens:\r\n        self.stored_balances[meta_j] -= dy\r\n\r\n        # Withdraw from the base pool if needed\r\n        if j > 0:\r\n            out_amount: uint256 = ERC20(output_coin).balanceOf(self)\r\n            StableSwap(BASE_POOL).remove_liquidity_one_coin(dy, base_j, 0)\r\n            dy = ERC20(output_coin).balanceOf(self) - out_amount\r\n\r\n        assert dy >= _min_dy\r\n\r\n    else:  # base pool swap (user should swap at base pool for better gas)\r\n\r\n        dy = ERC20(output_coin).balanceOf(self)\r\n        StableSwap(BASE_POOL).exchange(base_i, base_j, dx_w_fee, _min_dy)\r\n        dy = ERC20(output_coin).balanceOf(self) - dy\r\n\r\n    # --------------------------- Do Transfer out ----------------------------\r\n\r\n    assert ERC20(output_coin).transfer(_receiver, dy, default_return_value=True)\r\n\r\n    # ------------------------------------------------------------------------\r\n\r\n    log TokenExchangeUnderlying(msg.sender, i, _dx, j, dy)\r\n\r\n    return dy\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef add_liquidity(\r\n    _amounts: uint256[N_COINS],\r\n    _min_mint_amount: uint256,\r\n    _receiver: address = msg.sender\r\n) -> uint256:\r\n    \"\"\"\r\n    @notice Deposit coins into the pool\r\n    @param _amounts List of amounts of coins to deposit\r\n    @param _min_mint_amount Minimum amount of LP tokens to mint from the deposit\r\n    @param _receiver Address that owns the minted LP tokens\r\n    @return Amount of LP tokens received by depositing\r\n    \"\"\"\r\n    assert _receiver != empty(address)  # dev: do not send LP tokens to zero_address\r\n\r\n    amp: uint256 = self._A()\r\n    old_balances: uint256[N_COINS] = self._balances()\r\n    rates: uint256[N_COINS] = self._stored_rates()\r\n\r\n    # Initial invariant\r\n    D0: uint256 = self.get_D_mem(rates, old_balances, amp)\r\n\r\n    total_supply: uint256 = self.total_supply\r\n    new_balances: uint256[N_COINS] = old_balances\r\n\r\n    # -------------------------- Do Transfers In -----------------------------\r\n\r\n    for i in range(N_COINS_128):\r\n\r\n        if _amounts[i] > 0:\r\n\r\n            new_balances[i] += self._transfer_in(\r\n                i,\r\n                -1,  # <--- we're not handling underlying coins here\r\n                _amounts[i],\r\n                msg.sender,\r\n                False,  # expect_optimistic_transfer\r\n            )\r\n\r\n        else:\r\n\r\n            assert total_supply != 0  # dev: initial deposit requires all coins\r\n\r\n    # ------------------------------------------------------------------------\r\n\r\n    # Invariant after change\r\n    D1: uint256 = self.get_D_mem(rates, new_balances, amp)\r\n    assert D1 > D0\r\n\r\n    # We need to recalculate the invariant accounting for fees\r\n    # to calculate fair user's share\r\n    fees: uint256[N_COINS] = empty(uint256[N_COINS])\r\n    mint_amount: uint256 = 0\r\n\r\n    if total_supply > 0:\r\n\r\n        ideal_balance: uint256 = 0\r\n        difference: uint256 = 0\r\n        new_balance: uint256 = 0\r\n\r\n        ys: uint256 = unsafe_div(D0 + D1, N_COINS)\r\n        xs: uint256 = 0\r\n        _dynamic_fee_i: uint256 = 0\r\n\r\n        # Only account for fees if we are not the first to deposit\r\n        # base_fee: uint256 = self.fee * N_COINS / (4 * (N_COINS - 1))\r\n        # unsafe math is safu here:\r\n        base_fee: uint256 = unsafe_div(unsafe_mul(self.fee, N_COINS), 4)\r\n\r\n        for i in range(N_COINS_128):\r\n\r\n            ideal_balance = D1 * old_balances[i] / D0\r\n            new_balance = new_balances[i]\r\n\r\n            # unsafe math is safu here:\r\n            if ideal_balance > new_balance:\r\n                difference = unsafe_sub(ideal_balance, new_balance)\r\n            else:\r\n                difference = unsafe_sub(new_balance, ideal_balance)\r\n\r\n            # fee[i] = _dynamic_fee(i, j) * difference / FEE_DENOMINATOR\r\n            xs = unsafe_div(rates[i] * (old_balances[i] + new_balance), PRECISION)\r\n            _dynamic_fee_i = self._dynamic_fee(xs, ys, base_fee)\r\n            fees[i] = unsafe_div(_dynamic_fee_i * difference, FEE_DENOMINATOR)\r\n\r\n            # fees[i] * admin_fee / FEE_DENOMINATOR\r\n            self.admin_balances[i] += unsafe_div(fees[i] * admin_fee, FEE_DENOMINATOR)\r\n            new_balances[i] -= fees[i]\r\n\r\n        xp: uint256[N_COINS] = self._xp_mem(rates, new_balances)\r\n        D1 = math.get_D([xp[0], xp[1]], amp, N_COINS)  # <------ Reuse D1 for new D value.\r\n        # we do unsafe div here because we already did several safedivs with D0\r\n        mint_amount = unsafe_div(total_supply * (D1 - D0), D0)\r\n        self.upkeep_oracles(xp, amp, D1)\r\n\r\n    else:\r\n\r\n        mint_amount = D1  # Take the dust if there was any\r\n\r\n        # (re)instantiate D oracle if totalSupply is zero.\r\n        self.last_D_packed = self.pack_2(D1, D1)\r\n\r\n        # Update D ma time:\r\n        ma_last_time_unpacked: uint256[2] = self.unpack_2(self.ma_last_time)\r\n        if ma_last_time_unpacked[1] < block.timestamp:\r\n            ma_last_time_unpacked[1] = block.timestamp\r\n            self.ma_last_time = self.pack_2(ma_last_time_unpacked[0], ma_last_time_unpacked[1])\r\n\r\n    assert mint_amount >= _min_mint_amount, \"Slippage screwed you\"\r\n\r\n    # Mint pool tokens\r\n    total_supply += mint_amount\r\n    user_lp_token_bal: uint256 = self.balanceOf[_receiver]\r\n\r\n    # here we can increase balance using unsafe add because\r\n    # user balance will always be <= total_supply. so if total_supply\r\n    # safeadd works, this can be safely unsafe:\r\n    self.balanceOf[_receiver] = unsafe_add(user_lp_token_bal, mint_amount)\r\n    self.total_supply = total_supply\r\n    log Transfer(empty(address), _receiver, mint_amount)\r\n\r\n    log AddLiquidity(\r\n        msg.sender,\r\n        [_amounts[0], _amounts[1]],\r\n        [fees[0], fees[1]],\r\n        D1,\r\n        total_supply\r\n    )\r\n\r\n    return mint_amount\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef remove_liquidity_one_coin(\r\n    _burn_amount: uint256,\r\n    i: int128,\r\n    _min_received: uint256,\r\n    _receiver: address = msg.sender,\r\n) -> uint256:\r\n    \"\"\"\r\n    @notice Withdraw a single coin from the pool\r\n    @param _burn_amount Amount of LP tokens to burn in the withdrawal\r\n    @param i Index value of the coin to withdraw\r\n    @param _min_received Minimum amount of coin to receive\r\n    @param _receiver Address that receives the withdrawn coins\r\n    @return Amount of coin received\r\n    \"\"\"\r\n    assert _burn_amount > 0  # dev: do not remove 0 LP tokens\r\n\r\n    dy: uint256 = 0\r\n    fee: uint256 = 0\r\n    xp: uint256[N_COINS] = empty(uint256[N_COINS])\r\n    amp: uint256 = empty(uint256)\r\n    D: uint256 = empty(uint256)\r\n\r\n    dy, fee, xp, amp, D = self._calc_withdraw_one_coin(_burn_amount, i)\r\n    assert dy >= _min_received, \"Not enough coins removed\"\r\n\r\n    # fee * admin_fee / FEE_DENOMINATOR\r\n    self.admin_balances[i] += unsafe_div(fee * admin_fee, FEE_DENOMINATOR)\r\n\r\n    self._burnFrom(msg.sender, _burn_amount)\r\n\r\n    self._transfer_out(i, dy, _receiver)\r\n\r\n    log RemoveLiquidityOne(msg.sender, i, _burn_amount, dy, self.total_supply)\r\n\r\n    self.upkeep_oracles(xp, amp, D)\r\n\r\n    return dy\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef remove_liquidity_imbalance(\r\n    _amounts: uint256[N_COINS],\r\n    _max_burn_amount: uint256,\r\n    _receiver: address = msg.sender\r\n) -> uint256:\r\n    \"\"\"\r\n    @notice Withdraw coins from the pool in an imbalanced amount\r\n    @param _amounts List of amounts of underlying coins to withdraw\r\n    @param _max_burn_amount Maximum amount of LP token to burn in the withdrawal\r\n    @param _receiver Address that receives the withdrawn coins\r\n    @return Actual amount of the LP token burned in the withdrawal\r\n    \"\"\"\r\n\r\n    amp: uint256 = self._A()\r\n    rates: uint256[N_COINS] = self._stored_rates()\r\n    old_balances: uint256[N_COINS] = self._balances()\r\n    D0: uint256 = self.get_D_mem(rates, old_balances, amp)\r\n    new_balances: uint256[N_COINS] = old_balances\r\n\r\n    for i in range(N_COINS_128):\r\n\r\n        if _amounts[i] != 0:\r\n            new_balances[i] -= _amounts[i]\r\n            self._transfer_out(i, _amounts[i], _receiver)\r\n\r\n    D1: uint256 = self.get_D_mem(rates, new_balances, amp)\r\n    # base_fee: uint256 = self.fee * N_COINS / (4 * (N_COINS - 1))\r\n    base_fee: uint256 = unsafe_div(unsafe_mul(self.fee, N_COINS), 4)\r\n    # ys: uint256 = (D0 + D1) / N_COINS\r\n    ys: uint256 = unsafe_div(D0 + D1, N_COINS)\r\n\r\n    fees: uint256[N_COINS] = empty(uint256[N_COINS])\r\n    dynamic_fee: uint256 = 0\r\n    xs: uint256 = 0\r\n    ideal_balance: uint256 = 0\r\n    difference: uint256 = 0\r\n    new_balance: uint256 = 0\r\n\r\n    for i in range(N_COINS_128):\r\n\r\n        ideal_balance = D1 * old_balances[i] / D0\r\n        new_balance = new_balances[i]\r\n\r\n        if ideal_balance > new_balance:\r\n            difference = unsafe_sub(ideal_balance, new_balance)\r\n        else:\r\n            difference = unsafe_sub(new_balance, ideal_balance)\r\n\r\n        # base_fee * difference / FEE_DENOMINATOR\r\n        xs = unsafe_div(rates[i] * (old_balances[i] + new_balance), PRECISION)\r\n        dynamic_fee = self._dynamic_fee(xs, ys, base_fee)\r\n        fees[i] = unsafe_div(dynamic_fee * difference, FEE_DENOMINATOR)\r\n\r\n        # fees[i] * admin_fee / FEE_DENOMINATOR\r\n        self.admin_balances[i] += unsafe_div(fees[i] * admin_fee, FEE_DENOMINATOR)\r\n\r\n        new_balances[i] -= fees[i]\r\n\r\n    D1 = self.get_D_mem(rates, new_balances, amp)  # dev: reuse D1 for new D.\r\n    self.upkeep_oracles(self._xp_mem(rates, new_balances), amp, D1)\r\n\r\n    total_supply: uint256 = self.total_supply\r\n    # here we can do unsafe div by D0 because we did several safedivs:\r\n    # burn_amount: uint256 = ((D0 - D1) * total_supply / D0) + 1\r\n    burn_amount: uint256 = unsafe_div((D0 - D1) * total_supply, D0) + 1\r\n    assert burn_amount > 1  # dev: zero tokens burned\r\n    assert burn_amount <= _max_burn_amount, \"Slippage screwed you\"\r\n\r\n    self._burnFrom(msg.sender, burn_amount)\r\n\r\n    log RemoveLiquidityImbalance(\r\n        msg.sender,\r\n        [_amounts[0], _amounts[1]],\r\n        [fees[0], fees[1]],\r\n        D1,\r\n        total_supply - burn_amount\r\n    )\r\n\r\n    return burn_amount\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef remove_liquidity(\r\n    _burn_amount: uint256,\r\n    _min_amounts: uint256[N_COINS],\r\n    _receiver: address = msg.sender,\r\n    _claim_admin_fees: bool = True,\r\n) -> uint256[N_COINS]:\r\n    \"\"\"\r\n    @notice Withdraw coins from the pool\r\n    @dev Withdrawal amounts are based on current deposit ratios\r\n    @param _burn_amount Quantity of LP tokens to burn in the withdrawal\r\n    @param _min_amounts Minimum amounts of underlying coins to receive\r\n    @param _receiver Address that receives the withdrawn coins\r\n    @return List of amounts of coins that were withdrawn\r\n    \"\"\"\r\n    total_supply: uint256 = self.total_supply\r\n    assert _burn_amount > 0  # dev: invalid _burn_amount\r\n    amounts: uint256[N_COINS] = empty(uint256[N_COINS])\r\n    balances: uint256[N_COINS] = self._balances()\r\n\r\n    value: uint256 = 0\r\n\r\n    for i in range(N_COINS_128):\r\n\r\n        value = unsafe_div(balances[i] * _burn_amount, total_supply)\r\n        assert value >= _min_amounts[i], \"Withdrawal resulted in fewer coins than expected\"\r\n        amounts[i] = value\r\n        self._transfer_out(i, value, _receiver)\r\n\r\n    self._burnFrom(msg.sender, _burn_amount)  # dev: insufficient funds\r\n\r\n    # --------------------------- Upkeep D_oracle ----------------------------\r\n\r\n    ma_last_time_unpacked: uint256[2] = self.unpack_2(self.ma_last_time)\r\n    last_D_packed_current: uint256 = self.last_D_packed\r\n    old_D: uint256 = last_D_packed_current & (2**128 - 1)\r\n\r\n    self.last_D_packed = self.pack_2(\r\n        old_D - unsafe_div(old_D * _burn_amount, total_supply),  # new_D = proportionally reduce D.\r\n        self._calc_moving_average(\r\n            last_D_packed_current,\r\n            self.D_ma_time,\r\n            ma_last_time_unpacked[1]\r\n        )\r\n    )\r\n\r\n    if ma_last_time_unpacked[1] < block.timestamp:\r\n        ma_last_time_unpacked[1] = block.timestamp\r\n        self.ma_last_time = self.pack_2(ma_last_time_unpacked[0], ma_last_time_unpacked[1])\r\n\r\n    # ------------------------------- Log event ------------------------------\r\n\r\n    log RemoveLiquidity(\r\n        msg.sender,\r\n        [amounts[0], amounts[1]],\r\n        empty(DynArray[uint256, MAX_COINS]),\r\n        unsafe_sub(total_supply, _burn_amount)\r\n    )\r\n\r\n    # ------- Withdraw admin fees if _claim_admin_fees is set to True --------\r\n\r\n    if _claim_admin_fees:\r\n        self._withdraw_admin_fees()\r\n\r\n    return [amounts[0], amounts[1]]\r\n\r\n\r\n@external\r\ndef withdraw_admin_fees():\r\n    \"\"\"\r\n    @notice Claim admin fees. Callable by anyone.\r\n    \"\"\"\r\n    self._withdraw_admin_fees()\r\n\r\n\r\n# ------------------------ AMM Internal Functions ----------------------------\r\n\r\n\r\n@view\r\n@internal\r\ndef _dynamic_fee(xpi: uint256, xpj: uint256, _fee: uint256) -> uint256:\r\n\r\n    _offpeg_fee_multiplier: uint256 = self.offpeg_fee_multiplier\r\n\r\n    # to remove dynamic fee: just set _offpeg_fee_multiplier less than FEE_DENOMINATOR\r\n    if _offpeg_fee_multiplier <= FEE_DENOMINATOR:\r\n        return _fee\r\n\r\n    xps2: uint256 = (xpi + xpj) ** 2\r\n    return unsafe_div(\r\n        unsafe_mul(_offpeg_fee_multiplier, _fee),\r\n        unsafe_add(\r\n            unsafe_sub(_offpeg_fee_multiplier, FEE_DENOMINATOR) * 4 * xpi * xpj / xps2,\r\n            FEE_DENOMINATOR\r\n        )\r\n    )\r\n\r\n\r\n@internal\r\ndef __exchange(\r\n    x: uint256,\r\n    _xp: uint256[N_COINS],\r\n    rates: uint256[N_COINS],\r\n    i: int128,\r\n    j: int128,\r\n) -> uint256:\r\n\r\n    amp: uint256 = self._A()\r\n    D: uint256 = math.get_D([_xp[0], _xp[1]], amp, N_COINS)\r\n    y: uint256 = math.get_y(i, j, x, [_xp[0], _xp[1]], amp, D, N_COINS)\r\n\r\n    dy: uint256 = _xp[j] - y - 1  # -1 just in case there were some rounding errors\r\n    dy_fee: uint256 = unsafe_div(\r\n        dy * self._dynamic_fee(\r\n            unsafe_div(_xp[i] + x, 2), unsafe_div(_xp[j] + y, 2), self.fee\r\n        ),\r\n        FEE_DENOMINATOR\r\n    )\r\n\r\n    # Convert all to real units\r\n    dy = (dy - dy_fee) * PRECISION / rates[j]\r\n\r\n    # admin_fee = dy_fee * admin_fee / FEE_DENOMINATOR\r\n    self.admin_balances[j] += unsafe_div(\r\n        unsafe_div(dy_fee * admin_fee, FEE_DENOMINATOR) * PRECISION,\r\n        rates[j]  # we can do unsafediv here because we did safediv before\r\n    )\r\n\r\n    # Calculate and store state prices:\r\n    xp: uint256[N_COINS] = _xp\r\n    xp[i] = x\r\n    xp[j] = y\r\n    # D is not changed because we did not apply a fee\r\n    self.upkeep_oracles(xp, amp, D)\r\n\r\n    return dy\r\n\r\n\r\n@internal\r\ndef _exchange(\r\n    sender: address,\r\n    i: int128,\r\n    j: int128,\r\n    _dx: uint256,\r\n    _min_dy: uint256,\r\n    receiver: address,\r\n    expect_optimistic_transfer: bool\r\n) -> uint256:\r\n\r\n    assert i != j  # dev: coin index out of range\r\n    assert _dx > 0  # dev: do not exchange 0 coins\r\n\r\n    rates: uint256[N_COINS] = self._stored_rates()\r\n    old_balances: uint256[N_COINS] = self._balances()\r\n    xp: uint256[N_COINS] = self._xp_mem(rates, old_balances)\r\n\r\n    # --------------------------- Do Transfer in -----------------------------\r\n\r\n    # `dx` is whatever the pool received after ERC20 transfer:\r\n    dx: uint256 = self._transfer_in(\r\n        i,\r\n        -1,\r\n        _dx,\r\n        sender,\r\n        expect_optimistic_transfer\r\n    )\r\n\r\n    # ------------------------------- Exchange -------------------------------\r\n\r\n    # xp[i] + dx * rates[i] / PRECISION\r\n    x: uint256 = xp[i] + unsafe_div(dx * rates[i], PRECISION)\r\n    dy: uint256 = self.__exchange(x, xp, rates, i, j)\r\n    assert dy >= _min_dy, \"Exchange resulted in fewer coins than expected\"\r\n\r\n    # --------------------------- Do Transfer out ----------------------------\r\n\r\n    self._transfer_out(j, dy, receiver)\r\n\r\n    # ------------------------------------------------------------------------\r\n\r\n    log TokenExchange(msg.sender, i, dx, j, dy)\r\n\r\n    return dy\r\n\r\n\r\n@internal\r\ndef _meta_add_liquidity(dx: uint256, base_i: int128) -> uint256:\r\n\r\n    if BASE_POOL_IS_NG:\r\n\r\n        base_inputs: DynArray[uint256, MAX_COINS] = empty(DynArray[uint256, MAX_COINS])\r\n        for i in range(BASE_N_COINS, bound=MAX_COINS):\r\n            if i == convert(base_i, uint256):\r\n                base_inputs.append(dx)\r\n            else:\r\n                base_inputs.append(0)\r\n        return StableSwapNG(BASE_POOL).add_liquidity(base_inputs, 0)\r\n\r\n    coin_i: address = coins[MAX_METAPOOL_COIN_INDEX]\r\n    x: uint256 = ERC20(coin_i).balanceOf(self)\r\n\r\n    if BASE_N_COINS == 2:\r\n\r\n        base_inputs: uint256[2] = empty(uint256[2])\r\n        base_inputs[base_i] = dx\r\n        StableSwap2(BASE_POOL).add_liquidity(base_inputs, 0)\r\n\r\n    if BASE_N_COINS == 3:\r\n\r\n        base_inputs: uint256[3] = empty(uint256[3])\r\n        base_inputs[base_i] = dx\r\n        StableSwap3(BASE_POOL).add_liquidity(base_inputs, 0)\r\n\r\n    return ERC20(coin_i).balanceOf(self) - x\r\n\r\n\r\n@internal\r\ndef _withdraw_admin_fees():\r\n\r\n    fee_receiver: address = factory.fee_receiver()\r\n    if fee_receiver == empty(address):\r\n        return  # Do nothing.\r\n\r\n    admin_balances: DynArray[uint256, MAX_COINS] = self.admin_balances\r\n    for i in range(N_COINS_128):\r\n\r\n        if admin_balances[i] > 0:\r\n            self._transfer_out(i, admin_balances[i], fee_receiver)\r\n\r\n    self.admin_balances = [0, 0]\r\n\r\n\r\n# --------------------------- AMM Math Functions -----------------------------\r\n\r\n\r\n@view\r\n@internal\r\ndef _A() -> uint256:\r\n    \"\"\"\r\n    Handle ramping A up or down\r\n    \"\"\"\r\n    t1: uint256 = self.future_A_time\r\n    A1: uint256 = self.future_A\r\n\r\n    if block.timestamp < t1:\r\n        A0: uint256 = self.initial_A\r\n        t0: uint256 = self.initial_A_time\r\n        # Expressions in uint256 cannot have negative numbers, thus \"if\"\r\n        if A1 > A0:\r\n            return A0 + unsafe_sub(A1, A0) * (block.timestamp - t0) / (t1 - t0)\r\n        else:\r\n            return A0 - unsafe_sub(A0, A1) * (block.timestamp - t0) / (t1 - t0)\r\n\r\n    else:  # when t1 == 0 or block.timestamp >= t1\r\n        return A1\r\n\r\n\r\n@pure\r\n@internal\r\ndef _xp_mem(_rates: uint256[N_COINS], _balances: uint256[N_COINS]) -> uint256[N_COINS]:\r\n\r\n    result: uint256[N_COINS] = empty(uint256[N_COINS])\r\n    for i in range(N_COINS_128):\r\n        # _rates[i] * _balances[i] / PRECISION\r\n        result[i] = unsafe_div(_rates[i] * _balances[i], PRECISION)\r\n\r\n    return result\r\n\r\n\r\n@view\r\n@internal\r\ndef get_D_mem(\r\n    _rates: uint256[N_COINS],\r\n    _balances: uint256[N_COINS],\r\n    _amp: uint256\r\n) -> uint256:\r\n    xp: uint256[N_COINS] = self._xp_mem(_rates, _balances)\r\n    return math.get_D([xp[0], xp[1]], _amp, N_COINS)\r\n\r\n\r\n@view\r\n@internal\r\ndef _calc_withdraw_one_coin(\r\n    _burn_amount: uint256,\r\n    i: int128\r\n) -> (\r\n    uint256,\r\n    uint256,\r\n    uint256[N_COINS],\r\n    uint256,\r\n    uint256\r\n):\r\n\r\n    # First, need to:\r\n    # * Get current D\r\n    # * Solve Eqn against y_i for D - _token_amount\r\n\r\n    # get pool state\r\n    amp: uint256 = self._A()\r\n    rates: uint256[N_COINS] = self._stored_rates()\r\n    xp: uint256[N_COINS] = self._xp_mem(rates, self._balances())\r\n    D0: uint256 = math.get_D([xp[0], xp[1]], amp, N_COINS)\r\n\r\n    total_supply: uint256 = self.total_supply\r\n    D1: uint256 = D0 - _burn_amount * D0 / total_supply\r\n    new_y: uint256 = math.get_y_D(amp, i, [xp[0], xp[1]], D1, N_COINS)\r\n\r\n    base_fee: uint256 = unsafe_div(unsafe_mul(self.fee, N_COINS), 4)\r\n    xp_reduced: uint256[N_COINS] = xp\r\n    # ys: uint256 = (D0 + D1) / (2 * N_COINS)\r\n    ys: uint256 = unsafe_div((D0 + D1), 4)\r\n    # base_fee: uint256 = self.fee * N_COINS / (4 * (N_COINS - 1))\r\n\r\n    dx_expected: uint256 = 0\r\n    xp_j: uint256 = 0\r\n    xavg: uint256 = 0\r\n    dynamic_fee: uint256 = 0\r\n\r\n    for j in range(N_COINS_128):\r\n\r\n        dx_expected = 0\r\n        xp_j = xp[j]\r\n        if j == i:\r\n            dx_expected = xp_j * D1 / D0 - new_y\r\n            xavg = unsafe_div(xp_j + new_y, 2)\r\n        else:\r\n            dx_expected = xp_j - xp_j * D1 / D0\r\n            xavg = xp_j\r\n\r\n        # xp_j - dynamic_fee * dx_expected / FEE_DENOMINATOR\r\n        dynamic_fee = self._dynamic_fee(xavg, ys, base_fee)\r\n        xp_reduced[j] = xp_j - unsafe_div(dynamic_fee * dx_expected, FEE_DENOMINATOR)\r\n\r\n    dy: uint256 = xp_reduced[i] - math.get_y_D(amp, i, [xp_reduced[0], xp_reduced[1]], D1, N_COINS)\r\n    dy_0: uint256 = (xp[i] - new_y) * PRECISION / rates[i]  # w/o fees\r\n    dy = unsafe_div((dy - 1) * PRECISION, rates[i])  # Withdraw less to account for rounding errors\r\n\r\n    # calculate state price\r\n    xp[i] = new_y\r\n\r\n    return dy, dy_0 - dy, xp, amp, D1\r\n\r\n\r\n# -------------------------- AMM Price Methods -------------------------------\r\n\r\n@pure\r\n@internal\r\ndef pack_2(p1: uint256, p2: uint256) -> uint256:\r\n    assert p1 < 2**128\r\n    assert p2 < 2**128\r\n    return p1 | (p2 << 128)\r\n\r\n\r\n@pure\r\n@internal\r\ndef unpack_2(packed: uint256) -> uint256[2]:\r\n    return [packed & (2**128 - 1), packed >> 128]\r\n\r\n\r\n@internal\r\n@pure\r\ndef _get_p(\r\n    xp: uint256[N_COINS],\r\n    amp: uint256,\r\n    D: uint256,\r\n) -> uint256:\r\n\r\n    # dx_0 / dx_1 only, however can have any number of coins in pool\r\n    ANN: uint256 = unsafe_mul(amp, N_COINS)\r\n    Dr: uint256 = unsafe_div(D, pow_mod256(N_COINS, N_COINS))\r\n\r\n    for i in range(N_COINS_128):\r\n        Dr = Dr * D / xp[i]\r\n\r\n    # ANN * xp[0] / A_PRECISION\r\n    xp0_A: uint256 = unsafe_div(ANN * xp[0], A_PRECISION)\r\n    return 10**18 * (xp0_A + unsafe_div(Dr * xp[0], xp[1])) / (xp0_A + Dr)\r\n\r\n\r\n@internal\r\ndef upkeep_oracles(xp: uint256[N_COINS], amp: uint256, D: uint256):\r\n    \"\"\"\r\n    @notice Upkeeps price and D oracles.\r\n    \"\"\"\r\n    ma_last_time_unpacked: uint256[2] = self.unpack_2(self.ma_last_time)\r\n    last_prices_packed_current: uint256 = self.last_prices_packed\r\n    last_prices_packed_new: uint256 = last_prices_packed_current\r\n\r\n    spot_price: uint256 = self._get_p(xp, amp, D)\r\n\r\n    # -------------------------- Upkeep price oracle -------------------------\r\n\r\n    # Metapools are always 2-coin pools, so we care about idx=0 only:\r\n    if spot_price != 0:\r\n\r\n        # Update packed prices -----------------\r\n        last_prices_packed_new = self.pack_2(\r\n            min(spot_price, 2 * 10**18),  # <----- Cap spot value by 2.\r\n            self._calc_moving_average(\r\n                last_prices_packed_current,\r\n                self.ma_exp_time,\r\n                ma_last_time_unpacked[0],  # index 0 is ma_exp_time for prices\r\n            )\r\n        )\r\n\r\n    self.last_prices_packed = last_prices_packed_new\r\n\r\n    # ---------------------------- Upkeep D oracle ---------------------------\r\n\r\n    self.last_D_packed = self.pack_2(\r\n        D,\r\n        self._calc_moving_average(\r\n            self.last_D_packed,\r\n            self.D_ma_time,\r\n            ma_last_time_unpacked[1],  # index 1 is ma_exp_time for D\r\n        )\r\n    )\r\n\r\n    # Housekeeping: Update ma_last_time for p and D oracles ------------------\r\n    for i in range(2):\r\n        if ma_last_time_unpacked[i] < block.timestamp:\r\n            ma_last_time_unpacked[i] = block.timestamp\r\n\r\n    self.ma_last_time = self.pack_2(ma_last_time_unpacked[0], ma_last_time_unpacked[1])\r\n\r\n\r\n@internal\r\n@view\r\ndef _calc_moving_average(\r\n    packed_value: uint256,\r\n    averaging_window: uint256,\r\n    ma_last_time: uint256\r\n) -> uint256:\r\n\r\n    last_spot_value: uint256 = packed_value & (2**128 - 1)\r\n    last_ema_value: uint256 = (packed_value >> 128)\r\n\r\n    if ma_last_time < block.timestamp:  # calculate new_ema_value and return that.\r\n        alpha: uint256 = math.exp(\r\n            -convert(\r\n                unsafe_div(unsafe_mul(unsafe_sub(block.timestamp, ma_last_time), 10**18), averaging_window), int256\r\n            )\r\n        )\r\n        return unsafe_div(last_spot_value * (10**18 - alpha) + last_ema_value * alpha, 10**18)\r\n\r\n    return last_ema_value\r\n\r\n\r\n@view\r\n@external\r\ndef last_price(i: uint256) -> uint256:\r\n    assert i == 0  # dev: metapools do not have last_price indices greater than 0.\r\n    return self.last_prices_packed & (2**128 - 1)\r\n\r\n\r\n@view\r\n@external\r\ndef ema_price(i: uint256) -> uint256:\r\n    assert i == 0  # dev: metapools do not have ema_price indices greater than 0.\r\n    return (self.last_prices_packed >> 128)\r\n\r\n\r\n@external\r\n@view\r\ndef get_p(i: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Returns the AMM State price of token\r\n    @dev if i = 0, it will return the state price of coin[1].\r\n    @param i index of state price (0 for coin[1], 1 for coin[2], ...)\r\n    @return uint256 The state price quoted by the AMM for coin[i+1]\r\n    \"\"\"\r\n    assert i == 0  # dev: metapools do not have get_p indices greater than 0.\r\n\r\n    amp: uint256 = self._A()\r\n    xp: uint256[N_COINS] = self._xp_mem(\r\n        self._stored_rates(), self._balances()\r\n    )\r\n    D: uint256 = math.get_D([xp[0], xp[1]], amp, N_COINS)\r\n    return self._get_p(xp, amp, D)\r\n\r\n\r\n@external\r\n@view\r\n@nonreentrant('lock')\r\ndef price_oracle(i: uint256) -> uint256:\r\n    assert i == 0  # dev: metapools do not have price_oracle indices greater than 0.\r\n    return self._calc_moving_average(\r\n        self.last_prices_packed,\r\n        self.ma_exp_time,\r\n        self.ma_last_time & (2**128 - 1),\r\n    )\r\n\r\n\r\n@external\r\n@view\r\n@nonreentrant('lock')\r\ndef D_oracle() -> uint256:\r\n    return self._calc_moving_average(\r\n        self.last_D_packed,\r\n        self.D_ma_time,\r\n        self.ma_last_time >> 128\r\n    )\r\n\r\n\r\n# ---------------------------- ERC20 Utils -----------------------------------\r\n\r\n\r\n@view\r\n@internal\r\ndef _domain_separator() -> bytes32:\r\n    if chain.id != CACHED_CHAIN_ID:\r\n        return keccak256(\r\n            _abi_encode(\r\n                EIP712_TYPEHASH,\r\n                NAME_HASH,\r\n                VERSION_HASH,\r\n                chain.id,\r\n                self,\r\n                salt,\r\n            )\r\n        )\r\n    return CACHED_DOMAIN_SEPARATOR\r\n\r\n\r\n@internal\r\ndef _transfer(_from: address, _to: address, _value: uint256):\r\n    # # NOTE: vyper does not allow underflows\r\n    # #       so the following subtraction would revert on insufficient balance\r\n    self.balanceOf[_from] -= _value\r\n    self.balanceOf[_to] += _value\r\n\r\n    log Transfer(_from, _to, _value)\r\n\r\n\r\n@internal\r\ndef _burnFrom(_from: address, _burn_amount: uint256):\r\n\r\n    self.total_supply -= _burn_amount\r\n    self.balanceOf[_from] -= _burn_amount\r\n    log Transfer(_from, empty(address), _burn_amount)\r\n\r\n\r\n@external\r\ndef transfer(_to : address, _value : uint256) -> bool:\r\n    \"\"\"\r\n    @dev Transfer token for a specified address\r\n    @param _to The address to transfer to.\r\n    @param _value The amount to be transferred.\r\n    \"\"\"\r\n    self._transfer(msg.sender, _to, _value)\r\n    return True\r\n\r\n\r\n@external\r\ndef transferFrom(_from : address, _to : address, _value : uint256) -> bool:\r\n    \"\"\"\r\n     @dev Transfer tokens from one address to another.\r\n     @param _from address The address which you want to send tokens from\r\n     @param _to address The address which you want to transfer to\r\n     @param _value uint256 the amount of tokens to be transferred\r\n    \"\"\"\r\n    self._transfer(_from, _to, _value)\r\n\r\n    _allowance: uint256 = self.allowance[_from][msg.sender]\r\n    if _allowance != max_value(uint256):\r\n        _new_allowance: uint256 = _allowance - _value\r\n        self.allowance[_from][msg.sender] = _new_allowance\r\n        log Approval(_from, msg.sender, _new_allowance)\r\n\r\n    return True\r\n\r\n\r\n@external\r\ndef approve(_spender : address, _value : uint256) -> bool:\r\n    \"\"\"\r\n    @notice Approve the passed address to transfer the specified amount of\r\n            tokens on behalf of msg.sender\r\n    @dev Beware that changing an allowance via this method brings the risk that\r\n         someone may use both the old and new allowance by unfortunate transaction\r\n         ordering: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n    @param _spender The address which will transfer the funds\r\n    @param _value The amount of tokens that may be transferred\r\n    @return bool success\r\n    \"\"\"\r\n    self.allowance[msg.sender][_spender] = _value\r\n\r\n    log Approval(msg.sender, _spender, _value)\r\n    return True\r\n\r\n\r\n@external\r\ndef permit(\r\n    _owner: address,\r\n    _spender: address,\r\n    _value: uint256,\r\n    _deadline: uint256,\r\n    _v: uint8,\r\n    _r: bytes32,\r\n    _s: bytes32\r\n) -> bool:\r\n    \"\"\"\r\n    @notice Approves spender by owner's signature to expend owner's tokens.\r\n        See https://eips.ethereum.org/EIPS/eip-2612.\r\n    @dev Inspired by https://github.com/yearn/yearn-vaults/blob/main/contracts/Vault.vy#L753-L793\r\n    @dev Supports smart contract wallets which implement ERC1271\r\n        https://eips.ethereum.org/EIPS/eip-1271\r\n    @param _owner The address which is a source of funds and has signed the Permit.\r\n    @param _spender The address which is allowed to spend the funds.\r\n    @param _value The amount of tokens to be spent.\r\n    @param _deadline The timestamp after which the Permit is no longer valid.\r\n    @param _v The bytes[64] of the valid secp256k1 signature of permit by owner\r\n    @param _r The bytes[0:32] of the valid secp256k1 signature of permit by owner\r\n    @param _s The bytes[32:64] of the valid secp256k1 signature of permit by owner\r\n    @return True, if transaction completes successfully\r\n    \"\"\"\r\n    assert _owner != empty(address)\r\n    assert block.timestamp <= _deadline\r\n\r\n    nonce: uint256 = self.nonces[_owner]\r\n    digest: bytes32 = keccak256(\r\n        concat(\r\n            b\"\\x19\\x01\",\r\n            self._domain_separator(),\r\n            keccak256(_abi_encode(EIP2612_TYPEHASH, _owner, _spender, _value, nonce, _deadline))\r\n        )\r\n    )\r\n\r\n    if _owner.is_contract:\r\n        sig: Bytes[65] = concat(_abi_encode(_r, _s), slice(convert(_v, bytes32), 31, 1))\r\n        # reentrancy not a concern since this is a staticcall\r\n        assert ERC1271(_owner).isValidSignature(digest, sig) == ERC1271_MAGIC_VAL\r\n    else:\r\n        assert ecrecover(digest, convert(_v, uint256), convert(_r, uint256), convert(_s, uint256)) == _owner\r\n\r\n    self.allowance[_owner][_spender] = _value\r\n    self.nonces[_owner] = unsafe_add(nonce, 1)\r\n\r\n    log Approval(_owner, _spender, _value)\r\n    return True\r\n\r\n\r\n@view\r\n@external\r\ndef DOMAIN_SEPARATOR() -> bytes32:\r\n    \"\"\"\r\n    @notice EIP712 domain separator.\r\n    @return bytes32 Domain Separator set for the current chain.\r\n    \"\"\"\r\n    return self._domain_separator()\r\n\r\n\r\n# ------------------------- AMM View Functions -------------------------------\r\n\r\n\r\n@view\r\n@external\r\ndef get_dx(i: int128, j: int128, dy: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Calculate the current input dx given output dy\r\n    @dev Index values can be found via the `coins` public getter method\r\n    @param i Index value for the coin to send\r\n    @param j Index value of the coin to receive\r\n    @param dy Amount of `j` being received after exchange\r\n    @return Amount of `i` predicted\r\n    \"\"\"\r\n    return StableSwapViews(factory.views_implementation()).get_dx(i, j, dy, self)\r\n\r\n\r\n@view\r\n@external\r\ndef get_dx_underlying(i: int128, j: int128, dy: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Calculate the current input dx given output dy\r\n    @dev Swap involves base pool tokens (either i or j should be 0);\r\n         If not, this method reverts.\r\n    @param i Index value for the coin to send\r\n    @param j Index value of the coin to receive\r\n    @param dy Amount of `j` being received after exchange\r\n    @return Amount of `i` predicted\r\n    \"\"\"\r\n    return StableSwapViews(factory.views_implementation()).get_dx_underlying(i, j, dy, self)\r\n\r\n\r\n@view\r\n@external\r\ndef get_dy(i: int128, j: int128, dx: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Calculate the current output dy given input dx\r\n    @dev Index values can be found via the `coins` public getter method\r\n    @param i Index value for the coin to send\r\n    @param j Index value of the coin to receive\r\n    @param dx Amount of `i` being exchanged\r\n    @return Amount of `j` predicted\r\n    \"\"\"\r\n    return StableSwapViews(factory.views_implementation()).get_dy(i, j, dx, self)\r\n\r\n\r\n@view\r\n@external\r\ndef get_dy_underlying(i: int128, j: int128, dx: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Calculate the current output dy given input dx\r\n    @dev Swap involves base pool tokens (either i or j should be 0);\r\n         If not, this method reverts.\r\n    @param i Index value for the coin to send\r\n    @param j Index value of the coin to receive\r\n    @param dx Amount of `i` being exchanged\r\n    @return Amount of `j` predicted\r\n    \"\"\"\r\n    return StableSwapViews(factory.views_implementation()).get_dy_underlying(i, j, dx, self)\r\n\r\n\r\n@view\r\n@external\r\ndef calc_withdraw_one_coin(_burn_amount: uint256, i: int128) -> uint256:\r\n    \"\"\"\r\n    @notice Calculate the amount received when withdrawing a single coin\r\n    @param _burn_amount Amount of LP tokens to burn in the withdrawal\r\n    @param i Index value of the coin to withdraw\r\n    @return Amount of coin received\r\n    \"\"\"\r\n    return self._calc_withdraw_one_coin(_burn_amount, i)[0]\r\n\r\n\r\n@view\r\n@external\r\n@nonreentrant('lock')\r\ndef totalSupply() -> uint256:\r\n    \"\"\"\r\n    @notice The total supply of pool LP tokens\r\n    @return self.total_supply, 18 decimals.\r\n    \"\"\"\r\n    return self.total_supply\r\n\r\n\r\n@view\r\n@external\r\n@nonreentrant('lock')\r\ndef get_virtual_price() -> uint256:\r\n    \"\"\"\r\n    @notice The current virtual price of the pool LP token\r\n    @dev Useful for calculating profits.\r\n         The method may be vulnerable to donation-style attacks if implementation\r\n         contains rebasing tokens. For integrators, caution is advised.\r\n    @return LP token virtual price normalized to 1e18\r\n    \"\"\"\r\n    xp: uint256[N_COINS] = self._xp_mem(self._stored_rates(), self._balances())\r\n    D: uint256 = math.get_D([xp[0], xp[1]], self._A(), N_COINS)\r\n    # D is in the units similar to DAI (e.g. converted to precision 1e18)\r\n    # When balanced, D = n * x_u - total virtual value of the portfolio\r\n    return D * PRECISION / self.total_supply\r\n\r\n\r\n@view\r\n@external\r\ndef calc_token_amount(\r\n    _amounts: uint256[N_COINS],\r\n    _is_deposit: bool\r\n) -> uint256:\r\n    \"\"\"\r\n    @notice Calculate addition or reduction in token supply from a deposit or withdrawal\r\n    @param _amounts Amount of each coin being deposited\r\n    @param _is_deposit set True for deposits, False for withdrawals\r\n    @return Expected amount of LP tokens received\r\n    \"\"\"\r\n    return StableSwapViews(factory.views_implementation()).calc_token_amount(\r\n        [_amounts[0], _amounts[1]],\r\n        _is_deposit,\r\n        self\r\n    )\r\n\r\n\r\n@view\r\n@external\r\ndef A() -> uint256:\r\n    return unsafe_div(self._A(), A_PRECISION)\r\n\r\n\r\n@view\r\n@external\r\ndef A_precise() -> uint256:\r\n    return self._A()\r\n\r\n\r\n@view\r\n@external\r\ndef balances(i: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Get the current balance of a coin within the\r\n            pool, less the accrued admin fees\r\n    @param i Index value for the coin to query balance of\r\n    @return Token balance\r\n    \"\"\"\r\n    return self._balances()[i]\r\n\r\n\r\n@view\r\n@external\r\ndef get_balances() -> DynArray[uint256, MAX_COINS]:\r\n    balances: uint256[N_COINS] = self._balances()\r\n    return [balances[0], balances[1]]\r\n\r\n\r\n@view\r\n@external\r\ndef stored_rates() -> DynArray[uint256, MAX_COINS]:\r\n    rates: uint256[N_COINS] = self._stored_rates()\r\n    return [rates[0], rates[1]]\r\n\r\n\r\n@view\r\n@external\r\ndef dynamic_fee(i: int128, j: int128) -> uint256:\r\n    \"\"\"\r\n    @notice Return the fee for swapping between `i` and `j`\r\n    @param i Index value for the coin to send\r\n    @param j Index value of the coin to receive\r\n    @return Swap fee expressed as an integer with 1e10 precision\r\n    \"\"\"\r\n    return StableSwapViews(factory.views_implementation()).dynamic_fee(i, j, self)\r\n\r\n\r\n# --------------------------- AMM Admin Functions ----------------------------\r\n\r\n\r\n@external\r\ndef ramp_A(_future_A: uint256, _future_time: uint256):\r\n    assert msg.sender == factory.admin()  # dev: only owner\r\n    assert block.timestamp >= self.initial_A_time + MIN_RAMP_TIME\r\n    assert _future_time >= block.timestamp + MIN_RAMP_TIME  # dev: insufficient time\r\n\r\n    _initial_A: uint256 = self._A()\r\n    _future_A_p: uint256 = _future_A * A_PRECISION\r\n\r\n    assert _future_A > 0 and _future_A < MAX_A\r\n    if _future_A_p < _initial_A:\r\n        assert _future_A_p * MAX_A_CHANGE >= _initial_A\r\n    else:\r\n        assert _future_A_p <= _initial_A * MAX_A_CHANGE\r\n\r\n    self.initial_A = _initial_A\r\n    self.future_A = _future_A_p\r\n    self.initial_A_time = block.timestamp\r\n    self.future_A_time = _future_time\r\n\r\n    log RampA(_initial_A, _future_A_p, block.timestamp, _future_time)\r\n\r\n\r\n@external\r\ndef stop_ramp_A():\r\n    assert msg.sender == factory.admin()  # dev: only owner\r\n\r\n    current_A: uint256 = self._A()\r\n    self.initial_A = current_A\r\n    self.future_A = current_A\r\n    self.initial_A_time = block.timestamp\r\n    self.future_A_time = block.timestamp\r\n    # now (block.timestamp < t1) is always False, so we return saved A\r\n\r\n    log StopRampA(current_A, block.timestamp)\r\n\r\n\r\n@external\r\ndef set_new_fee(_new_fee: uint256, _new_offpeg_fee_multiplier: uint256):\r\n\r\n    assert msg.sender == factory.admin()\r\n\r\n    # set new fee:\r\n    assert _new_fee <= MAX_FEE\r\n    self.fee = _new_fee\r\n\r\n    # set new offpeg_fee_multiplier:\r\n    assert _new_offpeg_fee_multiplier * _new_fee <= MAX_FEE * FEE_DENOMINATOR  # dev: offpeg multiplier exceeds maximum\r\n    self.offpeg_fee_multiplier = _new_offpeg_fee_multiplier\r\n\r\n    log ApplyNewFee(_new_fee, _new_offpeg_fee_multiplier)\r\n\r\n\r\n@external\r\ndef set_ma_exp_time(_ma_exp_time: uint256, _D_ma_time: uint256):\r\n    \"\"\"\r\n    @notice Set the moving average window of the price oracles.\r\n    @param _ma_exp_time Moving average window for the price oracle. It is time_in_seconds / ln(2).\r\n    @param _D_ma_time Moving average window for the D oracle. It is time_in_seconds / ln(2).\r\n    \"\"\"\r\n    assert msg.sender == factory.admin()  # dev: only owner\r\n    assert unsafe_mul(_ma_exp_time, _D_ma_time) > 0  # dev: 0 in input values\r\n\r\n    self.ma_exp_time = _ma_exp_time\r\n    self.D_ma_time = _D_ma_time\r\n\r\n    log SetNewMATime(_ma_exp_time, _D_ma_time)", "ABI": "[{\"name\":\"Transfer\",\"inputs\":[{\"name\":\"sender\",\"type\":\"address\",\"indexed\":true},{\"name\":\"receiver\",\"type\":\"address\",\"indexed\":true},{\"name\":\"value\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Approval\",\"inputs\":[{\"name\":\"owner\",\"type\":\"address\",\"indexed\":true},{\"name\":\"spender\",\"type\":\"address\",\"indexed\":true},{\"name\":\"value\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"TokenExchange\",\"inputs\":[{\"name\":\"buyer\",\"type\":\"address\",\"indexed\":true},{\"name\":\"sold_id\",\"type\":\"int128\",\"indexed\":false},{\"name\":\"tokens_sold\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"bought_id\",\"type\":\"int128\",\"indexed\":false},{\"name\":\"tokens_bought\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"TokenExchangeUnderlying\",\"inputs\":[{\"name\":\"buyer\",\"type\":\"address\",\"indexed\":true},{\"name\":\"sold_id\",\"type\":\"int128\",\"indexed\":false},{\"name\":\"tokens_sold\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"bought_id\",\"type\":\"int128\",\"indexed\":false},{\"name\":\"tokens_bought\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"AddLiquidity\",\"inputs\":[{\"name\":\"provider\",\"type\":\"address\",\"indexed\":true},{\"name\":\"token_amounts\",\"type\":\"uint256[]\",\"indexed\":false},{\"name\":\"fees\",\"type\":\"uint256[]\",\"indexed\":false},{\"name\":\"invariant\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"token_supply\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"RemoveLiquidity\",\"inputs\":[{\"name\":\"provider\",\"type\":\"address\",\"indexed\":true},{\"name\":\"token_amounts\",\"type\":\"uint256[]\",\"indexed\":false},{\"name\":\"fees\",\"type\":\"uint256[]\",\"indexed\":false},{\"name\":\"token_supply\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"RemoveLiquidityOne\",\"inputs\":[{\"name\":\"provider\",\"type\":\"address\",\"indexed\":true},{\"name\":\"token_id\",\"type\":\"int128\",\"indexed\":false},{\"name\":\"token_amount\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"coin_amount\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"token_supply\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"RemoveLiquidityImbalance\",\"inputs\":[{\"name\":\"provider\",\"type\":\"address\",\"indexed\":true},{\"name\":\"token_amounts\",\"type\":\"uint256[]\",\"indexed\":false},{\"name\":\"fees\",\"type\":\"uint256[]\",\"indexed\":false},{\"name\":\"invariant\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"token_supply\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"RampA\",\"inputs\":[{\"name\":\"old_A\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"new_A\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"initial_time\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"future_time\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"StopRampA\",\"inputs\":[{\"name\":\"A\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"t\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"ApplyNewFee\",\"inputs\":[{\"name\":\"fee\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"offpeg_fee_multiplier\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetNewMATime\",\"inputs\":[{\"name\":\"ma_exp_time\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"D_ma_time\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"constructor\",\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_symbol\",\"type\":\"string\"},{\"name\":\"_A\",\"type\":\"uint256\"},{\"name\":\"_fee\",\"type\":\"uint256\"},{\"name\":\"_offpeg_fee_multiplier\",\"type\":\"uint256\"},{\"name\":\"_ma_exp_time\",\"type\":\"uint256\"},{\"name\":\"_math_implementation\",\"type\":\"address\"},{\"name\":\"_base_pool\",\"type\":\"address\"},{\"name\":\"_coins\",\"type\":\"address[]\"},{\"name\":\"_base_coins\",\"type\":\"address[]\"},{\"name\":\"_rate_multipliers\",\"type\":\"uint256[]\"},{\"name\":\"_asset_types\",\"type\":\"uint8[]\"},{\"name\":\"_method_ids\",\"type\":\"bytes4[]\"},{\"name\":\"_oracles\",\"type\":\"address[]\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"exchange\",\"inputs\":[{\"name\":\"i\",\"type\":\"int128\"},{\"name\":\"j\",\"type\":\"int128\"},{\"name\":\"_dx\",\"type\":\"uint256\"},{\"name\":\"_min_dy\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"exchange\",\"inputs\":[{\"name\":\"i\",\"type\":\"int128\"},{\"name\":\"j\",\"type\":\"int128\"},{\"name\":\"_dx\",\"type\":\"uint256\"},{\"name\":\"_min_dy\",\"type\":\"uint256\"},{\"name\":\"_receiver\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"exchange_received\",\"inputs\":[{\"name\":\"i\",\"type\":\"int128\"},{\"name\":\"j\",\"type\":\"int128\"},{\"name\":\"_dx\",\"type\":\"uint256\"},{\"name\":\"_min_dy\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"exchange_received\",\"inputs\":[{\"name\":\"i\",\"type\":\"int128\"},{\"name\":\"j\",\"type\":\"int128\"},{\"name\":\"_dx\",\"type\":\"uint256\"},{\"name\":\"_min_dy\",\"type\":\"uint256\"},{\"name\":\"_receiver\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"exchange_underlying\",\"inputs\":[{\"name\":\"i\",\"type\":\"int128\"},{\"name\":\"j\",\"type\":\"int128\"},{\"name\":\"_dx\",\"type\":\"uint256\"},{\"name\":\"_min_dy\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"exchange_underlying\",\"inputs\":[{\"name\":\"i\",\"type\":\"int128\"},{\"name\":\"j\",\"type\":\"int128\"},{\"name\":\"_dx\",\"type\":\"uint256\"},{\"name\":\"_min_dy\",\"type\":\"uint256\"},{\"name\":\"_receiver\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"add_liquidity\",\"inputs\":[{\"name\":\"_amounts\",\"type\":\"uint256[2]\"},{\"name\":\"_min_mint_amount\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"add_liquidity\",\"inputs\":[{\"name\":\"_amounts\",\"type\":\"uint256[2]\"},{\"name\":\"_min_mint_amount\",\"type\":\"uint256\"},{\"name\":\"_receiver\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"remove_liquidity_one_coin\",\"inputs\":[{\"name\":\"_burn_amount\",\"type\":\"uint256\"},{\"name\":\"i\",\"type\":\"int128\"},{\"name\":\"_min_received\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"remove_liquidity_one_coin\",\"inputs\":[{\"name\":\"_burn_amount\",\"type\":\"uint256\"},{\"name\":\"i\",\"type\":\"int128\"},{\"name\":\"_min_received\",\"type\":\"uint256\"},{\"name\":\"_receiver\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"remove_liquidity_imbalance\",\"inputs\":[{\"name\":\"_amounts\",\"type\":\"uint256[2]\"},{\"name\":\"_max_burn_amount\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"remove_liquidity_imbalance\",\"inputs\":[{\"name\":\"_amounts\",\"type\":\"uint256[2]\"},{\"name\":\"_max_burn_amount\",\"type\":\"uint256\"},{\"name\":\"_receiver\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"remove_liquidity\",\"inputs\":[{\"name\":\"_burn_amount\",\"type\":\"uint256\"},{\"name\":\"_min_amounts\",\"type\":\"uint256[2]\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256[2]\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"remove_liquidity\",\"inputs\":[{\"name\":\"_burn_amount\",\"type\":\"uint256\"},{\"name\":\"_min_amounts\",\"type\":\"uint256[2]\"},{\"name\":\"_receiver\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256[2]\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"remove_liquidity\",\"inputs\":[{\"name\":\"_burn_amount\",\"type\":\"uint256\"},{\"name\":\"_min_amounts\",\"type\":\"uint256[2]\"},{\"name\":\"_receiver\",\"type\":\"address\"},{\"name\":\"_claim_admin_fees\",\"type\":\"bool\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256[2]\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"withdraw_admin_fees\",\"inputs\":[],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"last_price\",\"inputs\":[{\"name\":\"i\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"ema_price\",\"inputs\":[{\"name\":\"i\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_p\",\"inputs\":[{\"name\":\"i\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"price_oracle\",\"inputs\":[{\"name\":\"i\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"D_oracle\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"transfer\",\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"transferFrom\",\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"approve\",\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"permit\",\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_deadline\",\"type\":\"uint256\"},{\"name\":\"_v\",\"type\":\"uint8\"},{\"name\":\"_r\",\"type\":\"bytes32\"},{\"name\":\"_s\",\"type\":\"bytes32\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"DOMAIN_SEPARATOR\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_dx\",\"inputs\":[{\"name\":\"i\",\"type\":\"int128\"},{\"name\":\"j\",\"type\":\"int128\"},{\"name\":\"dy\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_dx_underlying\",\"inputs\":[{\"name\":\"i\",\"type\":\"int128\"},{\"name\":\"j\",\"type\":\"int128\"},{\"name\":\"dy\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_dy\",\"inputs\":[{\"name\":\"i\",\"type\":\"int128\"},{\"name\":\"j\",\"type\":\"int128\"},{\"name\":\"dx\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_dy_underlying\",\"inputs\":[{\"name\":\"i\",\"type\":\"int128\"},{\"name\":\"j\",\"type\":\"int128\"},{\"name\":\"dx\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"calc_withdraw_one_coin\",\"inputs\":[{\"name\":\"_burn_amount\",\"type\":\"uint256\"},{\"name\":\"i\",\"type\":\"int128\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"totalSupply\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_virtual_price\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"calc_token_amount\",\"inputs\":[{\"name\":\"_amounts\",\"type\":\"uint256[2]\"},{\"name\":\"_is_deposit\",\"type\":\"bool\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"A\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"A_precise\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"balances\",\"inputs\":[{\"name\":\"i\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_balances\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"stored_rates\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"dynamic_fee\",\"inputs\":[{\"name\":\"i\",\"type\":\"int128\"},{\"name\":\"j\",\"type\":\"int128\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"ramp_A\",\"inputs\":[{\"name\":\"_future_A\",\"type\":\"uint256\"},{\"name\":\"_future_time\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"stop_ramp_A\",\"inputs\":[],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_new_fee\",\"inputs\":[{\"name\":\"_new_fee\",\"type\":\"uint256\"},{\"name\":\"_new_offpeg_fee_multiplier\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_ma_exp_time\",\"inputs\":[{\"name\":\"_ma_exp_time\",\"type\":\"uint256\"},{\"name\":\"_D_ma_time\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"N_COINS\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"BASE_POOL\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"BASE_N_COINS\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"BASE_COINS\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"coins\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"fee\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"offpeg_fee_multiplier\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"admin_fee\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"initial_A\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"future_A\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"initial_A_time\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"future_A_time\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"admin_balances\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"ma_exp_time\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"D_ma_time\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"ma_last_time\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"name\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"string\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"symbol\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"string\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"decimals\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"version\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"string\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"balanceOf\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"allowance\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"},{\"name\":\"arg1\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"nonces\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"salt\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}]}]", "ContractName": "CurveStableSwapMetaNG", "CompilerVersion": "vyper:0.3.10", "OptimizationUsed": "0", "Runs": "0", "ConstructorArguments": "00000000000000000000000000000000000000000000000000000000000001c0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000001f400000000000000000000000000000000000000000000000000000000000f42400000000000000000000000000000000000000000000000000000000ba43b74000000000000000000000000000000000000000000000000000000000000000362000000000000000000000000c9cbc565a9f4120a2740ec6f64cc24aeb2bb3e5e000000000000000000000000bebc44782c7db0a1a60cb6fe97d0b483032ff1c7000000000000000000000000000000000000000000000000000000000000024000000000000000000000000000000000000000000000000000000000000002a000000000000000000000000000000000000000000000000000000000000003200000000000000000000000000000000000000000000000000000000000000380000000000000000000000000000000000000000000000000000000000000044000000000000000000000000000000000000000000000000000000000000004a00000000000000000000000000000000000000000000000000000000000000009555344562d3363727600000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008555344563363727600000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020000000000000000000000000e573ce2736dd9637a0b21058352e1667925c7a80000000000000000000000006c3f90f043a72fa612cbac8115ee7e52bde6e49000000000000000000000000000000000000000000000000000000000000000030000000000000000000000006b175474e89094c44da98b954eedeac495271d0f000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48000000000000000000000000dac17f958d2ee523a2206206994597c13d831ec70000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000c9f2c9cd04674edea400000000000000000000000000000000000000000000000000000000de0b6b3a7640000000000000000000000000000000000000000000000000000000000000000000500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": ""}