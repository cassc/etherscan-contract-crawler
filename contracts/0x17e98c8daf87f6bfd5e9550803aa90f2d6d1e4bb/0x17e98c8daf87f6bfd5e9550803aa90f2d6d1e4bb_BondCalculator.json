{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Bond/BondCalculator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n/**\\r\\n _____\\r\\n/  __ \\\\\\r\\n| /  \\\\/ ___  _ ____   _____ _ __ __ _  ___ _ __   ___ ___\\r\\n| |    / _ \\\\| '_ \\\\ \\\\ / / _ \\\\ '__/ _` |/ _ \\\\ '_ \\\\ / __/ _ \\\\\\r\\n| \\\\__/\\\\ (_) | | | \\\\ V /  __/ | | (_| |  __/ | | | (_|  __/\\r\\n \\\\____/\\\\___/|_| |_|\\\\_/ \\\\___|_|  \\\\__, |\\\\___|_| |_|\\\\___\\\\___|\\r\\n                                 __/ |\\r\\n                                |___/\\r\\n */\\r\\npragma solidity ^0.8.0;\\r\\nimport \\\"../libs/ABDKMathQuad.sol\\\";\\r\\n\\r\\ncontract BondCalculator {\\r\\n    using ABDKMathQuad for uint256;\\r\\n    using ABDKMathQuad for bytes16;\\r\\n\\r\\n    uint256 public constant TEN_POWER_6 = 10 ** 6;\\r\\n\\r\\n    /* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=\\r\\n                            TIME RATIO\\r\\n    =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-= */\\r\\n    /**\\r\\n     * @notice Compute the time ratio representing the progression on a bonding round => t/T in bytes16\\r\\n     * @param durationFromStart time in (s) since the creation of the bond\\r\\n     * @param totalDuration     expiry duration of the bond\\r\\n     * @return timeRatio t/T\\r\\n     */\\r\\n    function computeTimeRatio(uint256 durationFromStart, uint256 totalDuration) internal pure returns (bytes16) {\\r\\n        return ABDKMathQuad.fromUInt(durationFromStart).div(ABDKMathQuad.fromUInt(totalDuration));\\r\\n    }\\r\\n\\r\\n    function computeTimeRatioUInt(uint256 durationFromStart, uint256 totalDuration) public pure returns (uint256) {\\r\\n        return\\r\\n            ABDKMathQuad.toUInt(\\r\\n                computeTimeRatio(durationFromStart, totalDuration).mul(\\r\\n                    ABDKMathQuad.fromUInt(TEN_POWER_6) //10**6 TO GET PRECISION: 0.26 => 260000\\r\\n                )\\r\\n            );\\r\\n    }\\r\\n\\r\\n    /* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=\\r\\n                            CVG EXPECTED\\r\\n    =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-= */\\r\\n\\r\\n    /**\\r\\n     *  @notice Compute the expected CVG minted at this moment\\r\\n     *  @param durationFromStart of the computation\\r\\n     *  @param totalDuration     start time of the bonding contract\\r\\n     *  @param composedFunction  bonding computation type => sqrt, \u00b2, ln\\r\\n     *  @param totalOutToken     maxCvg that can be minted by the bonding contract\\r\\n     *  @return cvgExpected is the number of CVG that are expected to be minted through the bond\\r\\n     */\\r\\n    function computeCvgExpected(\\r\\n        uint256 durationFromStart,\\r\\n        uint256 totalDuration,\\r\\n        uint256 composedFunction,\\r\\n        uint256 totalOutToken\\r\\n    ) internal pure returns (bytes16 cvgExpected) {\\r\\n        bytes16 timeRatio = computeTimeRatio(durationFromStart, totalDuration);\\r\\n\\r\\n        if (composedFunction == 0) {\\r\\n            cvgExpected = ABDKMathQuad.sqrt(timeRatio);\\r\\n        } else if (composedFunction == 1) {\\r\\n            cvgExpected = ABDKMathQuad\\r\\n                .ln(timeRatio)\\r\\n                .div(ABDKMathQuad.ln(ABDKMathQuad.fromUInt(totalOutToken).div(ABDKMathQuad.fromUInt(10 ** 18))))\\r\\n                .add(ABDKMathQuad.fromUInt(1));\\r\\n            cvgExpected = ABDKMathQuad.toInt(cvgExpected) < 0 ? ABDKMathQuad.fromUInt(0) : cvgExpected;\\r\\n        } else if (composedFunction == 2) {\\r\\n            cvgExpected = timeRatio.mul(timeRatio);\\r\\n        } else {\\r\\n            cvgExpected = timeRatio;\\r\\n        }\\r\\n        cvgExpected = cvgExpected.mul(ABDKMathQuad.fromUInt(totalOutToken));\\r\\n        //10**6 TO GET PRECISION: 0.26 => 260000\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     *  @notice Compute the expected CVG minted at this moment\\r\\n     *  @return ntrNtcRatio uint256\\r\\n     */\\r\\n    function computeCvgExpectedUInt(\\r\\n        uint256 durationFromStart,\\r\\n        uint256 totalDuration,\\r\\n        uint256 composedFunction,\\r\\n        uint256 maxCvgToMint\\r\\n    ) public pure returns (uint256) {\\r\\n        return\\r\\n            ABDKMathQuad.toUInt(computeCvgExpected(durationFromStart, totalDuration, composedFunction, maxCvgToMint));\\r\\n    }\\r\\n\\r\\n    /* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=\\r\\n                        RATIO REAL EXPECTED\\r\\n    =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-= */\\r\\n\\r\\n    /**\\r\\n     * @notice Compute the time ratio representing the progression on a bonding round => t/T in bytes16\\r\\n     * @param durationFromStart time in (s) since the creation of the bond\\r\\n     * @param totalDuration     total duration in (s) of the bond\\r\\n     * @param composedFunction  bonding computation type => sqrt, \u00b2, ln\\r\\n     * @param totalOutToken     maxCvg that will be minted by the bonding contract\\r\\n     * @param soldTokenOut      cvg amount already sold since the beginning of the bond\\r\\n     * @return ntrNtcRatio uint256\\r\\n     */\\r\\n    function computeNtrDivNtc(\\r\\n        uint256 durationFromStart,\\r\\n        uint256 totalDuration,\\r\\n        uint256 composedFunction,\\r\\n        uint256 totalOutToken,\\r\\n        uint256 soldTokenOut\\r\\n    ) external pure returns (uint256) {\\r\\n        bytes16 cvgExpectedOnActualRound = computeCvgExpected(\\r\\n            durationFromStart,\\r\\n            totalDuration,\\r\\n            composedFunction,\\r\\n            totalOutToken\\r\\n        );\\r\\n        return\\r\\n            ABDKMathQuad.toInt(cvgExpectedOnActualRound) == 0\\r\\n                ? 0\\r\\n                : ABDKMathQuad.toUInt(ABDKMathQuad.fromUInt(soldTokenOut * TEN_POWER_6).div(cvgExpectedOnActualRound));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     *  @notice Compute Number of TokenReal/TokenExpected\\r\\n     *  @return ntrNtcRatio uint256\\r\\n     */\\r\\n    function _computeNtrDivNtc(\\r\\n        uint256 durationFromStart,\\r\\n        uint256 totalDuration,\\r\\n        uint256 composedFunction,\\r\\n        uint256 totalOutToken,\\r\\n        uint256 soldTokenOut\\r\\n    ) internal pure returns (uint256) {\\r\\n        bytes16 cvgExpectedOnActualRound = computeCvgExpected(\\r\\n            durationFromStart,\\r\\n            totalDuration,\\r\\n            composedFunction,\\r\\n            totalOutToken\\r\\n        );\\r\\n        return\\r\\n            ABDKMathQuad.toInt(cvgExpectedOnActualRound) == 0\\r\\n                ? 0\\r\\n                : ABDKMathQuad.toUInt(ABDKMathQuad.fromUInt(soldTokenOut * TEN_POWER_6).div(cvgExpectedOnActualRound));\\r\\n    }\\r\\n\\r\\n    /* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=\\r\\n                        ROI COMPUTATION\\r\\n    =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-= */\\r\\n\\r\\n    /**\\r\\n     * @notice Compute the time ratio representing the progression on a bonding round => t/T in bytes16\\r\\n     * @param durationFromStart time in (s) since the creation of the bond\\r\\n     * @param totalDuration     total duration in (s) of the bond\\r\\n     * @param composedFunction  bonding computation type => sqrt, \u00b2, ln\\r\\n     * @param totalOutToken     maxCvg that will be minted by the bonding contract\\r\\n     * @param amountTokenSold   cvg amount already sold since the beginning of the bond\\r\\n     * @param gamma             variable dividing the NTR/NTB.\\r\\n     * @param scale             % that is removed on the ROI each time the intRange increases\\r\\n     * @param minRoi            minimum ROI that the bond allows\\r\\n     * @param maxRoi            maximum ROI that the bond allows\\r\\n     * @return roi uint256\\r\\n     */\\r\\n    function computeRoi(\\r\\n        uint256 durationFromStart,\\r\\n        uint256 totalDuration,\\r\\n        uint256 composedFunction,\\r\\n        uint256 totalOutToken,\\r\\n        uint256 amountTokenSold,\\r\\n        uint256 gamma,\\r\\n        uint256 scale,\\r\\n        uint256 minRoi,\\r\\n        uint256 maxRoi\\r\\n    ) external pure returns (uint256) {\\r\\n        uint256 percentageReduction = (_computeNtrDivNtc(\\r\\n            durationFromStart,\\r\\n            totalDuration,\\r\\n            composedFunction,\\r\\n            totalOutToken,\\r\\n            amountTokenSold\\r\\n        ) / gamma) * scale; // euclidean division here, we keep only the full number 4.8888 => 4\\r\\n\\r\\n        if (percentageReduction >= (maxRoi - minRoi)) {\\r\\n            return minRoi;\\r\\n        } else {\\r\\n            return maxRoi - percentageReduction;\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/libs/ABDKMathQuad.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-4-Clause\\r\\n/*\\r\\n * ABDK Math Quad Smart Contract Library.  Copyright \u00a9 2019 by ABDK Consulting.\\r\\n * Author: Mikhail Vladimirov <mikhail.vladimirov@gmail.com>\\r\\n */\\r\\npragma solidity ^0.8.17;\\r\\n\\r\\n/**\\r\\n * Smart contract library of mathematical functions operating with IEEE 754\\r\\n * quadruple-precision binary floating-point numbers (quadruple precision\\r\\n * numbers).  As long as quadruple precision numbers are 16-bytes long, they are\\r\\n * represented by bytes16 type.\\r\\n */\\r\\nlibrary ABDKMathQuad {\\r\\n    /*\\r\\n     * 0.\\r\\n     */\\r\\n    bytes16 private constant POSITIVE_ZERO = 0x00000000000000000000000000000000;\\r\\n\\r\\n    /*\\r\\n     * -0.\\r\\n     */\\r\\n    bytes16 private constant NEGATIVE_ZERO = 0x80000000000000000000000000000000;\\r\\n\\r\\n    /*\\r\\n     * +Infinity.\\r\\n     */\\r\\n    bytes16 private constant POSITIVE_INFINITY = 0x7FFF0000000000000000000000000000;\\r\\n\\r\\n    /*\\r\\n     * -Infinity.\\r\\n     */\\r\\n    bytes16 private constant NEGATIVE_INFINITY = 0xFFFF0000000000000000000000000000;\\r\\n\\r\\n    /*\\r\\n     * Canonical NaN value.\\r\\n     */\\r\\n    bytes16 private constant NaN = 0x7FFF8000000000000000000000000000;\\r\\n\\r\\n    /**\\r\\n     * Convert signed 256-bit integer number into quadruple precision number.\\r\\n     *\\r\\n     * @param x signed 256-bit integer number\\r\\n     * @return quadruple precision number\\r\\n     */\\r\\n    function fromInt(int256 x) internal pure returns (bytes16) {\\r\\n        unchecked {\\r\\n            if (x == 0) return bytes16(0);\\r\\n            else {\\r\\n                // We rely on overflow behavior here\\r\\n                uint256 result = uint256(x > 0 ? x : -x);\\r\\n\\r\\n                uint256 msb = mostSignificantBit(result);\\r\\n                if (msb < 112) result <<= 112 - msb;\\r\\n                else if (msb > 112) result >>= msb - 112;\\r\\n\\r\\n                result = (result & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF) | ((16383 + msb) << 112);\\r\\n                if (x < 0) result |= 0x80000000000000000000000000000000;\\r\\n\\r\\n                return bytes16(uint128(result));\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Convert quadruple precision number into signed 256-bit integer number\\r\\n     * rounding towards zero.  Revert on overflow.\\r\\n     *\\r\\n     * @param x quadruple precision number\\r\\n     * @return signed 256-bit integer number\\r\\n     */\\r\\n    function toInt(bytes16 x) internal pure returns (int256) {\\r\\n        unchecked {\\r\\n            uint256 exponent = (uint128(x) >> 112) & 0x7FFF;\\r\\n\\r\\n            require(exponent <= 16638); // Overflow\\r\\n            if (exponent < 16383) return 0; // Underflow\\r\\n\\r\\n            uint256 result = (uint256(uint128(x)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF) | 0x10000000000000000000000000000;\\r\\n\\r\\n            if (exponent < 16495) result >>= 16495 - exponent;\\r\\n            else if (exponent > 16495) result <<= exponent - 16495;\\r\\n\\r\\n            if (uint128(x) >= 0x80000000000000000000000000000000) {\\r\\n                // Negative\\r\\n                require(result <= 0x8000000000000000000000000000000000000000000000000000000000000000);\\r\\n                return -int256(result); // We rely on overflow behavior here\\r\\n            } else {\\r\\n                require(result <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\r\\n                return int256(result);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Convert unsigned 256-bit integer number into quadruple precision number.\\r\\n     *\\r\\n     * @param x unsigned 256-bit integer number\\r\\n     * @return quadruple precision number\\r\\n     */\\r\\n    function fromUInt(uint256 x) internal pure returns (bytes16) {\\r\\n        unchecked {\\r\\n            if (x == 0) return bytes16(0);\\r\\n            else {\\r\\n                uint256 result = x;\\r\\n\\r\\n                uint256 msb = mostSignificantBit(result);\\r\\n                if (msb < 112) result <<= 112 - msb;\\r\\n                else if (msb > 112) result >>= msb - 112;\\r\\n\\r\\n                result = (result & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF) | ((16383 + msb) << 112);\\r\\n\\r\\n                return bytes16(uint128(result));\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Convert quadruple precision number into unsigned 256-bit integer number\\r\\n     * rounding towards zero.  Revert on underflow.  Note, that negative floating\\r\\n     * point numbers in range (-1.0 .. 0.0) may be converted to unsigned integer\\r\\n     * without error, because they are rounded to zero.\\r\\n     *\\r\\n     * @param x quadruple precision number\\r\\n     * @return unsigned 256-bit integer number\\r\\n     */\\r\\n    function toUInt(bytes16 x) internal pure returns (uint256) {\\r\\n        unchecked {\\r\\n            uint256 exponent = (uint128(x) >> 112) & 0x7FFF;\\r\\n\\r\\n            if (exponent < 16383) return 0; // Underflow\\r\\n\\r\\n            require(uint128(x) < 0x80000000000000000000000000000000); // Negative\\r\\n\\r\\n            require(exponent <= 16638); // Overflow\\r\\n            uint256 result = (uint256(uint128(x)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF) | 0x10000000000000000000000000000;\\r\\n\\r\\n            if (exponent < 16495) result >>= 16495 - exponent;\\r\\n            else if (exponent > 16495) result <<= exponent - 16495;\\r\\n\\r\\n            return result;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Convert signed 128.128 bit fixed point number into quadruple precision\\r\\n     * number.\\r\\n     *\\r\\n     * @param x signed 128.128 bit fixed point number\\r\\n     * @return quadruple precision number\\r\\n     */\\r\\n    function from128x128(int256 x) internal pure returns (bytes16) {\\r\\n        unchecked {\\r\\n            if (x == 0) return bytes16(0);\\r\\n            else {\\r\\n                // We rely on overflow behavior here\\r\\n                uint256 result = uint256(x > 0 ? x : -x);\\r\\n\\r\\n                uint256 msb = mostSignificantBit(result);\\r\\n                if (msb < 112) result <<= 112 - msb;\\r\\n                else if (msb > 112) result >>= msb - 112;\\r\\n\\r\\n                result = (result & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF) | ((16255 + msb) << 112);\\r\\n                if (x < 0) result |= 0x80000000000000000000000000000000;\\r\\n\\r\\n                return bytes16(uint128(result));\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Convert quadruple precision number into signed 128.128 bit fixed point\\r\\n     * number.  Revert on overflow.\\r\\n     *\\r\\n     * @param x quadruple precision number\\r\\n     * @return signed 128.128 bit fixed point number\\r\\n     */\\r\\n    function to128x128(bytes16 x) internal pure returns (int256) {\\r\\n        unchecked {\\r\\n            uint256 exponent = (uint128(x) >> 112) & 0x7FFF;\\r\\n\\r\\n            require(exponent <= 16510); // Overflow\\r\\n            if (exponent < 16255) return 0; // Underflow\\r\\n\\r\\n            uint256 result = (uint256(uint128(x)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF) | 0x10000000000000000000000000000;\\r\\n\\r\\n            if (exponent < 16367) result >>= 16367 - exponent;\\r\\n            else if (exponent > 16367) result <<= exponent - 16367;\\r\\n\\r\\n            if (uint128(x) >= 0x80000000000000000000000000000000) {\\r\\n                // Negative\\r\\n                require(result <= 0x8000000000000000000000000000000000000000000000000000000000000000);\\r\\n                return -int256(result); // We rely on overflow behavior here\\r\\n            } else {\\r\\n                require(result <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\r\\n                return int256(result);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Convert signed 64.64 bit fixed point number into quadruple precision\\r\\n     * number.\\r\\n     *\\r\\n     * @param x signed 64.64 bit fixed point number\\r\\n     * @return quadruple precision number\\r\\n     */\\r\\n    function from64x64(int128 x) internal pure returns (bytes16) {\\r\\n        unchecked {\\r\\n            if (x == 0) return bytes16(0);\\r\\n            else {\\r\\n                // We rely on overflow behavior here\\r\\n                uint256 result = uint128(x > 0 ? x : -x);\\r\\n\\r\\n                uint256 msb = mostSignificantBit(result);\\r\\n                if (msb < 112) result <<= 112 - msb;\\r\\n                else if (msb > 112) result >>= msb - 112;\\r\\n\\r\\n                result = (result & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF) | ((16319 + msb) << 112);\\r\\n                if (x < 0) result |= 0x80000000000000000000000000000000;\\r\\n\\r\\n                return bytes16(uint128(result));\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Convert quadruple precision number into signed 64.64 bit fixed point\\r\\n     * number.  Revert on overflow.\\r\\n     *\\r\\n     * @param x quadruple precision number\\r\\n     * @return signed 64.64 bit fixed point number\\r\\n     */\\r\\n    function to64x64(bytes16 x) internal pure returns (int128) {\\r\\n        unchecked {\\r\\n            uint256 exponent = (uint128(x) >> 112) & 0x7FFF;\\r\\n\\r\\n            require(exponent <= 16446); // Overflow\\r\\n            if (exponent < 16319) return 0; // Underflow\\r\\n\\r\\n            uint256 result = (uint256(uint128(x)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF) | 0x10000000000000000000000000000;\\r\\n\\r\\n            if (exponent < 16431) result >>= 16431 - exponent;\\r\\n            else if (exponent > 16431) result <<= exponent - 16431;\\r\\n\\r\\n            if (uint128(x) >= 0x80000000000000000000000000000000) {\\r\\n                // Negative\\r\\n                require(result <= 0x80000000000000000000000000000000);\\r\\n                return -int128(int256(result)); // We rely on overflow behavior here\\r\\n            } else {\\r\\n                require(result <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\r\\n                return int128(int256(result));\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Convert octuple precision number into quadruple precision number.\\r\\n     *\\r\\n     * @param x octuple precision number\\r\\n     * @return quadruple precision number\\r\\n     */\\r\\n    function fromOctuple(bytes32 x) internal pure returns (bytes16) {\\r\\n        unchecked {\\r\\n            bool negative = x & 0x8000000000000000000000000000000000000000000000000000000000000000 > 0;\\r\\n\\r\\n            uint256 exponent = (uint256(x) >> 236) & 0x7FFFF;\\r\\n            uint256 significand = uint256(x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\r\\n\\r\\n            if (exponent == 0x7FFFF) {\\r\\n                if (significand > 0) return NaN;\\r\\n                else return negative ? NEGATIVE_INFINITY : POSITIVE_INFINITY;\\r\\n            }\\r\\n\\r\\n            if (exponent > 278526) return negative ? NEGATIVE_INFINITY : POSITIVE_INFINITY;\\r\\n            else if (exponent < 245649) return negative ? NEGATIVE_ZERO : POSITIVE_ZERO;\\r\\n            else if (exponent < 245761) {\\r\\n                significand =\\r\\n                    (significand | 0x100000000000000000000000000000000000000000000000000000000000) >>\\r\\n                    (245885 - exponent);\\r\\n                exponent = 0;\\r\\n            } else {\\r\\n                significand >>= 124;\\r\\n                exponent -= 245760;\\r\\n            }\\r\\n\\r\\n            uint128 result = uint128(significand | (exponent << 112));\\r\\n            if (negative) result |= 0x80000000000000000000000000000000;\\r\\n\\r\\n            return bytes16(result);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Convert quadruple precision number into octuple precision number.\\r\\n     *\\r\\n     * @param x quadruple precision number\\r\\n     * @return octuple precision number\\r\\n     */\\r\\n    function toOctuple(bytes16 x) internal pure returns (bytes32) {\\r\\n        unchecked {\\r\\n            uint256 exponent = (uint128(x) >> 112) & 0x7FFF;\\r\\n\\r\\n            uint256 result = uint128(x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\r\\n\\r\\n            if (exponent == 0x7FFF)\\r\\n                exponent = 0x7FFFF; // Infinity or NaN\\r\\n            else if (exponent == 0) {\\r\\n                if (result > 0) {\\r\\n                    uint256 msb = mostSignificantBit(result);\\r\\n                    result = (result << (236 - msb)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\r\\n                    exponent = 245649 + msb;\\r\\n                }\\r\\n            } else {\\r\\n                result <<= 124;\\r\\n                exponent += 245760;\\r\\n            }\\r\\n\\r\\n            result |= exponent << 236;\\r\\n            if (uint128(x) >= 0x80000000000000000000000000000000)\\r\\n                result |= 0x8000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\r\\n            return bytes32(result);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Convert double precision number into quadruple precision number.\\r\\n     *\\r\\n     * @param x double precision number\\r\\n     * @return quadruple precision number\\r\\n     */\\r\\n    function fromDouble(bytes8 x) internal pure returns (bytes16) {\\r\\n        unchecked {\\r\\n            uint256 exponent = (uint64(x) >> 52) & 0x7FF;\\r\\n\\r\\n            uint256 result = uint64(x) & 0xFFFFFFFFFFFFF;\\r\\n\\r\\n            if (exponent == 0x7FF)\\r\\n                exponent = 0x7FFF; // Infinity or NaN\\r\\n            else if (exponent == 0) {\\r\\n                if (result > 0) {\\r\\n                    uint256 msb = mostSignificantBit(result);\\r\\n                    result = (result << (112 - msb)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\r\\n                    exponent = 15309 + msb;\\r\\n                }\\r\\n            } else {\\r\\n                result <<= 60;\\r\\n                exponent += 15360;\\r\\n            }\\r\\n\\r\\n            result |= exponent << 112;\\r\\n            if (x & 0x8000000000000000 > 0) result |= 0x80000000000000000000000000000000;\\r\\n\\r\\n            return bytes16(uint128(result));\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Convert quadruple precision number into double precision number.\\r\\n     *\\r\\n     * @param x quadruple precision number\\r\\n     * @return double precision number\\r\\n     */\\r\\n    function toDouble(bytes16 x) internal pure returns (bytes8) {\\r\\n        unchecked {\\r\\n            bool negative = uint128(x) >= 0x80000000000000000000000000000000;\\r\\n\\r\\n            uint256 exponent = (uint128(x) >> 112) & 0x7FFF;\\r\\n            uint256 significand = uint128(x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\r\\n\\r\\n            if (exponent == 0x7FFF) {\\r\\n                if (significand > 0) return 0x7FF8000000000000;\\r\\n                // NaN\\r\\n                else\\r\\n                    return\\r\\n                        negative\\r\\n                            ? bytes8(0xFFF0000000000000) // -Infinity\\r\\n                            : bytes8(0x7FF0000000000000); // Infinity\\r\\n            }\\r\\n\\r\\n            if (exponent > 17406)\\r\\n                return\\r\\n                    negative\\r\\n                        ? bytes8(0xFFF0000000000000) // -Infinity\\r\\n                        : bytes8(0x7FF0000000000000);\\r\\n            // Infinity\\r\\n            else if (exponent < 15309)\\r\\n                return\\r\\n                    negative\\r\\n                        ? bytes8(0x8000000000000000) // -0\\r\\n                        : bytes8(0x0000000000000000);\\r\\n            // 0\\r\\n            else if (exponent < 15361) {\\r\\n                significand = (significand | 0x10000000000000000000000000000) >> (15421 - exponent);\\r\\n                exponent = 0;\\r\\n            } else {\\r\\n                significand >>= 60;\\r\\n                exponent -= 15360;\\r\\n            }\\r\\n\\r\\n            uint64 result = uint64(significand | (exponent << 52));\\r\\n            if (negative) result |= 0x8000000000000000;\\r\\n\\r\\n            return bytes8(result);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Test whether given quadruple precision number is NaN.\\r\\n     *\\r\\n     * @param x quadruple precision number\\r\\n     * @return true if x is NaN, false otherwise\\r\\n     */\\r\\n    function isNaN(bytes16 x) internal pure returns (bool) {\\r\\n        unchecked {\\r\\n            return uint128(x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF > 0x7FFF0000000000000000000000000000;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Test whether given quadruple precision number is positive or negative\\r\\n     * infinity.\\r\\n     *\\r\\n     * @param x quadruple precision number\\r\\n     * @return true if x is positive or negative infinity, false otherwise\\r\\n     */\\r\\n    function isInfinity(bytes16 x) internal pure returns (bool) {\\r\\n        unchecked {\\r\\n            return uint128(x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0x7FFF0000000000000000000000000000;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Calculate sign of x, i.e. -1 if x is negative, 0 if x if zero, and 1 if x\\r\\n     * is positive.  Note that sign (-0) is zero.  Revert if x is NaN.\\r\\n     *\\r\\n     * @param x quadruple precision number\\r\\n     * @return sign of x\\r\\n     */\\r\\n    function sign(bytes16 x) internal pure returns (int8) {\\r\\n        unchecked {\\r\\n            uint128 absoluteX = uint128(x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\r\\n\\r\\n            require(absoluteX <= 0x7FFF0000000000000000000000000000); // Not NaN\\r\\n\\r\\n            if (absoluteX == 0) return 0;\\r\\n            else if (uint128(x) >= 0x80000000000000000000000000000000) return -1;\\r\\n            else return 1;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Calculate sign (x - y).  Revert if either argument is NaN, or both\\r\\n     * arguments are infinities of the same sign.\\r\\n     *\\r\\n     * @param x quadruple precision number\\r\\n     * @param y quadruple precision number\\r\\n     * @return sign (x - y)\\r\\n     */\\r\\n    function cmp(bytes16 x, bytes16 y) internal pure returns (int8) {\\r\\n        unchecked {\\r\\n            uint128 absoluteX = uint128(x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\r\\n\\r\\n            require(absoluteX <= 0x7FFF0000000000000000000000000000); // Not NaN\\r\\n\\r\\n            uint128 absoluteY = uint128(y) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\r\\n\\r\\n            require(absoluteY <= 0x7FFF0000000000000000000000000000); // Not NaN\\r\\n\\r\\n            // Not infinities of the same sign\\r\\n            require(x != y || absoluteX < 0x7FFF0000000000000000000000000000);\\r\\n\\r\\n            if (x == y) return 0;\\r\\n            else {\\r\\n                bool negativeX = uint128(x) >= 0x80000000000000000000000000000000;\\r\\n                bool negativeY = uint128(y) >= 0x80000000000000000000000000000000;\\r\\n\\r\\n                if (negativeX) {\\r\\n                    if (negativeY) return absoluteX > absoluteY ? -1 : int8(1);\\r\\n                    else return -1;\\r\\n                } else {\\r\\n                    if (negativeY) return 1;\\r\\n                    else return absoluteX > absoluteY ? int8(1) : -1;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Test whether x equals y.  NaN, infinity, and -infinity are not equal to\\r\\n     * anything.\\r\\n     *\\r\\n     * @param x quadruple precision number\\r\\n     * @param y quadruple precision number\\r\\n     * @return true if x equals to y, false otherwise\\r\\n     */\\r\\n    function eq(bytes16 x, bytes16 y) internal pure returns (bool) {\\r\\n        unchecked {\\r\\n            if (x == y) {\\r\\n                return uint128(x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF < 0x7FFF0000000000000000000000000000;\\r\\n            } else return false;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Calculate x + y.  Special values behave in the following way:\\r\\n     *\\r\\n     * NaN + x = NaN for any x.\\r\\n     * Infinity + x = Infinity for any finite x.\\r\\n     * -Infinity + x = -Infinity for any finite x.\\r\\n     * Infinity + Infinity = Infinity.\\r\\n     * -Infinity + -Infinity = -Infinity.\\r\\n     * Infinity + -Infinity = -Infinity + Infinity = NaN.\\r\\n     *\\r\\n     * @param x quadruple precision number\\r\\n     * @param y quadruple precision number\\r\\n     * @return quadruple precision number\\r\\n     */\\r\\n    function add(bytes16 x, bytes16 y) internal pure returns (bytes16) {\\r\\n        unchecked {\\r\\n            uint256 xExponent = (uint128(x) >> 112) & 0x7FFF;\\r\\n            uint256 yExponent = (uint128(y) >> 112) & 0x7FFF;\\r\\n\\r\\n            if (xExponent == 0x7FFF) {\\r\\n                if (yExponent == 0x7FFF) {\\r\\n                    if (x == y) return x;\\r\\n                    else return NaN;\\r\\n                } else return x;\\r\\n            } else if (yExponent == 0x7FFF) return y;\\r\\n            else {\\r\\n                bool xSign = uint128(x) >= 0x80000000000000000000000000000000;\\r\\n                uint256 xSignifier = uint128(x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\r\\n                if (xExponent == 0) xExponent = 1;\\r\\n                else xSignifier |= 0x10000000000000000000000000000;\\r\\n\\r\\n                bool ySign = uint128(y) >= 0x80000000000000000000000000000000;\\r\\n                uint256 ySignifier = uint128(y) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\r\\n                if (yExponent == 0) yExponent = 1;\\r\\n                else ySignifier |= 0x10000000000000000000000000000;\\r\\n\\r\\n                if (xSignifier == 0) return y == NEGATIVE_ZERO ? POSITIVE_ZERO : y;\\r\\n                else if (ySignifier == 0) return x == NEGATIVE_ZERO ? POSITIVE_ZERO : x;\\r\\n                else {\\r\\n                    int256 delta = int256(xExponent) - int256(yExponent);\\r\\n\\r\\n                    if (xSign == ySign) {\\r\\n                        if (delta > 112) return x;\\r\\n                        else if (delta > 0) ySignifier >>= uint256(delta);\\r\\n                        else if (delta < -112) return y;\\r\\n                        else if (delta < 0) {\\r\\n                            xSignifier >>= uint256(-delta);\\r\\n                            xExponent = yExponent;\\r\\n                        }\\r\\n\\r\\n                        xSignifier += ySignifier;\\r\\n\\r\\n                        if (xSignifier >= 0x20000000000000000000000000000) {\\r\\n                            xSignifier >>= 1;\\r\\n                            xExponent += 1;\\r\\n                        }\\r\\n\\r\\n                        if (xExponent == 0x7FFF) return xSign ? NEGATIVE_INFINITY : POSITIVE_INFINITY;\\r\\n                        else {\\r\\n                            if (xSignifier < 0x10000000000000000000000000000) xExponent = 0;\\r\\n                            else xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\r\\n\\r\\n                            return\\r\\n                                bytes16(\\r\\n                                    uint128(\\r\\n                                        (xSign ? 0x80000000000000000000000000000000 : 0) |\\r\\n                                            (xExponent << 112) |\\r\\n                                            xSignifier\\r\\n                                    )\\r\\n                                );\\r\\n                        }\\r\\n                    } else {\\r\\n                        if (delta > 0) {\\r\\n                            xSignifier <<= 1;\\r\\n                            xExponent -= 1;\\r\\n                        } else if (delta < 0) {\\r\\n                            ySignifier <<= 1;\\r\\n                            xExponent = yExponent - 1;\\r\\n                        }\\r\\n\\r\\n                        if (delta > 112) ySignifier = 1;\\r\\n                        else if (delta > 1) ySignifier = ((ySignifier - 1) >> uint256(delta - 1)) + 1;\\r\\n                        else if (delta < -112) xSignifier = 1;\\r\\n                        else if (delta < -1) xSignifier = ((xSignifier - 1) >> uint256(-delta - 1)) + 1;\\r\\n\\r\\n                        if (xSignifier >= ySignifier) xSignifier -= ySignifier;\\r\\n                        else {\\r\\n                            xSignifier = ySignifier - xSignifier;\\r\\n                            xSign = ySign;\\r\\n                        }\\r\\n\\r\\n                        if (xSignifier == 0) return POSITIVE_ZERO;\\r\\n\\r\\n                        uint256 msb = mostSignificantBit(xSignifier);\\r\\n\\r\\n                        if (msb == 113) {\\r\\n                            xSignifier = (xSignifier >> 1) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\r\\n                            xExponent += 1;\\r\\n                        } else if (msb < 112) {\\r\\n                            uint256 shift = 112 - msb;\\r\\n                            if (xExponent > shift) {\\r\\n                                xSignifier = (xSignifier << shift) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\r\\n                                xExponent -= shift;\\r\\n                            } else {\\r\\n                                xSignifier <<= xExponent - 1;\\r\\n                                xExponent = 0;\\r\\n                            }\\r\\n                        } else xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\r\\n\\r\\n                        if (xExponent == 0x7FFF) return xSign ? NEGATIVE_INFINITY : POSITIVE_INFINITY;\\r\\n                        else\\r\\n                            return\\r\\n                                bytes16(\\r\\n                                    uint128(\\r\\n                                        (xSign ? 0x80000000000000000000000000000000 : 0) |\\r\\n                                            (xExponent << 112) |\\r\\n                                            xSignifier\\r\\n                                    )\\r\\n                                );\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Calculate x - y.  Special values behave in the following way:\\r\\n     *\\r\\n     * NaN - x = NaN for any x.\\r\\n     * Infinity - x = Infinity for any finite x.\\r\\n     * -Infinity - x = -Infinity for any finite x.\\r\\n     * Infinity - -Infinity = Infinity.\\r\\n     * -Infinity - Infinity = -Infinity.\\r\\n     * Infinity - Infinity = -Infinity - -Infinity = NaN.\\r\\n     *\\r\\n     * @param x quadruple precision number\\r\\n     * @param y quadruple precision number\\r\\n     * @return quadruple precision number\\r\\n     */\\r\\n    function sub(bytes16 x, bytes16 y) internal pure returns (bytes16) {\\r\\n        unchecked {\\r\\n            return add(x, y ^ 0x80000000000000000000000000000000);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Calculate x * y.  Special values behave in the following way:\\r\\n     *\\r\\n     * NaN * x = NaN for any x.\\r\\n     * Infinity * x = Infinity for any finite positive x.\\r\\n     * Infinity * x = -Infinity for any finite negative x.\\r\\n     * -Infinity * x = -Infinity for any finite positive x.\\r\\n     * -Infinity * x = Infinity for any finite negative x.\\r\\n     * Infinity * 0 = NaN.\\r\\n     * -Infinity * 0 = NaN.\\r\\n     * Infinity * Infinity = Infinity.\\r\\n     * Infinity * -Infinity = -Infinity.\\r\\n     * -Infinity * Infinity = -Infinity.\\r\\n     * -Infinity * -Infinity = Infinity.\\r\\n     *\\r\\n     * @param x quadruple precision number\\r\\n     * @param y quadruple precision number\\r\\n     * @return quadruple precision number\\r\\n     */\\r\\n    function mul(bytes16 x, bytes16 y) internal pure returns (bytes16) {\\r\\n        unchecked {\\r\\n            uint256 xExponent = (uint128(x) >> 112) & 0x7FFF;\\r\\n            uint256 yExponent = (uint128(y) >> 112) & 0x7FFF;\\r\\n\\r\\n            if (xExponent == 0x7FFF) {\\r\\n                if (yExponent == 0x7FFF) {\\r\\n                    if (x == y) return x ^ (y & 0x80000000000000000000000000000000);\\r\\n                    else if (x ^ y == 0x80000000000000000000000000000000) return x | y;\\r\\n                    else return NaN;\\r\\n                } else {\\r\\n                    if (y & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0) return NaN;\\r\\n                    else return x ^ (y & 0x80000000000000000000000000000000);\\r\\n                }\\r\\n            } else if (yExponent == 0x7FFF) {\\r\\n                if (x & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0) return NaN;\\r\\n                else return y ^ (x & 0x80000000000000000000000000000000);\\r\\n            } else {\\r\\n                uint256 xSignifier = uint128(x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\r\\n                if (xExponent == 0) xExponent = 1;\\r\\n                else xSignifier |= 0x10000000000000000000000000000;\\r\\n\\r\\n                uint256 ySignifier = uint128(y) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\r\\n                if (yExponent == 0) yExponent = 1;\\r\\n                else ySignifier |= 0x10000000000000000000000000000;\\r\\n\\r\\n                xSignifier *= ySignifier;\\r\\n                if (xSignifier == 0)\\r\\n                    return (x ^ y) & 0x80000000000000000000000000000000 > 0 ? NEGATIVE_ZERO : POSITIVE_ZERO;\\r\\n\\r\\n                xExponent += yExponent;\\r\\n\\r\\n                uint256 msb = xSignifier >= 0x200000000000000000000000000000000000000000000000000000000\\r\\n                    ? 225\\r\\n                    : xSignifier >= 0x100000000000000000000000000000000000000000000000000000000\\r\\n                    ? 224\\r\\n                    : mostSignificantBit(xSignifier);\\r\\n\\r\\n                if (xExponent + msb < 16496) {\\r\\n                    // Underflow\\r\\n                    xExponent = 0;\\r\\n                    xSignifier = 0;\\r\\n                } else if (xExponent + msb < 16608) {\\r\\n                    // Subnormal\\r\\n                    if (xExponent < 16496) xSignifier >>= 16496 - xExponent;\\r\\n                    else if (xExponent > 16496) xSignifier <<= xExponent - 16496;\\r\\n                    xExponent = 0;\\r\\n                } else if (xExponent + msb > 49373) {\\r\\n                    xExponent = 0x7FFF;\\r\\n                    xSignifier = 0;\\r\\n                } else {\\r\\n                    if (msb > 112) xSignifier >>= msb - 112;\\r\\n                    else if (msb < 112) xSignifier <<= 112 - msb;\\r\\n\\r\\n                    xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\r\\n\\r\\n                    xExponent = xExponent + msb - 16607;\\r\\n                }\\r\\n\\r\\n                return\\r\\n                    bytes16(\\r\\n                        uint128(uint128((x ^ y) & 0x80000000000000000000000000000000) | (xExponent << 112) | xSignifier)\\r\\n                    );\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Calculate x / y.  Special values behave in the following way:\\r\\n     *\\r\\n     * NaN / x = NaN for any x.\\r\\n     * x / NaN = NaN for any x.\\r\\n     * Infinity / x = Infinity for any finite non-negative x.\\r\\n     * Infinity / x = -Infinity for any finite negative x including -0.\\r\\n     * -Infinity / x = -Infinity for any finite non-negative x.\\r\\n     * -Infinity / x = Infinity for any finite negative x including -0.\\r\\n     * x / Infinity = 0 for any finite non-negative x.\\r\\n     * x / -Infinity = -0 for any finite non-negative x.\\r\\n     * x / Infinity = -0 for any finite non-negative x including -0.\\r\\n     * x / -Infinity = 0 for any finite non-negative x including -0.\\r\\n     *\\r\\n     * Infinity / Infinity = NaN.\\r\\n     * Infinity / -Infinity = -NaN.\\r\\n     * -Infinity / Infinity = -NaN.\\r\\n     * -Infinity / -Infinity = NaN.\\r\\n     *\\r\\n     * Division by zero behaves in the following way:\\r\\n     *\\r\\n     * x / 0 = Infinity for any finite positive x.\\r\\n     * x / -0 = -Infinity for any finite positive x.\\r\\n     * x / 0 = -Infinity for any finite negative x.\\r\\n     * x / -0 = Infinity for any finite negative x.\\r\\n     * 0 / 0 = NaN.\\r\\n     * 0 / -0 = NaN.\\r\\n     * -0 / 0 = NaN.\\r\\n     * -0 / -0 = NaN.\\r\\n     *\\r\\n     * @param x quadruple precision number\\r\\n     * @param y quadruple precision number\\r\\n     * @return quadruple precision number\\r\\n     */\\r\\n    function div(bytes16 x, bytes16 y) internal pure returns (bytes16) {\\r\\n        unchecked {\\r\\n            uint256 xExponent = (uint128(x) >> 112) & 0x7FFF;\\r\\n            uint256 yExponent = (uint128(y) >> 112) & 0x7FFF;\\r\\n\\r\\n            if (xExponent == 0x7FFF) {\\r\\n                if (yExponent == 0x7FFF) return NaN;\\r\\n                else return x ^ (y & 0x80000000000000000000000000000000);\\r\\n            } else if (yExponent == 0x7FFF) {\\r\\n                if (y & 0x0000FFFFFFFFFFFFFFFFFFFFFFFFFFFF != 0) return NaN;\\r\\n                else return POSITIVE_ZERO | ((x ^ y) & 0x80000000000000000000000000000000);\\r\\n            } else if (y & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0) {\\r\\n                if (x & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0) return NaN;\\r\\n                else return POSITIVE_INFINITY | ((x ^ y) & 0x80000000000000000000000000000000);\\r\\n            } else {\\r\\n                uint256 ySignifier = uint128(y) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\r\\n                if (yExponent == 0) yExponent = 1;\\r\\n                else ySignifier |= 0x10000000000000000000000000000;\\r\\n\\r\\n                uint256 xSignifier = uint128(x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\r\\n                if (xExponent == 0) {\\r\\n                    if (xSignifier != 0) {\\r\\n                        uint256 shift = 226 - mostSignificantBit(xSignifier);\\r\\n\\r\\n                        xSignifier <<= shift;\\r\\n\\r\\n                        xExponent = 1;\\r\\n                        yExponent += shift - 114;\\r\\n                    }\\r\\n                } else {\\r\\n                    xSignifier = (xSignifier | 0x10000000000000000000000000000) << 114;\\r\\n                }\\r\\n\\r\\n                xSignifier = xSignifier / ySignifier;\\r\\n                if (xSignifier == 0)\\r\\n                    return (x ^ y) & 0x80000000000000000000000000000000 > 0 ? NEGATIVE_ZERO : POSITIVE_ZERO;\\r\\n\\r\\n                assert(xSignifier >= 0x1000000000000000000000000000);\\r\\n\\r\\n                uint256 msb = xSignifier >= 0x80000000000000000000000000000\\r\\n                    ? mostSignificantBit(xSignifier)\\r\\n                    : xSignifier >= 0x40000000000000000000000000000\\r\\n                    ? 114\\r\\n                    : xSignifier >= 0x20000000000000000000000000000\\r\\n                    ? 113\\r\\n                    : 112;\\r\\n\\r\\n                if (xExponent + msb > yExponent + 16497) {\\r\\n                    // Overflow\\r\\n                    xExponent = 0x7FFF;\\r\\n                    xSignifier = 0;\\r\\n                } else if (xExponent + msb + 16380 < yExponent) {\\r\\n                    // Underflow\\r\\n                    xExponent = 0;\\r\\n                    xSignifier = 0;\\r\\n                } else if (xExponent + msb + 16268 < yExponent) {\\r\\n                    // Subnormal\\r\\n                    if (xExponent + 16380 > yExponent) xSignifier <<= xExponent + 16380 - yExponent;\\r\\n                    else if (xExponent + 16380 < yExponent) xSignifier >>= yExponent - xExponent - 16380;\\r\\n\\r\\n                    xExponent = 0;\\r\\n                } else {\\r\\n                    // Normal\\r\\n                    if (msb > 112) xSignifier >>= msb - 112;\\r\\n\\r\\n                    xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\r\\n\\r\\n                    xExponent = xExponent + msb + 16269 - yExponent;\\r\\n                }\\r\\n\\r\\n                return\\r\\n                    bytes16(\\r\\n                        uint128(uint128((x ^ y) & 0x80000000000000000000000000000000) | (xExponent << 112) | xSignifier)\\r\\n                    );\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Calculate -x.\\r\\n     *\\r\\n     * @param x quadruple precision number\\r\\n     * @return quadruple precision number\\r\\n     */\\r\\n    function neg(bytes16 x) internal pure returns (bytes16) {\\r\\n        unchecked {\\r\\n            return x ^ 0x80000000000000000000000000000000;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Calculate |x|.\\r\\n     *\\r\\n     * @param x quadruple precision number\\r\\n     * @return quadruple precision number\\r\\n     */\\r\\n    function abs(bytes16 x) internal pure returns (bytes16) {\\r\\n        unchecked {\\r\\n            return x & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Calculate square root of x.  Return NaN on negative x excluding -0.\\r\\n     *\\r\\n     * @param x quadruple precision number\\r\\n     * @return quadruple precision number\\r\\n     */\\r\\n    function sqrt(bytes16 x) internal pure returns (bytes16) {\\r\\n        unchecked {\\r\\n            if (uint128(x) > 0x80000000000000000000000000000000) return NaN;\\r\\n            else {\\r\\n                uint256 xExponent = (uint128(x) >> 112) & 0x7FFF;\\r\\n                if (xExponent == 0x7FFF) return x;\\r\\n                else {\\r\\n                    uint256 xSignifier = uint128(x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\r\\n                    if (xExponent == 0) xExponent = 1;\\r\\n                    else xSignifier |= 0x10000000000000000000000000000;\\r\\n\\r\\n                    if (xSignifier == 0) return POSITIVE_ZERO;\\r\\n\\r\\n                    bool oddExponent = xExponent & 0x1 == 0;\\r\\n                    xExponent = (xExponent + 16383) >> 1;\\r\\n\\r\\n                    if (oddExponent) {\\r\\n                        if (xSignifier >= 0x10000000000000000000000000000) xSignifier <<= 113;\\r\\n                        else {\\r\\n                            uint256 msb = mostSignificantBit(xSignifier);\\r\\n                            uint256 shift = (226 - msb) & 0xFE;\\r\\n                            xSignifier <<= shift;\\r\\n                            xExponent -= (shift - 112) >> 1;\\r\\n                        }\\r\\n                    } else {\\r\\n                        if (xSignifier >= 0x10000000000000000000000000000) xSignifier <<= 112;\\r\\n                        else {\\r\\n                            uint256 msb = mostSignificantBit(xSignifier);\\r\\n                            uint256 shift = (225 - msb) & 0xFE;\\r\\n                            xSignifier <<= shift;\\r\\n                            xExponent -= (shift - 112) >> 1;\\r\\n                        }\\r\\n                    }\\r\\n\\r\\n                    uint256 r = 0x10000000000000000000000000000;\\r\\n                    r = (r + xSignifier / r) >> 1;\\r\\n                    r = (r + xSignifier / r) >> 1;\\r\\n                    r = (r + xSignifier / r) >> 1;\\r\\n                    r = (r + xSignifier / r) >> 1;\\r\\n                    r = (r + xSignifier / r) >> 1;\\r\\n                    r = (r + xSignifier / r) >> 1;\\r\\n                    r = (r + xSignifier / r) >> 1; // Seven iterations should be enough\\r\\n                    uint256 r1 = xSignifier / r;\\r\\n                    if (r1 < r) r = r1;\\r\\n\\r\\n                    return bytes16(uint128((xExponent << 112) | (r & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF)));\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Calculate binary logarithm of x.  Return NaN on negative x excluding -0.\\r\\n     *\\r\\n     * @param x quadruple precision number\\r\\n     * @return quadruple precision number\\r\\n     */\\r\\n    function log_2(bytes16 x) internal pure returns (bytes16) {\\r\\n        unchecked {\\r\\n            if (uint128(x) > 0x80000000000000000000000000000000) return NaN;\\r\\n            else if (x == 0x3FFF0000000000000000000000000000) return POSITIVE_ZERO;\\r\\n            else {\\r\\n                uint256 xExponent = (uint128(x) >> 112) & 0x7FFF;\\r\\n                if (xExponent == 0x7FFF) return x;\\r\\n                else {\\r\\n                    uint256 xSignifier = uint128(x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\r\\n                    if (xExponent == 0) xExponent = 1;\\r\\n                    else xSignifier |= 0x10000000000000000000000000000;\\r\\n\\r\\n                    if (xSignifier == 0) return NEGATIVE_INFINITY;\\r\\n\\r\\n                    bool resultNegative;\\r\\n                    uint256 resultExponent = 16495;\\r\\n                    uint256 resultSignifier;\\r\\n\\r\\n                    if (xExponent >= 0x3FFF) {\\r\\n                        resultNegative = false;\\r\\n                        resultSignifier = xExponent - 0x3FFF;\\r\\n                        xSignifier <<= 15;\\r\\n                    } else {\\r\\n                        resultNegative = true;\\r\\n                        if (xSignifier >= 0x10000000000000000000000000000) {\\r\\n                            resultSignifier = 0x3FFE - xExponent;\\r\\n                            xSignifier <<= 15;\\r\\n                        } else {\\r\\n                            uint256 msb = mostSignificantBit(xSignifier);\\r\\n                            resultSignifier = 16493 - msb;\\r\\n                            xSignifier <<= 127 - msb;\\r\\n                        }\\r\\n                    }\\r\\n\\r\\n                    if (xSignifier == 0x80000000000000000000000000000000) {\\r\\n                        if (resultNegative) resultSignifier += 1;\\r\\n                        uint256 shift = 112 - mostSignificantBit(resultSignifier);\\r\\n                        resultSignifier <<= shift;\\r\\n                        resultExponent -= shift;\\r\\n                    } else {\\r\\n                        uint256 bb = resultNegative ? 1 : 0;\\r\\n                        while (resultSignifier < 0x10000000000000000000000000000) {\\r\\n                            resultSignifier <<= 1;\\r\\n                            resultExponent -= 1;\\r\\n\\r\\n                            xSignifier *= xSignifier;\\r\\n                            uint256 b = xSignifier >> 255;\\r\\n                            resultSignifier += b ^ bb;\\r\\n                            xSignifier >>= 127 + b;\\r\\n                        }\\r\\n                    }\\r\\n\\r\\n                    return\\r\\n                        bytes16(\\r\\n                            uint128(\\r\\n                                (resultNegative ? 0x80000000000000000000000000000000 : 0) |\\r\\n                                    (resultExponent << 112) |\\r\\n                                    (resultSignifier & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\\r\\n                            )\\r\\n                        );\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Calculate natural logarithm of x.  Return NaN on negative x excluding -0.\\r\\n     *\\r\\n     * @param x quadruple precision number\\r\\n     * @return quadruple precision number\\r\\n     */\\r\\n    function ln(bytes16 x) internal pure returns (bytes16) {\\r\\n        unchecked {\\r\\n            return mul(log_2(x), 0x3FFE62E42FEFA39EF35793C7673007E5);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Calculate 2^x.\\r\\n     *\\r\\n     * @param x quadruple precision number\\r\\n     * @return quadruple precision number\\r\\n     */\\r\\n    function pow_2(bytes16 x) internal pure returns (bytes16) {\\r\\n        unchecked {\\r\\n            bool xNegative = uint128(x) > 0x80000000000000000000000000000000;\\r\\n            uint256 xExponent = (uint128(x) >> 112) & 0x7FFF;\\r\\n            uint256 xSignifier = uint128(x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\r\\n\\r\\n            if (xExponent == 0x7FFF && xSignifier != 0) return NaN;\\r\\n            else if (xExponent > 16397) return xNegative ? POSITIVE_ZERO : POSITIVE_INFINITY;\\r\\n            else if (xExponent < 16255) return 0x3FFF0000000000000000000000000000;\\r\\n            else {\\r\\n                if (xExponent == 0) xExponent = 1;\\r\\n                else xSignifier |= 0x10000000000000000000000000000;\\r\\n\\r\\n                if (xExponent > 16367) xSignifier <<= xExponent - 16367;\\r\\n                else if (xExponent < 16367) xSignifier >>= 16367 - xExponent;\\r\\n\\r\\n                if (xNegative && xSignifier > 0x406E00000000000000000000000000000000) return POSITIVE_ZERO;\\r\\n\\r\\n                if (!xNegative && xSignifier > 0x3FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) return POSITIVE_INFINITY;\\r\\n\\r\\n                uint256 resultExponent = xSignifier >> 128;\\r\\n                xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\r\\n                if (xNegative && xSignifier != 0) {\\r\\n                    xSignifier = ~xSignifier;\\r\\n                    resultExponent += 1;\\r\\n                }\\r\\n\\r\\n                uint256 resultSignifier = 0x80000000000000000000000000000000;\\r\\n                if (xSignifier & 0x80000000000000000000000000000000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x16A09E667F3BCC908B2FB1366EA957D3E) >> 128;\\r\\n                if (xSignifier & 0x40000000000000000000000000000000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x1306FE0A31B7152DE8D5A46305C85EDEC) >> 128;\\r\\n                if (xSignifier & 0x20000000000000000000000000000000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x1172B83C7D517ADCDF7C8C50EB14A791F) >> 128;\\r\\n                if (xSignifier & 0x10000000000000000000000000000000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x10B5586CF9890F6298B92B71842A98363) >> 128;\\r\\n                if (xSignifier & 0x8000000000000000000000000000000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x1059B0D31585743AE7C548EB68CA417FD) >> 128;\\r\\n                if (xSignifier & 0x4000000000000000000000000000000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x102C9A3E778060EE6F7CACA4F7A29BDE8) >> 128;\\r\\n                if (xSignifier & 0x2000000000000000000000000000000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x10163DA9FB33356D84A66AE336DCDFA3F) >> 128;\\r\\n                if (xSignifier & 0x1000000000000000000000000000000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x100B1AFA5ABCBED6129AB13EC11DC9543) >> 128;\\r\\n                if (xSignifier & 0x800000000000000000000000000000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x10058C86DA1C09EA1FF19D294CF2F679B) >> 128;\\r\\n                if (xSignifier & 0x400000000000000000000000000000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x1002C605E2E8CEC506D21BFC89A23A00F) >> 128;\\r\\n                if (xSignifier & 0x200000000000000000000000000000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x100162F3904051FA128BCA9C55C31E5DF) >> 128;\\r\\n                if (xSignifier & 0x100000000000000000000000000000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x1000B175EFFDC76BA38E31671CA939725) >> 128;\\r\\n                if (xSignifier & 0x80000000000000000000000000000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x100058BA01FB9F96D6CACD4B180917C3D) >> 128;\\r\\n                if (xSignifier & 0x40000000000000000000000000000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x10002C5CC37DA9491D0985C348C68E7B3) >> 128;\\r\\n                if (xSignifier & 0x20000000000000000000000000000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x1000162E525EE054754457D5995292026) >> 128;\\r\\n                if (xSignifier & 0x10000000000000000000000000000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x10000B17255775C040618BF4A4ADE83FC) >> 128;\\r\\n                if (xSignifier & 0x8000000000000000000000000000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x1000058B91B5BC9AE2EED81E9B7D4CFAB) >> 128;\\r\\n                if (xSignifier & 0x4000000000000000000000000000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x100002C5C89D5EC6CA4D7C8ACC017B7C9) >> 128;\\r\\n                if (xSignifier & 0x2000000000000000000000000000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x10000162E43F4F831060E02D839A9D16D) >> 128;\\r\\n                if (xSignifier & 0x1000000000000000000000000000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x100000B1721BCFC99D9F890EA06911763) >> 128;\\r\\n                if (xSignifier & 0x800000000000000000000000000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x10000058B90CF1E6D97F9CA14DBCC1628) >> 128;\\r\\n                if (xSignifier & 0x400000000000000000000000000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x1000002C5C863B73F016468F6BAC5CA2B) >> 128;\\r\\n                if (xSignifier & 0x200000000000000000000000000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x100000162E430E5A18F6119E3C02282A5) >> 128;\\r\\n                if (xSignifier & 0x100000000000000000000000000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x1000000B1721835514B86E6D96EFD1BFE) >> 128;\\r\\n                if (xSignifier & 0x80000000000000000000000000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x100000058B90C0B48C6BE5DF846C5B2EF) >> 128;\\r\\n                if (xSignifier & 0x40000000000000000000000000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x10000002C5C8601CC6B9E94213C72737A) >> 128;\\r\\n                if (xSignifier & 0x20000000000000000000000000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x1000000162E42FFF037DF38AA2B219F06) >> 128;\\r\\n                if (xSignifier & 0x10000000000000000000000000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x10000000B17217FBA9C739AA5819F44F9) >> 128;\\r\\n                if (xSignifier & 0x8000000000000000000000000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x1000000058B90BFCDEE5ACD3C1CEDC823) >> 128;\\r\\n                if (xSignifier & 0x4000000000000000000000000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x100000002C5C85FE31F35A6A30DA1BE50) >> 128;\\r\\n                if (xSignifier & 0x2000000000000000000000000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x10000000162E42FF0999CE3541B9FFFCF) >> 128;\\r\\n                if (xSignifier & 0x1000000000000000000000000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x100000000B17217F80F4EF5AADDA45554) >> 128;\\r\\n                if (xSignifier & 0x800000000000000000000000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x10000000058B90BFBF8479BD5A81B51AD) >> 128;\\r\\n                if (xSignifier & 0x400000000000000000000000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x1000000002C5C85FDF84BD62AE30A74CC) >> 128;\\r\\n                if (xSignifier & 0x200000000000000000000000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x100000000162E42FEFB2FED257559BDAA) >> 128;\\r\\n                if (xSignifier & 0x100000000000000000000000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x1000000000B17217F7D5A7716BBA4A9AE) >> 128;\\r\\n                if (xSignifier & 0x80000000000000000000000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x100000000058B90BFBE9DDBAC5E109CCE) >> 128;\\r\\n                if (xSignifier & 0x40000000000000000000000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x10000000002C5C85FDF4B15DE6F17EB0D) >> 128;\\r\\n                if (xSignifier & 0x20000000000000000000000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x1000000000162E42FEFA494F1478FDE05) >> 128;\\r\\n                if (xSignifier & 0x10000000000000000000000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x10000000000B17217F7D20CF927C8E94C) >> 128;\\r\\n                if (xSignifier & 0x8000000000000000000000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x1000000000058B90BFBE8F71CB4E4B33D) >> 128;\\r\\n                if (xSignifier & 0x4000000000000000000000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x100000000002C5C85FDF477B662B26945) >> 128;\\r\\n                if (xSignifier & 0x2000000000000000000000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x10000000000162E42FEFA3AE53369388C) >> 128;\\r\\n                if (xSignifier & 0x1000000000000000000000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x100000000000B17217F7D1D351A389D40) >> 128;\\r\\n                if (xSignifier & 0x800000000000000000000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x10000000000058B90BFBE8E8B2D3D4EDE) >> 128;\\r\\n                if (xSignifier & 0x400000000000000000000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x1000000000002C5C85FDF4741BEA6E77E) >> 128;\\r\\n                if (xSignifier & 0x200000000000000000000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x100000000000162E42FEFA39FE95583C2) >> 128;\\r\\n                if (xSignifier & 0x100000000000000000000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x1000000000000B17217F7D1CFB72B45E1) >> 128;\\r\\n                if (xSignifier & 0x80000000000000000000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x100000000000058B90BFBE8E7CC35C3F0) >> 128;\\r\\n                if (xSignifier & 0x40000000000000000000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x10000000000002C5C85FDF473E242EA38) >> 128;\\r\\n                if (xSignifier & 0x20000000000000000000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x1000000000000162E42FEFA39F02B772C) >> 128;\\r\\n                if (xSignifier & 0x10000000000000000000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x10000000000000B17217F7D1CF7D83C1A) >> 128;\\r\\n                if (xSignifier & 0x8000000000000000000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x1000000000000058B90BFBE8E7BDCBE2E) >> 128;\\r\\n                if (xSignifier & 0x4000000000000000000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x100000000000002C5C85FDF473DEA871F) >> 128;\\r\\n                if (xSignifier & 0x2000000000000000000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x10000000000000162E42FEFA39EF44D91) >> 128;\\r\\n                if (xSignifier & 0x1000000000000000000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x100000000000000B17217F7D1CF79E949) >> 128;\\r\\n                if (xSignifier & 0x800000000000000000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x10000000000000058B90BFBE8E7BCE544) >> 128;\\r\\n                if (xSignifier & 0x400000000000000000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x1000000000000002C5C85FDF473DE6ECA) >> 128;\\r\\n                if (xSignifier & 0x200000000000000000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x100000000000000162E42FEFA39EF366F) >> 128;\\r\\n                if (xSignifier & 0x100000000000000000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x1000000000000000B17217F7D1CF79AFA) >> 128;\\r\\n                if (xSignifier & 0x80000000000000000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x100000000000000058B90BFBE8E7BCD6D) >> 128;\\r\\n                if (xSignifier & 0x40000000000000000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x10000000000000002C5C85FDF473DE6B2) >> 128;\\r\\n                if (xSignifier & 0x20000000000000000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x1000000000000000162E42FEFA39EF358) >> 128;\\r\\n                if (xSignifier & 0x10000000000000000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x10000000000000000B17217F7D1CF79AB) >> 128;\\r\\n                if (xSignifier & 0x8000000000000000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x1000000000000000058B90BFBE8E7BCD5) >> 128;\\r\\n                if (xSignifier & 0x4000000000000000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x100000000000000002C5C85FDF473DE6A) >> 128;\\r\\n                if (xSignifier & 0x2000000000000000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x10000000000000000162E42FEFA39EF34) >> 128;\\r\\n                if (xSignifier & 0x1000000000000000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x100000000000000000B17217F7D1CF799) >> 128;\\r\\n                if (xSignifier & 0x800000000000000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x10000000000000000058B90BFBE8E7BCC) >> 128;\\r\\n                if (xSignifier & 0x400000000000000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x1000000000000000002C5C85FDF473DE5) >> 128;\\r\\n                if (xSignifier & 0x200000000000000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x100000000000000000162E42FEFA39EF2) >> 128;\\r\\n                if (xSignifier & 0x100000000000000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x1000000000000000000B17217F7D1CF78) >> 128;\\r\\n                if (xSignifier & 0x80000000000000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x100000000000000000058B90BFBE8E7BB) >> 128;\\r\\n                if (xSignifier & 0x40000000000000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x10000000000000000002C5C85FDF473DD) >> 128;\\r\\n                if (xSignifier & 0x20000000000000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x1000000000000000000162E42FEFA39EE) >> 128;\\r\\n                if (xSignifier & 0x10000000000000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x10000000000000000000B17217F7D1CF6) >> 128;\\r\\n                if (xSignifier & 0x8000000000000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x1000000000000000000058B90BFBE8E7A) >> 128;\\r\\n                if (xSignifier & 0x4000000000000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x100000000000000000002C5C85FDF473C) >> 128;\\r\\n                if (xSignifier & 0x2000000000000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x10000000000000000000162E42FEFA39D) >> 128;\\r\\n                if (xSignifier & 0x1000000000000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x100000000000000000000B17217F7D1CE) >> 128;\\r\\n                if (xSignifier & 0x800000000000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x10000000000000000000058B90BFBE8E6) >> 128;\\r\\n                if (xSignifier & 0x400000000000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x1000000000000000000002C5C85FDF472) >> 128;\\r\\n                if (xSignifier & 0x200000000000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x100000000000000000000162E42FEFA38) >> 128;\\r\\n                if (xSignifier & 0x100000000000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x1000000000000000000000B17217F7D1B) >> 128;\\r\\n                if (xSignifier & 0x80000000000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x100000000000000000000058B90BFBE8D) >> 128;\\r\\n                if (xSignifier & 0x40000000000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x10000000000000000000002C5C85FDF46) >> 128;\\r\\n                if (xSignifier & 0x20000000000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x1000000000000000000000162E42FEFA2) >> 128;\\r\\n                if (xSignifier & 0x10000000000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x10000000000000000000000B17217F7D0) >> 128;\\r\\n                if (xSignifier & 0x8000000000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x1000000000000000000000058B90BFBE7) >> 128;\\r\\n                if (xSignifier & 0x4000000000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x100000000000000000000002C5C85FDF3) >> 128;\\r\\n                if (xSignifier & 0x2000000000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x10000000000000000000000162E42FEF9) >> 128;\\r\\n                if (xSignifier & 0x1000000000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x100000000000000000000000B17217F7C) >> 128;\\r\\n                if (xSignifier & 0x800000000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x10000000000000000000000058B90BFBD) >> 128;\\r\\n                if (xSignifier & 0x400000000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x1000000000000000000000002C5C85FDE) >> 128;\\r\\n                if (xSignifier & 0x200000000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x100000000000000000000000162E42FEE) >> 128;\\r\\n                if (xSignifier & 0x100000000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x1000000000000000000000000B17217F6) >> 128;\\r\\n                if (xSignifier & 0x80000000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x100000000000000000000000058B90BFA) >> 128;\\r\\n                if (xSignifier & 0x40000000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x10000000000000000000000002C5C85FC) >> 128;\\r\\n                if (xSignifier & 0x20000000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x1000000000000000000000000162E42FD) >> 128;\\r\\n                if (xSignifier & 0x10000000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x10000000000000000000000000B17217E) >> 128;\\r\\n                if (xSignifier & 0x8000000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x1000000000000000000000000058B90BE) >> 128;\\r\\n                if (xSignifier & 0x4000000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x100000000000000000000000002C5C85E) >> 128;\\r\\n                if (xSignifier & 0x2000000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x10000000000000000000000000162E42E) >> 128;\\r\\n                if (xSignifier & 0x1000000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x100000000000000000000000000B17216) >> 128;\\r\\n                if (xSignifier & 0x800000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x10000000000000000000000000058B90A) >> 128;\\r\\n                if (xSignifier & 0x400000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x1000000000000000000000000002C5C84) >> 128;\\r\\n                if (xSignifier & 0x200000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x100000000000000000000000000162E41) >> 128;\\r\\n                if (xSignifier & 0x100000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x1000000000000000000000000000B1720) >> 128;\\r\\n                if (xSignifier & 0x80000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x100000000000000000000000000058B8F) >> 128;\\r\\n                if (xSignifier & 0x40000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x10000000000000000000000000002C5C7) >> 128;\\r\\n                if (xSignifier & 0x20000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x1000000000000000000000000000162E3) >> 128;\\r\\n                if (xSignifier & 0x10000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x10000000000000000000000000000B171) >> 128;\\r\\n                if (xSignifier & 0x8000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x1000000000000000000000000000058B8) >> 128;\\r\\n                if (xSignifier & 0x4000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x100000000000000000000000000002C5B) >> 128;\\r\\n                if (xSignifier & 0x2000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x10000000000000000000000000000162D) >> 128;\\r\\n                if (xSignifier & 0x1000 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x100000000000000000000000000000B16) >> 128;\\r\\n                if (xSignifier & 0x800 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x10000000000000000000000000000058A) >> 128;\\r\\n                if (xSignifier & 0x400 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x1000000000000000000000000000002C4) >> 128;\\r\\n                if (xSignifier & 0x200 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x100000000000000000000000000000161) >> 128;\\r\\n                if (xSignifier & 0x100 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x1000000000000000000000000000000B0) >> 128;\\r\\n                if (xSignifier & 0x80 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x100000000000000000000000000000057) >> 128;\\r\\n                if (xSignifier & 0x40 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x10000000000000000000000000000002B) >> 128;\\r\\n                if (xSignifier & 0x20 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x100000000000000000000000000000015) >> 128;\\r\\n                if (xSignifier & 0x10 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x10000000000000000000000000000000A) >> 128;\\r\\n                if (xSignifier & 0x8 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x100000000000000000000000000000004) >> 128;\\r\\n                if (xSignifier & 0x4 > 0)\\r\\n                    resultSignifier = (resultSignifier * 0x100000000000000000000000000000001) >> 128;\\r\\n\\r\\n                if (!xNegative) {\\r\\n                    resultSignifier = (resultSignifier >> 15) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\r\\n                    resultExponent += 0x3FFF;\\r\\n                } else if (resultExponent <= 0x3FFE) {\\r\\n                    resultSignifier = (resultSignifier >> 15) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\r\\n                    resultExponent = 0x3FFF - resultExponent;\\r\\n                } else {\\r\\n                    resultSignifier = resultSignifier >> (resultExponent - 16367);\\r\\n                    resultExponent = 0;\\r\\n                }\\r\\n\\r\\n                return bytes16(uint128((resultExponent << 112) | resultSignifier));\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Calculate e^x.\\r\\n     *\\r\\n     * @param x quadruple precision number\\r\\n     * @return quadruple precision number\\r\\n     */\\r\\n    function exp(bytes16 x) internal pure returns (bytes16) {\\r\\n        unchecked {\\r\\n            return pow_2(mul(x, 0x3FFF71547652B82FE1777D0FFDA0D23A));\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Get index of the most significant non-zero bit in binary representation of\\r\\n     * x.  Reverts if x is zero.\\r\\n     *\\r\\n     * @return index of the most significant non-zero bit in binary representation\\r\\n     *         of x\\r\\n     */\\r\\n    function mostSignificantBit(uint256 x) private pure returns (uint256) {\\r\\n        unchecked {\\r\\n            require(x > 0);\\r\\n\\r\\n            uint256 result = 0;\\r\\n\\r\\n            if (x >= 0x100000000000000000000000000000000) {\\r\\n                x >>= 128;\\r\\n                result += 128;\\r\\n            }\\r\\n            if (x >= 0x10000000000000000) {\\r\\n                x >>= 64;\\r\\n                result += 64;\\r\\n            }\\r\\n            if (x >= 0x100000000) {\\r\\n                x >>= 32;\\r\\n                result += 32;\\r\\n            }\\r\\n            if (x >= 0x10000) {\\r\\n                x >>= 16;\\r\\n                result += 16;\\r\\n            }\\r\\n            if (x >= 0x100) {\\r\\n                x >>= 8;\\r\\n                result += 8;\\r\\n            }\\r\\n            if (x >= 0x10) {\\r\\n                x >>= 4;\\r\\n                result += 4;\\r\\n            }\\r\\n            if (x >= 0x4) {\\r\\n                x >>= 2;\\r\\n                result += 2;\\r\\n            }\\r\\n            if (x >= 0x2) result += 1; // No need to shift x anymore\\r\\n\\r\\n            return result;\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 250\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"name\":\"TEN_POWER_6\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"durationFromStart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"composedFunction\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxCvgToMint\",\"type\":\"uint256\"}],\"name\":\"computeCvgExpectedUInt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"durationFromStart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"composedFunction\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalOutToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"soldTokenOut\",\"type\":\"uint256\"}],\"name\":\"computeNtrDivNtc\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"durationFromStart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"composedFunction\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalOutToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountTokenSold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gamma\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"scale\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minRoi\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxRoi\",\"type\":\"uint256\"}],\"name\":\"computeRoi\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"durationFromStart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDuration\",\"type\":\"uint256\"}],\"name\":\"computeTimeRatioUInt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]", "ContractName": "BondCalculator", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "250", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}