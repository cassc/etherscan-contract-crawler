{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/interfaces/IBurnable.sol\": {\r\n      \"content\": \"//Made with Student Coin Terminal\\n//SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.0;\\n\\ninterface IBurnable {\\n  function burn(uint256) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IToken.sol\": {\r\n      \"content\": \"//Made with Student Coin Terminal\\n//SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.0;\\n\\nimport {IBurnable} from \\\"./IBurnable.sol\\\";\\nimport {ISaleSupply} from \\\"./ISaleSupply.sol\\\";\\nimport {IVestingSupply} from \\\"./IVestingSupply.sol\\\";\\n\\ninterface IToken is IBurnable, ISaleSupply, IVestingSupply {}\\n\"\r\n    },\r\n    \"contracts/interfaces/ISaleSupply.sol\": {\r\n      \"content\": \"//Made with Student Coin Terminal\\n//SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.0;\\n\\ninterface ISaleSupply {\\n  function saleSupply() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IVestingSupply.sol\": {\r\n      \"content\": \"//Made with Student Coin Terminal\\n//SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.0;\\n\\ninterface IVestingSupply {\\n  function vestingSupply() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/tokens/TokenERC20.sol\": {\r\n      \"content\": \"//Made with Student Coin Terminal\\n//SPDX-License-Identifier: NONE\\npragma solidity ^0.8.0;\\n\\nimport {AccessControl} from \\\"@openzeppelin/contracts/access/AccessControl.sol\\\";\\nimport {ERC20} from \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport {IToken} from \\\"../interfaces/IToken.sol\\\";\\n\\ncontract TokenERC20 is ERC20, AccessControl, IToken {\\n  // roles\\n  bytes32 public constant CAN_MINT_ROLE = keccak256(\\\"CAN MINT\\\");\\n  bytes32 public constant CAN_BURN_ROLE = keccak256(\\\"CAN BURN\\\");\\n\\n  // basic\\n  uint8 private immutable _decimals;\\n  uint256 private immutable _cap;\\n\\n  // tax\\n  uint8 public immutable tax;\\n\\n  // sale\\n  address public immutable saleAddress;\\n  uint256 private immutable _saleSupply;\\n\\n  // vesting\\n  address public immutable vestingAddress;\\n  uint256 private immutable _vestingSupply;\\n\\n  // internal\\n  mapping(address => bool) public internalContracts;\\n\\n  // errors\\n  error InvalidDecimals(uint8 decimals_);\\n  error SupplyGreaterThanCap(\\n    uint256 supply_,\\n    uint256 saleSupply_,\\n    uint256 vestingSupply_,\\n    uint256 cap_\\n  );\\n  error CapExceeded(uint256 amount_, uint256 cap_);\\n  error InvalidTransactionTax(uint256 percentage_);\\n  error InvalidAllowance(uint256 allowance_, uint256 amount_);\\n  error InvalidSaleConfig(address sale_, uint256 saleSupply_);\\n  error InvalidVestingConfig(address vesting_, uint256 vestingSupply_);\\n\\n  constructor(\\n    string memory name_,\\n    string memory symbol_,\\n    bytes memory arguments_\\n  ) ERC20(name_, symbol_) {\\n    // tx members\\n    address sender = tx.origin;\\n\\n    // decode\\n    (\\n      uint8 decimals_,\\n      uint256 cap_,\\n      uint256 initialSupply_,\\n      bool canMint_,\\n      bool canBurn_,\\n      uint8 tax_,\\n      address sale_,\\n      uint256 saleSupply_,\\n      address vesting_,\\n      uint256 vestingSupply_\\n    ) = abi.decode(\\n        arguments_,\\n        (uint8, uint256, uint256, bool, bool, uint8, address, uint256, address, uint256)\\n      );\\n\\n    // verify decimals\\n    if (decimals_ > 18) {\\n      revert InvalidDecimals(decimals_);\\n    }\\n\\n    // for uncapped use max uint256\\n    if (cap_ == 0) {\\n      cap_ = type(uint256).max;\\n    }\\n\\n    // verify supply\\n    if (initialSupply_ + saleSupply_ + vestingSupply_ > cap_) {\\n      revert SupplyGreaterThanCap(initialSupply_, saleSupply_, vestingSupply_, cap_);\\n    }\\n\\n    // verify transaction tax\\n    if (tax_ > 100) {\\n      revert InvalidTransactionTax(tax_);\\n    }\\n\\n    if ((saleSupply_ > 0 && sale_ == address(0x0)) || (saleSupply_ == 0 && sale_ != address(0x0))) {\\n      revert InvalidSaleConfig(sale_, saleSupply_);\\n    }\\n\\n    if (\\n      (vestingSupply_ > 0 && vesting_ == address(0x0)) ||\\n      (vestingSupply_ == 0 && vesting_ != address(0x0))\\n    ) {\\n      revert InvalidVestingConfig(vesting_, vestingSupply_);\\n    }\\n\\n    // token\\n    _decimals = decimals_;\\n    _cap = cap_;\\n    tax = tax_;\\n\\n    // mint supply\\n    if (initialSupply_ > 0) {\\n      _mint(sender, initialSupply_);\\n    }\\n\\n    // setup sale\\n    saleAddress = sale_;\\n    _saleSupply = saleSupply_;\\n    if (sale_ != address(0x0)) {\\n      // internal\\n      internalContracts[sale_] = true;\\n\\n      // mint\\n      _mint(sale_, saleSupply_);\\n    } else {\\n      if (saleSupply_ != 0) revert InvalidSaleConfig(sale_, saleSupply_);\\n    }\\n\\n    // setup vesting\\n    vestingAddress = vesting_;\\n    _vestingSupply = vestingSupply_;\\n    if (vesting_ != address(0x0)) {\\n      // internal\\n      internalContracts[vesting_] = true;\\n\\n      // mint\\n      _mint(vesting_, vestingSupply_);\\n    } else {\\n      if (vestingSupply_ != 0) revert InvalidVestingConfig(vesting_, vestingSupply_);\\n    }\\n\\n    // base role setup\\n    _setupRole(DEFAULT_ADMIN_ROLE, sender);\\n    _setRoleAdmin(CAN_MINT_ROLE, DEFAULT_ADMIN_ROLE);\\n    _setRoleAdmin(CAN_BURN_ROLE, DEFAULT_ADMIN_ROLE);\\n\\n    // mint role\\n    if (canMint_) {\\n      _setupRole(CAN_MINT_ROLE, sender);\\n    }\\n\\n    // burn role\\n    if (canBurn_) {\\n      _setupRole(CAN_BURN_ROLE, sender);\\n    }\\n\\n    // burn for sale\\n    if (sale_ != address(0x0)) {\\n      _setupRole(CAN_BURN_ROLE, sale_);\\n    }\\n  }\\n\\n  // getters\\n  function decimals() public view virtual override returns (uint8) {\\n    return _decimals;\\n  }\\n\\n  function cap() public view virtual returns (uint256) {\\n    return _cap;\\n  }\\n\\n  function saleSupply() external view override returns (uint256) {\\n    return _saleSupply;\\n  }\\n\\n  function vestingSupply() external view override returns (uint256) {\\n    return _vestingSupply;\\n  }\\n\\n  // mint & burn\\n  function mint(address account, uint256 amount) external onlyRole(CAN_MINT_ROLE) {\\n    _mint(account, amount);\\n  }\\n\\n  function burn(uint256 amount) external override onlyRole(CAN_BURN_ROLE) {\\n    _burn(msg.sender, amount);\\n  }\\n\\n  function _mint(address account, uint256 amount) internal virtual override {\\n    uint256 sum = ERC20.totalSupply() + amount;\\n    if (sum > _cap) {\\n      revert CapExceeded(sum, _cap);\\n    }\\n    super._mint(account, amount);\\n  }\\n\\n  // transfer\\n  function _calculateTax(uint256 amount) internal view returns (uint256, uint256) {\\n    uint256 burned = (amount * tax) / 100;\\n    uint256 untaxed = amount - burned;\\n    return (burned, untaxed);\\n  }\\n\\n  function isNotInternalTransfer() private view returns (bool) {\\n    return !internalContracts[msg.sender];\\n  }\\n\\n  function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n    if (tax > 0 && isNotInternalTransfer()) {\\n      // calculate tax\\n      (uint256 burned, uint256 untaxed) = _calculateTax(amount);\\n\\n      // burn and transfer\\n      _burn(msg.sender, burned);\\n      return super.transfer(recipient, untaxed);\\n    } else {\\n      return super.transfer(recipient, amount);\\n    }\\n  }\\n\\n  function transferFrom(\\n    address sender,\\n    address recipient,\\n    uint256 amount\\n  ) public virtual override returns (bool) {\\n    if (tax > 0 && isNotInternalTransfer()) {\\n      // calculate tax\\n      (uint256 burned, uint256 untaxed) = _calculateTax(amount);\\n\\n      // allowance for burn\\n      uint256 currentAllowance = allowance(sender, _msgSender());\\n      if (currentAllowance < amount) {\\n        revert InvalidAllowance(currentAllowance, amount);\\n      }\\n      unchecked {\\n        _approve(sender, _msgSender(), currentAllowance - burned);\\n      }\\n\\n      // burn and transfer\\n      _burn(sender, burned);\\n      return super.transferFrom(sender, recipient, untaxed);\\n    } else {\\n      return super.transferFrom(sender, recipient, amount);\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/AccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (access/AccessControl.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IAccessControl.sol\\\";\\nimport \\\"../utils/Context.sol\\\";\\nimport \\\"../utils/Strings.sol\\\";\\nimport \\\"../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev Contract module that allows children to implement role-based access\\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\\n * members except through off-chain means by accessing the contract event logs. Some\\n * applications may benefit from on-chain enumerability, for those cases see\\n * {AccessControlEnumerable}.\\n *\\n * Roles are referred to by their `bytes32` identifier. These should be exposed\\n * in the external API and be unique. The best way to achieve this is by\\n * using `public constant` hash digests:\\n *\\n * ```\\n * bytes32 public constant MY_ROLE = keccak256(\\\"MY_ROLE\\\");\\n * ```\\n *\\n * Roles can be used to represent a set of permissions. To restrict access to a\\n * function call, use {hasRole}:\\n *\\n * ```\\n * function foo() public {\\n *     require(hasRole(MY_ROLE, msg.sender));\\n *     ...\\n * }\\n * ```\\n *\\n * Roles can be granted and revoked dynamically via the {grantRole} and\\n * {revokeRole} functions. Each role has an associated admin role, and only\\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\\n *\\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\\n * that only accounts with this role will be able to grant or revoke other\\n * roles. More complex role relationships can be created by using\\n * {_setRoleAdmin}.\\n *\\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\\n * grant and revoke this role. Extra precautions should be taken to secure\\n * accounts that have been granted it.\\n */\\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\\n    struct RoleData {\\n        mapping(address => bool) members;\\n        bytes32 adminRole;\\n    }\\n\\n    mapping(bytes32 => RoleData) private _roles;\\n\\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n    /**\\n     * @dev Modifier that checks that an account has a specific role. Reverts\\n     * with a standardized message including the required role.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\\n     *\\n     * _Available since v4.1._\\n     */\\n    modifier onlyRole(bytes32 role) {\\n        _checkRole(role, _msgSender());\\n        _;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) public view override returns (bool) {\\n        return _roles[role].members[account];\\n    }\\n\\n    /**\\n     * @dev Revert with a standard message if `account` is missing `role`.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\\n     */\\n    function _checkRole(bytes32 role, address account) internal view {\\n        if (!hasRole(role, account)) {\\n            revert(\\n                string(\\n                    abi.encodePacked(\\n                        \\\"AccessControl: account \\\",\\n                        Strings.toHexString(uint160(account), 20),\\n                        \\\" is missing role \\\",\\n                        Strings.toHexString(uint256(role), 32)\\n                    )\\n                )\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\\n        return _roles[role].adminRole;\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) public virtual override {\\n        require(account == _msgSender(), \\\"AccessControl: can only renounce roles for self\\\");\\n\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event. Note that unlike {grantRole}, this function doesn't perform any\\n     * checks on the calling account.\\n     *\\n     * [WARNING]\\n     * ====\\n     * This function should only be called from the constructor when setting\\n     * up the initial roles for the system.\\n     *\\n     * Using this function in any other way is effectively circumventing the admin\\n     * system imposed by {AccessControl}.\\n     * ====\\n     *\\n     * NOTE: This function is deprecated in favor of {_grantRole}.\\n     */\\n    function _setupRole(bytes32 role, address account) internal virtual {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Sets `adminRole` as ``role``'s admin role.\\n     *\\n     * Emits a {RoleAdminChanged} event.\\n     */\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\n        bytes32 previousAdminRole = getRoleAdmin(role);\\n        _roles[role].adminRole = adminRole;\\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * Internal function without access restriction.\\n     */\\n    function _grantRole(bytes32 role, address account) internal virtual {\\n        if (!hasRole(role, account)) {\\n            _roles[role].members[account] = true;\\n            emit RoleGranted(role, account, _msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * Internal function without access restriction.\\n     */\\n    function _revokeRole(bytes32 role, address account) internal virtual {\\n        if (hasRole(role, account)) {\\n            _roles[role].members[account] = false;\\n            emit RoleRevoked(role, account, _msgSender());\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./extensions/IERC20Metadata.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * The default value of {decimals} is 18. To select a different value for\\n     * {decimals} you should overload it.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\n     * overridden;\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``sender``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n\\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\\n        require(currentAllowance >= amount, \\\"ERC20: transfer amount exceeds allowance\\\");\\n        unchecked {\\n            _approve(sender, _msgSender(), currentAllowance - amount);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) internal virtual {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n\\n        uint256 senderBalance = _balances[sender];\\n        require(senderBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[sender] = senderBalance - amount;\\n        }\\n        _balances[recipient] += amount;\\n\\n        emit Transfer(sender, recipient, amount);\\n\\n        _afterTokenTransfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        _balances[account] += amount;\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n        }\\n        _totalSupply -= amount;\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/IAccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (access/IAccessControl.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC165 detection.\\n */\\ninterface IAccessControl {\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {AccessControl-_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"contracts/whitelist/Whitelist.sol\": {\r\n      \"content\": \"//Made with Student Coin Terminal\\n//SPDX-License-Identifier: NONE\\npragma solidity ^0.8.0;\\n\\nimport {AccessControl} from \\\"@openzeppelin/contracts/access/AccessControl.sol\\\";\\nimport {Configurable} from \\\"../utils/Configurable.sol\\\";\\nimport {IWhitelist} from \\\"../interfaces/IWhitelist.sol\\\";\\n\\ncontract Whitelist is AccessControl, Configurable, IWhitelist {\\n  // roles\\n  bytes32 public constant CAN_MANAGE_ROLE = keccak256(\\\"CAN MANAGE\\\");\\n\\n  // structs\\n  struct Member {\\n    address account;\\n    uint256 allowance; // zero allowance -> inf allowance\\n  }\\n  struct Whitelisted {\\n    uint256 allowance; // zero allowance -> not whitelisted\\n    uint256 used;\\n  }\\n\\n  // storage\\n  mapping(address => Whitelisted) public members;\\n  address public sale;\\n\\n  // events\\n  event AccountNotWhitelisted(address account);\\n  event NotEnoughAllowance(address account, uint256 allowance, uint256 amount);\\n  event WhitelistUpdated(uint256 created, uint256 updated, uint256 deleted);\\n\\n  // errors\\n  error InvalidAccount(address account, uint8 i);\\n  error AccountAlreadyWhitelisted(address account);\\n  error AccountDoesNotExist(address account);\\n  error InvalidSender(address account);\\n  error UsedBiggerThanAllowance(address account, uint256 used, uint256 newAllowance);\\n\\n  modifier onlySale() {\\n    address sender = msg.sender;\\n    if (sender != sale) {\\n      revert InvalidSender(sender);\\n    }\\n    _;\\n  }\\n\\n  constructor(bytes memory arguments_) {\\n    // tx members\\n    address sender = tx.origin;\\n\\n    // decode\\n    Member[] memory members_ = abi.decode(arguments_, (Member[]));\\n\\n    for (uint8 i = 0; i < members_.length; i++) {\\n      // member\\n      Member memory member = members_[i];\\n\\n      // check address\\n      if (member.account == address(0x0)) {\\n        revert InvalidAccount(member.account, i);\\n      }\\n      if (member.allowance == 0) {\\n        member.allowance = type(uint256).max;\\n      }\\n\\n      members[member.account] = Whitelisted(member.allowance, 0);\\n    }\\n\\n    // role setup\\n    _setupRole(DEFAULT_ADMIN_ROLE, sender);\\n    _setRoleAdmin(CAN_MANAGE_ROLE, DEFAULT_ADMIN_ROLE);\\n    _setupRole(CAN_MANAGE_ROLE, sender);\\n  }\\n\\n  function configure(address sale_)\\n    external\\n    onlyInState(State.UNCONFIGURED)\\n    onlyRole(DEFAULT_ADMIN_ROLE)\\n  {\\n    // storage\\n    sale = sale_;\\n\\n    // state\\n    state = State.CONFIGURED;\\n  }\\n\\n  function update(\\n    Member[] memory toCreate,\\n    Member[] memory toUpdate,\\n    address[] memory toDelete\\n  ) external onlyRole(CAN_MANAGE_ROLE) {\\n    // bulk create\\n    for (uint8 i = 0; i < toCreate.length; i++) {\\n      // create member if not exists\\n      Member memory member = toCreate[i];\\n      if (members[member.account].allowance != 0) {\\n        revert AccountAlreadyWhitelisted(member.account);\\n      }\\n      if (member.allowance == 0) {\\n        member.allowance = type(uint256).max;\\n      }\\n\\n      // optional allowance, used 0\\n      members[member.account] = Whitelisted(member.allowance, 0);\\n    }\\n\\n    // bulk update\\n    for (uint8 i = 0; i < toUpdate.length; i++) {\\n      // update member if exists\\n      Member memory member = toUpdate[i];\\n      if (members[member.account].allowance == 0) {\\n        revert AccountDoesNotExist(member.account);\\n      }\\n\\n      // zero allowance in input is max allowance\\n      if (member.allowance == 0) {\\n        member.allowance = type(uint256).max;\\n      }\\n\\n      // revert if allowance limited and smaller than used\\n      uint256 used = members[member.account].used;\\n      if (used > member.allowance) {\\n        revert UsedBiggerThanAllowance(member.account, used, member.allowance);\\n      }\\n\\n      // allowance updated, preserve used\\n      members[member.account].allowance = member.allowance;\\n    }\\n\\n    // bulk delete\\n    for (uint8 i = 0; i < toDelete.length; i++) {\\n      // delete member if exists\\n      address account = toDelete[i];\\n      if (members[account].allowance == 0) {\\n        revert AccountDoesNotExist(account);\\n      }\\n\\n      // empty storage\\n      members[account] = Whitelisted(0, 0);\\n    }\\n\\n    // event\\n    emit WhitelistUpdated(toCreate.length, toUpdate.length, toDelete.length);\\n  }\\n\\n  function use(uint256 amount)\\n    external\\n    override\\n    onlyInState(State.CONFIGURED)\\n    onlySale\\n    returns (bool)\\n  {\\n    // tx.members\\n    address sender = tx.origin;\\n\\n    // member\\n    Whitelisted memory whitelisted = members[sender];\\n\\n    // not whitelisted\\n    if (whitelisted.allowance == 0) {\\n      emit AccountNotWhitelisted(sender);\\n      return false;\\n    }\\n\\n    // limit not enough\\n    uint256 allowance = whitelisted.allowance;\\n    if (allowance < whitelisted.used + amount) {\\n      emit NotEnoughAllowance(sender, allowance, amount);\\n      return false;\\n    }\\n\\n    // storage and return\\n    members[sender].used += amount;\\n    return true;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/Configurable.sol\": {\r\n      \"content\": \"//Made with Student Coin Terminal\\n//SPDX-License-Identifier: NONE\\npragma solidity ^0.8.0;\\n\\nabstract contract Configurable {\\n  // enum\\n  enum State {\\n    UNCONFIGURED,\\n    CONFIGURED\\n  }\\n\\n  // storage\\n  State public state = State.UNCONFIGURED;\\n\\n  // modifier\\n  modifier onlyInState(State _state) {\\n    require(state == _state, \\\"Invalid state\\\");\\n    _;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IWhitelist.sol\": {\r\n      \"content\": \"//Made with Student Coin Terminal\\n//SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.0;\\n\\ninterface IWhitelist {\\n  function use(uint256) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/sale/Sale.sol\": {\r\n      \"content\": \"//Made with Student Coin Terminal\\n//SPDX-License-Identifier: NONE\\npragma solidity ^0.8.0;\\n\\nimport {AccessControl} from \\\"@openzeppelin/contracts/access/AccessControl.sol\\\";\\nimport {Configurable} from \\\"../utils/Configurable.sol\\\";\\nimport {ITokenERC20} from \\\"../interfaces/ITokenERC20.sol\\\";\\nimport {IWhitelist} from \\\"../interfaces/IWhitelist.sol\\\";\\n\\ncontract Sale is AccessControl, Configurable {\\n  // stage\\n  struct Stage {\\n    uint256 supply; // stage supply\\n    uint256 rate; // tokens per wei (example: value 20 -> for 1 ETH gives 20 tokens)\\n    uint256 minAlloc; // minimum wei invested\\n    uint256 openingTime;\\n    uint256 closingTime;\\n  }\\n  struct Phase {\\n    Stage stage;\\n    uint256 soldTokens;\\n    uint256 weiRaised;\\n  }\\n\\n  // storage\\n  Phase[] public stages;\\n  ITokenERC20 public erc20;\\n  IWhitelist public whitelist;\\n\\n  address payable public immutable wallet;\\n  uint256 public immutable supply; // sale supply\\n  uint256 public immutable hardCap; // ether value of sale supply\\n  uint256 public weiRaised;\\n\\n  // events\\n  event TokenPurchase(\\n    address indexed purchaser,\\n    address indexed beneficiary,\\n    uint256 value,\\n    uint256 amount\\n  );\\n  event TokenBurn(uint256 amount);\\n\\n  // basic errors\\n  error SaleNotActive(uint256 timestamp);\\n  error SaleNotFinished(uint256 timestamp);\\n  error NoTokensLeft();\\n\\n  // sale errors\\n  error InvalidConfig(uint256 supply, uint256 cap, address wallet, uint256 stagesCount);\\n  error SupplyMismatch(uint256 supply, uint256 totalSupply);\\n  error ValueMismatch(uint256 hardCap, uint256 totalValue);\\n\\n  // stage errors\\n  error InvalidStageConfig(uint256 rate, uint8 i);\\n  error StartDateInThePast(uint256 start, uint256 now_, uint8 i);\\n  error StartDateNotBeforeEndDate(uint256 start, uint256 end, uint8 i);\\n  error SupplySmallerThanRate(uint256 supply, uint256 rate, uint8 i);\\n\\n  // configuration errors\\n  error SupplyConfigurationMishmatch(uint256 saleSupply, uint256 supply);\\n  error BalanceNotEqualSupply(uint256 balance, uint256 supply);\\n\\n  // buy errors\\n  error InvalidReceiver(address receiver);\\n  error NotEnoughBigInvestment(uint256 amount, uint256 minimum);\\n  error HardCapExceeded(uint256 amount, uint256 hardCap);\\n  error StageSupplyDrained(uint256 amount, uint256 supply);\\n  error WhitelistNotPassed(address member, uint256 weiAmount);\\n\\n  // modifiers\\n  modifier onlyWhenActive() {\\n    getCurrentStage();\\n    _;\\n  }\\n  modifier onlyWhenFinished() {\\n    uint256 timestamp = block.timestamp;\\n    if (timestamp < closingTime()) {\\n      revert SaleNotFinished(timestamp);\\n    }\\n    _;\\n  }\\n\\n  constructor(bytes memory arguments_) {\\n    // tx members\\n    address sender = tx.origin;\\n\\n    // decode\\n    (uint256 supply_, uint256 hardCap_, address wallet_, Stage[] memory stages_) = abi.decode(\\n      arguments_,\\n      (uint256, uint256, address, Stage[])\\n    );\\n\\n    // sale config\\n    uint256 stagesCount = stages_.length;\\n    if (\\n      supply_ == 0 ||\\n      hardCap_ == 0 ||\\n      wallet_ == address(0x0) ||\\n      stagesCount == 0 ||\\n      stagesCount > 16\\n    ) {\\n      revert InvalidConfig(supply_, hardCap_, wallet_, stages_.length);\\n    }\\n\\n    uint256 totalSupply;\\n    uint256 totalValue;\\n    uint256 lastClosingTime = block.timestamp;\\n    for (uint8 i = 0; i < stages_.length; i++) {\\n      Stage memory stage = stages_[i];\\n\\n      // stage config\\n      if (stage.rate == 0) {\\n        revert InvalidStageConfig(stage.rate, i);\\n      }\\n\\n      // stage opening\\n      if (stage.openingTime < lastClosingTime) {\\n        revert StartDateInThePast(stage.openingTime, lastClosingTime, i);\\n      }\\n\\n      // stage closing\\n      if (stage.openingTime >= stage.closingTime) {\\n        revert StartDateNotBeforeEndDate(stage.openingTime, stage.closingTime, i);\\n      }\\n\\n      // requirement of OpenZeppelin crowdsale from V2\\n      // FIXME: to discuss if support for other rates is needed\\n      // 1 token (decimals 0) -> MAX 1 wei\\n      // 1 token (decimals 1) -> MAX 10 wei\\n      // 1 token (decimals 5) -> MAX 100 000 wei\\n      // 1 MLN token (decimals 0) -> MAX 1 MLN wei\\n      if (stage.supply < stage.rate) {\\n        revert SupplySmallerThanRate(stage.supply, stage.rate, i);\\n      }\\n\\n      // increment counters\\n      totalValue += stage.supply / stage.rate;\\n      lastClosingTime = stage.closingTime;\\n      totalSupply += stage.supply;\\n\\n      // storage\\n      stages.push(Phase(stage, 0, 0));\\n    }\\n\\n    // sum of stages supply\\n    if (supply_ != totalSupply) {\\n      revert SupplyMismatch(supply_, totalSupply);\\n    }\\n\\n    // sum of stages hard caps\\n    if (hardCap_ != totalValue) {\\n      revert ValueMismatch(hardCap_, totalValue);\\n    }\\n\\n    // save storage\\n    supply = supply_;\\n    hardCap = hardCap_;\\n    wallet = payable(wallet_);\\n\\n    // base role\\n    _setupRole(DEFAULT_ADMIN_ROLE, sender);\\n  }\\n\\n  function configure(address erc20_, address whitelist_)\\n    external\\n    onlyInState(State.UNCONFIGURED)\\n    onlyRole(DEFAULT_ADMIN_ROLE)\\n  {\\n    // storage\\n    erc20 = ITokenERC20(erc20_);\\n    whitelist = IWhitelist(whitelist_);\\n\\n    // check supply vs params\\n    uint256 saleSupply = erc20.saleSupply();\\n    if (saleSupply != supply) {\\n      revert SupplyConfigurationMishmatch(saleSupply, supply);\\n    }\\n\\n    // check configuration vs balance\\n    uint256 balance = erc20.balanceOf(address(this));\\n    if (saleSupply != balance) {\\n      revert BalanceNotEqualSupply(balance, saleSupply);\\n    }\\n\\n    // state\\n    state = State.CONFIGURED;\\n  }\\n\\n  function buyTokens(address _beneficiary)\\n    external\\n    payable\\n    onlyInState(State.CONFIGURED)\\n    onlyWhenActive\\n  {\\n    // current state\\n    uint8 currentStage = getCurrentStage();\\n    Phase memory phase = stages[currentStage];\\n\\n    // tx members\\n    uint256 weiAmount = msg.value;\\n\\n    // validate receiver\\n    if (_beneficiary == address(0)) {\\n      revert InvalidReceiver(_beneficiary);\\n    }\\n\\n    // check min invesment\\n    if (weiAmount < phase.stage.minAlloc) {\\n      revert NotEnoughBigInvestment(weiAmount, phase.stage.minAlloc);\\n    }\\n\\n    // check hardcap\\n    uint256 raised = weiRaised + weiAmount;\\n    if (raised > hardCap) {\\n      revert HardCapExceeded(raised, hardCap);\\n    }\\n\\n    // calculate token amount to be sold\\n    uint256 tokenAmount = weiAmount * phase.stage.rate;\\n\\n    // check supply\\n    uint256 sold = phase.soldTokens + tokenAmount;\\n    if (sold > phase.stage.supply) {\\n      revert StageSupplyDrained(sold, phase.stage.supply);\\n    }\\n\\n    // use whitelist\\n    if (address(whitelist) != address(0x0)) {\\n      bool success = whitelist.use(weiAmount);\\n      if (!success) {\\n        revert WhitelistNotPassed(msg.sender, weiAmount);\\n      }\\n    }\\n\\n    // update state\\n    weiRaised = raised;\\n    stages[currentStage].weiRaised += weiAmount;\\n    stages[currentStage].soldTokens = sold;\\n\\n    // store profits\\n    wallet.transfer(weiAmount);\\n\\n    // send tokens\\n    erc20.transfer(_beneficiary, tokenAmount);\\n    emit TokenPurchase(msg.sender, _beneficiary, weiAmount, tokenAmount);\\n  }\\n\\n  receive() external payable {\\n    this.buyTokens(msg.sender);\\n  }\\n\\n  function stageCount() external view returns (uint256) {\\n    // frontend view\\n    return stages.length;\\n  }\\n\\n  function rate() external view returns (uint256) {\\n    // rate from current stage\\n    return stages[getCurrentStage()].stage.rate;\\n  }\\n\\n  function openingTime() external view returns (uint256) {\\n    // opening time of first stage\\n    return stages[0].stage.openingTime;\\n  }\\n\\n  function closingTime() public view returns (uint256) {\\n    // closing time of last stage\\n    return stages[getLastStage()].stage.closingTime;\\n  }\\n\\n  function tokensLeft() public view onlyInState(State.CONFIGURED) returns (uint256) {\\n    // tokens left on sale contract\\n    return erc20.balanceOf(address(this));\\n  }\\n\\n  function getLastStage() internal view returns (uint8) {\\n    return uint8(stages.length - 1);\\n  }\\n\\n  function getCurrentStage() public view returns (uint8) {\\n    // tx.members\\n    uint256 timestamp = block.timestamp;\\n\\n    // return active stage\\n    for (uint8 i = 0; i < stages.length; i++) {\\n      if (stages[i].stage.openingTime <= timestamp && timestamp <= stages[i].stage.closingTime) {\\n        return i;\\n      }\\n    }\\n\\n    // revert if no active stage\\n    revert SaleNotActive(timestamp);\\n  }\\n\\n  function hasClosed() external view returns (bool) {\\n    // OpenZeppelin standard method\\n    return block.timestamp > closingTime();\\n  }\\n\\n  function finalize() external onlyInState(State.CONFIGURED) onlyWhenFinished {\\n    // check tokens left\\n    uint256 tokenAmount = tokensLeft();\\n\\n    // revert if no tokens left\\n    if (tokenAmount == 0) {\\n      revert NoTokensLeft();\\n    }\\n\\n    // burn remaining tokens\\n    erc20.burn(tokenAmount);\\n    emit TokenBurn(tokenAmount);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ITokenERC20.sol\": {\r\n      \"content\": \"//Made with Student Coin Terminal\\n//SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.0;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {IToken} from \\\"./IToken.sol\\\";\\n\\ninterface ITokenERC20 is IERC20, IToken {}\\n\"\r\n    },\r\n    \"contracts/vesting/Vesting.sol\": {\r\n      \"content\": \"//Made with Student Coin Terminal\\n//SPDX-License-Identifier: NONE\\npragma solidity ^0.8.0;\\n\\nimport {AccessControl} from \\\"@openzeppelin/contracts/access/AccessControl.sol\\\";\\nimport {Math} from \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\nimport {Configurable} from \\\"../utils/Configurable.sol\\\";\\nimport {ITokenERC20} from \\\"../interfaces/ITokenERC20.sol\\\";\\n\\ncontract Vesting is AccessControl, Configurable {\\n  // structs\\n  struct Shareholder {\\n    address account;\\n    uint8 shares;\\n  }\\n  struct Member {\\n    Shareholder shareholder;\\n    uint256 collected;\\n    uint8 lastCheckpoint;\\n  }\\n\\n  // storage\\n  ITokenERC20 public erc20;\\n  mapping(address => Member) public members;\\n\\n  // config\\n  uint256 public immutable supply;\\n  uint8 public immutable duration; // 1-60\\n  uint256 public startTime;\\n\\n  // events\\n  event Collected(address sender, uint256 amount, uint8 lastCheckpoint, uint8 newCheckpoint);\\n\\n  // errors\\n  error InvalidConfig(uint256 supply_, uint8 duration_);\\n  error SharesNotInTheRange(address account, uint256 shares);\\n  error SharesNotSumTo100(uint256 total);\\n  error InvalidMember(address member);\\n  error NothingToCollect(address member, uint8 collected, uint8 checkpoint);\\n  error SupplyMismatch(uint256 balance, uint256 declared);\\n  error ConfigurationBalanceMishmatch(uint256 amount, uint256 balance);\\n\\n  // modifiers\\n  modifier onlyMember() {\\n    if (members[msg.sender].shareholder.shares == 0) {\\n      revert InvalidMember(msg.sender);\\n    }\\n    _;\\n  }\\n\\n  constructor(bytes memory arguments_) {\\n    // tx members\\n    address sender = tx.origin;\\n\\n    (uint256 supply_, uint8 duration_, Shareholder[] memory shareholders_) = abi.decode(\\n      arguments_,\\n      (uint256, uint8, Shareholder[])\\n    );\\n\\n    // check supply and duration\\n    if (supply_ == 0 || duration_ == 0 || duration_ > 60) {\\n      revert InvalidConfig(supply_, duration_);\\n    }\\n\\n    // check members\\n    uint8 totalShares = 0;\\n    for (uint8 i = 0; i < shareholders_.length; i++) {\\n      Member memory member = Member(shareholders_[i], 0, 0);\\n      uint8 shares = member.shareholder.shares;\\n      address account = member.shareholder.account;\\n\\n      // check address and individual shares\\n      if (account == address(0x0)) {\\n        revert InvalidMember(account);\\n      }\\n      if (shares == 0 || shares > 100) {\\n        revert SharesNotInTheRange(account, shares);\\n      }\\n\\n      members[account] = member;\\n      totalShares += shares;\\n    }\\n\\n    // check sum of shares\\n    if (totalShares != 100) {\\n      revert SharesNotSumTo100(totalShares);\\n    }\\n\\n    // storage\\n    supply = supply_;\\n    duration = duration_;\\n\\n    // base role\\n    _setupRole(DEFAULT_ADMIN_ROLE, sender);\\n  }\\n\\n  function configure(address erc20_)\\n    external\\n    onlyInState(State.UNCONFIGURED)\\n    onlyRole(DEFAULT_ADMIN_ROLE)\\n  {\\n    // tx.members\\n    startTime = block.timestamp;\\n\\n    // token\\n    erc20 = ITokenERC20(erc20_);\\n\\n    // check balance vs supply\\n    uint256 balance = erc20.balanceOf(address(this));\\n    if (balance != supply) {\\n      revert SupplyMismatch(balance, supply);\\n    }\\n\\n    // check configuration vs balance\\n    uint256 vestingSupply = erc20.vestingSupply();\\n    if (vestingSupply != balance) {\\n      revert ConfigurationBalanceMishmatch(vestingSupply, balance);\\n    }\\n\\n    // state\\n    state = State.CONFIGURED;\\n  }\\n\\n  function endTime() public view onlyInState(State.CONFIGURED) returns (uint256) {\\n    // start time + X months (where X is duration)\\n    return startTime + (30 days * duration);\\n  }\\n\\n  function currentCheckpoint() public view onlyInState(State.CONFIGURED) returns (uint8) {\\n    // not started case -> 0\\n    if (startTime > block.timestamp) return 0;\\n\\n    // checkpoint = (now - start time) / month\\n    uint256 checkpoint = (block.timestamp - startTime) / 30 days;\\n\\n    // checkpoint or cap to duration -> 0 ~ duration\\n    return uint8(Math.min(checkpoint, uint256(duration)));\\n  }\\n\\n  function collect() external onlyInState(State.CONFIGURED) onlyMember {\\n    // tx.members\\n    address sender = msg.sender;\\n\\n    // checkpoints\\n    uint8 checkpoint = currentCheckpoint();\\n    uint8 lastCheckpoint = members[sender].lastCheckpoint;\\n\\n    // revert if nothing to collect\\n    if (checkpoint <= lastCheckpoint) {\\n      revert NothingToCollect(sender, lastCheckpoint, checkpoint);\\n    }\\n\\n    uint256 amount;\\n    if (checkpoint == duration) {\\n      // calculate remaining amount\\n      amount = (supply * members[sender].shareholder.shares) / 100 - members[sender].collected;\\n    } else {\\n      // current checkpoint - last checkpoint\\n      uint8 checkpointsToCollect = checkpoint - lastCheckpoint;\\n\\n      // single batch amount\\n      uint256 partialSupply = supply / duration;\\n\\n      // shares of single batch\\n      uint256 singleCheckpointAmount = (partialSupply * members[sender].shareholder.shares) / 100;\\n\\n      // amount based on shares and checkpoints\\n      amount = checkpointsToCollect * singleCheckpointAmount;\\n    }\\n\\n    // update state and transfer\\n    members[sender].lastCheckpoint = checkpoint;\\n    members[sender].collected += amount;\\n    erc20.transfer(sender, amount);\\n\\n    // events\\n    emit Collected(sender, amount, lastCheckpoint, checkpoint);\\n  }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a / b + (a % b == 0 ? 0 : 1);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name_\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol_\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"arguments_\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cap_\",\"type\":\"uint256\"}],\"name\":\"CapExceeded\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"allowance_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"}],\"name\":\"InvalidAllowance\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"decimals_\",\"type\":\"uint8\"}],\"name\":\"InvalidDecimals\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sale_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"saleSupply_\",\"type\":\"uint256\"}],\"name\":\"InvalidSaleConfig\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"percentage_\",\"type\":\"uint256\"}],\"name\":\"InvalidTransactionTax\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vesting_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"vestingSupply_\",\"type\":\"uint256\"}],\"name\":\"InvalidVestingConfig\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"supply_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"saleSupply_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vestingSupply_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cap_\",\"type\":\"uint256\"}],\"name\":\"SupplyGreaterThanCap\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CAN_BURN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CAN_MINT_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DEFAULT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"internalContracts\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"saleAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"saleSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tax\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vestingAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vestingSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "TokenERC20", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000000646726f67677900000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003465247000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001400000000000000000000000000000000000000000000000000000000000000012000000000000000000000000000000000000314dc6448d9338c15b0a0000000000000000000000000000000000000000000018a6e32246c99c60ad85000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}