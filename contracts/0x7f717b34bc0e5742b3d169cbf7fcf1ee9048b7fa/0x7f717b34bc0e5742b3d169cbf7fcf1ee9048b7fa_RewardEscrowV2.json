{"SourceCode": "/*\n    ___            _       ___  _                          \n    | .\\ ___  _ _ <_> ___ | __><_>._ _  ___ ._ _  ___  ___ \n    |  _// ._>| '_>| ||___|| _> | || ' |<_> || ' |/ | '/ ._>\n    |_|  \\___.|_|  |_|     |_|  |_||_|_|<___||_|_|\\_|_.\\___.\n    \n* PeriFinance: RewardEscrowV2.sol\n*\n* Latest source (may be newer): https://github.com/perifinance/peri-finance/blob/master/contracts/RewardEscrowV2.sol\n* Docs: Will be added in the future. \n* https://docs.peri.finance/contracts/source/contracts/RewardEscrowV2\n*\n* Contract Dependencies: \n*\t- BaseRewardEscrowV2\n*\t- IAddressResolver\n*\t- Owned\n* Libraries: \n*\t- SafeDecimalMath\n*\t- SafeMath\n*\t- VestingEntries\n*\n* MIT License\n* ===========\n*\n* Copyright (c) 2021 PeriFinance\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n*/\n\n\n\npragma solidity 0.5.16;\n\n// https://docs.peri.finance/contracts/source/contracts/owned\ncontract Owned {\n    address public owner;\n    address public nominatedOwner;\n\n    constructor(address _owner) public {\n        require(_owner != address(0), \"Owner address cannot be 0\");\n        owner = _owner;\n        emit OwnerChanged(address(0), _owner);\n    }\n\n    function nominateNewOwner(address _owner) external onlyOwner {\n        nominatedOwner = _owner;\n        emit OwnerNominated(_owner);\n    }\n\n    function acceptOwnership() external {\n        require(msg.sender == nominatedOwner, \"You must be nominated before you can accept ownership\");\n        emit OwnerChanged(owner, nominatedOwner);\n        owner = nominatedOwner;\n        nominatedOwner = address(0);\n    }\n\n    modifier onlyOwner {\n        _onlyOwner();\n        _;\n    }\n\n    function _onlyOwner() private view {\n        require(msg.sender == owner, \"Only the contract owner may perform this action\");\n    }\n\n    event OwnerNominated(address newOwner);\n    event OwnerChanged(address oldOwner, address newOwner);\n}\n\n\n// https://docs.peri.finance/contracts/source/interfaces/iaddressresolver\ninterface IAddressResolver {\n    function getAddress(bytes32 name) external view returns (address);\n\n    function getPynth(bytes32 key) external view returns (address);\n\n    function requireAndGetAddress(bytes32 name, string calldata reason) external view returns (address);\n}\n\n\n// https://docs.peri.finance/contracts/source/interfaces/ipynth\ninterface IPynth {\n    // Views\n    function currencyKey() external view returns (bytes32);\n\n    function transferablePynths(address account) external view returns (uint);\n\n    // Mutative functions\n    function transferAndSettle(address to, uint value) external returns (bool);\n\n    function transferFromAndSettle(\n        address from,\n        address to,\n        uint value\n    ) external returns (bool);\n\n    // Restricted: used internally to PeriFinance\n    function burn(address account, uint amount) external;\n\n    function issue(address account, uint amount) external;\n}\n\n\n// https://docs.peri.finance/contracts/source/interfaces/iissuer\ninterface IIssuer {\n    // Views\n    function anyPynthOrPERIRateIsInvalid() external view returns (bool anyRateInvalid);\n\n    function availableCurrencyKeys() external view returns (bytes32[] memory);\n\n    function availablePynthCount() external view returns (uint);\n\n    function availablePynths(uint index) external view returns (IPynth);\n\n    function canBurnPynths(address account) external view returns (bool);\n\n    function collateral(address account) external view returns (uint);\n\n    function collateralisationRatio(address issuer) external view returns (uint);\n\n    function collateralisationRatioAndAnyRatesInvalid(address _issuer)\n        external\n        view\n        returns (uint cratio, bool anyRateIsInvalid);\n\n    function debtBalanceOf(address issuer, bytes32 currencyKey) external view returns (uint debtBalance);\n\n    function issuanceRatio() external view returns (uint);\n\n    function externalTokenLimit() external view returns (uint);\n\n    function lastIssueEvent(address account) external view returns (uint);\n\n    function maxIssuablePynths(address issuer) external view returns (uint maxIssuable);\n\n    function externalTokenQuota(\n        address _account,\n        uint _addtionalpUSD,\n        uint _addtionalExToken,\n        bool _isIssue\n    ) external view returns (uint);\n\n    function maxExternalTokenStakeAmount(address _account, bytes32 _currencyKey)\n        external\n        view\n        returns (uint issueAmountToQuota, uint stakeAmountToQuota);\n\n    function minimumStakeTime() external view returns (uint);\n\n    function remainingIssuablePynths(address issuer)\n        external\n        view\n        returns (\n            uint maxIssuable,\n            uint alreadyIssued,\n            uint totalSystemDebt\n        );\n\n    function pynths(bytes32 currencyKey) external view returns (IPynth);\n\n    function getPynths(bytes32[] calldata currencyKeys) external view returns (IPynth[] memory);\n\n    function pynthsByAddress(address pynthAddress) external view returns (bytes32);\n\n    function totalIssuedPynths(bytes32 currencyKey, bool excludeEtherCollateral) external view returns (uint);\n\n    function transferablePeriFinanceAndAnyRateIsInvalid(address account, uint balance)\n        external\n        view\n        returns (uint transferable, bool anyRateIsInvalid);\n\n    // Restricted: used internally to PeriFinance\n    function issuePynths(\n        address _issuer,\n        bytes32 _currencyKey,\n        uint _issueAmount\n    ) external;\n\n    function issueMaxPynths(address _issuer) external;\n\n    function issuePynthsToMaxQuota(address _issuer, bytes32 _currencyKey) external;\n\n    function burnPynths(\n        address _from,\n        bytes32 _currencyKey,\n        uint _burnAmount\n    ) external;\n\n    function fitToClaimable(address _from) external;\n\n    function exit(address _from) external;\n\n    function liquidateDelinquentAccount(\n        address account,\n        uint pusdAmount,\n        address liquidator\n    ) external returns (uint totalRedeemed, uint amountToLiquidate);\n}\n\n\n// Inheritance\n\n\n// Internal references\n\n\n// https://docs.peri.finance/contracts/source/contracts/addressresolver\ncontract AddressResolver is Owned, IAddressResolver {\n    mapping(bytes32 => address) public repository;\n\n    constructor(address _owner) public Owned(_owner) {}\n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    function importAddresses(bytes32[] calldata names, address[] calldata destinations) external onlyOwner {\n        require(names.length == destinations.length, \"Input lengths must match\");\n\n        for (uint i = 0; i < names.length; i++) {\n            bytes32 name = names[i];\n            address destination = destinations[i];\n            repository[name] = destination;\n            emit AddressImported(name, destination);\n        }\n    }\n\n    /* ========= PUBLIC FUNCTIONS ========== */\n\n    function rebuildCaches(MixinResolver[] calldata destinations) external {\n        for (uint i = 0; i < destinations.length; i++) {\n            destinations[i].rebuildCache();\n        }\n    }\n\n    /* ========== VIEWS ========== */\n\n    function areAddressesImported(bytes32[] calldata names, address[] calldata destinations) external view returns (bool) {\n        for (uint i = 0; i < names.length; i++) {\n            if (repository[names[i]] != destinations[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    function getAddress(bytes32 name) external view returns (address) {\n        return repository[name];\n    }\n\n    function requireAndGetAddress(bytes32 name, string calldata reason) external view returns (address) {\n        address _foundAddress = repository[name];\n        require(_foundAddress != address(0), reason);\n        return _foundAddress;\n    }\n\n    function getPynth(bytes32 key) external view returns (address) {\n        IIssuer issuer = IIssuer(repository[\"Issuer\"]);\n        require(address(issuer) != address(0), \"Cannot find Issuer address\");\n        return address(issuer.pynths(key));\n    }\n\n    /* ========== EVENTS ========== */\n\n    event AddressImported(bytes32 name, address destination);\n}\n\n\n// solhint-disable payable-fallback\n\n// https://docs.peri.finance/contracts/source/contracts/readproxy\ncontract ReadProxy is Owned {\n    address public target;\n\n    constructor(address _owner) public Owned(_owner) {}\n\n    function setTarget(address _target) external onlyOwner {\n        target = _target;\n        emit TargetUpdated(target);\n    }\n\n    function() external {\n        // The basics of a proxy read call\n        // Note that msg.sender in the underlying will always be the address of this contract.\n        assembly {\n            calldatacopy(0, 0, calldatasize)\n\n            // Use of staticcall - this will revert if the underlying function mutates state\n            let result := staticcall(gas, sload(target_slot), 0, calldatasize, 0, 0)\n            returndatacopy(0, 0, returndatasize)\n\n            if iszero(result) {\n                revert(0, returndatasize)\n            }\n            return(0, returndatasize)\n        }\n    }\n\n    event TargetUpdated(address newTarget);\n}\n\n\n// Inheritance\n\n\n// Internal references\n\n\n// https://docs.peri.finance/contracts/source/contracts/mixinresolver\ncontract MixinResolver {\n    AddressResolver public resolver;\n\n    mapping(bytes32 => address) private addressCache;\n\n    constructor(address _resolver) internal {\n        resolver = AddressResolver(_resolver);\n    }\n\n    /* ========== INTERNAL FUNCTIONS ========== */\n\n    function combineArrays(bytes32[] memory first, bytes32[] memory second)\n        internal\n        pure\n        returns (bytes32[] memory combination)\n    {\n        combination = new bytes32[](first.length + second.length);\n\n        for (uint i = 0; i < first.length; i++) {\n            combination[i] = first[i];\n        }\n\n        for (uint j = 0; j < second.length; j++) {\n            combination[first.length + j] = second[j];\n        }\n    }\n\n    /* ========== PUBLIC FUNCTIONS ========== */\n\n    // Note: this function is public not external in order for it to be overridden and invoked via super in subclasses\n    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {}\n\n    function rebuildCache() public {\n        bytes32[] memory requiredAddresses = resolverAddressesRequired();\n        // The resolver must call this function whenver it updates its state\n        for (uint i = 0; i < requiredAddresses.length; i++) {\n            bytes32 name = requiredAddresses[i];\n            // Note: can only be invoked once the resolver has all the targets needed added\n            address destination =\n                resolver.requireAndGetAddress(name, string(abi.encodePacked(\"Resolver missing target: \", name)));\n            addressCache[name] = destination;\n            emit CacheUpdated(name, destination);\n        }\n    }\n\n    /* ========== VIEWS ========== */\n\n    function isResolverCached() external view returns (bool) {\n        bytes32[] memory requiredAddresses = resolverAddressesRequired();\n        for (uint i = 0; i < requiredAddresses.length; i++) {\n            bytes32 name = requiredAddresses[i];\n            // false if our cache is invalid or if the resolver doesn't have the required address\n            if (resolver.getAddress(name) != addressCache[name] || addressCache[name] == address(0)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /* ========== INTERNAL FUNCTIONS ========== */\n\n    function requireAndGetAddress(bytes32 name) internal view returns (address) {\n        address _foundAddress = addressCache[name];\n        require(_foundAddress != address(0), string(abi.encodePacked(\"Missing address: \", name)));\n        return _foundAddress;\n    }\n\n    /* ========== EVENTS ========== */\n\n    event CacheUpdated(bytes32 name, address destination);\n}\n\n\n// https://docs.peri.finance/contracts/source/contracts/limitedsetup\ncontract LimitedSetup {\n    uint public setupExpiryTime;\n\n    /**\n     * @dev LimitedSetup Constructor.\n     * @param setupDuration The time the setup period will last for.\n     */\n    constructor(uint setupDuration) internal {\n        setupExpiryTime = now + setupDuration;\n    }\n\n    modifier onlyDuringSetup {\n        require(now < setupExpiryTime, \"Can only perform this action during setup\");\n        _;\n    }\n}\n\n\npragma experimental ABIEncoderV2;\n\nlibrary VestingEntries {\n    struct VestingEntry {\n        uint64 endTime;\n        uint256 escrowAmount;\n    }\n    struct VestingEntryWithID {\n        uint64 endTime;\n        uint256 escrowAmount;\n        uint256 entryID;\n    }\n}\n\ninterface IRewardEscrowV2 {\n    // Views\n    function balanceOf(address account) external view returns (uint);\n\n    function numVestingEntries(address account) external view returns (uint);\n\n    function totalEscrowedAccountBalance(address account) external view returns (uint);\n\n    function totalVestedAccountBalance(address account) external view returns (uint);\n\n    function getVestingQuantity(address account, uint256[] calldata entryIDs) external view returns (uint);\n\n    function getVestingSchedules(\n        address account,\n        uint256 index,\n        uint256 pageSize\n    ) external view returns (VestingEntries.VestingEntryWithID[] memory);\n\n    function getAccountVestingEntryIDs(\n        address account,\n        uint256 index,\n        uint256 pageSize\n    ) external view returns (uint256[] memory);\n\n    function getVestingEntryClaimable(address account, uint256 entryID) external view returns (uint);\n\n    function getVestingEntry(address account, uint256 entryID) external view returns (uint64, uint256);\n\n    // Mutative functions\n    function vest(uint256[] calldata entryIDs) external;\n\n    function createEscrowEntry(\n        address beneficiary,\n        uint256 deposit,\n        uint256 duration\n    ) external;\n\n    function appendVestingEntry(\n        address account,\n        uint256 quantity,\n        uint256 duration\n    ) external;\n\n    function migrateVestingSchedule(address _addressToMigrate) external;\n\n    function migrateAccountEscrowBalances(\n        address[] calldata accounts,\n        uint256[] calldata escrowBalances,\n        uint256[] calldata vestedBalances\n    ) external;\n\n    // Account Merging\n    function startMergingWindow() external;\n\n    function mergeAccount(address accountToMerge, uint256[] calldata entryIDs) external;\n\n    function nominateAccountToMerge(address account) external;\n\n    function accountMergingIsOpen() external view returns (bool);\n\n    // L2 Migration\n    function importVestingEntries(\n        address account,\n        uint256 escrowedAmount,\n        VestingEntries.VestingEntry[] calldata vestingEntries\n    ) external;\n\n    // Return amount of PERI transfered to PeriFinanceBridgeToOptimism deposit contract\n    function burnForMigration(address account, uint256[] calldata entryIDs)\n        external\n        returns (uint256 escrowedAccountBalance, VestingEntries.VestingEntry[] memory vestingEntries);\n}\n\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, \"SafeMath: division by zero\");\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n}\n\n\n// Libraries\n\n\n// https://docs.peri.finance/contracts/source/libraries/safedecimalmath\nlibrary SafeDecimalMath {\n    using SafeMath for uint;\n\n    /* Number of decimal places in the representations. */\n    uint8 public constant decimals = 18;\n    uint8 public constant highPrecisionDecimals = 27;\n\n    /* The number representing 1.0. */\n    uint public constant UNIT = 10**uint(decimals);\n\n    /* The number representing 1.0 for higher fidelity numbers. */\n    uint public constant PRECISE_UNIT = 10**uint(highPrecisionDecimals);\n    uint private constant UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR = 10**uint(highPrecisionDecimals - decimals);\n\n    /**\n     * @return Provides an interface to UNIT.\n     */\n    function unit() external pure returns (uint) {\n        return UNIT;\n    }\n\n    /**\n     * @return Provides an interface to PRECISE_UNIT.\n     */\n    function preciseUnit() external pure returns (uint) {\n        return PRECISE_UNIT;\n    }\n\n    /**\n     * @return The result of multiplying x and y, interpreting the operands as fixed-point\n     * decimals.\n     *\n     * @dev A unit factor is divided out after the product of x and y is evaluated,\n     * so that product must be less than 2**256. As this is an integer division,\n     * the internal division always rounds down. This helps save on gas. Rounding\n     * is more expensive on gas.\n     */\n    function multiplyDecimal(uint x, uint y) internal pure returns (uint) {\n        /* Divide by UNIT to remove the extra factor introduced by the product. */\n        return x.mul(y) / UNIT;\n    }\n\n    /**\n     * @return The result of safely multiplying x and y, interpreting the operands\n     * as fixed-point decimals of the specified precision unit.\n     *\n     * @dev The operands should be in the form of a the specified unit factor which will be\n     * divided out after the product of x and y is evaluated, so that product must be\n     * less than 2**256.\n     *\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\n     * (eg. small fractions or percentages).\n     */\n    function _multiplyDecimalRound(\n        uint x,\n        uint y,\n        uint precisionUnit\n    ) private pure returns (uint) {\n        /* Divide by UNIT to remove the extra factor introduced by the product. */\n        uint quotientTimesTen = x.mul(y) / (precisionUnit / 10);\n\n        if (quotientTimesTen % 10 >= 5) {\n            quotientTimesTen += 10;\n        }\n\n        return quotientTimesTen / 10;\n    }\n\n    /**\n     * @return The result of safely multiplying x and y, interpreting the operands\n     * as fixed-point decimals of a precise unit.\n     *\n     * @dev The operands should be in the precise unit factor which will be\n     * divided out after the product of x and y is evaluated, so that product must be\n     * less than 2**256.\n     *\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\n     * (eg. small fractions or percentages).\n     */\n    function multiplyDecimalRoundPrecise(uint x, uint y) internal pure returns (uint) {\n        return _multiplyDecimalRound(x, y, PRECISE_UNIT);\n    }\n\n    /**\n     * @return The result of safely multiplying x and y, interpreting the operands\n     * as fixed-point decimals of a standard unit.\n     *\n     * @dev The operands should be in the standard unit factor which will be\n     * divided out after the product of x and y is evaluated, so that product must be\n     * less than 2**256.\n     *\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\n     * (eg. small fractions or percentages).\n     */\n    function multiplyDecimalRound(uint x, uint y) internal pure returns (uint) {\n        return _multiplyDecimalRound(x, y, UNIT);\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is a high\n     * precision decimal.\n     *\n     * @dev y is divided after the product of x and the standard precision unit\n     * is evaluated, so the product of x and UNIT must be less than 2**256. As\n     * this is an integer division, the result is always rounded down.\n     * This helps save on gas. Rounding is more expensive on gas.\n     */\n    function divideDecimal(uint x, uint y) internal pure returns (uint) {\n        /* Reintroduce the UNIT factor that will be divided out by y. */\n        return x.mul(UNIT).div(y);\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is as a rounded\n     * decimal in the precision unit specified in the parameter.\n     *\n     * @dev y is divided after the product of x and the specified precision unit\n     * is evaluated, so the product of x and the specified precision unit must\n     * be less than 2**256. The result is rounded to the nearest increment.\n     */\n    function _divideDecimalRound(\n        uint x,\n        uint y,\n        uint precisionUnit\n    ) private pure returns (uint) {\n        uint resultTimesTen = x.mul(precisionUnit * 10).div(y);\n\n        if (resultTimesTen % 10 >= 5) {\n            resultTimesTen += 10;\n        }\n\n        return resultTimesTen / 10;\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is as a rounded\n     * standard precision decimal.\n     *\n     * @dev y is divided after the product of x and the standard precision unit\n     * is evaluated, so the product of x and the standard precision unit must\n     * be less than 2**256. The result is rounded to the nearest increment.\n     */\n    function divideDecimalRound(uint x, uint y) internal pure returns (uint) {\n        return _divideDecimalRound(x, y, UNIT);\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is as a rounded\n     * high precision decimal.\n     *\n     * @dev y is divided after the product of x and the high precision unit\n     * is evaluated, so the product of x and the high precision unit must\n     * be less than 2**256. The result is rounded to the nearest increment.\n     */\n    function divideDecimalRoundPrecise(uint x, uint y) internal pure returns (uint) {\n        return _divideDecimalRound(x, y, PRECISE_UNIT);\n    }\n\n    /**\n     * @dev Convert a standard decimal representation to a high precision one.\n     */\n    function decimalToPreciseDecimal(uint i) internal pure returns (uint) {\n        return i.mul(UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR);\n    }\n\n    /**\n     * @dev Convert a high precision decimal to a standard decimal representation.\n     */\n    function preciseDecimalToDecimal(uint i) internal pure returns (uint) {\n        uint quotientTimesTen = i / (UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR / 10);\n\n        if (quotientTimesTen % 10 >= 5) {\n            quotientTimesTen += 10;\n        }\n\n        return quotientTimesTen / 10;\n    }\n\n    /**\n     * @dev Round down the value with given number\n     */\n    function roundDownDecimal(uint x, uint d) internal pure returns (uint) {\n        return x.div(10**d).mul(10**d);\n    }\n\n    /**\n     * @dev Round up the value with given number\n     */\n    function roundUpDecimal(uint x, uint d) internal pure returns (uint) {\n        uint _decimal = 10**d;\n\n        if (x % _decimal > 0) {\n            x = x.add(10**d);\n        }\n\n        return x.div(_decimal).mul(_decimal);\n    }\n}\n\n\n// https://docs.peri.finance/contracts/source/interfaces/ierc20\ninterface IERC20 {\n    // ERC20 Optional Views\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n\n    // Views\n    function totalSupply() external view returns (uint);\n\n    function balanceOf(address owner) external view returns (uint);\n\n    function allowance(address owner, address spender) external view returns (uint);\n\n    // Mutative functions\n    function transfer(address to, uint value) external returns (bool);\n\n    function approve(address spender, uint value) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint value\n    ) external returns (bool);\n\n    // Events\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    event Approval(address indexed owner, address indexed spender, uint value);\n}\n\n\n// https://docs.peri.finance/contracts/source/interfaces/ifeepool\ninterface IFeePool {\n    // Views\n\n    // solhint-disable-next-line func-name-mixedcase\n    function FEE_ADDRESS() external view returns (address);\n\n    function feesAvailable(address account) external view returns (uint, uint);\n\n    function feePeriodDuration() external view returns (uint);\n\n    function isFeesClaimable(address account) external view returns (bool);\n\n    function targetThreshold() external view returns (uint);\n\n    function totalFeesAvailable() external view returns (uint);\n\n    function totalRewardsAvailable() external view returns (uint);\n\n    // Mutative Functions\n    function claimFees() external returns (bool);\n\n    function claimOnBehalf(address claimingForAddress) external returns (bool);\n\n    function closeCurrentFeePeriod() external;\n\n    // Restricted: used internally to PeriFinance\n    function appendAccountIssuanceRecord(\n        address account,\n        uint lockedAmount,\n        uint debtEntryIndex\n    ) external;\n\n    function recordFeePaid(uint pUSDAmount) external;\n\n    function setRewardsToDistribute(uint amount) external;\n}\n\n\ninterface IVirtualPynth {\n    // Views\n    function balanceOfUnderlying(address account) external view returns (uint);\n\n    function rate() external view returns (uint);\n\n    function readyToSettle() external view returns (bool);\n\n    function secsLeftInWaitingPeriod() external view returns (uint);\n\n    function settled() external view returns (bool);\n\n    function pynth() external view returns (IPynth);\n\n    // Mutative functions\n    function settle(address account) external;\n}\n\n\n// https://docs.peri.finance/contracts/source/interfaces/iperiFinance\ninterface IPeriFinance {\n    // Views\n    function getRequiredAddress(bytes32 contractName) external view returns (address);\n\n    function anyPynthOrPERIRateIsInvalid() external view returns (bool anyRateInvalid);\n\n    function availableCurrencyKeys() external view returns (bytes32[] memory);\n\n    function availablePynthCount() external view returns (uint);\n\n    function availablePynths(uint index) external view returns (IPynth);\n\n    function collateral(address account) external view returns (uint);\n\n    function collateralisationRatio(address issuer) external view returns (uint);\n\n    function debtBalanceOf(address issuer, bytes32 currencyKey) external view returns (uint);\n\n    function isWaitingPeriod(bytes32 currencyKey) external view returns (bool);\n\n    function maxIssuablePynths(address issuer) external view returns (uint maxIssuable);\n\n    function externalTokenQuota(\n        address _account,\n        uint _additionalpUSD,\n        uint _additionalExToken,\n        bool _isIssue\n    ) external view returns (uint);\n\n    function remainingIssuablePynths(address issuer)\n        external\n        view\n        returns (\n            uint maxIssuable,\n            uint alreadyIssued,\n            uint totalSystemDebt\n        );\n\n    function maxExternalTokenStakeAmount(address _account, bytes32 _currencyKey)\n        external\n        view\n        returns (uint issueAmountToQuota, uint stakeAmountToQuota);\n\n    function pynths(bytes32 currencyKey) external view returns (IPynth);\n\n    function pynthsByAddress(address pynthAddress) external view returns (bytes32);\n\n    function totalIssuedPynths(bytes32 currencyKey) external view returns (uint);\n\n    function totalIssuedPynthsExcludeEtherCollateral(bytes32 currencyKey) external view returns (uint);\n\n    function transferablePeriFinance(address account) external view returns (uint transferable);\n\n    // Mutative Functions\n    function issuePynths(bytes32 _currencyKey, uint _issueAmount) external;\n\n    function issueMaxPynths() external;\n\n    function issuePynthsToMaxQuota(bytes32 _currencyKey) external;\n\n    function burnPynths(bytes32 _currencyKey, uint _burnAmount) external;\n\n    function fitToClaimable() external;\n\n    function exit() external;\n\n    function exchange(\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey\n    ) external returns (uint amountReceived);\n\n    function exchangeOnBehalf(\n        address exchangeForAddress,\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey\n    ) external returns (uint amountReceived);\n\n    function exchangeWithTracking(\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey,\n        address originator,\n        bytes32 trackingCode\n    ) external returns (uint amountReceived);\n\n    function exchangeOnBehalfWithTracking(\n        address exchangeForAddress,\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey,\n        address originator,\n        bytes32 trackingCode\n    ) external returns (uint amountReceived);\n\n    function exchangeWithVirtual(\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey,\n        bytes32 trackingCode\n    ) external returns (uint amountReceived, IVirtualPynth vPynth);\n\n    function mint(address _user, uint _amount) external returns (bool);\n\n    function inflationalMint(uint _networkDebtShare) external returns (bool);\n\n    function settle(bytes32 currencyKey)\n        external\n        returns (\n            uint reclaimed,\n            uint refunded,\n            uint numEntries\n        );\n\n    // Liquidations\n    function liquidateDelinquentAccount(address account, uint pusdAmount) external returns (bool);\n\n    // Restricted Functions\n\n    function mintSecondary(address account, uint amount) external;\n\n    function mintSecondaryRewards(uint amount) external;\n\n    function burnSecondary(address account, uint amount) external;\n}\n\n\n// Inheritance\n\n\n// Libraries\n\n\n// Internal references\n\n\n// https://docs.peri.finance/contracts/RewardEscrow\ncontract BaseRewardEscrowV2 is Owned, IRewardEscrowV2, LimitedSetup(8 weeks), MixinResolver {\n    using SafeMath for uint;\n    using SafeDecimalMath for uint;\n\n    mapping(address => mapping(uint256 => VestingEntries.VestingEntry)) public vestingSchedules;\n\n    mapping(address => uint256[]) public accountVestingEntryIDs;\n\n    /*Counter for new vesting entry ids. */\n    uint256 public nextEntryId;\n\n    /* An account's total escrowed periFinance balance to save recomputing this for fee extraction purposes. */\n    mapping(address => uint256) public totalEscrowedAccountBalance;\n\n    /* An account's total vested reward periFinance. */\n    mapping(address => uint256) public totalVestedAccountBalance;\n\n    /* Mapping of nominated address to recieve account merging */\n    mapping(address => address) public nominatedReceiver;\n\n    /* The total remaining escrowed balance, for verifying the actual periFinance balance of this contract against. */\n    uint256 public totalEscrowedBalance;\n\n    /* Max escrow duration */\n    uint public max_duration = 2 * 52 weeks; // Default max 2 years duration\n\n    /* Max account merging duration */\n    uint public maxAccountMergingDuration = 4 weeks; // Default 4 weeks is max\n\n    /* ========== ACCOUNT MERGING CONFIGURATION ========== */\n\n    uint public accountMergingDuration = 1 weeks;\n\n    uint public accountMergingStartTime;\n\n    /* ========== ADDRESS RESOLVER CONFIGURATION ========== */\n\n    bytes32 private constant CONTRACT_PERIFINANCE = \"PeriFinance\";\n    bytes32 private constant CONTRACT_ISSUER = \"Issuer\";\n    bytes32 private constant CONTRACT_FEEPOOL = \"FeePool\";\n\n    /* ========== CONSTRUCTOR ========== */\n\n    constructor(address _owner, address _resolver) public Owned(_owner) MixinResolver(_resolver) {\n        nextEntryId = 1;\n    }\n\n    /* ========== VIEWS ======================= */\n\n    function feePool() internal view returns (IFeePool) {\n        return IFeePool(requireAndGetAddress(CONTRACT_FEEPOOL));\n    }\n\n    function periFinance() internal view returns (IPeriFinance) {\n        return IPeriFinance(requireAndGetAddress(CONTRACT_PERIFINANCE));\n    }\n\n    function issuer() internal view returns (IIssuer) {\n        return IIssuer(requireAndGetAddress(CONTRACT_ISSUER));\n    }\n\n    function _notImplemented() internal pure {\n        revert(\"Cannot be run on this layer\");\n    }\n\n    /* ========== VIEW FUNCTIONS ========== */\n\n    // Note: use public visibility so that it can be invoked in a subclass\n    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {\n        addresses = new bytes32[](3);\n        addresses[0] = CONTRACT_PERIFINANCE;\n        addresses[1] = CONTRACT_FEEPOOL;\n        addresses[2] = CONTRACT_ISSUER;\n    }\n\n    /**\n     * @notice A simple alias to totalEscrowedAccountBalance: provides ERC20 balance integration.\n     */\n    function balanceOf(address account) public view returns (uint) {\n        return totalEscrowedAccountBalance[account];\n    }\n\n    /**\n     * @notice The number of vesting dates in an account's schedule.\n     */\n    function numVestingEntries(address account) external view returns (uint) {\n        return accountVestingEntryIDs[account].length;\n    }\n\n    /**\n     * @notice Get a particular schedule entry for an account.\n     * @return The vesting entry object and rate per second emission.\n     */\n    function getVestingEntry(address account, uint256 entryID) external view returns (uint64 endTime, uint256 escrowAmount) {\n        endTime = vestingSchedules[account][entryID].endTime;\n        escrowAmount = vestingSchedules[account][entryID].escrowAmount;\n    }\n\n    function getVestingSchedules(\n        address account,\n        uint256 index,\n        uint256 pageSize\n    ) external view returns (VestingEntries.VestingEntryWithID[] memory) {\n        uint256 endIndex = index + pageSize;\n\n        // If index starts after the endIndex return no results\n        if (endIndex <= index) {\n            return new VestingEntries.VestingEntryWithID[](0);\n        }\n\n        // If the page extends past the end of the accountVestingEntryIDs, truncate it.\n        if (endIndex > accountVestingEntryIDs[account].length) {\n            endIndex = accountVestingEntryIDs[account].length;\n        }\n\n        uint256 n = endIndex - index;\n        VestingEntries.VestingEntryWithID[] memory vestingEntries = new VestingEntries.VestingEntryWithID[](n);\n        for (uint256 i; i < n; i++) {\n            uint256 entryID = accountVestingEntryIDs[account][i + index];\n\n            VestingEntries.VestingEntry memory entry = vestingSchedules[account][entryID];\n\n            vestingEntries[i] = VestingEntries.VestingEntryWithID({\n                endTime: uint64(entry.endTime),\n                escrowAmount: entry.escrowAmount,\n                entryID: entryID\n            });\n        }\n        return vestingEntries;\n    }\n\n    function getAccountVestingEntryIDs(\n        address account,\n        uint256 index,\n        uint256 pageSize\n    ) external view returns (uint256[] memory) {\n        uint256 endIndex = index + pageSize;\n\n        // If the page extends past the end of the accountVestingEntryIDs, truncate it.\n        if (endIndex > accountVestingEntryIDs[account].length) {\n            endIndex = accountVestingEntryIDs[account].length;\n        }\n        if (endIndex <= index) {\n            return new uint256[](0);\n        }\n\n        uint256 n = endIndex - index;\n        uint256[] memory page = new uint256[](n);\n        for (uint256 i; i < n; i++) {\n            page[i] = accountVestingEntryIDs[account][i + index];\n        }\n        return page;\n    }\n\n    function getVestingQuantity(address account, uint256[] calldata entryIDs) external view returns (uint total) {\n        for (uint i = 0; i < entryIDs.length; i++) {\n            VestingEntries.VestingEntry memory entry = vestingSchedules[account][entryIDs[i]];\n\n            /* Skip entry if escrowAmount == 0 */\n            if (entry.escrowAmount != 0) {\n                uint256 quantity = _claimableAmount(entry);\n\n                /* add quantity to total */\n                total = total.add(quantity);\n            }\n        }\n    }\n\n    function getVestingEntryClaimable(address account, uint256 entryID) external view returns (uint) {\n        VestingEntries.VestingEntry memory entry = vestingSchedules[account][entryID];\n        return _claimableAmount(entry);\n    }\n\n    function _claimableAmount(VestingEntries.VestingEntry memory _entry) internal view returns (uint256) {\n        uint256 quantity;\n        if (_entry.escrowAmount != 0) {\n            /* Escrow amounts claimable if block.timestamp equal to or after entry endTime */\n            quantity = block.timestamp >= _entry.endTime ? _entry.escrowAmount : 0;\n        }\n        return quantity;\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    /**\n     * Vest escrowed amounts that are claimable\n     * Allows users to vest their vesting entries based on msg.sender\n     */\n\n    function vest(uint256[] calldata entryIDs) external {\n        uint256 total;\n        for (uint i = 0; i < entryIDs.length; i++) {\n            VestingEntries.VestingEntry storage entry = vestingSchedules[msg.sender][entryIDs[i]];\n\n            /* Skip entry if escrowAmount == 0 already vested */\n            if (entry.escrowAmount != 0) {\n                uint256 quantity = _claimableAmount(entry);\n\n                /* update entry to remove escrowAmount */\n                if (quantity > 0) {\n                    entry.escrowAmount = 0;\n                }\n\n                /* add quantity to total */\n                total = total.add(quantity);\n            }\n        }\n\n        /* Transfer vested tokens. Will revert if total > totalEscrowedAccountBalance */\n        if (total != 0) {\n            _transferVestedTokens(msg.sender, total);\n        }\n    }\n\n    /**\n     * @notice Create an escrow entry to lock PERI for a given duration in seconds\n     * @dev This call expects that the depositor (msg.sender) has already approved the Reward escrow contract\n     to spend the the amount being escrowed.\n     */\n    function createEscrowEntry(\n        address beneficiary,\n        uint256 deposit,\n        uint256 duration\n    ) external {\n        require(beneficiary != address(0), \"Cannot create escrow with address(0)\");\n\n        /* Transfer PERI from msg.sender */\n        require(IERC20(address(periFinance())).transferFrom(msg.sender, address(this), deposit), \"token transfer failed\");\n\n        /* Append vesting entry for the beneficiary address */\n        _appendVestingEntry(beneficiary, deposit, duration);\n    }\n\n    /**\n     * @notice Add a new vesting entry at a given time and quantity to an account's schedule.\n     * @dev A call to this should accompany a previous successful call to periFinance.transfer(rewardEscrow, amount),\n     * to ensure that when the funds are withdrawn, there is enough balance.\n     * @param account The account to append a new vesting entry to.\n     * @param quantity The quantity of PERI that will be escrowed.\n     * @param duration The duration that PERI will be emitted.\n     */\n    function appendVestingEntry(\n        address account,\n        uint256 quantity,\n        uint256 duration\n    ) external onlyFeePool {\n        _appendVestingEntry(account, quantity, duration);\n    }\n\n    /* Transfer vested tokens and update totalEscrowedAccountBalance, totalVestedAccountBalance */\n    function _transferVestedTokens(address _account, uint256 _amount) internal {\n        _reduceAccountEscrowBalances(_account, _amount);\n        totalVestedAccountBalance[_account] = totalVestedAccountBalance[_account].add(_amount);\n        IERC20(address(periFinance())).transfer(_account, _amount);\n        emit Vested(_account, block.timestamp, _amount);\n    }\n\n    function _reduceAccountEscrowBalances(address _account, uint256 _amount) internal {\n        // Reverts if amount being vested is greater than the account's existing totalEscrowedAccountBalance\n        totalEscrowedBalance = totalEscrowedBalance.sub(_amount);\n        totalEscrowedAccountBalance[_account] = totalEscrowedAccountBalance[_account].sub(_amount);\n    }\n\n    /* ========== ACCOUNT MERGING ========== */\n\n    function accountMergingIsOpen() public view returns (bool) {\n        return accountMergingStartTime.add(accountMergingDuration) > block.timestamp;\n    }\n\n    function startMergingWindow() external onlyOwner {\n        accountMergingStartTime = block.timestamp;\n        emit AccountMergingStarted(accountMergingStartTime, accountMergingStartTime.add(accountMergingDuration));\n    }\n\n    function setAccountMergingDuration(uint256 duration) external onlyOwner {\n        require(duration <= maxAccountMergingDuration, \"exceeds max merging duration\");\n        accountMergingDuration = duration;\n        emit AccountMergingDurationUpdated(duration);\n    }\n\n    function setMaxAccountMergingWindow(uint256 duration) external onlyOwner {\n        maxAccountMergingDuration = duration;\n        emit MaxAccountMergingDurationUpdated(duration);\n    }\n\n    function setMaxEscrowDuration(uint256 duration) external onlyOwner {\n        max_duration = duration;\n        emit MaxEscrowDurationUpdated(duration);\n    }\n\n    /* Nominate an account to merge escrow and vesting schedule */\n    function nominateAccountToMerge(address account) external {\n        require(account != msg.sender, \"Cannot nominate own account to merge\");\n        require(accountMergingIsOpen(), \"Account merging has ended\");\n        require(issuer().debtBalanceOf(msg.sender, \"pUSD\") == 0, \"Cannot merge accounts with debt\");\n        nominatedReceiver[msg.sender] = account;\n        emit NominateAccountToMerge(msg.sender, account);\n    }\n\n    function mergeAccount(address accountToMerge, uint256[] calldata entryIDs) external {\n        require(accountMergingIsOpen(), \"Account merging has ended\");\n        require(issuer().debtBalanceOf(accountToMerge, \"pUSD\") == 0, \"Cannot merge accounts with debt\");\n        require(nominatedReceiver[accountToMerge] == msg.sender, \"Address is not nominated to merge\");\n\n        uint256 totalEscrowAmountMerged;\n        for (uint i = 0; i < entryIDs.length; i++) {\n            // retrieve entry\n            VestingEntries.VestingEntry memory entry = vestingSchedules[accountToMerge][entryIDs[i]];\n\n            /* ignore vesting entries with zero escrowAmount */\n            if (entry.escrowAmount != 0) {\n                /* copy entry to msg.sender (destination address) */\n                vestingSchedules[msg.sender][entryIDs[i]] = entry;\n\n                /* Add the escrowAmount of entry to the totalEscrowAmountMerged */\n                totalEscrowAmountMerged = totalEscrowAmountMerged.add(entry.escrowAmount);\n\n                /* append entryID to list of entries for account */\n                accountVestingEntryIDs[msg.sender].push(entryIDs[i]);\n\n                /* Delete entry from accountToMerge */\n                delete vestingSchedules[accountToMerge][entryIDs[i]];\n            }\n        }\n\n        /* update totalEscrowedAccountBalance for merged account and accountToMerge */\n        totalEscrowedAccountBalance[accountToMerge] = totalEscrowedAccountBalance[accountToMerge].sub(\n            totalEscrowAmountMerged\n        );\n        totalEscrowedAccountBalance[msg.sender] = totalEscrowedAccountBalance[msg.sender].add(totalEscrowAmountMerged);\n\n        emit AccountMerged(accountToMerge, msg.sender, totalEscrowAmountMerged, entryIDs, block.timestamp);\n    }\n\n    /* Internal function for importing vesting entry and creating new entry for escrow liquidations */\n    function _addVestingEntry(address account, VestingEntries.VestingEntry memory entry) internal returns (uint) {\n        uint entryID = nextEntryId;\n        vestingSchedules[account][entryID] = entry;\n\n        /* append entryID to list of entries for account */\n        accountVestingEntryIDs[account].push(entryID);\n\n        /* Increment the next entry id. */\n        nextEntryId = nextEntryId.add(1);\n\n        return entryID;\n    }\n\n    /* ========== MIGRATION OLD ESCROW ========== */\n\n    function migrateVestingSchedule(address) external {\n        _notImplemented();\n    }\n\n    function migrateAccountEscrowBalances(\n        address[] calldata,\n        uint256[] calldata,\n        uint256[] calldata\n    ) external {\n        _notImplemented();\n    }\n\n    /* ========== L2 MIGRATION ========== */\n\n    function burnForMigration(address, uint[] calldata) external returns (uint256, VestingEntries.VestingEntry[] memory) {\n        _notImplemented();\n    }\n\n    function importVestingEntries(\n        address,\n        uint256,\n        VestingEntries.VestingEntry[] calldata\n    ) external {\n        _notImplemented();\n    }\n\n    /* ========== INTERNALS ========== */\n\n    function _appendVestingEntry(\n        address account,\n        uint256 quantity,\n        uint256 duration\n    ) internal {\n        /* No empty or already-passed vesting entries allowed. */\n        require(quantity != 0, \"Quantity cannot be zero\");\n        require(duration > 0 && duration <= max_duration, \"Cannot escrow with 0 duration OR above max_duration\");\n\n        /* There must be enough balance in the contract to provide for the vesting entry. */\n        totalEscrowedBalance = totalEscrowedBalance.add(quantity);\n\n        require(\n            totalEscrowedBalance <= IERC20(address(periFinance())).balanceOf(address(this)),\n            \"Must be enough balance in the contract to provide for the vesting entry\"\n        );\n\n        /* Escrow the tokens for duration. */\n        uint endTime = block.timestamp + duration;\n\n        /* Add quantity to account's escrowed balance */\n        totalEscrowedAccountBalance[account] = totalEscrowedAccountBalance[account].add(quantity);\n\n        uint entryID = nextEntryId;\n        vestingSchedules[account][entryID] = VestingEntries.VestingEntry({endTime: uint64(endTime), escrowAmount: quantity});\n\n        accountVestingEntryIDs[account].push(entryID);\n\n        /* Increment the next entry id. */\n        nextEntryId = nextEntryId.add(1);\n\n        emit VestingEntryCreated(account, block.timestamp, quantity, duration, entryID);\n    }\n\n    /* ========== MODIFIERS ========== */\n    modifier onlyFeePool() {\n        require(msg.sender == address(feePool()), \"Only the FeePool can perform this action\");\n        _;\n    }\n\n    /* ========== EVENTS ========== */\n    event Vested(address indexed beneficiary, uint time, uint value);\n    event VestingEntryCreated(address indexed beneficiary, uint time, uint value, uint duration, uint entryID);\n    event MaxEscrowDurationUpdated(uint newDuration);\n    event MaxAccountMergingDurationUpdated(uint newDuration);\n    event AccountMergingDurationUpdated(uint newDuration);\n    event AccountMergingStarted(uint time, uint endTime);\n    event AccountMerged(\n        address indexed accountToMerge,\n        address destinationAddress,\n        uint escrowAmountMerged,\n        uint[] entryIDs,\n        uint time\n    );\n    event NominateAccountToMerge(address indexed account, address destination);\n}\n\n\n// https://docs.peri.finance/contracts/source/interfaces/irewardescrow\ninterface IRewardEscrow {\n    // Views\n    function balanceOf(address account) external view returns (uint);\n\n    function numVestingEntries(address account) external view returns (uint);\n\n    function totalEscrowedAccountBalance(address account) external view returns (uint);\n\n    function totalVestedAccountBalance(address account) external view returns (uint);\n\n    function getVestingScheduleEntry(address account, uint index) external view returns (uint[2] memory);\n\n    function getNextVestingIndex(address account) external view returns (uint);\n\n    // Mutative functions\n    function appendVestingEntry(address account, uint quantity) external;\n\n    function vest() external;\n}\n\n\n// https://docs.peri.finance/contracts/source/interfaces/isystemstatus\ninterface ISystemStatus {\n    struct Status {\n        bool canSuspend;\n        bool canResume;\n    }\n\n    struct Suspension {\n        bool suspended;\n        // reason is an integer code,\n        // 0 => no reason, 1 => upgrading, 2+ => defined by system usage\n        uint248 reason;\n    }\n\n    // Views\n    function accessControl(bytes32 section, address account) external view returns (bool canSuspend, bool canResume);\n\n    function requireSystemActive() external view;\n\n    function requireIssuanceActive() external view;\n\n    function requireExchangeActive() external view;\n\n    function requireExchangeBetweenPynthsAllowed(bytes32 sourceCurrencyKey, bytes32 destinationCurrencyKey) external view;\n\n    function requirePynthActive(bytes32 currencyKey) external view;\n\n    function requirePynthsActive(bytes32 sourceCurrencyKey, bytes32 destinationCurrencyKey) external view;\n\n    function systemSuspension() external view returns (bool suspended, uint248 reason);\n\n    function issuanceSuspension() external view returns (bool suspended, uint248 reason);\n\n    function exchangeSuspension() external view returns (bool suspended, uint248 reason);\n\n    function pynthExchangeSuspension(bytes32 currencyKey) external view returns (bool suspended, uint248 reason);\n\n    function pynthSuspension(bytes32 currencyKey) external view returns (bool suspended, uint248 reason);\n\n    function getPynthExchangeSuspensions(bytes32[] calldata pynths)\n        external\n        view\n        returns (bool[] memory exchangeSuspensions, uint256[] memory reasons);\n\n    function getPynthSuspensions(bytes32[] calldata pynths)\n        external\n        view\n        returns (bool[] memory suspensions, uint256[] memory reasons);\n\n    // Restricted functions\n    function suspendPynth(bytes32 currencyKey, uint256 reason) external;\n\n    function updateAccessControl(\n        bytes32 section,\n        address account,\n        bool canSuspend,\n        bool canResume\n    ) external;\n}\n\n\n// Inheritance\n\n\n// Internal references\n\n\n// https://docs.peri.finance/contracts/RewardEscrow\ncontract RewardEscrowV2 is BaseRewardEscrowV2 {\n    mapping(address => uint256) public totalBalancePendingMigration;\n\n    uint public migrateEntriesThresholdAmount = SafeDecimalMath.unit() * 1000; // Default 1000 PERI\n\n    /* ========== ADDRESS RESOLVER CONFIGURATION ========== */\n\n    bytes32 private constant CONTRACT_PERIFINANCE_BRIDGE_OPTIMISM = \"PeriFinanceBridgeToOptimism\";\n    bytes32 private constant CONTRACT_REWARD_ESCROW = \"RewardEscrow\";\n    bytes32 private constant CONTRACT_SYSTEMSTATUS = \"SystemStatus\";\n\n    /* ========== CONSTRUCTOR ========== */\n\n    constructor(address _owner, address _resolver) public BaseRewardEscrowV2(_owner, _resolver) {}\n\n    /* ========== VIEWS ======================= */\n\n    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {\n        bytes32[] memory existingAddresses = BaseRewardEscrowV2.resolverAddressesRequired();\n        bytes32[] memory newAddresses = new bytes32[](3);\n        newAddresses[0] = CONTRACT_PERIFINANCE_BRIDGE_OPTIMISM;\n        newAddresses[1] = CONTRACT_REWARD_ESCROW;\n        newAddresses[2] = CONTRACT_SYSTEMSTATUS;\n        return combineArrays(existingAddresses, newAddresses);\n    }\n\n    function periFinanceBridgeToOptimism() internal view returns (address) {\n        return requireAndGetAddress(CONTRACT_PERIFINANCE_BRIDGE_OPTIMISM);\n    }\n\n    function oldRewardEscrow() internal view returns (IRewardEscrow) {\n        return IRewardEscrow(requireAndGetAddress(CONTRACT_REWARD_ESCROW));\n    }\n\n    function systemStatus() internal view returns (ISystemStatus) {\n        return ISystemStatus(requireAndGetAddress(CONTRACT_SYSTEMSTATUS));\n    }\n\n    /* ========== OLD ESCROW LOOKUP ========== */\n\n    uint internal constant TIME_INDEX = 0;\n    uint internal constant QUANTITY_INDEX = 1;\n\n    /* ========== MIGRATION OLD ESCROW ========== */\n\n    /* Threshold amount for migrating escrow entries from old RewardEscrow */\n    function setMigrateEntriesThresholdAmount(uint amount) external onlyOwner {\n        migrateEntriesThresholdAmount = amount;\n        emit MigrateEntriesThresholdAmountUpdated(amount);\n    }\n\n    /* Function to allow any address to migrate vesting entries from previous reward escrow */\n    function migrateVestingSchedule(address addressToMigrate) external systemActive {\n        /* Ensure account escrow balance pending migration is not zero */\n        /* Ensure account escrowed balance is not zero - should have been migrated */\n        require(totalBalancePendingMigration[addressToMigrate] > 0, \"No escrow migration pending\");\n        require(totalEscrowedAccountBalance[addressToMigrate] > 0, \"Address escrow balance is 0\");\n\n        /* Add a vestable entry for addresses with totalBalancePendingMigration <= migrateEntriesThreshold amount of PERI */\n        if (totalBalancePendingMigration[addressToMigrate] <= migrateEntriesThresholdAmount) {\n            _importVestingEntry(\n                addressToMigrate,\n                VestingEntries.VestingEntry({\n                    endTime: uint64(block.timestamp),\n                    escrowAmount: totalBalancePendingMigration[addressToMigrate]\n                })\n            );\n\n            /* Remove totalBalancePendingMigration[addressToMigrate] */\n            delete totalBalancePendingMigration[addressToMigrate];\n        } else {\n            uint numEntries = oldRewardEscrow().numVestingEntries(addressToMigrate);\n\n            /* iterate and migrate old escrow schedules from rewardEscrow.vestingSchedules\n             * starting from the last entry in each staker's vestingSchedules\n             */\n            for (uint i = 1; i <= numEntries; i++) {\n                uint[2] memory vestingSchedule = oldRewardEscrow().getVestingScheduleEntry(addressToMigrate, numEntries - i);\n\n                uint time = vestingSchedule[TIME_INDEX];\n                uint amount = vestingSchedule[QUANTITY_INDEX];\n\n                /* The list is sorted, when we reach the first entry that can be vested stop */\n                if (time < block.timestamp) {\n                    break;\n                }\n\n                /* import vesting entry */\n                _importVestingEntry(\n                    addressToMigrate,\n                    VestingEntries.VestingEntry({endTime: uint64(time), escrowAmount: amount})\n                );\n\n                /* subtract amount from totalBalancePendingMigration - reverts if insufficient */\n                totalBalancePendingMigration[addressToMigrate] = totalBalancePendingMigration[addressToMigrate].sub(amount);\n            }\n        }\n    }\n\n    /**\n     * Import function for owner to import vesting schedule\n     * All entries imported should have past their vesting timestamp and will be ready to be vested\n     * Addresses with totalEscrowedAccountBalance == 0 will not be migrated as they have all vested\n     */\n    function importVestingSchedule(address[] calldata accounts, uint256[] calldata escrowAmounts)\n        external\n        onlyDuringSetup\n        onlyOwner\n    {\n        require(accounts.length == escrowAmounts.length, \"Account and escrowAmounts Length mismatch\");\n\n        for (uint i = 0; i < accounts.length; i++) {\n            address addressToMigrate = accounts[i];\n            uint256 escrowAmount = escrowAmounts[i];\n\n            // ensure account have escrow migration pending\n            require(totalEscrowedAccountBalance[addressToMigrate] > 0, \"Address escrow balance is 0\");\n            require(totalBalancePendingMigration[addressToMigrate] > 0, \"No escrow migration pending\");\n\n            /* Import vesting entry with endTime as block.timestamp and escrowAmount */\n            _importVestingEntry(\n                addressToMigrate,\n                VestingEntries.VestingEntry({endTime: uint64(block.timestamp), escrowAmount: escrowAmount})\n            );\n\n            /* update totalBalancePendingMigration - reverts if escrowAmount > remaining balance to migrate */\n            totalBalancePendingMigration[addressToMigrate] = totalBalancePendingMigration[addressToMigrate].sub(\n                escrowAmount\n            );\n\n            emit ImportedVestingSchedule(addressToMigrate, block.timestamp, escrowAmount);\n        }\n    }\n\n    /**\n     * Migration for owner to migrate escrowed and vested account balances\n     * Addresses with totalEscrowedAccountBalance == 0 will not be migrated as they have all vested\n     */\n    function migrateAccountEscrowBalances(\n        address[] calldata accounts,\n        uint256[] calldata escrowBalances,\n        uint256[] calldata vestedBalances\n    ) external onlyDuringSetup onlyOwner {\n        require(accounts.length == escrowBalances.length, \"Number of accounts and balances don't match\");\n        require(accounts.length == vestedBalances.length, \"Number of accounts and vestedBalances don't match\");\n\n        for (uint i = 0; i < accounts.length; i++) {\n            address account = accounts[i];\n            uint escrowedAmount = escrowBalances[i];\n            uint vestedAmount = vestedBalances[i];\n\n            // ensure account doesn't have escrow migration pending / being imported more than once\n            require(totalBalancePendingMigration[account] == 0, \"Account migration is pending already\");\n\n            /* Update totalEscrowedBalance for tracking the PeriFinance balance of this contract. */\n            totalEscrowedBalance = totalEscrowedBalance.add(escrowedAmount);\n\n            /* Update totalEscrowedAccountBalance and totalVestedAccountBalance for each account */\n            totalEscrowedAccountBalance[account] = totalEscrowedAccountBalance[account].add(escrowedAmount);\n            totalVestedAccountBalance[account] = totalVestedAccountBalance[account].add(vestedAmount);\n\n            /* update totalBalancePendingMigration for account */\n            totalBalancePendingMigration[account] = escrowedAmount;\n\n            emit MigratedAccountEscrow(account, escrowedAmount, vestedAmount, now);\n        }\n    }\n\n    /* Internal function to add entry to vestingSchedules and emit event */\n    function _importVestingEntry(address account, VestingEntries.VestingEntry memory entry) internal {\n        /* add vesting entry to account and assign an entryID to it */\n        uint entryID = BaseRewardEscrowV2._addVestingEntry(account, entry);\n\n        emit ImportedVestingEntry(account, entryID, entry.escrowAmount, entry.endTime);\n    }\n\n    /* ========== L2 MIGRATION ========== */\n\n    function burnForMigration(address account, uint[] calldata entryIDs)\n        external\n        onlyPeriFinanceBridge\n        returns (uint256 escrowedAccountBalance, VestingEntries.VestingEntry[] memory vestingEntries)\n    {\n        require(entryIDs.length > 0, \"Entry IDs required\");\n\n        vestingEntries = new VestingEntries.VestingEntry[](entryIDs.length);\n\n        for (uint i = 0; i < entryIDs.length; i++) {\n            VestingEntries.VestingEntry storage entry = vestingSchedules[account][entryIDs[i]];\n\n            if (entry.escrowAmount > 0) {\n                vestingEntries[i] = entry;\n\n                /* add the escrow amount to escrowedAccountBalance */\n                escrowedAccountBalance = escrowedAccountBalance.add(entry.escrowAmount);\n\n                /* Delete the vesting entry being migrated */\n                delete vestingSchedules[account][entryIDs[i]];\n            }\n        }\n\n        /**\n         *  update account total escrow balances for migration\n         *  transfer the escrowed PERI being migrated to the L2 deposit contract\n         */\n        if (escrowedAccountBalance > 0) {\n            _reduceAccountEscrowBalances(account, escrowedAccountBalance);\n            IERC20(address(periFinance())).transfer(periFinanceBridgeToOptimism(), escrowedAccountBalance);\n        }\n\n        emit BurnedForMigrationToL2(account, entryIDs, escrowedAccountBalance, block.timestamp);\n\n        return (escrowedAccountBalance, vestingEntries);\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    modifier onlyPeriFinanceBridge() {\n        require(msg.sender == periFinanceBridgeToOptimism(), \"Can only be invoked by PeriFinanceBridgeToOptimism contract\");\n        _;\n    }\n\n    modifier systemActive() {\n        systemStatus().requireSystemActive();\n        _;\n    }\n\n    /* ========== EVENTS ========== */\n    event MigratedAccountEscrow(address indexed account, uint escrowedAmount, uint vestedAmount, uint time);\n    event ImportedVestingSchedule(address indexed account, uint time, uint escrowAmount);\n    event BurnedForMigrationToL2(address indexed account, uint[] entryIDs, uint escrowedAmountMigrated, uint time);\n    event ImportedVestingEntry(address indexed account, uint entryID, uint escrowAmount, uint endTime);\n    event MigrateEntriesThresholdAmountUpdated(uint newAmount);\n}\n\n    ", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_resolver\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"accountToMerge\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"destinationAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"escrowAmountMerged\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"entryIDs\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"AccountMerged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newDuration\",\"type\":\"uint256\"}],\"name\":\"AccountMergingDurationUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"}],\"name\":\"AccountMergingStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"entryIDs\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"escrowedAmountMigrated\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"BurnedForMigrationToL2\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"destination\",\"type\":\"address\"}],\"name\":\"CacheUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"entryID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"escrowAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"}],\"name\":\"ImportedVestingEntry\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"escrowAmount\",\"type\":\"uint256\"}],\"name\":\"ImportedVestingSchedule\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newDuration\",\"type\":\"uint256\"}],\"name\":\"MaxAccountMergingDurationUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newDuration\",\"type\":\"uint256\"}],\"name\":\"MaxEscrowDurationUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newAmount\",\"type\":\"uint256\"}],\"name\":\"MigrateEntriesThresholdAmountUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"escrowedAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"vestedAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"MigratedAccountEscrow\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"destination\",\"type\":\"address\"}],\"name\":\"NominateAccountToMerge\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerNominated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Vested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"entryID\",\"type\":\"uint256\"}],\"name\":\"VestingEntryCreated\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"accountMergingDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"accountMergingIsOpen\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"accountMergingStartTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"accountVestingEntryIDs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"}],\"name\":\"appendVestingEntry\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"entryIDs\",\"type\":\"uint256[]\"}],\"name\":\"burnForMigration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"escrowedAccountBalance\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint64\",\"name\":\"endTime\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"escrowAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct VestingEntries.VestingEntry[]\",\"name\":\"vestingEntries\",\"type\":\"tuple[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"}],\"name\":\"createEscrowEntry\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pageSize\",\"type\":\"uint256\"}],\"name\":\"getAccountVestingEntryIDs\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"entryID\",\"type\":\"uint256\"}],\"name\":\"getVestingEntry\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"endTime\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"escrowAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"entryID\",\"type\":\"uint256\"}],\"name\":\"getVestingEntryClaimable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"entryIDs\",\"type\":\"uint256[]\"}],\"name\":\"getVestingQuantity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pageSize\",\"type\":\"uint256\"}],\"name\":\"getVestingSchedules\",\"outputs\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"endTime\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"escrowAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"entryID\",\"type\":\"uint256\"}],\"internalType\":\"struct VestingEntries.VestingEntryWithID[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint64\",\"name\":\"endTime\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"escrowAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct VestingEntries.VestingEntry[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"name\":\"importVestingEntries\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"escrowAmounts\",\"type\":\"uint256[]\"}],\"name\":\"importVestingSchedule\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isResolverCached\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxAccountMergingDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"max_duration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"accountToMerge\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"entryIDs\",\"type\":\"uint256[]\"}],\"name\":\"mergeAccount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"escrowBalances\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"vestedBalances\",\"type\":\"uint256[]\"}],\"name\":\"migrateAccountEscrowBalances\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"migrateEntriesThresholdAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"addressToMigrate\",\"type\":\"address\"}],\"name\":\"migrateVestingSchedule\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nextEntryId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"nominateAccountToMerge\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"nominateNewOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nominatedOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nominatedReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"numVestingEntries\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"rebuildCache\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"resolver\",\"outputs\":[{\"internalType\":\"contract AddressResolver\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"resolverAddressesRequired\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"addresses\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"}],\"name\":\"setAccountMergingDuration\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"}],\"name\":\"setMaxAccountMergingWindow\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"}],\"name\":\"setMaxEscrowDuration\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setMigrateEntriesThresholdAmount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"setupExpiryTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"startMergingWindow\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalBalancePendingMigration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalEscrowedAccountBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalEscrowedBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalVestedAccountBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"entryIDs\",\"type\":\"uint256[]\"}],\"name\":\"vest\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"vestingSchedules\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"endTime\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"escrowAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "RewardEscrowV2", "CompilerVersion": "v0.5.16+commit.9c3226ce", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000918153d6e806df9d4d33664d1cc580416171f7200000000000000000000000007015cd1e78ba1428d103b0c2513077b2826b64fc", "EVMVersion": "Default", "Library": "SafeDecimalMath:6e0bff12512a94f3b1ecebe08203fe7f8f8fae64", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}