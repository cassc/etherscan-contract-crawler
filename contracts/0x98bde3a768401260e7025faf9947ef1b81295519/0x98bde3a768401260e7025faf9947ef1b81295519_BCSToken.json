{"SourceCode": "/*************************************************************************\r\n * This contract has been merged with solidify\r\n * https://github.com/tiesnetwork/solidify\r\n *************************************************************************/\r\n \r\n pragma solidity ^0.4.10;\r\n\r\n/*************************************************************************\r\n * import \"../common/Manageable.sol\" : start\r\n *************************************************************************/\r\n\r\n/*************************************************************************\r\n * import \"../common/Owned.sol\" : start\r\n *************************************************************************/\r\n\r\n\r\ncontract Owned {\r\n    address public owner;        \r\n\r\n    function Owned() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    // allows execution by the owner only\r\n    modifier ownerOnly {\r\n        assert(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**@dev allows transferring the contract ownership. */\r\n    function transferOwnership(address _newOwner) public ownerOnly {\r\n        require(_newOwner != owner);\r\n        owner = _newOwner;\r\n    }\r\n}\r\n/*************************************************************************\r\n * import \"../common/Owned.sol\" : end\r\n *************************************************************************/\r\n\r\n///A token that have an owner and a list of managers that can perform some operations\r\n///Owner is always a manager too\r\ncontract Manageable is Owned {\r\n\r\n    event ManagerSet(address manager, bool state);\r\n\r\n    mapping (address => bool) public managers;\r\n\r\n    function Manageable() Owned() {\r\n        managers[owner] = true;\r\n    }\r\n\r\n    /**@dev Allows execution by managers only */\r\n    modifier managerOnly {\r\n        assert(managers[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address _newOwner) public ownerOnly {\r\n        super.transferOwnership(_newOwner);\r\n\r\n        managers[_newOwner] = true;\r\n        managers[msg.sender] = false;\r\n    }\r\n\r\n    function setManager(address manager, bool state) ownerOnly {\r\n        managers[manager] = state;\r\n        ManagerSet(manager, state);\r\n    }\r\n}/*************************************************************************\r\n * import \"../common/Manageable.sol\" : end\r\n *************************************************************************/\r\n/*************************************************************************\r\n * import \"./ValueToken.sol\" : start\r\n *************************************************************************/\r\n\r\n/*************************************************************************\r\n * import \"./ERC20StandardToken.sol\" : start\r\n *************************************************************************/\r\n\r\n/*************************************************************************\r\n * import \"./IERC20Token.sol\" : start\r\n *************************************************************************/\r\n\r\n/**@dev ERC20 compliant token interface. \r\nhttps://theethereum.wiki/w/index.php/ERC20_Token_Standard \r\nhttps://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md */\r\ncontract IERC20Token {\r\n\r\n    // these functions aren't abstract since the compiler emits automatically generated getter functions as external    \r\n    function name() public constant returns (string _name) { _name; }\r\n    function symbol() public constant returns (string _symbol) { _symbol; }\r\n    function decimals() public constant returns (uint8 _decimals) { _decimals; }\r\n    \r\n    function totalSupply() constant returns (uint total) {total;}\r\n    function balanceOf(address _owner) constant returns (uint balance) {_owner; balance;}    \r\n    function allowance(address _owner, address _spender) constant returns (uint remaining) {_owner; _spender; remaining;}\r\n\r\n    function transfer(address _to, uint _value) returns (bool success);\r\n    function transferFrom(address _from, address _to, uint _value) returns (bool success);\r\n    function approve(address _spender, uint _value) returns (bool success);\r\n    \r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n}\r\n/*************************************************************************\r\n * import \"./IERC20Token.sol\" : end\r\n *************************************************************************/\r\n/*************************************************************************\r\n * import \"../common/SafeMath.sol\" : start\r\n *************************************************************************/\r\n\r\n/**dev Utility methods for overflow-proof arithmetic operations \r\n*/\r\ncontract SafeMath {\r\n\r\n    /**dev Returns the sum of a and b. Throws an exception if it exceeds uint256 limits*/\r\n    function safeAdd(uint256 a, uint256 b) internal returns (uint256) {        \r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**dev Returns the difference of a and b. Throws an exception if a is less than b*/\r\n    function safeSub(uint256 a, uint256 b) internal returns (uint256) {\r\n        assert(a >= b);\r\n        return a - b;\r\n    }\r\n\r\n    /**dev Returns the product of a and b. Throws an exception if it exceeds uint256 limits*/\r\n    function safeMult(uint256 x, uint256 y) internal returns(uint256) {\r\n        uint256 z = x * y;\r\n        assert((x == 0) || (z / x == y));\r\n        return z;\r\n    }\r\n\r\n    function safeDiv(uint256 x, uint256 y) internal returns (uint256) {\r\n        assert(y != 0);\r\n        return x / y;\r\n    }\r\n}/*************************************************************************\r\n * import \"../common/SafeMath.sol\" : end\r\n *************************************************************************/\r\n\r\n/**@dev Standard ERC20 compliant token implementation */\r\ncontract ERC20StandardToken is IERC20Token, SafeMath {\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals;\r\n\r\n    //tokens already issued\r\n    uint256 tokensIssued;\r\n    //balances for each account\r\n    mapping (address => uint256) balances;\r\n    //one account approves the transfer of an amount to another account\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n\r\n    function ERC20StandardToken() {\r\n     \r\n    }    \r\n\r\n    //\r\n    //IERC20Token implementation\r\n    // \r\n\r\n    function totalSupply() constant returns (uint total) {\r\n        total = tokensIssued;\r\n    }\r\n \r\n    function balanceOf(address _owner) constant returns (uint balance) {\r\n        balance = balances[_owner];\r\n    }\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool) {\r\n        require(_to != address(0));\r\n\r\n        // safeSub inside doTransfer will throw if there is not enough balance.\r\n        doTransfer(msg.sender, _to, _value);        \r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool) {\r\n        require(_to != address(0));\r\n        \r\n        // Check for allowance is not needed because sub(_allowance, _value) will throw if this condition is not met\r\n        allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _value);        \r\n        // safeSub inside doTransfer will throw if there is not enough balance.\r\n        doTransfer(_from, _to, _value);        \r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n        remaining = allowed[_owner][_spender];\r\n    }    \r\n\r\n    //\r\n    // Additional functions\r\n    //\r\n    /**@dev Gets real token amount in the smallest token units */\r\n    function getRealTokenAmount(uint256 tokens) constant returns (uint256) {\r\n        return tokens * (uint256(10) ** decimals);\r\n    }\r\n\r\n    //\r\n    // Internal functions\r\n    //    \r\n    \r\n    function doTransfer(address _from, address _to, uint256 _value) internal {\r\n        balances[_from] = safeSub(balances[_from], _value);\r\n        balances[_to] = safeAdd(balances[_to], _value);\r\n    }\r\n}/*************************************************************************\r\n * import \"./ERC20StandardToken.sol\" : end\r\n *************************************************************************/\r\n/*************************************************************************\r\n * import \"../token/ValueTokenAgent.sol\" : start\r\n *************************************************************************/\r\n\r\n\r\n\r\n\r\n/**@dev Watches transfer operation of tokens to validate value-distribution state */\r\ncontract ValueTokenAgent {\r\n\r\n    /**@dev Token whose transfers that contract watches */\r\n    ValueToken public valueToken;\r\n\r\n    /**@dev Allows only token to execute method */\r\n    modifier valueTokenOnly {require(msg.sender == address(valueToken)); _;}\r\n\r\n    function ValueTokenAgent(ValueToken token) {\r\n        valueToken = token;\r\n    }\r\n\r\n    /**@dev Called just before the token balance update*/   \r\n    function tokenIsBeingTransferred(address from, address to, uint256 amount);\r\n\r\n    /**@dev Called when non-transfer token state change occurs: burn, issue, change of valuable tokens.\r\n    holder - address of token holder that committed the change\r\n    amount - amount of new or deleted tokens  */\r\n    function tokenChanged(address holder, uint256 amount);\r\n}/*************************************************************************\r\n * import \"../token/ValueTokenAgent.sol\" : end\r\n *************************************************************************/\r\n\r\n\r\n/**@dev Can be relied on to distribute values according to its balances \r\n Can set some reserve addreses whose tokens don't take part in dividend distribution */\r\ncontract ValueToken is Manageable, ERC20StandardToken {\r\n    \r\n    /**@dev Watches transfer operation of this token */\r\n    ValueTokenAgent valueAgent;\r\n\r\n    /**@dev Holders of reserved tokens */\r\n    mapping (address => bool) public reserved;\r\n\r\n    /**@dev Reserved token amount */\r\n    uint256 public reservedAmount;\r\n\r\n    function ValueToken() {}\r\n\r\n    /**@dev Sets new value agent */\r\n    function setValueAgent(ValueTokenAgent newAgent) managerOnly {\r\n        valueAgent = newAgent;\r\n    }\r\n\r\n    function doTransfer(address _from, address _to, uint256 _value) internal {\r\n\r\n        if (address(valueAgent) != 0x0) {\r\n            //first execute agent method\r\n            valueAgent.tokenIsBeingTransferred(_from, _to, _value);\r\n        }\r\n\r\n        //first check if addresses are reserved and adjust reserved amount accordingly\r\n        if (reserved[_from]) {\r\n            reservedAmount = safeSub(reservedAmount, _value);\r\n            //reservedAmount -= _value;\r\n        } \r\n        if (reserved[_to]) {\r\n            reservedAmount = safeAdd(reservedAmount, _value);\r\n            //reservedAmount += _value;\r\n        }\r\n\r\n        //then do actual transfer\r\n        super.doTransfer(_from, _to, _value);\r\n    }\r\n\r\n    /**@dev Returns a token amount that is accounted in the process of dividend calculation */\r\n    function getValuableTokenAmount() constant returns (uint256) {\r\n        return totalSupply() - reservedAmount;\r\n    }\r\n\r\n    /**@dev Sets specific address to be reserved */\r\n    function setReserved(address holder, bool state) managerOnly {        \r\n\r\n        uint256 holderBalance = balanceOf(holder);\r\n        if (address(valueAgent) != 0x0) {            \r\n            valueAgent.tokenChanged(holder, holderBalance);\r\n        }\r\n\r\n        //change reserved token amount according to holder's state\r\n        if (state) {\r\n            //reservedAmount += holderBalance;\r\n            reservedAmount = safeAdd(reservedAmount, holderBalance);\r\n        } else {\r\n            //reservedAmount -= holderBalance;\r\n            reservedAmount = safeSub(reservedAmount, holderBalance);\r\n        }\r\n\r\n        reserved[holder] = state;\r\n    }\r\n}/*************************************************************************\r\n * import \"./ValueToken.sol\" : end\r\n *************************************************************************/\r\n/*************************************************************************\r\n * import \"./ReturnableToken.sol\" : start\r\n *************************************************************************/\r\n\r\n\r\n\r\n/*************************************************************************\r\n * import \"./ReturnTokenAgent.sol\" : start\r\n *************************************************************************/\r\n\r\n\r\n\r\n\r\n///Returnable tokens receiver\r\ncontract ReturnTokenAgent is Manageable {\r\n    //ReturnableToken public returnableToken;\r\n\r\n    /**@dev List of returnable tokens in format token->flag  */\r\n    mapping (address => bool) public returnableTokens;\r\n\r\n    /**@dev Allows only token to execute method */\r\n    //modifier returnableTokenOnly {require(msg.sender == address(returnableToken)); _;}\r\n    modifier returnableTokenOnly {require(returnableTokens[msg.sender]); _;}\r\n\r\n    /**@dev Executes when tokens are transferred to this */\r\n    function returnToken(address from, uint256 amountReturned);\r\n\r\n    /**@dev Sets token that can call returnToken method */\r\n    function setReturnableToken(ReturnableToken token) managerOnly {\r\n        returnableTokens[address(token)] = true;\r\n    }\r\n\r\n    /**@dev Removes token that can call returnToken method */\r\n    function removeReturnableToken(ReturnableToken token) managerOnly {\r\n        returnableTokens[address(token)] = false;\r\n    }\r\n}/*************************************************************************\r\n * import \"./ReturnTokenAgent.sol\" : end\r\n *************************************************************************/\r\n\r\n///Token that when sent to specified contract (returnAgent) invokes additional actions\r\ncontract ReturnableToken is Manageable, ERC20StandardToken {\r\n\r\n    /**@dev List of return agents */\r\n    mapping (address => bool) public returnAgents;\r\n\r\n    function ReturnableToken() {}    \r\n    \r\n    /**@dev Sets new return agent */\r\n    function setReturnAgent(ReturnTokenAgent agent) managerOnly {\r\n        returnAgents[address(agent)] = true;\r\n    }\r\n\r\n    /**@dev Removes return agent from list */\r\n    function removeReturnAgent(ReturnTokenAgent agent) managerOnly {\r\n        returnAgents[address(agent)] = false;\r\n    }\r\n\r\n    function doTransfer(address _from, address _to, uint256 _value) internal {\r\n        super.doTransfer(_from, _to, _value);\r\n        if (returnAgents[_to]) {\r\n            ReturnTokenAgent(_to).returnToken(_from, _value);                \r\n        }\r\n    }\r\n}/*************************************************************************\r\n * import \"./ReturnableToken.sol\" : end\r\n *************************************************************************/\r\n/*************************************************************************\r\n * import \"./IBurnableToken.sol\" : start\r\n *************************************************************************/\r\n\r\n/**@dev A token that can be burnt */\r\ncontract IBurnableToken {\r\n    function burn(uint256 _value);\r\n}/*************************************************************************\r\n * import \"./IBurnableToken.sol\" : end\r\n *************************************************************************/\r\n\r\n/**@dev bcshop.io crowdsale token */\r\ncontract BCSToken is ValueToken, ReturnableToken, IBurnableToken {\r\n\r\n    /**@dev Specifies allowed address that always can transfer tokens in case of global transfer lock */\r\n    mapping (address => bool) public transferAllowed;\r\n    /**@dev Specifies timestamp when specific token holder can transfer funds */    \r\n    mapping (address => uint256) public transferLockUntil; \r\n    /**@dev True if transfer is locked for all holders, false otherwise */\r\n    bool public transferLocked;\r\n\r\n    event Burn(address sender, uint256 value);\r\n\r\n    /**@dev Creates a token with given initial supply  */\r\n    function BCSToken(uint256 _initialSupply, uint8 _decimals) {\r\n        name = \"BCShop.io Token\";\r\n        symbol = \"BCS\";\r\n        decimals = _decimals;        \r\n\r\n        tokensIssued = _initialSupply * (uint256(10) ** decimals);\r\n        //store all tokens at the owner's address;\r\n        balances[msg.sender] = tokensIssued;\r\n\r\n        transferLocked = true;\r\n        transferAllowed[msg.sender] = true;        \r\n    }\r\n\r\n    /**@dev ERC20StandatdToken override */\r\n    function doTransfer(address _from, address _to, uint256 _value) internal {\r\n        require(canTransfer(_from));\r\n        super.doTransfer(_from, _to, _value);\r\n    }    \r\n\r\n    /**@dev Returns true if given address can transfer tokens */\r\n    function canTransfer(address holder) constant returns (bool) {\r\n        if(transferLocked) {\r\n            return transferAllowed[holder];\r\n        } else {\r\n            return now > transferLockUntil[holder];\r\n        }\r\n        //return !transferLocked && now > transferLockUntil[holder];\r\n    }    \r\n\r\n    /**@dev Lock transfer for a given holder for a given amount of days */\r\n    function lockTransferFor(address holder, uint256 daysFromNow) managerOnly {\r\n        transferLockUntil[holder] = daysFromNow * 1 days + now;\r\n    }\r\n\r\n    /**@dev Sets transfer allowance for specific holder */\r\n    function allowTransferFor(address holder, bool state) managerOnly {\r\n        transferAllowed[holder] = state;\r\n    }\r\n\r\n    /**@dev Locks or allows transfer for all holders, for emergency reasons*/\r\n    function setLockedState(bool state) managerOnly {\r\n        transferLocked = state;\r\n    }\r\n    \r\n    function burn(uint256 _value) managerOnly {        \r\n        require (balances[msg.sender] >= _value);            // Check if the sender has enough\r\n\r\n        if (address(valueAgent) != 0x0) {            \r\n            valueAgent.tokenChanged(msg.sender, _value);\r\n        }\r\n\r\n        balances[msg.sender] -= _value;                      // Subtract from the sender\r\n        tokensIssued -= _value;                              // Updates totalSupply        \r\n\r\n        Burn(msg.sender, _value);        \r\n    }\r\n}", "ABI": "[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"transferLocked\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"transferAllowed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"total\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newAgent\",\"type\":\"address\"}],\"name\":\"setValueAgent\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"agent\",\"type\":\"address\"}],\"name\":\"setReturnAgent\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"holder\",\"type\":\"address\"},{\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"allowTransferFor\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"transferLockUntil\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getValuableTokenAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"holder\",\"type\":\"address\"}],\"name\":\"canTransfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"setLockedState\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"agent\",\"type\":\"address\"}],\"name\":\"removeReturnAgent\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"returnAgents\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"manager\",\"type\":\"address\"},{\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"setManager\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"getRealTokenAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"holder\",\"type\":\"address\"},{\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"setReserved\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"reserved\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"holder\",\"type\":\"address\"},{\"name\":\"daysFromNow\",\"type\":\"uint256\"}],\"name\":\"lockTransferFor\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"reservedAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"managers\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"_initialSupply\",\"type\":\"uint256\"},{\"name\":\"_decimals\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"manager\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"ManagerSet\",\"type\":\"event\"}]", "ContractName": "BCSToken", "CompilerVersion": "v0.4.15+commit.bbb8e64f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000000000000000000000000000000000000009896800000000000000000000000000000000000000000000000000000000000000012", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://474149328d7edafd2632a1df93a432971d50262829325ad61f7e45b82a3cd3d1"}