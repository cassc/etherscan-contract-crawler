{"SourceCode": "{\"IdentityComplete.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity 0.7.4;\\n\\nimport \\\"./SafeMathLib.sol\\\";\\n\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\\n\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\\n     */\\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\\n}\\n\\n// ERC 721\\ncontract Identity {\\n    using SafeMathLib for uint;\\n\\n    mapping (uint =\\u003e address) public owners;\\n    mapping (address =\\u003e uint) public balances;\\n\\n    // Mapping from owner to operator approvals\\n    mapping (address =\\u003e mapping (address =\\u003e bool)) public operatorApprovals;\\n    mapping (uint =\\u003e address) public tokenApprovals;\\n\\n    // Equals to `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`\\n    // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\\n    bytes4 private constant ERC721_RECEIVED = 0x150b7a02;\\n\\n    /*\\n     *     bytes4(keccak256(\\u0027balanceOf(address)\\u0027)) == 0x70a08231\\n     *     bytes4(keccak256(\\u0027ownerOf(uint256)\\u0027)) == 0x6352211e\\n     *     bytes4(keccak256(\\u0027approve(address,uint256)\\u0027)) == 0x095ea7b3\\n     *     bytes4(keccak256(\\u0027getApproved(uint256)\\u0027)) == 0x081812fc\\n     *     bytes4(keccak256(\\u0027setApprovalForAll(address,bool)\\u0027)) == 0xa22cb465\\n     *     bytes4(keccak256(\\u0027isApprovedForAll(address,address)\\u0027)) == 0xe985e9c5\\n     *     bytes4(keccak256(\\u0027transferFrom(address,address,uint256)\\u0027)) == 0x23b872dd\\n     *     bytes4(keccak256(\\u0027safeTransferFrom(address,address,uint256)\\u0027)) == 0x42842e0e\\n     *     bytes4(keccak256(\\u0027safeTransferFrom(address,address,uint256,bytes)\\u0027)) == 0xb88d4fde\\n     *\\n     *     =\\u003e 0x70a08231 ^ 0x6352211e ^ 0x095ea7b3 ^ 0x081812fc ^\\n     *        0xa22cb465 ^ 0xe985e9c5 ^ 0x23b872dd ^ 0x42842e0e ^ 0xb88d4fde == 0x80ac58cd\\n     */\\n    bytes4 private constant INTERFACE_ID_ERC721 = 0x80ac58cd;\\n\\n    /*\\n     * bytes4(keccak256(\\u0027supportsInterface(bytes4)\\u0027)) == 0x01ffc9a7\\n     */\\n    bytes4 private constant INTERFACE_ID_ERC165 = 0x01ffc9a7;\\n\\n    uint public identityIncreaseFactor = 2;\\n    uint public identityIncreaseDenominator = 1;\\n    uint public lastIdentityPrice = 100 * 1 ether; // burn cost of making an identity, in IERC20\\n    uint public identityDecayFactor = 1 ether / 100;\\n    uint public identityPriceFloor = 100 * 1 ether;\\n    uint public numIdentities = 0;\\n    uint public lastPurchaseBlock;\\n\\n    address public management;\\n\\n    IERC20 public token;\\n\\n    event ManagementUpdated(address oldManagement, address newManagement);\\n    event TokenSet(address token);\\n    event IdentityIncreaseFactorUpdated(uint oldIdIncreaseFactor, uint newIdIncreaseFactor);\\n    event IdentityIncreaseDenominatorUpdated(uint oldIdIncreaseDenominator, uint newIdIncreaseDenominator);\\n    event IdentityDecayFactorUpdated(uint oldIdDecayFactor, uint newIdDecayFactor);\\n    event IdentityPriceFloorUpdated(uint oldIdPriceFloor, uint newIdPriceFloor);\\n    event IdentityCreated(address indexed owner, uint indexed token);\\n\\n\\n    /// @dev This emits when ownership of any NFT changes by any mechanism.\\n    ///  This event emits when NFTs are created (`from` == 0) and destroyed\\n    ///  (`to` == 0). Exception: during contract creation, any number of NFTs\\n    ///  may be created and assigned without emitting Transfer. At the time of\\n    ///  any transfer, the approved address for that NFT (if any) is reset to none.\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /// @dev This emits when the approved address for an NFT is changed or\\n    ///  reaffirmed. The zero address indicates there is no approved address.\\n    ///  When a Transfer event emits, this also indicates that the approved\\n    ///  address for that NFT (if any) is reset to none.\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /// @dev This emits when an operator is enabled or disabled for an owner.\\n    ///  The operator can manage all NFTs of the owner.\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    modifier managementOnly() {\\n        require (msg.sender == management, \\u0027Identity: Only management may call this\\u0027);\\n        _;\\n    }\\n\\n    constructor(address mgmt) {\\n        management = mgmt;\\n        lastPurchaseBlock = block.number;\\n    }\\n\\n    function setToken(address tokenAddr) public managementOnly {\\n        token = IERC20(tokenAddr);\\n        emit TokenSet(tokenAddr);\\n    }\\n\\n    // this function creates an identity by burning the IERC20. Anyone can call it.\\n    function createMyIdentity(uint maxPrice) public {\\n        uint identityPrice = getIdentityPrice();\\n        require(maxPrice \\u003e= identityPrice || maxPrice == 0, \\\"Identity: current price exceeds user maximum\\\");\\n        token.transferFrom(msg.sender, address(0), identityPrice);\\n        createIdentity(msg.sender);\\n        lastIdentityPrice = identityPrice.times(identityIncreaseFactor) / identityIncreaseDenominator;\\n        lastPurchaseBlock = block.number;\\n    }\\n\\n    // this function creates an identity for free. Only management can call it.\\n    function createIdentityFor(address newId) public managementOnly {\\n        createIdentity(newId);\\n    }\\n\\n    function createIdentity(address owner) internal {\\n        numIdentities = numIdentities.plus(1);\\n        owners[numIdentities] = owner;\\n        balances[owner] = balances[owner].plus(1);\\n        emit Transfer(address(0), owner, numIdentities);\\n        emit IdentityCreated(owner, numIdentities);\\n    }\\n\\n    function getIdentityPrice() public view returns (uint) {\\n        uint decay = identityDecayFactor.times(block.number.minus(lastPurchaseBlock));\\n        if (lastIdentityPrice \\u003c decay.plus(identityPriceFloor)) {\\n            return identityPriceFloor;\\n        } else {\\n            return lastIdentityPrice.minus(decay);\\n        }\\n    }\\n\\n    /// ================= SETTERS =======================================\\n\\n    // change the management key\\n    function setManagement(address newMgmt) public managementOnly {\\n        address oldMgmt =  management;\\n        management = newMgmt;\\n        emit ManagementUpdated(oldMgmt, newMgmt);\\n    }\\n\\n    function setIdentityIncreaseFactor(uint newIncreaseFactor) public managementOnly {\\n        uint oldIncreaseFactor = identityIncreaseFactor;\\n        identityIncreaseFactor = newIncreaseFactor;\\n        emit IdentityIncreaseFactorUpdated(oldIncreaseFactor, newIncreaseFactor);\\n    }\\n\\n    function setIdentityIncreaseDenominator(uint newIncreaseDenominator) public managementOnly {\\n        uint oldIncreaseDenominator = identityIncreaseDenominator;\\n        identityIncreaseDenominator = newIncreaseDenominator;\\n        emit IdentityIncreaseDenominatorUpdated(oldIncreaseDenominator, newIncreaseDenominator);\\n    }\\n\\n    function setIdentityDecayFactor(uint newDecayFactor) public managementOnly {\\n        uint oldDecayFactor = identityDecayFactor;\\n        identityDecayFactor = newDecayFactor;\\n        emit IdentityDecayFactorUpdated(oldDecayFactor, newDecayFactor);\\n    }\\n\\n    function setIdentityPriceFloor(uint newPriceFloor) public managementOnly {\\n        uint oldFloor = identityPriceFloor;\\n        identityPriceFloor = newPriceFloor;\\n        emit IdentityPriceFloorUpdated(oldFloor, newPriceFloor);\\n    }\\n\\n    /// ================= ERC 721 FUNCTIONS =============================================\\n\\n    /// @notice Count all NFTs assigned to an owner\\n    /// @dev NFTs assigned to the zero address are considered invalid, and this\\n    ///  function throws for queries about the zero address.\\n    /// @param owner An address for whom to query the balance\\n    /// @return The number of NFTs owned by `owner`, possibly zero\\n    function balanceOf(address owner) external view returns (uint256) {\\n        return balances[owner];\\n    }\\n\\n    /// @notice Find the owner of an NFT\\n    /// @dev NFTs assigned to zero address are considered invalid, and queries\\n    ///  about them do throw.\\n    /// @param tokenId The identifier for an NFT\\n    /// @return The address of the owner of the NFT\\n    function ownerOf(uint256 tokenId) external view returns (address)  {\\n        address owner = owners[tokenId];\\n        require(owner != address(0), \\u0027No such token\\u0027);\\n        return owner;\\n    }\\n\\n    /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\\n    ///  TO CONFIRM THAT `to` IS CAPABLE OF RECEIVING NFTS OR ELSE\\n    ///  THEY MAY BE PERMANENTLY LOST\\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\\n    ///  operator, or the approved address for this NFT. Throws if `from` is\\n    ///  not the current owner. Throws if `to` is the zero address. Throws if\\n    ///  `tokenId` is not a valid NFT.\\n    /// @param from The current owner of the NFT\\n    /// @param to The new owner\\n    /// @param tokenId The NFT to transfer\\n    function transferFrom(address from, address to, uint256 tokenId) public {\\n        require(isApproved(msg.sender, tokenId), \\u0027Identity: Unapproved transfer\\u0027);\\n        transfer(from, to, tokenId);\\n    }\\n\\n    /// @notice Transfers the ownership of an NFT from one address to another address\\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\\n    ///  operator, or the approved address for this NFT. Throws if `from` is\\n    ///  not the current owner. Throws if `to` is the zero address. Throws if\\n    ///  `tokenId` is not a valid NFT. When transfer is complete, this function\\n    ///  checks if `to` is a smart contract (code size \\u003e 0). If so, it calls\\n    ///  `onERC721Received` on `to` and throws if the return value is not\\n    ///  `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`.\\n    /// @param from The current owner of the NFT\\n    /// @param to The new owner\\n    /// @param tokenId The NFT to transfer\\n    /// @param data Additional data with no specified format, sent in call to `to`\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public {\\n        transferFrom(from, to, tokenId);\\n        require(checkOnERC721Received(from, to, tokenId, data), \\\"Identity: transfer to non ERC721Receiver implementer\\\");\\n    }\\n\\n    /// @notice Transfers the ownership of an NFT from one address to another address\\n    /// @dev This works identically to the other function with an extra data parameter,\\n    ///  except this function just sets data to \\\"\\\".\\n    /// @param from The current owner of the NFT\\n    /// @param to The new owner\\n    /// @param tokenId The NFT to transfer\\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\\n        safeTransferFrom(from, to, tokenId, \\u0027\\u0027);\\n    }\\n\\n\\n    /// @notice Change or reaffirm the approved address for an NFT\\n    /// @dev The zero address indicates there is no approved address.\\n    ///  Throws unless `msg.sender` is the current NFT owner, or an authorized\\n    ///  operator of the current owner.\\n    /// @param approved The new approved NFT controller\\n    /// @param tokenId The NFT to approve\\n    function approve(address approved, uint256 tokenId) public {\\n        address owner = owners[tokenId];\\n        require(isApproved(msg.sender, tokenId), \\u0027Identity: Not authorized to approve\\u0027);\\n        require(owner != approved, \\u0027Identity: Approving self not allowed\\u0027);\\n        tokenApprovals[tokenId] = approved;\\n        emit Approval(owner, approved, tokenId);\\n    }\\n\\n    /// @notice Enable or disable approval for a third party (\\\"operator\\\") to manage\\n    ///  all of `msg.sender`\\u0027s assets\\n    /// @dev Emits the ApprovalForAll event. The contract MUST allow\\n    ///  multiple operators per owner.\\n    /// @param operator Address to add to the set of authorized operators\\n    /// @param approved True if the operator is approved, false to revoke approval\\n    function setApprovalForAll(address operator, bool approved) external {\\n        operatorApprovals[msg.sender][operator] = approved;\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    /// @notice Get the approved address for a single NFT\\n    /// @dev Throws if `tokenId` is not a valid NFT.\\n    /// @param tokenId The NFT to find the approved address for\\n    /// @return The approved address for this NFT, or the zero address if there is none\\n    function getApproved(uint256 tokenId) external view returns (address) {\\n        address owner = owners[tokenId];\\n        require(owner != address(0), \\u0027Identity: Invalid tokenId\\u0027);\\n        return tokenApprovals[tokenId];\\n    }\\n\\n    /// @notice Query if an address is an authorized operator for another address\\n    /// @param owner The address that owns the NFTs\\n    /// @param operator The address that acts on behalf of the owner\\n    /// @return True if `operator` is an approved operator for `owner`, false otherwise\\n    function isApprovedForAll(address owner, address operator) public view returns (bool) {\\n        return operatorApprovals[owner][operator];\\n    }\\n\\n    /// ================ UTILS =========================\\n    function isApproved(address operator, uint tokenId) public view returns (bool) {\\n        address owner = owners[tokenId];\\n        return (\\n            operator == owner ||\\n            operatorApprovals[owner][operator] ||\\n            tokenApprovals[tokenId] == operator\\n        );\\n    }\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address from, address to, uint256 tokenId) internal {\\n        require(owners[tokenId] == from, \\\"Identity: Transfer of token that is not own\\\");\\n        require(to != address(0), \\\"Identity: transfer to the zero address\\\");\\n\\n        // Clear approvals from the previous owner\\n        approve(address(0), tokenId);\\n\\n        owners[tokenId] = to;\\n        balances[from] = balances[from].minus(1);\\n        balances[to] = balances[to].plus(1);\\n\\n        emit Transfer(from, to, tokenId);\\n    }\\n\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for non-contract addresses\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size \\u003e 0;\\n    }\\n\\n    /**\\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\\n     * The call is not executed if the target address is not a contract.\\n     *\\n     * @param from address representing the previous owner of the given token ID\\n     * @param to target address that will receive the tokens\\n     * @param tokenId uint256 ID of the token to be transferred\\n     * @param data bytes optional data to send along with the call\\n     * @return bool whether the call correctly returned the expected magic value\\n     */\\n    function checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data)\\n        private returns (bool)\\n    {\\n        if (!isContract(to)) {\\n            return true;\\n        }\\n        IERC721Receiver target = IERC721Receiver(to);\\n        bytes4 retval = target.onERC721Received(from, to, tokenId, data);\\n        return ERC721_RECEIVED == retval;\\n    }\\n\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external pure returns (bool) {\\n        return (\\n            interfaceId == INTERFACE_ID_ERC721 ||\\n            interfaceId == INTERFACE_ID_ERC165\\n        );\\n    }\\n\\n}\\n\"},\"SafeMathLib.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity 0.7.4;\\n\\nlibrary SafeMathLib {\\n  function times(uint a, uint b) public pure returns (uint) {\\n    uint c = a * b;\\n    require(a == 0 || c / a == b, \\u0027Overflow detected\\u0027);\\n    return c;\\n  }\\n\\n  function minus(uint a, uint b) public pure returns (uint) {\\n    require(b \\u003c= a, \\u0027Underflow detected\\u0027);\\n    return a - b;\\n  }\\n\\n  function plus(uint a, uint b) public pure returns (uint) {\\n    uint c = a + b;\\n    require(c\\u003e=a \\u0026\\u0026 c\\u003e=b, \\u0027Overflow detected\\u0027);\\n    return c;\\n  }\\n\\n}\\n\"}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"mgmt\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"token\",\"type\":\"uint256\"}],\"name\":\"IdentityCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldIdDecayFactor\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newIdDecayFactor\",\"type\":\"uint256\"}],\"name\":\"IdentityDecayFactorUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldIdIncreaseDenominator\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newIdIncreaseDenominator\",\"type\":\"uint256\"}],\"name\":\"IdentityIncreaseDenominatorUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldIdIncreaseFactor\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newIdIncreaseFactor\",\"type\":\"uint256\"}],\"name\":\"IdentityIncreaseFactorUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldIdPriceFloor\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newIdPriceFloor\",\"type\":\"uint256\"}],\"name\":\"IdentityPriceFloorUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldManagement\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newManagement\",\"type\":\"address\"}],\"name\":\"ManagementUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"TokenSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newId\",\"type\":\"address\"}],\"name\":\"createIdentityFor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxPrice\",\"type\":\"uint256\"}],\"name\":\"createMyIdentity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getIdentityPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"identityDecayFactor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"identityIncreaseDenominator\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"identityIncreaseFactor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"identityPriceFloor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"isApproved\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastIdentityPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastPurchaseBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"management\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numIdentities\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"operatorApprovals\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"owners\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newDecayFactor\",\"type\":\"uint256\"}],\"name\":\"setIdentityDecayFactor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newIncreaseDenominator\",\"type\":\"uint256\"}],\"name\":\"setIdentityIncreaseDenominator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newIncreaseFactor\",\"type\":\"uint256\"}],\"name\":\"setIdentityIncreaseFactor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newPriceFloor\",\"type\":\"uint256\"}],\"name\":\"setIdentityPriceFloor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newMgmt\",\"type\":\"address\"}],\"name\":\"setManagement\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddr\",\"type\":\"address\"}],\"name\":\"setToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenApprovals\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Identity", "CompilerVersion": "v0.7.4+commit.3f05b770", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000288fe43139741f91a8cbb6f4add83811c794851b", "EVMVersion": "Default", "Library": "SafeMathLib:82d7630c5eb722557de6d76575c9a7b8de718500", "LicenseType": "GNU GPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://6733bb9ceb3b8e55ed006e5c85c3c2f5992025c64a3d50616832e57061796a76"}