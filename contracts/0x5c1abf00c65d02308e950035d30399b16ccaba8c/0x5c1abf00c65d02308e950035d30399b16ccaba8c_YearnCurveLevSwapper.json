{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/swappers/YearnCurveLevSwapper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// solhint-disable avoid-low-level-calls\\npragma solidity >=0.8.0;\\n\\nimport {SafeTransferLib} from \\\"solady/utils/SafeTransferLib.sol\\\";\\nimport {IERC20} from \\\"BoringSolidity/interfaces/IERC20.sol\\\";\\nimport {IBentoBoxV1} from \\\"interfaces/IBentoBoxV1.sol\\\";\\nimport {CurveLevSwapper} from \\\"swappers/CurveLevSwapper.sol\\\";\\nimport {IYearnVault} from \\\"interfaces/IYearnVault.sol\\\";\\nimport {ICurvePool, CurvePoolInterfaceType} from \\\"interfaces/ICurvePool.sol\\\";\\n\\ncontract YearnCurveLevSwapper is CurveLevSwapper {\\n    using SafeTransferLib for address;\\n\\n    IYearnVault public immutable wrapper;\\n\\n    constructor(\\n        IBentoBoxV1 _bentoBox,\\n        IYearnVault _wrapper,\\n        address _mim,\\n        CurvePoolInterfaceType _curvePoolInterfaceType,\\n        address _curvePool,\\n        address _curvePoolDepositor /* Optional Curve Deposit Zapper */,\\n        address[] memory _poolTokens,\\n        address _zeroXExchangeProxy\\n    )\\n        CurveLevSwapper(\\n            _bentoBox,\\n            _wrapper.token(),\\n            _mim,\\n            _curvePoolInterfaceType,\\n            _curvePool,\\n            _curvePoolDepositor,\\n            _poolTokens,\\n            _zeroXExchangeProxy\\n        )\\n    {\\n        wrapper = _wrapper;\\n        curveToken.safeApprove(address(_wrapper), type(uint256).max);\\n    }\\n\\n    function depositInBentoBox(uint256 amount, address recipient) internal override returns (uint256 shareReturned) {\\n        // CurveLP -> Yearn Vault\\n        amount = wrapper.deposit(amount, address(bentoBox));\\n\\n        (, shareReturned) = bentoBox.deposit(IERC20(address(wrapper)), address(bentoBox), recipient, amount, 0);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solady/src/utils/SafeTransferLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/SafeTransferLib.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n///\\n/// @dev Note:\\n/// - For ETH transfers, please use `forceSafeTransferETH` for DoS protection.\\n/// - For ERC20s, this implementation won't check that a token has code,\\n///   responsibility is delegated to the caller.\\nlibrary SafeTransferLib {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The ETH transfer has failed.\\n    error ETHTransferFailed();\\n\\n    /// @dev The ERC20 `transferFrom` has failed.\\n    error TransferFromFailed();\\n\\n    /// @dev The ERC20 `transfer` has failed.\\n    error TransferFailed();\\n\\n    /// @dev The ERC20 `approve` has failed.\\n    error ApproveFailed();\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Suggested gas stipend for contract receiving ETH that disallows any storage writes.\\n    uint256 internal constant GAS_STIPEND_NO_STORAGE_WRITES = 2300;\\n\\n    /// @dev Suggested gas stipend for contract receiving ETH to perform a few\\n    /// storage reads and writes, but low enough to prevent griefing.\\n    uint256 internal constant GAS_STIPEND_NO_GRIEF = 100000;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       ETH OPERATIONS                       */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    // If the ETH transfer MUST succeed with a reasonable gas budget, use the force variants.\\n    //\\n    // The regular variants:\\n    // - Forwards all remaining gas to the target.\\n    // - Reverts if the target reverts.\\n    // - Reverts if the current contract has insufficient balance.\\n    //\\n    // The force variants:\\n    // - Forwards with an optional gas stipend\\n    //   (defaults to `GAS_STIPEND_NO_GRIEF`, which is sufficient for most cases).\\n    // - If the target reverts, or if the gas stipend is exhausted,\\n    //   creates a temporary contract to force send the ETH via `SELFDESTRUCT`.\\n    //   Future compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758.\\n    // - Reverts if the current contract has insufficient balance.\\n    //\\n    // The try variants:\\n    // - Forwards with a mandatory gas stipend.\\n    // - Instead of reverting, returns whether the transfer succeeded.\\n\\n    /// @dev Sends `amount` (in wei) ETH to `to`.\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(call(gas(), to, amount, codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Sends all the ETH in the current contract to `to`.\\n    function safeTransferAllETH(address to) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Transfer all the ETH and check if it succeeded or not.\\n            if iszero(call(gas(), to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\\n    function forceSafeTransferETH(address to, uint256 amount, uint256 gasStipend) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if lt(selfbalance(), amount) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            if iszero(call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends all the ETH in the current contract to `to`, with a `gasStipend`.\\n    function forceSafeTransferAllETH(address to, uint256 gasStipend) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with `GAS_STIPEND_NO_GRIEF`.\\n    function forceSafeTransferETH(address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if lt(selfbalance(), amount) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, amount, codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends all the ETH in the current contract to `to`, with `GAS_STIPEND_NO_GRIEF`.\\n    function forceSafeTransferAllETH(address to) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // forgefmt: disable-next-item\\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\\n    function trySafeTransferETH(address to, uint256 amount, uint256 gasStipend)\\n        internal\\n        returns (bool success)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            success := call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)\\n        }\\n    }\\n\\n    /// @dev Sends all the ETH in the current contract to `to`, with a `gasStipend`.\\n    function trySafeTransferAllETH(address to, uint256 gasStipend)\\n        internal\\n        returns (bool success)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            success := call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                      ERC20 OPERATIONS                      */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\\n    /// Reverts upon failure.\\n    ///\\n    /// The `from` account must have at least `amount` approved for\\n    /// the current contract to manage.\\n    function safeTransferFrom(address token, address from, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x60, amount) // Store the `amount` argument.\\n            mstore(0x40, to) // Store the `to` argument.\\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\\n            mstore(0x0c, 0x23b872dd000000000000000000000000) // `transferFrom(address,address,uint256)`.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Sends all of ERC20 `token` from `from` to `to`.\\n    /// Reverts upon failure.\\n    ///\\n    /// The `from` account must have their entire balance approved for\\n    /// the current contract to manage.\\n    function safeTransferAllFrom(address token, address from, address to)\\n        internal\\n        returns (uint256 amount)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x40, to) // Store the `to` argument.\\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\\n            mstore(0x0c, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\\n            // Read the balance, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                    staticcall(gas(), token, 0x1c, 0x24, 0x60, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x00, 0x23b872dd) // `transferFrom(address,address,uint256)`.\\n            amount := mload(0x60) // The `amount` is already at 0x60. We'll need to return it.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Sends `amount` of ERC20 `token` from the current contract to `to`.\\n    /// Reverts upon failure.\\n    function safeTransfer(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Sends all of ERC20 `token` from the current contract to `to`.\\n    /// Reverts upon failure.\\n    function safeTransferAll(address token, address to) internal returns (uint256 amount) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, 0x70a08231) // Store the function selector of `balanceOf(address)`.\\n            mstore(0x20, address()) // Store the address of the current contract.\\n            // Read the balance, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                    staticcall(gas(), token, 0x1c, 0x24, 0x34, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x14, to) // Store the `to` argument.\\n            amount := mload(0x34) // The `amount` is already at 0x34. We'll need to return it.\\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\\n    /// Reverts upon failure.\\n    function safeApprove(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n            // Perform the approval, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\\n    /// If the initial attempt to approve fails, attempts to reset the approved amount to zero,\\n    /// then retries the approval again (some tokens, e.g. USDT, requires this).\\n    /// Reverts upon failure.\\n    function safeApproveWithRetry(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n            // Perform the approval, retrying upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x34, 0) // Store 0 for the `amount`.\\n                mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n                pop(call(gas(), token, 0, 0x10, 0x44, codesize(), 0x00)) // Reset the approval.\\n                mstore(0x34, amount) // Store back the original `amount`.\\n                // Retry the approval, reverting upon failure.\\n                if iszero(\\n                    and(\\n                        or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                        call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                    )\\n                ) {\\n                    mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Returns the amount of ERC20 `token` owned by `account`.\\n    /// Returns zero if the `token` does not exist.\\n    function balanceOf(address token, address account) internal view returns (uint256 amount) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, account) // Store the `account` argument.\\n            mstore(0x00, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\\n            amount :=\\n                mul(\\n                    mload(0x20),\\n                    and( // The arguments of `and` are evaluated from right to left.\\n                        gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                        staticcall(gas(), token, 0x10, 0x24, 0x20, 0x20)\\n                    )\\n                )\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/BoringSolidity/contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IERC20 {\\n    // transfer and tranferFrom have been removed, because they don't work on all tokens (some aren't ERC20 complaint).\\n    // By removing them you can't accidentally use them.\\n    // name, symbol and decimals have been removed, because they are optional and sometimes wrongly implemented (MKR).\\n    // Use BoringERC20 with `using BoringERC20 for IERC20` and call `safeTransfer`, `safeTransferFrom`, etc instead.\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /// @notice EIP 2612\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n}\\n\\ninterface IStrictERC20 {\\n    // This is the strict ERC20 interface. Don't use this, certainly not if you don't control the ERC20 token you're calling.\\n    function name() external view returns (string memory);\\n    function symbol() external view returns (string memory);\\n    function decimals() external view returns (uint8);\\n    function totalSupply() external view returns (uint256);\\n    function balanceOf(address _owner) external view returns (uint256 balance);\\n    function transfer(address _to, uint256 _value) external returns (bool success);\\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\\n    function approve(address _spender, uint256 _value) external returns (bool success);\\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /// @notice EIP 2612\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IBentoBoxV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\nimport \\\"BoringSolidity/interfaces/IERC20.sol\\\";\\nimport \\\"BoringSolidity/libraries/BoringRebase.sol\\\";\\nimport \\\"interfaces/IStrategy.sol\\\";\\n\\ninterface IFlashBorrower {\\n    /// @notice The flashloan callback. `amount` + `fee` needs to repayed to msg.sender before this call returns.\\n    /// @param sender The address of the invoker of this flashloan.\\n    /// @param token The address of the token that is loaned.\\n    /// @param amount of the `token` that is loaned.\\n    /// @param fee The fee that needs to be paid on top for this loan. Needs to be the same as `token`.\\n    /// @param data Additional data that was passed to the flashloan function.\\n    function onFlashLoan(\\n        address sender,\\n        IERC20 token,\\n        uint256 amount,\\n        uint256 fee,\\n        bytes calldata data\\n    ) external;\\n}\\n\\ninterface IBatchFlashBorrower {\\n    /// @notice The callback for batched flashloans. Every amount + fee needs to repayed to msg.sender before this call returns.\\n    /// @param sender The address of the invoker of this flashloan.\\n    /// @param tokens Array of addresses for ERC-20 tokens that is loaned.\\n    /// @param amounts A one-to-one map to `tokens` that is loaned.\\n    /// @param fees A one-to-one map to `tokens` that needs to be paid on top for each loan. Needs to be the same token.\\n    /// @param data Additional data that was passed to the flashloan function.\\n    function onBatchFlashLoan(\\n        address sender,\\n        IERC20[] calldata tokens,\\n        uint256[] calldata amounts,\\n        uint256[] calldata fees,\\n        bytes calldata data\\n    ) external;\\n}\\n\\ninterface IBentoBoxV1 {\\n    function balanceOf(IERC20, address) external view returns (uint256);\\n\\n    function batch(bytes[] calldata calls, bool revertOnFail) external payable returns (bool[] memory successes, bytes[] memory results);\\n\\n    function batchFlashLoan(\\n        IBatchFlashBorrower borrower,\\n        address[] calldata receivers,\\n        IERC20[] calldata tokens,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) external;\\n\\n    function claimOwnership() external;\\n\\n    function flashLoan(\\n        IFlashBorrower borrower,\\n        address receiver,\\n        IERC20 token,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external;\\n\\n    function deploy(\\n        address masterContract,\\n        bytes calldata data,\\n        bool useCreate2\\n    ) external payable returns (address);\\n\\n    function deposit(\\n        IERC20 token_,\\n        address from,\\n        address to,\\n        uint256 amount,\\n        uint256 share\\n    ) external payable returns (uint256 amountOut, uint256 shareOut);\\n\\n    function harvest(\\n        IERC20 token,\\n        bool balance,\\n        uint256 maxChangeAmount\\n    ) external;\\n\\n    function masterContractApproved(address, address) external view returns (bool);\\n\\n    function masterContractOf(address) external view returns (address);\\n\\n    function nonces(address) external view returns (uint256);\\n\\n    function owner() external view returns (address);\\n\\n    function pendingOwner() external view returns (address);\\n\\n    function pendingStrategy(IERC20) external view returns (IStrategy);\\n\\n    function permitToken(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    function registerProtocol() external;\\n\\n    function setMasterContractApproval(\\n        address user,\\n        address masterContract,\\n        bool approved,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    function setStrategy(IERC20 token, IStrategy newStrategy) external;\\n\\n    function setStrategyTargetPercentage(IERC20 token, uint64 targetPercentage_) external;\\n\\n    function strategy(IERC20) external view returns (IStrategy);\\n\\n    function strategyData(IERC20)\\n        external\\n        view\\n        returns (\\n            uint64 strategyStartDate,\\n            uint64 targetPercentage,\\n            uint128 balance\\n        );\\n\\n    function toAmount(\\n        IERC20 token,\\n        uint256 share,\\n        bool roundUp\\n    ) external view returns (uint256 amount);\\n\\n    function toShare(\\n        IERC20 token,\\n        uint256 amount,\\n        bool roundUp\\n    ) external view returns (uint256 share);\\n\\n    function totals(IERC20) external view returns (Rebase memory totals_);\\n\\n    function transfer(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 share\\n    ) external;\\n\\n    function transferMultiple(\\n        IERC20 token,\\n        address from,\\n        address[] calldata tos,\\n        uint256[] calldata shares\\n    ) external;\\n\\n    function transferOwnership(\\n        address newOwner,\\n        bool direct,\\n        bool renounce\\n    ) external;\\n\\n    function whitelistMasterContract(address masterContract, bool approved) external;\\n\\n    function whitelistedMasterContracts(address) external view returns (bool);\\n\\n    function withdraw(\\n        IERC20 token_,\\n        address from,\\n        address to,\\n        uint256 amount,\\n        uint256 share\\n    ) external returns (uint256 amountOut, uint256 shareOut);\\n}\\n\"\r\n    },\r\n    \"src/swappers/CurveLevSwapper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// solhint-disable avoid-low-level-calls\\npragma solidity >=0.8.0;\\n\\nimport {SafeTransferLib} from \\\"solady/utils/SafeTransferLib.sol\\\";\\nimport {IERC20} from \\\"BoringSolidity/interfaces/IERC20.sol\\\";\\nimport {IBentoBoxV1} from \\\"interfaces/IBentoBoxV1.sol\\\";\\nimport {ILevSwapperV2} from \\\"interfaces/ILevSwapperV2.sol\\\";\\nimport {ICurvePool, CurvePoolInterfaceType, ICurve3PoolZapper} from \\\"interfaces/ICurvePool.sol\\\";\\n\\ncontract CurveLevSwapper is ILevSwapperV2 {\\n    using SafeTransferLib for address;\\n\\n    error ErrSwapFailed();\\n    error ErrUnsupportedCurvePool();\\n    error ErrUnsupportedCurvePoolLength();\\n\\n    IBentoBoxV1 public immutable bentoBox;\\n    address public immutable curveToken;\\n    address public immutable mim;\\n    CurvePoolInterfaceType public immutable curvePoolInterfaceType;\\n    address public immutable zeroXExchangeProxy;\\n    address public immutable curvePool;\\n    address public immutable curvePoolDepositor;\\n    uint256 public immutable curvePoolCoinsLength;\\n\\n    constructor(\\n        IBentoBoxV1 _bentoBox,\\n        address _curveToken,\\n        address _mim,\\n        CurvePoolInterfaceType _curvePoolInterfaceType,\\n        address _curvePool,\\n        address _curvePoolDepositor /* Optional Curve Deposit Zapper */,\\n        address[] memory _poolTokens,\\n        address _zeroXExchangeProxy\\n    ) {\\n        bentoBox = _bentoBox;\\n        curveToken = _curveToken;\\n        mim = _mim;\\n        zeroXExchangeProxy = _zeroXExchangeProxy;\\n        curvePoolCoinsLength = _poolTokens.length;\\n        curvePoolInterfaceType = _curvePoolInterfaceType;\\n        curvePool = _curvePool;\\n\\n        _mim.safeApprove(_zeroXExchangeProxy, type(uint256).max);\\n\\n        address depositor = _curvePool;\\n\\n        if (_curvePoolDepositor != address(0)) {\\n            depositor = _curvePoolDepositor;\\n        }\\n\\n        for (uint256 i = 0; i < _poolTokens.length; i++) {\\n            _poolTokens[i].safeApprove(address(depositor), type(uint256).max);\\n        }\\n\\n        curvePoolDepositor = depositor;\\n    }\\n\\n    function depositInBentoBox(uint256 amount, address recipient) internal virtual returns (uint256 shareReturned) {\\n        (, shareReturned) = bentoBox.deposit(IERC20(curveToken), address(bentoBox), recipient, amount, 0);\\n    }\\n\\n    /// @inheritdoc ILevSwapperV2\\n    function swap(\\n        address recipient,\\n        uint256 shareToMin,\\n        uint256 shareFrom,\\n        bytes calldata data\\n    ) external override returns (uint256 extraShare, uint256 shareReturned) {\\n        (address underlyingToken, uint256 poolIndex, bytes memory swapData) = abi.decode(data, (address, uint256, bytes));\\n        bentoBox.withdraw(IERC20(mim), address(this), address(this), 0, shareFrom);\\n\\n        // Optional MIM -> Asset\\n        if (swapData.length != 0) {\\n            (bool success, ) = zeroXExchangeProxy.call(swapData);\\n            if (!success) {\\n                revert ErrSwapFailed();\\n            }\\n\\n            // Refund remaining underlying balance to the recipient\\n            mim.safeTransfer(recipient, mim.balanceOf(address(this)));\\n        }\\n\\n        // Asset -> Curve LP\\n        if (curvePoolInterfaceType == CurvePoolInterfaceType.ICURVE_3POOL_ZAPPER) {\\n            _addLiquidityUsing3PoolZapper(underlyingToken, poolIndex);\\n        } else if (\\n            curvePoolInterfaceType == CurvePoolInterfaceType.ICURVE_POOL ||\\n            curvePoolInterfaceType == CurvePoolInterfaceType.IFACTORY_POOL ||\\n            curvePoolInterfaceType == CurvePoolInterfaceType.ITRICRYPTO_POOL\\n        ) {\\n            _addLiquidityCurvePool(underlyingToken, poolIndex);\\n        } else {\\n            revert ErrUnsupportedCurvePool();\\n        }\\n\\n        uint256 _amount = curveToken.balanceOf(address(this));\\n        shareReturned = depositInBentoBox(_amount, recipient);\\n        extraShare = shareReturned - shareToMin;\\n    }\\n\\n    function _addLiquidityUsing3PoolZapper(address underlyingToken, uint256 poolIndex) internal {\\n        uint256[4] memory amounts;\\n        amounts[poolIndex] = underlyingToken.balanceOf(address(this));\\n        ICurve3PoolZapper(curvePoolDepositor).add_liquidity(curvePool, amounts, 0);\\n    }\\n\\n    function _addLiquidityCurvePool(address underlyingToken, uint256 poolIndex) internal {\\n        if (curvePoolCoinsLength == 2) {\\n            uint256[2] memory amounts;\\n            amounts[poolIndex] = underlyingToken.balanceOf(address(this));\\n            ICurvePool(curvePoolDepositor).add_liquidity(amounts, 0);\\n        } else if (curvePoolCoinsLength == 3) {\\n            uint256[3] memory amounts;\\n            amounts[poolIndex] = underlyingToken.balanceOf(address(this));\\n            ICurvePool(curvePoolDepositor).add_liquidity(amounts, 0);\\n        } else if (curvePoolCoinsLength == 4) {\\n            uint256[4] memory amounts;\\n            amounts[poolIndex] = underlyingToken.balanceOf(address(this));\\n            ICurvePool(curvePoolDepositor).add_liquidity(amounts, 0);\\n        } else {\\n            revert ErrUnsupportedCurvePoolLength();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IYearnVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// solhint-disable func-name-mixedcase, var-name-mixedcase\\npragma solidity >=0.8.0;\\nimport \\\"BoringSolidity/interfaces/IERC20.sol\\\";\\n\\ninterface IYearnVault is IERC20 {\\n    function withdraw() external returns (uint256);\\n    function deposit(uint256 amount, address recipient) external returns (uint256);\\n    function pricePerShare() external view returns (uint256);\\n    function token() external view returns (address);\\n    function decimals() external view returns (uint256);\\n}\"\r\n    },\r\n    \"src/interfaces/ICurvePool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// solhint-disable func-name-mixedcase, var-name-mixedcase\\npragma solidity >=0.8.0;\\n\\nenum CurvePoolInterfaceType {\\n    ICURVE_POOL,\\n    ICURVE_3POOL_ZAPPER,\\n    IFACTORY_POOL,\\n    ITRICRYPTO_POOL\\n}\\n\\ninterface ICurvePool {\\n    function decimals() external view returns (uint256);\\n\\n    function coins(uint256 i) external view returns (address);\\n\\n    function exchange_underlying(int128 i, int128 j, uint256 dx, uint256 min_dy, address receiver) external returns (uint256);\\n\\n    function exchange(int128 i, int128 j, uint256 dx, uint256 min_dy, address receiver) external returns (uint256);\\n\\n    function exchange(uint256 i, uint256 j, uint256 dx, uint256 min_dy) external returns (uint256);\\n\\n    function get_dy_underlying(int128 i, int128 j, uint256 dx) external view returns (uint256);\\n\\n    function get_dy(int128 i, int128 j, uint256 dx) external view returns (uint256);\\n\\n    function approve(address _spender, uint256 _value) external returns (bool);\\n\\n    function add_liquidity(uint256[2] memory amounts, uint256 _min_mint_amount) external;\\n\\n    function add_liquidity(uint256[3] memory amounts, uint256 _min_mint_amount) external;\\n\\n    function add_liquidity(uint256[4] memory amounts, uint256 _min_mint_amount) external;\\n\\n    function remove_liquidity_one_coin(uint256 tokenAmount, int128 i, uint256 min_amount) external returns (uint256);\\n\\n    function get_virtual_price() external view returns (uint256 price);\\n}\\n\\ninterface ICurve3PoolZapper {\\n    function add_liquidity(address _pool, uint256[4] memory _deposit_amounts, uint256 _min_mint_amount) external returns (uint256);\\n\\n    function add_liquidity(\\n        address _pool,\\n        uint256[4] memory _deposit_amounts,\\n        uint256 _min_mint_amount,\\n        address _receiver\\n    ) external returns (uint256);\\n\\n    function remove_liquidity(address _pool, uint256 _burn_amount, uint256[4] memory _min_amounts) external returns (uint256[4] memory);\\n\\n    function remove_liquidity(\\n        address _pool,\\n        uint256 _burn_amount,\\n        uint256[4] memory _min_amounts,\\n        address _receiver\\n    ) external returns (uint256[4] memory);\\n\\n    function remove_liquidity_one_coin(address _pool, uint256 _burn_amount, int128 i, uint256 _min_amount) external returns (uint256);\\n\\n    function remove_liquidity_one_coin(\\n        address _pool,\\n        uint256 _burn_amount,\\n        int128 i,\\n        uint256 _min_amount,\\n        address _receiver\\n    ) external returns (uint256);\\n}\\n\\ninterface IFactoryPool is ICurvePool {\\n    function remove_liquidity_one_coin(uint256 tokenAmount, uint256 i, uint256 min_amount) external returns (uint256);\\n}\\n\\ninterface ITriCrypto is ICurvePool {\\n    function remove_liquidity_one_coin(uint256 tokenAmount, uint256 i, uint256 min_amount) external;\\n}\\n\"\r\n    },\r\n    \"lib/BoringSolidity/contracts/libraries/BoringRebase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nstruct Rebase {\\n    uint128 elastic;\\n    uint128 base;\\n}\\n\\n/// @notice A rebasing library using overflow-/underflow-safe math.\\nlibrary RebaseLibrary {\\n    /// @notice Calculates the base value in relationship to `elastic` and `total`.\\n    function toBase(\\n        Rebase memory total,\\n        uint256 elastic,\\n        bool roundUp\\n    ) internal pure returns (uint256 base) {\\n        if (total.elastic == 0) {\\n            base = elastic;\\n        } else {\\n            base = (elastic * total.base) / total.elastic;\\n            if (roundUp && (base * total.elastic) / total.base < elastic) {\\n                base++;\\n            }\\n        }\\n    }\\n\\n    /// @notice Calculates the elastic value in relationship to `base` and `total`.\\n    function toElastic(\\n        Rebase memory total,\\n        uint256 base,\\n        bool roundUp\\n    ) internal pure returns (uint256 elastic) {\\n        if (total.base == 0) {\\n            elastic = base;\\n        } else {\\n            elastic = (base * total.elastic) / total.base;\\n            if (roundUp && (elastic * total.base) / total.elastic < base) {\\n                elastic++;\\n            }\\n        }\\n    }\\n\\n    /// @notice Add `elastic` to `total` and doubles `total.base`.\\n    /// @return (Rebase) The new total.\\n    /// @return base in relationship to `elastic`.\\n    function add(\\n        Rebase memory total,\\n        uint256 elastic,\\n        bool roundUp\\n    ) internal pure returns (Rebase memory, uint256 base) {\\n        base = toBase(total, elastic, roundUp);\\n        total.elastic += uint128(elastic);\\n        total.base += uint128(base);\\n        return (total, base);\\n    }\\n\\n    /// @notice Sub `base` from `total` and update `total.elastic`.\\n    /// @return (Rebase) The new total.\\n    /// @return elastic in relationship to `base`.\\n    function sub(\\n        Rebase memory total,\\n        uint256 base,\\n        bool roundUp\\n    ) internal pure returns (Rebase memory, uint256 elastic) {\\n        elastic = toElastic(total, base, roundUp);\\n        total.elastic -= uint128(elastic);\\n        total.base -= uint128(base);\\n        return (total, elastic);\\n    }\\n\\n    /// @notice Add `elastic` and `base` to `total`.\\n    function add(\\n        Rebase memory total,\\n        uint256 elastic,\\n        uint256 base\\n    ) internal pure returns (Rebase memory) {\\n        total.elastic += uint128(elastic);\\n        total.base += uint128(base);\\n        return total;\\n    }\\n\\n    /// @notice Subtract `elastic` and `base` to `total`.\\n    function sub(\\n        Rebase memory total,\\n        uint256 elastic,\\n        uint256 base\\n    ) internal pure returns (Rebase memory) {\\n        total.elastic -= uint128(elastic);\\n        total.base -= uint128(base);\\n        return total;\\n    }\\n\\n    /// @notice Add `elastic` to `total` and update storage.\\n    /// @return newElastic Returns updated `elastic`.\\n    function addElastic(Rebase storage total, uint256 elastic) internal returns (uint256 newElastic) {\\n        newElastic = total.elastic += uint128(elastic);\\n    }\\n\\n    /// @notice Subtract `elastic` from `total` and update storage.\\n    /// @return newElastic Returns updated `elastic`.\\n    function subElastic(Rebase storage total, uint256 elastic) internal returns (uint256 newElastic) {\\n        newElastic = total.elastic -= uint128(elastic);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IStrategy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity >=0.8.0;\\n\\ninterface IStrategy {\\n    /// @notice Send the assets to the Strategy and call skim to invest them.\\n    /// @param amount The amount of tokens to invest.\\n    function skim(uint256 amount) external;\\n\\n    /// @notice Harvest any profits made converted to the asset and pass them to the caller.\\n    /// @param balance The amount of tokens the caller thinks it has invested.\\n    /// @param sender The address of the initiator of this transaction. Can be used for reimbursements, etc.\\n    /// @return amountAdded The delta (+profit or -loss) that occured in contrast to `balance`.\\n    function harvest(uint256 balance, address sender) external returns (int256 amountAdded);\\n\\n    /// @notice Withdraw assets. The returned amount can differ from the requested amount due to rounding.\\n    /// @dev The `actualAmount` should be very close to the amount.\\n    /// The difference should NOT be used to report a loss. That's what harvest is for.\\n    /// @param amount The requested amount the caller wants to withdraw.\\n    /// @return actualAmount The real amount that is withdrawn.\\n    function withdraw(uint256 amount) external returns (uint256 actualAmount);\\n\\n    /// @notice Withdraw all assets in the safest way possible. This shouldn't fail.\\n    /// @param balance The amount of tokens the caller thinks it has invested.\\n    /// @return amountAdded The delta (+profit or -loss) that occured in contrast to `balance`.\\n    function exit(uint256 balance) external returns (int256 amountAdded);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ILevSwapperV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\ninterface ILevSwapperV2 {\\n    function swap(\\n        address recipient,\\n        uint256 shareToMin,\\n        uint256 shareFrom,\\n        bytes calldata data\\n    ) external returns (uint256 extraShare, uint256 shareReturned);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"/=src/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/contracts/\",\r\n      \"BoringSolidity/=lib/BoringSolidity/contracts/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"solmate/=lib/solmate/src/\",\r\n      \"utils/=utils/\",\r\n      \"libraries/=src/libraries/\",\r\n      \"interfaces/=src/interfaces/\",\r\n      \"cauldrons/=src/cauldrons/\",\r\n      \"swappers/=src/swappers/\",\r\n      \"oracles/=src/oracles/\",\r\n      \"strategies/=src/strategies/\",\r\n      \"tokens/=src/tokens/\",\r\n      \"periphery/=src/periphery/\",\r\n      \"mixins/=src/mixins/\",\r\n      \"lenses/=src/lenses/\",\r\n      \"surl/=lib/surl/src/\",\r\n      \"solady/=lib/solady/src/\",\r\n      \"forge-deploy/=lib/forge-deploy/contracts/\",\r\n      \"ExcessivelySafeCall/=lib/ExcessivelySafeCall/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 800\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"shanghai\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IBentoBoxV1\",\"name\":\"_bentoBox\",\"type\":\"address\"},{\"internalType\":\"contract IYearnVault\",\"name\":\"_wrapper\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_mim\",\"type\":\"address\"},{\"internalType\":\"enum CurvePoolInterfaceType\",\"name\":\"_curvePoolInterfaceType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"_curvePool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_curvePoolDepositor\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_poolTokens\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"_zeroXExchangeProxy\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ErrSwapFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ErrUnsupportedCurvePool\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ErrUnsupportedCurvePoolLength\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"bentoBox\",\"outputs\":[{\"internalType\":\"contract IBentoBoxV1\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"curvePool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"curvePoolCoinsLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"curvePoolDepositor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"curvePoolInterfaceType\",\"outputs\":[{\"internalType\":\"enum CurvePoolInterfaceType\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"curveToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mim\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"shareToMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"shareFrom\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"swap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"extraShare\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"shareReturned\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wrapper\",\"outputs\":[{\"internalType\":\"contract IYearnVault\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"zeroXExchangeProxy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "YearnCurveLevSwapper", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "800", "ConstructorArguments": "000000000000000000000000d96f48665a1410c0cd669a88898eca36b9fc2cce0000000000000000000000007845ebf66c9575fc5f5a0dbb9a34a706ad997a3f00000000000000000000000099d8a9c45b2eca8864373a26d1459e3dff1e17f30000000000000000000000000000000000000000000000000000000000000002000000000000000000000000f5f5b97624542d72a9e06f04804bf81baa15e2b400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000def1c0ded9bec7f1a1670819833240f027b25eff0000000000000000000000000000000000000000000000000000000000000003000000000000000000000000dac17f958d2ee523a2206206994597c13d831ec70000000000000000000000002260fac5e5542a773aa44fbcfedf7c193bc2c599000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2", "EVMVersion": "shanghai", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}