{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/PricingV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n///@title PricingV1\\n///@author Koto Protocol\\n///@notice\\n\\npragma solidity 0.8.23;\\n\\nimport {IKotoV3} from \\\"./interfaces/IKotoV3.sol\\\";\\nimport {SafeTransferLib} from \\\"solmate/utils/SafeTransferLib.sol\\\";\\nimport {IERC20Minimal} from \\\"./interfaces/IERC20Minimal.sol\\\";\\nimport {FullMath} from \\\"./libraries/FullMath.sol\\\";\\n\\ncontract PricingV1 {\\n    // ====================================================== \\\\\\\\\\n    //                         CONSTANTS                      \\\\\\\\\\n    // ====================================================== \\\\\\\\\\n\\n    IKotoV3 public constant KOTO = IKotoV3(0x64C7d8C8Abf28Daf9D441c507CfE9Be678A0929c);\\n    address public constant BOND_DEPOSITORY = 0xE58B33c813ac4077bd2519dE90FccB189a19FA71;\\n    address public constant PAIR = 0x47287d8d7C1a5854Aa11868E7d2186b138069F84;\\n    uint256 public constant INTERVAL = 86400;\\n    uint256 public constant LENGTH = 604800;\\n    address public constant OWNER = 0x946eF43867225695E29241813A8F41519634B36b;\\n    bool private constant zeroForOne = true;\\n\\n    // ====================================================== \\\\\\\\\\n    //                         STRUCTS                        \\\\\\\\\\n    // ====================================================== \\\\\\\\\\n\\n    struct Model {\\n        uint48 interval;\\n        uint48 last;\\n        uint48 conclusion;\\n        uint96 theta;\\n        uint96 price;\\n        uint96 capacity;\\n    }\\n\\n    // ====================================================== \\\\\\\\\\n    //                         STORAGE                        \\\\\\\\\\n    // ====================================================== \\\\\\\\\\n\\n    Model public ethModel;\\n    Model public lpModel;\\n    uint256 private ethCapacity;\\n    uint256 private lpCapacity;\\n\\n    constructor() {}\\n\\n    // ====================================================== \\\\\\\\\\n    //                   EXTERNAL FUNCTIONS                   \\\\\\\\\\n    // ====================================================== \\\\\\\\\\n\\n    ///@notice bond Eth for koto\\n    function bond() external payable {\\n        if (block.timestamp > ethModel.conclusion) revert MarketClosed();\\n        if (ethModel.capacity != 0) {\\n            SafeTransferLib.safeTransferETH(address(KOTO), msg.value);\\n            // Cache variables for later use to minimize storage calls\\n            Model memory eth = ethModel;\\n\\n            uint48 time = uint48(block.timestamp);\\n            uint256 theta = eth.theta * (time - eth.last);\\n            uint256 price = eth.price - theta;\\n            uint256 payout = (msg.value * 1e18 / price);\\n            if (payout > _max(eth)) revert MaxPayout();\\n\\n            // Update market variables\\n            eth.price = uint96(_marketPrice(eth, payout));\\n            eth.theta = uint96(_decay(eth));\\n            eth.capacity -= uint96(payout);\\n            eth.last = time;\\n            ethModel = eth;\\n\\n            bool success = KOTO.transfer(msg.sender, payout);\\n            if (!success) revert BondFailed();\\n            emit Bond(msg.sender, payout, price);\\n        } else {\\n            //If bonds are not available refund the eth sent to the contract\\n            SafeTransferLib.safeTransferETH(msg.sender, msg.value);\\n        }\\n    }\\n\\n    ///@notice bond Koto / WETH LP tokens for Koto\\n    ///@param amount the amount of koto lp tokens to bond\\n    function bondLp(uint256 amount) external {\\n        if (block.timestamp > lpModel.conclusion) revert MarketClosed();\\n        if (lpModel.capacity != 0) {\\n            IERC20Minimal(PAIR).transferFrom(msg.sender, BOND_DEPOSITORY, amount);\\n            // Cache variables for later use to minimize storage calls\\n            Model memory lp = lpModel;\\n            uint48 time = uint48(block.timestamp);\\n            uint256 theta = lp.theta * (time - lp.last);\\n\\n            uint256 price = lp.price - theta;\\n\\n            uint256 payout = (amount * 1e18 / price);\\n            if (payout > _max(lp)) revert MaxPayout();\\n\\n            // Update market variables\\n            lp.price = uint96(_marketPrice(lp, payout));\\n            lp.theta = uint96(_decay(lp));\\n            lp.capacity -= uint96(payout);\\n            lp.last = time;\\n            lpModel = lp;\\n            bool success = KOTO.transfer(msg.sender, payout);\\n            if (!success) revert BondFailed();\\n            emit Bond(msg.sender, payout, price);\\n        } else {\\n            revert BondsSoldOut();\\n        }\\n    }\\n\\n    ///@notice transfer in the koto to be sold as bonds\\n    ///@param amount the amount of koto tokens to transfer in\\n    function notifyRewardAmount(uint256 amount) external {\\n        if (msg.sender != BOND_DEPOSITORY) revert OnlyDepository();\\n        KOTO.transferFrom(BOND_DEPOSITORY, address(this), amount);\\n    }\\n\\n    ///@notice transfer eth bonded for koto to the koto contract\\n    function addReserves() external {\\n        SafeTransferLib.safeTransferETH(address(KOTO), address(this).balance);\\n    }\\n\\n    ///@notice burn any unsold bonds\\n    function burn() external {\\n        if (msg.sender != OWNER) revert OnlyOwner();\\n        uint256 amount;\\n        if (KOTO.balanceOf(address(this)) - (ethModel.capacity + lpModel.capacity) > 0) {\\n            amount = KOTO.balanceOf(address(this)) - (ethModel.capacity + lpModel.capacity);\\n        }\\n        KOTO.burn(amount);\\n    }\\n\\n    function create(uint256 ethBonds, uint256 lpBonds) external {\\n        if (msg.sender != OWNER) revert OnlyOwner();\\n        if (ethModel.conclusion > block.timestamp) revert OngoingMarket();\\n        if (ethBonds + lpBonds > KOTO.balanceOf(address(this))) revert BondOverflow();\\n        ethCapacity = ethBonds;\\n        lpCapacity = lpBonds;\\n        _create();\\n        _createLpMarket();\\n    }\\n\\n    // ====================================================== \\\\\\\\\\n    //                   EXTERNAL VIEW FUNCTIONS               \\\\\\\\\\n    // ====================================================== \\\\\\\\\\n\\n    function market() external view returns (Model memory, Model memory) {\\n        return (ethModel, lpModel);\\n    }\\n\\n    function ethPrice() external view returns (uint256) {\\n        Model memory model = ethModel;\\n        return model.price - (model.theta * (block.timestamp - model.last));\\n    }\\n\\n    function lpPrice() external view returns (uint256) {\\n        Model memory model = lpModel;\\n        return model.price - (model.theta * (block.timestamp - model.last));\\n    }\\n\\n    // ====================================================== \\\\\\\\\\n    //                    INTERNAL FUNCTIONS                  \\\\\\\\\\n    // ====================================================== \\\\\\\\\\n\\n    // Set the initial price to the current market price\\n    function _create() private {\\n        uint256 _capacity = ethCapacity;\\n        if (_capacity > 0) {\\n            uint256 initialPrice = _getPrice();\\n            uint96 capacity = uint96(_capacity);\\n            uint48 conclusion = uint48(block.timestamp + LENGTH);\\n            bool policy = _policy(capacity, initialPrice);\\n\\n            if (policy) {\\n                Model memory _ethModel = Model(\\n                    uint48(INTERVAL),\\n                    uint48(block.timestamp),\\n                    uint48(conclusion),\\n                    0,\\n                    uint96(initialPrice),\\n                    uint96(capacity)\\n                );\\n                _ethModel.theta = uint96(_decay(_ethModel));\\n                ethModel = _ethModel;\\n                emit CreateMarket(capacity, block.timestamp, conclusion);\\n            } else {\\n                KOTO.burn(capacity);\\n                // Set the markets so that they will be closed for the next interval. Important step to make sure\\n                // that if anyone accidently tries to buy a bond they get refunded their eth.\\n                ethModel.conclusion = uint48(block.timestamp + INTERVAL);\\n                ethModel.capacity = 0;\\n            }\\n            ethCapacity = 0;\\n        } else {\\n            ethModel.conclusion = uint48(block.timestamp + LENGTH);\\n        }\\n    }\\n\\n    function _createLpMarket() private {\\n        uint256 _capacity = lpCapacity;\\n        if (_capacity > 0) {\\n            uint256 initialPrice = _getLpPrice();\\n            uint96 capacity = uint96(_capacity);\\n            uint48 conclusion = uint48(block.timestamp + LENGTH);\\n            Model memory _lpModel = Model(\\n                uint48(INTERVAL), uint48(block.timestamp), uint48(conclusion), 0, uint96(initialPrice), uint96(capacity)\\n            );\\n            _lpModel.theta = uint96(_decay(_lpModel));\\n            lpModel = _lpModel;\\n            emit CreateMarket(capacity, block.timestamp, conclusion);\\n            lpCapacity = 0;\\n        } else {\\n            lpModel.conclusion = uint48(block.timestamp + LENGTH);\\n        }\\n    }\\n\\n    // ====================================================== \\\\\\\\\\n    //                 INTERNAL VIEW FUNCTIONS                \\\\\\\\\\n    // ====================================================== \\\\\\\\\\n\\n    function _policy(uint256 capacity, uint256 price) private view returns (bool decision) {\\n        uint256 supply = KOTO.totalSupply();\\n        uint256 burnRelative = (address(KOTO).balance * 1e18) / (supply - capacity);\\n        uint256 bondRelative = ((address(KOTO).balance * 1e18) + ((capacity * price))) / supply;\\n        decision = burnRelative >= bondRelative ? false : true;\\n    }\\n\\n    ///@notice calculate the current decay per second required to sell all the bonds within the\\n    /// remaining amount of time.\\n    function _decay(Model memory model) private view returns (uint256) {\\n        uint256 delta = model.conclusion - block.timestamp;\\n        uint256 decay = model.price / delta;\\n        return decay;\\n    }\\n\\n    ///@notice calculate the new market price based off of the previous bond sell.\\n    function _marketPrice(Model memory model, uint256 sold) private pure returns (uint256) {\\n        uint256 price = FullMath.mulDiv(model.price, model.capacity, model.capacity - sold);\\n        return price;\\n    }\\n\\n    function _max(Model memory model) private view returns (uint256) {\\n        uint256 remaining = model.conclusion - block.timestamp;\\n        uint256 max = (model.capacity * model.interval) / remaining;\\n        return max;\\n    }\\n\\n    ///@notice calculate the current market price based on the reserves of the Uniswap Pair\\n    ///@dev price is returned as the amount of ETH you would get back for 1 full (1e18) Koto tokens\\n    function _getPrice() private view returns (uint256 price) {\\n        uint112 reserve0;\\n        uint112 reserve1;\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0x0902f1ac00000000000000000000000000000000000000000000000000000000)\\n            let success := staticcall(gas(), PAIR, ptr, 4, 0, 0)\\n            if iszero(success) { revert(0, 0) }\\n            returndatacopy(0x00, 0, 32)\\n            returndatacopy(0x20, 0x20, 32)\\n            reserve0 := mload(0x00)\\n            reserve1 := mload(0x20)\\n        }\\n\\n        if (zeroForOne) {\\n            price = FullMath.mulDiv(uint256(reserve1), 1e18, uint256(reserve0));\\n        } else {\\n            price = FullMath.mulDiv(uint256(reserve0), 1e18, uint256(reserve1));\\n        }\\n    }\\n\\n    ///@notice return the current price in koto for 1 LP token\\n    function _getLpPrice() private view returns (uint256 _lpPrice) {\\n        uint112 reserve0;\\n        uint112 reserve1;\\n        uint256 lpTotalSupply;\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0x0902f1ac00000000000000000000000000000000000000000000000000000000)\\n            let success := staticcall(gas(), PAIR, ptr, 4, 0, 0)\\n            if iszero(success) { revert(0, 0) }\\n            returndatacopy(0x00, 0, 32)\\n            returndatacopy(0x20, 0x20, 32)\\n            reserve0 := mload(0x00)\\n            reserve1 := mload(0x20)\\n            mstore(add(ptr, 0x20), 0x18160ddd00000000000000000000000000000000000000000000000000000000)\\n            let result := staticcall(gas(), PAIR, add(ptr, 0x20), 4, 0, 32)\\n            lpTotalSupply := mload(0x00)\\n        }\\n        ///@dev with uniswap v2 we simply treat the other token total as equal value to simplify the pricing mechanism\\n        if (zeroForOne) {\\n            _lpPrice = FullMath.mulDiv(reserve0 * 2, 1e18, lpTotalSupply);\\n        } else {\\n            _lpPrice = FullMath.mulDiv(reserve1 * 2, 1e18, lpTotalSupply);\\n        }\\n    }\\n\\n    // ====================================================== \\\\\\\\\\n    //                     ERROR AND EVENTS                   \\\\\\\\\\n    // ====================================================== \\\\\\\\\\n\\n    error OnlyDepository();\\n    error MarketClosed();\\n    error MaxPayout();\\n    error BondFailed();\\n    error BondsSoldOut();\\n    error OngoingMarket();\\n    error OnlyOwner();\\n    error BondOverflow();\\n\\n    event Bond(address indexed caller, uint256 payout, uint256 price);\\n    event CreateMarket(uint256 bonds, uint256 start, uint256 end);\\n\\n    receive() external payable {}\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IKotoV3.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.23;\\n\\nimport {PricingLibrary} from \\\"../PricingLibrary.sol\\\";\\n\\ninterface IKotoV3 {\\n    // ==================== EXTERNAL FUNCTIONS ===================== \\\\\\\\\\n\\n    function transfer(address _to, uint256 _value) external returns (bool success);\\n\\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\\n\\n    function approve(address _spender, uint256 _value) external returns (bool success);\\n\\n    ///@notice exchange ETH for Koto tokens at the current bonding price\\n    ///@dev bonds are set on 1 day intervals with 4 hour deposit intervals and 30 minute tune intervals.\\n    function bond() external payable returns (uint256 payout);\\n\\n    function bondLp(uint256 _lpAmount) external returns (uint256 payout);\\n\\n    ///@notice burn Koto tokens in exchange for a piece of the underlying reserves\\n    ///@param amount The amount of Koto tokens to redeem\\n    ///@return payout The amount of ETH received in exchange for the Koto tokens\\n    function redeem(uint256 amount) external returns (uint256 payout);\\n\\n    ///@notice burn Koto tokens, without redemption\\n    ///@param amount the amount of Koto to burn\\n    function burn(uint256 amount) external returns (bool success);\\n\\n    // ==================== EXTERNAL VIEW FUNCTIONS ===================== \\\\\\\\\\n\\n    ///@notice get the tokens name\\n    function name() external pure returns (string memory);\\n\\n    ///@notice get the tokens symbol\\n    function symbol() external pure returns (string memory);\\n\\n    ///@notice get the tokens decimals\\n    function decimals() external pure returns (uint8);\\n\\n    ///@notice get the tokens total supply\\n    function totalSupply() external view returns (uint256);\\n\\n    ///@notice get the current balance of a user\\n    ///@param _owner the user whos balance you want to check\\n    function balanceOf(address _owner) external view returns (uint256);\\n\\n    ///@notice get current approved amount for transfer from another party\\n    ///@param owner the current owner of the tokens\\n    ///@param spender the user who has approval (or not) to spend the owners tokens\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    ///@notice return the Uniswap V2 Pair address\\n    function pool() external view returns (address);\\n\\n    ///@notice get the owner of the contract\\n    ///@dev ownership is nontransferable and limited to opening trade, exclusion / inclusion,s and increasing liquidity\\n    function ownership() external pure returns (address);\\n\\n    ///@notice the current price a bond\\n    function bondPrice() external view returns (uint256);\\n\\n    function bondPriceLp() external view returns (uint256);\\n\\n    ///@notice return the current redemption price for 1 uint of Koto.\\n    function redemptionPrice() external view returns (uint256);\\n\\n    function marketInfo()\\n        external\\n        view\\n        returns (PricingLibrary.Market memory, PricingLibrary.Term memory, PricingLibrary.Data memory);\\n\\n    function lpMarketInfo()\\n        external\\n        view\\n        returns (PricingLibrary.Market memory, PricingLibrary.Term memory, PricingLibrary.Data memory);\\n\\n    function depository() external pure returns (address);\\n\\n    function create(uint256 ethBondAmount, uint256 lpBondAmount) external;\\n\\n    // ========================= EVENTS ========================= \\\\\\\\\\n\\n    event AmmAdded(address poolAdded);\\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\\n    event Bond(address indexed buyer, uint256 amount, uint256 bondPrice);\\n    event CreateMarket(uint256 bonds, uint256 start, uint48 end);\\n    event IncreaseLiquidity(uint256 kotoAdded, uint256 ethAdded);\\n    event Launched(uint256 time);\\n    event LimitsRemoved(uint256 time);\\n    event OpenBondMarket(uint256 openingTime);\\n    event Redeem(address indexed sender, uint256 burned, uint256 payout, uint256 floorPrice);\\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\\n    event UserExcluded(address indexed userToExclude);\\n\\n    // ========================= ERRORS ========================= \\\\\\\\\\n\\n    error AlreadyLaunched();\\n    error BondFailed();\\n    error InsufficentAllowance();\\n    error InsufficentBalance();\\n    error InsufficentBondsAvailable();\\n    error InvalidSender();\\n    error InvalidTransfer();\\n    error LimitsReached();\\n    error MarketClosed();\\n    error MaxPayout();\\n    error OngoingBonds();\\n    error OnlyOwner();\\n    error RedeemFailed();\\n    error Reentrancy();\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/utils/SafeTransferLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"../tokens/ERC20.sol\\\";\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\\nlibrary SafeTransferLib {\\n    /*//////////////////////////////////////////////////////////////\\n                             ETH OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Transfer the ETH and store if it succeeded or not.\\n            success := call(gas(), to, amount, 0, 0, 0, 0)\\n        }\\n\\n        require(success, \\\"ETH_TRANSFER_FAILED\\\");\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            ERC20 OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferFrom(\\n        ERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), and(from, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \\\"from\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \\\"amount\\\" argument. Masking not required as it's a full 32 byte type.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"TRANSFER_FROM_FAILED\\\");\\n    }\\n\\n    function safeTransfer(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument. Masking not required as it's a full 32 byte type.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"TRANSFER_FAILED\\\");\\n    }\\n\\n    function safeApprove(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument. Masking not required as it's a full 32 byte type.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"APPROVE_FAILED\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IERC20Minimal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.23;\\n\\ninterface IERC20Minimal {\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n    function transfer(address, uint256) external returns (bool);\\n    function balanceOf(address) external view returns (uint256);\\n    function totalSupply() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"src/libraries/FullMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @title Contains 512-bit math functions\\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\\n/// @dev Handles \\\"phantom overflow\\\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\\nlibrary FullMath {\\n    /// @notice Calculates floor(a\u00d7b\u00f7denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n    /// @param a The multiplicand\\n    /// @param b The multiplier\\n    /// @param denominator The divisor\\n    /// @return result The 256-bit result\\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\\n    function mulDiv(uint256 a, uint256 b, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = a * b\\n            // Compute the product mod 2**256 and mod 2**256 - 1\\n            // then use the Chinese Remainder Theorem to reconstruct\\n            // the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2**256 + prod0\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(a, b, not(0))\\n                prod0 := mul(a, b)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division\\n            if (prod1 == 0) {\\n                require(denominator > 0);\\n                assembly {\\n                    result := div(prod0, denominator)\\n                }\\n                return result;\\n            }\\n\\n            // Make sure the result is less than 2**256.\\n            // Also prevents denominator == 0\\n            require(denominator > prod1);\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0]\\n            // Compute remainder using mulmod\\n            uint256 remainder;\\n            assembly {\\n                remainder := mulmod(a, b, denominator)\\n            }\\n            // Subtract 256 bit number from 512 bit number\\n            assembly {\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator\\n            // Compute largest power of two divisor of denominator.\\n            // Always >= 1.\\n            uint256 twos = (0 - denominator) & denominator;\\n            // Divide denominator by power of two\\n            assembly {\\n                denominator := div(denominator, twos)\\n            }\\n\\n            // Divide [prod1 prod0] by the factors of two\\n            assembly {\\n                prod0 := div(prod0, twos)\\n            }\\n            // Shift in bits from prod1 into prod0. For this we need\\n            // to flip `twos` such that it is 2**256 / twos.\\n            // If twos is zero, then it becomes one\\n            assembly {\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2**256\\n            // Now that denominator is an odd number, it has an inverse\\n            // modulo 2**256 such that denominator * inv = 1 mod 2**256.\\n            // Compute the inverse by starting with a seed that is correct\\n            // correct for four bits. That is, denominator * inv = 1 mod 2**4\\n            uint256 inv = (3 * denominator) ^ 2;\\n            // Now use Newton-Raphson iteration to improve the precision.\\n            // Thanks to Hensel's lifting lemma, this also works in modular\\n            // arithmetic, doubling the correct bits in each step.\\n            inv *= 2 - denominator * inv; // inverse mod 2**8\\n            inv *= 2 - denominator * inv; // inverse mod 2**16\\n            inv *= 2 - denominator * inv; // inverse mod 2**32\\n            inv *= 2 - denominator * inv; // inverse mod 2**64\\n            inv *= 2 - denominator * inv; // inverse mod 2**128\\n            inv *= 2 - denominator * inv; // inverse mod 2**256\\n\\n            // Because the division is now exact we can divide by multiplying\\n            // with the modular inverse of denominator. This will give us the\\n            // correct result modulo 2**256. Since the precoditions guarantee\\n            // that the outcome is less than 2**256, this is the final result.\\n            // We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inv;\\n            return result;\\n        }\\n    }\\n\\n    /// @notice Calculates ceil(a\u00d7b\u00f7denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n    /// @param a The multiplicand\\n    /// @param b The multiplier\\n    /// @param denominator The divisor\\n    /// @return result The 256-bit result\\n    function mulDivRoundingUp(uint256 a, uint256 b, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            result = mulDiv(a, b, denominator);\\n            if (mulmod(a, b, denominator) > 0) {\\n                require(result < type(uint256).max);\\n                result++;\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/PricingLibrary.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.23;\\n\\nlibrary PricingLibrary {\\n    // 1 Slot\\n    struct Data {\\n        uint48 lastTune;\\n        uint48 lastDecay; // last timestamp when market was created and debt was decayed\\n        uint48 length; // time from creation to conclusion. used as speed to decay debt.\\n        uint48 depositInterval; // target frequency of deposits\\n        uint48 tuneInterval; // frequency of tuning\\n    }\\n\\n    // 2 Storage slots\\n    struct Market {\\n        uint96 capacity; // capacity remaining\\n        uint96 totalDebt; // total debt from market\\n        uint96 maxPayout; // max tokens in/out\\n        uint96 sold; // Koto out\\n        uint96 purchased; // Eth in\\n    }\\n\\n    // 1 Storage Slot\\n    struct Adjustment {\\n        uint128 change;\\n        uint48 lastAdjustment;\\n        uint48 timeToAdjusted;\\n        bool active;\\n    }\\n\\n    // 2 Storage slots\\n    struct Term {\\n        uint48 conclusion; // timestamp when the current market will end\\n        uint256 controlVariable; // scaling variable for price\\n    }\\n\\n    function decay(Data memory data, Market memory market, Term memory terms, Adjustment memory adjustments)\\n        internal\\n        view\\n        returns (Market memory, Data memory, Term memory, Adjustment memory)\\n    {\\n        uint48 time = uint48(block.timestamp);\\n        market.totalDebt -= debtDecay(data, market);\\n        data.lastDecay = time;\\n\\n        if (adjustments.active) {\\n            (uint128 adjustby, uint48 dt, bool stillActive) = controlDecay(adjustments);\\n            terms.controlVariable -= adjustby;\\n            if (stillActive) {\\n                adjustments.change -= adjustby;\\n                adjustments.timeToAdjusted -= dt;\\n                adjustments.lastAdjustment = time;\\n            } else {\\n                adjustments.active = false;\\n            }\\n        }\\n        return (market, data, terms, adjustments);\\n    }\\n\\n    function controlDecay(Adjustment memory info) internal view returns (uint128, uint48, bool) {\\n        if (!info.active) return (0, 0, false);\\n\\n        uint48 secondsSince = uint48(block.timestamp) - info.lastAdjustment;\\n        bool active = secondsSince < info.timeToAdjusted;\\n        uint128 _decay = active ? (info.change * secondsSince) / info.timeToAdjusted : info.change;\\n        return (_decay, secondsSince, active);\\n    }\\n\\n    function marketPrice(uint256 _controlVariable, uint256 _totalDebt, uint256 _totalSupply)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return ((_controlVariable * debtRatio(_totalDebt, _totalSupply)) / 1e18);\\n    }\\n\\n    function debtRatio(uint256 _totalDebt, uint256 _totalSupply) internal pure returns (uint256) {\\n        return ((_totalDebt * 1e18) / _totalSupply);\\n    }\\n\\n    function debtDecay(Data memory data, Market memory market) internal view returns (uint64) {\\n        uint256 secondsSince = block.timestamp - data.lastDecay;\\n        return uint64((market.totalDebt * secondsSince) / data.length);\\n    }\\n\\n    struct TuneCache {\\n        uint256 remaining;\\n        uint256 price;\\n        uint256 capacity;\\n        uint256 targetDebt;\\n        uint256 ncv;\\n    }\\n\\n    function tune(\\n        uint48 time,\\n        Market memory market,\\n        Term memory term,\\n        Data memory data,\\n        Adjustment memory adjustment,\\n        uint256 _totalSupply\\n    ) internal pure returns (Market memory, Term memory, Data memory, Adjustment memory) {\\n        TuneCache memory cache;\\n        if (time >= data.lastTune + data.tuneInterval) {\\n            cache.remaining = term.conclusion - time;\\n            cache.price = marketPrice(term.controlVariable, market.totalDebt, _totalSupply);\\n            cache.capacity = market.capacity;\\n            market.maxPayout = uint96((cache.capacity * data.depositInterval / cache.remaining));\\n            cache.targetDebt = cache.capacity * data.length / cache.remaining;\\n            cache.ncv = (cache.price * _totalSupply) / cache.targetDebt;\\n\\n            if (cache.ncv < term.controlVariable) {\\n                uint128 change = uint128(term.controlVariable - cache.ncv);\\n                adjustment = Adjustment(change, time, data.tuneInterval, true);\\n            } else {\\n                term.controlVariable = cache.ncv;\\n            }\\n            data.lastTune = time;\\n        }\\n        return (market, term, data, adjustment);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/tokens/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\\nabstract contract ERC20 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    uint8 public immutable decimals;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            EIP-2612 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\n\\n    mapping(address => uint256) public nonces;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n\\n        INITIAL_CHAIN_ID = block.chainid;\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        balanceOf[msg.sender] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\n\\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\\n\\n        balanceOf[from] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             EIP-2612 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        require(deadline >= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\n\\n        // Unchecked because the only math done is incrementing\\n        // the owner's nonce which cannot realistically overflow.\\n        unchecked {\\n            address recoveredAddress = ecrecover(\\n                keccak256(\\n                    abi.encodePacked(\\n                        \\\"\\\\x19\\\\x01\\\",\\n                        DOMAIN_SEPARATOR(),\\n                        keccak256(\\n                            abi.encode(\\n                                keccak256(\\n                                    \\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\"\\n                                ),\\n                                owner,\\n                                spender,\\n                                value,\\n                                nonces[owner]++,\\n                                deadline\\n                            )\\n                        )\\n                    )\\n                ),\\n                v,\\n                r,\\n                s\\n            );\\n\\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"INVALID_SIGNER\\\");\\n\\n            allowance[recoveredAddress][spender] = value;\\n        }\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\n    }\\n\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                    keccak256(bytes(name)),\\n                    keccak256(\\\"1\\\"),\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        totalSupply += amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        balanceOf[from] -= amount;\\n\\n        // Cannot underflow because a user's balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply -= amount;\\n        }\\n\\n        emit Transfer(from, address(0), amount);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"solmate/=lib/solmate/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"shanghai\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"BondFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BondOverflow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BondsSoldOut\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MarketClosed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MaxPayout\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OngoingMarket\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyDepository\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyOwner\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"payout\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"Bond\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bonds\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"}],\"name\":\"CreateMarket\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BOND_DEPOSITORY\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"INTERVAL\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"KOTO\",\"outputs\":[{\"internalType\":\"contract IKotoV3\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LENGTH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"OWNER\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PAIR\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"addReserves\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bond\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"bondLp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ethBonds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lpBonds\",\"type\":\"uint256\"}],\"name\":\"create\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ethModel\",\"outputs\":[{\"internalType\":\"uint48\",\"name\":\"interval\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"last\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"conclusion\",\"type\":\"uint48\"},{\"internalType\":\"uint96\",\"name\":\"theta\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"price\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"capacity\",\"type\":\"uint96\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ethPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lpModel\",\"outputs\":[{\"internalType\":\"uint48\",\"name\":\"interval\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"last\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"conclusion\",\"type\":\"uint48\"},{\"internalType\":\"uint96\",\"name\":\"theta\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"price\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"capacity\",\"type\":\"uint96\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lpPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"market\",\"outputs\":[{\"components\":[{\"internalType\":\"uint48\",\"name\":\"interval\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"last\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"conclusion\",\"type\":\"uint48\"},{\"internalType\":\"uint96\",\"name\":\"theta\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"price\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"capacity\",\"type\":\"uint96\"}],\"internalType\":\"struct PricingV1.Model\",\"name\":\"\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint48\",\"name\":\"interval\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"last\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"conclusion\",\"type\":\"uint48\"},{\"internalType\":\"uint96\",\"name\":\"theta\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"price\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"capacity\",\"type\":\"uint96\"}],\"internalType\":\"struct PricingV1.Model\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"notifyRewardAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "PricingV1", "CompilerVersion": "v0.8.23+commit.f704f362", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "shanghai", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://4451dce76e16dffb8841aa733a98ff4b369d09ff83cda5eea288425f60c1c495"}