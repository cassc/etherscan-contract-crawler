{"SourceCode": "/**\r\n *Submitted for verification at Etherscan.io on 2023-02-25\r\n*/\r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\n\r\nlibrary Bytecode {\r\n  error InvalidCodeAtRange(uint256 _size, uint256 _start, uint256 _end);\r\n\r\n  /**\r\n    @notice Generate a creation code that results on a contract with `_code` as bytecode\r\n    @param _code The returning value of the resulting `creationCode`\r\n    @return creationCode (constructor) for new contract\r\n  */\r\n  function creationCodeFor(bytes memory _code) internal pure returns (bytes memory) {\r\n    /*\r\n      0x00    0x63         0x63XXXXXX  PUSH4 _code.length  size\r\n      0x01    0x80         0x80        DUP1                size size\r\n      0x02    0x60         0x600e      PUSH1 14            14 size size\r\n      0x03    0x60         0x6000      PUSH1 00            0 14 size size\r\n      0x04    0x39         0x39        CODECOPY            size\r\n      0x05    0x60         0x6000      PUSH1 00            0 size\r\n      0x06    0xf3         0xf3        RETURN\r\n      <CODE>\r\n    */\r\n\r\n    return abi.encodePacked(\r\n      hex\"63\",\r\n      uint32(_code.length),\r\n      hex\"80_60_0E_60_00_39_60_00_F3\",\r\n      _code\r\n    );\r\n  }\r\n\r\n  /**\r\n    @notice Returns the size of the code on a given address\r\n    @param _addr Address that may or may not contain code\r\n    @return size of the code on the given `_addr`\r\n  */\r\n  function codeSize(address _addr) internal view returns (uint256 size) {\r\n    assembly { size := extcodesize(_addr) }\r\n  }\r\n\r\n  /**\r\n    @notice Returns the code of a given address\r\n    @dev It will fail if `_end < _start`\r\n    @param _addr Address that may or may not contain code\r\n    @param _start number of bytes of code to skip on read\r\n    @param _end index before which to end extraction\r\n    @return oCode read from `_addr` deployed bytecode\r\n\r\n    Forked from: https://gist.github.com/KardanovIR/fe98661df9338c842b4a30306d507fbd\r\n  */\r\n  function codeAt(address _addr, uint256 _start, uint256 _end) internal view returns (bytes memory oCode) {\r\n    uint256 csize = codeSize(_addr);\r\n    if (csize == 0) return bytes(\"\");\r\n\r\n    if (_start > csize) return bytes(\"\");\r\n    if (_end < _start) revert InvalidCodeAtRange(csize, _start, _end); \r\n\r\n    unchecked {\r\n      uint256 reqSize = _end - _start;\r\n      uint256 maxSize = csize - _start;\r\n\r\n      uint256 size = maxSize < reqSize ? maxSize : reqSize;\r\n\r\n      assembly {\r\n        // allocate output byte array - this could also be done without assembly\r\n        // by using o_code = new bytes(size)\r\n        oCode := mload(0x40)\r\n        // new \"memory end\" including padding\r\n        mstore(0x40, add(oCode, and(add(add(size, 0x20), 0x1f), not(0x1f))))\r\n        // store length in memory\r\n        mstore(oCode, size)\r\n        // actually retrieve the code, this needs assembly\r\n        extcodecopy(_addr, add(oCode, 0x20), _start, size)\r\n      }\r\n    }\r\n  }\r\n}\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n  @title A key-value storage with auto-generated keys for storing chunks of data with a lower write & read cost.\r\n  @author Agustin Aguilar <aa@horizon.io>\r\n  Readme: https://github.com/0xsequence/sstore2#readme\r\n*/\r\nlibrary SSTORE2 {\r\n  error WriteError();\r\n\r\n  /**\r\n    @notice Stores `_data` and returns `pointer` as key for later retrieval\r\n    @dev The pointer is a contract address with `_data` as code\r\n    @param _data to be written\r\n    @return pointer Pointer to the written `_data`\r\n  */\r\n  function write(bytes memory _data) internal returns (address pointer) {\r\n    // Append 00 to _data so contract can't be called\r\n    // Build init code\r\n    bytes memory code = Bytecode.creationCodeFor(\r\n      abi.encodePacked(\r\n        hex'00',\r\n        _data\r\n      )\r\n    );\r\n\r\n    // Deploy contract using create\r\n    assembly { pointer := create(0, add(code, 32), mload(code)) }\r\n\r\n    // Address MUST be non-zero\r\n    if (pointer == address(0)) revert WriteError();\r\n  }\r\n\r\n  /**\r\n    @notice Reads the contents of the `_pointer` code as data, skips the first byte \r\n    @dev The function is intended for reading pointers generated by `write`\r\n    @param _pointer to be read\r\n    @return data read from `_pointer` contract\r\n  */\r\n  function read(address _pointer) internal view returns (bytes memory) {\r\n    return Bytecode.codeAt(_pointer, 1, type(uint256).max);\r\n  }\r\n\r\n  /**\r\n    @notice Reads the contents of the `_pointer` code as data, skips the first byte \r\n    @dev The function is intended for reading pointers generated by `write`\r\n    @param _pointer to be read\r\n    @param _start number of bytes to skip\r\n    @return data read from `_pointer` contract\r\n  */\r\n  function read(address _pointer, uint256 _start) internal view returns (bytes memory) {\r\n    return Bytecode.codeAt(_pointer, _start + 1, type(uint256).max);\r\n  }\r\n\r\n  /**\r\n    @notice Reads the contents of the `_pointer` code as data, skips the first byte \r\n    @dev The function is intended for reading pointers generated by `write`\r\n    @param _pointer to be read\r\n    @param _start number of bytes to skip\r\n    @param _end index before which to end extraction\r\n    @return data read from `_pointer` contract\r\n  */\r\n  function read(address _pointer, uint256 _start, uint256 _end) internal view returns (bytes memory) {\r\n    return Bytecode.codeAt(_pointer, _start + 1, _end + 1);\r\n  }\r\n}\r\n\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\n\r\nlibrary BytesLib {\r\n    function concat(\r\n        bytes memory _preBytes,\r\n        bytes memory _postBytes\r\n    )\r\n        internal\r\n        pure\r\n        returns (bytes memory)\r\n    {\r\n        bytes memory tempBytes;\r\n\r\n        assembly {\r\n            // Get a location of some free memory and store it in tempBytes as\r\n            // Solidity does for memory variables.\r\n            tempBytes := mload(0x40)\r\n\r\n            // Store the length of the first bytes array at the beginning of\r\n            // the memory for tempBytes.\r\n            let length := mload(_preBytes)\r\n            mstore(tempBytes, length)\r\n\r\n            // Maintain a memory counter for the current write location in the\r\n            // temp bytes array by adding the 32 bytes for the array length to\r\n            // the starting location.\r\n            let mc := add(tempBytes, 0x20)\r\n            // Stop copying when the memory counter reaches the length of the\r\n            // first bytes array.\r\n            let end := add(mc, length)\r\n\r\n            for {\r\n                // Initialize a copy counter to the start of the _preBytes data,\r\n                // 32 bytes into its memory.\r\n                let cc := add(_preBytes, 0x20)\r\n            } lt(mc, end) {\r\n                // Increase both counters by 32 bytes each iteration.\r\n                mc := add(mc, 0x20)\r\n                cc := add(cc, 0x20)\r\n            } {\r\n                // Write the _preBytes data into the tempBytes memory 32 bytes\r\n                // at a time.\r\n                mstore(mc, mload(cc))\r\n            }\r\n\r\n            // Add the length of _postBytes to the current length of tempBytes\r\n            // and store it as the new length in the first 32 bytes of the\r\n            // tempBytes memory.\r\n            length := mload(_postBytes)\r\n            mstore(tempBytes, add(length, mload(tempBytes)))\r\n\r\n            // Move the memory counter back from a multiple of 0x20 to the\r\n            // actual end of the _preBytes data.\r\n            mc := end\r\n            // Stop copying when the memory counter reaches the new combined\r\n            // length of the arrays.\r\n            end := add(mc, length)\r\n\r\n            for {\r\n                let cc := add(_postBytes, 0x20)\r\n            } lt(mc, end) {\r\n                mc := add(mc, 0x20)\r\n                cc := add(cc, 0x20)\r\n            } {\r\n                mstore(mc, mload(cc))\r\n            }\r\n\r\n            // Update the free-memory pointer by padding our last write location\r\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\r\n            // next 32 byte block, then round down to the nearest multiple of\r\n            // 32. If the sum of the length of the two arrays is zero then add\r\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\r\n            mstore(0x40, and(\r\n              add(add(end, iszero(add(length, mload(_preBytes)))), 31),\r\n              not(31) // Round down to the nearest 32 bytes.\r\n            ))\r\n        }\r\n\r\n        return tempBytes;\r\n    }\r\n\r\n    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\r\n        assembly {\r\n            // Read the first 32 bytes of _preBytes storage, which is the length\r\n            // of the array. (We don't need to use the offset into the slot\r\n            // because arrays use the entire slot.)\r\n            let fslot := sload(_preBytes.slot)\r\n            // Arrays of 31 bytes or less have an even value in their slot,\r\n            // while longer arrays have an odd value. The actual length is\r\n            // the slot divided by two for odd values, and the lowest order\r\n            // byte divided by two for even values.\r\n            // If the slot is even, bitwise and the slot with 255 and divide by\r\n            // two to get the length. If the slot is odd, bitwise and the slot\r\n            // with -1 and divide by two.\r\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\r\n            let mlength := mload(_postBytes)\r\n            let newlength := add(slength, mlength)\r\n            // slength can contain both the length and contents of the array\r\n            // if length < 32 bytes so let's prepare for that\r\n            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\r\n            switch add(lt(slength, 32), lt(newlength, 32))\r\n            case 2 {\r\n                // Since the new array still fits in the slot, we just need to\r\n                // update the contents of the slot.\r\n                // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\r\n                sstore(\r\n                    _preBytes.slot,\r\n                    // all the modifications to the slot are inside this\r\n                    // next block\r\n                    add(\r\n                        // we can just add to the slot contents because the\r\n                        // bytes we want to change are the LSBs\r\n                        fslot,\r\n                        add(\r\n                            mul(\r\n                                div(\r\n                                    // load the bytes from memory\r\n                                    mload(add(_postBytes, 0x20)),\r\n                                    // zero all bytes to the right\r\n                                    exp(0x100, sub(32, mlength))\r\n                                ),\r\n                                // and now shift left the number of bytes to\r\n                                // leave space for the length in the slot\r\n                                exp(0x100, sub(32, newlength))\r\n                            ),\r\n                            // increase length by the double of the memory\r\n                            // bytes length\r\n                            mul(mlength, 2)\r\n                        )\r\n                    )\r\n                )\r\n            }\r\n            case 1 {\r\n                // The stored value fits in the slot, but the combined value\r\n                // will exceed it.\r\n                // get the keccak hash to get the contents of the array\r\n                mstore(0x0, _preBytes.slot)\r\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\r\n\r\n                // save new length\r\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\r\n\r\n                // The contents of the _postBytes array start 32 bytes into\r\n                // the structure. Our first read should obtain the `submod`\r\n                // bytes that can fit into the unused space in the last word\r\n                // of the stored array. To get this, we read 32 bytes starting\r\n                // from `submod`, so the data we read overlaps with the array\r\n                // contents by `submod` bytes. Masking the lowest-order\r\n                // `submod` bytes allows us to add that value directly to the\r\n                // stored value.\r\n\r\n                let submod := sub(32, slength)\r\n                let mc := add(_postBytes, submod)\r\n                let end := add(_postBytes, mlength)\r\n                let mask := sub(exp(0x100, submod), 1)\r\n\r\n                sstore(\r\n                    sc,\r\n                    add(\r\n                        and(\r\n                            fslot,\r\n                            0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\r\n                        ),\r\n                        and(mload(mc), mask)\r\n                    )\r\n                )\r\n\r\n                for {\r\n                    mc := add(mc, 0x20)\r\n                    sc := add(sc, 1)\r\n                } lt(mc, end) {\r\n                    sc := add(sc, 1)\r\n                    mc := add(mc, 0x20)\r\n                } {\r\n                    sstore(sc, mload(mc))\r\n                }\r\n\r\n                mask := exp(0x100, sub(mc, end))\r\n\r\n                sstore(sc, mul(div(mload(mc), mask), mask))\r\n            }\r\n            default {\r\n                // get the keccak hash to get the contents of the array\r\n                mstore(0x0, _preBytes.slot)\r\n                // Start copying to the last used word of the stored array.\r\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\r\n\r\n                // save new length\r\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\r\n\r\n                // Copy over the first `submod` bytes of the new data as in\r\n                // case 1 above.\r\n                let slengthmod := mod(slength, 32)\r\n                let mlengthmod := mod(mlength, 32)\r\n                let submod := sub(32, slengthmod)\r\n                let mc := add(_postBytes, submod)\r\n                let end := add(_postBytes, mlength)\r\n                let mask := sub(exp(0x100, submod), 1)\r\n\r\n                sstore(sc, add(sload(sc), and(mload(mc), mask)))\r\n\r\n                for {\r\n                    sc := add(sc, 1)\r\n                    mc := add(mc, 0x20)\r\n                } lt(mc, end) {\r\n                    sc := add(sc, 1)\r\n                    mc := add(mc, 0x20)\r\n                } {\r\n                    sstore(sc, mload(mc))\r\n                }\r\n\r\n                mask := exp(0x100, sub(mc, end))\r\n\r\n                sstore(sc, mul(div(mload(mc), mask), mask))\r\n            }\r\n        }\r\n    }\r\n\r\n    function slice(\r\n        bytes memory _bytes,\r\n        uint256 _start,\r\n        uint256 _length\r\n    )\r\n        internal\r\n        pure\r\n        returns (bytes memory)\r\n    {\r\n        require(_length + 31 >= _length, \"slice_overflow\");\r\n        require(_bytes.length >= _start + _length, \"slice_outOfBounds\");\r\n\r\n        bytes memory tempBytes;\r\n\r\n        assembly {\r\n            switch iszero(_length)\r\n            case 0 {\r\n                // Get a location of some free memory and store it in tempBytes as\r\n                // Solidity does for memory variables.\r\n                tempBytes := mload(0x40)\r\n\r\n                // The first word of the slice result is potentially a partial\r\n                // word read from the original array. To read it, we calculate\r\n                // the length of that partial word and start copying that many\r\n                // bytes into the array. The first word we copy will start with\r\n                // data we don't care about, but the last `lengthmod` bytes will\r\n                // land at the beginning of the contents of the new array. When\r\n                // we're done copying, we overwrite the full first word with\r\n                // the actual length of the slice.\r\n                let lengthmod := and(_length, 31)\r\n\r\n                // The multiplication in the next line is necessary\r\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\r\n                // the following copy loop was copying the origin's length\r\n                // and then ending prematurely not copying everything it should.\r\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\r\n                let end := add(mc, _length)\r\n\r\n                for {\r\n                    // The multiplication in the next line has the same exact purpose\r\n                    // as the one above.\r\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\r\n                } lt(mc, end) {\r\n                    mc := add(mc, 0x20)\r\n                    cc := add(cc, 0x20)\r\n                } {\r\n                    mstore(mc, mload(cc))\r\n                }\r\n\r\n                mstore(tempBytes, _length)\r\n\r\n                //update free-memory pointer\r\n                //allocating the array padded to 32 bytes like the compiler does now\r\n                mstore(0x40, and(add(mc, 31), not(31)))\r\n            }\r\n            //if we want a zero-length slice let's just return a zero-length array\r\n            default {\r\n                tempBytes := mload(0x40)\r\n                //zero out the 32 bytes slice we are about to return\r\n                //we need to do it because Solidity does not garbage collect\r\n                mstore(tempBytes, 0)\r\n\r\n                mstore(0x40, add(tempBytes, 0x20))\r\n            }\r\n        }\r\n\r\n        return tempBytes;\r\n    }\r\n\r\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\r\n        require(_bytes.length >= _start + 20, \"toAddress_outOfBounds\");\r\n        address tempAddress;\r\n\r\n        assembly {\r\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\r\n        }\r\n\r\n        return tempAddress;\r\n    }\r\n\r\n    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {\r\n        require(_bytes.length >= _start + 1 , \"toUint8_outOfBounds\");\r\n        uint8 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x1), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n\r\n    function toUint16(bytes memory _bytes, uint256 _start) internal pure returns (uint16) {\r\n        require(_bytes.length >= _start + 2, \"toUint16_outOfBounds\");\r\n        uint16 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x2), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n\r\n    function toUint32(bytes memory _bytes, uint256 _start) internal pure returns (uint32) {\r\n        require(_bytes.length >= _start + 4, \"toUint32_outOfBounds\");\r\n        uint32 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x4), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n\r\n    function toUint64(bytes memory _bytes, uint256 _start) internal pure returns (uint64) {\r\n        require(_bytes.length >= _start + 8, \"toUint64_outOfBounds\");\r\n        uint64 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x8), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n\r\n    function toUint96(bytes memory _bytes, uint256 _start) internal pure returns (uint96) {\r\n        require(_bytes.length >= _start + 12, \"toUint96_outOfBounds\");\r\n        uint96 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0xc), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n\r\n    function toUint128(bytes memory _bytes, uint256 _start) internal pure returns (uint128) {\r\n        require(_bytes.length >= _start + 16, \"toUint128_outOfBounds\");\r\n        uint128 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x10), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n\r\n    function toUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {\r\n        require(_bytes.length >= _start + 32, \"toUint256_outOfBounds\");\r\n        uint256 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x20), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n\r\n    function toBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32) {\r\n        require(_bytes.length >= _start + 32, \"toBytes32_outOfBounds\");\r\n        bytes32 tempBytes32;\r\n\r\n        assembly {\r\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\r\n        }\r\n\r\n        return tempBytes32;\r\n    }\r\n\r\n    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\r\n        bool success = true;\r\n\r\n        assembly {\r\n            let length := mload(_preBytes)\r\n\r\n            // if lengths don't match the arrays are not equal\r\n            switch eq(length, mload(_postBytes))\r\n            case 1 {\r\n                // cb is a circuit breaker in the for loop since there's\r\n                //  no said feature for inline assembly loops\r\n                // cb = 1 - don't breaker\r\n                // cb = 0 - break\r\n                let cb := 1\r\n\r\n                let mc := add(_preBytes, 0x20)\r\n                let end := add(mc, length)\r\n\r\n                for {\r\n                    let cc := add(_postBytes, 0x20)\r\n                // the next line is the loop condition:\r\n                // while(uint256(mc < end) + cb == 2)\r\n                } eq(add(lt(mc, end), cb), 2) {\r\n                    mc := add(mc, 0x20)\r\n                    cc := add(cc, 0x20)\r\n                } {\r\n                    // if any of these checks fails then arrays are not equal\r\n                    if iszero(eq(mload(mc), mload(cc))) {\r\n                        // unsuccess:\r\n                        success := 0\r\n                        cb := 0\r\n                    }\r\n                }\r\n            }\r\n            default {\r\n                // unsuccess:\r\n                success := 0\r\n            }\r\n        }\r\n\r\n        return success;\r\n    }\r\n\r\n    function equalStorage(\r\n        bytes storage _preBytes,\r\n        bytes memory _postBytes\r\n    )\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        bool success = true;\r\n\r\n        assembly {\r\n            // we know _preBytes_offset is 0\r\n            let fslot := sload(_preBytes.slot)\r\n            // Decode the length of the stored array like in concatStorage().\r\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\r\n            let mlength := mload(_postBytes)\r\n\r\n            // if lengths don't match the arrays are not equal\r\n            switch eq(slength, mlength)\r\n            case 1 {\r\n                // slength can contain both the length and contents of the array\r\n                // if length < 32 bytes so let's prepare for that\r\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\r\n                if iszero(iszero(slength)) {\r\n                    switch lt(slength, 32)\r\n                    case 1 {\r\n                        // blank the last byte which is the length\r\n                        fslot := mul(div(fslot, 0x100), 0x100)\r\n\r\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\r\n                            // unsuccess:\r\n                            success := 0\r\n                        }\r\n                    }\r\n                    default {\r\n                        // cb is a circuit breaker in the for loop since there's\r\n                        //  no said feature for inline assembly loops\r\n                        // cb = 1 - don't breaker\r\n                        // cb = 0 - break\r\n                        let cb := 1\r\n\r\n                        // get the keccak hash to get the contents of the array\r\n                        mstore(0x0, _preBytes.slot)\r\n                        let sc := keccak256(0x0, 0x20)\r\n\r\n                        let mc := add(_postBytes, 0x20)\r\n                        let end := add(mc, mlength)\r\n\r\n                        // the next line is the loop condition:\r\n                        // while(uint256(mc < end) + cb == 2)\r\n                        for {} eq(add(lt(mc, end), cb), 2) {\r\n                            sc := add(sc, 1)\r\n                            mc := add(mc, 0x20)\r\n                        } {\r\n                            if iszero(eq(sload(sc), mload(mc))) {\r\n                                // unsuccess:\r\n                                success := 0\r\n                                cb := 0\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            default {\r\n                // unsuccess:\r\n                success := 0\r\n            }\r\n        }\r\n\r\n        return success;\r\n    }\r\n}\r\n\r\n\r\n\r\n/**\r\n *Submitted for verification at Etherscan.io on 2023-02-17\r\n*/\r\n\r\n// File: @openzeppelin/contracts/utils/structs/EnumerableSet.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/structs/EnumerableSet.sol)\r\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Library for managing\r\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\r\n * types.\r\n *\r\n * Sets have the following properties:\r\n *\r\n * - Elements are added, removed, and checked for existence in constant time\r\n * (O(1)).\r\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\r\n *\r\n * ```\r\n * contract Example {\r\n *     // Add the library methods\r\n *     using EnumerableSet for EnumerableSet.AddressSet;\r\n *\r\n *     // Declare a set state variable\r\n *     EnumerableSet.AddressSet private mySet;\r\n * }\r\n * ```\r\n *\r\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\r\n * and `uint256` (`UintSet`) are supported.\r\n *\r\n * [WARNING]\r\n * ====\r\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\r\n * unusable.\r\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\r\n *\r\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\r\n * array of EnumerableSet.\r\n * ====\r\n */\r\nlibrary EnumerableSet {\r\n    // To implement this library for multiple types with as little code\r\n    // repetition as possible, we write it in terms of a generic Set type with\r\n    // bytes32 values.\r\n    // The Set implementation uses private functions, and user-facing\r\n    // implementations (such as AddressSet) are just wrappers around the\r\n    // underlying Set.\r\n    // This means that we can only create new EnumerableSets for types that fit\r\n    // in bytes32.\r\n\r\n    struct Set {\r\n        // Storage of set values\r\n        bytes32[] _values;\r\n        // Position of the value in the `values` array, plus 1 because index 0\r\n        // means a value is not in the set.\r\n        mapping(bytes32 => uint256) _indexes;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function _add(Set storage set, bytes32 value) private returns (bool) {\r\n        if (!_contains(set, value)) {\r\n            set._values.push(value);\r\n            // The value is stored at length-1, but we add 1 to all indexes\r\n            // and use 0 as a sentinel value\r\n            set._indexes[value] = set._values.length;\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\r\n        // We read and store the value's index to prevent multiple reads from the same storage slot\r\n        uint256 valueIndex = set._indexes[value];\r\n\r\n        if (valueIndex != 0) {\r\n            // Equivalent to contains(set, value)\r\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\r\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\r\n            // This modifies the order of the array, as noted in {at}.\r\n\r\n            uint256 toDeleteIndex = valueIndex - 1;\r\n            uint256 lastIndex = set._values.length - 1;\r\n\r\n            if (lastIndex != toDeleteIndex) {\r\n                bytes32 lastValue = set._values[lastIndex];\r\n\r\n                // Move the last value to the index where the value to delete is\r\n                set._values[toDeleteIndex] = lastValue;\r\n                // Update the index for the moved value\r\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\r\n            }\r\n\r\n            // Delete the slot where the moved value was stored\r\n            set._values.pop();\r\n\r\n            // Delete the index for the deleted slot\r\n            delete set._indexes[value];\r\n\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\r\n        return set._indexes[value] != 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values on the set. O(1).\r\n     */\r\n    function _length(Set storage set) private view returns (uint256) {\r\n        return set._values.length;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value stored at position `index` in the set. O(1).\r\n     *\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\r\n        return set._values[index];\r\n    }\r\n\r\n    /**\r\n     * @dev Return the entire set in an array\r\n     *\r\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\r\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\r\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\r\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\r\n     */\r\n    function _values(Set storage set) private view returns (bytes32[] memory) {\r\n        return set._values;\r\n    }\r\n\r\n    // Bytes32Set\r\n\r\n    struct Bytes32Set {\r\n        Set _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\r\n        return _add(set._inner, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\r\n        return _remove(set._inner, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\r\n        return _contains(set._inner, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values in the set. O(1).\r\n     */\r\n    function length(Bytes32Set storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value stored at position `index` in the set. O(1).\r\n     *\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\r\n        return _at(set._inner, index);\r\n    }\r\n\r\n    /**\r\n     * @dev Return the entire set in an array\r\n     *\r\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\r\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\r\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\r\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\r\n     */\r\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\r\n        bytes32[] memory store = _values(set._inner);\r\n        bytes32[] memory result;\r\n\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            result := store\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    // AddressSet\r\n\r\n    struct AddressSet {\r\n        Set _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function add(AddressSet storage set, address value) internal returns (bool) {\r\n        return _add(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(AddressSet storage set, address value) internal returns (bool) {\r\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\r\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values in the set. O(1).\r\n     */\r\n    function length(AddressSet storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value stored at position `index` in the set. O(1).\r\n     *\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\r\n        return address(uint160(uint256(_at(set._inner, index))));\r\n    }\r\n\r\n    /**\r\n     * @dev Return the entire set in an array\r\n     *\r\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\r\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\r\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\r\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\r\n     */\r\n    function values(AddressSet storage set) internal view returns (address[] memory) {\r\n        bytes32[] memory store = _values(set._inner);\r\n        address[] memory result;\r\n\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            result := store\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    // UintSet\r\n\r\n    struct UintSet {\r\n        Set _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\r\n        return _add(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\r\n        return _remove(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\r\n        return _contains(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values in the set. O(1).\r\n     */\r\n    function length(UintSet storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value stored at position `index` in the set. O(1).\r\n     *\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\r\n        return uint256(_at(set._inner, index));\r\n    }\r\n\r\n    /**\r\n     * @dev Return the entire set in an array\r\n     *\r\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\r\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\r\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\r\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\r\n     */\r\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\r\n        bytes32[] memory store = _values(set._inner);\r\n        uint256[] memory result;\r\n\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            result := store\r\n        }\r\n\r\n        return result;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/StorageSlot.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/StorageSlot.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Library for reading and writing primitive types to specific storage slots.\r\n *\r\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\r\n * This library helps with reading and writing to such slots without the need for inline assembly.\r\n *\r\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\r\n *\r\n * Example usage to set ERC1967 implementation slot:\r\n * ```\r\n * contract ERC1967 {\r\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\r\n *\r\n *     function _getImplementation() internal view returns (address) {\r\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\r\n *     }\r\n *\r\n *     function _setImplementation(address newImplementation) internal {\r\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\r\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\r\n *     }\r\n * }\r\n * ```\r\n *\r\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\r\n */\r\nlibrary StorageSlot {\r\n    struct AddressSlot {\r\n        address value;\r\n    }\r\n\r\n    struct BooleanSlot {\r\n        bool value;\r\n    }\r\n\r\n    struct Bytes32Slot {\r\n        bytes32 value;\r\n    }\r\n\r\n    struct Uint256Slot {\r\n        uint256 value;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\r\n     */\r\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            r.slot := slot\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\r\n     */\r\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            r.slot := slot\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\r\n     */\r\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            r.slot := slot\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\r\n     */\r\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            r.slot := slot\r\n        }\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/Address.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\r\n\r\npragma solidity ^0.8.1;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\r\n     *\r\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\r\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\r\n     * constructor.\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize/address.code.length, which returns 0\r\n        // for contracts in construction, since the code is only stored at the end\r\n        // of the constructor execution.\r\n\r\n        return account.code.length > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain `call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\r\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\r\n     *\r\n     * _Available since v4.8._\r\n     */\r\n    function verifyCallResultFromTarget(\r\n        address target,\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        if (success) {\r\n            if (returndata.length == 0) {\r\n                // only check isContract if the call was successful and the return data is empty\r\n                // otherwise we already know that it was a contract\r\n                require(isContract(target), \"Address: call to non-contract\");\r\n            }\r\n            return returndata;\r\n        } else {\r\n            _revert(returndata, errorMessage);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\r\n     * revert reason or using the provided one.\r\n     *\r\n     * _Available since v4.3._\r\n     */\r\n    function verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            _revert(returndata, errorMessage);\r\n        }\r\n    }\r\n\r\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\r\n        // Look for revert reason and bubble it up if present\r\n        if (returndata.length > 0) {\r\n            // The easiest way to bubble the revert reason is using memory via assembly\r\n            /// @solidity memory-safe-assembly\r\n            assembly {\r\n                let returndata_size := mload(returndata)\r\n                revert(add(32, returndata), returndata_size)\r\n            }\r\n        } else {\r\n            revert(errorMessage);\r\n        }\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/math/Math.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Standard math utilities missing in the Solidity language.\r\n */\r\nlibrary Math {\r\n    enum Rounding {\r\n        Down, // Toward negative infinity\r\n        Up, // Toward infinity\r\n        Zero // Toward zero\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the largest of two numbers.\r\n     */\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a > b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the smallest of two numbers.\r\n     */\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the average of two numbers. The result is rounded towards\r\n     * zero.\r\n     */\r\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b) / 2 can overflow.\r\n        return (a & b) + (a ^ b) / 2;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the ceiling of the division of two numbers.\r\n     *\r\n     * This differs from standard division with `/` in that it rounds up instead\r\n     * of rounding down.\r\n     */\r\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b - 1) / b can overflow on addition, so we distribute.\r\n        return a == 0 ? 0 : (a - 1) / b + 1;\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\r\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\r\n     * with further edits by Uniswap Labs also under MIT license.\r\n     */\r\n    function mulDiv(\r\n        uint256 x,\r\n        uint256 y,\r\n        uint256 denominator\r\n    ) internal pure returns (uint256 result) {\r\n        unchecked {\r\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\r\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\r\n            // variables such that product = prod1 * 2^256 + prod0.\r\n            uint256 prod0; // Least significant 256 bits of the product\r\n            uint256 prod1; // Most significant 256 bits of the product\r\n            assembly {\r\n                let mm := mulmod(x, y, not(0))\r\n                prod0 := mul(x, y)\r\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\r\n            }\r\n\r\n            // Handle non-overflow cases, 256 by 256 division.\r\n            if (prod1 == 0) {\r\n                return prod0 / denominator;\r\n            }\r\n\r\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\r\n            require(denominator > prod1);\r\n\r\n            ///////////////////////////////////////////////\r\n            // 512 by 256 division.\r\n            ///////////////////////////////////////////////\r\n\r\n            // Make division exact by subtracting the remainder from [prod1 prod0].\r\n            uint256 remainder;\r\n            assembly {\r\n                // Compute remainder using mulmod.\r\n                remainder := mulmod(x, y, denominator)\r\n\r\n                // Subtract 256 bit number from 512 bit number.\r\n                prod1 := sub(prod1, gt(remainder, prod0))\r\n                prod0 := sub(prod0, remainder)\r\n            }\r\n\r\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\r\n            // See https://cs.stackexchange.com/q/138556/92363.\r\n\r\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\r\n            uint256 twos = denominator & (~denominator + 1);\r\n            assembly {\r\n                // Divide denominator by twos.\r\n                denominator := div(denominator, twos)\r\n\r\n                // Divide [prod1 prod0] by twos.\r\n                prod0 := div(prod0, twos)\r\n\r\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\r\n                twos := add(div(sub(0, twos), twos), 1)\r\n            }\r\n\r\n            // Shift in bits from prod1 into prod0.\r\n            prod0 |= prod1 * twos;\r\n\r\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\r\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\r\n            // four bits. That is, denominator * inv = 1 mod 2^4.\r\n            uint256 inverse = (3 * denominator) ^ 2;\r\n\r\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\r\n            // in modular arithmetic, doubling the correct bits in each step.\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\r\n\r\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\r\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\r\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\r\n            // is no longer required.\r\n            result = prod0 * inverse;\r\n            return result;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\r\n     */\r\n    function mulDiv(\r\n        uint256 x,\r\n        uint256 y,\r\n        uint256 denominator,\r\n        Rounding rounding\r\n    ) internal pure returns (uint256) {\r\n        uint256 result = mulDiv(x, y, denominator);\r\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\r\n            result += 1;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\r\n     *\r\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\r\n     */\r\n    function sqrt(uint256 a) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\r\n        //\r\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\r\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\r\n        //\r\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\r\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\r\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\r\n        //\r\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\r\n        uint256 result = 1 << (log2(a) >> 1);\r\n\r\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\r\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\r\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\r\n        // into the expected uint128 result.\r\n        unchecked {\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            return min(result, a / result);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates sqrt(a), following the selected rounding direction.\r\n     */\r\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\r\n        unchecked {\r\n            uint256 result = sqrt(a);\r\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 2, rounded down, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log2(uint256 value) internal pure returns (uint256) {\r\n        uint256 result = 0;\r\n        unchecked {\r\n            if (value >> 128 > 0) {\r\n                value >>= 128;\r\n                result += 128;\r\n            }\r\n            if (value >> 64 > 0) {\r\n                value >>= 64;\r\n                result += 64;\r\n            }\r\n            if (value >> 32 > 0) {\r\n                value >>= 32;\r\n                result += 32;\r\n            }\r\n            if (value >> 16 > 0) {\r\n                value >>= 16;\r\n                result += 16;\r\n            }\r\n            if (value >> 8 > 0) {\r\n                value >>= 8;\r\n                result += 8;\r\n            }\r\n            if (value >> 4 > 0) {\r\n                value >>= 4;\r\n                result += 4;\r\n            }\r\n            if (value >> 2 > 0) {\r\n                value >>= 2;\r\n                result += 2;\r\n            }\r\n            if (value >> 1 > 0) {\r\n                result += 1;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\r\n        unchecked {\r\n            uint256 result = log2(value);\r\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 10, rounded down, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log10(uint256 value) internal pure returns (uint256) {\r\n        uint256 result = 0;\r\n        unchecked {\r\n            if (value >= 10**64) {\r\n                value /= 10**64;\r\n                result += 64;\r\n            }\r\n            if (value >= 10**32) {\r\n                value /= 10**32;\r\n                result += 32;\r\n            }\r\n            if (value >= 10**16) {\r\n                value /= 10**16;\r\n                result += 16;\r\n            }\r\n            if (value >= 10**8) {\r\n                value /= 10**8;\r\n                result += 8;\r\n            }\r\n            if (value >= 10**4) {\r\n                value /= 10**4;\r\n                result += 4;\r\n            }\r\n            if (value >= 10**2) {\r\n                value /= 10**2;\r\n                result += 2;\r\n            }\r\n            if (value >= 10**1) {\r\n                result += 1;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\r\n        unchecked {\r\n            uint256 result = log10(value);\r\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 256, rounded down, of a positive value.\r\n     * Returns 0 if given 0.\r\n     *\r\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\r\n     */\r\n    function log256(uint256 value) internal pure returns (uint256) {\r\n        uint256 result = 0;\r\n        unchecked {\r\n            if (value >> 128 > 0) {\r\n                value >>= 128;\r\n                result += 16;\r\n            }\r\n            if (value >> 64 > 0) {\r\n                value >>= 64;\r\n                result += 8;\r\n            }\r\n            if (value >> 32 > 0) {\r\n                value >>= 32;\r\n                result += 4;\r\n            }\r\n            if (value >> 16 > 0) {\r\n                value >>= 16;\r\n                result += 2;\r\n            }\r\n            if (value >> 8 > 0) {\r\n                result += 1;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\r\n        unchecked {\r\n            uint256 result = log256(value);\r\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\r\n        }\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/Strings.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev String operations.\r\n */\r\nlibrary Strings {\r\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\r\n    uint8 private constant _ADDRESS_LENGTH = 20;\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\r\n     */\r\n    function toString(uint256 value) internal pure returns (string memory) {\r\n        unchecked {\r\n            uint256 length = Math.log10(value) + 1;\r\n            string memory buffer = new string(length);\r\n            uint256 ptr;\r\n            /// @solidity memory-safe-assembly\r\n            assembly {\r\n                ptr := add(buffer, add(32, length))\r\n            }\r\n            while (true) {\r\n                ptr--;\r\n                /// @solidity memory-safe-assembly\r\n                assembly {\r\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\r\n                }\r\n                value /= 10;\r\n                if (value == 0) break;\r\n            }\r\n            return buffer;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\r\n     */\r\n    function toHexString(uint256 value) internal pure returns (string memory) {\r\n        unchecked {\r\n            return toHexString(value, Math.log256(value) + 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\r\n     */\r\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\r\n        bytes memory buffer = new bytes(2 * length + 2);\r\n        buffer[0] = \"0\";\r\n        buffer[1] = \"x\";\r\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\r\n            buffer[i] = _SYMBOLS[value & 0xf];\r\n            value >>= 4;\r\n        }\r\n        require(value == 0, \"Strings: hex length insufficient\");\r\n        return string(buffer);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\r\n     */\r\n    function toHexString(address addr) internal pure returns (string memory) {\r\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title ERC721 token receiver interface\r\n * @dev Interface for any contract that wants to support safeTransfers\r\n * from ERC721 asset contracts.\r\n */\r\ninterface IERC721Receiver {\r\n    /**\r\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\r\n     * by `operator` from `from`, this function is called.\r\n     *\r\n     * It must return its Solidity selector to confirm the token transfer.\r\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\r\n     *\r\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\r\n     */\r\n    function onERC721Received(\r\n        address operator,\r\n        address from,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}\r\n\r\n// File: solidity-bits/contracts/Popcount.sol\r\n\r\n\r\n/**\r\n   _____       ___     ___ __           ____  _ __      \r\n  / ___/____  / (_)___/ (_) /___  __   / __ )(_) /______\r\n  \\__ \\/ __ \\/ / / __  / / __/ / / /  / __  / / __/ ___/\r\n ___/ / /_/ / / / /_/ / / /_/ /_/ /  / /_/ / / /_(__  ) \r\n/____/\\____/_/_/\\__,_/_/\\__/\\__, /  /_____/_/\\__/____/  \r\n                           /____/                        \r\n\r\n- npm: https://www.npmjs.com/package/solidity-bits\r\n- github: https://github.com/estarriolvetch/solidity-bits\r\n\r\n */\r\n\r\npragma solidity ^0.8.0;\r\n\r\nlibrary Popcount {\r\n    uint256 private constant m1 = 0x5555555555555555555555555555555555555555555555555555555555555555;\r\n    uint256 private constant m2 = 0x3333333333333333333333333333333333333333333333333333333333333333;\r\n    uint256 private constant m4 = 0x0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f;\r\n    uint256 private constant h01 = 0x0101010101010101010101010101010101010101010101010101010101010101;\r\n\r\n    function popcount256A(uint256 x) internal pure returns (uint256 count) {\r\n        unchecked{\r\n            for (count=0; x!=0; count++)\r\n                x &= x - 1;\r\n        }\r\n    }\r\n\r\n    function popcount256B(uint256 x) internal pure returns (uint256) {\r\n        if (x == type(uint256).max) {\r\n            return 256;\r\n        }\r\n        unchecked {\r\n            x -= (x >> 1) & m1;             //put count of each 2 bits into those 2 bits\r\n            x = (x & m2) + ((x >> 2) & m2); //put count of each 4 bits into those 4 bits \r\n            x = (x + (x >> 4)) & m4;        //put count of each 8 bits into those 8 bits \r\n            x = (x * h01) >> 248;  //returns left 8 bits of x + (x<<8) + (x<<16) + (x<<24) + ... \r\n        }\r\n        return x;\r\n    }\r\n}\r\n// File: solidity-bits/contracts/BitScan.sol\r\n\r\n\r\n/**\r\n   _____       ___     ___ __           ____  _ __      \r\n  / ___/____  / (_)___/ (_) /___  __   / __ )(_) /______\r\n  \\__ \\/ __ \\/ / / __  / / __/ / / /  / __  / / __/ ___/\r\n ___/ / /_/ / / / /_/ / / /_/ /_/ /  / /_/ / / /_(__  ) \r\n/____/\\____/_/_/\\__,_/_/\\__/\\__, /  /_____/_/\\__/____/  \r\n                           /____/                        \r\n\r\n- npm: https://www.npmjs.com/package/solidity-bits\r\n- github: https://github.com/estarriolvetch/solidity-bits\r\n\r\n */\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\nlibrary BitScan {\r\n    uint256 constant private DEBRUIJN_256 = 0x818283848586878898a8b8c8d8e8f929395969799a9b9d9e9faaeb6bedeeff;\r\n    bytes constant private LOOKUP_TABLE_256 = hex\"0001020903110a19042112290b311a3905412245134d2a550c5d32651b6d3a7506264262237d468514804e8d2b95569d0d495ea533a966b11c886eb93bc176c9071727374353637324837e9b47af86c7155181ad4fd18ed32c9096db57d59ee30e2e4a6a5f92a6be3498aae067ddb2eb1d5989b56fd7baf33ca0c2ee77e5caf7ff0810182028303840444c545c646c7425617c847f8c949c48a4a8b087b8c0c816365272829aaec650acd0d28fdad4e22d6991bd97dfdcea58b4d6f29fede4f6fe0f1f2f3f4b5b6b607b8b93a3a7b7bf357199c5abcfd9e168bcdee9b3f1ecf5fd1e3e5a7a8aa2b670c4ced8bbe8f0f4fc3d79a1c3cde7effb78cce6facbf9f8\";\r\n\r\n    /**\r\n        @dev Isolate the least significant set bit.\r\n     */ \r\n    function isolateLS1B256(uint256 bb) pure internal returns (uint256) {\r\n        require(bb > 0);\r\n        unchecked {\r\n            return bb & (0 - bb);\r\n        }\r\n    } \r\n\r\n    /**\r\n        @dev Isolate the most significant set bit.\r\n     */ \r\n    function isolateMS1B256(uint256 bb) pure internal returns (uint256) {\r\n        require(bb > 0);\r\n        unchecked {\r\n            bb |= bb >> 128;\r\n            bb |= bb >> 64;\r\n            bb |= bb >> 32;\r\n            bb |= bb >> 16;\r\n            bb |= bb >> 8;\r\n            bb |= bb >> 4;\r\n            bb |= bb >> 2;\r\n            bb |= bb >> 1;\r\n            \r\n            return (bb >> 1) + 1;\r\n        }\r\n    } \r\n\r\n    /**\r\n        @dev Find the index of the lest significant set bit. (trailing zero count)\r\n     */ \r\n    function bitScanForward256(uint256 bb) pure internal returns (uint8) {\r\n        unchecked {\r\n            return uint8(LOOKUP_TABLE_256[(isolateLS1B256(bb) * DEBRUIJN_256) >> 248]);\r\n        }   \r\n    }\r\n\r\n    /**\r\n        @dev Find the index of the most significant set bit.\r\n     */ \r\n    function bitScanReverse256(uint256 bb) pure internal returns (uint8) {\r\n        unchecked {\r\n            return 255 - uint8(LOOKUP_TABLE_256[((isolateMS1B256(bb) * DEBRUIJN_256) >> 248)]);\r\n        }   \r\n    }\r\n\r\n    function log2(uint256 bb) pure internal returns (uint8) {\r\n        unchecked {\r\n            return uint8(LOOKUP_TABLE_256[(isolateMS1B256(bb) * DEBRUIJN_256) >> 248]);\r\n        } \r\n    }\r\n}\r\n\r\n// File: solidity-bits/contracts/BitMaps.sol\r\n\r\n\r\n/**\r\n   _____       ___     ___ __           ____  _ __      \r\n  / ___/____  / (_)___/ (_) /___  __   / __ )(_) /______\r\n  \\__ \\/ __ \\/ / / __  / / __/ / / /  / __  / / __/ ___/\r\n ___/ / /_/ / / / /_/ / / /_/ /_/ /  / /_/ / / /_(__  ) \r\n/____/\\____/_/_/\\__,_/_/\\__/\\__, /  /_____/_/\\__/____/  \r\n                           /____/                        \r\n\r\n- npm: https://www.npmjs.com/package/solidity-bits\r\n- github: https://github.com/estarriolvetch/solidity-bits\r\n\r\n */\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n/**\r\n * @dev This Library is a modified version of Openzeppelin's BitMaps library with extra features.\r\n *\r\n * 1. Functions of finding the index of the closest set bit from a given index are added.\r\n *    The indexing of each bucket is modifed to count from the MSB to the LSB instead of from the LSB to the MSB.\r\n *    The modification of indexing makes finding the closest previous set bit more efficient in gas usage.\r\n * 2. Setting and unsetting the bitmap consecutively.\r\n * 3. Accounting number of set bits within a given range.   \r\n *\r\n*/\r\n\r\n/**\r\n * @dev Library for managing uint256 to bool mapping in a compact and efficient way, providing the keys are sequential.\r\n * Largelly inspired by Uniswap's https://github.com/Uniswap/merkle-distributor/blob/master/contracts/MerkleDistributor.sol[merkle-distributor].\r\n */\r\n\r\nlibrary BitMaps {\r\n    using BitScan for uint256;\r\n    uint256 private constant MASK_INDEX_ZERO = (1 << 255);\r\n    uint256 private constant MASK_FULL = type(uint256).max;\r\n\r\n    struct BitMap {\r\n        mapping(uint256 => uint256) _data;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether the bit at `index` is set.\r\n     */\r\n    function get(BitMap storage bitmap, uint256 index) internal view returns (bool) {\r\n        uint256 bucket = index >> 8;\r\n        uint256 mask = MASK_INDEX_ZERO >> (index & 0xff);\r\n        return bitmap._data[bucket] & mask != 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the bit at `index` to the boolean `value`.\r\n     */\r\n    function setTo(\r\n        BitMap storage bitmap,\r\n        uint256 index,\r\n        bool value\r\n    ) internal {\r\n        if (value) {\r\n            set(bitmap, index);\r\n        } else {\r\n            unset(bitmap, index);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the bit at `index`.\r\n     */\r\n    function set(BitMap storage bitmap, uint256 index) internal {\r\n        uint256 bucket = index >> 8;\r\n        uint256 mask = MASK_INDEX_ZERO >> (index & 0xff);\r\n        bitmap._data[bucket] |= mask;\r\n    }\r\n\r\n    /**\r\n     * @dev Unsets the bit at `index`.\r\n     */\r\n    function unset(BitMap storage bitmap, uint256 index) internal {\r\n        uint256 bucket = index >> 8;\r\n        uint256 mask = MASK_INDEX_ZERO >> (index & 0xff);\r\n        bitmap._data[bucket] &= ~mask;\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Consecutively sets `amount` of bits starting from the bit at `startIndex`.\r\n     */    \r\n    function setBatch(BitMap storage bitmap, uint256 startIndex, uint256 amount) internal {\r\n        uint256 bucket = startIndex >> 8;\r\n\r\n        uint256 bucketStartIndex = (startIndex & 0xff);\r\n\r\n        unchecked {\r\n            if(bucketStartIndex + amount < 256) {\r\n                bitmap._data[bucket] |= MASK_FULL << (256 - amount) >> bucketStartIndex;\r\n            } else {\r\n                bitmap._data[bucket] |= MASK_FULL >> bucketStartIndex;\r\n                amount -= (256 - bucketStartIndex);\r\n                bucket++;\r\n\r\n                while(amount > 256) {\r\n                    bitmap._data[bucket] = MASK_FULL;\r\n                    amount -= 256;\r\n                    bucket++;\r\n                }\r\n\r\n                bitmap._data[bucket] |= MASK_FULL << (256 - amount);\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Consecutively unsets `amount` of bits starting from the bit at `startIndex`.\r\n     */    \r\n    function unsetBatch(BitMap storage bitmap, uint256 startIndex, uint256 amount) internal {\r\n        uint256 bucket = startIndex >> 8;\r\n\r\n        uint256 bucketStartIndex = (startIndex & 0xff);\r\n\r\n        unchecked {\r\n            if(bucketStartIndex + amount < 256) {\r\n                bitmap._data[bucket] &= ~(MASK_FULL << (256 - amount) >> bucketStartIndex);\r\n            } else {\r\n                bitmap._data[bucket] &= ~(MASK_FULL >> bucketStartIndex);\r\n                amount -= (256 - bucketStartIndex);\r\n                bucket++;\r\n\r\n                while(amount > 256) {\r\n                    bitmap._data[bucket] = 0;\r\n                    amount -= 256;\r\n                    bucket++;\r\n                }\r\n\r\n                bitmap._data[bucket] &= ~(MASK_FULL << (256 - amount));\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns number of set bits within a range.\r\n     */\r\n    function popcountA(BitMap storage bitmap, uint256 startIndex, uint256 amount) internal view returns(uint256 count) {\r\n        uint256 bucket = startIndex >> 8;\r\n\r\n        uint256 bucketStartIndex = (startIndex & 0xff);\r\n\r\n        unchecked {\r\n            if(bucketStartIndex + amount < 256) {\r\n                count +=  Popcount.popcount256A(\r\n                    bitmap._data[bucket] & (MASK_FULL << (256 - amount) >> bucketStartIndex)\r\n                );\r\n            } else {\r\n                count += Popcount.popcount256A(\r\n                    bitmap._data[bucket] & (MASK_FULL >> bucketStartIndex)\r\n                );\r\n                amount -= (256 - bucketStartIndex);\r\n                bucket++;\r\n\r\n                while(amount > 256) {\r\n                    count += Popcount.popcount256A(bitmap._data[bucket]);\r\n                    amount -= 256;\r\n                    bucket++;\r\n                }\r\n                count += Popcount.popcount256A(\r\n                    bitmap._data[bucket] & (MASK_FULL << (256 - amount))\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns number of set bits within a range.\r\n     */\r\n    function popcountB(BitMap storage bitmap, uint256 startIndex, uint256 amount) internal view returns(uint256 count) {\r\n        uint256 bucket = startIndex >> 8;\r\n\r\n        uint256 bucketStartIndex = (startIndex & 0xff);\r\n\r\n        unchecked {\r\n            if(bucketStartIndex + amount < 256) {\r\n                count +=  Popcount.popcount256B(\r\n                    bitmap._data[bucket] & (MASK_FULL << (256 - amount) >> bucketStartIndex)\r\n                );\r\n            } else {\r\n                count += Popcount.popcount256B(\r\n                    bitmap._data[bucket] & (MASK_FULL >> bucketStartIndex)\r\n                );\r\n                amount -= (256 - bucketStartIndex);\r\n                bucket++;\r\n\r\n                while(amount > 256) {\r\n                    count += Popcount.popcount256B(bitmap._data[bucket]);\r\n                    amount -= 256;\r\n                    bucket++;\r\n                }\r\n                count += Popcount.popcount256B(\r\n                    bitmap._data[bucket] & (MASK_FULL << (256 - amount))\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Find the closest index of the set bit before `index`.\r\n     */\r\n    function scanForward(BitMap storage bitmap, uint256 index) internal view returns (uint256 setBitIndex) {\r\n        uint256 bucket = index >> 8;\r\n\r\n        // index within the bucket\r\n        uint256 bucketIndex = (index & 0xff);\r\n\r\n        // load a bitboard from the bitmap.\r\n        uint256 bb = bitmap._data[bucket];\r\n\r\n        // offset the bitboard to scan from `bucketIndex`.\r\n        bb = bb >> (0xff ^ bucketIndex); // bb >> (255 - bucketIndex)\r\n        \r\n        if(bb > 0) {\r\n            unchecked {\r\n                setBitIndex = (bucket << 8) | (bucketIndex -  bb.bitScanForward256());    \r\n            }\r\n        } else {\r\n            while(true) {\r\n                require(bucket > 0, \"BitMaps: The set bit before the index doesn't exist.\");\r\n                unchecked {\r\n                    bucket--;\r\n                }\r\n                // No offset. Always scan from the least significiant bit now.\r\n                bb = bitmap._data[bucket];\r\n                \r\n                if(bb > 0) {\r\n                    unchecked {\r\n                        setBitIndex = (bucket << 8) | (255 -  bb.bitScanForward256());\r\n                        break;\r\n                    }\r\n                } \r\n            }\r\n        }\r\n    }\r\n\r\n    function getBucket(BitMap storage bitmap, uint256 bucket) internal view returns (uint256) {\r\n        return bitmap._data[bucket];\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/security/ReentrancyGuard.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and making it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        _nonReentrantBefore();\r\n        _;\r\n        _nonReentrantAfter();\r\n    }\r\n\r\n    function _nonReentrantBefore() private {\r\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n    }\r\n\r\n    function _nonReentrantAfter() private {\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/introspection/IERC165.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC721/IERC721.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Required interface of an ERC721 compliant contract.\r\n */\r\ninterface IERC721 is IERC165 {\r\n    /**\r\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\r\n     */\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\r\n     */\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Returns the number of tokens in ``owner``'s account.\r\n     */\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    /**\r\n     * @dev Returns the owner of the `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\r\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\r\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\r\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\r\n     * The approval is cleared when the token is transferred.\r\n     *\r\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The caller must own the token or be an approved operator.\r\n     * - `tokenId` must exist.\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address to, uint256 tokenId) external;\r\n\r\n    /**\r\n     * @dev Approve or remove `operator` as an operator for the caller.\r\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The `operator` cannot be the caller.\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     */\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n\r\n    /**\r\n     * @dev Returns the account approved for `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function getApproved(uint256 tokenId) external view returns (address operator);\r\n\r\n    /**\r\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\r\n     *\r\n     * See {setApprovalForAll}\r\n     */\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\r\n * @dev See https://eips.ethereum.org/EIPS/eip-721\r\n */\r\ninterface IERC721Metadata is IERC721 {\r\n    /**\r\n     * @dev Returns the token collection name.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the token collection symbol.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\r\n     */\r\n    function tokenURI(uint256 tokenId) external view returns (string memory);\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/introspection/ERC165.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Implementation of the {IERC165} interface.\r\n *\r\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\r\n * for the additional interface id that will be supported. For example:\r\n *\r\n * ```solidity\r\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\r\n * }\r\n * ```\r\n *\r\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\r\n */\r\nabstract contract ERC165 is IERC165 {\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n        return interfaceId == type(IERC165).interfaceId;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/interfaces/IERC2981.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.6.0) (interfaces/IERC2981.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Interface for the NFT Royalty Standard.\r\n *\r\n * A standardized way to retrieve royalty payment information for non-fungible tokens (NFTs) to enable universal\r\n * support for royalty payments across all NFT marketplaces and ecosystem participants.\r\n *\r\n * _Available since v4.5._\r\n */\r\ninterface IERC2981 is IERC165 {\r\n    /**\r\n     * @dev Returns how much royalty is owed and to whom, based on a sale price that may be denominated in any unit of\r\n     * exchange. The royalty amount is denominated and should be paid in that same unit of exchange.\r\n     */\r\n    function royaltyInfo(uint256 tokenId, uint256 salePrice)\r\n        external\r\n        view\r\n        returns (address receiver, uint256 royaltyAmount);\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/common/ERC2981.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.7.0) (token/common/ERC2981.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n/**\r\n * @dev Implementation of the NFT Royalty Standard, a standardized way to retrieve royalty payment information.\r\n *\r\n * Royalty information can be specified globally for all token ids via {_setDefaultRoyalty}, and/or individually for\r\n * specific token ids via {_setTokenRoyalty}. The latter takes precedence over the first.\r\n *\r\n * Royalty is specified as a fraction of sale price. {_feeDenominator} is overridable but defaults to 10000, meaning the\r\n * fee is specified in basis points by default.\r\n *\r\n * IMPORTANT: ERC-2981 only specifies a way to signal royalty information and does not enforce its payment. See\r\n * https://eips.ethereum.org/EIPS/eip-2981#optional-royalty-payments[Rationale] in the EIP. Marketplaces are expected to\r\n * voluntarily pay royalties together with sales, but note that this standard is not yet widely supported.\r\n *\r\n * _Available since v4.5._\r\n */\r\nabstract contract ERC2981 is IERC2981, ERC165 {\r\n    struct RoyaltyInfo {\r\n        address receiver;\r\n        uint96 royaltyFraction;\r\n    }\r\n\r\n    RoyaltyInfo private _defaultRoyaltyInfo;\r\n    mapping(uint256 => RoyaltyInfo) private _tokenRoyaltyInfo;\r\n\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC165) returns (bool) {\r\n        return interfaceId == type(IERC2981).interfaceId || super.supportsInterface(interfaceId);\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc IERC2981\r\n     */\r\n    function royaltyInfo(uint256 _tokenId, uint256 _salePrice) public view virtual override returns (address, uint256) {\r\n        RoyaltyInfo memory royalty = _tokenRoyaltyInfo[_tokenId];\r\n\r\n        if (royalty.receiver == address(0)) {\r\n            royalty = _defaultRoyaltyInfo;\r\n        }\r\n\r\n        uint256 royaltyAmount = (_salePrice * royalty.royaltyFraction) / _feeDenominator();\r\n\r\n        return (royalty.receiver, royaltyAmount);\r\n    }\r\n\r\n    /**\r\n     * @dev The denominator with which to interpret the fee set in {_setTokenRoyalty} and {_setDefaultRoyalty} as a\r\n     * fraction of the sale price. Defaults to 10000 so fees are expressed in basis points, but may be customized by an\r\n     * override.\r\n     */\r\n    function _feeDenominator() internal pure virtual returns (uint96) {\r\n        return 10000;\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the royalty information that all ids in this contract will default to.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `receiver` cannot be the zero address.\r\n     * - `feeNumerator` cannot be greater than the fee denominator.\r\n     */\r\n    function _setDefaultRoyalty(address receiver, uint96 feeNumerator) internal virtual {\r\n        require(feeNumerator <= _feeDenominator(), \"ERC2981: royalty fee will exceed salePrice\");\r\n        require(receiver != address(0), \"ERC2981: invalid receiver\");\r\n\r\n        _defaultRoyaltyInfo = RoyaltyInfo(receiver, feeNumerator);\r\n    }\r\n\r\n    /**\r\n     * @dev Removes default royalty information.\r\n     */\r\n    function _deleteDefaultRoyalty() internal virtual {\r\n        delete _defaultRoyaltyInfo;\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the royalty information for a specific token id, overriding the global default.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `receiver` cannot be the zero address.\r\n     * - `feeNumerator` cannot be greater than the fee denominator.\r\n     */\r\n    function _setTokenRoyalty(\r\n        uint256 tokenId,\r\n        address receiver,\r\n        uint96 feeNumerator\r\n    ) internal virtual {\r\n        require(feeNumerator <= _feeDenominator(), \"ERC2981: royalty fee will exceed salePrice\");\r\n        require(receiver != address(0), \"ERC2981: Invalid parameters\");\r\n\r\n        _tokenRoyaltyInfo[tokenId] = RoyaltyInfo(receiver, feeNumerator);\r\n    }\r\n\r\n    /**\r\n     * @dev Resets royalty information for the token id back to the global default.\r\n     */\r\n    function _resetTokenRoyalty(uint256 tokenId) internal virtual {\r\n        delete _tokenRoyaltyInfo[tokenId];\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/Context.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: erc721psi/contracts/ERC721Psi.sol\r\n\r\n\r\n/**\r\n  ______ _____   _____ ______ ___  __ _  _  _ \r\n |  ____|  __ \\ / ____|____  |__ \\/_ | || || |\r\n | |__  | |__) | |        / /   ) || | \\| |/ |\r\n |  __| |  _  /| |       / /   / / | |\\_   _/ \r\n | |____| | \\ \\| |____  / /   / /_ | |  | |   \r\n |______|_|  \\_\\\\_____|/_/   |____||_|  |_|   \r\n\r\n - github: https://github.com/estarriolvetch/ERC721Psi\r\n - npm: https://www.npmjs.com/package/erc721psi\r\n                                          \r\n */\r\n\r\npragma solidity ^0.8.0;\r\n\r\ncontract ERC721Psi is Context, ERC165, IERC721, IERC721Metadata {\r\n    using Address for address;\r\n    using Strings for uint256;\r\n    using BitMaps for BitMaps.BitMap;\r\n\r\n    BitMaps.BitMap internal _batchHead;\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n\r\n    // Mapping from token ID to owner address\r\n    mapping(uint256 => address) internal _owners;\r\n    uint256 internal _currentIndex;\r\n\r\n    mapping(uint256 => address) private _tokenApprovals;\r\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\r\n\r\n    /**\r\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\r\n     */\r\n    constructor(string memory name_, string memory symbol_) {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n        _currentIndex = _startTokenId();\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the starting token ID.\r\n     * To change the starting token ID, please override this function.\r\n     */\r\n    function _startTokenId() internal pure virtual returns (uint256) {\r\n        // It will become modifiable in the future versions\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the next token ID to be minted.\r\n     */\r\n    function _nextTokenId() internal view virtual returns (uint256) {\r\n        return _currentIndex;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the total amount of tokens minted in the contract.\r\n     */\r\n    function _totalMinted() internal view virtual returns (uint256) {\r\n        return _currentIndex - _startTokenId();\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId)\r\n        public\r\n        view\r\n        virtual\r\n        override(ERC165, IERC165)\r\n        returns (bool)\r\n    {\r\n        return\r\n            interfaceId == type(IERC721).interfaceId ||\r\n            interfaceId == type(IERC721Metadata).interfaceId ||\r\n            super.supportsInterface(interfaceId);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-balanceOf}.\r\n     */\r\n    function balanceOf(address owner) \r\n        public \r\n        view \r\n        virtual \r\n        override \r\n        returns (uint) \r\n    {\r\n        require(owner != address(0), \"ERC721Psi: balance query for the zero address\");\r\n\r\n        uint count;\r\n        for( uint i = _startTokenId(); i < _nextTokenId(); ++i ){\r\n            if(_exists(i)){\r\n                if( owner == ownerOf(i)){\r\n                    ++count;\r\n                }\r\n            }\r\n        }\r\n        return count;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-ownerOf}.\r\n     */\r\n    function ownerOf(uint256 tokenId)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (address)\r\n    {\r\n        (address owner, ) = _ownerAndBatchHeadOf(tokenId);\r\n        return owner;\r\n    }\r\n\r\n    function _ownerAndBatchHeadOf(uint256 tokenId) internal view virtual returns (address owner, uint256 tokenIdBatchHead){\r\n        require(_exists(tokenId), \"ERC721Psi: owner query for nonexistent token\");\r\n        tokenIdBatchHead = _getBatchHead(tokenId);\r\n        owner = _owners[tokenIdBatchHead];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721Metadata-name}.\r\n     */\r\n    function name() public view virtual override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721Metadata-symbol}.\r\n     */\r\n    function symbol() public view virtual override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721Metadata-tokenURI}.\r\n     */\r\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\r\n        require(_exists(tokenId), \"ERC721Psi: URI query for nonexistent token\");\r\n\r\n        string memory baseURI = _baseURI();\r\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\r\n    }\r\n\r\n    /**\r\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\r\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\r\n     * by default, can be overriden in child contracts.\r\n     */\r\n    function _baseURI() internal view virtual returns (string memory) {\r\n        return \"\";\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev See {IERC721-approve}.\r\n     */\r\n    function approve(address to, uint256 tokenId) public virtual override {\r\n        address owner = ownerOf(tokenId);\r\n        require(to != owner, \"ERC721Psi: approval to current owner\");\r\n\r\n        require(\r\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\r\n            \"ERC721Psi: approve caller is not owner nor approved for all\"\r\n        );\r\n\r\n        _approve(to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-getApproved}.\r\n     */\r\n    function getApproved(uint256 tokenId)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (address)\r\n    {\r\n        require(\r\n            _exists(tokenId),\r\n            \"ERC721Psi: approved query for nonexistent token\"\r\n        );\r\n\r\n        return _tokenApprovals[tokenId];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-setApprovalForAll}.\r\n     */\r\n    function setApprovalForAll(address operator, bool approved)\r\n        public\r\n        virtual\r\n        override\r\n    {\r\n        require(operator != _msgSender(), \"ERC721Psi: approve to caller\");\r\n\r\n        _operatorApprovals[_msgSender()][operator] = approved;\r\n        emit ApprovalForAll(_msgSender(), operator, approved);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-isApprovedForAll}.\r\n     */\r\n    function isApprovedForAll(address owner, address operator)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (bool)\r\n    {\r\n        return _operatorApprovals[owner][operator];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-transferFrom}.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) public virtual override {\r\n        //solhint-disable-next-line max-line-length\r\n        require(\r\n            _isApprovedOrOwner(_msgSender(), tokenId),\r\n            \"ERC721Psi: transfer caller is not owner nor approved\"\r\n        );\r\n\r\n        _transfer(from, to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-safeTransferFrom}.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) public virtual override {\r\n        safeTransferFrom(from, to, tokenId, \"\");\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-safeTransferFrom}.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory _data\r\n    ) public virtual override {\r\n        require(\r\n            _isApprovedOrOwner(_msgSender(), tokenId),\r\n            \"ERC721Psi: transfer caller is not owner nor approved\"\r\n        );\r\n        _safeTransfer(from, to, tokenId, _data);\r\n    }\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\r\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\r\n     *\r\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\r\n     *\r\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\r\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function _safeTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory _data\r\n    ) internal virtual {\r\n        _transfer(from, to, tokenId);\r\n        require(\r\n            _checkOnERC721Received(from, to, tokenId, 1,_data),\r\n            \"ERC721Psi: transfer to non ERC721Receiver implementer\"\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether `tokenId` exists.\r\n     *\r\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\r\n     *\r\n     * Tokens start existing when they are minted (`_mint`).\r\n     */\r\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\r\n        return tokenId < _nextTokenId() && _startTokenId() <= tokenId;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function _isApprovedOrOwner(address spender, uint256 tokenId)\r\n        internal\r\n        view\r\n        virtual\r\n        returns (bool)\r\n    {\r\n        require(\r\n            _exists(tokenId),\r\n            \"ERC721Psi: operator query for nonexistent token\"\r\n        );\r\n        address owner = ownerOf(tokenId);\r\n        return (spender == owner ||\r\n            getApproved(tokenId) == spender ||\r\n            isApprovedForAll(owner, spender));\r\n    }\r\n\r\n    /**\r\n     * @dev Safely mints `quantity` tokens and transfers them to `to`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called for each safe transfer.\r\n     * - `quantity` must be greater than 0.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function _safeMint(address to, uint256 quantity) internal virtual {\r\n        _safeMint(to, quantity, \"\");\r\n    }\r\n\r\n    \r\n    function _safeMint(\r\n        address to,\r\n        uint256 quantity,\r\n        bytes memory _data\r\n    ) internal virtual {\r\n        uint256 nextTokenId = _nextTokenId();\r\n        _mint(to, quantity);\r\n        require(\r\n            _checkOnERC721Received(address(0), to, nextTokenId, quantity, _data),\r\n            \"ERC721Psi: transfer to non ERC721Receiver implementer\"\r\n        );\r\n    }\r\n\r\n\r\n    function _mint(\r\n        address to,\r\n        uint256 quantity\r\n    ) internal virtual {\r\n        uint256 nextTokenId = _nextTokenId();\r\n        \r\n        require(quantity > 0, \"ERC721Psi: quantity must be greater 0\");\r\n        require(to != address(0), \"ERC721Psi: mint to the zero address\");\r\n        \r\n        _beforeTokenTransfers(address(0), to, nextTokenId, quantity);\r\n        _currentIndex += quantity;\r\n        _owners[nextTokenId] = to;\r\n        _batchHead.set(nextTokenId);\r\n        _afterTokenTransfers(address(0), to, nextTokenId, quantity);\r\n        \r\n        // Emit events\r\n        for(uint256 tokenId=nextTokenId; tokenId < nextTokenId + quantity; tokenId++){\r\n            emit Transfer(address(0), to, tokenId);\r\n        } \r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * @dev Transfers `tokenId` from `from` to `to`.\r\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must be owned by `from`.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) internal virtual {\r\n        (address owner, uint256 tokenIdBatchHead) = _ownerAndBatchHeadOf(tokenId);\r\n\r\n        require(\r\n            owner == from,\r\n            \"ERC721Psi: transfer of token that is not own\"\r\n        );\r\n        require(to != address(0), \"ERC721Psi: transfer to the zero address\");\r\n\r\n        _beforeTokenTransfers(from, to, tokenId, 1);\r\n\r\n        // Clear approvals from the previous owner\r\n        _approve(address(0), tokenId);   \r\n\r\n        uint256 subsequentTokenId = tokenId + 1;\r\n\r\n        if(!_batchHead.get(subsequentTokenId) &&  \r\n            subsequentTokenId < _nextTokenId()\r\n        ) {\r\n            _owners[subsequentTokenId] = from;\r\n            _batchHead.set(subsequentTokenId);\r\n        }\r\n\r\n        _owners[tokenId] = to;\r\n        if(tokenId != tokenIdBatchHead) {\r\n            _batchHead.set(tokenId);\r\n        }\r\n\r\n        emit Transfer(from, to, tokenId);\r\n\r\n        _afterTokenTransfers(from, to, tokenId, 1);\r\n    }\r\n\r\n    /**\r\n     * @dev Approve `to` to operate on `tokenId`\r\n     *\r\n     * Emits a {Approval} event.\r\n     */\r\n    function _approve(address to, uint256 tokenId) internal virtual {\r\n        _tokenApprovals[tokenId] = to;\r\n        emit Approval(ownerOf(tokenId), to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\r\n     * The call is not executed if the target address is not a contract.\r\n     *\r\n     * @param from address representing the previous owner of the given token ID\r\n     * @param to target address that will receive the tokens\r\n     * @param startTokenId uint256 the first ID of the tokens to be transferred\r\n     * @param quantity uint256 amount of the tokens to be transfered.\r\n     * @param _data bytes optional data to send along with the call\r\n     * @return r bool whether the call correctly returned the expected magic value\r\n     */\r\n    function _checkOnERC721Received(\r\n        address from,\r\n        address to,\r\n        uint256 startTokenId,\r\n        uint256 quantity,\r\n        bytes memory _data\r\n    ) private returns (bool r) {\r\n        if (to.isContract()) {\r\n            r = true;\r\n            for(uint256 tokenId = startTokenId; tokenId < startTokenId + quantity; tokenId++){\r\n                try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\r\n                    r = r && retval == IERC721Receiver.onERC721Received.selector;\r\n                } catch (bytes memory reason) {\r\n                    if (reason.length == 0) {\r\n                        revert(\"ERC721Psi: transfer to non ERC721Receiver implementer\");\r\n                    } else {\r\n                        assembly {\r\n                            revert(add(32, reason), mload(reason))\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return r;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    function _getBatchHead(uint256 tokenId) internal view returns (uint256 tokenIdBatchHead) {\r\n        tokenIdBatchHead = _batchHead.scanForward(tokenId); \r\n    }\r\n\r\n\r\n    function totalSupply() public virtual view returns (uint256) {\r\n        return _totalMinted();\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an array of token IDs owned by `owner`.\r\n     *\r\n     * This function scans the ownership mapping and is O(`totalSupply`) in complexity.\r\n     * It is meant to be called off-chain.\r\n     *\r\n     * This function is compatiable with ERC721AQueryable.\r\n     */\r\n    function tokensOfOwner(address owner) external view virtual returns (uint256[] memory) {\r\n        unchecked {\r\n            uint256 tokenIdsIdx;\r\n            uint256 tokenIdsLength = balanceOf(owner);\r\n            uint256[] memory tokenIds = new uint256[](tokenIdsLength);\r\n            for (uint256 i = _startTokenId(); tokenIdsIdx != tokenIdsLength; ++i) {\r\n                if (_exists(i)) {\r\n                    if (ownerOf(i) == owner) {\r\n                        tokenIds[tokenIdsIdx++] = i;\r\n                    }\r\n                }\r\n            }\r\n            return tokenIds;   \r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Hook that is called before a set of serially-ordered token ids are about to be transferred. This includes minting.\r\n     *\r\n     * startTokenId - the first token id to be transferred\r\n     * quantity - the amount to be transferred\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\r\n     * transferred to `to`.\r\n     * - When `from` is zero, `tokenId` will be minted for `to`.\r\n     */\r\n    function _beforeTokenTransfers(\r\n        address from,\r\n        address to,\r\n        uint256 startTokenId,\r\n        uint256 quantity\r\n    ) internal virtual {}\r\n\r\n    /**\r\n     * @dev Hook that is called after a set of serially-ordered token ids have been transferred. This includes\r\n     * minting.\r\n     *\r\n     * startTokenId - the first token id to be transferred\r\n     * quantity - the amount to be transferred\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - when `from` and `to` are both non-zero.\r\n     * - `from` and `to` are never both zero.\r\n     */\r\n    function _afterTokenTransfers(\r\n        address from,\r\n        address to,\r\n        uint256 startTokenId,\r\n        uint256 quantity\r\n    ) internal virtual {}\r\n}\r\n// File: erc721psi/contracts/extension/ERC721PsiBurnable.sol\r\n\r\n\r\n/**\r\n  ______ _____   _____ ______ ___  __ _  _  _ \r\n |  ____|  __ \\ / ____|____  |__ \\/_ | || || |\r\n | |__  | |__) | |        / /   ) || | \\| |/ |\r\n |  __| |  _  /| |       / /   / / | |\\_   _/ \r\n | |____| | \\ \\| |____  / /   / /_ | |  | |   \r\n |______|_|  \\_\\\\_____|/_/   |____||_|  |_|   \r\n                                              \r\n                                            \r\n */\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n\r\nabstract contract ERC721PsiBurnable is ERC721Psi {\r\n    using BitMaps for BitMaps.BitMap;\r\n    BitMaps.BitMap internal _burnedToken;\r\n\r\n    /**\r\n     * @dev Destroys `tokenId`.\r\n     * The approval is cleared when the token is burned.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function _burn(uint256 tokenId) internal virtual {\r\n        address from = ownerOf(tokenId);\r\n        _beforeTokenTransfers(from, address(0), tokenId, 1);\r\n        _burnedToken.set(tokenId);\r\n        \r\n        emit Transfer(from, address(0), tokenId);\r\n\r\n        _afterTokenTransfers(from, address(0), tokenId, 1);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether `tokenId` exists.\r\n     *\r\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\r\n     *\r\n     * Tokens start existing when they are minted (`_mint`),\r\n     * and stop existing when they are burned (`_burn`).\r\n     */\r\n    function _exists(uint256 tokenId) internal view override virtual returns (bool){\r\n        if(_burnedToken.get(tokenId)) {\r\n            return false;\r\n        } \r\n        return super._exists(tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721Enumerable-totalSupply}.\r\n     */\r\n    function totalSupply() public view virtual override returns (uint256) {\r\n        return _totalMinted() - _burned();\r\n    }\r\n\r\n    /**\r\n     * @dev Returns number of token burned.\r\n     */\r\n    function _burned() internal view returns (uint256 burned){\r\n        uint256 startBucket = _startTokenId() >> 8;\r\n        uint256 lastBucket = (_nextTokenId() >> 8) + 1;\r\n\r\n        for(uint256 i=startBucket; i < lastBucket; i++) {\r\n            uint256 bucket = _burnedToken.getBucket(i);\r\n            burned += _popcount(bucket);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns number of set bits.\r\n     */\r\n    function _popcount(uint256 x) private pure returns (uint256 count) {\r\n        unchecked{\r\n            for (count=0; x!=0; count++)\r\n                x &= x - 1;\r\n        }\r\n    }\r\n}\r\n// File: @openzeppelin/contracts/access/Ownable.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the sender is not the owner.\r\n     */\r\n    function _checkOwner() internal view virtual {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n// File: EXO/NEW/EXO.sol\r\n\r\npragma solidity >=0.6.0;\r\n\r\n/// @title Base64\r\n/// @author Brecht Devos - <brecht@loopring.org>\r\n/// @notice Provides functions for encoding/decoding base64\r\nlibrary Base64 {\r\n    string internal constant TABLE_ENCODE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\r\n    bytes  internal constant TABLE_DECODE = hex\"0000000000000000000000000000000000000000000000000000000000000000\"\r\n                                            hex\"00000000000000000000003e0000003f3435363738393a3b3c3d000000000000\"\r\n                                            hex\"00000102030405060708090a0b0c0d0e0f101112131415161718190000000000\"\r\n                                            hex\"001a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132330000000000\";\r\n\r\n    function encode(bytes memory data) internal pure returns (string memory) {\r\n        if (data.length == 0) return '';\r\n\r\n        // load the table into memory\r\n        string memory table = TABLE_ENCODE;\r\n\r\n        // multiply by 4/3 rounded up\r\n        uint256 encodedLen = 4 * ((data.length + 2) / 3);\r\n\r\n        // add some extra buffer at the end required for the writing\r\n        string memory result = new string(encodedLen + 32);\r\n\r\n        assembly {\r\n            // set the actual output length\r\n            mstore(result, encodedLen)\r\n\r\n            // prepare the lookup table\r\n            let tablePtr := add(table, 1)\r\n\r\n            // input ptr\r\n            let dataPtr := data\r\n            let endPtr := add(dataPtr, mload(data))\r\n\r\n            // result ptr, jump over length\r\n            let resultPtr := add(result, 32)\r\n\r\n            // run over the input, 3 bytes at a time\r\n            for {} lt(dataPtr, endPtr) {}\r\n            {\r\n                // read 3 bytes\r\n                dataPtr := add(dataPtr, 3)\r\n                let input := mload(dataPtr)\r\n\r\n                // write 4 characters\r\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\r\n                resultPtr := add(resultPtr, 1)\r\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\r\n                resultPtr := add(resultPtr, 1)\r\n                mstore8(resultPtr, mload(add(tablePtr, and(shr( 6, input), 0x3F))))\r\n                resultPtr := add(resultPtr, 1)\r\n                mstore8(resultPtr, mload(add(tablePtr, and(        input,  0x3F))))\r\n                resultPtr := add(resultPtr, 1)\r\n            }\r\n\r\n            // padding with '='\r\n            switch mod(mload(data), 3)\r\n            case 1 { mstore(sub(resultPtr, 2), shl(240, 0x3d3d)) }\r\n            case 2 { mstore(sub(resultPtr, 1), shl(248, 0x3d)) }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    function decode(string memory _data) internal pure returns (bytes memory) {\r\n        bytes memory data = bytes(_data);\r\n\r\n        if (data.length == 0) return new bytes(0);\r\n        require(data.length % 4 == 0, \"invalid base64 decoder input\");\r\n\r\n        // load the table into memory\r\n        bytes memory table = TABLE_DECODE;\r\n\r\n        // every 4 characters represent 3 bytes\r\n        uint256 decodedLen = (data.length / 4) * 3;\r\n\r\n        // add some extra buffer at the end required for the writing\r\n        bytes memory result = new bytes(decodedLen + 32);\r\n\r\n        assembly {\r\n            // padding with '='\r\n            let lastBytes := mload(add(data, mload(data)))\r\n            if eq(and(lastBytes, 0xFF), 0x3d) {\r\n                decodedLen := sub(decodedLen, 1)\r\n                if eq(and(lastBytes, 0xFFFF), 0x3d3d) {\r\n                    decodedLen := sub(decodedLen, 1)\r\n                }\r\n            }\r\n\r\n            // set the actual output length\r\n            mstore(result, decodedLen)\r\n\r\n            // prepare the lookup table\r\n            let tablePtr := add(table, 1)\r\n\r\n            // input ptr\r\n            let dataPtr := data\r\n            let endPtr := add(dataPtr, mload(data))\r\n\r\n            // result ptr, jump over length\r\n            let resultPtr := add(result, 32)\r\n\r\n            // run over the input, 4 characters at a time\r\n            for {} lt(dataPtr, endPtr) {}\r\n            {\r\n               // read 4 characters\r\n               dataPtr := add(dataPtr, 4)\r\n               let input := mload(dataPtr)\r\n\r\n               // write 3 bytes\r\n               let output := add(\r\n                   add(\r\n                       shl(18, and(mload(add(tablePtr, and(shr(24, input), 0xFF))), 0xFF)),\r\n                       shl(12, and(mload(add(tablePtr, and(shr(16, input), 0xFF))), 0xFF))),\r\n                   add(\r\n                       shl( 6, and(mload(add(tablePtr, and(shr( 8, input), 0xFF))), 0xFF)),\r\n                               and(mload(add(tablePtr, and(        input , 0xFF))), 0xFF)\r\n                    )\r\n                )\r\n                mstore(resultPtr, shl(232, output))\r\n                resultPtr := add(resultPtr, 3)\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\npragma solidity ^0.8.7;\r\n\r\n\r\nabstract contract MerkleProof {\r\n    mapping(uint256 => bytes32) internal _wlMerkleRoot;\r\n    mapping(uint256 => bytes32) internal _alMerkleRoot;\r\n\r\n    uint256 public phaseId;\r\n    function _setWlMerkleRoot(bytes32 merkleRoot_) internal virtual {\r\n        _wlMerkleRoot[phaseId] = merkleRoot_;\r\n    }\r\n\r\n    function _setWlMerkleRootWithId(uint256 _phaseId,bytes32 merkleRoot_) internal virtual {\r\n        _wlMerkleRoot[_phaseId] = merkleRoot_;\r\n    }\r\n    function isWhitelisted(address address_, uint256 _phaseId, uint256 wlCount, bytes32[] memory proof_) public view returns (bool) {\r\n        bytes32 _leaf = keccak256(abi.encodePacked(address_, wlCount));\r\n        for (uint256 i = 0; i < proof_.length; i++) {\r\n            _leaf = _leaf < proof_[i] ? keccak256(abi.encodePacked(_leaf, proof_[i])) : keccak256(abi.encodePacked(proof_[i], _leaf));\r\n        }\r\n        return _leaf == _wlMerkleRoot[_phaseId];\r\n    }\r\n\r\n    function _setAlMerkleRootWithId(uint256 _phaseId,bytes32 merkleRoot_) internal virtual {\r\n        _alMerkleRoot[_phaseId] = merkleRoot_;\r\n    }\r\n\r\n    function _setAlMerkleRoot(bytes32 merkleRoot_) internal virtual {\r\n        _alMerkleRoot[phaseId] = merkleRoot_;\r\n    }\r\n\r\n    function isAllowlisted(address address_,uint256 _alId, bytes32[] memory proof_) public view returns (bool) {\r\n        bytes32 _leaf = keccak256(abi.encodePacked(address_));\r\n        for (uint256 i = 0; i < proof_.length; i++) {\r\n            _leaf = _leaf < proof_[i] ? keccak256(abi.encodePacked(_leaf, proof_[i])) : keccak256(abi.encodePacked(proof_[i], _leaf));\r\n        }\r\n        return _leaf == _alMerkleRoot[_alId];\r\n    }\r\n\r\n}\r\n\r\npragma solidity ^0.8.9;\r\nabstract contract Operable is Context {\r\n    mapping(address => bool) _operators;\r\n    modifier onlyOperator() {\r\n        _checkOperatorRole(_msgSender());\r\n        _;\r\n    }\r\n    function isOperator(address _operator) public view returns (bool) {\r\n        return _operators[_operator];\r\n    }\r\n    function _grantOperatorRole(address _candidate) internal {\r\n        require(\r\n            !_operators[_candidate],\r\n            string(\r\n                abi.encodePacked(\r\n                    \"account \",\r\n                    Strings.toHexString(uint160(_msgSender()), 20),\r\n                    \" is already has an operator role\"\r\n                )\r\n            )\r\n        );\r\n        _operators[_candidate] = true;\r\n    }\r\n    function _revokeOperatorRole(address _candidate) internal {\r\n        _checkOperatorRole(_candidate);\r\n        delete _operators[_candidate];\r\n    }\r\n    function _checkOperatorRole(address _operator) internal view {\r\n        require(\r\n            _operators[_operator],\r\n            string(\r\n                abi.encodePacked(\r\n                    \"account \",\r\n                    Strings.toHexString(uint160(_msgSender()), 20),\r\n                    \" is not an operator\"\r\n                )\r\n            )\r\n        );\r\n    }\r\n}\r\n\r\npragma solidity ^0.8.13;\r\n\r\ninterface IOperatorFilterRegistry {\r\n    function isOperatorAllowed(address registrant, address operator) external view returns (bool);\r\n    function register(address registrant) external;\r\n    function registerAndSubscribe(address registrant, address subscription) external;\r\n    function registerAndCopyEntries(address registrant, address registrantToCopy) external;\r\n    function unregister(address addr) external;\r\n    function updateOperator(address registrant, address operator, bool filtered) external;\r\n    function updateOperators(address registrant, address[] calldata operators, bool filtered) external;\r\n    function updateCodeHash(address registrant, bytes32 codehash, bool filtered) external;\r\n    function updateCodeHashes(address registrant, bytes32[] calldata codeHashes, bool filtered) external;\r\n    function subscribe(address registrant, address registrantToSubscribe) external;\r\n    function unsubscribe(address registrant, bool copyExistingEntries) external;\r\n    function subscriptionOf(address addr) external returns (address registrant);\r\n    function subscribers(address registrant) external returns (address[] memory);\r\n    function subscriberAt(address registrant, uint256 index) external returns (address);\r\n    function copyEntriesOf(address registrant, address registrantToCopy) external;\r\n    function isOperatorFiltered(address registrant, address operator) external returns (bool);\r\n    function isCodeHashOfFiltered(address registrant, address operatorWithCode) external returns (bool);\r\n    function isCodeHashFiltered(address registrant, bytes32 codeHash) external returns (bool);\r\n    function filteredOperators(address addr) external returns (address[] memory);\r\n    function filteredCodeHashes(address addr) external returns (bytes32[] memory);\r\n    function filteredOperatorAt(address registrant, uint256 index) external returns (address);\r\n    function filteredCodeHashAt(address registrant, uint256 index) external returns (bytes32);\r\n    function isRegistered(address addr) external returns (bool);\r\n    function codeHashOf(address addr) external returns (bytes32);\r\n}\r\n\r\npragma solidity ^0.8.13;\r\n\r\n\r\n/**\r\n * @title  OperatorFilterer\r\n * @notice Abstract contract whose constructor automatically registers and optionally subscribes to or copies another\r\n *         registrant's entries in the OperatorFilterRegistry.\r\n * @dev    This smart contract is meant to be inherited by token contracts so they can use the following:\r\n *         - `onlyAllowedOperator` modifier for `transferFrom` and `safeTransferFrom` methods.\r\n *         - `onlyAllowedOperatorApproval` modifier for `approve` and `setApprovalForAll` methods.\r\n */\r\nabstract contract OperatorFilterer {\r\n    error OperatorNotAllowed(address operator);\r\n    bool public operatorFilteringEnabled = true;\r\n\r\n    IOperatorFilterRegistry public constant OPERATOR_FILTER_REGISTRY =\r\n        IOperatorFilterRegistry(0x000000000000AAeB6D7670E522A718067333cd4E);\r\n\r\n    constructor(address subscriptionOrRegistrantToCopy, bool subscribe) {\r\n        // If an inheriting token contract is deployed to a network without the registry deployed, the modifier\r\n        // will not revert, but the contract will need to be registered with the registry once it is deployed in\r\n        // order for the modifier to filter addresses.\r\n        if (address(OPERATOR_FILTER_REGISTRY).code.length > 0) {\r\n            if (subscribe) {\r\n                OPERATOR_FILTER_REGISTRY.registerAndSubscribe(address(this), subscriptionOrRegistrantToCopy);\r\n            } else {\r\n                if (subscriptionOrRegistrantToCopy != address(0)) {\r\n                    OPERATOR_FILTER_REGISTRY.registerAndCopyEntries(address(this), subscriptionOrRegistrantToCopy);\r\n                } else {\r\n                    OPERATOR_FILTER_REGISTRY.register(address(this));\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    modifier onlyAllowedOperator(address from) virtual {\r\n        // Check registry code length to facilitate testing in environments without a deployed registry.\r\n        if (address(OPERATOR_FILTER_REGISTRY).code.length > 0 && operatorFilteringEnabled) {\r\n            // Allow spending tokens from addresses with balance\r\n            // Note that this still allows listings and marketplaces with escrow to transfer tokens if transferred\r\n            // from an EOA.\r\n            if (from == msg.sender) {\r\n                _;\r\n                return;\r\n            }\r\n            if (!OPERATOR_FILTER_REGISTRY.isOperatorAllowed(address(this), msg.sender)) {\r\n                revert OperatorNotAllowed(msg.sender);\r\n            }\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier onlyAllowedOperatorApproval(address operator) virtual {\r\n        // Check registry code length to facilitate testing in environments without a deployed registry.\r\n        if (address(OPERATOR_FILTER_REGISTRY).code.length > 0 && operatorFilteringEnabled) {\r\n            if (!OPERATOR_FILTER_REGISTRY.isOperatorAllowed(address(this), operator)) {\r\n                revert OperatorNotAllowed(operator);\r\n            }\r\n        }\r\n        _;\r\n    }\r\n}\r\n\r\n\r\npragma solidity ^0.8.13;\r\n/**\r\n * @title  DefaultOperatorFilterer\r\n * @notice Inherits from OperatorFilterer and automatically subscribes to the default OpenSea subscription.\r\n */\r\nabstract contract DefaultOperatorFilterer is OperatorFilterer {\r\n    address constant DEFAULT_SUBSCRIPTION = address(0x3cc6CddA760b79bAfa08dF41ECFA224f810dCeB6);\r\n\r\n    constructor() OperatorFilterer(DEFAULT_SUBSCRIPTION, true) {}\r\n}\r\n\r\n\r\n\r\n\r\n\r\npragma solidity >=0.7.0 <0.9.0;\r\n\r\ninterface IContractAllowListProxy {\r\n    function isAllowed(address _transferer, uint256 _level)\r\n        external\r\n        view\r\n        returns (bool);\r\n}\r\n\r\npragma solidity >=0.8.0;\r\n\r\n/// @title IERC721RestrictApprove\r\n/// @dev Approve\u6291\u5236\u6a5f\u80fd\u4ed8\u304d\u30b3\u30f3\u30c8\u30e9\u30af\u30c8\u306e\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30fc\u30b9\r\n/// @author Lavulite\r\n\r\ninterface IERC721RestrictApprove {\r\n    /**\r\n     * @dev CAL\u30ec\u30d9\u30eb\u304c\u5909\u66f4\u3055\u308c\u305f\u5834\u5408\u306e\u30a4\u30d9\u30f3\u30c8\r\n     */\r\n    event CalLevelChanged(address indexed operator, uint256 indexed level);\r\n    \r\n    /**\r\n     * @dev LocalContractAllowListn\u306b\u8ffd\u52a0\u3055\u308c\u305f\u5834\u5408\u306e\u30a4\u30d9\u30f3\u30c8\r\n     */\r\n    event LocalCalAdded(address indexed operator, address indexed transferer);\r\n\r\n    /**\r\n     * @dev LocalContractAllowListn\u306b\u524a\u9664\u3055\u308c\u305f\u5834\u5408\u306e\u30a4\u30d9\u30f3\u30c8\r\n     */\r\n    event LocalCalRemoved(address indexed operator, address indexed transferer);\r\n\r\n    /**\r\n     * @dev CAL\u3092\u5229\u7528\u3059\u308b\u5834\u5408\u306eCAL\u306e\u30ec\u30d9\u30eb\u3092\u8a2d\u5b9a\u3059\u308b\u3002\u30ec\u30d9\u30eb\u304c\u9ad8\u3044\u307b\u3069\u3001\u8a31\u53ef\u3055\u308c\u308b\u30b3\u30f3\u30c8\u30e9\u30af\u30c8\u306e\u7bc4\u56f2\u304c\u72ed\u3044\u3002\r\n     */\r\n    function setCALLevel(uint256 level) external;\r\n\r\n    /**\r\n     * @dev CAL\u306e\u30a2\u30c9\u30ec\u30b9\u3092\u30bb\u30c3\u30c8\u3059\u308b\u3002\r\n     */\r\n    function setCAL(address calAddress) external;\r\n\r\n    /**\r\n     * @dev CAL\u306e\u30ea\u30b9\u30c8\u306b\u7121\u3044\u72ec\u81ea\u306e\u8a31\u53ef\u30a2\u30c9\u30ec\u30b9\u3092\u8ffd\u52a0\u3059\u308b\u5834\u5408\u3001\u3053\u3061\u3089\u306b\u30a2\u30c9\u30ec\u30b9\u3092\u8a18\u8f09\u3059\u308b\u3002\r\n     */\r\n    function addLocalContractAllowList(address transferer) external;\r\n\r\n    /**\r\n     * @dev CAL\u306e\u30ea\u30b9\u30c8\u306b\u3042\u308b\u72ec\u81ea\u306e\u8a31\u53ef\u30a2\u30c9\u30ec\u30b9\u3092\u524a\u9664\u3059\u308b\u5834\u5408\u3001\u3053\u3061\u3089\u306b\u30a2\u30c9\u30ec\u30b9\u3092\u8a18\u8f09\u3059\u308b\u3002\r\n     */\r\n    function removeLocalContractAllowList(address transferer) external;\r\n\r\n    /**\r\n     * @dev CAL\u306e\u30ea\u30b9\u30c8\u306b\u3042\u308b\u72ec\u81ea\u306e\u8a31\u53ef\u30a2\u30c9\u30ec\u30b9\u306e\u4e00\u89a7\u3092\u53d6\u5f97\u3059\u308b\u3002\r\n     */\r\n    function getLocalContractAllowList() external view returns(address[] memory);\r\n\r\n}\r\n\r\npragma solidity >=0.8.0;\r\n\r\n/// @title AntiScam\u6a5f\u80fd\u4ed8\u304dERC721A\r\n/// @dev Readme\u3092\u898b\u3066\u304f\u3060\u3055\u3044\u3002\r\n\r\nabstract contract ERC721RestrictApprove is ERC721PsiBurnable, IERC721RestrictApprove {\r\n    using EnumerableSet for EnumerableSet.AddressSet;\r\n\r\n    IContractAllowListProxy public CAL;\r\n    EnumerableSet.AddressSet localAllowedAddresses;\r\n\r\n    modifier onlyHolder(uint256 tokenId) {\r\n        require(\r\n            msg.sender == ownerOf(tokenId),\r\n            \"RestrictApprove: operation is only holder.\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n    \u5909\u6570\r\n    //////////////////////////////////////////////////////////////*/\r\n    bool public enableRestrict = true;\r\n\r\n    // token lock\r\n    mapping(uint256 => uint256) public tokenCALLevel;\r\n\r\n    // wallet lock\r\n    mapping(address => uint256) public walletCALLevel;\r\n\r\n    // contract lock\r\n    uint256 public CALLevel = 1;\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n    Approve\u6291\u5236\u6a5f\u80fd\u30ed\u30b8\u30c3\u30af\r\n    //////////////////////////////////////////////////////////////*/\r\n    function _addLocalContractAllowList(address transferer)\r\n        internal\r\n        virtual\r\n    {\r\n        localAllowedAddresses.add(transferer);\r\n        emit LocalCalAdded(msg.sender, transferer);\r\n    }\r\n\r\n    function _removeLocalContractAllowList(address transferer)\r\n        internal\r\n        virtual\r\n    {\r\n        localAllowedAddresses.remove(transferer);\r\n        emit LocalCalRemoved(msg.sender, transferer);\r\n    }\r\n\r\n    function _getLocalContractAllowList()\r\n        internal\r\n        virtual\r\n        view\r\n        returns(address[] memory)\r\n    {\r\n        return localAllowedAddresses.values();\r\n    }\r\n\r\n    function _isLocalAllowed(address transferer)\r\n        internal\r\n        view\r\n        virtual\r\n        returns (bool)\r\n    {\r\n        return localAllowedAddresses.contains(transferer);\r\n    }\r\n\r\n    function _isAllowed(address transferer)\r\n        internal\r\n        view\r\n        virtual\r\n        returns (bool)\r\n    {\r\n        return _isAllowed(msg.sender, transferer);\r\n    }\r\n\r\n    function _isAllowed(uint256 tokenId, address transferer)\r\n        internal\r\n        view\r\n        virtual\r\n        returns (bool)\r\n    {\r\n        uint256 level = _getCALLevel(msg.sender, tokenId);\r\n        return _isAllowed(transferer, level);\r\n    }\r\n\r\n    function _isAllowed(address holder, address transferer)\r\n        internal\r\n        view\r\n        virtual\r\n        returns (bool)\r\n    {\r\n        uint256 level = _getCALLevel(holder);\r\n        return _isAllowed(transferer, level);\r\n    }\r\n\r\n    function _isAllowed(address transferer, uint256 level)\r\n        internal\r\n        view\r\n        virtual\r\n        returns (bool)\r\n    {\r\n        if (!enableRestrict) {\r\n            return true;\r\n        }\r\n\r\n        return _isLocalAllowed(transferer) || CAL.isAllowed(transferer, level);\r\n    }\r\n\r\n    function _getCALLevel(address holder, uint256 tokenId)\r\n        internal\r\n        view\r\n        virtual\r\n        returns (uint256)\r\n    {\r\n        if (tokenCALLevel[tokenId] > 0) {\r\n            return tokenCALLevel[tokenId];\r\n        }\r\n\r\n        return _getCALLevel(holder);\r\n    }\r\n\r\n    function _getCALLevel(address holder)\r\n        internal\r\n        view\r\n        virtual\r\n        returns (uint256)\r\n    {\r\n        if (walletCALLevel[holder] > 0) {\r\n            return walletCALLevel[holder];\r\n        }\r\n\r\n        return CALLevel;\r\n    }\r\n\r\n    function _setCAL(address _cal) internal virtual {\r\n        CAL = IContractAllowListProxy(_cal);\r\n    }\r\n\r\n    function _deleteTokenCALLevel(uint256 tokenId) internal virtual {\r\n        delete tokenCALLevel[tokenId];\r\n    }\r\n\r\n    function setTokenCALLevel(uint256 tokenId, uint256 level)\r\n        external\r\n        virtual\r\n        onlyHolder(tokenId)\r\n    {\r\n        tokenCALLevel[tokenId] = level;\r\n    }\r\n\r\n    function setWalletCALLevel(uint256 level)\r\n        external\r\n        virtual\r\n    {\r\n        walletCALLevel[msg.sender] = level;\r\n    }\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                              OVERRIDES\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function isApprovedForAll(address owner, address operator)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (bool)\r\n    {\r\n        if (_isAllowed(owner, operator) == false) {\r\n            return false;\r\n        }\r\n        return super.isApprovedForAll(owner, operator);\r\n    }\r\n\r\n    function setApprovalForAll(address operator, bool approved)\r\n        public\r\n        virtual\r\n        override\r\n    {\r\n        require(\r\n            _isAllowed(operator) || approved == false,\r\n            \"RestrictApprove: Can not approve locked token\"\r\n        );\r\n        super.setApprovalForAll(operator, approved);\r\n    }\r\n\r\n    function _beforeApprove(address to, uint256 tokenId)\r\n        internal\r\n        virtual\r\n    {\r\n        if (to != address(0)) {\r\n            require(_isAllowed(tokenId, to), \"RestrictApprove: The contract is not allowed.\");\r\n        }\r\n    }\r\n\r\n    function approve(address to, uint256 tokenId)\r\n        public\r\n        virtual\r\n        override\r\n    {\r\n        _beforeApprove(to, tokenId);\r\n        super.approve(to, tokenId);\r\n    }\r\n\r\n    function _afterTokenTransfers(\r\n        address from,\r\n        address, /*to*/\r\n        uint256 startTokenId,\r\n        uint256 /*quantity*/\r\n    ) internal virtual override {\r\n        // \u8ee2\u9001\u3084\u30d0\u30fc\u30f3\u306b\u304a\u3044\u3066\u306f\u3001\u5e38\u306bstartTokenId\u306f TokenID\u305d\u306e\u3082\u306e\u3068\u306a\u308a\u307e\u3059\u3002\r\n        if (from != address(0)) {\r\n            // CAL\u30ec\u30d9\u30eb\u3092\u30c7\u30d5\u30a9\u30eb\u30c8\u306b\u623b\u3059\u3002\r\n            _deleteTokenCALLevel(startTokenId);\r\n        }\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceId)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (bool)\r\n    {\r\n        return\r\n            interfaceId == type(IERC721RestrictApprove).interfaceId ||\r\n            super.supportsInterface(interfaceId);\r\n    }\r\n}\r\n\r\n\r\npragma solidity ^0.8.7;\r\n/*\r\n\u250f\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2533\u2501\u2501\u2513\u254b\u250f\u2501\u2501\u2501\u2533\u2501\u2513\u254b\u250f\u2533\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2533\u2513\u250f\u2501\u2533\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2513\r\n\u2503\u250f\u2501\u2513\u2503\u250f\u2501\u2501\u252b\u250f\u2513\u2503\u254b\u2503\u250f\u2501\u2513\u2503\u2503\u2517\u2513\u2503\u2503\u250f\u2501\u2501\u252b\u250f\u2501\u2513\u2503\u2503\u2503\u250f\u252b\u250f\u2501\u2501\u252b\u250f\u2501\u2513\u2503\r\n\u2503\u2503\u254b\u2503\u2503\u2517\u2501\u2501\u252b\u2517\u251b\u2517\u2513\u2503\u2517\u2501\u2501\u252b\u250f\u2513\u2517\u251b\u2503\u2517\u2501\u2501\u252b\u2503\u254b\u2503\u2503\u2517\u251b\u251b\u2503\u2517\u2501\u2501\u252b\u2517\u2501\u251b\u2503\r\n\u2503\u2517\u2501\u251b\u2503\u250f\u2501\u2501\u252b\u250f\u2501\u2513\u2503\u2517\u2501\u2501\u2513\u2503\u2503\u2517\u2513\u2503\u2503\u250f\u2501\u2501\u252b\u2517\u2501\u251b\u2503\u250f\u2513\u2503\u2503\u250f\u2501\u2501\u252b\u250f\u2513\u250f\u251b\r\n\u2503\u250f\u2501\u2513\u2503\u2517\u2501\u2501\u252b\u2517\u2501\u251b\u2503\u2503\u2517\u2501\u251b\u2503\u2503\u254b\u2503\u2503\u2503\u2517\u2501\u2501\u252b\u250f\u2501\u2513\u2503\u2503\u2503\u2517\u252b\u2517\u2501\u2501\u252b\u2503\u2503\u2517\u2513\r\n\u2517\u251b\u254b\u2517\u253b\u2501\u2501\u2501\u253b\u2501\u2501\u2501\u251b\u2517\u2501\u2501\u2501\u253b\u251b\u254b\u2517\u2501\u253b\u2501\u2501\u2501\u253b\u251b\u254b\u2517\u253b\u251b\u2517\u2501\u253b\u2501\u2501\u2501\u253b\u251b\u2517\u2501\u251b\r\n*/\r\ncontract AEBSNEAKER is Ownable, ERC721RestrictApprove, ReentrancyGuard, MerkleProof, ERC2981, DefaultOperatorFilterer,Operable {\r\n  //Project Settings\r\n  mapping(uint256 => uint256) public alMintPrice;\r\n  uint256 public psMintPrice = 0.05 ether;\r\n  uint256 public wlMintPrice;  \r\n  mapping(uint256 => uint256) public maxMintsPerAL;\r\n  uint256 public maxMintsPerPS = 99;\r\n  uint256 public maxMintsPerALOT = 99;\r\n  uint256 public maxMintsPerPSOT = 99;\r\n  uint256 public maxSupply;\r\n  uint256 public mintable;\r\n  uint256 public revealed = 100;\r\n  uint256 public nowPhaseWl;\r\n  uint256 public nowPhaseAl;\r\n  uint256 public nowPhasePs;\r\n\r\n  address internal _withdrawWallet;\r\n  address internal _aa;\r\n  address internal _bb;\r\n  address internal _cc;\r\n  address internal _dd;\r\n  address internal _ee;\r\n  address internal _ff;\r\n\r\n  uint256 internal _aaPerc;\r\n  uint256 internal _bbPerc;\r\n  uint256 internal _ccPerc;\r\n  uint256 internal _ddPerc;\r\n  uint256 internal _eePerc;\r\n  uint256 internal _ffPerc;\r\n\r\n  //URI\r\n  string internal hiddenURI;\r\n  string internal _baseTokenURI;\r\n  string public _baseExtension = \".json\";\r\n\r\n  //flags\r\n  mapping(uint256 => bool) public isWlSaleEnabled;\r\n  mapping(uint256 => bool) public isAlSaleEnabled;\r\n  bool public isPublicSaleEnabled;\r\n  bool internal lockBurn = false;\r\n\r\n  //mint records.\r\n  mapping(uint256 => uint256) public phaseIds;\r\n  mapping(uint256 => mapping(address => uint256)) internal _wlMinted;\r\n  mapping(uint256 => mapping(uint256 => mapping(address => uint256))) internal _alMinted;\r\n  mapping(uint256 => mapping(address => uint256)) internal _psMinted;\r\n  \r\n  constructor (\r\n    address _royaltyReceiver,\r\n    uint96 _royaltyFraction,\r\n    uint256 _aaPercAdd\r\n  ) ERC721Psi (\"AEB Sneaker Collection\",\"AEBS\") {\r\n    _grantOperatorRole(msg.sender);\r\n    _grantOperatorRole(_royaltyReceiver);\r\n    _setDefaultRoyalty(_royaltyReceiver,_royaltyFraction);\r\n    //CAL initialization\r\n    setCALLevel(1);\r\n    _setCAL(0xF2A78c73ffBAB6ECc3548Acc54B546ace279312E);//Ethereum mainnet proxy\r\n    _addLocalContractAllowList(0x1E0049783F008A0085193E00003D00cd54003c71);//OpenSea\r\n    _addLocalContractAllowList(0x4feE7B061C97C9c496b01DbcE9CDb10c02f0a0Be);//Rarible\r\n    _aa = msg.sender;\r\n    _aaPerc = _aaPercAdd;\r\n  }\r\n  //start from 1.adjust.\r\n  function _startTokenId() internal pure virtual override returns (uint256) {\r\n        return 1;\r\n  }\r\n  //set Default Royalty._feeNumerator 500 = 5% Royalty\r\n  function setDefaultRoyalty(address _receiver, uint96 _feeNumerator) external virtual onlyOperator {\r\n      _setDefaultRoyalty(_receiver, _feeNumerator);\r\n  }\r\n  //for ERC2981\r\n  function supportsInterface(bytes4 interfaceId) public view virtual override(ERC721RestrictApprove, ERC2981) returns (bool) {\r\n    return super.supportsInterface(interfaceId);\r\n  }\r\n  //for ERC2981 Opensea\r\n  function contractURI() external view virtual returns (string memory) {\r\n        return _formatContractURI();\r\n  }\r\n  //make contractURI\r\n  function _formatContractURI() internal view returns (string memory) {\r\n    (address receiver, uint256 royaltyFraction) = royaltyInfo(0,_feeDenominator());//tokenid=0\r\n    return string(\r\n      abi.encodePacked(\r\n        \"data:application/json;base64,\",\r\n        Base64.encode(\r\n          bytes(\r\n            abi.encodePacked(\r\n                '{\"seller_fee_basis_points\":', Strings.toString(royaltyFraction),\r\n                ', \"fee_recipient\":\"', Strings.toHexString(uint256(uint160(receiver)), 20), '\"}'\r\n            )\r\n          )\r\n        )\r\n      )\r\n    );\r\n  }\r\n  //set maxSupply.only owner.\r\n  function setMaxSupply(uint256 _maxSupply) external virtual onlyOperator {\r\n    maxSupply = _maxSupply;\r\n  }\r\n  //set mintable.only owner.\r\n  function setMintable(uint256 _mintable) external virtual onlyOperator {\r\n    mintable = _mintable;\r\n  }\r\n    // GET phaseId.\r\n  function getPhaseIds(uint256 _alId) external view virtual returns (uint256){\r\n    return phaseIds[_alId];\r\n  }\r\n    // SET phaseId.\r\n  function setPhaseId(uint256 _alId,uint256 _phaseId) external virtual onlyOperator {\r\n    phaseIds[_alId] = _phaseId;\r\n  }\r\n    // SET phaseId.\r\n  function setPhaseIdWithReset(uint256 _alId,uint256 _phaseId) external virtual onlyOperator {\r\n    phaseIds[_alId] = _phaseId;\r\n    nowPhaseAl += 1;\r\n  }\r\n  function setNowPhaseWl(uint256 _nowPhaseWl) external virtual onlyOperator {\r\n    nowPhaseWl = _nowPhaseWl;\r\n  }\r\n  function setNowPhaseAl(uint256 _nowPhaseAl) external virtual onlyOperator {\r\n    nowPhaseAl = _nowPhaseAl;\r\n  }\r\n  function setNowPhasePs(uint256 _nowPhasePs) external virtual onlyOperator {\r\n    nowPhasePs = _nowPhasePs;\r\n  }\r\n  // SET PRICES.\r\n  //WL.Price\r\n  function setWlPrice(uint256 newPrice) external virtual onlyOperator {\r\n    wlMintPrice = newPrice;\r\n  }\r\n  //AL.Price\r\n  function setAlPrice(uint256 _alId,uint256 newPrice) external virtual onlyOperator {\r\n    alMintPrice[_alId] = newPrice;\r\n  }\r\n  //PS.Price\r\n  function setPsPrice(uint256 newPrice) external virtual onlyOperator {\r\n    psMintPrice = newPrice;\r\n  }\r\n  //set reveal.only owner.\r\n  function setReveal(uint256 newRevealNum) external virtual onlyOperator {\r\n    revealed = newRevealNum;\r\n  }\r\n  //return _isRevealed()\r\n  function _isRevealed(uint256 _tokenId) internal view virtual returns (bool){\r\n    return _tokenId <= revealed;\r\n  }\r\n  // GET MINTED COUNT.\r\n  function wlMinted(address _address) external view virtual returns (uint256){\r\n    return _wlMinted[nowPhaseWl][_address];\r\n  }\r\n  function alMinted(address _address) external view virtual returns (uint256){\r\n    return _alMinted[nowPhaseAl][phaseIds[nowPhaseAl]][_address];\r\n  }\r\n  function alIdMinted(uint256 _nowPhaseAl,address _address) external view virtual returns (uint256){\r\n    return _alMinted[_nowPhaseAl][phaseIds[_nowPhaseAl]][_address];\r\n  }\r\n  function psMinted(address _address) external view virtual returns (uint256){\r\n    return _psMinted[nowPhasePs][_address];\r\n  }\r\n  // SET MAX MINTS.\r\n  //get.AL.mxmints\r\n  function getAlMaxMints() external view virtual returns (uint256){\r\n    return maxMintsPerAL[phaseId];\r\n  }\r\n  //set.AL.mxmints\r\n  function setAlMaxMints(uint256 _alId,uint256 _max) external virtual onlyOperator {\r\n    maxMintsPerAL[_alId] = _max;\r\n  }\r\n  //PS.mxmints\r\n  function setPsMaxMints(uint256 _max) external virtual onlyOperator {\r\n    maxMintsPerPS = _max;\r\n  }\r\n  // SET SALES ENABLE.\r\n  //WL.SaleEnable\r\n  function setWhitelistSaleEnable(uint256 _phaseId,bool bool_) external virtual onlyOperator {\r\n    isWlSaleEnabled[_phaseId] = bool_;\r\n  }\r\n  //AL.SaleEnable\r\n  function setAllowlistSaleEnable(uint256 _alId,bool bool_) external virtual onlyOperator {\r\n    isAlSaleEnabled[_alId] = bool_;\r\n  }\r\n  //PS.SaleEnable\r\n  function setPublicSaleEnable(bool bool_) external virtual onlyOperator {\r\n    isPublicSaleEnabled = bool_;\r\n  }\r\n\r\n  function setMerkleRootWl(bytes32 merkleRoot_) external virtual onlyOperator {\r\n    _setWlMerkleRoot(merkleRoot_);\r\n  }\r\n\r\n  function setMerkleRootWlWithId(uint256 _phaseId,bytes32 merkleRoot_) external virtual onlyOperator {\r\n    _setWlMerkleRootWithId(_phaseId,merkleRoot_);\r\n  }\r\n\r\n  function setMerkleRootAlWithId(uint256 _phaseId,bytes32 merkleRoot_) external virtual onlyOperator {\r\n    _setAlMerkleRootWithId(_phaseId,merkleRoot_);\r\n  }\r\n  //set HiddenBaseURI.only owner.\r\n  function setHiddenURI(string memory uri_) external virtual onlyOperator {\r\n    hiddenURI = uri_;\r\n  }\r\n  //return _currentIndex\r\n  function getCurrentIndex() external view virtual returns (uint256){\r\n    return _nextTokenId() -1;\r\n  }\r\n  /** @dev set BaseURI at after reveal. only owner. */\r\n  function setBaseURI(string memory uri_) external virtual onlyOperator {\r\n    _baseTokenURI = uri_;\r\n  }\r\n\r\n  function setBaseExtension(string memory _newBaseExtension) external onlyOperator\r\n  {\r\n    _baseExtension = _newBaseExtension;\r\n  }\r\n\r\n  /** @dev BaseURI.internal. */\r\n  function _currentBaseURI() internal view returns (string memory){\r\n    return _baseTokenURI;\r\n  }\r\n\r\n  function tokenURI(uint256 _tokenId) public view virtual override returns (string memory) {\r\n    require(_exists(_tokenId), \"URI query for nonexistent token\");\r\n    if(_isRevealed(_tokenId)){\r\n        return string(abi.encodePacked(_currentBaseURI(), Strings.toString(_tokenId), _baseExtension));\r\n    }\r\n    return hiddenURI;\r\n  }\r\n  \r\n  /** @dev owner mint.transfer to _address.only owner. */\r\n  function ownerMintSafe(uint256 _amount, address _address) external virtual onlyOperator { \r\n    require((_amount + totalSupply()) <= (maxSupply) || maxSupply == 0, \"No more NFTs\");\r\n    _safeMint(_address, _amount);\r\n  }\r\n  \r\n  //WL mint.\r\n  function whitelistMint(uint256 _phaseId,uint256 _amount, uint256 wlcount, bytes32[] memory proof_) external payable virtual nonReentrant {\r\n    require(isWlSaleEnabled[_phaseId], \"whitelistMint is Paused\");\r\n    require(isWhitelisted(msg.sender,_phaseId, wlcount, proof_), \"You are not whitelisted!\");\r\n    require(wlcount > 0, \"You have no WL!\");\r\n    require(wlcount >= _amount, \"whitelistMint: Over max mints per wallet\");\r\n    require(wlcount >= _wlMinted[_phaseId][msg.sender] + _amount, \"You have no whitelistMint left\");\r\n    require(msg.value == wlMintPrice * _amount, \"ETH value is not correct\");\r\n    require((_amount + totalSupply()) <= (mintable) || mintable == 0, \"No more NFTs\");\r\n    _wlMinted[_phaseId][msg.sender] += _amount;\r\n    _safeMint(msg.sender, _amount);\r\n  }\r\n  \r\n  //AL mint.\r\n  function allowlistMint(uint256 _alId,uint256 _amount, bytes32[] memory proof_) external payable virtual nonReentrant {\r\n    require(isAlSaleEnabled[_alId], \"allowlistMint is Paused\");\r\n    require(isAllowlisted(msg.sender,_alId, proof_), \"You are not whitelisted!\");\r\n    require(maxMintsPerALOT >= _amount, \"allowlistMint: Over max mints per one time\");\r\n    require(maxMintsPerAL[_alId] >= _amount, \"allowlistMint: Over max mints per wallet\");\r\n    require(maxMintsPerAL[_alId] >= _alMinted[_alId][phaseIds[_alId]][msg.sender] + _amount, \"You have no whitelistMint left\");\r\n    require(msg.value == alMintPrice[_alId] * _amount, \"ETH value is not correct\");\r\n    require((_amount + totalSupply()) <= (mintable) || mintable == 0, \"No more NFTs\");\r\n    _alMinted[_alId][phaseIds[_alId]][msg.sender] += _amount;\r\n    _safeMint(msg.sender, _amount);\r\n  }\r\n\r\n  //Public mint.\r\n  function publicMint(uint256 _amount) external payable virtual nonReentrant {\r\n    require(isPublicSaleEnabled, \"publicMint is Paused\");\r\n    require(maxMintsPerPSOT >= _amount, \"publicMint: Over max mints per one time\");\r\n    require(maxMintsPerPS >= _amount, \"publicMint: Over max mints per wallet\");\r\n    require(maxMintsPerPS >= _psMinted[nowPhasePs][msg.sender] + _amount, \"You have no publicMint left\");\r\n    require(msg.value == psMintPrice * _amount, \"ETH value is not correct\");\r\n    require((_amount + totalSupply()) <= (mintable) || mintable == 0, \"No more NFTs\");\r\n    _psMinted[nowPhasePs][msg.sender] += _amount;\r\n    _safeMint(msg.sender, _amount);\r\n  }\r\n\r\n  /** @dev receive. */\r\n  function receiveToDeb() external payable virtual onlyOperator nonReentrant {\r\n      require(msg.value > 0, \"ETH value is not correct\");\r\n  }\r\n\r\n  /** @dev widraw ETH from this contract.only operator. */\r\n  function withdraw() external payable virtual onlyOperator nonReentrant{\r\n    require((_aa != address(0) && _aaPerc != 0) || _aa == address(0),\"please set withdraw Address_aa and percentage.\");\r\n    require((_bb != address(0) && _bbPerc != 0) || _bb == address(0),\"please set withdraw Address_bb and percentage.\");\r\n    require((_cc != address(0) && _ccPerc != 0) || _cc == address(0),\"please set withdraw Address_cc and percentage.\");\r\n    require((_dd != address(0) && _ddPerc != 0) || _dd == address(0),\"please set withdraw Address_dd and percentage.\");\r\n    require((_ee != address(0) && _eePerc != 0) || _ee == address(0),\"please set withdraw Address_ee and percentage.\");\r\n    require((_ff != address(0) && _ffPerc != 0) || _ff == address(0),\"please set withdraw Address_ff and percentage.\");\r\n    uint256 _ethBalance = address(this).balance;\r\n    bool os;\r\n    if(_aa != address(0)){//if _aa has.\r\n        (os, ) = payable(_aa).call{value: (_ethBalance * _aaPerc/10000)}(\"\");\r\n        require(os, \"Failed to withdraw_aa Ether\");\r\n    }\r\n    if(_bb != address(0)){//if _bb has.\r\n        (os, ) = payable(_bb).call{value: (_ethBalance * _bbPerc/10000)}(\"\");\r\n        require(os, \"Failed to withdraw_bb Ether\");\r\n    }\r\n    if(_cc != address(0)){//if _cc has.\r\n        (os, ) = payable(_cc).call{value: (_ethBalance * _ccPerc/10000)}(\"\");\r\n        require(os, \"Failed to withdraw_cc Ether\");\r\n    }\r\n    if(_dd != address(0)){//if _dd has.\r\n        (os, ) = payable(_dd).call{value: (_ethBalance * _ddPerc/10000)}(\"\");\r\n        require(os, \"Failed to withdraw_dd Ether\");\r\n    }\r\n    if(_ee != address(0)){//if _ee has.\r\n        (os, ) = payable(_ee).call{value: (_ethBalance * _eePerc/10000)}(\"\");\r\n        require(os, \"Failed to withdraw_ee Ether\");\r\n    }\r\n    if(_ff != address(0)){//if _ff has.\r\n        (os, ) = payable(_ff).call{value: (_ethBalance * _ffPerc/10000)}(\"\");\r\n        require(os, \"Failed to withdraw_ff Ether\");\r\n    }\r\n    _ethBalance = address(this).balance;\r\n    if(_withdrawWallet != address(0)){//if _withdrawWallet has.\r\n        (os, ) = payable(_withdrawWallet).call{value: (_ethBalance)}(\"\");\r\n    }else{\r\n        (os, ) = payable(owner()).call{value: (_ethBalance)}(\"\");\r\n    }\r\n    require(os, \"Failed to withdraw Ether\");\r\n  }\r\n\r\n    //burn\r\n    function burn(uint256 tokenId) external virtual {\r\n        require(ownerOf(tokenId) == msg.sender, \"isnt owner token\");\r\n        require(lockBurn == false, \"not allow\");\r\n        _burn(tokenId);\r\n    }\r\n    // //set.LockBurn\r\n    function setLockBurn(bool bool_) external virtual onlyOperator {\r\n        lockBurn = bool_;\r\n    }\r\n\r\n  //return wallet owned tokenids.\r\n  function walletOfOwner(address _address) external view virtual returns (uint256[] memory) {\r\n    uint256 ownerTokenCount = balanceOf(_address);\r\n    uint256[] memory tokenIds = new uint256[](ownerTokenCount);\r\n    //search from all tonkenid. so spend high gas values.attention.\r\n    uint256 tokenindex = 0;\r\n    for (uint256 i = _startTokenId(); i < (_nextTokenId() -1); i++) {\r\n      if(_address == this.tryOwnerOf(i)) tokenIds[tokenindex++] = i;\r\n    }\r\n    return tokenIds;\r\n  }\r\n\r\n    //try catch vaersion ownerOf. support burned tokenid.\r\n    function tryOwnerOf(uint256 tokenId) external view  virtual returns (address) {\r\n        try this.ownerOf(tokenId) returns (address _address) {\r\n            return(_address);\r\n        } catch {\r\n            return (address(0));//return 0x0 if error.\r\n        }\r\n    }\r\n\r\n  /**\r\n    @dev set aa's wallet and fraction.withdraw to this wallet.only operator.\r\n    */\r\n  function setWallet__aa(address _owner,uint256 _perc) external virtual onlyOperator {\r\n    _aa = _owner;\r\n    _aaPerc = _perc;\r\n  }\r\n\r\n  /**\r\n    @dev set bb's wallet and fraction.withdraw to this wallet.only operator.\r\n    */\r\n  function setWallet__bb(address _owner,uint256 _perc) external virtual onlyOperator {\r\n    _bb = _owner;\r\n    _bbPerc = _perc;\r\n  }\r\n\r\n  /**\r\n    @dev set cc's wallet and fraction.withdraw to this wallet.only operator.\r\n    */\r\n  function setWallet__cc(address _owner,uint256 _perc) external virtual onlyOperator {\r\n    _cc = _owner;\r\n    _ccPerc = _perc;\r\n  }\r\n\r\n  /**\r\n    @dev set dd's wallet and fraction.withdraw to this wallet.only operator.\r\n    */\r\n  function setWallet__dd(address _owner,uint256 _perc) external virtual onlyOperator {\r\n    _dd = _owner;\r\n    _ddPerc = _perc;\r\n  }\r\n\r\n  /**\r\n    @dev set ee's wallet and fraction.withdraw to this wallet.only operator.\r\n    */\r\n  function setWallet__ee(address _owner,uint256 _perc) external virtual onlyOperator {\r\n    _ee = _owner;\r\n    _eePerc = _perc;\r\n  }\r\n\r\n  /**\r\n    @dev set ff's wallet and fraction.withdraw to this wallet.only operator.\r\n    */\r\n  function setWallet__ff(address _owner,uint256 _perc) external virtual onlyOperator {\r\n    _ff = _owner;\r\n    _ffPerc = _perc;\r\n  }\r\n  /**\r\n    @dev set withdraw's wallet.withdraw to this wallet.only operator.\r\n    */\r\n  function setWallet__ww(address _owner) external virtual onlyOperator {\r\n    _withdrawWallet = _owner;\r\n  }\r\n\r\n    //OPENSEA.OPERATORFilterer.START\r\n    /**\r\n     * @notice Set the state of the OpenSea operator filter\r\n     * @param value Flag indicating if the operator filter should be applied to transfers and approvals\r\n     */\r\n    function setOperatorFilteringEnabled(bool value) external onlyOperator {\r\n        operatorFilteringEnabled = value;\r\n    }\r\n\r\n    function setApprovalForAll(address operator, bool approved) public override onlyAllowedOperatorApproval(operator) {\r\n        super.setApprovalForAll(operator, approved);\r\n    }\r\n\r\n    function approve(address operator, uint256 tokenId) public override onlyAllowedOperatorApproval(operator) {\r\n        super.approve(operator, tokenId);\r\n    }\r\n\r\n    function transferFrom(address from, address to, uint256 tokenId) public override onlyAllowedOperator(from) {\r\n        super.transferFrom(from, to, tokenId);\r\n    }\r\n\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) public override onlyAllowedOperator(from) {\r\n        super.safeTransferFrom(from, to, tokenId);\r\n    }\r\n\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data)\r\n        public\r\n        override\r\n        onlyAllowedOperator(from)\r\n    {\r\n        super.safeTransferFrom(from, to, tokenId, data);\r\n    }\r\n    //OPENSEA.OPERATORFilterer.END\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                    OVERRIDES ERC721RestrictApprove\r\n    //////////////////////////////////////////////////////////////*/\r\n    function addLocalContractAllowList(address transferer)\r\n        external\r\n        override\r\n        onlyOperator\r\n    {\r\n        _addLocalContractAllowList(transferer);\r\n    }\r\n\r\n    function removeLocalContractAllowList(address transferer)\r\n        external\r\n        override\r\n        onlyOperator\r\n    {\r\n        _removeLocalContractAllowList(transferer);\r\n    }\r\n\r\n    function getLocalContractAllowList()\r\n        external\r\n        override\r\n        view\r\n        returns(address[] memory)\r\n    {\r\n        return _getLocalContractAllowList();\r\n    }\r\n\r\n    function setCALLevel(uint256 level) public override onlyOperator {\r\n        CALLevel = level;\r\n    }\r\n\r\n    function setCAL(address calAddress) external override onlyOperator {\r\n        _setCAL(calAddress);\r\n    }\r\n\r\n    /**\r\n        @dev Operable.Role.ADD\r\n     */\r\n    function grantOperatorRole(address _candidate) external onlyOwner {\r\n        _grantOperatorRole(_candidate);\r\n    }\r\n    /**\r\n        @dev Operable.Role.REMOVE\r\n     */\r\n    function revokeOperatorRole(address _candidate) external onlyOwner {\r\n        _revokeOperatorRole(_candidate);\r\n    }\r\n    \r\n}\r\n//CODE.BY.FRICKLIK", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_royaltyReceiver\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"_royaltyFraction\",\"type\":\"uint96\"},{\"internalType\":\"uint256\",\"name\":\"_aaPercAdd\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"OperatorNotAllowed\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"}],\"name\":\"CalLevelChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"transferer\",\"type\":\"address\"}],\"name\":\"LocalCalAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"transferer\",\"type\":\"address\"}],\"name\":\"LocalCalRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CAL\",\"outputs\":[{\"internalType\":\"contract IContractAllowListProxy\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CALLevel\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"OPERATOR_FILTER_REGISTRY\",\"outputs\":[{\"internalType\":\"contract IOperatorFilterRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_baseExtension\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"transferer\",\"type\":\"address\"}],\"name\":\"addLocalContractAllowList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nowPhaseAl\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"alIdMinted\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"alMintPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"alMinted\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_alId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof_\",\"type\":\"bytes32[]\"}],\"name\":\"allowlistMint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enableRestrict\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAlMaxMints\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLocalContractAllowList\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_alId\",\"type\":\"uint256\"}],\"name\":\"getPhaseIds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_candidate\",\"type\":\"address\"}],\"name\":\"grantOperatorRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"isAlSaleEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"address_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_alId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof_\",\"type\":\"bytes32[]\"}],\"name\":\"isAllowlisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isOperator\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isPublicSaleEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"address_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_phaseId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"wlCount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof_\",\"type\":\"bytes32[]\"}],\"name\":\"isWhitelisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"isWlSaleEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"maxMintsPerAL\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxMintsPerALOT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxMintsPerPS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxMintsPerPSOT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nowPhaseAl\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nowPhasePs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nowPhaseWl\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"operatorFilteringEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"ownerMintSafe\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"phaseId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"phaseIds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"psMintPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"psMinted\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"publicMint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"receiveToDeb\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"transferer\",\"type\":\"address\"}],\"name\":\"removeLocalContractAllowList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"revealed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_candidate\",\"type\":\"address\"}],\"name\":\"revokeOperatorRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_salePrice\",\"type\":\"uint256\"}],\"name\":\"royaltyInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_alId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_max\",\"type\":\"uint256\"}],\"name\":\"setAlMaxMints\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_alId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newPrice\",\"type\":\"uint256\"}],\"name\":\"setAlPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_alId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"bool_\",\"type\":\"bool\"}],\"name\":\"setAllowlistSaleEnable\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_newBaseExtension\",\"type\":\"string\"}],\"name\":\"setBaseExtension\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"uri_\",\"type\":\"string\"}],\"name\":\"setBaseURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"calAddress\",\"type\":\"address\"}],\"name\":\"setCAL\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"}],\"name\":\"setCALLevel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"_feeNumerator\",\"type\":\"uint96\"}],\"name\":\"setDefaultRoyalty\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"uri_\",\"type\":\"string\"}],\"name\":\"setHiddenURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"bool_\",\"type\":\"bool\"}],\"name\":\"setLockBurn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxSupply\",\"type\":\"uint256\"}],\"name\":\"setMaxSupply\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_phaseId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"merkleRoot_\",\"type\":\"bytes32\"}],\"name\":\"setMerkleRootAlWithId\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"merkleRoot_\",\"type\":\"bytes32\"}],\"name\":\"setMerkleRootWl\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_phaseId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"merkleRoot_\",\"type\":\"bytes32\"}],\"name\":\"setMerkleRootWlWithId\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_mintable\",\"type\":\"uint256\"}],\"name\":\"setMintable\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nowPhaseAl\",\"type\":\"uint256\"}],\"name\":\"setNowPhaseAl\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nowPhasePs\",\"type\":\"uint256\"}],\"name\":\"setNowPhasePs\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nowPhaseWl\",\"type\":\"uint256\"}],\"name\":\"setNowPhaseWl\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"setOperatorFilteringEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_alId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_phaseId\",\"type\":\"uint256\"}],\"name\":\"setPhaseId\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_alId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_phaseId\",\"type\":\"uint256\"}],\"name\":\"setPhaseIdWithReset\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_max\",\"type\":\"uint256\"}],\"name\":\"setPsMaxMints\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newPrice\",\"type\":\"uint256\"}],\"name\":\"setPsPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"bool_\",\"type\":\"bool\"}],\"name\":\"setPublicSaleEnable\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newRevealNum\",\"type\":\"uint256\"}],\"name\":\"setReveal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"}],\"name\":\"setTokenCALLevel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"}],\"name\":\"setWalletCALLevel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_perc\",\"type\":\"uint256\"}],\"name\":\"setWallet__aa\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_perc\",\"type\":\"uint256\"}],\"name\":\"setWallet__bb\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_perc\",\"type\":\"uint256\"}],\"name\":\"setWallet__cc\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_perc\",\"type\":\"uint256\"}],\"name\":\"setWallet__dd\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_perc\",\"type\":\"uint256\"}],\"name\":\"setWallet__ee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_perc\",\"type\":\"uint256\"}],\"name\":\"setWallet__ff\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"setWallet__ww\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_phaseId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"bool_\",\"type\":\"bool\"}],\"name\":\"setWhitelistSaleEnable\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newPrice\",\"type\":\"uint256\"}],\"name\":\"setWlPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenCALLevel\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"tokensOfOwner\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tryOwnerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"walletCALLevel\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"walletOfOwner\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_phaseId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"wlcount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof_\",\"type\":\"bytes32[]\"}],\"name\":\"whitelistMint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wlMintPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"wlMinted\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "AEBSNEAKER", "CompilerVersion": "v0.8.21+commit.d9974bed", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000027d2210a381e7d5921fbb4df6fa39fd875cecb5700000000000000000000000000000000000000000000000000000000000003e800000000000000000000000000000000000000000000000000000000000003e8", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://108a4277ae1bb308c5441592e4576777a4db3fd7698c0924fc3b31651e5cbc92"}