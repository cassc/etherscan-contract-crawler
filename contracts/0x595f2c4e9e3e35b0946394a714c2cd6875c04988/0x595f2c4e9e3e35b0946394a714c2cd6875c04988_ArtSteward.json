{"SourceCode": "{\"Address.sol\":{\"content\":\"pragma solidity ^0.6.2;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\n        // for accounts without code, i.e. `keccak256(\\u0027\\u0027)`\\n        bytes32 codehash;\\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { codehash := extcodehash(account) }\\n        return (codehash != accountHash \\u0026\\u0026 codehash != 0x0);\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity\\u0027s `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance \\u003e= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n}\"},\"ArtSteward.sol\":{\"content\":\"pragma solidity ^0.6.6;\\nimport \\\"./IERC721.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\n\\n// What changed for V2 (June 2020 update):\\n// - Medium Severity Fixes:\\n// - Added a check on buy to prevent front-running. Needs to give currentPrice when buying.\\n// - Removed ability for someone to block buying through revert on ETH send. Funds get sent to a pull location.\\n// - Added patron check on depositWei. Since anyone can send, it can be front-run, stealing a deposit by buying before deposit clears.\\n// - Other Minor Changes:\\n// - Added past foreclosureTime() if it happened in the past.\\n// - Moved patron modifier checks to AFTER patronage. Thus, not necessary to have steward state anymore.\\n// - Removed steward state. Only check on price now. If price = zero = foreclosed. \\n// - Removed paid mapping. Wasn\\u0027t used.\\n// - Moved constructor to a function in case this is used with upgradeable contracts.\\n// - Changed currentCollected into a view function rather than tracking variable. This fixed a bug where CC would keep growing in between ownerships.\\n// - Kept the numerator/denominator code (for reference), but removed to save gas costs for 100% patronage rate.\\n\\n// - Changes for UI:\\n// - Need to have additional current price when buying.\\n// - foreclosureTime() will now backdate if past foreclose time.\\n\\ncontract ArtSteward {\\n    \\n    /*\\n    This smart contract collects patronage from current owner through a Harberger tax model and \\n    takes stewardship of the artwork if the patron can\\u0027t pay anymore.\\n\\n    Harberger Tax (COST): \\n    - Artwork is always on sale.\\n    - You have to have a price set.\\n    - Tax (Patronage) is paid to maintain ownership.\\n    - Steward maints control over ERC721.\\n    */\\n    using SafeMath for uint256;\\n    \\n    uint256 public price; //in wei\\n    IERC721 public art; // ERC721 NFT.\\n    \\n    uint256 public totalCollected; // all patronage ever collected\\n\\n    /* In the event that a foreclosure happens AFTER it should have been foreclosed already,\\n    this variable is backdated to when it should\\u0027ve occurred. Thus: timeHeld is accurate to actual deposit. */\\n    uint256 public timeLastCollected; // timestamp when last collection occurred\\n    uint256 public deposit; // funds for paying patronage\\n    address payable public artist; // beneficiary\\n    uint256 public artistFund; // what artist has earned and can withdraw\\n\\n    /*\\n    If for whatever reason the transfer fails when being sold,\\n    it\\u0027s added to a pullFunds such that previous owner can withdraw it.\\n    */\\n    mapping (address =\\u003e uint256) public pullFunds; // storage area in case a sale can\\u0027t send the funds towards previous owner.\\n    mapping (address =\\u003e bool) public patrons; // list of whom have owned it\\n    mapping (address =\\u003e uint256) public timeHeld; // time held by particular patron\\n\\n    uint256 public timeAcquired; // when it is newly bought/sold\\n    \\n    // percentage patronage rate. eg 5% or 100% \\n    // granular to an additionial 10 zeroes.\\n    uint256 patronageNumerator; \\n    uint256 patronageDenominator;\\n\\n    bool init;\\n\\n    constructor(address payable _artist, address _artwork) public {\\n    //function setup(address payable _artist, address _artwork) public {\\n        // this is kept here in case you want to use this in an upgradeable contract\\n        require(init == false, \\\"Steward already initialized.\\\");\\n        // 100% patronage: only here for reference\\n        patronageNumerator = 1000000000000;\\n        patronageDenominator = 1000000000000;\\n        art = IERC721(_artwork);\\n        art.setup();\\n        artist = _artist;\\n\\n        //sets up initial parameters for foreclosure\\n        _forecloseIfNecessary();\\n\\n        init = true;\\n    }\\n\\n    event LogBuy(address indexed owner, uint256 indexed price);\\n    event LogPriceChange(uint256 indexed newPrice);\\n    event LogForeclosure(address indexed prevOwner);\\n    event LogCollection(uint256 indexed collected);\\n    \\n    modifier onlyPatron() {\\n        require(msg.sender == art.ownerOf(42), \\\"Not patron\\\");\\n        _;\\n    }\\n\\n    modifier collectPatronage() {\\n       _collectPatronage(); \\n       _;\\n    }\\n\\n    /* public view functions */\\n    /* used internally in external actions */\\n\\n    // how much is owed from last collection to now.\\n    function patronageOwed() public view returns (uint256 patronageDue) {\\n        //return price.mul(now.sub(timeLastCollected)).mul(patronageNumerator).div(patronageDenominator).div(365 days);\\n        return price.mul(now.sub(timeLastCollected)).div(365 days);\\n    }\\n\\n    /* not used internally in external actions */\\n    function patronageOwedRange(uint256 _time) public view returns (uint256 patronageDue) {\\n        //return price.mul(_time).mul(patronageNumerator).div(patronageDenominator).div(365 days);\\n        return price.mul(_time).div(365 days);\\n    }\\n\\n    function currentCollected() public view returns (uint256 patronageDue) {\\n        if(timeLastCollected \\u003e timeAcquired) {\\n            return patronageOwedRange(timeLastCollected.sub(timeAcquired));\\n        } else { return 0; }\\n    }\\n\\n    function patronageOwedWithTimestamp() public view returns (uint256 patronageDue, uint256 timestamp) {\\n        return (patronageOwed(), now);\\n    }\\n\\n    function foreclosed() public view returns (bool) {\\n        // returns whether it is in foreclosed state or not\\n        // depending on whether deposit covers patronage due\\n        // useful helper function when price should be zero, but contract doesn\\u0027t reflect it yet.\\n        uint256 collection = patronageOwed();\\n        if(collection \\u003e= deposit) {\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    // same function as above, basically\\n    function depositAbleToWithdraw() public view returns (uint256) {\\n        uint256 collection = patronageOwed();\\n        if(collection \\u003e= deposit) {\\n            return 0;\\n        } else {\\n            return deposit.sub(collection);\\n        }\\n    }\\n\\n    /*\\n    now + deposit/patronage per second \\n    now + depositAbleToWithdraw/(price*nume/denom/365).\\n    */\\n    function foreclosureTime() public view returns (uint256) {\\n        // patronage per second\\n        uint256 pps = price.mul(patronageNumerator).div(patronageDenominator).div(365 days);\\n        uint256 daw = depositAbleToWithdraw();\\n        if(daw \\u003e 0) {\\n            return now + depositAbleToWithdraw().div(pps);\\n        } else if (pps \\u003e 0) {\\n            // it is still active, but in foreclosure state\\n            // it is NOW or was in the past\\n            uint256 collection = patronageOwed();\\n            return timeLastCollected.add(((now.sub(timeLastCollected)).mul(deposit).div(collection)));\\n        } else {\\n            // not active and actively foreclosed (price is zero)\\n            return timeLastCollected; // it has been foreclosed or in foreclosure.\\n        }\\n    }\\n\\n    /* actions */\\n    // determine patronage to pay\\n    function _collectPatronage() public {\\n\\n        if (price != 0) { // price \\u003e 0 == active owned state\\n            uint256 collection = patronageOwed();\\n            \\n            if (collection \\u003e= deposit) { // foreclosure happened in the past\\n\\n                // up to when was it actually paid for?\\n                // TLC + (time_elapsed)*deposit/collection\\n                timeLastCollected = timeLastCollected.add((now.sub(timeLastCollected)).mul(deposit).div(collection));\\n                collection = deposit; // take what\\u0027s left.\\n            } else { \\n                timeLastCollected = now; \\n            } // normal collection\\n\\n            deposit = deposit.sub(collection);\\n            totalCollected = totalCollected.add(collection);\\n            artistFund = artistFund.add(collection);\\n            emit LogCollection(collection);\\n\\n            _forecloseIfNecessary();\\n        }\\n\\n    }\\n\\n    function buy(uint256 _newPrice, uint256 _currentPrice) public payable collectPatronage {\\n        /* \\n            this is protection against a front-run attack.\\n            the person will only buy the artwork if it is what they agreed to.\\n            thus: someone can\\u0027t buy it from under them and change the price, eating into their deposit.\\n        */\\n        require(price == _currentPrice, \\\"Current Price incorrect\\\");\\n        require(_newPrice \\u003e 0, \\\"Price is zero\\\");\\n        require(msg.value \\u003e price, \\\"Not enough\\\"); // \\u003e, coz need to have at least something for deposit\\n\\n        address currentOwner = art.ownerOf(42);\\n\\n        uint256 totalToPayBack = price.add(deposit);\\n        if(totalToPayBack \\u003e 0) { // this won\\u0027t execute if steward owns it. price = 0. deposit = 0.\\n            // pay previous owner their price + deposit back.\\n            address payable payableCurrentOwner = address(uint160(currentOwner));\\n            bool transferSuccess = payableCurrentOwner.send(totalToPayBack);\\n\\n            // if the send fails, keep the funds separate for the owner\\n            if(!transferSuccess) { pullFunds[currentOwner] = pullFunds[currentOwner].add(totalToPayBack); }\\n        }\\n\\n        // new purchase\\n        timeLastCollected = now;\\n        \\n        deposit = msg.value.sub(price);\\n        transferArtworkTo(currentOwner, msg.sender, _newPrice);\\n        emit LogBuy(msg.sender, _newPrice);\\n    }\\n\\n    /* Only Patron Actions */\\n    function depositWei() public payable collectPatronage onlyPatron {\\n        deposit = deposit.add(msg.value);\\n    }\\n\\n    function changePrice(uint256 _newPrice) public collectPatronage onlyPatron {\\n        require(_newPrice \\u003e 0, \\u0027Price is zero\\u0027); \\n        price = _newPrice;\\n        emit LogPriceChange(price);\\n    }\\n    \\n    function withdrawDeposit(uint256 _wei) public collectPatronage onlyPatron {\\n        _withdrawDeposit(_wei);\\n    }\\n\\n    function exit() public collectPatronage onlyPatron {\\n        _withdrawDeposit(deposit);\\n    }\\n\\n    /* Actions that don\\u0027t affect state of the artwork */\\n    /* Artist Actions */\\n    function withdrawArtistFunds() public {\\n        require(msg.sender == artist, \\\"Not artist\\\");\\n        uint256 toSend = artistFund;\\n        artistFund = 0;\\n        artist.transfer(toSend);\\n    }\\n\\n    /* Withdrawing Stuck Deposits */\\n    /* To reduce complexity, pull funds are entirely separate from current deposit */\\n    function withdrawPullFunds() public {\\n        require(pullFunds[msg.sender] \\u003e 0, \\\"No pull funds available.\\\");\\n        uint256 toSend = pullFunds[msg.sender];\\n        pullFunds[msg.sender] = 0;\\n        msg.sender.transfer(toSend);\\n    }\\n\\n    /* internal */\\n    function _withdrawDeposit(uint256 _wei) internal {\\n        // note: can withdraw whole deposit, which puts it in immediate to be foreclosed state.\\n        require(deposit \\u003e= _wei, \\u0027Withdrawing too much\\u0027);\\n\\n        deposit = deposit.sub(_wei);\\n        msg.sender.transfer(_wei); // msg.sender == patron\\n\\n        _forecloseIfNecessary();\\n    }\\n\\n    function _forecloseIfNecessary() internal {\\n        if(deposit == 0) {\\n            // become steward of artwork (aka foreclose)\\n            address currentOwner = art.ownerOf(42);\\n            transferArtworkTo(currentOwner, address(this), 0);\\n            emit LogForeclosure(currentOwner);\\n        }\\n    }\\n\\n    function transferArtworkTo(address _currentOwner, address _newOwner, uint256 _newPrice) internal {\\n        // note: it would also tabulate time held in stewardship by smart contract\\n        timeHeld[_currentOwner] = timeHeld[_currentOwner].add((timeLastCollected.sub(timeAcquired)));\\n        \\n        art.transferFrom(_currentOwner, _newOwner, 42);\\n\\n        price = _newPrice;\\n        timeAcquired = now;\\n        patrons[_newOwner] = true;\\n    }\\n}\"},\"BlockReceiver.sol\":{\"content\":\"pragma solidity ^0.6.6;\\n\\nimport \\\"./ArtSteward.sol\\\"; // dont need an interface since it\\u0027s a test contract\\n\\n/*\\nTesting contract\\n*/\\n\\ncontract BlockReceiver {\\n\\n    ArtSteward steward;\\n\\n    constructor (address _steward) public {\\n        steward = ArtSteward(_steward);\\n    }\\n\\n    function buy(uint256 currentPrice) public payable {\\n        uint256 price = 1 ether;\\n        // steward.buy{value: msg.value}(price, currentPrice);\\n        // note: for some reason, it can\\u0027t determine difference between buy(uint256) \\u0026 buy(uint256,uint256)\\n        // Thus: manually creating this call for testing\\n        address(steward).call.value(msg.value)(abi.encodeWithSignature(\\\"buy(uint256,uint256)\\\", price, currentPrice));\\n    }\\n\\n    function withdrawPullFunds() public {\\n        steward.withdrawPullFunds();\\n    }\\n\\n    // no fallback\\n    // no receive\\n    // will cause ETH sends to revert\\n}\"},\"Counters.sol\":{\"content\":\"pragma solidity ^0.6.0;\\n\\nimport \\\"./SafeMath.sol\\\";\\n\\n/**\\n * @title Counters\\n * @author Matt Condon (@shrugs)\\n * @dev Provides counters that can only be incremented or decremented by one. This can be used e.g. to track the number\\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\\n *\\n * Include with `using Counters for Counters.Counter;`\\n * Since it is not possible to overflow a 256 bit integer with increments of one, `increment` can skip the {SafeMath}\\n * overflow check, thereby saving gas. This does assume however correct usage, in that the underlying `_value` is never\\n * directly accessed.\\n */\\nlibrary Counters {\\n    using SafeMath for uint256;\\n\\n    struct Counter {\\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\\n        // the library\\u0027s function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\\n        uint256 _value; // default: 0\\n    }\\n\\n    function current(Counter storage counter) internal view returns (uint256) {\\n        return counter._value;\\n    }\\n\\n    function increment(Counter storage counter) internal {\\n        // The {SafeMath} overflow check can be skipped here, see the comment at the top\\n        counter._value += 1;\\n    }\\n\\n    function decrement(Counter storage counter) internal {\\n        counter._value = counter._value.sub(1);\\n    }\\n}\"},\"EnumerableMap.sol\":{\"content\":\"pragma solidity ^0.6.0;\\n\\n/**\\n * @dev Library for managing an enumerable variant of Solidity\\u0027s\\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\\n * type.\\n *\\n * Maps have the following properties:\\n *\\n * - Entries are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\\n *\\n *     // Declare a set state variable\\n *     EnumerableMap.UintToAddressMap private myMap;\\n * }\\n * ```\\n *\\n * As of v3.0.0, only maps of type `uint256 -\\u003e address` (`UintToAddressMap`) are\\n * supported.\\n */\\nlibrary EnumerableMap {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Map type with\\n    // bytes32 keys and values.\\n    // The Map implementation uses private functions, and user-facing\\n    // implementations (such as Uint256ToAddressMap) are just wrappers around\\n    // the underlying Map.\\n    // This means that we can only create new EnumerableMaps for types that fit\\n    // in bytes32.\\n\\n    struct MapEntry {\\n        bytes32 _key;\\n        bytes32 _value;\\n    }\\n\\n    struct Map {\\n        // Storage of map keys and values\\n        MapEntry[] _entries;\\n\\n        // Position of the entry defined by a key in the `entries` array, plus 1\\n        // because index 0 means a key is not in the map.\\n        mapping (bytes32 =\\u003e uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n    function _set(Map storage map, bytes32 key, bytes32 value) private returns (bool) {\\n        // We read and store the key\\u0027s index to prevent multiple reads from the same storage slot\\n        uint256 keyIndex = map._indexes[key];\\n\\n        if (keyIndex == 0) { // Equivalent to !contains(map, key)\\n            map._entries.push(MapEntry({ _key: key, _value: value }));\\n            // The entry is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            map._indexes[key] = map._entries.length;\\n            return true;\\n        } else {\\n            map._entries[keyIndex - 1]._value = value;\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a key-value pair from a map. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n    function _remove(Map storage map, bytes32 key) private returns (bool) {\\n        // We read and store the key\\u0027s index to prevent multiple reads from the same storage slot\\n        uint256 keyIndex = map._indexes[key];\\n\\n        if (keyIndex != 0) { // Equivalent to contains(map, key)\\n            // To delete a key-value pair from the _entries array in O(1), we swap the entry to delete with the last one\\n            // in the array, and then remove the last entry (sometimes called as \\u0027swap and pop\\u0027).\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = keyIndex - 1;\\n            uint256 lastIndex = map._entries.length - 1;\\n\\n            // When the entry to delete is the last one, the swap operation is unnecessary. However, since this occurs\\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an \\u0027if\\u0027 statement.\\n\\n            MapEntry storage lastEntry = map._entries[lastIndex];\\n\\n            // Move the last entry to the index where the entry to delete is\\n            map._entries[toDeleteIndex] = lastEntry;\\n            // Update the index for the moved entry\\n            map._indexes[lastEntry._key] = toDeleteIndex + 1; // All indexes are 1-based\\n\\n            // Delete the slot where the moved entry was stored\\n            map._entries.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete map._indexes[key];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the key is in the map. O(1).\\n     */\\n    function _contains(Map storage map, bytes32 key) private view returns (bool) {\\n        return map._indexes[key] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of key-value pairs in the map. O(1).\\n     */\\n    function _length(Map storage map) private view returns (uint256) {\\n        return map._entries.length;\\n    }\\n\\n   /**\\n    * @dev Returns the key-value pair stored at position `index` in the map. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of entries inside the\\n    * array, and it may change when more entries are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function _at(Map storage map, uint256 index) private view returns (bytes32, bytes32) {\\n        require(map._entries.length \\u003e index, \\\"EnumerableMap: index out of bounds\\\");\\n\\n        MapEntry storage entry = map._entries[index];\\n        return (entry._key, entry._value);\\n    }\\n\\n    /**\\n     * @dev Returns the value associated with `key`.  O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n    function _get(Map storage map, bytes32 key) private view returns (bytes32) {\\n        return _get(map, key, \\\"EnumerableMap: nonexistent key\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {_get}, with a custom error message when `key` is not in the map.\\n     */\\n    function _get(Map storage map, bytes32 key, string memory errorMessage) private view returns (bytes32) {\\n        uint256 keyIndex = map._indexes[key];\\n        require(keyIndex != 0, errorMessage); // Equivalent to contains(map, key)\\n        return map._entries[keyIndex - 1]._value; // All indexes are 1-based\\n    }\\n\\n    // UintToAddressMap\\n\\n    struct UintToAddressMap {\\n        Map _inner;\\n    }\\n\\n    /**\\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n    function set(UintToAddressMap storage map, uint256 key, address value) internal returns (bool) {\\n        return _set(map._inner, bytes32(key), bytes32(uint256(value)));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n    function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\\n        return _remove(map._inner, bytes32(key));\\n    }\\n\\n    /**\\n     * @dev Returns true if the key is in the map. O(1).\\n     */\\n    function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\\n        return _contains(map._inner, bytes32(key));\\n    }\\n\\n    /**\\n     * @dev Returns the number of elements in the map. O(1).\\n     */\\n    function length(UintToAddressMap storage map) internal view returns (uint256) {\\n        return _length(map._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the element stored at position `index` in the set. O(1).\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\\n        (bytes32 key, bytes32 value) = _at(map._inner, index);\\n        return (uint256(key), address(uint256(value)));\\n    }\\n\\n    /**\\n     * @dev Returns the value associated with `key`.  O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n    function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\\n        return address(uint256(_get(map._inner, bytes32(key))));\\n    }\\n\\n    /**\\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\\n     */\\n    function get(UintToAddressMap storage map, uint256 key, string memory errorMessage) internal view returns (address) {\\n        return address(uint256(_get(map._inner, bytes32(key), errorMessage)));\\n    }\\n}\"},\"EnumerableSet.sol\":{\"content\":\"pragma solidity ^0.6.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.0.0, only sets of type `address` (`AddressSet`) and `uint256`\\n * (`UintSet`) are supported.\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping (bytes32 =\\u003e uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value\\u0027s index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as \\u0027swap and pop\\u0027).\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an \\u0027if\\u0027 statement.\\n\\n            bytes32 lastvalue = set._values[lastIndex];\\n\\n            // Move the last value to the index where the value to delete is\\n            set._values[toDeleteIndex] = lastvalue;\\n            // Update the index for the moved value\\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        require(set._values.length \\u003e index, \\\"EnumerableSet: index out of bounds\\\");\\n        return set._values[index];\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(value)));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(value)));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(value)));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint256(_at(set._inner, index)));\\n    }\\n\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n}\"},\"ERC165.sol\":{\"content\":\"pragma solidity ^0.6.6;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts may inherit from this and call {_registerInterface} to declare\\n * their support of an interface.\\n */\\ncontract ERC165 is IERC165 {\\n    \\n\\n    /**\\n     * @dev Mapping of interface ids to whether or not it\\u0027s supported.\\n     */\\n    mapping(bytes4 =\\u003e bool) private _supportedInterfaces;\\n\\n    /*constructor () internal {\\n        // Derived contracts need only register support for their own interfaces,\\n        // we register support for ERC165 itself here\\n        _registerInterface(_INTERFACE_ID_ERC165);\\n    }*/\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     *\\n     * Time complexity O(1), guaranteed to always use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view override returns (bool) {\\n        return _supportedInterfaces[interfaceId];\\n    }\\n\\n    /**\\n     * @dev Registers the contract as an implementer of the interface defined by\\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\\n     * registering its interface id is not required.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     *\\n     * Requirements:\\n     *\\n     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\\n     */\\n    function _registerInterface(bytes4 interfaceId) internal virtual {\\n        require(interfaceId != 0xffffffff, \\\"ERC165: invalid interface id\\\");\\n        _supportedInterfaces[interfaceId] = true;\\n    }\\n}\"},\"ERC721.sol\":{\"content\":\"pragma solidity ^0.6.6;\\n\\n// import \\\"../../GSN/Context.sol\\\";\\nimport \\\"./IERC721.sol\\\";\\nimport \\\"./IERC721Metadata.sol\\\";\\nimport \\\"./IERC721Enumerable.sol\\\";\\n// import \\\"./IERC721Receiver.sol\\\";\\nimport \\\"./ERC165.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./Address.sol\\\";\\nimport \\\"./EnumerableSet.sol\\\";\\nimport \\\"./EnumerableMap.sol\\\";\\nimport \\\"./Strings.sol\\\";\\n\\n/**\\n * @title ERC721 Non-Fungible Token Standard basic implementation\\n * @dev see https://eips.ethereum.org/EIPS/eip-721\\n */\\ncontract ERC721 is ERC165, IERC721, IERC721Metadata, IERC721Enumerable {\\n    using SafeMath for uint256;\\n    using Address for address;\\n    using EnumerableSet for EnumerableSet.UintSet;\\n    using EnumerableMap for EnumerableMap.UintToAddressMap;\\n    using Strings for uint256;\\n\\n    // Equals to `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`\\n    // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\\n    // bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\\n\\n    // Mapping from holder address to their (enumerable) set of owned tokens\\n    mapping (address =\\u003e EnumerableSet.UintSet) private _holderTokens;\\n\\n    // Enumerable mapping from token ids to their owners\\n    EnumerableMap.UintToAddressMap private _tokenOwners;\\n\\n    // Mapping from token ID to approved address\\n    mapping (uint256 =\\u003e address) private _tokenApprovals;\\n\\n    // Mapping from owner to operator approvals\\n    mapping (address =\\u003e mapping (address =\\u003e bool)) private _operatorApprovals;\\n\\n    // Token name\\n    string private _name;\\n\\n    // Token symbol\\n    string private _symbol;\\n\\n    // Optional mapping for token URIs\\n    mapping(uint256 =\\u003e string) private _tokenURIs;\\n\\n    // Base URI\\n    string private _baseURI;\\n\\n    /*\\n     *     bytes4(keccak256(\\u0027balanceOf(address)\\u0027)) == 0x70a08231\\n     *     bytes4(keccak256(\\u0027ownerOf(uint256)\\u0027)) == 0x6352211e\\n     *     bytes4(keccak256(\\u0027approve(address,uint256)\\u0027)) == 0x095ea7b3\\n     *     bytes4(keccak256(\\u0027getApproved(uint256)\\u0027)) == 0x081812fc\\n     *     bytes4(keccak256(\\u0027setApprovalForAll(address,bool)\\u0027)) == 0xa22cb465\\n     *     bytes4(keccak256(\\u0027isApprovedForAll(address,address)\\u0027)) == 0xe985e9c5\\n     *     bytes4(keccak256(\\u0027transferFrom(address,address,uint256)\\u0027)) == 0x23b872dd\\n     *     bytes4(keccak256(\\u0027safeTransferFrom(address,address,uint256)\\u0027)) == 0x42842e0e\\n     *     bytes4(keccak256(\\u0027safeTransferFrom(address,address,uint256,bytes)\\u0027)) == 0xb88d4fde\\n     *\\n     *     =\\u003e 0x70a08231 ^ 0x6352211e ^ 0x095ea7b3 ^ 0x081812fc ^\\n     *        0xa22cb465 ^ 0xe985e9c ^ 0x23b872dd ^ 0x42842e0e ^ 0xb88d4fde == 0x80ac58cd\\n     */\\n    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\\n\\n    /*\\n     *     bytes4(keccak256(\\u0027name()\\u0027)) == 0x06fdde03\\n     *     bytes4(keccak256(\\u0027symbol()\\u0027)) == 0x95d89b41\\n     *     bytes4(keccak256(\\u0027tokenURI(uint256)\\u0027)) == 0xc87b56dd\\n     *\\n     *     =\\u003e 0x06fdde03 ^ 0x95d89b41 ^ 0xc87b56dd == 0x5b5e139f\\n     */\\n    bytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\\n\\n    /*\\n     *     bytes4(keccak256(\\u0027totalSupply()\\u0027)) == 0x18160ddd\\n     *     bytes4(keccak256(\\u0027tokenOfOwnerByIndex(address,uint256)\\u0027)) == 0x2f745c59\\n     *     bytes4(keccak256(\\u0027tokenByIndex(uint256)\\u0027)) == 0x4f6ccce7\\n     *\\n     *     =\\u003e 0x18160ddd ^ 0x2f745c59 ^ 0x4f6ccce7 == 0x780e9d63\\n     */\\n    bytes4 private constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;\\n\\n    /*\\n     * bytes4(keccak256(\\u0027supportsInterface(bytes4)\\u0027)) == 0x01ffc9a7\\n     */\\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\\n\\n    // IMPLEMENTATION SPECIFIC VARS\\n    address public steward;\\n    bool public init;\\n\\n    function setup() public override {\\n        require(init == false, \\\"Artwork already initialized.\\\");\\n\\n        _name = \\\"This Artwork Is Always On Sale 2\\\";\\n        _symbol = \\\"TAIAOS2\\\";\\n        steward = msg.sender;\\n        // mint artwork\\n        _mint(steward, 42); // mint\\n        _setTokenURI(42, \\\"https://thisartworkisalwaysonsale.com/metadata2\\\");\\n\\n        // register the supported interfaces to conform to ERC721 via ERC165\\n        _registerInterface(_INTERFACE_ID_ERC165);\\n        _registerInterface(_INTERFACE_ID_ERC721);\\n        _registerInterface(_INTERFACE_ID_ERC721_METADATA);\\n        _registerInterface(_INTERFACE_ID_ERC721_ENUMERABLE);\\n\\n        init=true;\\n    }\\n\\n    /**\\n     * @dev Gets the balance of the specified address.\\n     * @param owner address to query the balance of\\n     * @return uint256 representing the amount owned by the passed address\\n     */\\n    function balanceOf(address owner) public view override returns (uint256) {\\n        require(owner != address(0), \\\"ERC721: balance query for the zero address\\\");\\n\\n        return _holderTokens[owner].length();\\n    }\\n\\n    /**\\n     * @dev Gets the owner of the specified token ID.\\n     * @param tokenId uint256 ID of the token to query the owner of\\n     * @return address currently marked as the owner of the given token ID\\n     */\\n    function ownerOf(uint256 tokenId) public view override returns (address) {\\n        return _tokenOwners.get(tokenId, \\\"ERC721: owner query for nonexistent token\\\");\\n    }\\n\\n    /**\\n     * @dev Gets the token name.\\n     * @return string representing the token name\\n     */\\n    function name() public view override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Gets the token symbol.\\n     * @return string representing the token symbol\\n     */\\n    function symbol() public view override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the URI for a given token ID. May return an empty string.\\n     *\\n     * If a base URI is set (via {_setBaseURI}), it is added as a prefix to the\\n     * token\\u0027s own URI (via {_setTokenURI}).\\n     *\\n     * If there is a base URI but no token URI, the token\\u0027s ID will be used as\\n     * its URI when appending it to the base URI. This pattern for autogenerated\\n     * token URIs can lead to large gas savings.\\n     *\\n     * .Examples\\n     * |===\\n     * |`_setBaseURI()` |`_setTokenURI()` |`tokenURI()`\\n     * | \\\"\\\"\\n     * | \\\"\\\"\\n     * | \\\"\\\"\\n     * | \\\"\\\"\\n     * | \\\"token.uri/123\\\"\\n     * | \\\"token.uri/123\\\"\\n     * | \\\"token.uri/\\\"\\n     * | \\\"123\\\"\\n     * | \\\"token.uri/123\\\"\\n     * | \\\"token.uri/\\\"\\n     * | \\\"\\\"\\n     * | \\\"token.uri/\\u003ctokenId\\u003e\\\"\\n     * |===\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\\n        require(_exists(tokenId), \\\"ERC721Metadata: URI query for nonexistent token\\\");\\n\\n        string memory _tokenURI = _tokenURIs[tokenId];\\n\\n        // If there is no base URI, return the token URI.\\n        if (bytes(_baseURI).length == 0) {\\n            return _tokenURI;\\n        }\\n        // If both are set, concatenate the baseURI and tokenURI (via abi.encodePacked).\\n        if (bytes(_tokenURI).length \\u003e 0) {\\n            return string(abi.encodePacked(_baseURI, _tokenURI));\\n        }\\n        // If there is a baseURI but no tokenURI, concatenate the tokenID to the baseURI.\\n        return string(abi.encodePacked(_baseURI, tokenId.toString()));\\n    }\\n\\n    /**\\n    * @dev Returns the base URI set via {_setBaseURI}. This will be\\n    * automatically added as a prefix in {tokenURI} to each token\\u0027s URI, or\\n    * to the token ID if no specific URI is set for that token ID.\\n    */\\n    function baseURI() public view returns (string memory) {\\n        return _baseURI;\\n    }\\n\\n    /**\\n     * @dev Gets the token ID at a given index of the tokens list of the requested owner.\\n     * @param owner address owning the tokens list to be accessed\\n     * @param index uint256 representing the index to be accessed of the requested tokens list\\n     * @return uint256 token ID at the given index of the tokens list owned by the requested address\\n     */\\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view override returns (uint256) {\\n        return _holderTokens[owner].at(index);\\n    }\\n\\n    /**\\n     * @dev Gets the total amount of tokens stored by the contract.\\n     * @return uint256 representing the total amount of tokens\\n     */\\n    function totalSupply() public view override returns (uint256) {\\n        // _tokenOwners are indexed by tokenIds, so .length() returns the number of tokenIds\\n        return _tokenOwners.length();\\n    }\\n\\n    /**\\n     * @dev Gets the token ID at a given index of all the tokens in this contract\\n     * Reverts if the index is greater or equal to the total number of tokens.\\n     * @param index uint256 representing the index to be accessed of the tokens list\\n     * @return uint256 token ID at the given index of the tokens list\\n     */\\n    function tokenByIndex(uint256 index) public view override returns (uint256) {\\n        (uint256 tokenId, ) = _tokenOwners.at(index);\\n        return tokenId;\\n    }\\n\\n    /**\\n     * @dev Approves another address to transfer the given token ID\\n     * The zero address indicates there is no approved address.\\n     * There can only be one approved address per token at a given time.\\n     * Can only be called by the token owner or an approved operator.\\n     * @param to address to be approved for the given token ID\\n     * @param tokenId uint256 ID of the token to be approved\\n     */\\n    function approve(address to, uint256 tokenId) public virtual override {\\n        address owner = ownerOf(tokenId);\\n        require(to != owner, \\\"ERC721: approval to current owner\\\");\\n\\n        require(msg.sender == owner || isApprovedForAll(owner, msg.sender),\\n            \\\"ERC721: approve caller is not owner nor approved for all\\\"\\n        );\\n\\n        _approve(to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Gets the approved address for a token ID, or zero if no address set\\n     * Reverts if the token ID does not exist.\\n     * @param tokenId uint256 ID of the token to query the approval of\\n     * @return address currently approved for the given token ID\\n     */\\n    function getApproved(uint256 tokenId) public view override returns (address) {\\n        require(_exists(tokenId), \\\"ERC721: approved query for nonexistent token\\\");\\n\\n        return _tokenApprovals[tokenId];\\n    }\\n\\n    /**\\n     * @dev Sets or unsets the approval of a given operator\\n     * An operator is allowed to transfer all tokens of the sender on their behalf.\\n     * @param operator operator address to set the approval\\n     * @param approved representing the status of the approval to be set\\n     */\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\n        require(operator != msg.sender, \\\"ERC721: approve to caller\\\");\\n\\n        _operatorApprovals[msg.sender][operator] = approved;\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    /**\\n     * @dev Tells whether an operator is approved by a given owner.\\n     * @param owner owner address which you want to query the approval of\\n     * @param operator operator address which you want to query the approval of\\n     * @return bool whether the given operator is approved by the given owner\\n     */\\n    function isApprovedForAll(address owner, address operator) public view override returns (bool) {\\n        return _operatorApprovals[owner][operator];\\n    }\\n\\n    /**\\n     * @dev Transfers the ownership of a given token ID to another address.\\n     * Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     * Requires the msg.sender to be the owner, approved, or operator.\\n     * @param from current owner of the token\\n     * @param to address to receive the ownership of the given token ID\\n     * @param tokenId uint256 ID of the token to be transferred\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\\n        //solhint-disable-next-line max-line-length\\n        require(_isApprovedOrOwner(msg.sender, tokenId), \\\"ERC721: transfer caller is not steward.\\\");\\n\\n        _transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Safely transfers the ownership of a given token ID to another address\\n     * If the target address is a contract, it must implement {IERC721Receiver-onERC721Received},\\n     * which is called upon a safe transfer, and return the magic value\\n     * `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`; otherwise,\\n     * the transfer is reverted.\\n     * Requires the msg.sender to be the owner, approved, or operator\\n     * @param from current owner of the token\\n     * @param to address to receive the ownership of the given token ID\\n     * @param tokenId uint256 ID of the token to be transferred\\n     */\\n    /*function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\\n        safeTransferFrom(from, to, tokenId, \\\"\\\");\\n    }*/\\n\\n    /**\\n     * @dev Safely transfers the ownership of a given token ID to another address\\n     * If the target address is a contract, it must implement {IERC721Receiver-onERC721Received},\\n     * which is called upon a safe transfer, and return the magic value\\n     * `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`; otherwise,\\n     * the transfer is reverted.\\n     * Requires the msg.sender to be the owner, approved, or operator\\n     * @param from current owner of the token\\n     * @param to address to receive the ownership of the given token ID\\n     * @param tokenId uint256 ID of the token to be transferred\\n     * @param _data bytes data to send along with a safe transfer check\\n     */\\n    /* function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public virtual override {\\n        require(_isApprovedOrOwner(msg.sender, tokenId), \\\"ERC721: transfer caller is not owner nor approved\\\");\\n        _safeTransfer(from, to, tokenId, _data);\\n    }*/\\n\\n    /**\\n     * @dev Safely transfers the ownership of a given token ID to another address\\n     * If the target address is a contract, it must implement `onERC721Received`,\\n     * which is called upon a safe transfer, and return the magic value\\n     * `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`; otherwise,\\n     * the transfer is reverted.\\n     * Requires the msg.sender to be the owner, approved, or operator\\n     * @param from current owner of the token\\n     * @param to address to receive the ownership of the given token ID\\n     * @param tokenId uint256 ID of the token to be transferred\\n     * @param _data bytes data to send along with a safe transfer check\\n     */\\n    /*function _safeTransfer(address from, address to, uint256 tokenId, bytes memory _data) internal virtual {\\n        _transfer(from, to, tokenId);\\n        require(_checkOnERC721Received(from, to, tokenId, _data), \\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n    }*/\\n\\n    /**\\n     * @dev Returns whether the specified token exists.\\n     * @param tokenId uint256 ID of the token to query the existence of\\n     * @return bool whether the token exists\\n     */\\n    function _exists(uint256 tokenId) internal view returns (bool) {\\n        return _tokenOwners.contains(tokenId);\\n    }\\n\\n    /**\\n     * @dev Returns whether the given spender can transfer a given token ID.\\n     * @param spender address of the spender to query\\n     * @param tokenId uint256 ID of the token to be transferred\\n     * @return bool whether the msg.sender is approved for the given token ID,\\n     * is an operator of the owner, or is the owner of the token\\n     */\\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {\\n        require(_exists(tokenId), \\\"ERC721: operator query for nonexistent token\\\");\\n        // address owner = ownerOf(tokenId);\\n        // return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\\n\\n        // MODIFIED:\\n        // Only the steward is allowed to transfer\\n        return (spender == steward); \\n    }\\n\\n    /**\\n     * @dev Internal function to safely mint a new token.\\n     * Reverts if the given token ID already exists.\\n     * If the target address is a contract, it must implement `onERC721Received`,\\n     * which is called upon a safe transfer, and return the magic value\\n     * `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`; otherwise,\\n     * the transfer is reverted.\\n     * @param to The address that will own the minted token\\n     * @param tokenId uint256 ID of the token to be minted\\n     */\\n    /*function _safeMint(address to, uint256 tokenId) internal virtual {\\n        _safeMint(to, tokenId, \\\"\\\");\\n    }*/\\n\\n    /**\\n     * @dev Internal function to safely mint a new token.\\n     * Reverts if the given token ID already exists.\\n     * If the target address is a contract, it must implement `onERC721Received`,\\n     * which is called upon a safe transfer, and return the magic value\\n     * `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`; otherwise,\\n     * the transfer is reverted.\\n     * @param to The address that will own the minted token\\n     * @param tokenId uint256 ID of the token to be minted\\n     * @param _data bytes data to send along with a safe transfer check\\n     */\\n    /*function _safeMint(address to, uint256 tokenId, bytes memory _data) internal virtual {\\n        _mint(to, tokenId);\\n        require(_checkOnERC721Received(address(0), to, tokenId, _data), \\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n    }*/\\n\\n    /**\\n     * @dev Internal function to mint a new token.\\n     * Reverts if the given token ID already exists.\\n     * @param to The address that will own the minted token\\n     * @param tokenId uint256 ID of the token to be minted\\n     */\\n    function _mint(address to, uint256 tokenId) internal virtual {\\n        require(to != address(0), \\\"ERC721: mint to the zero address\\\");\\n        require(!_exists(tokenId), \\\"ERC721: token already minted\\\");\\n\\n        _beforeTokenTransfer(address(0), to, tokenId);\\n\\n        _holderTokens[to].add(tokenId);\\n\\n        _tokenOwners.set(tokenId, to);\\n\\n        emit Transfer(address(0), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Internal function to burn a specific token.\\n     * Reverts if the token does not exist.\\n     * @param tokenId uint256 ID of the token being burned\\n     */\\n    function _burn(uint256 tokenId) internal virtual {\\n        address owner = ownerOf(tokenId);\\n\\n        _beforeTokenTransfer(owner, address(0), tokenId);\\n\\n        // Clear approvals\\n        _approve(address(0), tokenId);\\n\\n        // Clear metadata (if any)\\n        if (bytes(_tokenURIs[tokenId]).length != 0) {\\n            delete _tokenURIs[tokenId];\\n        }\\n\\n        _holderTokens[owner].remove(tokenId);\\n\\n        _tokenOwners.remove(tokenId);\\n\\n        emit Transfer(owner, address(0), tokenId);\\n    }\\n\\n    /**\\n     * @dev Internal function to transfer ownership of a given token ID to another address.\\n     * As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\\n     * @param from current owner of the token\\n     * @param to address to receive the ownership of the given token ID\\n     * @param tokenId uint256 ID of the token to be transferred\\n     */\\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\\n        require(ownerOf(tokenId) == from, \\\"ERC721: transfer of token that is not own\\\");\\n        require(to != address(0), \\\"ERC721: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, tokenId);\\n\\n        // Clear approvals from the previous owner\\n        _approve(address(0), tokenId);\\n\\n        _holderTokens[from].remove(tokenId);\\n        _holderTokens[to].add(tokenId);\\n\\n        _tokenOwners.set(tokenId, to);\\n\\n        emit Transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Internal function to set the token URI for a given token.\\n     *\\n     * Reverts if the token ID does not exist.\\n     *\\n     * TIP: If all token IDs share a prefix (for example, if your URIs look like\\n     * `https://api.myproject.com/token/\\u003cid\\u003e`), use {_setBaseURI} to store\\n     * it and save gas.\\n     */\\n    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {\\n        require(_exists(tokenId), \\\"ERC721Metadata: URI set of nonexistent token\\\");\\n        _tokenURIs[tokenId] = _tokenURI;\\n    }\\n\\n    /**\\n     * @dev Internal function to set the base URI for all token IDs. It is\\n     * automatically added as a prefix to the value returned in {tokenURI},\\n     * or to the token ID if {tokenURI} is empty.\\n     */\\n    function _setBaseURI(string memory baseURI_) internal virtual {\\n        _baseURI = baseURI_;\\n    }\\n\\n    // removed docstring due to parsing errors\\n    /*function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\\n        private returns (bool)\\n    {\\n        if (!to.isContract()) {\\n            return true;\\n        }\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = to.call(abi.encodeWithSelector(\\n            IERC721Receiver(to).onERC721Received.selector,\\n            msg.sender,\\n            from,\\n            tokenId,\\n            _data\\n        ));\\n        if (!success) {\\n            if (returndata.length \\u003e 0) {\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(\\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n            }\\n        } else {\\n            bytes4 retval = abi.decode(returndata, (bytes4));\\n            return (retval == _ERC721_RECEIVED);\\n        }\\n    }*/\\n\\n    function _approve(address to, uint256 tokenId) private {\\n        _tokenApprovals[tokenId] = to;\\n        emit Approval(ownerOf(tokenId), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any token transfer. This includes minting\\n     * and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, ``from``\\u0027s `tokenId` will be\\n     * transferred to `to`.\\n     * - when `from` is zero, `tokenId` will be minted for `to`.\\n     * - when `to` is zero, ``from``\\u0027s `tokenId` will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual { }\\n}\"},\"IERC165.sol\":{\"content\":\"pragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\"},\"IERC721.sol\":{\"content\":\"pragma solidity ^0.6.2;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transfered from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``\\u0027s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from`, `to` cannot be zero.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    // function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from`, `to` cannot be zero.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n      * @dev Safely transfers `tokenId` token from `from` to `to`.\\n      *\\n      * Requirements:\\n      *\\n      * - `from`, `to` cannot be zero.\\n      * - `tokenId` token must exist and be owned by `from`.\\n      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n      *\\n      * Emits a {Transfer} event.\\n      */\\n    // function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n\\n    function setup() external;\\n}\"},\"IERC721Enumerable.sol\":{\"content\":\"pragma solidity ^0.6.2;\\n\\nimport \\\"./IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Enumerable is IERC721 {\\n\\n    /**\\n     * @dev Returns the total amount of tokens stored by the contract.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\\n     * Use along with {balanceOf} to enumerate all of ``owner``\\u0027s tokens.\\n     */\\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\\n\\n    /**\\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\\n     * Use along with {totalSupply} to enumerate all tokens.\\n     */\\n    function tokenByIndex(uint256 index) external view returns (uint256);\\n}\"},\"IERC721Metadata.sol\":{\"content\":\"pragma solidity ^0.6.2;\\n\\nimport \\\"./IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Metadata is IERC721 {\\n\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\"},\"Initializable.sol\":{\"content\":\"pragma solidity \\u003e=0.4.24 \\u003c0.7.0;\\n\\n\\n/**\\n * @title Initializable\\n *\\n * @dev Helper contract to support initializer functions. To use it, replace\\n * the constructor with a function that has the `initializer` modifier.\\n * WARNING: Unlike constructors, initializer functions must be manually\\n * invoked. This applies both to deploying an Initializable contract, as well\\n * as extending an Initializable contract via inheritance.\\n * WARNING: When used with inheritance, manual care must be taken to not invoke\\n * a parent initializer twice, or ensure that all initializers are idempotent,\\n * because this is not dealt with automatically as with constructors.\\n */\\ncontract Initializable {\\n\\n  /**\\n   * @dev Indicates that the contract has been initialized.\\n   */\\n  bool private initialized;\\n\\n  /**\\n   * @dev Indicates that the contract is in the process of being initialized.\\n   */\\n  bool private initializing;\\n\\n  /**\\n   * @dev Modifier to use in the initializer function of a contract.\\n   */\\n  modifier initializer() {\\n    require(initializing || isConstructor() || !initialized, \\\"Contract instance has already been initialized\\\");\\n\\n    bool isTopLevelCall = !initializing;\\n    if (isTopLevelCall) {\\n      initializing = true;\\n      initialized = true;\\n    }\\n\\n    _;\\n\\n    if (isTopLevelCall) {\\n      initializing = false;\\n    }\\n  }\\n\\n  /// @dev Returns true if and only if the function is running in the constructor\\n  function isConstructor() private view returns (bool) {\\n    // extcodesize checks the size of the code stored in an address, and\\n    // address returns the current address. Since the code is still not\\n    // deployed when running a constructor, any checks on its code size will\\n    // yield zero, making it an effective way to detect if a contract is\\n    // under construction or not.\\n    address self = address(this);\\n    uint256 cs;\\n    assembly { cs := extcodesize(self) }\\n    return cs == 0;\\n  }\\n\\n  // Reserved storage space to allow for layout changes in the future.\\n  uint256[50] private ______gap;\\n}\"},\"Router.sol\":{\"content\":\"pragma solidity ^0.6.6;\\n\\nimport \\\"./ArtSteward.sol\\\"; // dont need an interface since it\\u0027s a test contract\\n\\n/*\\nTesting contract\\n*/\\n\\ncontract Router {\\n\\n    ArtSteward steward;\\n    bool public toBlock = true;\\n\\n    constructor (address _steward) public {\\n        steward = ArtSteward(_steward);\\n    }\\n\\n    function buy(uint256 currentPrice) public payable {\\n        // steward.buy{value: msg.value}(1 ether, currentPrice);\\n        // note: for some reason, it can\\u0027t determine difference between buy(uint256) \\u0026 buy(uint256,uint256)\\n        // Thus: manually creating this call for testing\\n        address(steward).call.value(msg.value)(abi.encodeWithSignature(\\\"buy(uint256,uint256)\\\", 1 ether, currentPrice));\\n    }\\n\\n    function withdrawPullFunds() public {\\n        steward.withdrawPullFunds();\\n    }\\n\\n    fallback() external payable {\\n        if(toBlock) { revert(\\u0027blocked\\u0027); }\\n    }\\n\\n    function setBlock(bool _tb) public {\\n        toBlock = _tb;\\n    }\\n}\"},\"SafeMath.sol\":{\"content\":\"pragma solidity ^0.6.0;\\n\\n/**\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it\\u0027s recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b \\u003c= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b \\u003e 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\"},\"Strings.sol\":{\"content\":\"pragma solidity ^0.6.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI\\u0027s implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        uint256 index = digits - 1;\\n        temp = value;\\n        while (temp != 0) {\\n            buffer[index--] = byte(uint8(48 + temp % 10));\\n            temp /= 10;\\n        }\\n        return string(buffer);\\n    }\\n}\"}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_artist\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_artwork\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"LogBuy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"collected\",\"type\":\"uint256\"}],\"name\":\"LogCollection\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"prevOwner\",\"type\":\"address\"}],\"name\":\"LogForeclosure\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"newPrice\",\"type\":\"uint256\"}],\"name\":\"LogPriceChange\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_collectPatronage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"art\",\"outputs\":[{\"internalType\":\"contract IERC721\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"artist\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"artistFund\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_currentPrice\",\"type\":\"uint256\"}],\"name\":\"buy\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newPrice\",\"type\":\"uint256\"}],\"name\":\"changePrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentCollected\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"patronageDue\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositAbleToWithdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositWei\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"foreclosed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"foreclosureTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"patronageOwed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"patronageDue\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"patronageOwedRange\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"patronageDue\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"patronageOwedWithTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"patronageDue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"patrons\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"price\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"pullFunds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timeAcquired\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"timeHeld\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timeLastCollected\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalCollected\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawArtistFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_wei\",\"type\":\"uint256\"}],\"name\":\"withdrawDeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawPullFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "ArtSteward", "CompilerVersion": "v0.6.10+commit.00c0fcaf", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "0000000000000000000000000cacc6104d8cd9d7b2850b4f35c65c1ecdeece03000000000000000000000000e51a7572323040792ba69b2dc4096e8e6b22fdd4", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://358e109c807fad63a81f2671cea2baf77a38526a03bb9b5f97a228d5c4b005d4"}