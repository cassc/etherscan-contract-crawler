{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@metalabel/solmate/src/tokens/ERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Data stored per-token, fits into a single storage word\\nstruct TokenData {\\n    address owner;\\n    uint16 sequenceId;\\n    uint80 data;\\n}\\n\\n/// @notice Modern, minimalist, and gas efficient ERC-721 implementation.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\\nabstract contract ERC721 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\\n\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                         METADATA STORAGE/LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function tokenURI(uint256 id) public view virtual returns (string memory);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                      ERC721 BALANCE/OWNER STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    mapping(uint256 => TokenData) internal _tokenData;\\n\\n    mapping(address => uint256) internal _balanceOf;\\n\\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\\n        require((owner = _tokenData[id].owner) != address(0), \\\"NOT_MINTED\\\");\\n    }\\n\\n    function balanceOf(address owner) public view virtual returns (uint256) {\\n        require(owner != address(0), \\\"ZERO_ADDRESS\\\");\\n\\n        return _balanceOf[owner];\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                         ERC721 APPROVAL STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    mapping(uint256 => address) public getApproved;\\n\\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC721 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 id) public virtual {\\n        address owner = _tokenData[id].owner;\\n\\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], \\\"NOT_AUTHORIZED\\\");\\n\\n        getApproved[id] = spender;\\n\\n        emit Approval(owner, spender, id);\\n    }\\n\\n    function setApprovalForAll(address operator, bool approved) public virtual {\\n        isApprovedForAll[msg.sender][operator] = approved;\\n\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) public virtual {\\n        require(from == _tokenData[id].owner, \\\"WRONG_FROM\\\");\\n\\n        require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n\\n        require(\\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\\n            \\\"NOT_AUTHORIZED\\\"\\n        );\\n\\n        // Underflow of the sender's balance is impossible because we check for\\n        // ownership above and the recipient's balance can't realistically overflow.\\n        unchecked {\\n            _balanceOf[from]--;\\n\\n            _balanceOf[to]++;\\n        }\\n\\n        _tokenData[id].owner = to;\\n\\n        delete getApproved[id];\\n\\n        emit Transfer(from, to, id);\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) public virtual {\\n        transferFrom(from, to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \\\"\\\") ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        bytes calldata data\\n    ) public virtual {\\n        transferFrom(from, to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC165 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\\n        return\\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 id) internal virtual {\\n        return _mint(to, id, 0, 0);\\n    }\\n\\n    function _mint(address to, uint256 id, uint16 sequenceId, uint80 data) internal virtual {\\n        require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n\\n        require(_tokenData[id].owner == address(0), \\\"ALREADY_MINTED\\\");\\n\\n        // Counter overflow is incredibly unrealistic.\\n        unchecked {\\n            _balanceOf[to]++;\\n        }\\n\\n        _tokenData[id] = TokenData({\\n            owner: to,\\n            sequenceId: sequenceId,\\n            data: data\\n        });\\n\\n        emit Transfer(address(0), to, id);\\n    }\\n\\n    function _burn(uint256 id) internal virtual {\\n        address owner = _tokenData[id].owner;\\n\\n        require(owner != address(0), \\\"NOT_MINTED\\\");\\n\\n        // Ownership check above ensures no underflow.\\n        unchecked {\\n            _balanceOf[owner]--;\\n        }\\n\\n        delete _tokenData[id];\\n\\n        delete getApproved[id];\\n\\n        emit Transfer(owner, address(0), id);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL SAFE MINT LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _safeMint(address to, uint256 id) internal virtual {\\n        _mint(to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, \\\"\\\") ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function _safeMint(\\n        address to,\\n        uint256 id,\\n        bytes memory data\\n    ) internal virtual {\\n        _mint(to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                    METALABEL ADDED FUNCTIONALITY\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function getTokenData(uint256 id) external view virtual returns (TokenData memory) {\\n        TokenData memory data = _tokenData[id];\\n        require(data.owner != address(0), \\\"NOT_MINTED\\\");\\n        return data;\\n    }\\n}\\n\\n/// @notice A generic interface for a contract which properly accepts ERC721 tokens.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\\nabstract contract ERC721TokenReceiver {\\n    function onERC721Received(\\n        address,\\n        address,\\n        uint256,\\n        bytes calldata\\n    ) external virtual returns (bytes4) {\\n        return ERC721TokenReceiver.onERC721Received.selector;\\n    }\\n}\\n\"\r\n    },\r\n    \"@metalabel/solmate/src/utils/SSTORE2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Read and write to persistent storage at a fraction of the cost.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SSTORE2.sol)\\n/// @author Modified from 0xSequence (https://github.com/0xSequence/sstore2/blob/master/contracts/SSTORE2.sol)\\nlibrary SSTORE2 {\\n    uint256 internal constant DATA_OFFSET = 1; // We skip the first byte as it's a STOP opcode to ensure the contract can't be called.\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               WRITE LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function write(bytes memory data) internal returns (address pointer) {\\n        // Prefix the bytecode with a STOP opcode to ensure it cannot be called.\\n        bytes memory runtimeCode = abi.encodePacked(hex\\\"00\\\", data);\\n\\n        bytes memory creationCode = abi.encodePacked(\\n            //---------------------------------------------------------------------------------------------------------------//\\n            // Opcode  | Opcode + Arguments  | Description  | Stack View                                                     //\\n            //---------------------------------------------------------------------------------------------------------------//\\n            // 0x60    |  0x600B             | PUSH1 11     | codeOffset                                                     //\\n            // 0x59    |  0x59               | MSIZE        | 0 codeOffset                                                   //\\n            // 0x81    |  0x81               | DUP2         | codeOffset 0 codeOffset                                        //\\n            // 0x38    |  0x38               | CODESIZE     | codeSize codeOffset 0 codeOffset                               //\\n            // 0x03    |  0x03               | SUB          | (codeSize - codeOffset) 0 codeOffset                           //\\n            // 0x80    |  0x80               | DUP          | (codeSize - codeOffset) (codeSize - codeOffset) 0 codeOffset   //\\n            // 0x92    |  0x92               | SWAP3        | codeOffset (codeSize - codeOffset) 0 (codeSize - codeOffset)   //\\n            // 0x59    |  0x59               | MSIZE        | 0 codeOffset (codeSize - codeOffset) 0 (codeSize - codeOffset) //\\n            // 0x39    |  0x39               | CODECOPY     | 0 (codeSize - codeOffset)                                      //\\n            // 0xf3    |  0xf3               | RETURN       |                                                                //\\n            //---------------------------------------------------------------------------------------------------------------//\\n            hex\\\"60_0B_59_81_38_03_80_92_59_39_F3\\\", // Returns all code in the contract except for the first 11 (0B in hex) bytes.\\n            runtimeCode // The bytecode we want the contract to have after deployment. Capped at 1 byte less than the code size limit.\\n        );\\n\\n        assembly {\\n            // Deploy a new contract with the generated creation code.\\n            // We start 32 bytes into the code to avoid copying the byte length.\\n            pointer := create(0, add(creationCode, 32), mload(creationCode))\\n        }\\n\\n        require(pointer != address(0), \\\"DEPLOYMENT_FAILED\\\");\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               READ LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function read(address pointer) internal view returns (bytes memory) {\\n        return readBytecode(pointer, DATA_OFFSET, pointer.code.length - DATA_OFFSET);\\n    }\\n\\n    function read(address pointer, uint256 start) internal view returns (bytes memory) {\\n        start += DATA_OFFSET;\\n\\n        return readBytecode(pointer, start, pointer.code.length - start);\\n    }\\n\\n    function read(\\n        address pointer,\\n        uint256 start,\\n        uint256 end\\n    ) internal view returns (bytes memory) {\\n        start += DATA_OFFSET;\\n        end += DATA_OFFSET;\\n\\n        require(pointer.code.length >= end, \\\"OUT_OF_BOUNDS\\\");\\n\\n        return readBytecode(pointer, start, end - start);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                          INTERNAL HELPER LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function readBytecode(\\n        address pointer,\\n        uint256 start,\\n        uint256 size\\n    ) private view returns (bytes memory data) {\\n        assembly {\\n            // Get a pointer to some free memory.\\n            data := mload(0x40)\\n\\n            // Update the free memory pointer to prevent overriding our data.\\n            // We use and(x, not(31)) as a cheaper equivalent to sub(x, mod(x, 32)).\\n            // Adding 31 to size and running the result through the logic above ensures\\n            // the memory pointer remains word-aligned, following the Solidity convention.\\n            mstore(0x40, add(data, and(add(add(size, 32), 31), not(31))))\\n\\n            // Store the size of the data in the first 32 byte chunk of free memory.\\n            mstore(data, size)\\n\\n            // Copy the code into memory right after the 32 bytes we used to store the size.\\n            extcodecopy(pointer, add(data, 32), start, size)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/interfaces/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/introspection/IERC165.sol\\\";\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/interfaces/IERC2981.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (interfaces/IERC2981.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Interface for the NFT Royalty Standard.\\n *\\n * A standardized way to retrieve royalty payment information for non-fungible tokens (NFTs) to enable universal\\n * support for royalty payments across all NFT marketplaces and ecosystem participants.\\n *\\n * _Available since v4.5._\\n */\\ninterface IERC2981 is IERC165 {\\n    /**\\n     * @dev Returns how much royalty is owed and to whom, based on a sale price that may be denominated in any unit of\\n     * exchange. The royalty amount is denominated and should be paid in that same unit of exchange.\\n     */\\n    function royaltyInfo(uint256 tokenId, uint256 salePrice)\\n        external\\n        view\\n        returns (address receiver, uint256 royaltyAmount);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/Collection.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\n/*\\n\\n\u2588\u2588\u2588\u2557   \u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557      \u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2557\\n\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u2550\u2588\u2588\u2554\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551     \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2551\\n\u2588\u2588\u2554\u2588\u2588\u2588\u2588\u2554\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2557     \u2588\u2588\u2551   \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2551     \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2551\\n\u2588\u2588\u2551\u255a\u2588\u2588\u2554\u255d\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u255d     \u2588\u2588\u2551   \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551\u2588\u2588\u2551     \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u255d  \u2588\u2588\u2551\\n\u2588\u2588\u2551 \u255a\u2550\u255d \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557   \u2588\u2588\u2551   \u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\\n\u255a\u2550\u255d     \u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d   \u255a\u2550\u255d   \u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\\n\\n\\nDeployed by Metalabel with \ud83d\udc96 as a permanent application on the Ethereum blockchain.\\n\\nMetalabel is a growing universe of tools, knowledge, and resources for\\nmetalabels and cultural collectives.\\n\\nOur purpose is to establish the metalabel as key infrastructure for creative\\ncollectives and to inspire a new culture of creative collaboration and mutual\\nsupport.\\n\\nOUR SQUAD\\n\\nAnna Bulbrook (Curator)\\nAustin Robey (Community)\\nBrandon Valosek (Engineer)\\nIlya Yudanov (Designer)\\nLauren Dorman (Engineer)\\nRob Kalin (Board)\\nYancey Strickler (Director)\\n\\nhttps://metalabel.xyz\\n\\n*/\\n\\nimport {IERC165} from \\\"@openzeppelin/contracts/interfaces/IERC165.sol\\\";\\nimport {IERC2981} from \\\"@openzeppelin/contracts/interfaces/IERC2981.sol\\\";\\nimport {ERC721} from \\\"@metalabel/solmate/src/tokens/ERC721.sol\\\";\\nimport {SSTORE2} from \\\"@metalabel/solmate/src/utils/SSTORE2.sol\\\";\\nimport {INodeRegistry} from \\\"./interfaces/INodeRegistry.sol\\\";\\nimport {IEngine, SequenceData} from \\\"./interfaces/IEngine.sol\\\";\\nimport {ICollection} from \\\"./interfaces/ICollection.sol\\\";\\nimport {Resource, AccessControlData} from \\\"./Resource.sol\\\";\\n\\n/// @notice Immutable data stored per-collection.\\n/// @dev This is stored via SSTORE2 to save gas.\\nstruct ImmutableCollectionData {\\n    string name;\\n    string symbol;\\n    string contractURI;\\n}\\n\\n/// @notice Collections are ERC721 contracts that contain records.\\n/// - Minting logic, tokenURI, and royalties are delegated to an external engine\\n///     contract\\n/// - Sequences are a mapping between an external engine contract and parameters\\n///     stored in the collection\\n/// - Multiple sequences can be configured for a single collection, records may\\n///     be rendered and minted in a variety of different ways\\ncontract Collection is ERC721, Resource, ICollection, IERC2981 {\\n    // ---\\n    // Errors\\n    // ---\\n\\n    /// @notice The init function was called more than once.\\n    error AlreadyInitialized();\\n\\n    /// @notice A record mint attempt was made for a sequence that is currently\\n    /// sealed.\\n    error SequenceIsSealed();\\n\\n    /// @notice A record mint attempt was made for a sequence that has no\\n    /// remaining supply.\\n    error SequenceSupplyExhausted();\\n\\n    /// @notice An invalid sequence config was provided during configuration.\\n    error InvalidSequenceConfig();\\n\\n    /// @notice msg.sender during a mint call did not match expected engine\\n    /// origin.\\n    error InvalidMintRequest();\\n\\n    // ---\\n    // Events\\n    // ---\\n\\n    /// @notice A new record was minted.\\n    /// @dev The underlying ERC721 implementation already emits a Transfer event\\n    /// on mint, this event announces the sequence the token is minted into and\\n    /// its immutable token data.\\n    event RecordCreated(\\n        uint256 indexed tokenId,\\n        uint16 indexed sequenceId,\\n        uint80 data\\n    );\\n\\n    /// @notice A sequence has been set or updated.\\n    event SequenceConfigured(\\n        uint16 indexed sequenceId,\\n        SequenceData sequenceData,\\n        bytes engineData\\n    );\\n\\n    /// @notice The owner address of this collection was updated.\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    // ---\\n    // Storage\\n    // ---\\n\\n    /// @notice Total number of records minted in this collection.\\n    uint256 public totalSupply;\\n\\n    /// @notice Total number of sequences configured in this collection.\\n    uint16 public sequenceCount;\\n\\n    /// @notice Only for marketplace interop, can be set by owner of the control\\n    /// node.\\n    address public owner;\\n\\n    /// @notice The SSTORE2 storage pointer for immutable collection data.\\n    /// @dev This data is exposed through name, symbol, and contractURI views\\n    address internal immutableStoragePointer;\\n\\n    /// @notice Information about each sequence.\\n    mapping(uint16 => SequenceData) internal sequences;\\n\\n    // ---\\n    // Constructor\\n    // ---\\n\\n    /// @dev Constructor only called during deployment of the implementation,\\n    /// all storage should be set up in init function which is called atomically\\n    /// after clone deployment\\n    constructor() {\\n        // Write dummy data to the immutable storage pointer to prevent\\n        // initialization of the implementation contract.\\n        immutableStoragePointer = SSTORE2.write(\\n            abi.encode(\\n                ImmutableCollectionData({name: \\\"\\\", symbol: \\\"\\\", contractURI: \\\"\\\"})\\n            )\\n        );\\n    }\\n\\n    // ---\\n    // Clone init\\n    // ---\\n\\n    /// @notice Initialize contract state.\\n    /// @dev Should be called immediately after deploying the clone in the same\\n    /// transaction.\\n    function init(\\n        address _owner,\\n        AccessControlData calldata _accessControl,\\n        string calldata _metadata,\\n        ImmutableCollectionData calldata _data\\n    ) external {\\n        if (immutableStoragePointer != address(0)) revert AlreadyInitialized();\\n        immutableStoragePointer = SSTORE2.write(abi.encode(_data));\\n\\n        // Set ERC721 market interop.\\n        owner = _owner;\\n        emit OwnershipTransferred(address(0), owner);\\n\\n        // Assign access control data.\\n        accessControl = _accessControl;\\n\\n        // This memberships collection is a resource that can be cataloged -\\n        // emit the initial metadata value\\n        emit Broadcast(\\\"metadata\\\", _metadata);\\n    }\\n\\n    // ---\\n    // Admin functionality\\n    // ---\\n\\n    /// @notice Change the owner address of this collection.\\n    /// @dev This is only here for market interop, access control is handled via\\n    /// the control node.\\n    function setOwner(address _owner) external onlyAuthorized {\\n        address previousOwner = owner;\\n        owner = _owner;\\n        emit OwnershipTransferred(previousOwner, _owner);\\n    }\\n\\n    /// @notice Create a new sequence configuration.\\n    /// @dev The _engineData bytes parameter is arbitrary data that is passed\\n    /// directly to the engine powering this new sequence.\\n    function configureSequence(\\n        SequenceData calldata _sequence,\\n        bytes calldata _engineData\\n    ) external onlyAuthorized {\\n        // The drop this sequence is associated with must be manageable by\\n        // msg.sender. This is in addition to the onlyAuthorized modifier which\\n        // asserts msg.sender can manage the control node of the whole\\n        // collection.\\n        // msg.sender is either a metalabel admin EOA, or a controller contract\\n        // that has been authorized to do drops on the drop node.\\n        if (\\n            !accessControl.nodeRegistry.isAuthorizedAddressForNode(\\n                _sequence.dropNodeId,\\n                msg.sender\\n            )\\n        ) {\\n            revert NotAuthorized();\\n        }\\n\\n        // If there is sealedAfter timestamp (i.e timebound sequence), ensure\\n        // that sealedBefore is strictly less than sealedAfter AND that\\n        // sealedAfter occurs strictly in the future. If sealedAfter is zero,\\n        // there is no time limit. We are allowing cases where sealedBefore\\n        // occurs in the past.\\n        if (\\n            _sequence.sealedAfterTimestamp > 0 &&\\n            (_sequence.sealedBeforeTimestamp >=\\n                _sequence.sealedAfterTimestamp ||\\n                _sequence.sealedAfterTimestamp <= block.timestamp)\\n        ) {\\n            revert InvalidSequenceConfig();\\n        }\\n\\n        // Prevent having a minted count before the sequence starts. This\\n        // wouldn't break anything, but would cause the indexed \\\"minted\\\" amount\\n        // from actual mints to differ from the sequence data tracking total\\n        // supply, which is non-ideal and worth the small gas to check.\\n        //\\n        // We're not using a separate struct here for inputs that omits the\\n        // minted count field, being able to copy from calldata to storage is\\n        // nice.\\n        if (_sequence.minted != 0) {\\n            revert InvalidSequenceConfig();\\n        }\\n\\n        // Write sequence data to storage\\n        uint16 sequenceId = ++sequenceCount;\\n        sequences[sequenceId] = _sequence;\\n        emit SequenceConfigured(sequenceId, _sequence, _engineData);\\n\\n        // Invoke configureSequence on the engine to give it a chance to setup\\n        // and store any needed info. Doing this after event emitting so that\\n        // indexers see the sequence first before any engine-side events\\n        _sequence.engine.configureSequence(sequenceId, _sequence, _engineData);\\n    }\\n\\n    // ---\\n    // Engine functionality\\n    // ---\\n\\n    /// @inheritdoc ICollection\\n    function mintRecord(\\n        address to,\\n        uint16 sequenceId,\\n        uint80 tokenData\\n    ) external returns (uint256 tokenId) {\\n        SequenceData storage sequence = sequences[sequenceId];\\n        _validateSequence(sequence);\\n\\n        // Mint the record.\\n        tokenId = ++totalSupply;\\n        ++sequence.minted;\\n        _mint(to, tokenId, sequenceId, tokenData);\\n        emit RecordCreated(tokenId, sequenceId, tokenData);\\n    }\\n\\n    /// @inheritdoc ICollection\\n    function mintRecord(address to, uint16 sequenceId)\\n        external\\n        returns (uint256 tokenId)\\n    {\\n        SequenceData storage sequence = sequences[sequenceId];\\n        _validateSequence(sequence);\\n\\n        // Mint the record.\\n        tokenId = ++totalSupply;\\n        uint64 editionNumber = ++sequence.minted;\\n        _mint(to, tokenId, sequenceId, editionNumber);\\n        emit RecordCreated(tokenId, sequenceId, editionNumber);\\n    }\\n\\n    /// @dev Ensure a given sequence is valid to mint into by the current msg.sender\\n    function _validateSequence(SequenceData memory sequence) internal view {\\n        // Ensure that only the engine for this sequence can mint records. Mint\\n        // transactions termiante on the engine side - the engine then invokes\\n        // the mint functions on the Collection.\\n        if (sequence.engine != IEngine(msg.sender)) {\\n            revert InvalidMintRequest();\\n        }\\n\\n        // Ensure that mint is not happening before or after allowed window.\\n        if (\\n            block.timestamp < sequence.sealedBeforeTimestamp ||\\n            (sequence.sealedAfterTimestamp > 0 && // sealed after = 0 => no end\\n                block.timestamp >= sequence.sealedAfterTimestamp)\\n        ) {\\n            revert SequenceIsSealed();\\n        }\\n\\n        // Ensure we have remaining supply to mint\\n        if (sequence.maxSupply > 0 && sequence.minted >= sequence.maxSupply) {\\n            revert SequenceSupplyExhausted();\\n        }\\n    }\\n\\n    // ---\\n    // ICollection views\\n    // ---\\n\\n    /// @inheritdoc ICollection\\n    function getSequenceData(uint16 sequenceId)\\n        external\\n        view\\n        override\\n        returns (SequenceData memory sequence)\\n    {\\n        sequence = sequences[sequenceId];\\n    }\\n\\n    // ---\\n    // ERC721 views\\n    // ---\\n\\n    /// @notice The collection name.\\n    function name() public view virtual returns (string memory value) {\\n        value = _resolveImmutableStorage().name;\\n    }\\n\\n    /// @notice The collection symbol.\\n    function symbol() public view virtual returns (string memory value) {\\n        value = _resolveImmutableStorage().symbol;\\n    }\\n\\n    /// @inheritdoc ERC721\\n    /// @dev Resolve token URI from the engine powering the sequence.\\n    function tokenURI(uint256 tokenId)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (string memory uri)\\n    {\\n        IEngine engine = sequences[_tokenData[tokenId].sequenceId].engine;\\n        uri = engine.getTokenURI(address(this), tokenId);\\n    }\\n\\n    /// @notice Get the contract URI.\\n    function contractURI() public view virtual returns (string memory value) {\\n        value = _resolveImmutableStorage().contractURI;\\n    }\\n\\n    // ---\\n    // Misc views\\n    // ---\\n\\n    /// @inheritdoc ICollection\\n    function tokenSequenceId(uint256 tokenId)\\n        external\\n        view\\n        returns (uint16 sequenceId)\\n    {\\n        sequenceId = _tokenData[tokenId].sequenceId;\\n    }\\n\\n    /// @inheritdoc ICollection\\n    /// @dev Token mint data is either edition number or arbitrary custom data\\n    /// passed in the by the engine at mint-time.\\n    function tokenMintData(uint256 tokenId)\\n        external\\n        view\\n        returns (uint80 data)\\n    {\\n        data = _tokenData[tokenId].data;\\n    }\\n\\n    // ---\\n    // ERC2981 functionality\\n    // ---\\n\\n    /// @inheritdoc IERC2981\\n    /// @dev Resolve royalty info from the engine powering the sequence.\\n    function royaltyInfo(uint256 tokenId, uint256 salePrice)\\n        external\\n        view\\n        returns (address receiver, uint256 royaltyAmount)\\n    {\\n        IEngine engine = sequences[_tokenData[tokenId].sequenceId].engine;\\n        return engine.getRoyaltyInfo(address(this), tokenId, salePrice);\\n    }\\n\\n    // ---\\n    // Introspection\\n    // ---\\n\\n    /// @inheritdoc IERC165\\n    /// @dev ERC165 checks return true for: ERC165, ERC721, and ERC2981.\\n    function supportsInterface(bytes4 interfaceId)\\n        public\\n        view\\n        virtual\\n        override(ERC721, IERC165)\\n        returns (bool)\\n    {\\n        return\\n            interfaceId == type(IERC2981).interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n    // ---\\n    // Internal views\\n    // ---\\n\\n    /// @dev Read name/symbol/contractURI strings via SSTORE2.\\n    function _resolveImmutableStorage()\\n        internal\\n        view\\n        returns (ImmutableCollectionData memory data)\\n    {\\n        data = abi.decode(\\n            SSTORE2.read(immutableStoragePointer),\\n            (ImmutableCollectionData)\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ICollection.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport {SequenceData} from \\\"./IEngine.sol\\\";\\n\\n/// @notice Collections are ERC721 contracts that contain records.\\ninterface ICollection {\\n    /// @notice Mint a new record with custom immutable token data. Only\\n    /// callable by the sequence-specific engine.\\n    function mintRecord(\\n        address to,\\n        uint16 sequenceId,\\n        uint80 tokenData\\n    ) external returns (uint256 tokenId);\\n\\n    /// @notice Mint a new record with the edition number of the sequence\\n    /// written to the immutable token data. Only callable by the\\n    /// sequence-specific engine.\\n    function mintRecord(address to, uint16 sequenceId)\\n        external\\n        returns (uint256 tokenId);\\n\\n    /// @notice Get the sequence ID for a given token.\\n    function tokenSequenceId(uint256 tokenId)\\n        external\\n        view\\n        returns (uint16 sequenceId);\\n\\n    /// @notice Get the immutable mint data for a given token.\\n    function tokenMintData(uint256 tokenId) external view returns (uint80 data);\\n\\n    /// @notice Get the sequence data for a given sequence ID.\\n    function getSequenceData(uint16 sequenceId)\\n        external\\n        view\\n        returns (SequenceData memory);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IEngine.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\n/// @notice Data stored in the collection for each sequence.\\n/// @dev We could use smaller ints for timestamps and supply, but we'd still be\\n/// stuck with a 2-word storage layout. engine + dropNodeId is 28 bytes, leaving\\n/// us with only 4 bytes for the remaining parameters.\\nstruct SequenceData {\\n    uint64 sealedBeforeTimestamp;\\n    uint64 sealedAfterTimestamp;\\n    uint64 maxSupply;\\n    uint64 minted;\\n    // ^ 1 word\\n    IEngine engine;\\n    uint64 dropNodeId;\\n    // 4 bytes remaining\\n}\\n\\n/// @notice An engine contract implements record minting mechanics, tokenURI\\n/// computation, and royalty computation.\\ninterface IEngine {\\n    /// @notice Called by the collection when a new sequence is configured.\\n    /// @dev An arbitrary bytes buffer engineData is forwarded from the\\n    /// collection that can be used to pass setup and configuration data\\n    function configureSequence(\\n        uint16 sequenceId,\\n        SequenceData calldata sequence,\\n        bytes calldata engineData\\n    ) external;\\n\\n    /// @notice Called by the collection to resolve tokenURI.\\n    function getTokenURI(address collection, uint256 tokenId)\\n        external\\n        view\\n        returns (string memory);\\n\\n    /// @notice Called by the collection to resolve royalties.\\n    function getRoyaltyInfo(\\n        address collection,\\n        uint256 tokenId,\\n        uint256 salePrice\\n    ) external view returns (address receiver, uint256 royaltyAmount);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/INodeRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nenum NodeType {\\n    INVALID_NODE_TYPE,\\n    METALABEL,\\n    RELEASE\\n}\\n\\n/// @notice Data stored per node.\\nstruct NodeData {\\n    NodeType nodeType;\\n    uint64 owner;\\n    uint64 parent;\\n    uint64 groupNode;\\n    // 7 bytes remaining\\n}\\n\\n/// @notice The node registry maintains a tree of ownable nodes that are used to\\n/// catalog logical entities and manage access control in the Metalabel\\n/// universe.\\ninterface INodeRegistry {\\n    /// @notice Create a new node. Child nodes can specify an group node that\\n    /// will be used to determine ownership, and a separate logical parent that\\n    /// expresses the entity relationship.  Child nodes can only be created if\\n    /// msg.sender is an authorized manager of the parent node.\\n    function createNode(\\n        NodeType nodeType,\\n        uint64 owner,\\n        uint64 parent,\\n        uint64 groupNode,\\n        address[] memory initialControllers,\\n        string memory metadata\\n    ) external returns (uint64 id);\\n\\n    /// @notice Determine if an address is authorized to manage a node.\\n    /// A node can be managed by an address if any of the following conditions\\n    /// are true:\\n    ///   - The address's account is the owner of the node\\n    ///   - The address's account is the owner of the node's group node\\n    ///   - The address is an authorized controller of the node\\n    ///   - The address is an authorized controller of the node's group node\\n    function isAuthorizedAddressForNode(uint64 node, address subject)\\n        external\\n        view\\n        returns (bool isAuthorized);\\n\\n    /// @notice Resolve node owner account.\\n    function ownerOf(uint64 id) external view returns (uint64);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IResource.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport {INodeRegistry} from \\\"./INodeRegistry.sol\\\";\\n\\n/// @notice An on-chain resource that is intended to be cataloged within the\\n/// Metalabel universe\\ninterface IResource {\\n    /// @notice Broadcast an arbitrary message.\\n    event Broadcast(string topic, string message);\\n\\n    /// @notice Return the node registry contract address.\\n    function nodeRegistry() external view returns (INodeRegistry);\\n\\n    /// @notice Return the control node ID for this resource.\\n    function controlNode() external view returns (uint64 nodeId);\\n\\n    /// @notice Return true if the given address is authorized to manage this\\n    /// resource.\\n    function isAuthorized(address subject)\\n        external\\n        view\\n        returns (bool authorized);\\n\\n    /// @notice Emit an on-chain message. msg.sender must be authorized to\\n    /// manage this resource's control node\\n    function broadcast(string calldata topic, string calldata message) external;\\n}\\n\"\r\n    },\r\n    \"contracts/Resource.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\n/*\\n\\n\u2588\u2588\u2588\u2557   \u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557      \u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2557\\n\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u2550\u2588\u2588\u2554\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551     \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2551\\n\u2588\u2588\u2554\u2588\u2588\u2588\u2588\u2554\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2557     \u2588\u2588\u2551   \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2551     \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2551\\n\u2588\u2588\u2551\u255a\u2588\u2588\u2554\u255d\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u255d     \u2588\u2588\u2551   \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551\u2588\u2588\u2551     \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u255d  \u2588\u2588\u2551\\n\u2588\u2588\u2551 \u255a\u2550\u255d \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557   \u2588\u2588\u2551   \u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\\n\u255a\u2550\u255d     \u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d   \u255a\u2550\u255d   \u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\\n\\n\\nDeployed by Metalabel with \ud83d\udc96 as a permanent application on the Ethereum blockchain.\\n\\nMetalabel is a growing universe of tools, knowledge, and resources for\\nmetalabels and cultural collectives.\\n\\nOur purpose is to establish the metalabel as key infrastructure for creative\\ncollectives and to inspire a new culture of creative collaboration and mutual\\nsupport.\\n\\nOUR SQUAD\\n\\nAnna Bulbrook (Curator)\\nAustin Robey (Community)\\nBrandon Valosek (Engineer)\\nIlya Yudanov (Designer)\\nLauren Dorman (Engineer)\\nRob Kalin (Board)\\nYancey Strickler (Director)\\n\\nhttps://metalabel.xyz\\n\\n*/\\n\\nimport {IResource} from \\\"./interfaces/IResource.sol\\\";\\nimport {INodeRegistry} from \\\"./interfaces/INodeRegistry.sol\\\";\\n\\n/// @notice Data stored for handling access control resolution.\\nstruct AccessControlData {\\n    INodeRegistry nodeRegistry;\\n    uint64 controlNodeId;\\n    // 4 bytes remaining\\n}\\n\\n/// @notice A resource that can be cataloged on the Metalabel protocol.\\ncontract Resource is IResource {\\n    // ---\\n    // Errors\\n    // ---\\n\\n    /// @notice Unauthorized msg.sender attempted to interact with this resource\\n    error NotAuthorized();\\n\\n    // ---\\n    // Storage\\n    // ---\\n\\n    /// @notice Access control data for this resource.\\n    AccessControlData public accessControl;\\n\\n    // ---\\n    // Modifiers\\n    // ---\\n\\n    /// @dev Make a function only callable by a msg.sender that is authorized to\\n    /// manage the control node of this resource\\n    modifier onlyAuthorized() {\\n        if (\\n            !accessControl.nodeRegistry.isAuthorizedAddressForNode(\\n                accessControl.controlNodeId,\\n                msg.sender\\n            )\\n        ) {\\n            revert NotAuthorized();\\n        }\\n        _;\\n    }\\n\\n    // ---\\n    // Admin functionality\\n    // ---\\n\\n    /// @inheritdoc IResource\\n    function broadcast(string calldata topic, string calldata message)\\n        external\\n        onlyAuthorized\\n    {\\n        emit Broadcast(topic, message);\\n    }\\n\\n    // ---\\n    // Resource views\\n    // ---\\n\\n    /// @inheritdoc IResource\\n    function nodeRegistry() external view virtual returns (INodeRegistry) {\\n        return accessControl.nodeRegistry;\\n    }\\n\\n    /// @inheritdoc IResource\\n    function controlNode() external view virtual returns (uint64 nodeId) {\\n        return accessControl.controlNodeId;\\n    }\\n\\n    /// @inheritdoc IResource\\n    function isAuthorized(address subject)\\n        public\\n        view\\n        virtual\\n        returns (bool authorized)\\n    {\\n        authorized = accessControl.nodeRegistry.isAuthorizedAddressForNode(\\n            accessControl.controlNodeId,\\n            subject\\n        );\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AlreadyInitialized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidMintRequest\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSequenceConfig\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotAuthorized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SequenceIsSealed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SequenceSupplyExhausted\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"topic\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"}],\"name\":\"Broadcast\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint16\",\"name\":\"sequenceId\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint80\",\"name\":\"data\",\"type\":\"uint80\"}],\"name\":\"RecordCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint16\",\"name\":\"sequenceId\",\"type\":\"uint16\"},{\"components\":[{\"internalType\":\"uint64\",\"name\":\"sealedBeforeTimestamp\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"sealedAfterTimestamp\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"maxSupply\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"minted\",\"type\":\"uint64\"},{\"internalType\":\"contract IEngine\",\"name\":\"engine\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"dropNodeId\",\"type\":\"uint64\"}],\"indexed\":false,\"internalType\":\"struct SequenceData\",\"name\":\"sequenceData\",\"type\":\"tuple\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"engineData\",\"type\":\"bytes\"}],\"name\":\"SequenceConfigured\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"accessControl\",\"outputs\":[{\"internalType\":\"contract INodeRegistry\",\"name\":\"nodeRegistry\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"controlNodeId\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"topic\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"}],\"name\":\"broadcast\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"sealedBeforeTimestamp\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"sealedAfterTimestamp\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"maxSupply\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"minted\",\"type\":\"uint64\"},{\"internalType\":\"contract IEngine\",\"name\":\"engine\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"dropNodeId\",\"type\":\"uint64\"}],\"internalType\":\"struct SequenceData\",\"name\":\"_sequence\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"_engineData\",\"type\":\"bytes\"}],\"name\":\"configureSequence\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"value\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"controlNode\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"nodeId\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"sequenceId\",\"type\":\"uint16\"}],\"name\":\"getSequenceData\",\"outputs\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"sealedBeforeTimestamp\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"sealedAfterTimestamp\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"maxSupply\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"minted\",\"type\":\"uint64\"},{\"internalType\":\"contract IEngine\",\"name\":\"engine\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"dropNodeId\",\"type\":\"uint64\"}],\"internalType\":\"struct SequenceData\",\"name\":\"sequence\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getTokenData\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"sequenceId\",\"type\":\"uint16\"},{\"internalType\":\"uint80\",\"name\":\"data\",\"type\":\"uint80\"}],\"internalType\":\"struct TokenData\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"contract INodeRegistry\",\"name\":\"nodeRegistry\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"controlNodeId\",\"type\":\"uint64\"}],\"internalType\":\"struct AccessControlData\",\"name\":\"_accessControl\",\"type\":\"tuple\"},{\"internalType\":\"string\",\"name\":\"_metadata\",\"type\":\"string\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"contractURI\",\"type\":\"string\"}],\"internalType\":\"struct ImmutableCollectionData\",\"name\":\"_data\",\"type\":\"tuple\"}],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"subject\",\"type\":\"address\"}],\"name\":\"isAuthorized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"authorized\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"sequenceId\",\"type\":\"uint16\"}],\"name\":\"mintRecord\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"sequenceId\",\"type\":\"uint16\"},{\"internalType\":\"uint80\",\"name\":\"tokenData\",\"type\":\"uint80\"}],\"name\":\"mintRecord\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"value\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nodeRegistry\",\"outputs\":[{\"internalType\":\"contract INodeRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"salePrice\",\"type\":\"uint256\"}],\"name\":\"royaltyInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"royaltyAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sequenceCount\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"value\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenMintData\",\"outputs\":[{\"internalType\":\"uint80\",\"name\":\"data\",\"type\":\"uint80\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenSequenceId\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"sequenceId\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Collection", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "1000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}