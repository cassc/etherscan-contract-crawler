{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/MEVVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GLPV2\\npragma solidity ^0.8.13;\\n\\nimport \\\"./interfaces/IVaultManager.sol\\\";\\nimport \\\"./interfaces/IMEVVault.sol\\\";\\nimport \\\"./libraries/WadRayMath.sol\\\";\\n\\ncontract MEVVault is IMEVVault{\\n    using WadRayMath for uint256;\\n\\n    //We must use immutable variables since they need get injected directly into the bytecode, and we are cloning\\n    IVaultManager immutable public vaultManager;\\n\\n    //Assume precision on last rate to be relative to ray\\n    uint256 public lastFee;\\n\\n    //Constructor will only be called on deploying the implementation of MEVVaults\\n    //Clones will already have immutable variable set in bytecode, and no constructor call can be done on them\\n    //(Technically its more like the constructor call was already done for them,\\n    //bytecode wise, storage does not get copied, immutable vars are injected into bytecode at construction)\\n    constructor(address _vm) {\\n        vaultManager = IVaultManager(_vm);\\n    }\\n\\n    //User can become grandfathered into a operation fee if they have not claimed since fee change\\n    //However, anyone who wants to can claim for them at any time and reset the operation fee if they want\\n    function extractMEV() external {\\n        uint256 jinoroFee = address(this).balance.rayMul(lastFee);\\n        address payable account = payable(vaultManager.vaultToAccount(address(this)));\\n        account.transfer(address(this).balance - jinoroFee);\\n        payable(address(vaultManager)).transfer(jinoroFee);\\n        lastFee = vaultManager.JinoroFee();\\n    }\\n\\n    function updateFee() external onlyVaultManager{\\n        lastFee = vaultManager.JinoroFee();\\n    }\\n\\n    //Allow contract to receive eth\\n    receive() external payable{\\n    }\\n\\n    modifier onlyVaultManager {\\n        require(msg.sender == address(vaultManager), \\\"MEVVault: Not Authorized\\\");\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IVaultManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\ninterface IVaultManager {\\n\\n    function MEVVaultImplementation() external view returns(address);\\n\\n    function JinoroFee() external view returns (uint256);\\n\\n    function vaultToAccount(address user) external view returns (address);\\n\\n    function accountToVault(address account) external view returns(address);\\n\\n    function checkIfVaultBuilt(address account) external view returns (bool);\\n\\n    function setMEVVaultImplementation(address impl) external;\\n\\n    function setJinoroFee(uint256 newRate) external;\\n\\n    function collectVaultRewards(address account) external;\\n\\n    function collectVaultRewards() external;\\n\\n    function collectVaultRewardsBulk(address[] calldata accounts) external;\\n\\n    function buildVault(address account) external returns(address);\\n\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IMEVVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport \\\"./IVaultManager.sol\\\";\\n\\ninterface IMEVVault {\\n\\n    function vaultManager() external view returns(IVaultManager);\\n\\n    function lastFee() external view returns(uint256);\\n\\n    function extractMEV() external;\\n\\n    function updateFee() external;\\n}\\n\"\r\n    },\r\n    \"src/libraries/WadRayMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPLV2\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title WadRayMath library\\n * @author Aave\\n * @notice Provides functions to perform calculations with Wad and Ray units\\n * @dev Provides mul and div function for wads (decimal numbers with 18 digits of precision) and rays (decimal numbers\\n * with 27 digits of precision)\\n * @dev Operations are rounded. If a value is >=.5, will be rounded up, otherwise rounded down.\\n */\\nlibrary WadRayMath {\\n    // HALF_WAD and HALF_RAY expressed with extended notation as constant with operations are not supported in Yul assembly\\n    uint256 internal constant WAD = 1e18;\\n    uint256 internal constant HALF_WAD = 0.5e18;\\n\\n    uint256 internal constant RAY = 1e27;\\n    uint256 internal constant HALF_RAY = 0.5e27;\\n\\n    uint256 internal constant WAD_RAY_RATIO = 1e9;\\n\\n    /**\\n     * @dev Multiplies two wad, rounding half up to the nearest wad\\n   * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\\n   * @param a Wad\\n   * @param b Wad\\n   * @return c = a*b, in wad\\n   */\\n    function wadMul(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n        // to avoid overflow, a <= (type(uint256).max - HALF_WAD) / b\\n        assembly {\\n            if iszero(or(iszero(b), iszero(gt(a, div(sub(not(0), HALF_WAD), b))))) {\\n                revert(0, 0)\\n            }\\n\\n            c := div(add(mul(a, b), HALF_WAD), WAD)\\n        }\\n    }\\n\\n    /**\\n     * @dev Divides two wad, rounding half up to the nearest wad\\n   * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\\n   * @param a Wad\\n   * @param b Wad\\n   * @return c = a/b, in wad\\n   */\\n    function wadDiv(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n        // to avoid overflow, a <= (type(uint256).max - halfB) / WAD\\n        assembly {\\n            if or(iszero(b), iszero(iszero(gt(a, div(sub(not(0), div(b, 2)), WAD))))) {\\n                revert(0, 0)\\n            }\\n\\n            c := div(add(mul(a, WAD), div(b, 2)), b)\\n        }\\n    }\\n\\n    /**\\n     * @notice Multiplies two ray, rounding half up to the nearest ray\\n   * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\\n   * @param a Ray\\n   * @param b Ray\\n   * @return c = a raymul b\\n   */\\n    function rayMul(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n        // to avoid overflow, a <= (type(uint256).max - HALF_RAY) / b\\n        assembly {\\n            if iszero(or(iszero(b), iszero(gt(a, div(sub(not(0), HALF_RAY), b))))) {\\n                revert(0, 0)\\n            }\\n\\n            c := div(add(mul(a, b), HALF_RAY), RAY)\\n        }\\n    }\\n\\n    /**\\n     * @notice Divides two ray, rounding half up to the nearest ray\\n   * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\\n   * @param a Ray\\n   * @param b Ray\\n   * @return c = a raydiv b\\n   */\\n    function rayDiv(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n        // to avoid overflow, a <= (type(uint256).max - halfB) / RAY\\n        assembly {\\n            if or(iszero(b), iszero(iszero(gt(a, div(sub(not(0), div(b, 2)), RAY))))) {\\n                revert(0, 0)\\n            }\\n\\n            c := div(add(mul(a, RAY), div(b, 2)), b)\\n        }\\n    }\\n\\n    /**\\n     * @dev Casts ray down to wad\\n   * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\\n   * @param a Ray\\n   * @return b = a converted to wad, rounded half up to the nearest wad\\n   */\\n    function rayToWad(uint256 a) internal pure returns (uint256 b) {\\n        assembly {\\n            b := div(a, WAD_RAY_RATIO)\\n            let remainder := mod(a, WAD_RAY_RATIO)\\n            if iszero(lt(remainder, div(WAD_RAY_RATIO, 2))) {\\n                b := add(b, 1)\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts wad up to ray\\n   * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\\n   * @param a Wad\\n   * @return b = a converted in ray\\n   */\\n    function wadToRay(uint256 a) internal pure returns (uint256 b) {\\n        // to avoid overflow, b/WAD_RAY_RATIO == a\\n        assembly {\\n            b := mul(a, WAD_RAY_RATIO)\\n\\n            if iszero(eq(div(b, WAD_RAY_RATIO), a)) {\\n                revert(0, 0)\\n            }\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@openzeppelin/contracts/=node_modules/@openzeppelin/contracts/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vm\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"extractMEV\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updateFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vaultManager\",\"outputs\":[{\"internalType\":\"contract IVaultManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "MEVVault", "CompilerVersion": "v0.8.21+commit.d9974bed", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000886fb464552024bee92a47a19100530d44c27e6f", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}