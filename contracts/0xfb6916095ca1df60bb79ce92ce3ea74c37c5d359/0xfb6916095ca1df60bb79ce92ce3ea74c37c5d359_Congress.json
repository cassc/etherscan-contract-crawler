{"SourceCode": "contract owned {\r\n        address public owner;\r\n\r\n        function owned() {\r\n                owner = msg.sender;\r\n        }\r\n\r\n        modifier onlyOwner {\r\n                if (msg.sender != owner) throw;\r\n                _\r\n        }\r\n\r\n        function transferOwnership(address newOwner) onlyOwner {\r\n                owner = newOwner;\r\n        }\r\n}\r\n\r\n/* The token is used as a voting shares */\r\ncontract token {\r\n        function mintToken(address target, uint256 mintedAmount);\r\n}\r\n\r\ncontract Congress is owned {\r\n\r\n        /* Contract Variables and events */\r\n        uint public minimumQuorum;\r\n        uint public debatingPeriodInMinutes;\r\n        int public majorityMargin;\r\n        Proposal[] public proposals;\r\n        uint public numProposals;\r\n        mapping(address => uint) public memberId;\r\n        Member[] public members;\r\n\r\n        address public unicornAddress;\r\n        uint public priceOfAUnicornInFinney;\r\n\r\n        event ProposalAdded(uint proposalID, address recipient, uint amount, string description);\r\n        event Voted(uint proposalID, bool position, address voter, string justification);\r\n        event ProposalTallied(uint proposalID, int result, uint quorum, bool active);\r\n        event MembershipChanged(address member);\r\n        event ChangeOfRules(uint minimumQuorum, uint debatingPeriodInMinutes, int majorityMargin);\r\n\r\n        struct Proposal {\r\n                address recipient;\r\n                uint amount;\r\n                string description;\r\n                uint votingDeadline;\r\n                bool executed;\r\n                bool proposalPassed;\r\n                uint numberOfVotes;\r\n                int currentResult;\r\n                bytes32 proposalHash;\r\n                Vote[] votes;\r\n                mapping(address => bool) voted;\r\n        }\r\n\r\n        struct Member {\r\n                address member;\r\n                uint voteWeight;\r\n                bool canAddProposals;\r\n                string name;\r\n                uint memberSince;\r\n        }\r\n\r\n        struct Vote {\r\n                bool inSupport;\r\n                address voter;\r\n                string justification;\r\n        }\r\n\r\n\r\n        /* First time setup */\r\n        function Congress(uint minimumQuorumForProposals, uint minutesForDebate, int marginOfVotesForMajority, address congressLeader) {\r\n                minimumQuorum = minimumQuorumForProposals;\r\n                debatingPeriodInMinutes = minutesForDebate;\r\n                majorityMargin = marginOfVotesForMajority;\r\n                members.length++;\r\n                members[0] = Member({\r\n                        member: 0,\r\n                        voteWeight: 0,\r\n                        canAddProposals: false,\r\n                        memberSince: now,\r\n                        name: ''\r\n                });\r\n                if (congressLeader != 0) owner = congressLeader;\r\n\r\n        }\r\n\r\n        /*make member*/\r\n        function changeMembership(address targetMember, uint voteWeight, bool canAddProposals, string memberName) onlyOwner {\r\n                uint id;\r\n                if (memberId[targetMember] == 0) {\r\n                        memberId[targetMember] = members.length;\r\n                        id = members.length++;\r\n                        members[id] = Member({\r\n                                member: targetMember,\r\n                                voteWeight: voteWeight,\r\n                                canAddProposals: canAddProposals,\r\n                                memberSince: now,\r\n                                name: memberName\r\n                        });\r\n                } else {\r\n                        id = memberId[targetMember];\r\n                        Member m = members[id];\r\n                        m.voteWeight = voteWeight;\r\n                        m.canAddProposals = canAddProposals;\r\n                        m.name = memberName;\r\n                }\r\n\r\n                MembershipChanged(targetMember);\r\n\r\n        }\r\n\r\n        /*change rules*/\r\n        function changeVotingRules(uint minimumQuorumForProposals, uint minutesForDebate, int marginOfVotesForMajority) onlyOwner {\r\n                minimumQuorum = minimumQuorumForProposals;\r\n                debatingPeriodInMinutes = minutesForDebate;\r\n                majorityMargin = marginOfVotesForMajority;\r\n\r\n                ChangeOfRules(minimumQuorum, debatingPeriodInMinutes, majorityMargin);\r\n        }\r\n\r\n        // ribbonPriceInEther\r\n        function changeUnicorn(uint newUnicornPriceInFinney, address newUnicornAddress) onlyOwner {\r\n                unicornAddress = newUnicornAddress;\r\n                priceOfAUnicornInFinney = newUnicornPriceInFinney;\r\n        }\r\n\r\n        /* Function to create a new proposal */\r\n        function newProposalInWei(address beneficiary, uint weiAmount, string JobDescription, bytes transactionBytecode) returns(uint proposalID) {\r\n                if (memberId[msg.sender] == 0 || !members[memberId[msg.sender]].canAddProposals) throw;\r\n\r\n                proposalID = proposals.length++;\r\n                Proposal p = proposals[proposalID];\r\n                p.recipient = beneficiary;\r\n                p.amount = weiAmount;\r\n                p.description = JobDescription;\r\n                p.proposalHash = sha3(beneficiary, weiAmount, transactionBytecode);\r\n                p.votingDeadline = now + debatingPeriodInMinutes * 1 minutes;\r\n                p.executed = false;\r\n                p.proposalPassed = false;\r\n                p.numberOfVotes = 0;\r\n                ProposalAdded(proposalID, beneficiary, weiAmount, JobDescription);\r\n                numProposals = proposalID + 1;\r\n        }\r\n\r\n        /* Function to create a new proposal */\r\n        function newProposalInEther(address beneficiary, uint etherAmount, string JobDescription, bytes transactionBytecode) returns(uint proposalID) {\r\n                if (memberId[msg.sender] == 0 || !members[memberId[msg.sender]].canAddProposals) throw;\r\n\r\n                proposalID = proposals.length++;\r\n                Proposal p = proposals[proposalID];\r\n                p.recipient = beneficiary;\r\n                p.amount = etherAmount * 1 ether;\r\n                p.description = JobDescription;\r\n                p.proposalHash = sha3(beneficiary, etherAmount * 1 ether, transactionBytecode);\r\n                p.votingDeadline = now + debatingPeriodInMinutes * 1 minutes;\r\n                p.executed = false;\r\n                p.proposalPassed = false;\r\n                p.numberOfVotes = 0;\r\n                ProposalAdded(proposalID, beneficiary, etherAmount, JobDescription);\r\n                numProposals = proposalID + 1;\r\n        }\r\n\r\n        /* function to check if a proposal code matches */\r\n        function checkProposalCode(uint proposalNumber, address beneficiary, uint amount, bytes transactionBytecode) constant returns(bool codeChecksOut) {\r\n                Proposal p = proposals[proposalNumber];\r\n                return p.proposalHash == sha3(beneficiary, amount, transactionBytecode);\r\n        }\r\n\r\n        function vote(uint proposalNumber, bool supportsProposal, string justificationText) returns(uint voteID) {\r\n                if (memberId[msg.sender] == 0) throw;\r\n\r\n                uint voteWeight = members[memberId[msg.sender]].voteWeight;\r\n\r\n                Proposal p = proposals[proposalNumber]; // Get the proposal\r\n                if (p.voted[msg.sender] == true) throw; // If has already voted, cancel\r\n                p.voted[msg.sender] = true; // Set this voter as having voted\r\n                p.numberOfVotes += voteWeight; // Increase the number of votes\r\n                if (supportsProposal) { // If they support the proposal\r\n                        p.currentResult += int(voteWeight); // Increase score\r\n                } else { // If they don't\r\n                        p.currentResult -= int(voteWeight); // Decrease the score\r\n                }\r\n                // Create a log of this event\r\n                Voted(proposalNumber, supportsProposal, msg.sender, justificationText);\r\n        }\r\n\r\n        function executeProposal(uint proposalNumber, bytes transactionBytecode) returns(int result) {\r\n                Proposal p = proposals[proposalNumber];\r\n                /* Check if the proposal can be executed */\r\n                if (now < p.votingDeadline // has the voting deadline arrived?  \r\n                        || p.executed // has it been already executed? \r\n                        || p.proposalHash != sha3(p.recipient, p.amount, transactionBytecode) // Does the transaction code match the proposal? \r\n                        || p.numberOfVotes < minimumQuorum) // has minimum quorum?\r\n                        throw;\r\n\r\n                /* execute result */\r\n                if (p.currentResult > majorityMargin) {\r\n                        /* If difference between support and opposition is larger than margin */\r\n                        p.recipient.call.value(p.amount)(transactionBytecode);\r\n                        p.executed = true;\r\n                        p.proposalPassed = true;\r\n                } else {\r\n                        p.executed = true;\r\n                        p.proposalPassed = false;\r\n                }\r\n                // Fire Events\r\n                ProposalTallied(proposalNumber, p.currentResult, p.numberOfVotes, p.proposalPassed);\r\n        }\r\n\r\n        function() {\r\n                if (msg.value > priceOfAUnicornInFinney) {\r\n                        token unicorn = token(unicornAddress);\r\n                        unicorn.mintToken(msg.sender, msg.value / (priceOfAUnicornInFinney * 1 finney));\r\n                }\r\n\r\n        }\r\n}\r\n\r\n\r\ncontract MyToken is owned {\r\n        /* Public variables of the token */\r\n        string public name;\r\n        string public symbol;\r\n        uint8 public decimals;\r\n        uint256 public totalSupply;\r\n\r\n        /* This creates an array with all balances */\r\n        mapping(address => uint256) public balanceOf;\r\n        mapping(address => bool) public frozenAccount;\r\n        mapping(address => mapping(address => uint)) public allowance;\r\n        mapping(address => mapping(address => uint)) public spentAllowance;\r\n\r\n\r\n        /* This generates a public event on the blockchain that will notify clients */\r\n        event Transfer(address indexed from, address indexed to, uint256 value);\r\n        event FrozenFunds(address target, bool frozen);\r\n\r\n        /* Initializes contract with initial supply tokens to the creator of the contract */\r\n        function MyToken(uint256 initialSupply, string tokenName, uint8 decimalUnits, string tokenSymbol, address centralMinter) {\r\n                if (centralMinter != 0) owner = centralMinter; // Sets the minter\r\n                balanceOf[msg.sender] = initialSupply; // Give the creator all initial tokens                    \r\n                name = tokenName; // Set the name for display purposes     \r\n                symbol = tokenSymbol; // Set the symbol for display purposes    \r\n                decimals = decimalUnits; // Amount of decimals for display purposes        \r\n                totalSupply = initialSupply;\r\n        }\r\n\r\n        /* Send coins */\r\n        function transfer(address _to, uint256 _value) {\r\n                if (balanceOf[msg.sender] < _value) throw; // Check if the sender has enough   \r\n                if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows\r\n                if (frozenAccount[msg.sender]) throw; // Check if frozen\r\n                balanceOf[msg.sender] -= _value; // Subtract from the sender\r\n                balanceOf[_to] += _value; // Add the same to the recipient            \r\n                Transfer(msg.sender, _to, _value); // Notify anyone listening that this transfer took place\r\n        }\r\n\r\n        function mintToken(address target, uint256 mintedAmount) onlyOwner {\r\n                balanceOf[target] += mintedAmount;\r\n                totalSupply += mintedAmount;\r\n                Transfer(owner, target, mintedAmount);\r\n        }\r\n\r\n        function freezeAccount(address target, bool freeze) onlyOwner {\r\n                frozenAccount[target] = freeze;\r\n                FrozenFunds(target, freeze);\r\n        }\r\n\r\n        function transferFrom(address _from, address _to, uint256 _value) returns(bool success) {\r\n                if (balanceOf[_from] < _value) throw; // Check if the sender has enough   \r\n                if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows\r\n                if (frozenAccount[_from]) throw; // Check if frozen\r\n                if (spentAllowance[_from][msg.sender] + _value > allowance[_from][msg.sender]) throw; // Check allowance\r\n                balanceOf[_from] -= _value; // Subtract from the sender\r\n                balanceOf[_to] += _value; // Add the same to the recipient            \r\n                spentAllowance[_from][msg.sender] += _value;\r\n                Transfer(msg.sender, _to, _value);\r\n        }\r\n\r\n        function approve(address _spender, uint256 _value) returns(bool success) {\r\n                allowance[msg.sender][_spender] = _value;\r\n        }\r\n\r\n        function() {\r\n                //owner.send(msg.value);\r\n                throw;\r\n        }\r\n}", "ABI": "[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"proposals\",\"outputs\":[{\"name\":\"recipient\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"description\",\"type\":\"string\"},{\"name\":\"votingDeadline\",\"type\":\"uint256\"},{\"name\":\"executed\",\"type\":\"bool\"},{\"name\":\"proposalPassed\",\"type\":\"bool\"},{\"name\":\"numberOfVotes\",\"type\":\"uint256\"},{\"name\":\"currentResult\",\"type\":\"int256\"},{\"name\":\"proposalHash\",\"type\":\"bytes32\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"proposalNumber\",\"type\":\"uint256\"},{\"name\":\"transactionBytecode\",\"type\":\"bytes\"}],\"name\":\"executeProposal\",\"outputs\":[{\"name\":\"result\",\"type\":\"int256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"memberId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numProposals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"priceOfAUnicornInFinney\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newUnicornPriceInFinney\",\"type\":\"uint256\"},{\"name\":\"newUnicornAddress\",\"type\":\"address\"}],\"name\":\"changeUnicorn\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"members\",\"outputs\":[{\"name\":\"member\",\"type\":\"address\"},{\"name\":\"voteWeight\",\"type\":\"uint256\"},{\"name\":\"canAddProposals\",\"type\":\"bool\"},{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"memberSince\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"debatingPeriodInMinutes\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minimumQuorum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"targetMember\",\"type\":\"address\"},{\"name\":\"voteWeight\",\"type\":\"uint256\"},{\"name\":\"canAddProposals\",\"type\":\"bool\"},{\"name\":\"memberName\",\"type\":\"string\"}],\"name\":\"changeMembership\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"beneficiary\",\"type\":\"address\"},{\"name\":\"weiAmount\",\"type\":\"uint256\"},{\"name\":\"JobDescription\",\"type\":\"string\"},{\"name\":\"transactionBytecode\",\"type\":\"bytes\"}],\"name\":\"newProposalInWei\",\"outputs\":[{\"name\":\"proposalID\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"majorityMargin\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"unicornAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"beneficiary\",\"type\":\"address\"},{\"name\":\"etherAmount\",\"type\":\"uint256\"},{\"name\":\"JobDescription\",\"type\":\"string\"},{\"name\":\"transactionBytecode\",\"type\":\"bytes\"}],\"name\":\"newProposalInEther\",\"outputs\":[{\"name\":\"proposalID\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"minimumQuorumForProposals\",\"type\":\"uint256\"},{\"name\":\"minutesForDebate\",\"type\":\"uint256\"},{\"name\":\"marginOfVotesForMajority\",\"type\":\"int256\"}],\"name\":\"changeVotingRules\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"proposalNumber\",\"type\":\"uint256\"},{\"name\":\"supportsProposal\",\"type\":\"bool\"},{\"name\":\"justificationText\",\"type\":\"string\"}],\"name\":\"vote\",\"outputs\":[{\"name\":\"voteID\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"proposalNumber\",\"type\":\"uint256\"},{\"name\":\"beneficiary\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"transactionBytecode\",\"type\":\"bytes\"}],\"name\":\"checkProposalCode\",\"outputs\":[{\"name\":\"codeChecksOut\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"type\":\"function\"},{\"inputs\":[{\"name\":\"minimumQuorumForProposals\",\"type\":\"uint256\"},{\"name\":\"minutesForDebate\",\"type\":\"uint256\"},{\"name\":\"marginOfVotesForMajority\",\"type\":\"int256\"},{\"name\":\"congressLeader\",\"type\":\"address\"}],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"proposalID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"description\",\"type\":\"string\"}],\"name\":\"ProposalAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"proposalID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"position\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"voter\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"justification\",\"type\":\"string\"}],\"name\":\"Voted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"proposalID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"result\",\"type\":\"int256\"},{\"indexed\":false,\"name\":\"quorum\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"active\",\"type\":\"bool\"}],\"name\":\"ProposalTallied\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"member\",\"type\":\"address\"}],\"name\":\"MembershipChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"minimumQuorum\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"debatingPeriodInMinutes\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"majorityMargin\",\"type\":\"int256\"}],\"name\":\"ChangeOfRules\",\"type\":\"event\"}]", "ContractName": "Congress", "CompilerVersion": "v0.2.0-2016-01-13-d2f18c7", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}