{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.17;\r\n\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the decimals places of the token.\r\n     */\r\n    function decimals() external view returns (uint8);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract VRVesting {\r\n\r\n    uint[12] public lockedDateList = [\r\n        1709366400, // UTC 2024-03-02 08:00:00 AM\r\n        1712044800, // UTC 2024-04-02 08:00:00 AM\r\n        1714636800, // UTC 2024-05-02 08:00:00 AM\r\n        1717315200, // UTC 2024-06-02 08:00:00 AM\r\n        1719907200, // UTC 2024-07-02 08:00:00 AM\r\n        1722585600, // UTC 2024-08-02 08:00:00 AM\r\n        1725264000, // UTC 2024-09-02 08:00:00 AM\r\n        1727856000, // UTC 2024-10-02 08:00:00 AM\r\n        1730534400, // UTC 2024-11-02 08:00:00 AM\r\n        1733126400, // UTC 2024-12-02 08:00:00 AM\r\n        1735804800, // UTC 2025-01-02 08:00:00 AM\r\n        1738483200  // UTC 2025-02-02 08:00:00 AM\r\n    ];\r\n\r\n    address public tokenAddress = 0x7d5121505149065b562C789A0145eD750e6E8cdD;\r\n\r\n    address public unlockAddress = 0xC4df3507B91dEbc8ab355825BB75528ee46880c2;\r\n\r\n    uint256 public totalAmount;\r\n\r\n    uint256 public unlockedAmount;\r\n\r\n    uint256 public monthUnlockAmount;\r\n\r\n    uint256 public lastUnlockTime;\r\n\r\n    uint256 public maxUnlockTimes = 12;\r\n\r\n    event MonthUnlock(address indexed mananger, uint256 day, uint256 amount);\r\n\r\n    bool internal locked = false;\r\n\r\n    modifier unlockCheck() {\r\n        require(!locked);\r\n        locked = true;\r\n        if(unlockedAmount == 0) {\r\n            require(\r\n                balanceOf() >= totalAmount,\r\n                \"The project party is requested to transfer enough tokens to start the lock up contract\"\r\n            );\r\n        }\r\n        require(msg.sender == unlockAddress, \"You do not have permission to unlock\");\r\n        _;\r\n        locked = false;\r\n    }\r\n\r\n    constructor() {\r\n        totalAmount = (10 ** IERC20(tokenAddress).decimals()) * 25_000_000;   // total 25 million\r\n        monthUnlockAmount = totalAmount / 12;                                 // Unlock 12% every month\r\n    }\r\n\r\n    function blockTimestamp() public view returns(uint256) {\r\n        return block.timestamp;\r\n    }\r\n\r\n    function getUnlockedTimes() public view returns(uint256) {\r\n        uint256 t;\r\n        for(uint i = 0; i < lockedDateList.length; i++) {\r\n            if(blockTimestamp() >= lockedDateList[i]) {\r\n                t++;\r\n            }\r\n        }\r\n        return t;\r\n    }\r\n\r\n    function balanceOf() public view returns(uint256) {\r\n        return IERC20(tokenAddress).balanceOf(address(this));\r\n    }\r\n\r\n    function _safeTransfer(uint256 unlockToken) private {\r\n        require(balanceOf() >= unlockToken, \"Insufficient available balance for transfer\");\r\n        IERC20(tokenAddress).transfer(unlockAddress, unlockToken);\r\n    }\r\n\r\n    function viewMonthUnlock() public view returns(uint) {\r\n        uint256 unlockTime = getUnlockedTimes();\r\n        uint256 unlockToken;\r\n        if(unlockTime >= maxUnlockTimes) {\r\n            unlockToken = balanceOf();\r\n        } else {\r\n            uint256 allowUnlockCount = unlockTime - lastUnlockTime;\r\n            if(allowUnlockCount > 0) {\r\n                unlockToken = monthUnlockAmount * allowUnlockCount;\r\n            }\r\n        }\r\n        return unlockToken;\r\n    }\r\n\r\n    function monthUnlock() public unlockCheck {\r\n        require(balanceOf() > 0, \"There is no balance to unlock and withdraw\");\r\n        uint256 unlockTime = getUnlockedTimes();\r\n        uint256 unlockToken;\r\n        if(unlockTime >= maxUnlockTimes) {\r\n            unlockToken = balanceOf();\r\n            lastUnlockTime = maxUnlockTimes;\r\n        } else {\r\n            uint256 allowUnlockCount = unlockTime - lastUnlockTime;\r\n            require(allowUnlockCount > 0, \"No current extractable times\");\r\n            lastUnlockTime = unlockTime;\r\n            unlockToken = monthUnlockAmount * allowUnlockCount;\r\n        }\r\n        unlockedAmount = unlockedAmount + unlockToken;\r\n        _safeTransfer(unlockToken);\r\n        emit MonthUnlock(unlockAddress, unlockTime, unlockToken);\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"mananger\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"day\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"MonthUnlock\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"blockTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getUnlockedTimes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastUnlockTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"lockedDateList\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxUnlockTimes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"monthUnlock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"monthUnlockAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unlockAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unlockedAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"viewMonthUnlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "VRVesting", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://560e9e5e67e6b34363ff18c01d2223618d313ab77b58d87ab3035418c4bccd4f"}