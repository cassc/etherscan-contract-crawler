{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/diamonds/nayms/facets/TokenizedVaultIOFacet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport { Modifiers } from \\\"../Modifiers.sol\\\";\\nimport { LibTokenizedVaultIO } from \\\"../libs/LibTokenizedVaultIO.sol\\\";\\nimport { LibEntity } from \\\"../libs/LibEntity.sol\\\";\\nimport { LibAdmin } from \\\"../libs/LibAdmin.sol\\\";\\nimport { LibObject } from \\\"../libs/LibObject.sol\\\";\\nimport { ReentrancyGuard } from \\\"../../../utils/ReentrancyGuard.sol\\\";\\nimport { ITokenizedVaultIOFacet } from \\\"../interfaces/ITokenizedVaultIOFacet.sol\\\";\\nimport { LibConstants as LC } from \\\"../libs/LibConstants.sol\\\";\\nimport { LibACL } from \\\"../libs/LibACL.sol\\\";\\nimport { LibHelpers } from \\\"../libs/LibHelpers.sol\\\";\\nimport { ExternalWithdrawInvalidReceiver } from \\\"../interfaces/CustomErrors.sol\\\";\\n\\n/**\\n * @title Token Vault IO\\n * @notice External interface to the Token Vault\\n * @dev Used for external transfers. Adaptation of ERC-1155 that uses AppStorage and aligns with Nayms ACL implementation.\\n *      https://github.com/OpenZeppelin/openzeppelin-contracts/tree/master/contracts/token/ERC1155\\n */\\ncontract TokenizedVaultIOFacet is ITokenizedVaultIOFacet, Modifiers, ReentrancyGuard {\\n    /**\\n     * @notice Deposit funds into msg.sender's Nayms platform entity\\n     * @dev Deposit from msg.sender to their associated entity\\n     * @param _externalTokenAddress Token address\\n     * @param _amount deposit amount\\n     */\\n    function externalDeposit(address _externalTokenAddress, uint256 _amount)\\n        external\\n        notLocked(msg.sig)\\n        nonReentrant\\n        assertPrivilege(LibObject._getParentFromAddress(msg.sender), LC.GROUP_EXTERNAL_DEPOSIT)\\n    {\\n        // a user can only deposit an approved external ERC20 token\\n        require(LibAdmin._isSupportedExternalTokenAddress(_externalTokenAddress), \\\"extDeposit: invalid ERC20 token\\\");\\n        // a user can only deposit to their valid entity\\n        bytes32 entityId = LibObject._getParentFromAddress(msg.sender);\\n        require(LibEntity._isEntity(entityId), \\\"extDeposit: invalid receiver\\\");\\n\\n        LibTokenizedVaultIO._externalDeposit(entityId, _externalTokenAddress, _amount);\\n    }\\n\\n    /**\\n     * @notice Withdraw funds out of Nayms platform\\n     * @dev Withdraw from entity to an external account\\n     * @param _entityId Internal ID of the entity the user is withdrawing from\\n     * @param _receiver Internal ID of the account receiving the funds\\n     * @param _externalTokenAddress Token address\\n     * @param _amount amount to withdraw\\n     */\\n    function externalWithdrawFromEntity(\\n        bytes32 _entityId,\\n        address _receiver,\\n        address _externalTokenAddress,\\n        uint256 _amount\\n    ) external notLocked(msg.sig) nonReentrant assertPrivilege(LibObject._getParentFromAddress(msg.sender), LC.GROUP_EXTERNAL_WITHDRAW_FROM_ENTITY) {\\n        if (!LibACL._hasGroupPrivilege(LibHelpers._getIdForAddress(_receiver), _entityId, LibHelpers._stringToBytes32(LC.GROUP_EXTERNAL_WITHDRAW_FROM_ENTITY)))\\n            revert ExternalWithdrawInvalidReceiver(_receiver);\\n        LibTokenizedVaultIO._externalWithdraw(_entityId, _receiver, _externalTokenAddress, _amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/diamonds/nayms/Modifiers.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\n/// @notice modifiers\\n\\nimport { LibAdmin } from \\\"./libs/LibAdmin.sol\\\";\\nimport { LibConstants as LC } from \\\"./libs/LibConstants.sol\\\";\\nimport { LibHelpers } from \\\"./libs/LibHelpers.sol\\\";\\nimport { LibObject } from \\\"./libs/LibObject.sol\\\";\\nimport { LibACL } from \\\"./libs/LibACL.sol\\\";\\nimport { InvalidGroupPrivilege } from \\\"./interfaces/CustomErrors.sol\\\";\\n\\n/**\\n * @title Modifiers\\n * @notice Function modifiers to control access\\n * @dev Function modifiers to control access\\n */\\ncontract Modifiers {\\n    using LibHelpers for *;\\n    using LibACL for *;\\n\\n    modifier notLocked(bytes4 functionSelector) {\\n        require(!LibAdmin._isFunctionLocked(functionSelector), \\\"function is locked\\\");\\n        _;\\n    }\\n\\n    modifier assertPrivilege(bytes32 _context, string memory _group) {\\n        if (!msg.sender._getIdForAddress()._hasGroupPrivilege(_context, _group._stringToBytes32()))\\n            /// Note: If the role returned by `_getRoleInContext` is empty (represented by bytes32(0)), we explicitly return an empty string.\\n            /// This ensures the user doesn't receive a string that could potentially include unwanted data (like pointer and length) without any meaningful content.\\n            revert InvalidGroupPrivilege(\\n                msg.sender._getIdForAddress(),\\n                _context,\\n                (msg.sender._getIdForAddress()._getRoleInContext(_context) == bytes32(0))\\n                    ? \\\"\\\"\\n                    : string(msg.sender._getIdForAddress()._getRoleInContext(_context)._bytes32ToBytes()),\\n                _group\\n            );\\n        _;\\n    }\\n\\n    modifier assertIsInGroup(\\n        bytes32 _objectId,\\n        bytes32 _contextId,\\n        bytes32 _group\\n    ) {\\n        require(LibACL._isInGroup(_objectId, _contextId, _group), \\\"not in group\\\");\\n        _;\\n    }\\n\\n    modifier assertERC20Wrapper(bytes32 _tokenId) {\\n        (, , , , address erc20Wrapper) = LibObject._getObjectMeta(_tokenId);\\n        require(msg.sender == erc20Wrapper, \\\"only wrapper calls allowed\\\");\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/diamonds/nayms/libs/LibTokenizedVaultIO.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport { LibHelpers } from \\\"./LibHelpers.sol\\\";\\nimport { LibTokenizedVault } from \\\"./LibTokenizedVault.sol\\\";\\nimport { LibERC20 } from \\\"../../../erc20/LibERC20.sol\\\";\\nimport { ExternalDepositAmountCannotBeZero, ExternalWithdrawAmountCannotBeZero } from \\\"src/diamonds/nayms/interfaces/CustomErrors.sol\\\";\\n\\n/**\\n * @dev Adaptation of ERC-1155 that uses AppStorage and aligns with Nayms ACL implementation.\\n * https://github.com/OpenZeppelin/openzeppelin-contracts/tree/master/contracts/token/ERC1155\\n */\\nlibrary LibTokenizedVaultIO {\\n    function _externalDeposit(\\n        bytes32 _receiverId,\\n        address _externalTokenAddress,\\n        uint256 _amount\\n    ) internal {\\n        if (_amount == 0) {\\n            revert ExternalDepositAmountCannotBeZero();\\n        }\\n\\n        bytes32 internalTokenId = LibHelpers._getIdForAddress(_externalTokenAddress);\\n\\n        uint256 balanceBeforeTransfer = LibERC20.balanceOf(_externalTokenAddress, address(this));\\n        // Funds are transferred to entity\\n        LibERC20.transferFrom(_externalTokenAddress, msg.sender, address(this), _amount);\\n\\n        uint256 balanceAfterTransfer = LibERC20.balanceOf(_externalTokenAddress, address(this));\\n\\n        uint256 mintAmount = balanceAfterTransfer - balanceBeforeTransfer;\\n\\n        // note: Only mint what has been collected.\\n        LibTokenizedVault._internalMint(_receiverId, internalTokenId, mintAmount);\\n    }\\n\\n    function _externalWithdraw(\\n        bytes32 _entityId,\\n        address _receiver,\\n        address _externalTokenAddress,\\n        uint256 _amount\\n    ) internal {\\n        if (_amount == 0) {\\n            revert ExternalWithdrawAmountCannotBeZero();\\n        }\\n\\n        // withdraw from the user's entity\\n        bytes32 internalTokenId = LibHelpers._getIdForAddress(_externalTokenAddress);\\n\\n        // burn internal token\\n        LibTokenizedVault._internalBurn(_entityId, internalTokenId, _amount);\\n\\n        // transfer AFTER burn\\n        LibERC20.transfer(_externalTokenAddress, _receiver, _amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/diamonds/nayms/libs/LibEntity.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport { LibAppStorage, AppStorage } from \\\"../AppStorage.sol\\\";\\nimport { Entity, SimplePolicy, Stakeholders, FeeSchedule } from \\\"../AppStorage.sol\\\";\\nimport { LibConstants } from \\\"./LibConstants.sol\\\";\\nimport { LibAdmin } from \\\"./LibAdmin.sol\\\";\\nimport { LibHelpers } from \\\"./LibHelpers.sol\\\";\\nimport { LibObject } from \\\"./LibObject.sol\\\";\\nimport { LibACL } from \\\"./LibACL.sol\\\";\\nimport { LibTokenizedVault } from \\\"./LibTokenizedVault.sol\\\";\\nimport { LibMarket } from \\\"./LibMarket.sol\\\";\\nimport { LibSimplePolicy } from \\\"./LibSimplePolicy.sol\\\";\\nimport { LibFeeRouter } from \\\"./LibFeeRouter.sol\\\";\\n\\nimport { ECDSA } from \\\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\\\";\\nimport { FeeBasisPointsExceedHalfMax, EntityDoesNotExist, DuplicateSignerCreatingSimplePolicy, PolicyIdCannotBeZero, ObjectCannotBeTokenized, CreatingEntityThatAlreadyExists, SimplePolicyStakeholderSignatureInvalid, SimplePolicyClaimsPaidShouldStartAtZero, SimplePolicyPremiumsPaidShouldStartAtZero, CancelCannotBeTrueWhenCreatingSimplePolicy, UtilizedCapacityGreaterThanMaxCapacity } from \\\"src/diamonds/nayms/interfaces/CustomErrors.sol\\\";\\n\\nlibrary LibEntity {\\n    using ECDSA for bytes32;\\n    /**\\n     * @notice New entity has been created\\n     * @dev Emitted when entity is created\\n     * @param entityId Unique ID for the entity\\n     * @param entityAdmin Unique ID of the entity administrator\\n     */\\n    event EntityCreated(bytes32 indexed entityId, bytes32 entityAdmin);\\n    event EntityUpdated(bytes32 indexed entityId);\\n    event SimplePolicyCreated(bytes32 indexed id, bytes32 entityId);\\n    event TokenSaleStarted(bytes32 indexed entityId, uint256 offerId, string tokenSymbol, string tokenName);\\n    event CollateralRatioUpdated(bytes32 indexed entityId, uint256 collateralRatio, uint256 utilizedCapacity);\\n\\n    /**\\n     * @dev If an entity passes their checks to create a policy, ensure that the entity's capacity is appropriately decreased by the amount of capital that will be tied to the new policy being created.\\n     */\\n\\n    function _validateSimplePolicyCreation(\\n        bytes32 _entityId,\\n        SimplePolicy memory simplePolicy,\\n        Stakeholders calldata _stakeholders\\n    ) internal view {\\n        // The policy's limit cannot be 0. If a policy's limit is zero, this essentially means the policy doesn't require any capital, which doesn't make business sense.\\n        require(simplePolicy.limit > 0, \\\"limit not > 0\\\");\\n        require(LibAdmin._isSupportedExternalToken(simplePolicy.asset), \\\"external token is not supported\\\");\\n\\n        if (simplePolicy.claimsPaid != 0) {\\n            revert SimplePolicyClaimsPaidShouldStartAtZero();\\n        }\\n        if (simplePolicy.premiumsPaid != 0) {\\n            revert SimplePolicyPremiumsPaidShouldStartAtZero();\\n        }\\n        if (simplePolicy.cancelled) {\\n            revert CancelCannotBeTrueWhenCreatingSimplePolicy();\\n        }\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n        Entity memory entity = s.entities[_entityId];\\n\\n        require(simplePolicy.asset == entity.assetId, \\\"asset not matching with entity\\\");\\n\\n        // Calculate the entity's utilized capacity after it writes this policy.\\n        uint256 updatedUtilizedCapacity = entity.utilizedCapacity + ((simplePolicy.limit * entity.collateralRatio) / LibConstants.BP_FACTOR);\\n\\n        // The entity must have enough capacity available to write this policy.\\n        // An entity is not able to write an additional policy that will utilize its capacity beyond its assigned max capacity.\\n        require(entity.maxCapacity >= updatedUtilizedCapacity, \\\"not enough available capacity\\\");\\n\\n        // The entity's balance must be >= to the updated capacity requirement\\n        require(LibTokenizedVault._internalBalanceOf(_entityId, simplePolicy.asset) >= updatedUtilizedCapacity, \\\"not enough capital\\\");\\n\\n        require(simplePolicy.startDate >= block.timestamp, \\\"start date < block.timestamp\\\");\\n        require(simplePolicy.maturationDate > simplePolicy.startDate, \\\"start date > maturation date\\\");\\n\\n        require(simplePolicy.maturationDate - simplePolicy.startDate > 1 days, \\\"policy period must be more than a day\\\");\\n\\n        FeeSchedule memory feeSchedule = LibFeeRouter._getFeeSchedule(_entityId, LibConstants.FEE_TYPE_PREMIUM);\\n        uint256 feeReceiversCount = feeSchedule.receiver.length;\\n        // There must be at least one receiver from the fee schedule\\n        require(feeReceiversCount > 0, \\\"must have fee schedule receivers\\\"); // error there must be at least one receiver from fee schedule\\n\\n        // policy-level receivers are expected\\n        uint256 commissionReceiversArrayLength = simplePolicy.commissionReceivers.length;\\n        require(commissionReceiversArrayLength <= _stakeholders.roles.length, \\\"too many commission receivers\\\"); // error too many POLICY level commission receivers\\n\\n        uint256 commissionBasisPointsArrayLength = simplePolicy.commissionBasisPoints.length;\\n        require(commissionReceiversArrayLength == commissionBasisPointsArrayLength, \\\"number of commissions don't match\\\");\\n\\n        uint256 commissionReceiversTotalBP;\\n        for (uint256 i; i < commissionBasisPointsArrayLength; ++i) {\\n            commissionReceiversTotalBP += simplePolicy.commissionBasisPoints[i];\\n        }\\n\\n        if (commissionReceiversTotalBP > LibConstants.BP_FACTOR / 2) {\\n            revert FeeBasisPointsExceedHalfMax(commissionReceiversTotalBP, LibConstants.BP_FACTOR / 2);\\n        }\\n\\n        require(_stakeholders.roles.length == _stakeholders.entityIds.length, \\\"stakeholders roles mismatch\\\");\\n    }\\n\\n    function _createSimplePolicy(\\n        bytes32 _policyId,\\n        bytes32 _entityId,\\n        Stakeholders calldata _stakeholders,\\n        SimplePolicy calldata _simplePolicy,\\n        bytes32 _offchainDataHash\\n    ) internal {\\n        if (_policyId == 0) {\\n            revert PolicyIdCannotBeZero();\\n        }\\n\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n        if (!s.existingEntities[_entityId]) {\\n            revert EntityDoesNotExist(_entityId);\\n        }\\n        require(_stakeholders.entityIds.length == _stakeholders.signatures.length, \\\"incorrect number of signatures\\\");\\n\\n        s.simplePolicies[_policyId] = _simplePolicy;\\n\\n        _validateSimplePolicyCreation(_entityId, s.simplePolicies[_policyId], _stakeholders);\\n\\n        Entity storage entity = s.entities[_entityId];\\n        uint256 factoredLimit = (_simplePolicy.limit * entity.collateralRatio) / LibConstants.BP_FACTOR;\\n\\n        entity.utilizedCapacity += factoredLimit;\\n        s.lockedBalances[_entityId][entity.assetId] += factoredLimit;\\n\\n        // hash contents are implicitly checked by making sure that resolved signer is the stakeholder entity's admin\\n        bytes32 signingHash = LibSimplePolicy._getSigningHash(_simplePolicy.startDate, _simplePolicy.maturationDate, _simplePolicy.asset, _simplePolicy.limit, _offchainDataHash);\\n\\n        LibObject._createObject(_policyId, _entityId, signingHash);\\n        s.simplePolicies[_policyId].fundsLocked = true;\\n\\n        uint256 rolesCount = _stakeholders.roles.length;\\n        address signer;\\n        address previousSigner;\\n\\n        for (uint256 i = 0; i < rolesCount; i++) {\\n            previousSigner = signer;\\n\\n            signer = getSigner(signingHash, _stakeholders.signatures[i]);\\n\\n            if (LibObject._getParentFromAddress(signer) != _stakeholders.entityIds[i]) {\\n                revert SimplePolicyStakeholderSignatureInvalid(\\n                    signingHash,\\n                    _stakeholders.signatures[i],\\n                    LibHelpers._getIdForAddress(signer),\\n                    LibObject._getParentFromAddress(signer),\\n                    _stakeholders.entityIds[i]\\n                );\\n            }\\n\\n            // Ensure there are no duplicate signers.\\n            if (previousSigner >= signer) {\\n                revert DuplicateSignerCreatingSimplePolicy(previousSigner, signer);\\n            }\\n\\n            LibACL._assignRole(_stakeholders.entityIds[i], _policyId, _stakeholders.roles[i]);\\n        }\\n\\n        s.existingSimplePolicies[_policyId] = true;\\n        emit SimplePolicyCreated(_policyId, _entityId);\\n    }\\n\\n    function getSigner(bytes32 signingHash, bytes memory signature) private pure returns (address) {\\n        bytes32 r;\\n        bytes32 s;\\n        uint8 v;\\n\\n        // ecrecover takes the signature parameters, and the only way to get them\\n        if (signature.length == 65) {\\n            // currently is to use assembly.\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n\\n                switch v\\n                // if v == 0, then v = 27\\n                case 0 {\\n                    v := 27\\n                }\\n                // if v == 1, then v = 28\\n                case 1 {\\n                    v := 28\\n                }\\n            }\\n        }\\n\\n        (address signer, ) = ECDSA.tryRecover(ECDSA.toEthSignedMessageHash(signingHash), v, r, s);\\n\\n        return signer;\\n    }\\n\\n    /// @param _amount the amount of entity token that is minted and put on sale\\n    /// @param _totalPrice the buy amount\\n    function _startTokenSale(\\n        bytes32 _entityId,\\n        uint256 _amount,\\n        uint256 _totalPrice\\n    ) internal {\\n        require(_amount > 0, \\\"mint amount must be > 0\\\");\\n        require(_totalPrice > 0, \\\"total price must be > 0\\\");\\n\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n\\n        if (!s.existingEntities[_entityId]) {\\n            revert EntityDoesNotExist(_entityId);\\n        }\\n\\n        if (!LibObject._isObjectTokenizable(_entityId)) {\\n            revert ObjectCannotBeTokenized(_entityId);\\n        }\\n\\n        Entity memory entity = s.entities[_entityId];\\n\\n        // note: The participation tokens of the entity are minted to the entity. The participation tokens minted have the same ID as the entity.\\n        LibTokenizedVault._internalMint(_entityId, _entityId, _amount);\\n\\n        (uint256 offerId, , ) = LibMarket._executeLimitOffer(_entityId, _entityId, _amount, entity.assetId, _totalPrice, LibConstants.FEE_TYPE_INITIAL_SALE);\\n\\n        emit TokenSaleStarted(_entityId, offerId, s.objectTokenSymbol[_entityId], s.objectTokenName[_entityId]);\\n    }\\n\\n    function _createEntity(\\n        bytes32 _entityId,\\n        bytes32 _accountAdmin,\\n        Entity calldata _entity,\\n        bytes32 _dataHash\\n    ) internal {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n\\n        if (s.existingEntities[_entityId]) {\\n            revert CreatingEntityThatAlreadyExists(_entityId);\\n        }\\n        validateEntity(_entity);\\n\\n        LibObject._createObject(_entityId, _dataHash);\\n        LibObject._setParent(_accountAdmin, _entityId);\\n        s.existingEntities[_entityId] = true;\\n\\n        LibACL._assignRole(_accountAdmin, _entityId, LibHelpers._stringToBytes32(LibConstants.ROLE_ENTITY_ADMIN));\\n\\n        // An entity starts without any capacity being utilized\\n        require(_entity.utilizedCapacity == 0, \\\"utilized capacity starts at 0\\\");\\n\\n        s.entities[_entityId] = _entity;\\n\\n        emit EntityCreated(_entityId, _accountAdmin);\\n    }\\n\\n    /// @dev This currently updates a non cell type entity and a cell type entity, but\\n    /// we should consider splitting the functionality\\n    function _updateEntity(bytes32 _entityId, Entity calldata _updateEntityStruct) internal {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n\\n        // Cannot update a non-existing entity's metadata.\\n        if (!s.existingEntities[_entityId]) {\\n            revert EntityDoesNotExist(_entityId);\\n        }\\n\\n        validateEntity(_updateEntityStruct);\\n\\n        uint256 oldCollateralRatio = s.entities[_entityId].collateralRatio;\\n        uint256 oldUtilizedCapacity = s.entities[_entityId].utilizedCapacity;\\n        bytes32 entityAssetId = s.entities[_entityId].assetId;\\n\\n        if (entityAssetId != _updateEntityStruct.assetId) {\\n            revert(\\\"assetId change not allowed\\\");\\n        }\\n\\n        // can update max capacity and simplePolicyEnabled toggle first since it's not used in collateral ratio calculation below\\n        s.entities[_entityId].maxCapacity = _updateEntityStruct.maxCapacity;\\n        s.entities[_entityId].simplePolicyEnabled = _updateEntityStruct.simplePolicyEnabled;\\n\\n        // if it's a cell, and collateral ratio changed\\n        if (entityAssetId != 0 && _updateEntityStruct.collateralRatio != oldCollateralRatio) {\\n            uint256 newUtilizedCapacity = (oldUtilizedCapacity * _updateEntityStruct.collateralRatio) / oldCollateralRatio;\\n            uint256 newLockedBalance = s.lockedBalances[_entityId][entityAssetId] - oldUtilizedCapacity + newUtilizedCapacity;\\n\\n            require(LibTokenizedVault._internalBalanceOf(_entityId, entityAssetId) >= newLockedBalance, \\\"collateral ratio invalid, not enough balance\\\");\\n            require(newUtilizedCapacity <= _updateEntityStruct.maxCapacity, \\\"max capacity must be >= utilized capacity\\\");\\n\\n            s.entities[_entityId].collateralRatio = _updateEntityStruct.collateralRatio;\\n            s.entities[_entityId].utilizedCapacity = newUtilizedCapacity;\\n            s.lockedBalances[_entityId][entityAssetId] = newLockedBalance;\\n\\n            emit CollateralRatioUpdated(_entityId, _updateEntityStruct.collateralRatio, newUtilizedCapacity);\\n        }\\n\\n        emit EntityUpdated(_entityId);\\n    }\\n\\n    function validateEntity(Entity calldata _entity) internal view {\\n        // If a non cell type entity is converted into a cell type entity, then the following checks must be performed.\\n        if (_entity.assetId != 0) {\\n            // entity has an underlying asset, which means it's a cell\\n\\n            // External token must be whitelisted by the platform\\n            require(LibAdmin._isSupportedExternalToken(_entity.assetId), \\\"external token is not supported\\\");\\n\\n            // Collateral ratio must be in acceptable range of 1 to 10000 basis points (0.01% to 100% collateralized).\\n            // Cannot ever be completely uncollateralized (0 basis points), if entity is a cell.\\n            require(1 <= _entity.collateralRatio && _entity.collateralRatio <= LibConstants.BP_FACTOR, \\\"collateral ratio should be 1 to 10000\\\");\\n\\n            // Max capacity is the capital amount that an entity can write across all of their policies.\\n            // note: We do not directly use the value maxCapacity to determine if the entity can or cannot write a policy.\\n            //       First, we use the bool simplePolicyEnabled to toggle (enable / disable) whether an entity can or cannot write a policy.\\n            //       If an entity has this set to true, then we check if an entity has enough capacity to write a policy.\\n            require(!_entity.simplePolicyEnabled || (_entity.maxCapacity > 0), \\\"max capacity should be greater than 0 for policy creation\\\");\\n\\n            if (_entity.utilizedCapacity > _entity.maxCapacity) {\\n                revert UtilizedCapacityGreaterThanMaxCapacity(_entity.utilizedCapacity, _entity.maxCapacity);\\n            }\\n        } else {\\n            // non-cell entity\\n            require(_entity.collateralRatio == 0, \\\"only cell has collateral ratio\\\");\\n            require(!_entity.simplePolicyEnabled, \\\"only cell can issue policies\\\");\\n            require(_entity.maxCapacity == 0, \\\"only cells have max capacity\\\");\\n        }\\n    }\\n\\n    function _getEntityInfo(bytes32 _entityId) internal view returns (Entity memory entity) {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n        entity = s.entities[_entityId];\\n    }\\n\\n    function _isEntity(bytes32 _entityId) internal view returns (bool) {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n        return s.existingEntities[_entityId];\\n    }\\n}\\n\"\r\n    },\r\n    \"src/diamonds/nayms/libs/LibAdmin.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport { AppStorage, FunctionLockedStorage, LibAppStorage } from \\\"../AppStorage.sol\\\";\\nimport { LibConstants } from \\\"./LibConstants.sol\\\";\\nimport { LibHelpers } from \\\"./LibHelpers.sol\\\";\\nimport { LibObject } from \\\"./LibObject.sol\\\";\\nimport { LibERC20 } from \\\"src/erc20/LibERC20.sol\\\";\\n\\nimport { CannotAddNullDiscountToken, CannotAddNullSupportedExternalToken, CannotSupportExternalTokenWithMoreThan18Decimals } from \\\"src/diamonds/nayms/interfaces/CustomErrors.sol\\\";\\nimport { IEntityFacet } from \\\"src/diamonds/nayms/interfaces/IEntityFacet.sol\\\";\\nimport { ISimplePolicyFacet } from \\\"src/diamonds/nayms/interfaces/ISimplePolicyFacet.sol\\\";\\nimport { IMarketFacet } from \\\"src/diamonds/nayms/interfaces/IMarketFacet.sol\\\";\\nimport { ITokenizedVaultFacet } from \\\"src/diamonds/nayms/interfaces/ITokenizedVaultFacet.sol\\\";\\nimport { ITokenizedVaultIOFacet } from \\\"src/diamonds/nayms/interfaces/ITokenizedVaultIOFacet.sol\\\";\\n\\nlibrary LibAdmin {\\n    event MaxDividendDenominationsUpdated(uint8 oldMax, uint8 newMax);\\n    event SupportedTokenAdded(address indexed tokenAddress);\\n    event FunctionsLocked(bytes4[] functionSelectors);\\n    event FunctionsUnlocked(bytes4[] functionSelectors);\\n\\n    function _getSystemId() internal pure returns (bytes32) {\\n        return LibHelpers._stringToBytes32(LibConstants.SYSTEM_IDENTIFIER);\\n    }\\n\\n    function _getEmptyId() internal pure returns (bytes32) {\\n        return LibHelpers._stringToBytes32(LibConstants.EMPTY_IDENTIFIER);\\n    }\\n\\n    function _updateMaxDividendDenominations(uint8 _newMaxDividendDenominations) internal {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n        uint8 old = s.maxDividendDenominations;\\n        require(_newMaxDividendDenominations > old, \\\"_updateMaxDividendDenominations: cannot reduce\\\");\\n        s.maxDividendDenominations = _newMaxDividendDenominations;\\n\\n        emit MaxDividendDenominationsUpdated(old, _newMaxDividendDenominations);\\n    }\\n\\n    function _getMaxDividendDenominations() internal view returns (uint8) {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n        return s.maxDividendDenominations;\\n    }\\n\\n    function _isSupportedExternalTokenAddress(address _tokenId) internal view returns (bool) {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n        return s.externalTokenSupported[_tokenId];\\n    }\\n\\n    function _isSupportedExternalToken(bytes32 _tokenId) internal view returns (bool) {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n        return s.externalTokenSupported[LibHelpers._getAddressFromId(_tokenId)];\\n    }\\n\\n    function _addSupportedExternalToken(address _tokenAddress) internal {\\n        if (LibERC20.decimals(_tokenAddress) > 18) {\\n            revert CannotSupportExternalTokenWithMoreThan18Decimals();\\n        }\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n        require(!s.externalTokenSupported[_tokenAddress], \\\"external token already added\\\");\\n        require(s.objectTokenWrapperId[_tokenAddress] == bytes32(0), \\\"cannot add participation token wrapper as external\\\");\\n\\n        string memory symbol = LibERC20.symbol(_tokenAddress);\\n        require(LibObject._tokenSymbolNotUsed(symbol), \\\"token symbol already in use\\\");\\n\\n        s.externalTokenSupported[_tokenAddress] = true;\\n        bytes32 tokenId = LibHelpers._getIdForAddress(_tokenAddress);\\n        LibObject._createObject(tokenId);\\n        s.supportedExternalTokens.push(_tokenAddress);\\n        s.tokenSymbolObjectId[symbol] = tokenId;\\n\\n        emit SupportedTokenAdded(_tokenAddress);\\n    }\\n\\n    function _getSupportedExternalTokens() internal view returns (address[] memory) {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n\\n        // Supported tokens cannot be removed because they may exist in the system!\\n        return s.supportedExternalTokens;\\n    }\\n\\n    function _lockFunction(bytes4 functionSelector) internal {\\n        FunctionLockedStorage storage s = LibAppStorage.functionLockStorage();\\n        s.locked[functionSelector] = true;\\n\\n        bytes4[] memory functionSelectors = new bytes4[](1);\\n        functionSelectors[0] = functionSelector;\\n        emit FunctionsLocked(functionSelectors);\\n    }\\n\\n    function _unlockFunction(bytes4 functionSelector) internal {\\n        FunctionLockedStorage storage s = LibAppStorage.functionLockStorage();\\n        s.locked[functionSelector] = false;\\n\\n        bytes4[] memory functionSelectors = new bytes4[](1);\\n        functionSelectors[0] = functionSelector;\\n        emit FunctionsUnlocked(functionSelectors);\\n    }\\n\\n    function _isFunctionLocked(bytes4 functionSelector) internal view returns (bool) {\\n        FunctionLockedStorage storage s = LibAppStorage.functionLockStorage();\\n        return s.locked[functionSelector];\\n    }\\n\\n    function _lockAllFundTransferFunctions() internal {\\n        FunctionLockedStorage storage s = LibAppStorage.functionLockStorage();\\n        s.locked[IEntityFacet.startTokenSale.selector] = true;\\n        s.locked[ISimplePolicyFacet.paySimpleClaim.selector] = true;\\n        s.locked[ISimplePolicyFacet.paySimplePremium.selector] = true;\\n        s.locked[ISimplePolicyFacet.checkAndUpdateSimplePolicyState.selector] = true;\\n        s.locked[IMarketFacet.cancelOffer.selector] = true;\\n        s.locked[IMarketFacet.executeLimitOffer.selector] = true;\\n        s.locked[ITokenizedVaultFacet.internalTransferFromEntity.selector] = true;\\n        s.locked[ITokenizedVaultFacet.payDividendFromEntity.selector] = true;\\n        s.locked[ITokenizedVaultFacet.internalBurn.selector] = true;\\n        s.locked[ITokenizedVaultFacet.wrapperInternalTransferFrom.selector] = true;\\n        s.locked[ITokenizedVaultFacet.withdrawDividend.selector] = true;\\n        s.locked[ITokenizedVaultFacet.withdrawAllDividends.selector] = true;\\n        s.locked[ITokenizedVaultIOFacet.externalWithdrawFromEntity.selector] = true;\\n        s.locked[ITokenizedVaultIOFacet.externalDeposit.selector] = true;\\n\\n        bytes4[] memory lockedFunctions = new bytes4[](14);\\n        lockedFunctions[0] = IEntityFacet.startTokenSale.selector;\\n        lockedFunctions[1] = ISimplePolicyFacet.paySimpleClaim.selector;\\n        lockedFunctions[2] = ISimplePolicyFacet.paySimplePremium.selector;\\n        lockedFunctions[3] = ISimplePolicyFacet.checkAndUpdateSimplePolicyState.selector;\\n        lockedFunctions[4] = IMarketFacet.cancelOffer.selector;\\n        lockedFunctions[5] = IMarketFacet.executeLimitOffer.selector;\\n        lockedFunctions[6] = ITokenizedVaultFacet.internalTransferFromEntity.selector;\\n        lockedFunctions[7] = ITokenizedVaultFacet.payDividendFromEntity.selector;\\n        lockedFunctions[8] = ITokenizedVaultFacet.internalBurn.selector;\\n        lockedFunctions[9] = ITokenizedVaultFacet.wrapperInternalTransferFrom.selector;\\n        lockedFunctions[10] = ITokenizedVaultFacet.withdrawDividend.selector;\\n        lockedFunctions[11] = ITokenizedVaultFacet.withdrawAllDividends.selector;\\n        lockedFunctions[12] = ITokenizedVaultIOFacet.externalWithdrawFromEntity.selector;\\n        lockedFunctions[13] = ITokenizedVaultIOFacet.externalDeposit.selector;\\n\\n        emit FunctionsLocked(lockedFunctions);\\n    }\\n\\n    function _unlockAllFundTransferFunctions() internal {\\n        FunctionLockedStorage storage s = LibAppStorage.functionLockStorage();\\n        s.locked[IEntityFacet.startTokenSale.selector] = false;\\n        s.locked[ISimplePolicyFacet.paySimpleClaim.selector] = false;\\n        s.locked[ISimplePolicyFacet.paySimplePremium.selector] = false;\\n        s.locked[ISimplePolicyFacet.checkAndUpdateSimplePolicyState.selector] = false;\\n        s.locked[IMarketFacet.cancelOffer.selector] = false;\\n        s.locked[IMarketFacet.executeLimitOffer.selector] = false;\\n        s.locked[ITokenizedVaultFacet.internalTransferFromEntity.selector] = false;\\n        s.locked[ITokenizedVaultFacet.payDividendFromEntity.selector] = false;\\n        s.locked[ITokenizedVaultFacet.internalBurn.selector] = false;\\n        s.locked[ITokenizedVaultFacet.wrapperInternalTransferFrom.selector] = false;\\n        s.locked[ITokenizedVaultFacet.withdrawDividend.selector] = false;\\n        s.locked[ITokenizedVaultFacet.withdrawAllDividends.selector] = false;\\n        s.locked[ITokenizedVaultIOFacet.externalWithdrawFromEntity.selector] = false;\\n        s.locked[ITokenizedVaultIOFacet.externalDeposit.selector] = false;\\n\\n        bytes4[] memory lockedFunctions = new bytes4[](14);\\n        lockedFunctions[0] = IEntityFacet.startTokenSale.selector;\\n        lockedFunctions[1] = ISimplePolicyFacet.paySimpleClaim.selector;\\n        lockedFunctions[2] = ISimplePolicyFacet.paySimplePremium.selector;\\n        lockedFunctions[3] = ISimplePolicyFacet.checkAndUpdateSimplePolicyState.selector;\\n        lockedFunctions[4] = IMarketFacet.cancelOffer.selector;\\n        lockedFunctions[5] = IMarketFacet.executeLimitOffer.selector;\\n        lockedFunctions[6] = ITokenizedVaultFacet.internalTransferFromEntity.selector;\\n        lockedFunctions[7] = ITokenizedVaultFacet.payDividendFromEntity.selector;\\n        lockedFunctions[8] = ITokenizedVaultFacet.internalBurn.selector;\\n        lockedFunctions[9] = ITokenizedVaultFacet.wrapperInternalTransferFrom.selector;\\n        lockedFunctions[10] = ITokenizedVaultFacet.withdrawDividend.selector;\\n        lockedFunctions[11] = ITokenizedVaultFacet.withdrawAllDividends.selector;\\n        lockedFunctions[12] = ITokenizedVaultIOFacet.externalWithdrawFromEntity.selector;\\n        lockedFunctions[13] = ITokenizedVaultIOFacet.externalDeposit.selector;\\n\\n        emit FunctionsUnlocked(lockedFunctions);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/diamonds/nayms/libs/LibObject.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport { AppStorage, LibAppStorage } from \\\"../AppStorage.sol\\\";\\nimport { LibHelpers } from \\\"./LibHelpers.sol\\\";\\nimport { EntityDoesNotExist, MissingSymbolWhenEnablingTokenization } from \\\"src/diamonds/nayms/interfaces/CustomErrors.sol\\\";\\n\\nimport { ERC20Wrapper } from \\\"../../../erc20/ERC20Wrapper.sol\\\";\\n\\n/// @notice Contains internal methods for core Nayms system functionality\\nlibrary LibObject {\\n    event TokenizationEnabled(bytes32 objectId, string tokenSymbol, string tokenName);\\n    event TokenWrapped(bytes32 indexed entityId, address tokenWrapper);\\n    event TokenInfoUpdated(bytes32 indexed objectId, string symbol, string name);\\n    event ObjectCreated(bytes32 objectId, bytes32 parentId, bytes32 dataHash);\\n    event ObjectUpdated(bytes32 objectId, bytes32 parentId, bytes32 dataHash);\\n\\n    function _createObject(\\n        bytes32 _objectId,\\n        bytes32 _parentId,\\n        bytes32 _dataHash\\n    ) internal {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n        _createObject(_objectId);\\n        s.objectParent[_objectId] = _parentId;\\n        s.objectDataHashes[_objectId] = _dataHash;\\n\\n        emit ObjectCreated(_objectId, _parentId, _dataHash);\\n    }\\n\\n    function _createObject(bytes32 _objectId, bytes32 _dataHash) internal {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n        _createObject(_objectId);\\n        s.objectDataHashes[_objectId] = _dataHash;\\n\\n        emit ObjectCreated(_objectId, 0, _dataHash);\\n    }\\n\\n    function _createObject(bytes32 _objectId) internal {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n        require(!s.existingObjects[_objectId], \\\"objectId is already being used by another object\\\");\\n        s.existingObjects[_objectId] = true;\\n\\n        emit ObjectCreated(_objectId, 0, 0);\\n    }\\n\\n    function _setDataHash(bytes32 _objectId, bytes32 _dataHash) internal {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n\\n        require(s.existingObjects[_objectId], \\\"setDataHash: object doesn't exist\\\");\\n        s.objectDataHashes[_objectId] = _dataHash;\\n\\n        emit ObjectUpdated(_objectId, 0, _dataHash);\\n    }\\n\\n    function _getDataHash(bytes32 _objectId) internal view returns (bytes32 objectDataHash) {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n        return s.objectDataHashes[_objectId];\\n    }\\n\\n    function _getParent(bytes32 _objectId) internal view returns (bytes32) {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n        return s.objectParent[_objectId];\\n    }\\n\\n    function _getParentFromAddress(address addr) internal view returns (bytes32) {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n        bytes32 objectId = LibHelpers._getIdForAddress(addr);\\n        return s.objectParent[objectId];\\n    }\\n\\n    function _setParent(bytes32 _objectId, bytes32 _parentId) internal {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n        s.objectParent[_objectId] = _parentId;\\n\\n        emit ObjectUpdated(_objectId, _parentId, 0);\\n    }\\n\\n    function _isObjectTokenizable(bytes32 _objectId) internal view returns (bool) {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n        return (bytes(s.objectTokenSymbol[_objectId]).length != 0);\\n    }\\n\\n    function _tokenSymbolNotUsed(string memory _symbol) internal view returns (bool) {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n        return s.tokenSymbolObjectId[_symbol] == bytes32(0);\\n    }\\n\\n    function _enableObjectTokenization(\\n        bytes32 _objectId,\\n        string memory _symbol,\\n        string memory _name\\n    ) internal {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n        if (bytes(_symbol).length == 0) {\\n            revert MissingSymbolWhenEnablingTokenization(_objectId);\\n        }\\n        require(bytes(_symbol).length < 16, \\\"symbol must be less than 16 characters\\\");\\n\\n        // Ensure the entity exists before tokenizing the entity, otherwise revert.\\n        if (!s.existingEntities[_objectId]) {\\n            revert EntityDoesNotExist(_objectId);\\n        }\\n\\n        require(!_isObjectTokenizable(_objectId), \\\"object already tokenized\\\");\\n        require(_tokenSymbolNotUsed(_symbol), \\\"token symbol already in use\\\");\\n\\n        require(bytes(_name).length > 0, \\\"name must not be empty\\\");\\n\\n        s.objectTokenSymbol[_objectId] = _symbol;\\n        s.objectTokenName[_objectId] = _name;\\n        s.tokenSymbolObjectId[_symbol] = _objectId;\\n\\n        emit TokenizationEnabled(_objectId, _symbol, _name);\\n    }\\n\\n    function _updateTokenInfo(\\n        bytes32 _objectId,\\n        string memory _symbol,\\n        string memory _name\\n    ) internal {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n        require(_tokenSymbolNotUsed(_symbol), \\\"token symbol already in use\\\");\\n        require(_isObjectTokenizable(_objectId), \\\"object not tokenized\\\");\\n\\n        string memory oldSymbol = s.objectTokenSymbol[_objectId];\\n        delete s.tokenSymbolObjectId[oldSymbol];\\n\\n        s.objectTokenSymbol[_objectId] = _symbol;\\n        s.objectTokenName[_objectId] = _name;\\n        s.tokenSymbolObjectId[_symbol] = _objectId;\\n\\n        emit TokenInfoUpdated(_objectId, _symbol, _name);\\n    }\\n\\n    function _isObjectTokenWrapped(bytes32 _objectId) internal view returns (bool) {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n        return (s.objectTokenWrapper[_objectId] != address(0));\\n    }\\n\\n    function _wrapToken(bytes32 _entityId) internal {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n\\n        require(_isObjectTokenizable(_entityId), \\\"must be tokenizable\\\");\\n        require(!_isObjectTokenWrapped(_entityId), \\\"must not be wrapped already\\\");\\n\\n        ERC20Wrapper tokenWrapper = new ERC20Wrapper(_entityId);\\n        address wrapperAddress = address(tokenWrapper);\\n\\n        s.objectTokenWrapper[_entityId] = wrapperAddress;\\n        s.objectTokenWrapperId[wrapperAddress] = _entityId;\\n\\n        emit TokenWrapped(_entityId, wrapperAddress);\\n    }\\n\\n    function _isObject(bytes32 _id) internal view returns (bool) {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n        return s.existingObjects[_id];\\n    }\\n\\n    function _getObjectMeta(bytes32 _id)\\n        internal\\n        view\\n        returns (\\n            bytes32 parent,\\n            bytes32 dataHash,\\n            string memory tokenSymbol,\\n            string memory tokenName,\\n            address tokenWrapper\\n        )\\n    {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n        parent = s.objectParent[_id];\\n        dataHash = s.objectDataHashes[_id];\\n        tokenSymbol = s.objectTokenSymbol[_id];\\n        tokenName = s.objectTokenName[_id];\\n        tokenWrapper = s.objectTokenWrapper[_id];\\n    }\\n}\\n\"\r\n    },\r\n    \"src/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport { LibAppStorage } from \\\"src/diamonds/nayms/AppStorage.sol\\\";\\n\\n// From OpenZeppelin: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, reentrancyStatus will be _NOT_ENTERED\\n        require(LibAppStorage.diamondStorage().reentrancyStatus != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        LibAppStorage.diamondStorage().reentrancyStatus = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        LibAppStorage.diamondStorage().reentrancyStatus = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/diamonds/nayms/interfaces/ITokenizedVaultIOFacet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\n/**\\n * @title Token Vault IO\\n * @notice External interface to the Token Vault\\n * @dev Used for external transfers. Adaptation of ERC-1155 that uses AppStorage and aligns with Nayms ACL implementation.\\n *      https://github.com/OpenZeppelin/openzeppelin-contracts/tree/master/contracts/token/ERC1155\\n */\\ninterface ITokenizedVaultIOFacet {\\n    /**\\n     * @notice Deposit funds into msg.sender's Nayms platform entity\\n     * @dev Deposit from msg.sender to their associated entity\\n     * @param _externalTokenAddress Token address\\n     * @param _amount deposit amount\\n     */\\n    function externalDeposit(address _externalTokenAddress, uint256 _amount) external;\\n\\n    /**\\n     * @notice Withdraw funds out of Nayms platform\\n     * @dev Withdraw from entity to an external account\\n     * @param _entityId Internal ID of the entity the user is withdrawing from\\n     * @param _receiverId Internal ID of the account receiving the funds\\n     * @param _externalTokenAddress Token address\\n     * @param _amount amount to withdraw\\n     */\\n    function externalWithdrawFromEntity(\\n        bytes32 _entityId,\\n        address _receiverId,\\n        address _externalTokenAddress,\\n        uint256 _amount\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"src/diamonds/nayms/libs/LibConstants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\n/**\\n * @dev Settings keys.\\n */\\nlibrary LibConstants {\\n    /// Reserved IDs\\n    string internal constant EMPTY_IDENTIFIER = \\\"\\\";\\n    string internal constant SYSTEM_IDENTIFIER = \\\"System\\\";\\n    string internal constant NDF_IDENTIFIER = \\\"NDF\\\";\\n    string internal constant STM_IDENTIFIER = \\\"Staking Mechanism\\\";\\n    string internal constant SSF_IDENTIFIER = \\\"SSF\\\";\\n    string internal constant NAYM_TOKEN_IDENTIFIER = \\\"NAYM\\\"; //This is the ID in the system as well as the token ID\\n    string internal constant DIVIDEND_BANK_IDENTIFIER = \\\"Dividend Bank\\\"; //This will hold all the dividends\\n    string internal constant NAYMS_LTD_IDENTIFIER = \\\"Nayms Ltd\\\";\\n\\n    /// Roles\\n\\n    string internal constant ROLE_SYSTEM_ADMIN = \\\"System Admin\\\";\\n    string internal constant ROLE_SYSTEM_MANAGER = \\\"System Manager\\\";\\n    string internal constant ROLE_SYSTEM_UNDERWRITER = \\\"System Underwriter\\\";\\n\\n    string internal constant ROLE_ENTITY_ADMIN = \\\"Entity Admin\\\";\\n    string internal constant ROLE_ENTITY_MANAGER = \\\"Entity Manager\\\";\\n    string internal constant ROLE_ENTITY_BROKER = \\\"Broker\\\";\\n    string internal constant ROLE_ENTITY_INSURED = \\\"Insured\\\";\\n    string internal constant ROLE_ENTITY_CP = \\\"Capital Provider\\\";\\n    string internal constant ROLE_ENTITY_CONSULTANT = \\\"Consultant\\\"; // note NEW name for ROLE_SERVICE_PROVIDER\\n\\n    string internal constant ROLE_ENTITY_COMPTROLLER_COMBINED = \\\"Comptroller Combined\\\";\\n    string internal constant ROLE_ENTITY_COMPTROLLER_WITHDRAW = \\\"Comptroller Withdraw\\\";\\n    string internal constant ROLE_ENTITY_COMPTROLLER_CLAIM = \\\"Comptroller Claim\\\";\\n    string internal constant ROLE_ENTITY_COMPTROLLER_DIVIDEND = \\\"Comptroller Dividend\\\";\\n\\n    /// old roles\\n    string internal constant ROLE_SPONSOR = \\\"Sponsor\\\";\\n    string internal constant ROLE_CAPITAL_PROVIDER = \\\"Capital Provider\\\";\\n    string internal constant ROLE_INSURED_PARTY = \\\"Insured\\\";\\n    string internal constant ROLE_BROKER = \\\"Broker\\\";\\n    string internal constant ROLE_SERVICE_PROVIDER = \\\"Service Provider\\\";\\n\\n    string internal constant ROLE_UNDERWRITER = \\\"Underwriter\\\";\\n    string internal constant ROLE_CLAIMS_ADMIN = \\\"Claims Admin\\\";\\n    string internal constant ROLE_TRADER = \\\"Trader\\\";\\n    string internal constant ROLE_SEGREGATED_ACCOUNT = \\\"Segregated Account\\\";\\n\\n    /// Groups\\n\\n    string internal constant GROUP_SYSTEM_ADMINS = \\\"System Admins\\\";\\n    string internal constant GROUP_SYSTEM_MANAGERS = \\\"System Managers\\\";\\n    string internal constant GROUP_SYSTEM_UNDERWRITERS = \\\"System Underwriters\\\";\\n\\n    string internal constant GROUP_TENANTS = \\\"Tenants\\\";\\n    string internal constant GROUP_MANAGERS = \\\"Managers\\\"; // a group of roles that can be assigned by both system and entity managers\\n\\n    string internal constant GROUP_START_TOKEN_SALE = \\\"Start Token Sale\\\";\\n    string internal constant GROUP_EXECUTE_LIMIT_OFFER = \\\"Execute Limit Offer\\\";\\n    string internal constant GROUP_CANCEL_OFFER = \\\"Cancel Offer\\\";\\n    string internal constant GROUP_INTERNAL_TRANSFER_FROM_ENTITY = \\\"Internal Transfer From Entity\\\";\\n    string internal constant GROUP_EXTERNAL_WITHDRAW_FROM_ENTITY = \\\"External Withdraw From Entity\\\";\\n    string internal constant GROUP_EXTERNAL_DEPOSIT = \\\"External Deposit\\\";\\n    string internal constant GROUP_PAY_SIMPLE_CLAIM = \\\"Pay Simple Claim\\\";\\n    string internal constant GROUP_PAY_SIMPLE_PREMIUM = \\\"Pay Simple Premium\\\";\\n    string internal constant GROUP_PAY_DIVIDEND_FROM_ENTITY = \\\"Pay Dividend From Entity\\\";\\n\\n    string internal constant GROUP_POLICY_HANDLERS = \\\"Policy Handlers\\\"; // note replaced with GROUP_PAY_SIMPLE_PREMIUM\\n\\n    string internal constant GROUP_ENTITY_ADMINS = \\\"Entity Admins\\\";\\n    string internal constant GROUP_ENTITY_MANAGERS = \\\"Entity Managers\\\";\\n    string internal constant GROUP_APPROVED_USERS = \\\"Approved Users\\\";\\n    string internal constant GROUP_BROKERS = \\\"Brokers\\\";\\n    string internal constant GROUP_INSURED_PARTIES = \\\"Insured Parties\\\";\\n    string internal constant GROUP_UNDERWRITERS = \\\"Underwriters\\\";\\n    string internal constant GROUP_CAPITAL_PROVIDERS = \\\"Capital Providers\\\";\\n    string internal constant GROUP_CLAIMS_ADMINS = \\\"Claims Admins\\\";\\n    string internal constant GROUP_TRADERS = \\\"Traders\\\";\\n    string internal constant GROUP_SEGREGATED_ACCOUNTS = \\\"Segregated Accounts\\\";\\n    string internal constant GROUP_SERVICE_PROVIDERS = \\\"Service Providers\\\";\\n\\n    /*///////////////////////////////////////////////////////////////////////////\\n                        Market and Premium Fee Schedules\\n    ///////////////////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal constant FEE_TYPE_PREMIUM = 1;\\n    uint256 internal constant FEE_TYPE_TRADING = 2;\\n    uint256 internal constant FEE_TYPE_INITIAL_SALE = 3;\\n\\n    bytes32 internal constant DEFAULT_FEE_SCHEDULE = 0;\\n\\n    /*///////////////////////////////////////////////////////////////////////////\\n                        MARKET OFFER STATES\\n    ///////////////////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal constant OFFER_STATE_ACTIVE = 1;\\n    uint256 internal constant OFFER_STATE_CANCELLED = 2;\\n    uint256 internal constant OFFER_STATE_FULFILLED = 3;\\n\\n    uint256 internal constant DUST = 1;\\n    uint256 internal constant BP_FACTOR = 10000;\\n\\n    /*///////////////////////////////////////////////////////////////////////////\\n                        SIMPLE POLICY STATES\\n    ///////////////////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal constant SIMPLE_POLICY_STATE_CREATED = 0;\\n    uint256 internal constant SIMPLE_POLICY_STATE_APPROVED = 1;\\n    uint256 internal constant SIMPLE_POLICY_STATE_ACTIVE = 2;\\n    uint256 internal constant SIMPLE_POLICY_STATE_MATURED = 3;\\n    uint256 internal constant SIMPLE_POLICY_STATE_CANCELLED = 4;\\n    uint256 internal constant STAKING_WEEK = 7 days;\\n    uint256 internal constant STAKING_MINTIME = 60 days; // 60 days min lock\\n    uint256 internal constant STAKING_MAXTIME = 4 * 365 days; // 4 years max lock\\n    uint256 internal constant SCALE = 1e18; //10 ^ 18\\n\\n    /// _depositFor Types for events\\n    int128 internal constant STAKING_DEPOSIT_FOR_TYPE = 0;\\n    int128 internal constant STAKING_CREATE_LOCK_TYPE = 1;\\n    int128 internal constant STAKING_INCREASE_LOCK_AMOUNT = 2;\\n    int128 internal constant STAKING_INCREASE_UNLOCK_TIME = 3;\\n\\n    string internal constant VE_NAYM_NAME = \\\"veNAYM\\\";\\n    string internal constant VE_NAYM_SYMBOL = \\\"veNAYM\\\";\\n    uint8 internal constant VE_NAYM_DECIMALS = 18;\\n    uint8 internal constant INTERNAL_TOKEN_DECIMALS = 18;\\n    address internal constant DAI_CONSTANT = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\\n}\\n\"\r\n    },\r\n    \"src/diamonds/nayms/libs/LibACL.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport { AppStorage, LibAppStorage } from \\\"../AppStorage.sol\\\";\\nimport { LibDiamond } from \\\"src/diamonds/shared/libs/LibDiamond.sol\\\";\\nimport { LibHelpers } from \\\"./LibHelpers.sol\\\";\\nimport { LibAdmin } from \\\"./LibAdmin.sol\\\";\\nimport { LibObject } from \\\"./LibObject.sol\\\";\\nimport { LibConstants } from \\\"./LibConstants.sol\\\";\\nimport { OwnerCannotBeSystemAdmin, RoleIsMissing, AssignerGroupIsMissing } from \\\"src/diamonds/nayms/interfaces/CustomErrors.sol\\\";\\n\\nlibrary LibACL {\\n    /**\\n     * @dev Emitted when a role gets updated. Empty roleId is assigned upon role removal\\n     * @param objectId The user or object that was assigned the role.\\n     * @param contextId The context where the role was assigned to.\\n     * @param assignedRoleId The ID of the role which got (un)assigned. (empty ID when unassigned)\\n     * @param functionName The function performing the action\\n     */\\n    event RoleUpdated(bytes32 indexed objectId, bytes32 contextId, bytes32 assignedRoleId, string functionName);\\n    /**\\n     * @dev Emitted when a role group gets updated.\\n     * @param role The role name.\\n     * @param group the group name.\\n     * @param roleInGroup whether the role is now in the group or not.\\n     */\\n    event RoleGroupUpdated(string role, string group, bool roleInGroup);\\n    /**\\n     * @dev Emitted when a role assigners get updated.\\n     * @param role The role name.\\n     * @param group the name of the group that can now assign this role.\\n     */\\n    event RoleCanAssignUpdated(string role, string group);\\n\\n    function _assignRole(\\n        bytes32 _objectId,\\n        bytes32 _contextId,\\n        bytes32 _roleId\\n    ) internal {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n        require(_objectId != \\\"\\\", \\\"invalid object ID\\\");\\n        require(_contextId != \\\"\\\", \\\"invalid context ID\\\");\\n        require(_roleId != \\\"\\\", \\\"invalid role ID\\\");\\n\\n        bytes32 oldRole = s.roles[_objectId][_contextId];\\n        if (_contextId == LibAdmin._getSystemId() && oldRole == LibHelpers._stringToBytes32(LibConstants.ROLE_SYSTEM_ADMIN) && oldRole != _roleId) {\\n            require(s.sysAdmins > 1, \\\"must have at least one system admin\\\");\\n            unchecked {\\n                s.sysAdmins -= 1;\\n            }\\n        }\\n\\n        if (_contextId == LibAdmin._getSystemId() && _roleId == LibHelpers._stringToBytes32(LibConstants.ROLE_SYSTEM_ADMIN)) {\\n            if (LibDiamond.contractOwner() == LibHelpers._getAddressFromId(_objectId)) {\\n                revert OwnerCannotBeSystemAdmin();\\n            } else {\\n                unchecked {\\n                    s.sysAdmins += 1;\\n                }\\n            }\\n        }\\n\\n        s.roles[_objectId][_contextId] = _roleId;\\n\\n        emit RoleUpdated(_objectId, _contextId, _roleId, \\\"_assignRole\\\");\\n    }\\n\\n    function _unassignRole(bytes32 _objectId, bytes32 _contextId) internal {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n\\n        bytes32 roleId = s.roles[_objectId][_contextId];\\n        if (_contextId == LibAdmin._getSystemId() && roleId == LibHelpers._stringToBytes32(LibConstants.ROLE_SYSTEM_ADMIN)) {\\n            require(s.sysAdmins > 1, \\\"must have at least one system admin\\\");\\n            unchecked {\\n                s.sysAdmins -= 1;\\n            }\\n        }\\n\\n        emit RoleUpdated(_objectId, _contextId, s.roles[_objectId][_contextId], \\\"_unassignRole\\\");\\n        delete s.roles[_objectId][_contextId];\\n    }\\n\\n    /// @dev _isInGroup no longer falls back to check the _objectId's role in the system context\\n    function _isInGroup(\\n        bytes32 _objectId,\\n        bytes32 _contextId,\\n        bytes32 _groupId\\n    ) internal view returns (bool ret) {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n\\n        // Check for the role in the context\\n        bytes32 objectRoleInContext = s.roles[_objectId][_contextId];\\n\\n        if (objectRoleInContext != 0 && s.groups[objectRoleInContext][_groupId]) return true;\\n        return false;\\n    }\\n\\n    function _isParentInGroup(\\n        bytes32 _objectId,\\n        bytes32 _contextId,\\n        bytes32 _groupId\\n    ) internal view returns (bool) {\\n        bytes32 parentId = LibObject._getParent(_objectId);\\n        return _isInGroup(parentId, _contextId, _groupId);\\n    }\\n\\n    /**\\n     * @notice Checks if assigner has the authority to assign object to a role in given context\\n     * @dev Any object ID can be a context, system is a special context with highest priority\\n     * @param _assignerId ID of an account wanting to assign a role to an object\\n     * @param _objectId ID of an object that is being assigned a role\\n     * @param _contextId ID of the context in which a role is being assigned\\n     * @param _roleId ID of a role being assigned\\n     * @return  true if allowed false otherwise\\n     */\\n    function _canAssign(\\n        bytes32 _assignerId,\\n        bytes32 _objectId,\\n        bytes32 _contextId,\\n        bytes32 _roleId\\n    ) internal view returns (bool) {\\n        // we might impose additional restrictions on _objectId in the future\\n        require(_objectId != \\\"\\\", \\\"invalid object ID\\\");\\n\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n\\n        bytes32 assignerGroup = s.canAssign[_roleId];\\n\\n        // Check for assigner's group membership in given context\\n        if (_isInGroup(_assignerId, _contextId, assignerGroup)) return true;\\n        // Otherwise, check his membership in system context\\n        // if account itself does not have the membership in given context, then having membership\\n        // in the system context grants him the privilege needed\\n        if (_isInGroup(_assignerId, LibAdmin._getSystemId(), assignerGroup)) return true;\\n        return false;\\n    }\\n\\n    function _hasGroupPrivilege(\\n        bytes32 _userId,\\n        bytes32 _contextId,\\n        bytes32 _groupId\\n    ) internal view returns (bool) {\\n        if (_isParentInGroup(_userId, _contextId, _groupId)) return true;\\n        if (_isInGroup(_userId, _contextId, _groupId)) return true;\\n        if (_isInGroup(_userId, LibAdmin._getSystemId(), _groupId)) return true;\\n        return false;\\n    }\\n\\n    function _getRoleInContext(bytes32 _objectId, bytes32 _contextId) internal view returns (bytes32) {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n        return s.roles[_objectId][_contextId];\\n    }\\n\\n    function _isRoleInGroup(string memory role, string memory group) internal view returns (bool) {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n        return s.groups[LibHelpers._stringToBytes32(role)][LibHelpers._stringToBytes32(group)];\\n    }\\n\\n    function _canGroupAssignRole(string memory role, string memory group) internal view returns (bool) {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n        return s.canAssign[LibHelpers._stringToBytes32(role)] == LibHelpers._stringToBytes32(group);\\n    }\\n\\n    function _updateRoleAssigner(string memory _role, string memory _assignerGroup) internal {\\n        if (bytes32(bytes(_role)) == \\\"\\\") {\\n            revert RoleIsMissing();\\n        }\\n        if (bytes32(bytes(_assignerGroup)) == \\\"\\\") {\\n            revert AssignerGroupIsMissing();\\n        }\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n        s.canAssign[LibHelpers._stringToBytes32(_role)] = LibHelpers._stringToBytes32(_assignerGroup);\\n        emit RoleCanAssignUpdated(_role, _assignerGroup);\\n    }\\n\\n    function _updateRoleGroup(\\n        string memory _role,\\n        string memory _group,\\n        bool _roleInGroup\\n    ) internal {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n        if (bytes32(bytes(_role)) == \\\"\\\") {\\n            revert RoleIsMissing();\\n        }\\n        if (bytes32(bytes(_group)) == \\\"\\\") {\\n            revert AssignerGroupIsMissing();\\n        }\\n\\n        s.groups[LibHelpers._stringToBytes32(_role)][LibHelpers._stringToBytes32(_group)] = _roleInGroup;\\n        emit RoleGroupUpdated(_role, _group, _roleInGroup);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/diamonds/nayms/libs/LibHelpers.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\n/// @notice Pure functions\\nlibrary LibHelpers {\\n    function _getIdForObjectAtIndex(uint256 _index) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(_index));\\n    }\\n\\n    function _getIdForAddress(address _addr) internal pure returns (bytes32) {\\n        return bytes32(bytes20(_addr));\\n    }\\n\\n    function _getSenderId() internal view returns (bytes32) {\\n        return _getIdForAddress(msg.sender);\\n    }\\n\\n    function _checkBottom12BytesAreEmpty(bytes32 value) internal pure returns (bool) {\\n        bytes32 mask = 0x0000000000000000000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF;\\n        bytes32 bottom12Bytes = value & mask;\\n\\n        // returns true if bottom 12 bytes are empty\\n        return bottom12Bytes == 0;\\n    }\\n\\n    function _checkUpper12BytesAreEmpty(bytes32 value) internal pure returns (bool) {\\n        bytes32 mask = 0xFFFFFFFFFFFFFFFFFFFFFFFF0000000000000000000000000000000000000000;\\n\\n        bytes32 upper12Bytes = value & mask;\\n\\n        // returns true if upper 12 bytes are empty\\n        return upper12Bytes == 0;\\n    }\\n\\n    function _getAddressFromId(bytes32 _id) internal pure returns (address) {\\n        if (!_checkBottom12BytesAreEmpty(_id)) {\\n            revert(\\\"Invalid external token address\\\");\\n        }\\n        // returns the bottom 20 bytes of the id\\n        return address(bytes20(_id));\\n    }\\n\\n    function _isAddress(bytes32 _id) internal pure returns (bool) {\\n        return _id & 0x0000000000000000000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF == 0;\\n    }\\n\\n    // Conversion Utilities\\n\\n    /**\\n     * @dev Converts a string to a bytes32 representation.\\n     *      No length check for the input string is performed in this function, as it is only\\n     *      used with predefined string constants from LibConstants related to role names,\\n     *      role group names, and special platform identifiers.\\n     *      These critical string constants are verified to be 32 bytes or less off-chain\\n     *      before being used, and can only be set by platform admins.\\n     * @param strIn The input string to be converted\\n     * @return The bytes32 representation of the input string\\n     */\\n    function _stringToBytes32(string memory strIn) internal pure returns (bytes32) {\\n        return _bytesToBytes32(bytes(strIn));\\n    }\\n\\n    function _bytesToBytes32(bytes memory source) internal pure returns (bytes32 result) {\\n        if (source.length == 0) {\\n            return 0x0;\\n        }\\n        assembly {\\n            result := mload(add(source, 32))\\n        }\\n    }\\n\\n    function _bytes32ToBytes(bytes32 input) internal pure returns (bytes memory) {\\n        bytes memory b = new bytes(32);\\n        assembly {\\n            mstore(add(b, 32), input)\\n        }\\n        return b;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/diamonds/nayms/interfaces/CustomErrors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\n/// @dev The Nayms Diamond (proxy contract) owner (address) must be mutually exclusive with the system admin role.\\nerror OwnerCannotBeSystemAdmin();\\n\\n/// @dev Passing in a missing role when trying to assign a role.\\nerror RoleIsMissing();\\n\\n/// @dev Passing in a missing group when trying to assign a role to a group.\\nerror AssignerGroupIsMissing();\\n\\n/// @dev Role assigner (msg.sender) must be in the assigners group to unassign a role.\\n/// @param assigner Id of the role assigner, LibHelpers._getIdForAddress(msg sender)\\n/// @param assignee ObjectId that the role is being assigned to\\n/// @param context Context that the role is being assigned in\\n/// @param roleInContext Role that is being assigned\\nerror AssignerCannotUnassignRole(bytes32 assigner, bytes32 assignee, bytes32 context, string roleInContext);\\n\\n/// @notice Error message for when a sender is not authorized to perform an action with their assigned role in a given context of a group\\n/// @dev In the assertPrivilege modifier, this error message returns the context and the role in the context, not the user's role in the system context.\\n/// @param msgSenderId Id of the sender\\n/// @param context Context in which the sender is trying to perform an action\\n/// @param roleInContext Role of the sender in the context\\n/// @param group Group to check the sender's role in\\nerror InvalidGroupPrivilege(bytes32 msgSenderId, bytes32 context, string roleInContext, string group);\\n\\n/// @dev Passing in a missing address when trying to add a token address to the supported external token list.\\nerror CannotAddNullSupportedExternalToken();\\n\\n/// @dev Cannot add a ERC20 token to the supported external token list that has more than 18 decimal places.\\nerror CannotSupportExternalTokenWithMoreThan18Decimals();\\n\\n/// @dev Passing in a missing address when trying to assign a new token address as the new discount token.\\nerror CannotAddNullDiscountToken();\\n\\n/// @dev The entity does not exist when it should.\\nerror EntityDoesNotExist(bytes32 objectId);\\n\\n/// @dev Cannot create an entity that already exists.\\nerror CreatingEntityThatAlreadyExists(bytes32 entityId);\\n\\n/// @dev (non specific) the object is not enabled to be tokenized.\\nerror ObjectCannotBeTokenized(bytes32 objectId);\\n\\n/// @dev Passing in a missing symbol when trying to enable an object to be tokenized.\\nerror MissingSymbolWhenEnablingTokenization(bytes32 objectId);\\n\\n/// @dev Passing in 0 amount for deposits is not allowed.\\nerror ExternalDepositAmountCannotBeZero();\\n\\n/// @dev Passing in 0 amount for withdraws is not allowed.\\nerror ExternalWithdrawAmountCannotBeZero();\\n\\n/// @dev The receiver of the withdraw must haveGroupPriviledge with the roles entity admin, comptroller combined, or comptroller withdraw.\\nerror ExternalWithdrawInvalidReceiver(address receiver);\\n\\n/// @dev Cannot create a simple policy with policyId of 0\\nerror PolicyIdCannotBeZero();\\n\\n/// @dev Policy commissions among commission receivers cannot sum to be greater than 10_000 basis points.\\nerror PolicyCommissionsBasisPointsCannotBeGreaterThan10000(uint256 calculatedTotalBp);\\n\\n/// @dev The total basis points for a fee schedule, policy fee receivers at policy creation, or maker bp cannot be greater than half of LibConstants.BP_FACTOR.\\n///     This is to prevent the total basis points of a fee schedule with additional fee receivers (policy fee receivers for fee payments on premiums) from being greater than 100%.\\nerror FeeBasisPointsExceedHalfMax(uint256 actual, uint256 expected);\\n\\n/// @dev The total fees can never exceed the premium payment or the marketplace trade.\\nerror FeeBasisPointsExceedMax(uint256 actual, uint256 expected);\\n\\n/// @dev When validating an entity, the utilized capacity cannot be greater than the max capacity.\\nerror UtilizedCapacityGreaterThanMaxCapacity(uint256 utilizedCapacity, uint256 maxCapacity);\\n\\n/// @dev Policy stakeholder signature validation failed\\nerror SimplePolicyStakeholderSignatureInvalid(bytes32 signingHash, bytes signature, bytes32 signerId, bytes32 signersParent, bytes32 entityId);\\n\\n/// @dev When creating a simple policy, the total claims paid should start at 0.\\nerror SimplePolicyClaimsPaidShouldStartAtZero();\\n\\n/// @dev When creating a simple policy, the total premiums paid should start at 0.\\nerror SimplePolicyPremiumsPaidShouldStartAtZero();\\n\\n/// @dev The cancel bool should not be set to true when creating a new simple policy.\\nerror CancelCannotBeTrueWhenCreatingSimplePolicy();\\n\\n/// @dev (non specific) The policyId must exist.\\nerror PolicyDoesNotExist(bytes32 policyId);\\n\\n/// @dev There is a duplicate address in the list of signers (the previous signer in the list is not < the next signer in the list).\\nerror DuplicateSignerCreatingSimplePolicy(address previousSigner, address nextSigner);\\n\"\r\n    },\r\n    \"src/diamonds/nayms/libs/LibTokenizedVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport { AppStorage, LibAppStorage } from \\\"../AppStorage.sol\\\";\\nimport { LibAdmin } from \\\"./LibAdmin.sol\\\";\\nimport { LibConstants } from \\\"./LibConstants.sol\\\";\\nimport { LibHelpers } from \\\"./LibHelpers.sol\\\";\\nimport { LibObject } from \\\"./LibObject.sol\\\";\\n\\nlibrary LibTokenizedVault {\\n    /**\\n     * @dev Emitted when a token balance gets updated.\\n     * @param ownerId Id of owner\\n     * @param tokenId ID of token\\n     * @param newAmountOwned new amount owned\\n     * @param functionName Function name\\n     * @param msgSender msg.sender\\n     */\\n    event InternalTokenBalanceUpdate(bytes32 indexed ownerId, bytes32 tokenId, uint256 newAmountOwned, string functionName, address indexed msgSender);\\n\\n    /**\\n     * @dev Emitted when a token supply gets updated.\\n     * @param tokenId ID of token\\n     * @param newTokenSupply New token supply\\n     * @param functionName Function name\\n     * @param msgSender msg.sender\\n     */\\n    event InternalTokenSupplyUpdate(bytes32 indexed tokenId, uint256 newTokenSupply, string functionName, address indexed msgSender);\\n\\n    /**\\n     * @dev Emitted when a dividend gets payed out.\\n     * @param guid dividend distribution ID\\n     * @param from distribution initiator\\n     * @param to distribution receiver\\n     * @param amount distributed amount\\n     */\\n    event DividendDistribution(bytes32 indexed guid, bytes32 from, bytes32 to, bytes32 dividendTokenId, uint256 amount);\\n\\n    /**\\n     * @dev Emitted when a dividend gets payed out.\\n     * @param accountId ID of the account withdrawing the dividend\\n     * @param tokenId ID of the participation token that is paying out the dividends to holders\\n     * @param amountOwned owned amount of the participation tokens\\n     * @param dividendTokenId ID of the dividend denomination token\\n     * @param dividendAmountWithdrawn amount withdrawn\\n     */\\n    event DividendWithdrawn(bytes32 indexed accountId, bytes32 tokenId, uint256 amountOwned, bytes32 dividendTokenId, uint256 dividendAmountWithdrawn);\\n\\n    function _internalBalanceOf(bytes32 _ownerId, bytes32 _tokenId) internal view returns (uint256) {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n        return s.tokenBalances[_tokenId][_ownerId];\\n    }\\n\\n    function _internalTokenSupply(bytes32 _objectId) internal view returns (uint256) {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n        return s.tokenSupply[_objectId];\\n    }\\n\\n    function _internalTransfer(\\n        bytes32 _from,\\n        bytes32 _to,\\n        bytes32 _tokenId,\\n        uint256 _amount\\n    ) internal returns (bool success) {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n\\n        require(s.tokenBalances[_tokenId][_from] >= _amount, \\\"_internalTransfer: insufficient balance\\\");\\n        require(s.tokenBalances[_tokenId][_from] - s.lockedBalances[_from][_tokenId] >= _amount, \\\"_internalTransfer: insufficient balance available, funds locked\\\");\\n\\n        _withdrawAllDividends(_from, _tokenId);\\n\\n        s.tokenBalances[_tokenId][_from] -= _amount;\\n        s.tokenBalances[_tokenId][_to] += _amount;\\n\\n        _normalizeDividends(_from, _to, _tokenId, _amount, false);\\n\\n        emit InternalTokenBalanceUpdate(_from, _tokenId, s.tokenBalances[_tokenId][_from], \\\"_internalTransfer\\\", msg.sender);\\n        emit InternalTokenBalanceUpdate(_to, _tokenId, s.tokenBalances[_tokenId][_to], \\\"_internalTransfer\\\", msg.sender);\\n\\n        success = true;\\n    }\\n\\n    function _internalMint(\\n        bytes32 _to,\\n        bytes32 _tokenId,\\n        uint256 _amount\\n    ) internal {\\n        require(_to != \\\"\\\", \\\"_internalMint: mint to zero address\\\");\\n        require(_amount > 0, \\\"_internalMint: mint zero tokens\\\");\\n\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n\\n        _normalizeDividends(bytes32(0), _to, _tokenId, _amount, true);\\n\\n        s.tokenSupply[_tokenId] += _amount;\\n        s.tokenBalances[_tokenId][_to] += _amount;\\n\\n        emit InternalTokenSupplyUpdate(_tokenId, s.tokenSupply[_tokenId], \\\"_internalMint\\\", msg.sender);\\n        emit InternalTokenBalanceUpdate(_to, _tokenId, s.tokenBalances[_tokenId][_to], \\\"_internalMint\\\", msg.sender);\\n    }\\n\\n    function _normalizeDividends(\\n        bytes32 _from,\\n        bytes32 _to,\\n        bytes32 _tokenId,\\n        uint256 _amount,\\n        bool _updateTotals\\n    ) internal {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n        uint256 supply = _internalTokenSupply(_tokenId);\\n\\n        // This must be done BEFORE the supply increases!!!\\n        // This will calculate the hypothetical dividends that would correspond to this number of shares.\\n        // It must be added to the withdrawn dividend for every denomination for the user who receives the minted tokens\\n        bytes32[] memory dividendDenominations = s.dividendDenominations[_tokenId];\\n\\n        for (uint256 i = 0; i < dividendDenominations.length; ++i) {\\n            bytes32 dividendDenominationId = dividendDenominations[i];\\n            uint256 totalDividend = s.totalDividends[_tokenId][dividendDenominationId];\\n\\n            // Dividend deduction for newly issued shares\\n            uint256 dividendDeductionIssued = _getWithdrawableDividendAndDeductionMath(_amount, supply, totalDividend, 0);\\n\\n            // Scale total dividends and withdrawn dividend for new owner\\n            s.withdrawnDividendPerOwner[_tokenId][dividendDenominationId][_to] += dividendDeductionIssued;\\n\\n            // Scale total dividends for the previous owner, if applicable\\n            if (_from != bytes32(0)) {\\n                s.withdrawnDividendPerOwner[_tokenId][dividendDenominationId][_from] -= dividendDeductionIssued;\\n            }\\n\\n            if (_updateTotals) {\\n                s.totalDividends[_tokenId][dividendDenominationId] += (s.totalDividends[_tokenId][dividendDenominationId] * _amount) / supply;\\n            }\\n        }\\n    }\\n\\n    function _internalBurn(\\n        bytes32 _from,\\n        bytes32 _tokenId,\\n        uint256 _amount\\n    ) internal {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n\\n        require(s.tokenBalances[_tokenId][_from] >= _amount, \\\"_internalBurn: insufficient balance\\\");\\n        require(s.tokenBalances[_tokenId][_from] - s.lockedBalances[_from][_tokenId] >= _amount, \\\"_internalBurn: insufficient balance available, funds locked\\\");\\n\\n        _withdrawAllDividends(_from, _tokenId);\\n\\n        s.tokenSupply[_tokenId] -= _amount;\\n        s.tokenBalances[_tokenId][_from] -= _amount;\\n\\n        emit InternalTokenSupplyUpdate(_tokenId, s.tokenSupply[_tokenId], \\\"_internalBurn\\\", msg.sender);\\n        emit InternalTokenBalanceUpdate(_from, _tokenId, s.tokenBalances[_tokenId][_from], \\\"_internalBurn\\\", msg.sender);\\n    }\\n\\n    //   DIVIDEND PAYOUT LOGIC\\n    //\\n    // When a dividend is payed, you divide by the total supply and add it to the totalDividendPerToken\\n    // Dividends are held by the diamond contract at: LibHelpers._stringToBytes32(LibConstants.DIVIDEND_BANK_IDENTIFIER)\\n    // When dividends are paid, they are transferred OUT of that same diamond contract ID.\\n    //\\n    // To calculate withdrawableDividend = ownedTokens * totalDividendPerToken - totalWithdrawnDividendPerOwner\\n    //\\n    // When a dividend is collected you set the totalWithdrawnDividendPerOwner to the total amount the owner withdrew\\n    //\\n    // When you transfer, you pay out all dividends to previous owner first, then transfer ownership\\n    // !!!YOU ALSO TRANSFER totalWithdrawnDividendPerOwner for those shares!!!\\n    // totalWithdrawnDividendPerOwner(for new owner) += numberOfSharesTransferred * totalDividendPerToken\\n    // totalWithdrawnDividendPerOwner(for previous owner) -= numberOfSharesTransferred * totalDividendPerToken (can be optimized)\\n    //\\n    // When minting\\n    // Add the token balance to the new owner\\n    // totalWithdrawnDividendPerOwner(for new owner) += numberOfSharesMinted * totalDividendPerToken\\n    //\\n    // When doing the division these will be dust. Leave the dust in the diamond!!!\\n    function _withdrawDividend(\\n        bytes32 _ownerId,\\n        bytes32 _tokenId,\\n        bytes32 _dividendTokenId\\n    ) internal {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n        bytes32 dividendBankId = LibHelpers._stringToBytes32(LibConstants.DIVIDEND_BANK_IDENTIFIER);\\n\\n        uint256 amountOwned = s.tokenBalances[_tokenId][_ownerId];\\n        uint256 supply = _internalTokenSupply(_tokenId);\\n        uint256 totalDividend = s.totalDividends[_tokenId][_dividendTokenId];\\n        uint256 withdrawnSoFar = s.withdrawnDividendPerOwner[_tokenId][_dividendTokenId][_ownerId];\\n\\n        uint256 withdrawableDividend = _getWithdrawableDividendAndDeductionMath(amountOwned, supply, totalDividend, withdrawnSoFar);\\n        if (withdrawableDividend > 0) {\\n            // Bump the withdrawn dividends for the owner\\n            s.withdrawnDividendPerOwner[_tokenId][_dividendTokenId][_ownerId] += withdrawableDividend;\\n\\n            // Move the dividend\\n            s.tokenBalances[_dividendTokenId][dividendBankId] -= withdrawableDividend;\\n            s.tokenBalances[_dividendTokenId][_ownerId] += withdrawableDividend;\\n\\n            emit InternalTokenBalanceUpdate(dividendBankId, _dividendTokenId, s.tokenBalances[_dividendTokenId][dividendBankId], \\\"_withdrawDividend\\\", msg.sender);\\n            emit InternalTokenBalanceUpdate(_ownerId, _dividendTokenId, s.tokenBalances[_dividendTokenId][_ownerId], \\\"_withdrawDividend\\\", msg.sender);\\n            emit DividendWithdrawn(_ownerId, _tokenId, amountOwned, _dividendTokenId, withdrawableDividend);\\n        }\\n    }\\n\\n    function _getWithdrawableDividend(\\n        bytes32 _ownerId,\\n        bytes32 _tokenId,\\n        bytes32 _dividendTokenId\\n    ) internal view returns (uint256 withdrawableDividend_) {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n\\n        uint256 amount = s.tokenBalances[_tokenId][_ownerId];\\n        uint256 supply = _internalTokenSupply(_tokenId);\\n        uint256 totalDividend = s.totalDividends[_tokenId][_dividendTokenId];\\n        uint256 withdrawnSoFar = s.withdrawnDividendPerOwner[_tokenId][_dividendTokenId][_ownerId];\\n\\n        withdrawableDividend_ = _getWithdrawableDividendAndDeductionMath(amount, supply, totalDividend, withdrawnSoFar);\\n    }\\n\\n    function _withdrawAllDividends(bytes32 _ownerId, bytes32 _tokenId) internal {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n        bytes32[] memory dividendDenominations = s.dividendDenominations[_tokenId];\\n\\n        for (uint256 i = 0; i < dividendDenominations.length; ++i) {\\n            _withdrawDividend(_ownerId, _tokenId, dividendDenominations[i]);\\n        }\\n    }\\n\\n    function _payDividend(\\n        bytes32 _guid,\\n        bytes32 _from,\\n        bytes32 _to,\\n        bytes32 _dividendTokenId,\\n        uint256 _amount\\n    ) internal {\\n        require(_amount > 0, \\\"dividend amount must be > 0\\\");\\n        require(LibAdmin._isSupportedExternalToken(_dividendTokenId), \\\"must be supported dividend token\\\");\\n        require(!LibObject._isObject(_guid), \\\"nonunique dividend distribution identifier\\\");\\n\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n        bytes32 dividendBankId = LibHelpers._stringToBytes32(LibConstants.DIVIDEND_BANK_IDENTIFIER);\\n\\n        // If no tokens are issued, then deposit directly.\\n        // note: This functionality is for the business case where we want to distribute dividends directly to entities.\\n        // How this functionality is implemented may be changed in the future.\\n        if (_internalTokenSupply(_to) == 0) {\\n            _internalTransfer(_from, _to, _dividendTokenId, _amount);\\n        }\\n        // Otherwise pay as dividend\\n        else {\\n            // issue dividend. if you are owed dividends on the _dividendTokenId, they will be collected\\n            // Check for possible infinite loop, but probably not\\n            _internalTransfer(_from, dividendBankId, _dividendTokenId, _amount);\\n            s.totalDividends[_to][_dividendTokenId] += _amount;\\n\\n            // keep track of the dividend denominations\\n            // if dividend has not yet been issued in this token, add it to the list and update mappings\\n            if (s.dividendDenominationIndex[_to][_dividendTokenId] == 0 && s.dividendDenominationAtIndex[_to][0] != _dividendTokenId) {\\n                // We must limit the number of different tokens dividends are paid in\\n                if (s.dividendDenominations[_to].length >= LibAdmin._getMaxDividendDenominations()) {\\n                    revert(\\\"exceeds max div denominations\\\");\\n                }\\n\\n                s.dividendDenominationIndex[_to][_dividendTokenId] = uint8(s.dividendDenominations[_to].length);\\n                s.dividendDenominationAtIndex[_to][uint8(s.dividendDenominations[_to].length)] = _dividendTokenId;\\n                s.dividendDenominations[_to].push(_dividendTokenId);\\n            }\\n        }\\n\\n        // prevent guid reuse/collision\\n        LibObject._createObject(_guid);\\n\\n        // Events are emitted from the _internalTransfer()\\n        emit DividendDistribution(_guid, _from, _to, _dividendTokenId, _amount);\\n    }\\n\\n    function _getWithdrawableDividendAndDeductionMath(\\n        uint256 _amount,\\n        uint256 _supply,\\n        uint256 _totalDividend,\\n        uint256 _withdrawnSoFar\\n    ) internal pure returns (uint256 _withdrawableDividend) {\\n        // The holder dividend is: holderDividend = (totalDividend/tokenSupply) * _amount. The remainder (dust) is lost.\\n        uint256 totalDividendTimesAmount = _totalDividend * _amount;\\n        uint256 holderDividend = _supply == 0 ? 0 : (totalDividendTimesAmount / _supply);\\n\\n        _withdrawableDividend = (_withdrawnSoFar >= holderDividend) ? 0 : holderDividend - _withdrawnSoFar;\\n    }\\n\\n    function _getLockedBalance(bytes32 _accountId, bytes32 _tokenId) internal view returns (uint256 amount) {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n        return s.lockedBalances[_accountId][_tokenId];\\n    }\\n}\\n\"\r\n    },\r\n    \"src/erc20/LibERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge\\n*\\n/******************************************************************************/\\n\\nimport { IERC20 } from \\\"./IERC20.sol\\\";\\n\\nlibrary LibERC20 {\\n    function decimals(address _token) internal returns (uint8) {\\n        _assertNotEmptyContract(_token);\\n        (bool success, bytes memory result) = _token.call(abi.encodeWithSelector(IERC20.decimals.selector));\\n        if (success) {\\n            return abi.decode(result, (uint8));\\n        } else {\\n            revert(\\\"LibERC20: call to decimals() failed\\\");\\n        }\\n    }\\n\\n    function symbol(address _token) internal returns (string memory) {\\n        _assertNotEmptyContract(_token);\\n        (bool success, bytes memory result) = _token.call(abi.encodeWithSelector(IERC20.symbol.selector));\\n        if (success) {\\n            return abi.decode(result, (string));\\n        } else {\\n            revert(\\\"LibERC20: call to symbol() failed\\\");\\n        }\\n    }\\n\\n    function balanceOf(address _token, address _who) internal returns (uint256) {\\n        _assertNotEmptyContract(_token);\\n        (bool success, bytes memory result) = _token.call(abi.encodeWithSelector(IERC20.balanceOf.selector, _who));\\n        if (success) {\\n            return abi.decode(result, (uint256));\\n        } else {\\n            revert(\\\"LibERC20: call to balanceOf() failed\\\");\\n        }\\n    }\\n\\n    function transferFrom(\\n        address _token,\\n        address _from,\\n        address _to,\\n        uint256 _value\\n    ) internal {\\n        _assertNotEmptyContract(_token);\\n        (bool success, bytes memory result) = _token.call(abi.encodeWithSelector(IERC20.transferFrom.selector, _from, _to, _value));\\n        handleReturn(success, result);\\n    }\\n\\n    function transfer(\\n        address _token,\\n        address _to,\\n        uint256 _value\\n    ) internal {\\n        _assertNotEmptyContract(_token);\\n        (bool success, bytes memory result) = _token.call(abi.encodeWithSelector(IERC20.transfer.selector, _to, _value));\\n        handleReturn(success, result);\\n    }\\n\\n    function handleReturn(bool _success, bytes memory _result) internal pure {\\n        if (_success) {\\n            if (_result.length > 0) {\\n                require(abi.decode(_result, (bool)), \\\"LibERC20: transfer or transferFrom returned false\\\");\\n            }\\n        } else {\\n            if (_result.length > 0) {\\n                // bubble up any reason for revert\\n                // see https://github.com/OpenZeppelin/openzeppelin-contracts/blob/c239e1af8d1a1296577108dd6989a17b57434f8e/contracts/utils/Address.sol#L201\\n                assembly {\\n                    revert(add(32, _result), mload(_result))\\n                }\\n            } else {\\n                revert(\\\"LibERC20: transfer or transferFrom reverted\\\");\\n            }\\n        }\\n    }\\n\\n    function _assertNotEmptyContract(address _token) internal view {\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(_token)\\n        }\\n        require(size > 0, \\\"LibERC20: ERC20 token address has no code\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"src/diamonds/nayms/AppStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\n/// @notice storage for nayms v3 decentralized insurance platform\\n\\n// solhint-disable no-global-import\\nimport \\\"./interfaces/FreeStructs.sol\\\";\\n\\nstruct AppStorage {\\n    // Has this diamond been initialized?\\n    bool diamondInitialized;\\n    //// EIP712 domain separator ////\\n    uint256 initialChainId;\\n    bytes32 initialDomainSeparator;\\n    //// Reentrancy guard ////\\n    uint256 reentrancyStatus;\\n    //// NAYMS ERC20 TOKEN ////\\n    string name;\\n    mapping(address => mapping(address => uint256)) allowance;\\n    uint256 totalSupply;\\n    mapping(bytes32 => bool) internalToken;\\n    mapping(address => uint256) balances;\\n    //// Object ////\\n    mapping(bytes32 => bool) existingObjects; // objectId => is an object?\\n    mapping(bytes32 => bytes32) objectParent; // objectId => parentId\\n    mapping(bytes32 => bytes32) objectDataHashes;\\n    mapping(bytes32 => string) objectTokenSymbol;\\n    mapping(bytes32 => string) objectTokenName;\\n    mapping(bytes32 => address) objectTokenWrapper;\\n    mapping(bytes32 => bool) existingEntities; // entityId => is an entity?\\n    mapping(bytes32 => bool) existingSimplePolicies; // simplePolicyId => is a simple policy?\\n    //// ENTITY ////\\n    mapping(bytes32 => Entity) entities; // objectId => Entity struct\\n    //// SIMPLE POLICY ////\\n    mapping(bytes32 => SimplePolicy) simplePolicies; // objectId => SimplePolicy struct\\n    //// External Tokens ////\\n    mapping(address => bool) externalTokenSupported;\\n    address[] supportedExternalTokens;\\n    //// TokenizedObject ////\\n    mapping(bytes32 => mapping(bytes32 => uint256)) tokenBalances; // tokenId => (ownerId => balance)\\n    mapping(bytes32 => uint256) tokenSupply; // tokenId => Total Token Supply\\n    //// Dividends ////\\n    uint8 maxDividendDenominations;\\n    mapping(bytes32 => bytes32[]) dividendDenominations; // object => tokenId of the dividend it allows\\n    mapping(bytes32 => mapping(bytes32 => uint8)) dividendDenominationIndex; // entity ID => (token ID => index of dividend denomination)\\n    mapping(bytes32 => mapping(uint8 => bytes32)) dividendDenominationAtIndex; // entity ID => (index of dividend denomination => token id)\\n    mapping(bytes32 => mapping(bytes32 => uint256)) totalDividends; // token ID => (denomination ID => total dividend)\\n    mapping(bytes32 => mapping(bytes32 => mapping(bytes32 => uint256))) withdrawnDividendPerOwner; // entity => (tokenId => (owner => total withdrawn dividend)) NOT per share!!! this is TOTAL\\n    //// ACL Configuration////\\n    mapping(bytes32 => mapping(bytes32 => bool)) groups; //role => (group => isRoleInGroup)\\n    mapping(bytes32 => bytes32) canAssign; //role => Group that can assign/unassign that role\\n    //// User Data ////\\n    mapping(bytes32 => mapping(bytes32 => bytes32)) roles; // userId => (contextId => role)\\n    //// MARKET ////\\n    uint256 lastOfferId;\\n    mapping(uint256 => MarketInfo) offers; // offer Id => MarketInfo struct\\n    mapping(bytes32 => mapping(bytes32 => uint256)) bestOfferId; // sell token => buy token => best offer Id\\n    mapping(bytes32 => mapping(bytes32 => uint256)) span; // sell token => buy token => span\\n    address naymsToken; // represents the address key for this NAYMS token in AppStorage\\n    bytes32 naymsTokenId; // represents the bytes32 key for this NAYMS token in AppStorage\\n    /// Trading Commissions (all in basis points) ///\\n    uint16 tradingCommissionTotalBP; // note DEPRECATED // the total amount that is deducted for trading commissions (BP)\\n    // The total commission above is further divided as follows:\\n    uint16 tradingCommissionNaymsLtdBP; // note DEPRECATED\\n    uint16 tradingCommissionNDFBP; // note DEPRECATED\\n    uint16 tradingCommissionSTMBP; // note DEPRECATED\\n    uint16 tradingCommissionMakerBP;\\n    // Premium Commissions\\n    uint16 premiumCommissionNaymsLtdBP; // note DEPRECATED\\n    uint16 premiumCommissionNDFBP; // note DEPRECATED\\n    uint16 premiumCommissionSTMBP; // note DEPRECATED\\n    // A policy can pay out additional commissions on premiums to entities having a variety of roles on the policy\\n    mapping(bytes32 => mapping(bytes32 => uint256)) lockedBalances; // keep track of token balance that is locked, ownerId => tokenId => lockedAmount\\n    /// Simple two phase upgrade scheme\\n    mapping(bytes32 => uint256) upgradeScheduled; // id of the upgrade => the time that the upgrade is valid until.\\n    uint256 upgradeExpiration; // the period of time that an upgrade is valid until.\\n    uint256 sysAdmins; // counter for the number of sys admin accounts currently assigned\\n    mapping(address => bytes32) objectTokenWrapperId; // reverse mapping token wrapper address => object ID\\n    mapping(string => bytes32) tokenSymbolObjectId; // reverse mapping token symbol => object ID, to ensure symbol uniqueness\\n    mapping(bytes32 => mapping(uint256 => FeeSchedule)) feeSchedules; // map entity ID to a fee schedule type and then to array of FeeReceivers (feeScheduleType (1-premium, 2-trading, n-others))\\n}\\n\\nstruct FunctionLockedStorage {\\n    mapping(bytes4 => bool) locked; // function selector => is locked?\\n}\\n\\nlibrary LibAppStorage {\\n    bytes32 internal constant NAYMS_DIAMOND_STORAGE_POSITION = keccak256(\\\"diamond.standard.nayms.storage\\\");\\n    bytes32 internal constant FUNCTION_LOCK_STORAGE_POSITION = keccak256(\\\"diamond.function.lock.storage\\\");\\n\\n    function diamondStorage() internal pure returns (AppStorage storage ds) {\\n        bytes32 position = NAYMS_DIAMOND_STORAGE_POSITION;\\n        assembly {\\n            ds.slot := position\\n        }\\n    }\\n\\n    function functionLockStorage() internal pure returns (FunctionLockedStorage storage ds) {\\n        bytes32 position = FUNCTION_LOCK_STORAGE_POSITION;\\n        assembly {\\n            ds.slot := position\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/diamonds/nayms/libs/LibMarket.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport { AppStorage, LibAppStorage } from \\\"../AppStorage.sol\\\";\\nimport { MarketInfo, TokenAmount, CalculatedFees } from \\\"../AppStorage.sol\\\";\\nimport { LibHelpers } from \\\"./LibHelpers.sol\\\";\\nimport { LibTokenizedVault } from \\\"./LibTokenizedVault.sol\\\";\\nimport { LibConstants } from \\\"./LibConstants.sol\\\";\\nimport { LibFeeRouter } from \\\"./LibFeeRouter.sol\\\";\\n\\nlibrary LibMarket {\\n    struct MatchingOfferResult {\\n        uint256 remainingBuyAmount;\\n        uint256 remainingSellAmount;\\n        uint256 buyTokenCommissionsPaid;\\n        uint256 sellTokenCommissionsPaid;\\n    }\\n\\n    /// @notice order has been added\\n    event OrderAdded(\\n        uint256 indexed orderId,\\n        bytes32 indexed maker,\\n        bytes32 indexed sellToken,\\n        uint256 sellAmount,\\n        uint256 sellAmountInitial,\\n        bytes32 buyToken,\\n        uint256 buyAmount,\\n        uint256 buyAmountInitial,\\n        uint256 state\\n    );\\n\\n    /// @notice order has been executed\\n    event OrderExecuted(uint256 indexed orderId, bytes32 indexed taker, bytes32 indexed sellToken, uint256 sellAmount, bytes32 buyToken, uint256 buyAmount, uint256 state);\\n\\n    /// @notice order has been cancelled\\n    event OrderCancelled(uint256 indexed orderId, bytes32 indexed taker, bytes32 sellToken);\\n\\n    function _getBestOfferId(bytes32 _sellToken, bytes32 _buyToken) internal view returns (uint256) {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n        return s.bestOfferId[_sellToken][_buyToken];\\n    }\\n\\n    function _insertOfferIntoSortedList(uint256 _offerId) internal {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n\\n        // check that offer is NOT in the sorted list\\n        require(!_isOfferInSortedList(_offerId), \\\"offer already in sorted list\\\");\\n\\n        bytes32 sellToken = s.offers[_offerId].sellToken;\\n        bytes32 buyToken = s.offers[_offerId].buyToken;\\n\\n        uint256 prevId;\\n\\n        // find position of next highest offer\\n        uint256 top = s.bestOfferId[sellToken][buyToken];\\n        uint256 oldTop;\\n\\n        while (top != 0 && _isOfferPricedLtOrEq(_offerId, top)) {\\n            oldTop = top;\\n            top = s.offers[top].rankPrev;\\n        }\\n\\n        uint256 pos = oldTop;\\n\\n        // insert offer at position\\n        if (pos != 0) {\\n            prevId = s.offers[pos].rankPrev;\\n            s.offers[pos].rankPrev = _offerId;\\n            s.offers[_offerId].rankNext = pos;\\n        }\\n        // else this is the new best offer, so insert at top\\n        else {\\n            prevId = s.bestOfferId[sellToken][buyToken];\\n            s.bestOfferId[sellToken][buyToken] = _offerId;\\n        }\\n\\n        if (prevId != 0) {\\n            // requirement below is satisfied by statements above\\n            // require(!_isOfferPricedLtOrEq(_offerId, prevId));\\n            s.offers[prevId].rankNext = _offerId;\\n            s.offers[_offerId].rankPrev = prevId;\\n        }\\n\\n        s.span[sellToken][buyToken]++;\\n    }\\n\\n    function _removeOfferFromSortedList(uint256 _offerId) internal {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n\\n        // check that offer is in the sorted list\\n        require(_isOfferInSortedList(_offerId), \\\"offer not in sorted list\\\");\\n\\n        bytes32 sellToken = s.offers[_offerId].sellToken;\\n        bytes32 buyToken = s.offers[_offerId].buyToken;\\n\\n        require(s.span[sellToken][buyToken] > 0, \\\"token pair list does not exist\\\");\\n\\n        // if offer is not the highest offer\\n        if (_offerId != s.bestOfferId[sellToken][buyToken]) {\\n            uint256 nextId = s.offers[_offerId].rankNext;\\n            require(s.offers[nextId].rankPrev == _offerId, \\\"sort check failed\\\");\\n            s.offers[nextId].rankPrev = s.offers[_offerId].rankPrev;\\n        }\\n        // if offer is the highest offer\\n        else {\\n            s.bestOfferId[sellToken][buyToken] = s.offers[_offerId].rankPrev;\\n        }\\n\\n        // if offer is not the lowest offer\\n        if (s.offers[_offerId].rankPrev != 0) {\\n            uint256 prevId = s.offers[_offerId].rankPrev;\\n            require(s.offers[prevId].rankNext == _offerId, \\\"sort check failed\\\");\\n            s.offers[prevId].rankNext = s.offers[_offerId].rankNext;\\n        }\\n\\n        // nullify\\n        delete s.offers[_offerId].rankNext;\\n        delete s.offers[_offerId].rankPrev;\\n\\n        s.span[sellToken][buyToken]--;\\n    }\\n\\n    /**\\n     * @dev If the relative price of the sell token for offer1 (\\\"low offer\\\") is more expensive than the relative price of of the sell token for offer2 (\\\"high offer\\\"), then this returns true.\\n     *      If the sell token for offer1 is \\\"more expensive\\\", this means that one will need more sell token to buy the same amount of buy token when comparing relative prices of offer1 to offer2.\\n     */\\n    function _isOfferPricedLtOrEq(uint256 _lowOfferId, uint256 _highOfferId) internal view returns (bool) {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n\\n        uint256 lowSellAmount = s.offers[_lowOfferId].sellAmount;\\n        uint256 lowBuyAmount = s.offers[_lowOfferId].buyAmount;\\n\\n        uint256 highSellAmount = s.offers[_highOfferId].sellAmount;\\n        uint256 highBuyAmount = s.offers[_highOfferId].buyAmount;\\n\\n        return lowBuyAmount * highSellAmount >= highBuyAmount * lowSellAmount;\\n    }\\n\\n    function _isOfferInSortedList(uint256 _offerId) internal view returns (bool) {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n\\n        bytes32 sellToken = s.offers[_offerId].sellToken;\\n        bytes32 buyToken = s.offers[_offerId].buyToken;\\n\\n        return _offerId != 0 && (s.offers[_offerId].rankNext != 0 || s.offers[_offerId].rankPrev != 0 || s.bestOfferId[sellToken][buyToken] == _offerId);\\n    }\\n\\n    function _matchToExistingOffers(\\n        bytes32 _takerId,\\n        bytes32 _sellToken,\\n        uint256 _sellAmount,\\n        bytes32 _buyToken,\\n        uint256 _buyAmount,\\n        uint256 _feeScheduleType\\n    ) internal returns (MatchingOfferResult memory result) {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n\\n        result.remainingBuyAmount = _buyAmount;\\n        result.remainingSellAmount = _sellAmount;\\n\\n        // sell: p100 buy: $100 =>  YES! buy more\\n        // sell: $100 buy: p100 =>  NO! DON'T buy more\\n\\n        // If the buyToken is entity(p-token)   => limit both buy and sell amounts\\n        // If the buyToken is external          => limit only sell amount\\n\\n        bool buyExternalToken = LibHelpers._isAddress(_buyToken) && s.externalTokenSupported[LibHelpers._getAddressFromId(_buyToken)];\\n        while (result.remainingSellAmount != 0 && (buyExternalToken || result.remainingBuyAmount != 0)) {\\n            // there is at least one offer stored for token pair\\n            uint256 bestOfferId = s.bestOfferId[_buyToken][_sellToken];\\n            if (bestOfferId == 0) {\\n                break; // no market liquidity, bail out\\n            }\\n\\n            {\\n                uint256 makerBuyAmount = s.offers[bestOfferId].buyAmount;\\n                uint256 makerSellAmount = s.offers[bestOfferId].sellAmount;\\n\\n                // Check if best available price on the market is better or same,\\n                // as the one taker is willing to pay, within error margin of \u00b11.\\n                // This ugly hack is to work around rounding errors. Based on the idea that\\n                // the furthest the amounts can stray from their \\\"true\\\" values is 1.\\n                // Ergo the worst case has `sellAmount` and `makerSellAmount` at +1 away from\\n                // their \\\"correct\\\" values and `makerBuyAmount` and `buyAmount` at -1.\\n                // Since (c - 1) * (d - 1) > (a + 1) * (b + 1) is equivalent to\\n                // c * d > a * b + a + b + c + d\\n                // (For detailed breakdown see https://hiddentao.com/archives/2019/09/08/maker-otc-on-chain-orderbook-deep-dive)\\n                if (\\n                    makerBuyAmount * result.remainingBuyAmount >\\n                    result.remainingSellAmount * makerSellAmount + makerBuyAmount + result.remainingBuyAmount + result.remainingSellAmount + makerSellAmount\\n                ) {\\n                    break; // no matching price, bail out\\n                }\\n\\n                // ^ The `rounding` parameter is a compromise borne of a couple days of discussion.\\n            }\\n            // avoid stack-too-deep\\n            {\\n                // take the offer\\n                uint256 currentSellAmount;\\n                uint256 currentBuyAmount;\\n\\n                if (buyExternalToken) {\\n                    // if the maker's buy amount is less than the remaining sell amount, then we sell only the maker's buy amount. Else, we sell the remaining sell amount\\n                    currentSellAmount = s.offers[bestOfferId].buyAmount < result.remainingSellAmount ? s.offers[bestOfferId].buyAmount : result.remainingSellAmount;\\n                    currentBuyAmount = (currentSellAmount * s.offers[bestOfferId].sellAmount) / s.offers[bestOfferId].buyAmount; // (a / b) * c = c * a / b  -> multiply first, avoid underflow\\n\\n                    uint256 commissionsPaid = _takeOffer(_feeScheduleType, bestOfferId, _takerId, currentBuyAmount, currentSellAmount, buyExternalToken);\\n                    result.buyTokenCommissionsPaid += commissionsPaid;\\n                } else {\\n                    // Similar operations, but for the non-external token case (the fee is always paid in external tokens)\\n                    currentBuyAmount = s.offers[bestOfferId].sellAmount < result.remainingBuyAmount ? s.offers[bestOfferId].sellAmount : result.remainingBuyAmount;\\n                    currentSellAmount = (currentBuyAmount * s.offers[bestOfferId].buyAmount) / s.offers[bestOfferId].sellAmount; // (a / b) * c = c * a / b  -> multiply first, avoid underflow\\n                    uint256 commissionsPaid = _takeOffer(_feeScheduleType, bestOfferId, _takerId, currentBuyAmount, currentSellAmount, buyExternalToken);\\n                    result.sellTokenCommissionsPaid += commissionsPaid;\\n                }\\n                // Update how much is left to buy/sell\\n                result.remainingSellAmount -= currentSellAmount;\\n                result.remainingBuyAmount = currentBuyAmount > result.remainingBuyAmount ? 0 : result.remainingBuyAmount - currentBuyAmount;\\n            }\\n        }\\n    }\\n\\n    function _createOffer(\\n        bytes32 _creator,\\n        bytes32 _sellToken,\\n        uint256 _sellAmount,\\n        uint256 _sellAmountInitial,\\n        bytes32 _buyToken,\\n        uint256 _buyAmount,\\n        uint256 _buyAmountInitial,\\n        uint256 _feeScheduleType\\n    ) internal returns (uint256) {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n\\n        uint256 lastOfferId = ++s.lastOfferId;\\n\\n        MarketInfo memory marketInfo;\\n        marketInfo.creator = _creator;\\n        marketInfo.sellToken = _sellToken;\\n        marketInfo.sellAmount = _sellAmount;\\n        marketInfo.sellAmountInitial = _sellAmountInitial;\\n        marketInfo.buyToken = _buyToken;\\n        marketInfo.buyAmount = _buyAmount;\\n        marketInfo.buyAmountInitial = _buyAmountInitial;\\n        marketInfo.feeSchedule = _feeScheduleType;\\n\\n        if (_buyAmount < LibConstants.DUST || _sellAmount < LibConstants.DUST) {\\n            marketInfo.state = LibConstants.OFFER_STATE_FULFILLED;\\n        } else {\\n            marketInfo.state = LibConstants.OFFER_STATE_ACTIVE;\\n\\n            // lock tokens!\\n            s.lockedBalances[_creator][_sellToken] += _sellAmount;\\n        }\\n\\n        s.offers[lastOfferId] = marketInfo;\\n        emit OrderAdded(lastOfferId, marketInfo.creator, _sellToken, _sellAmount, _sellAmountInitial, _buyToken, _buyAmount, _buyAmountInitial, marketInfo.state);\\n\\n        return lastOfferId;\\n    }\\n\\n    function _takeOffer(\\n        uint256 _feeScheduleType,\\n        uint256 _offerId,\\n        bytes32 _takerId,\\n        uint256 _buyAmount,\\n        uint256 _sellAmount,\\n        bool _takeExternalToken\\n    ) internal returns (uint256 commissionsPaid_) {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n\\n        // check bounds and update balances\\n        _checkBoundsAndUpdateBalances(_offerId, _buyAmount, _sellAmount);\\n\\n        /// Check to see if the fee schedule from the new order (`startTokenSale()`) is the initial offer fee schedule or not\\n        /// Use the initial offer fee schedule if it is, otherwise use the fee schedule from the original order placed\\n\\n        {\\n            uint256 feeScheduleType;\\n            if (s.offers[_offerId].feeSchedule == LibConstants.FEE_TYPE_INITIAL_SALE || _feeScheduleType == LibConstants.FEE_TYPE_INITIAL_SALE) {\\n                feeScheduleType = LibConstants.FEE_TYPE_INITIAL_SALE;\\n            } else {\\n                feeScheduleType = LibConstants.FEE_TYPE_TRADING;\\n            }\\n\\n            bytes32 buyer;\\n            if (feeScheduleType == LibConstants.FEE_TYPE_INITIAL_SALE && s.offers[_offerId].creator != s.offers[_offerId].sellToken) {\\n                buyer = s.offers[_offerId].creator;\\n            } else {\\n                buyer = _takerId;\\n            }\\n\\n            // _takeExternalToken == true means the creator is selling an external token\\n            if (_takeExternalToken) {\\n                // sellToken is external supported token, commissions are paid on top of _buyAmount in sellToken\\n                commissionsPaid_ = LibFeeRouter._payTradingFees(feeScheduleType, buyer, s.offers[_offerId].creator, _takerId, s.offers[_offerId].sellToken, _buyAmount);\\n            } else {\\n                // sellToken is internal/participation token, commissions are paid from _sellAmount in buyToken\\n                commissionsPaid_ = LibFeeRouter._payTradingFees(feeScheduleType, buyer, s.offers[_offerId].creator, _takerId, s.offers[_offerId].buyToken, _sellAmount);\\n            }\\n            s.lockedBalances[s.offers[_offerId].creator][s.offers[_offerId].sellToken] -= _buyAmount;\\n\\n            LibTokenizedVault._internalTransfer(s.offers[_offerId].creator, _takerId, s.offers[_offerId].sellToken, _buyAmount);\\n            LibTokenizedVault._internalTransfer(_takerId, s.offers[_offerId].creator, s.offers[_offerId].buyToken, _sellAmount);\\n        }\\n\\n        // close offer if it has become dust\\n        if (s.offers[_offerId].sellAmount < LibConstants.DUST) {\\n            s.offers[_offerId].state = LibConstants.OFFER_STATE_FULFILLED;\\n            _cancelOffer(_offerId);\\n        }\\n\\n        emit OrderExecuted(\\n            _offerId,\\n            _takerId,\\n            s.offers[_offerId].sellToken,\\n            s.offers[_offerId].sellAmount,\\n            s.offers[_offerId].buyToken,\\n            s.offers[_offerId].buyAmount,\\n            s.offers[_offerId].state\\n        );\\n    }\\n\\n    function _checkBoundsAndUpdateBalances(\\n        uint256 _offerId,\\n        uint256 _sellAmount,\\n        uint256 _buyAmount\\n    ) internal {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n\\n        (TokenAmount memory offerSell, TokenAmount memory offerBuy) = _getOfferTokenAmounts(_offerId);\\n\\n        _assertAmounts(_sellAmount, _buyAmount);\\n\\n        require(_buyAmount <= offerBuy.amount, \\\"requested buy amount too large\\\");\\n        require(_sellAmount <= offerSell.amount, \\\"calculated sell amount too large\\\");\\n\\n        // update balances\\n        s.offers[_offerId].sellAmount = offerSell.amount - _sellAmount;\\n        s.offers[_offerId].buyAmount = offerBuy.amount - _buyAmount;\\n    }\\n\\n    function _cancelOffer(uint256 _offerId) internal {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n\\n        if (_isOfferInSortedList(_offerId)) {\\n            _removeOfferFromSortedList(_offerId);\\n        }\\n\\n        MarketInfo memory marketInfo = s.offers[_offerId];\\n\\n        // unlock the remaining sell amount back to creator\\n        if (marketInfo.sellAmount > 0) {\\n            // note nothing is transferred since tokens for sale are UN-escrowed. Just unlock!\\n            s.lockedBalances[s.offers[_offerId].creator][s.offers[_offerId].sellToken] -= marketInfo.sellAmount;\\n        }\\n\\n        // don't emit event stating market order is cancelled if the market order was executed and fulfilled\\n        if (marketInfo.state != LibConstants.OFFER_STATE_FULFILLED) {\\n            s.offers[_offerId].state = LibConstants.OFFER_STATE_CANCELLED;\\n            emit OrderCancelled(_offerId, marketInfo.creator, marketInfo.sellToken);\\n        }\\n\\n        /// @dev Burn the par tokens if this was an initial token sale (selling par tokens through startTokenSale())\\n        if (marketInfo.feeSchedule == LibConstants.FEE_TYPE_INITIAL_SALE) {\\n            LibTokenizedVault._internalBurn(s.offers[_offerId].sellToken, s.offers[_offerId].sellToken, marketInfo.sellAmount);\\n        }\\n    }\\n\\n    function _assertAmounts(uint256 _sellAmount, uint256 _buyAmount) internal pure {\\n        require(_sellAmount <= type(uint128).max, \\\"sell amount exceeds uint128 limit\\\");\\n        require(_buyAmount <= type(uint128).max, \\\"buy amount exceeds uint128 limit\\\");\\n        require(_sellAmount > 0, \\\"sell amount must be >0\\\");\\n        require(_buyAmount > 0, \\\"buy amount must be >0\\\");\\n    }\\n\\n    function _assertValidOffer(\\n        bytes32 _entityId,\\n        bytes32 _sellToken,\\n        uint256 _sellAmount,\\n        bytes32 _buyToken,\\n        uint256 _buyAmount,\\n        uint256 _feeScheduleType\\n    ) internal view {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n\\n        // A valid offer can only be made by an existing entity.\\n        require(_entityId != 0 && s.existingEntities[_entityId], \\\"offer must be made by an existing entity\\\");\\n\\n        // note: Clarification on terminology:\\n        // A participation token is also called an entity token. A par token is an entity tokenized.\\n        // An external token is an ERC20 token. An external token can be approved to be used on the Nayms platform.\\n        // There can only be one participation token and one external token involved in a trade. In other words, a par token cannot be traded for another par token.\\n        // The platform also does not allow entities to trade external tokens (cannot trade an external token for another external token).\\n\\n        bool isSellTokenAParticipationToken = s.existingEntities[_sellToken];\\n        bool isSellTokenASupportedExternalToken = LibHelpers._isAddress(_sellToken) && s.externalTokenSupported[LibHelpers._getAddressFromId(_sellToken)];\\n        bool isBuyTokenAParticipationToken = s.existingEntities[_buyToken];\\n        bool isBuyTokenASupportedExternalToken = LibHelpers._isAddress(_buyToken) && s.externalTokenSupported[LibHelpers._getAddressFromId(_buyToken)];\\n\\n        _assertAmounts(_sellAmount, _buyAmount);\\n\\n        require(isSellTokenAParticipationToken || isSellTokenASupportedExternalToken, \\\"sell token must be valid\\\");\\n        require(isBuyTokenAParticipationToken || isBuyTokenASupportedExternalToken, \\\"buy token must be valid\\\");\\n        require(_sellToken != _buyToken, \\\"cannot sell and buy same token\\\");\\n        require(\\n            (isSellTokenAParticipationToken && isBuyTokenASupportedExternalToken) || (isSellTokenASupportedExternalToken && isBuyTokenAParticipationToken),\\n            \\\"must be one participation token and one external token\\\"\\n        );\\n\\n        // note: add restriction to not be able to sell tokens that are already for sale\\n        // maker must own sell amount and it must not be locked\\n        require(s.tokenBalances[_sellToken][_entityId] >= _sellAmount, \\\"insufficient balance\\\");\\n        require(s.tokenBalances[_sellToken][_entityId] - s.lockedBalances[_entityId][_sellToken] >= _sellAmount, \\\"insufficient balance available, funds locked\\\");\\n\\n        // must have a valid fee schedule\\n        require(_feeScheduleType == LibConstants.FEE_TYPE_TRADING || _feeScheduleType == LibConstants.FEE_TYPE_INITIAL_SALE, \\\"fee type invalid\\\");\\n    }\\n\\n    function _getOfferTokenAmounts(uint256 _offerId) internal view returns (TokenAmount memory sell_, TokenAmount memory buy_) {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n\\n        sell_.token = s.offers[_offerId].sellToken;\\n        sell_.amount = s.offers[_offerId].sellAmount;\\n        buy_.token = s.offers[_offerId].buyToken;\\n        buy_.amount = s.offers[_offerId].buyAmount;\\n    }\\n\\n    function _executeLimitOffer(\\n        bytes32 _creator,\\n        bytes32 _sellToken,\\n        uint256 _sellAmount,\\n        bytes32 _buyToken,\\n        uint256 _buyAmount,\\n        uint256 _feeScheduleType\\n    )\\n        internal\\n        returns (\\n            uint256 offerId_,\\n            uint256 buyTokenCommissionsPaid_,\\n            uint256 sellTokenCommissionsPaid_\\n        )\\n    {\\n        _assertValidOffer(_creator, _sellToken, _sellAmount, _buyToken, _buyAmount, _feeScheduleType);\\n\\n        MatchingOfferResult memory result = _matchToExistingOffers(_creator, _sellToken, _sellAmount, _buyToken, _buyAmount, _feeScheduleType);\\n        buyTokenCommissionsPaid_ = result.buyTokenCommissionsPaid;\\n        sellTokenCommissionsPaid_ = result.sellTokenCommissionsPaid;\\n\\n        offerId_ = _createOffer(_creator, _sellToken, result.remainingSellAmount, _sellAmount, _buyToken, result.remainingBuyAmount, _buyAmount, _feeScheduleType);\\n\\n        // if still some left\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n        if (s.offers[offerId_].state == LibConstants.OFFER_STATE_ACTIVE) {\\n            // ensure it's in the right position in the list\\n            _insertOfferIntoSortedList(offerId_);\\n        }\\n    }\\n\\n    function _getOffer(uint256 _offerId) internal view returns (MarketInfo memory _offerState) {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n        return s.offers[_offerId];\\n    }\\n\\n    function _getLastOfferId() internal view returns (uint256) {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n        return s.lastOfferId;\\n    }\\n\\n    function _isActiveOffer(uint256 _offerId) internal view returns (bool) {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n        return s.offers[_offerId].state == LibConstants.OFFER_STATE_ACTIVE;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/diamonds/nayms/libs/LibSimplePolicy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport { AppStorage, LibAppStorage } from \\\"../AppStorage.sol\\\";\\nimport { Entity, SimplePolicy } from \\\"../AppStorage.sol\\\";\\nimport { LibACL } from \\\"./LibACL.sol\\\";\\nimport { LibConstants } from \\\"./LibConstants.sol\\\";\\nimport { LibObject } from \\\"./LibObject.sol\\\";\\nimport { LibTokenizedVault } from \\\"./LibTokenizedVault.sol\\\";\\nimport { LibFeeRouter } from \\\"./LibFeeRouter.sol\\\";\\nimport { LibHelpers } from \\\"./LibHelpers.sol\\\";\\nimport { LibEIP712 } from \\\"src/diamonds/nayms/libs/LibEIP712.sol\\\";\\n\\nimport { EntityDoesNotExist, PolicyDoesNotExist } from \\\"src/diamonds/nayms/interfaces/CustomErrors.sol\\\";\\n\\nlibrary LibSimplePolicy {\\n    event SimplePolicyMatured(bytes32 indexed id);\\n    event SimplePolicyCancelled(bytes32 indexed id);\\n    event SimplePolicyPremiumPaid(bytes32 indexed id, uint256 amount);\\n    event SimplePolicyClaimPaid(bytes32 indexed _claimId, bytes32 indexed policyId, bytes32 indexed insuredId, uint256 amount);\\n\\n    function _getSimplePolicyInfo(bytes32 _policyId) internal view returns (SimplePolicy memory simplePolicyInfo) {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n        simplePolicyInfo = s.simplePolicies[_policyId];\\n    }\\n\\n    function _checkAndUpdateState(bytes32 _policyId) internal {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n        SimplePolicy storage simplePolicy = s.simplePolicies[_policyId];\\n\\n        if (!simplePolicy.cancelled && block.timestamp >= simplePolicy.maturationDate && simplePolicy.fundsLocked) {\\n            // When the policy matures, the entity regains their capacity that was being utilized for that policy.\\n            releaseFunds(_policyId);\\n\\n            // emit event\\n            emit SimplePolicyMatured(_policyId);\\n        }\\n    }\\n\\n    function _payPremium(\\n        bytes32 _payerEntityId,\\n        bytes32 _policyId,\\n        uint256 _amount\\n    ) internal {\\n        require(_amount > 0, \\\"invalid premium amount\\\");\\n\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n        if (!s.existingEntities[_payerEntityId]) {\\n            revert EntityDoesNotExist(_payerEntityId);\\n        }\\n        if (!s.existingSimplePolicies[_policyId]) {\\n            revert PolicyDoesNotExist(_policyId);\\n        }\\n        bytes32 policyEntityId = LibObject._getParent(_policyId);\\n        SimplePolicy storage simplePolicy = s.simplePolicies[_policyId];\\n        require(!simplePolicy.cancelled, \\\"Policy is cancelled\\\");\\n\\n        LibTokenizedVault._internalTransfer(_payerEntityId, policyEntityId, simplePolicy.asset, _amount);\\n        LibFeeRouter._payPremiumFees(_policyId, _amount);\\n\\n        simplePolicy.premiumsPaid += _amount;\\n\\n        emit SimplePolicyPremiumPaid(_policyId, _amount);\\n    }\\n\\n    function _payClaim(\\n        bytes32 _claimId,\\n        bytes32 _policyId,\\n        bytes32 _insuredEntityId,\\n        uint256 _amount\\n    ) internal {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n\\n        require(_amount > 0, \\\"invalid claim amount\\\");\\n        require(LibACL._isInGroup(_insuredEntityId, _policyId, LibHelpers._stringToBytes32(LibConstants.GROUP_INSURED_PARTIES)), \\\"not an insured party\\\");\\n\\n        SimplePolicy storage simplePolicy = s.simplePolicies[_policyId];\\n        require(!simplePolicy.cancelled, \\\"Policy is cancelled\\\");\\n\\n        uint256 claimsPaid = simplePolicy.claimsPaid;\\n        require(simplePolicy.limit >= _amount + claimsPaid, \\\"exceeds policy limit\\\");\\n        simplePolicy.claimsPaid += _amount;\\n\\n        bytes32 entityId = LibObject._getParent(_policyId);\\n        Entity memory entity = s.entities[entityId];\\n        s.lockedBalances[entityId][entity.assetId] -= (_amount * entity.collateralRatio) / LibConstants.BP_FACTOR;\\n\\n        s.entities[entityId].utilizedCapacity -= (_amount * entity.collateralRatio) / LibConstants.BP_FACTOR;\\n\\n        LibObject._createObject(_claimId);\\n\\n        LibTokenizedVault._internalTransfer(entityId, _insuredEntityId, simplePolicy.asset, _amount);\\n\\n        emit SimplePolicyClaimPaid(_claimId, _policyId, _insuredEntityId, _amount);\\n    }\\n\\n    function _cancel(bytes32 _policyId) internal {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n        SimplePolicy storage simplePolicy = s.simplePolicies[_policyId];\\n        require(!simplePolicy.cancelled, \\\"Policy already cancelled\\\");\\n\\n        releaseFunds(_policyId);\\n        simplePolicy.cancelled = true;\\n\\n        emit SimplePolicyCancelled(_policyId);\\n    }\\n\\n    function releaseFunds(bytes32 _policyId) private {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n        bytes32 entityId = LibObject._getParent(_policyId);\\n\\n        SimplePolicy storage simplePolicy = s.simplePolicies[_policyId];\\n        Entity storage entity = s.entities[entityId];\\n\\n        uint256 policyLockedAmount = ((simplePolicy.limit - simplePolicy.claimsPaid) * entity.collateralRatio) / LibConstants.BP_FACTOR;\\n        entity.utilizedCapacity -= policyLockedAmount;\\n        s.lockedBalances[entityId][entity.assetId] -= policyLockedAmount;\\n\\n        simplePolicy.fundsLocked = false;\\n    }\\n\\n    function _getSigningHash(\\n        uint256 _startDate,\\n        uint256 _maturationDate,\\n        bytes32 _asset,\\n        uint256 _limit,\\n        bytes32 _offchainDataHash\\n    ) internal view returns (bytes32) {\\n        return\\n            LibEIP712._hashTypedDataV4(\\n                keccak256(\\n                    abi.encode(\\n                        keccak256(\\\"SimplePolicy(uint256 startDate,uint256 maturationDate,bytes32 asset,uint256 limit,bytes32 offchainDataHash)\\\"),\\n                        _startDate,\\n                        _maturationDate,\\n                        _asset,\\n                        _limit,\\n                        _offchainDataHash\\n                    )\\n                )\\n            );\\n    }\\n}\\n\"\r\n    },\r\n    \"src/diamonds/nayms/libs/LibFeeRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport { AppStorage, LibAppStorage, CalculatedFees, FeeAllocation, FeeSchedule } from \\\"../AppStorage.sol\\\";\\nimport { LibObject } from \\\"./LibObject.sol\\\";\\nimport { LibConstants } from \\\"./LibConstants.sol\\\";\\nimport { LibTokenizedVault } from \\\"./LibTokenizedVault.sol\\\";\\nimport { FeeBasisPointsExceedHalfMax } from \\\"src/diamonds/nayms/interfaces/CustomErrors.sol\\\";\\n\\nlibrary LibFeeRouter {\\n    event FeePaid(bytes32 indexed fromId, bytes32 indexed toId, bytes32 tokenId, uint256 amount, uint256 feeType);\\n\\n    event MakerBasisPointsUpdated(uint16 tradingCommissionMakerBP);\\n    event FeeScheduleAdded(bytes32 _entityId, uint256 _feeType, FeeSchedule feeSchedule);\\n\\n    function _calculatePremiumFees(bytes32 _policyId, uint256 _premiumPaid) internal view returns (CalculatedFees memory cf) {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n\\n        bytes32[] memory commissionReceivers = s.simplePolicies[_policyId].commissionReceivers;\\n        uint256[] memory commissionBasisPoints = s.simplePolicies[_policyId].commissionBasisPoints;\\n        uint256 commissionsCount = commissionReceivers.length;\\n\\n        bytes32 parentEntityId = LibObject._getParent(_policyId);\\n        FeeSchedule memory feeSchedule = _getFeeSchedule(parentEntityId, LibConstants.FEE_TYPE_PREMIUM);\\n        uint256 feeScheduleReceiversCount = feeSchedule.receiver.length;\\n\\n        uint256 totalReceiverCount;\\n        totalReceiverCount += feeScheduleReceiversCount + commissionsCount;\\n\\n        cf.feeAllocations = new FeeAllocation[](totalReceiverCount);\\n\\n        uint256 fee;\\n        for (uint256 i; i < commissionsCount; ++i) {\\n            fee = (_premiumPaid * commissionBasisPoints[i]) / LibConstants.BP_FACTOR;\\n\\n            cf.feeAllocations[i].to = commissionReceivers[i];\\n            cf.feeAllocations[i].basisPoints = commissionBasisPoints[i];\\n            cf.feeAllocations[i].fee = fee;\\n\\n            cf.totalBP += commissionBasisPoints[i];\\n            cf.totalFees += fee;\\n        }\\n\\n        for (uint256 i; i < feeScheduleReceiversCount; ++i) {\\n            fee = (_premiumPaid * feeSchedule.basisPoints[i]) / LibConstants.BP_FACTOR;\\n\\n            cf.feeAllocations[commissionsCount + i].to = feeSchedule.receiver[i];\\n            cf.feeAllocations[commissionsCount + i].basisPoints = feeSchedule.basisPoints[i];\\n            cf.feeAllocations[commissionsCount + i].fee = fee;\\n\\n            cf.totalBP += feeSchedule.basisPoints[i];\\n            cf.totalFees += fee;\\n        }\\n    }\\n\\n    /// @dev The total bp for a policy premium fee schedule cannot exceed LibConstants.BP_FACTOR since the policy's additional fee receivers and fee schedule are each checked to be less than LibConstants.BP_FACTOR / 2 when they are being set.\\n    function _payPremiumFees(bytes32 _policyId, uint256 _premiumPaid) internal {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n\\n        bytes32[] memory commissionReceivers = s.simplePolicies[_policyId].commissionReceivers;\\n        uint256[] memory commissionBasisPoints = s.simplePolicies[_policyId].commissionBasisPoints;\\n        uint256 commissionsCount = commissionReceivers.length;\\n\\n        bytes32 parentEntityId = LibObject._getParent(_policyId);\\n\\n        bytes32 asset = s.simplePolicies[_policyId].asset;\\n        uint256 fee;\\n        for (uint256 i; i < commissionsCount; ++i) {\\n            fee = (_premiumPaid * commissionBasisPoints[i]) / LibConstants.BP_FACTOR;\\n\\n            emit FeePaid(parentEntityId, commissionReceivers[i], asset, fee, LibConstants.FEE_TYPE_PREMIUM);\\n            LibTokenizedVault._internalTransfer(parentEntityId, commissionReceivers[i], asset, fee);\\n        }\\n\\n        FeeSchedule memory feeSchedule = _getFeeSchedule(parentEntityId, LibConstants.FEE_TYPE_PREMIUM);\\n\\n        uint256 feeScheduleReceiversCount = feeSchedule.receiver.length;\\n        for (uint256 i; i < feeScheduleReceiversCount; ++i) {\\n            fee = (_premiumPaid * feeSchedule.basisPoints[i]) / LibConstants.BP_FACTOR;\\n\\n            if (fee > 0) {\\n                emit FeePaid(parentEntityId, feeSchedule.receiver[i], asset, fee, LibConstants.FEE_TYPE_PREMIUM);\\n                LibTokenizedVault._internalTransfer(parentEntityId, feeSchedule.receiver[i], asset, fee);\\n            }\\n        }\\n    }\\n\\n    function _calculateTradingFees(\\n        bytes32 _buyerId,\\n        bytes32 _sellToken,\\n        bytes32 _buyToken,\\n        uint256 _buyAmount\\n    ) internal view returns (uint256 totalFees_, uint256 totalBP_) {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n\\n        uint256 offerId = s.bestOfferId[_buyToken][_sellToken];\\n        uint256 remainingBuyAmount = _buyAmount;\\n        uint256 offerCounter;\\n\\n        while (remainingBuyAmount > 0) {\\n            // if no liquidity, apply default fees\\n            uint256 feeType = s.offers[offerId].sellAmount == 0 ? LibConstants.FEE_TYPE_INITIAL_SALE : s.offers[offerId].feeSchedule;\\n            FeeSchedule memory feeSchedule = _getFeeSchedule(_buyerId, feeType);\\n\\n            uint256 amount = s.offers[offerId].sellAmount == 0 || remainingBuyAmount < s.offers[offerId].sellAmount ? remainingBuyAmount : s.offers[offerId].sellAmount;\\n\\n            remainingBuyAmount -= amount;\\n\\n            for (uint256 i; i < feeSchedule.basisPoints.length; i++) {\\n                totalFees_ += (amount * feeSchedule.basisPoints[i]) / LibConstants.BP_FACTOR;\\n                totalBP_ += feeSchedule.basisPoints[i];\\n            }\\n\\n            if (s.tradingCommissionMakerBP > 0) {\\n                totalFees_ += (amount * s.tradingCommissionMakerBP) / LibConstants.BP_FACTOR;\\n                totalBP_ += s.tradingCommissionMakerBP;\\n            }\\n\\n            offerCounter++;\\n            offerId = s.offers[offerId].rankPrev;\\n        }\\n        totalBP_ = offerCounter > 0 ? totalBP_ / offerCounter : totalBP_; // normalize total BP\\n    }\\n\\n    /// @dev The total bp for a marketplace fee schedule cannot exceed LibConstants.BP_FACTOR since the maker BP and fee schedules are each checked to be less than LibConstants.BP_FACTOR / 2 when they are being set.\\n    function _payTradingFees(\\n        uint256 _feeScheduleType,\\n        bytes32 _buyer,\\n        bytes32 _makerId,\\n        bytes32 _takerId,\\n        bytes32 _tokenId,\\n        uint256 _buyAmount\\n    ) internal returns (uint256 totalFees_) {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n\\n        // Get the fee receivers for this _feeScheduleType\\n        FeeSchedule memory feeSchedule = _getFeeSchedule(_buyer, _feeScheduleType);\\n\\n        uint256 fee;\\n        // Calculate fees for the market maker\\n        if (s.tradingCommissionMakerBP > 0) {\\n            fee = (_buyAmount * s.tradingCommissionMakerBP) / LibConstants.BP_FACTOR;\\n            totalFees_ += fee;\\n\\n            emit FeePaid(_takerId, _makerId, _tokenId, fee, LibConstants.FEE_TYPE_TRADING);\\n            LibTokenizedVault._internalTransfer(_takerId, _makerId, _tokenId, fee);\\n        }\\n\\n        uint256 feeScheduleReceiversCount = feeSchedule.receiver.length;\\n        for (uint256 i; i < feeScheduleReceiversCount; i++) {\\n            fee = (_buyAmount * feeSchedule.basisPoints[i]) / LibConstants.BP_FACTOR;\\n\\n            if (fee > 0) {\\n                LibTokenizedVault._internalTransfer(_buyer, feeSchedule.receiver[i], _tokenId, fee);\\n                totalFees_ += fee;\\n                emit FeePaid(_buyer, feeSchedule.receiver[i], _tokenId, fee, LibConstants.FEE_TYPE_TRADING);\\n            }\\n        }\\n    }\\n\\n    function _replaceMakerBP(uint16 tradingCommissionMakerBP) internal {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n        if (tradingCommissionMakerBP > LibConstants.BP_FACTOR / 2) {\\n            revert FeeBasisPointsExceedHalfMax(tradingCommissionMakerBP, LibConstants.BP_FACTOR / 2);\\n        }\\n\\n        s.tradingCommissionMakerBP = tradingCommissionMakerBP;\\n\\n        emit MakerBasisPointsUpdated(tradingCommissionMakerBP);\\n    }\\n\\n    function _addFeeSchedule(\\n        bytes32 _entityId,\\n        uint256 _feeScheduleType,\\n        bytes32[] calldata _receiver,\\n        uint16[] calldata _basisPoints\\n    ) internal {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n\\n        require(_receiver.length == _basisPoints.length, \\\"receivers and basis points mismatch\\\");\\n\\n        // Remove the fee schedule for this _entityId/_feeScheduleType if it already exists\\n        delete s.feeSchedules[_entityId][_feeScheduleType];\\n\\n        FeeSchedule memory feeSchedule = FeeSchedule({ receiver: _receiver, basisPoints: _basisPoints });\\n\\n        // Check to see that the total basis points does not exceed LibConstants.BP_FACTOR / 2 basis points\\n        uint256 receiverCount = feeSchedule.receiver.length;\\n        uint256 totalBp;\\n        for (uint256 i; i < receiverCount; ++i) {\\n            totalBp += feeSchedule.basisPoints[i];\\n        }\\n        if (totalBp > LibConstants.BP_FACTOR / 2) {\\n            revert FeeBasisPointsExceedHalfMax(totalBp, LibConstants.BP_FACTOR / 2);\\n        }\\n\\n        s.feeSchedules[_entityId][_feeScheduleType] = feeSchedule;\\n\\n        emit FeeScheduleAdded(_entityId, _feeScheduleType, feeSchedule);\\n    }\\n\\n    /// @dev VERY IMPORTANT: always use this method to fetch the fee schedule because of fallback to default one!\\n    function _getFeeSchedule(bytes32 _entityId, uint256 _feeScheduleType) internal view returns (FeeSchedule memory) {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n        FeeSchedule memory feeSchedule = s.feeSchedules[_entityId][_feeScheduleType];\\n\\n        if (feeSchedule.receiver.length == 0 || feeSchedule.receiver.length != feeSchedule.basisPoints.length) {\\n            // return default fee schedule\\n            feeSchedule = s.feeSchedules[LibConstants.DEFAULT_FEE_SCHEDULE][_feeScheduleType];\\n        }\\n        return feeSchedule;\\n    }\\n\\n    function _removeFeeSchedule(bytes32 _entityId, uint256 _feeScheduleType) internal {\\n        require(_entityId != LibConstants.DEFAULT_FEE_SCHEDULE, \\\"cannot remove default fees\\\");\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n        delete s.feeSchedules[_entityId][_feeScheduleType];\\n    }\\n\\n    function _getMakerBP() internal view returns (uint16) {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n        return s.tradingCommissionMakerBP;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/ozv4/contracts/utils/cryptography/ECDSA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/ECDSA.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../Strings.sol\\\";\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    enum RecoverError {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS,\\n        InvalidSignatureV // Deprecated in v4.8\\n    }\\n\\n    function _throwError(RecoverError error) private pure {\\n        if (error == RecoverError.NoError) {\\n            return; // no error: do nothing\\n        } else if (error == RecoverError.InvalidSignature) {\\n            revert(\\\"ECDSA: invalid signature\\\");\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        } else if (error == RecoverError.InvalidSignatureS) {\\n            revert(\\\"ECDSA: invalid signature 's' value\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature` or error string. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return tryRecover(hash, v, r, s);\\n        } else {\\n            return (address(0), RecoverError.InvalidSignatureLength);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError) {\\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\\n        return tryRecover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\n     *\\n     * _Available since v4.2._\\n     */\\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (302): v \u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return (address(0), RecoverError.InvalidSignatureS);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        if (signer == address(0)) {\\n            return (address(0), RecoverError.InvalidSignature);\\n        }\\n\\n        return (signer, RecoverError.NoError);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n\\\", Strings.toString(s.length), s));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\n    }\\n}\\n\"\r\n    },\r\n    \"src/diamonds/nayms/interfaces/IEntityFacet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport { FeeSchedule, SimplePolicy, Entity, Stakeholders } from \\\"./FreeStructs.sol\\\";\\n\\n/**\\n * @title Entities\\n * @notice Used to handle policies and token sales\\n * @dev Mainly used for token sale and policies\\n */\\ninterface IEntityFacet {\\n    /**\\n     * @dev Returns the domain separator for the current chain.\\n     */\\n    function domainSeparatorV4() external view returns (bytes32);\\n\\n    /**\\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\\n     * function returns the hash of the fully encoded EIP712 message for this domain.\\n     *\\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\\n     *\\n     * ```solidity\\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\\n     *     keccak256(\\\"Mail(address to,string contents)\\\"),\\n     *     mailTo,\\n     *     keccak256(bytes(mailContents))\\n     * )));\\n     * address signer = ECDSA.recover(digest, signature);\\n     * ```\\n     */\\n    function hashTypedDataV4(bytes32 structHash) external view returns (bytes32);\\n\\n    /**\\n     * @notice Create a Simple Policy\\n     * @param _policyId id of the policy\\n     * @param _entityId id of the entity\\n     * @param _stakeholders Struct of roles, entity IDs and signatures for the policy\\n     * @param _simplePolicy policy to create\\n     * @param _dataHash hash of the offchain data\\n     */\\n    function createSimplePolicy(\\n        bytes32 _policyId,\\n        bytes32 _entityId,\\n        Stakeholders calldata _stakeholders,\\n        SimplePolicy calldata _simplePolicy,\\n        bytes32 _dataHash\\n    ) external;\\n\\n    /**\\n     * @notice Enable an entity to be tokenized\\n     * @param _entityId ID of the entity\\n     * @param _symbol The symbol assigned to the entity token\\n     * @param _name The name assigned to the entity token\\n     */\\n    function enableEntityTokenization(\\n        bytes32 _entityId,\\n        string memory _symbol,\\n        string memory _name\\n    ) external;\\n\\n    /**\\n     * @notice Update entity token name and symbol\\n     * @param _entityId ID of the entity\\n     * @param _symbol New entity token symbol\\n     * @param _name New entity token name\\n     */\\n    function updateEntityTokenInfo(\\n        bytes32 _entityId,\\n        string memory _symbol,\\n        string memory _name\\n    ) external;\\n\\n    /**\\n     * @notice Start token sale of `_amount` tokens for total price of `_totalPrice`\\n     * @dev Entity tokens are minted when the sale is started\\n     * @param _entityId ID of the entity\\n     * @param _amount amount of entity tokens to put on sale\\n     * @param _totalPrice total price of the tokens\\n     */\\n    function startTokenSale(\\n        bytes32 _entityId,\\n        uint256 _amount,\\n        uint256 _totalPrice\\n    ) external;\\n\\n    /**\\n     * @notice Check if an entity token is wrapped as ERC20\\n     * @param _entityId ID of the entity\\n     * @return true if it is, false otherwise\\n     */\\n    function isTokenWrapped(bytes32 _entityId) external view returns (bool);\\n\\n    /**\\n     * @notice Update entity metadata\\n     * @param _entityId ID of the entity\\n     * @param _entity metadata of the entity\\n     */\\n    function updateEntity(bytes32 _entityId, Entity calldata _entity) external;\\n\\n    /**\\n     * @notice Get the the data for entity with ID: `_entityId`\\n     * @dev Get the Entity data for a given entityId\\n     * @param _entityId ID of the entity\\n     * @return Entity struct with metadata of the entity\\n     */\\n    function getEntityInfo(bytes32 _entityId) external view returns (Entity memory);\\n\\n    function getFeeSchedule(bytes32 _entityId, uint256 _feeScheduleType) external view returns (FeeSchedule memory);\\n}\\n\"\r\n    },\r\n    \"src/diamonds/nayms/interfaces/ISimplePolicyFacet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport { SimplePolicyInfo, SimplePolicy, CalculatedFees } from \\\"./FreeStructs.sol\\\";\\n\\n/**\\n * @title Simple Policies\\n * @notice Facet for working with Simple Policies\\n * @dev Simple Policy facet\\n */\\ninterface ISimplePolicyFacet {\\n    /**\\n     * @dev Generate a simple policy hash for singing by the stakeholders\\n     * @param _startDate Date when policy becomes active\\n     * @param _maturationDate Date after which policy becomes matured\\n     * @param _asset ID of the underlying asset, used as collateral and to pay out claims\\n     * @param _limit Policy coverage limit\\n     * @param _offchainDataHash Hash of all the important policy data stored offchain\\n     * @return signingHash_ hash for signing\\n     */\\n    function getSigningHash(\\n        uint256 _startDate,\\n        uint256 _maturationDate,\\n        bytes32 _asset,\\n        uint256 _limit,\\n        bytes32 _offchainDataHash\\n    ) external view returns (bytes32 signingHash_);\\n\\n    /**\\n     * @dev Pay a premium of `_amount` on simple policy\\n     * @param _policyId Id of the simple policy\\n     * @param _amount Amount of the premium\\n     */\\n    function paySimplePremium(bytes32 _policyId, uint256 _amount) external;\\n\\n    /**\\n     * @dev Pay a claim of `_amount` for simple policy\\n     * @param _claimId Id of the simple policy claim\\n     * @param _policyId Id of the simple policy\\n     * @param _insuredId Id of the insured party\\n     * @param _amount Amount of the claim\\n     */\\n    function paySimpleClaim(\\n        bytes32 _claimId,\\n        bytes32 _policyId,\\n        bytes32 _insuredId,\\n        uint256 _amount\\n    ) external;\\n\\n    /**\\n     * @dev Get simple policy info\\n     * @param _id Id of the simple policy\\n     * @return Simple policy metadata\\n     */\\n    function getSimplePolicyInfo(bytes32 _id) external view returns (SimplePolicyInfo memory);\\n\\n    /**\\n     * @dev Get the list of commission receivers\\n     * @param _id Id of the simple policy\\n     * @return commissionReceivers\\n     */\\n    function getPolicyCommissionReceivers(bytes32 _id) external returns (bytes32[] memory commissionReceivers);\\n\\n    /**\\n     * @dev Check and update simple policy state\\n     * @param _id Id of the simple policy\\n     */\\n    function checkAndUpdateSimplePolicyState(bytes32 _id) external;\\n\\n    /**\\n     * @dev Cancel a simple policy\\n     * @param _policyId Id of the simple policy\\n     */\\n    function cancelSimplePolicy(bytes32 _policyId) external;\\n\\n    /**\\n     * @dev Calculate the policy premium fees based on a buy amount.\\n     * @param _premiumPaid The amount that the fees payments are calculated from.\\n     * @return cf CalculatedFees struct\\n     */\\n    function calculatePremiumFees(bytes32 _policyId, uint256 _premiumPaid) external view returns (CalculatedFees memory cf);\\n}\\n\"\r\n    },\r\n    \"src/diamonds/nayms/interfaces/IMarketFacet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport { MarketInfo } from \\\"./FreeStructs.sol\\\";\\n\\n/**\\n * @title Matching Market (inspired by MakerOTC: https://github.com/nayms/maker-otc/blob/master/contracts/matching_market.sol)\\n * @notice Trade entity tokens\\n * @dev This should only be called through an entity, never directly by an EOA\\n */\\ninterface IMarketFacet {\\n    /**\\n     * @notice Execute a limit offer.\\n     *\\n     * @param _sellToken Token to sell.\\n     * @param _sellAmount Amount to sell.\\n     * @param _buyToken Token to buy.\\n     * @param _buyAmount Amount to buy.\\n     * @return offerId_ returns >0 if a limit offer was created on the market because the offer couldn't be totally fulfilled immediately. In this case the return value is the created offer's id.\\n     * @return buyTokenCommissionsPaid_ The amount of the buy token paid as commissions on this particular order.\\n     * @return sellTokenCommissionsPaid_ The amount of the sell token paid as commissions on this particular order.\\n     */\\n    function executeLimitOffer(\\n        bytes32 _sellToken,\\n        uint256 _sellAmount,\\n        bytes32 _buyToken,\\n        uint256 _buyAmount\\n    )\\n        external\\n        returns (\\n            uint256 offerId_,\\n            uint256 buyTokenCommissionsPaid_,\\n            uint256 sellTokenCommissionsPaid_\\n        );\\n\\n    /**\\n     * @notice Cancel offer #`_offerId`. This will cancel the offer so that it's no longer active.\\n     *\\n     * @dev This function can be frontrun: In the scenario where a user wants to cancel an unfavorable market offer, an attacker can potentially monitor and identify\\n     *       that the user has called this method, determine that filling this market offer is profitable, and as a result call executeLimitOffer with a higher gas price to have\\n     *       their transaction filled before the user can have cancelOffer filled. The most ideal situation for the user is to not have placed the unfavorable market offer\\n     *       in the first place since an attacker can always monitor our marketplace and potentially identify profitable market offers. Our UI will aide users in not placing\\n     *       market offers that are obviously unfavorable to the user and/or seem like mistake orders. In the event that a user needs to cancel an offer, it is recommended to\\n     *       use Flashbots in order to privately send your transaction so an attack cannot be triggered from monitoring the mempool for calls to cancelOffer. A user is recommended\\n     *       to change their RPC endpoint to point to https://rpc.flashbots.net when calling cancelOffer. We will add additional documentation to aide our users in this process.\\n     *       More information on using Flashbots: https://docs.flashbots.net/flashbots-protect/rpc/quick-start/\\n     *\\n     * @param _offerId offer ID\\n     */\\n    function cancelOffer(uint256 _offerId) external;\\n\\n    /**\\n     * @notice Get current best offer for given token pair.\\n     *\\n     * @dev This means finding the highest sellToken-per-buyToken price, i.e. price = sellToken / buyToken\\n     *\\n     * @return offerId, or 0 if no current best is available.\\n     */\\n    function getBestOfferId(bytes32 _sellToken, bytes32 _buyToken) external view returns (uint256);\\n\\n    /**\\n     * @dev Get last created offer.\\n     *\\n     * @return offer id.\\n     */\\n    function getLastOfferId() external view returns (uint256);\\n\\n    /**\\n     * @dev Get the details of the offer #`_offerId`\\n     * @param _offerId ID of a particular offer\\n     * @return _offerState details of the offer\\n     */\\n    function getOffer(uint256 _offerId) external view returns (MarketInfo memory _offerState);\\n\\n    /**\\n     * @dev Check if the offer #`_offerId` is active or not.\\n     * @param _offerId ID of a particular offer\\n     * @return active or not\\n     */\\n    function isActiveOffer(uint256 _offerId) external view returns (bool);\\n\\n    /**\\n     * @dev Calculate the trading fees based on a buy amount.\\n     * @param _buyerId The account buying the asset.\\n     * @param _sellToken The asset being sold.\\n     * @param _buyToken The asset being bought.\\n     * @param _buyAmount The amount that the fees payments are calculated from.\\n     * @return totalFees_ total fee to be payed\\n     * @return totalBP_ total basis points\\n     */\\n    function calculateTradingFees(\\n        bytes32 _buyerId,\\n        bytes32 _sellToken,\\n        bytes32 _buyToken,\\n        uint256 _buyAmount\\n    ) external view returns (uint256 totalFees_, uint256 totalBP_);\\n\\n    /**\\n     * @dev Get the maker commission basis points.\\n     * @return maker fee BP\\n     */\\n    function getMakerBP() external view returns (uint16);\\n}\\n\"\r\n    },\r\n    \"src/diamonds/nayms/interfaces/ITokenizedVaultFacet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\ninterface ITokenizedVaultFacet {\\n    /**\\n     * @notice Gets balance of an account within platform\\n     * @dev Internal balance for given account\\n     * @param tokenId Internal ID of the asset\\n     * @return current balance\\n     */\\n    function internalBalanceOf(bytes32 accountId, bytes32 tokenId) external view returns (uint256);\\n\\n    /**\\n     * @notice Current supply for the asset\\n     * @dev Total supply of platform asset\\n     * @param tokenId Internal ID of the asset\\n     * @return current balance\\n     */\\n    function internalTokenSupply(bytes32 tokenId) external view returns (uint256);\\n\\n    /**\\n     * @notice Internal transfer of `amount` tokens\\n     * @dev Transfer tokens internally\\n     * @param to token receiver\\n     * @param tokenId Internal ID of the token\\n     */\\n    function internalTransferFromEntity(\\n        bytes32 to,\\n        bytes32 tokenId,\\n        uint256 amount\\n    ) external;\\n\\n    /**\\n     * @notice Internal transfer of `amount` tokens `from` -> `to`\\n     * @dev Transfer tokens internally between two IDs\\n     * @param from token sender\\n     * @param to token receiver\\n     * @param tokenId Internal ID of the token\\n     */\\n    function wrapperInternalTransferFrom(\\n        bytes32 from,\\n        bytes32 to,\\n        bytes32 tokenId,\\n        uint256 amount\\n    ) external;\\n\\n    function internalBurn(\\n        bytes32 from,\\n        bytes32 tokenId,\\n        uint256 amount\\n    ) external;\\n\\n    /**\\n     * @notice Get withdrawable dividend amount\\n     * @dev Divident available for an entity to withdraw\\n     * @param _entityId Unique ID of the entity\\n     * @param _tokenId Unique ID of token\\n     * @param _dividendTokenId Unique ID of dividend token\\n     * @return _entityPayout accumulated dividend\\n     */\\n    function getWithdrawableDividend(\\n        bytes32 _entityId,\\n        bytes32 _tokenId,\\n        bytes32 _dividendTokenId\\n    ) external view returns (uint256 _entityPayout);\\n\\n    /**\\n     * @notice Withdraw available dividend\\n     * @dev Transfer dividends to the entity\\n     * @param ownerId Unique ID of the dividend receiver\\n     * @param tokenId Unique ID of token\\n     * @param dividendTokenId Unique ID of dividend token\\n     */\\n    function withdrawDividend(\\n        bytes32 ownerId,\\n        bytes32 tokenId,\\n        bytes32 dividendTokenId\\n    ) external;\\n\\n    /**\\n     * @notice Withdraws a user's available dividends.\\n     * @dev Dividends can be available in more than one dividend denomination. This method will withdraw all available dividends in the different dividend denominations.\\n     * @param ownerId Unique ID of the dividend receiver\\n     * @param tokenId Unique ID of token\\n     */\\n    function withdrawAllDividends(bytes32 ownerId, bytes32 tokenId) external;\\n\\n    /**\\n     * @notice Pay `amount` of dividends\\n     * @dev Transfer dividends to the entity\\n     * @param guid Globally unique identifier of a dividend distribution.\\n     * @param amount the mamount of the dividend token to be distributed to NAYMS token holders.\\n     */\\n    function payDividendFromEntity(bytes32 guid, uint256 amount) external;\\n\\n    /**\\n     * @notice Get the amount of tokens that an entity has for sale in the marketplace.\\n     * @param _entityId  Unique platform ID of the entity.\\n     * @param _tokenId The ID assigned to an external token.\\n     * @return amount of tokens that the entity has for sale in the marketplace.\\n     */\\n    function getLockedBalance(bytes32 _entityId, bytes32 _tokenId) external view returns (uint256 amount);\\n\\n    function internalTransferBySystemAdmin(\\n        bytes32 _fromEntityId,\\n        bytes32 _toEntityId,\\n        bytes32 _tokenId,\\n        uint256 _amount\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"src/erc20/ERC20Wrapper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport { IERC20 } from \\\"./IERC20.sol\\\";\\nimport { INayms } from \\\"../diamonds/nayms/INayms.sol\\\";\\nimport { LibHelpers } from \\\"../diamonds/nayms/libs/LibHelpers.sol\\\";\\nimport { ReentrancyGuard } from \\\"../utils/ReentrancyGuard.sol\\\";\\n\\ncontract ERC20Wrapper is IERC20, ReentrancyGuard {\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n    bytes32 internal immutable tokenId;\\n    INayms internal immutable nayms;\\n    mapping(address => mapping(address => uint256)) public allowances;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            EIP-2612 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\n    mapping(address => uint256) public nonces;\\n\\n    constructor(bytes32 _tokenId) {\\n        // ensure only diamond can instantiate this\\n        nayms = INayms(msg.sender);\\n\\n        require(nayms.isObjectTokenizable(_tokenId), \\\"must be tokenizable\\\");\\n        require(!nayms.isTokenWrapped(_tokenId), \\\"must not be wrapped already\\\");\\n\\n        tokenId = _tokenId;\\n\\n        INITIAL_CHAIN_ID = block.chainid;\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\n    }\\n\\n    function name() external view returns (string memory) {\\n        (, , , string memory tokenName, ) = nayms.getObjectMeta(tokenId);\\n        return tokenName;\\n    }\\n\\n    function symbol() external view returns (string memory) {\\n        (, , string memory tokenSymbol, , ) = nayms.getObjectMeta(tokenId);\\n        return tokenSymbol;\\n    }\\n\\n    function decimals() external pure returns (uint8) {\\n        return 18;\\n    }\\n\\n    function totalSupply() external view returns (uint256) {\\n        return nayms.internalTokenSupply(tokenId);\\n    }\\n\\n    function balanceOf(address who) external view returns (uint256) {\\n        return nayms.internalBalanceOf(LibHelpers._getIdForAddress(who), tokenId);\\n    }\\n\\n    function allowance(address owner, address spender) external view returns (uint256) {\\n        return allowances[owner][spender];\\n    }\\n\\n    function transfer(address to, uint256 value) external nonReentrant returns (bool) {\\n        bytes32 fromId = LibHelpers._getIdForAddress(msg.sender);\\n        bytes32 toId = LibHelpers._getIdForAddress(to);\\n\\n        emit Transfer(msg.sender, to, value);\\n\\n        nayms.wrapperInternalTransferFrom(fromId, toId, tokenId, value);\\n\\n        return true;\\n    }\\n\\n    function approve(address spender, uint256 value) external returns (bool) {\\n        allowances[msg.sender][spender] = value;\\n        return true;\\n    }\\n\\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool) {\\n        require(type(uint256).max - allowances[msg.sender][spender] >= addedValue, \\\"ERC20: allowance overflow\\\");\\n        unchecked {\\n            allowances[msg.sender][spender] += addedValue;\\n        }\\n        return true;\\n    }\\n\\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool) {\\n        uint256 currentAllowance = allowances[msg.sender][spender];\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            allowances[msg.sender][spender] -= subtractedValue;\\n        }\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external nonReentrant returns (bool) {\\n        if (value == 0) {\\n            revert();\\n        }\\n        uint256 allowed = allowances[from][msg.sender]; // Saves gas for limited approvals.\\n        require(allowed >= value, \\\"not enough allowance\\\");\\n\\n        if (allowed != type(uint256).max) allowances[from][msg.sender] = allowed - value;\\n\\n        bytes32 fromId = LibHelpers._getIdForAddress(from);\\n        bytes32 toId = LibHelpers._getIdForAddress(to);\\n\\n        emit Transfer(from, to, value);\\n\\n        nayms.wrapperInternalTransferFrom(fromId, toId, tokenId, value);\\n\\n        return true;\\n    }\\n\\n    // refer to https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol#L116\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external {\\n        require(deadline >= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\n\\n        // Unchecked because the only math done is incrementing\\n        // the owner's nonce which cannot realistically overflow.\\n        unchecked {\\n            address recoveredAddress = ecrecover(\\n                keccak256(\\n                    abi.encodePacked(\\n                        \\\"\\\\x19\\\\x01\\\",\\n                        DOMAIN_SEPARATOR(),\\n                        keccak256(\\n                            abi.encode(\\n                                keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\"),\\n                                owner,\\n                                spender,\\n                                value,\\n                                nonces[owner]++,\\n                                deadline\\n                            )\\n                        )\\n                    )\\n                ),\\n                v,\\n                r,\\n                s\\n            );\\n\\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"INVALID_SIGNER\\\");\\n\\n            allowances[recoveredAddress][spender] = value;\\n        }\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\n    }\\n\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                    keccak256(LibHelpers._bytes32ToBytes(tokenId)),\\n                    keccak256(\\\"1\\\"),\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n}\\n\"\r\n    },\r\n    \"src/diamonds/shared/libs/LibDiamond.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\nimport { IDiamondCut } from \\\"../interfaces/IDiamondCut.sol\\\";\\nimport { IDiamondLoupe } from \\\"../interfaces/IDiamondLoupe.sol\\\";\\nimport { IERC165 } from \\\"../interfaces/IERC165.sol\\\";\\nimport { IERC173 } from \\\"../interfaces/IERC173.sol\\\";\\nimport { IACLFacet } from \\\"src/diamonds/nayms/interfaces/IACLFacet.sol\\\";\\nimport { IGovernanceFacet } from \\\"src/diamonds/nayms/interfaces/IGovernanceFacet.sol\\\";\\nimport { AppStorage, LibAppStorage } from \\\"src/diamonds/nayms/AppStorage.sol\\\";\\nimport { LibHelpers } from \\\"src/diamonds/nayms/libs/LibHelpers.sol\\\";\\nimport { LibConstants } from \\\"src/diamonds/nayms/libs/LibConstants.sol\\\";\\nimport { LibAdmin } from \\\"src/diamonds/nayms/libs/LibAdmin.sol\\\";\\nimport { LibACL } from \\\"src/diamonds/nayms/libs/LibACL.sol\\\";\\n\\nerror InitializationFunctionReverted(address _initializationContractAddress, bytes _calldata);\\n\\nlibrary LibDiamond {\\n    bytes32 internal constant DIAMOND_STORAGE_POSITION = keccak256(\\\"diamond.standard.diamond.storage\\\");\\n\\n    struct DiamondStorage {\\n        // maps function selectors to the facets that execute the functions.\\n        // and maps the selectors to their position in the selectorSlots array.\\n        // func selector => address facet, selector position\\n        mapping(bytes4 => bytes32) facets;\\n        // array of slots of function selectors.\\n        // each slot holds 8 function selectors.\\n        mapping(uint256 => bytes32) selectorSlots;\\n        // The number of function selectors in selectorSlots\\n        uint16 selectorCount;\\n        // Used to query if a contract implements an interface.\\n        // Used to implement ERC-165.\\n        mapping(bytes4 => bool) supportedInterfaces;\\n        // owner of the contract\\n        address contractOwner;\\n    }\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n    event DiamondCut(IDiamondCut.FacetCut[] diamondCut, address init, bytes _calldata);\\n\\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\\n        bytes32 position = DIAMOND_STORAGE_POSITION;\\n        assembly {\\n            ds.slot := position\\n        }\\n    }\\n\\n    function setContractOwner(address _newOwner) internal {\\n        DiamondStorage storage ds = diamondStorage();\\n        address previousOwner = ds.contractOwner;\\n        ds.contractOwner = _newOwner;\\n        emit OwnershipTransferred(previousOwner, _newOwner);\\n    }\\n\\n    function contractOwner() internal view returns (address contractOwner_) {\\n        contractOwner_ = diamondStorage().contractOwner;\\n    }\\n\\n    function enforceIsContractOwner() internal view {\\n        require(msg.sender == diamondStorage().contractOwner, \\\"LibDiamond: Must be contract owner\\\");\\n    }\\n\\n    function setRoleGroupsAndAssigners() internal {\\n        LibACL._updateRoleGroup(LibConstants.ROLE_SYSTEM_ADMIN, LibConstants.GROUP_SYSTEM_ADMINS, true);\\n        LibACL._updateRoleGroup(LibConstants.ROLE_SYSTEM_ADMIN, LibConstants.GROUP_SYSTEM_MANAGERS, true);\\n        LibACL._updateRoleGroup(LibConstants.ROLE_SYSTEM_MANAGER, LibConstants.GROUP_SYSTEM_MANAGERS, true);\\n        LibACL._updateRoleGroup(LibConstants.ROLE_ENTITY_ADMIN, LibConstants.GROUP_ENTITY_ADMINS, true);\\n        LibACL._updateRoleGroup(LibConstants.ROLE_ENTITY_MANAGER, LibConstants.GROUP_ENTITY_MANAGERS, true);\\n        LibACL._updateRoleGroup(LibConstants.ROLE_BROKER, LibConstants.GROUP_BROKERS, true);\\n        LibACL._updateRoleGroup(LibConstants.ROLE_UNDERWRITER, LibConstants.GROUP_UNDERWRITERS, true);\\n        LibACL._updateRoleGroup(LibConstants.ROLE_INSURED_PARTY, LibConstants.GROUP_INSURED_PARTIES, true);\\n        LibACL._updateRoleGroup(LibConstants.ROLE_CAPITAL_PROVIDER, LibConstants.GROUP_CAPITAL_PROVIDERS, true);\\n        LibACL._updateRoleGroup(LibConstants.ROLE_CLAIMS_ADMIN, LibConstants.GROUP_CLAIMS_ADMINS, true);\\n        LibACL._updateRoleGroup(LibConstants.ROLE_TRADER, LibConstants.GROUP_TRADERS, true);\\n        LibACL._updateRoleGroup(LibConstants.ROLE_SEGREGATED_ACCOUNT, LibConstants.GROUP_SEGREGATED_ACCOUNTS, true);\\n        LibACL._updateRoleGroup(LibConstants.ROLE_SERVICE_PROVIDER, LibConstants.GROUP_SERVICE_PROVIDERS, true);\\n        LibACL._updateRoleGroup(LibConstants.ROLE_BROKER, LibConstants.GROUP_POLICY_HANDLERS, true);\\n        LibACL._updateRoleGroup(LibConstants.ROLE_INSURED_PARTY, LibConstants.GROUP_POLICY_HANDLERS, true);\\n\\n        LibACL._updateRoleAssigner(LibConstants.ROLE_SYSTEM_ADMIN, LibConstants.GROUP_SYSTEM_ADMINS);\\n        LibACL._updateRoleAssigner(LibConstants.ROLE_SYSTEM_MANAGER, LibConstants.GROUP_SYSTEM_MANAGERS);\\n        LibACL._updateRoleAssigner(LibConstants.ROLE_ENTITY_ADMIN, LibConstants.GROUP_SYSTEM_MANAGERS);\\n        LibACL._updateRoleAssigner(LibConstants.ROLE_ENTITY_MANAGER, LibConstants.GROUP_SYSTEM_MANAGERS);\\n        LibACL._updateRoleAssigner(LibConstants.ROLE_BROKER, LibConstants.GROUP_SYSTEM_MANAGERS);\\n        LibACL._updateRoleAssigner(LibConstants.ROLE_UNDERWRITER, LibConstants.GROUP_SYSTEM_MANAGERS);\\n        LibACL._updateRoleAssigner(LibConstants.ROLE_INSURED_PARTY, LibConstants.GROUP_SYSTEM_MANAGERS);\\n        LibACL._updateRoleAssigner(LibConstants.ROLE_CAPITAL_PROVIDER, LibConstants.GROUP_SYSTEM_MANAGERS);\\n        LibACL._updateRoleAssigner(LibConstants.ROLE_CLAIMS_ADMIN, LibConstants.GROUP_SYSTEM_MANAGERS);\\n        LibACL._updateRoleAssigner(LibConstants.ROLE_TRADER, LibConstants.GROUP_SYSTEM_MANAGERS);\\n        LibACL._updateRoleAssigner(LibConstants.ROLE_SEGREGATED_ACCOUNT, LibConstants.GROUP_SYSTEM_MANAGERS);\\n        LibACL._updateRoleAssigner(LibConstants.ROLE_SERVICE_PROVIDER, LibConstants.GROUP_SYSTEM_MANAGERS);\\n    }\\n\\n    function setSystemAdmin(address _newSystemAdmin) internal {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n\\n        bytes32 userId = LibHelpers._getIdForAddress(_newSystemAdmin);\\n        s.existingObjects[userId] = true;\\n\\n        LibACL._assignRole(userId, LibAdmin._getSystemId(), LibHelpers._stringToBytes32(LibConstants.ROLE_SYSTEM_ADMIN));\\n    }\\n\\n    function setUpgradeExpiration() internal {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n        /// @dev We set the upgrade expiration to 7 days from now (604800 seconds)\\n        s.upgradeExpiration = 1 weeks;\\n    }\\n\\n    function addDiamondFunctions(\\n        address _diamondCutFacet,\\n        address _diamondLoupeFacet,\\n        address _ownershipFacet,\\n        address _aclFacet,\\n        address _governanceFacet\\n    ) internal {\\n        IDiamondCut.FacetCut[] memory cut = new IDiamondCut.FacetCut[](5);\\n        bytes4[] memory functionSelectors = new bytes4[](1);\\n        functionSelectors[0] = IDiamondCut.diamondCut.selector;\\n        cut[0] = IDiamondCut.FacetCut({ facetAddress: _diamondCutFacet, action: IDiamondCut.FacetCutAction.Add, functionSelectors: functionSelectors });\\n        functionSelectors = new bytes4[](5);\\n        functionSelectors[0] = IDiamondLoupe.facets.selector;\\n        functionSelectors[1] = IDiamondLoupe.facetFunctionSelectors.selector;\\n        functionSelectors[2] = IDiamondLoupe.facetAddresses.selector;\\n        functionSelectors[3] = IDiamondLoupe.facetAddress.selector;\\n        functionSelectors[4] = IERC165.supportsInterface.selector;\\n        cut[1] = IDiamondCut.FacetCut({ facetAddress: _diamondLoupeFacet, action: IDiamondCut.FacetCutAction.Add, functionSelectors: functionSelectors });\\n        functionSelectors = new bytes4[](2);\\n        functionSelectors[0] = IERC173.transferOwnership.selector;\\n        functionSelectors[1] = IERC173.owner.selector;\\n        cut[2] = IDiamondCut.FacetCut({ facetAddress: _ownershipFacet, action: IDiamondCut.FacetCutAction.Add, functionSelectors: functionSelectors });\\n        functionSelectors = new bytes4[](11);\\n        functionSelectors[0] = IACLFacet.assignRole.selector;\\n        functionSelectors[1] = IACLFacet.unassignRole.selector;\\n        functionSelectors[2] = IACLFacet.isInGroup.selector;\\n        functionSelectors[3] = IACLFacet.isParentInGroup.selector;\\n        functionSelectors[4] = IACLFacet.canAssign.selector;\\n        functionSelectors[5] = IACLFacet.getRoleInContext.selector;\\n        functionSelectors[6] = IACLFacet.isRoleInGroup.selector;\\n        functionSelectors[7] = IACLFacet.canGroupAssignRole.selector;\\n        functionSelectors[8] = IACLFacet.updateRoleAssigner.selector;\\n        functionSelectors[9] = IACLFacet.updateRoleGroup.selector;\\n        functionSelectors[10] = IACLFacet.hasGroupPrivilege.selector;\\n        cut[3] = IDiamondCut.FacetCut({ facetAddress: _aclFacet, action: IDiamondCut.FacetCutAction.Add, functionSelectors: functionSelectors });\\n        functionSelectors = new bytes4[](6);\\n        functionSelectors[0] = IGovernanceFacet.isDiamondInitialized.selector;\\n        functionSelectors[1] = IGovernanceFacet.createUpgrade.selector;\\n        functionSelectors[2] = IGovernanceFacet.updateUpgradeExpiration.selector;\\n        functionSelectors[3] = IGovernanceFacet.cancelUpgrade.selector;\\n        functionSelectors[4] = IGovernanceFacet.getUpgrade.selector;\\n        functionSelectors[5] = IGovernanceFacet.getUpgradeExpiration.selector;\\n        cut[4] = IDiamondCut.FacetCut({ facetAddress: _governanceFacet, action: IDiamondCut.FacetCutAction.Add, functionSelectors: functionSelectors });\\n        diamondCut(cut, address(0), \\\"\\\");\\n    }\\n\\n    bytes32 internal constant CLEAR_ADDRESS_MASK = bytes32(uint256(0xffffffffffffffffffffffff));\\n    bytes32 internal constant CLEAR_SELECTOR_MASK = bytes32(uint256(0xffffffff << 224));\\n\\n    // Internal function version of diamondCut\\n    // This code is almost the same as the external diamondCut,\\n    // except it is using 'Facet[] memory _diamondCut' instead of\\n    // 'Facet[] calldata _diamondCut'.\\n    // The code is duplicated to prevent copying calldata to memory which\\n    // causes an error for a two dimensional array.\\n    function diamondCut(\\n        IDiamondCut.FacetCut[] memory _diamondCut,\\n        address _init,\\n        bytes memory _calldata\\n    ) internal {\\n        DiamondStorage storage ds = diamondStorage();\\n        uint256 originalSelectorCount = ds.selectorCount;\\n        uint256 selectorCount = originalSelectorCount;\\n        bytes32 selectorSlot;\\n        // Check if last selector slot is not full\\n        // \\\"selectorCount & 7\\\" is a gas efficient modulo by eight \\\"selectorCount % 8\\\"\\n        if (selectorCount & 7 > 0) {\\n            // get last selectorSlot\\n            // \\\"selectorSlot >> 3\\\" is a gas efficient division by 8 \\\"selectorSlot / 8\\\"\\n            selectorSlot = ds.selectorSlots[selectorCount >> 3];\\n        }\\n        // loop through diamond cut\\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\\n            (selectorCount, selectorSlot) = addReplaceRemoveFacetSelectors(\\n                selectorCount,\\n                selectorSlot,\\n                _diamondCut[facetIndex].facetAddress,\\n                _diamondCut[facetIndex].action,\\n                _diamondCut[facetIndex].functionSelectors\\n            );\\n        }\\n        if (selectorCount != originalSelectorCount) {\\n            ds.selectorCount = uint16(selectorCount);\\n        }\\n        // If last selector slot is not full\\n        // \\\"selectorCount & 7\\\" is a gas efficient modulo by eight \\\"selectorCount % 8\\\"\\n        if (selectorCount & 7 > 0) {\\n            // \\\"selectorSlot >> 3\\\" is a gas efficient division by 8 \\\"selectorSlot / 8\\\"\\n            ds.selectorSlots[selectorCount >> 3] = selectorSlot;\\n        }\\n        emit DiamondCut(_diamondCut, _init, _calldata);\\n        initializeDiamondCut(_init, _calldata);\\n    }\\n\\n    function addReplaceRemoveFacetSelectors(\\n        uint256 _selectorCount,\\n        bytes32 _selectorSlot,\\n        address _newFacetAddress,\\n        IDiamondCut.FacetCutAction _action,\\n        bytes4[] memory _selectors\\n    ) internal returns (uint256, bytes32) {\\n        DiamondStorage storage ds = diamondStorage();\\n        require(_selectors.length > 0, \\\"LibDiamondCut: No selectors in facet to cut\\\");\\n        if (_action == IDiamondCut.FacetCutAction.Add) {\\n            enforceHasContractCode(_newFacetAddress, \\\"LibDiamondCut: Add facet has no code\\\");\\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; selectorIndex++) {\\n                bytes4 selector = _selectors[selectorIndex];\\n                bytes32 oldFacet = ds.facets[selector];\\n                require(address(bytes20(oldFacet)) == address(0), \\\"LibDiamondCut: Can't add function that already exists\\\");\\n                // add facet for selector\\n                ds.facets[selector] = bytes20(_newFacetAddress) | bytes32(_selectorCount);\\n                // \\\"_selectorCount & 7\\\" is a gas efficient modulo by eight \\\"_selectorCount % 8\\\"\\n                uint256 selectorInSlotPosition = (_selectorCount & 7) << 5;\\n                // clear selector position in slot and add selector\\n                _selectorSlot = (_selectorSlot & ~(CLEAR_SELECTOR_MASK >> selectorInSlotPosition)) | (bytes32(selector) >> selectorInSlotPosition);\\n                // if slot is full then write it to storage\\n                if (selectorInSlotPosition == 224) {\\n                    // \\\"_selectorSlot >> 3\\\" is a gas efficient division by 8 \\\"_selectorSlot / 8\\\"\\n                    ds.selectorSlots[_selectorCount >> 3] = _selectorSlot;\\n                    _selectorSlot = 0;\\n                }\\n                _selectorCount++;\\n            }\\n        } else if (_action == IDiamondCut.FacetCutAction.Replace) {\\n            enforceHasContractCode(_newFacetAddress, \\\"LibDiamondCut: Replace facet has no code\\\");\\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; selectorIndex++) {\\n                bytes4 selector = _selectors[selectorIndex];\\n                bytes32 oldFacet = ds.facets[selector];\\n                address oldFacetAddress = address(bytes20(oldFacet));\\n                // only useful if immutable functions exist\\n                require(oldFacetAddress != address(this), \\\"LibDiamondCut: Can't replace immutable function\\\");\\n                require(oldFacetAddress != _newFacetAddress, \\\"LibDiamondCut: Can't replace function with same function\\\");\\n                require(oldFacetAddress != address(0), \\\"LibDiamondCut: Can't replace function that doesn't exist\\\");\\n                // replace old facet address\\n                ds.facets[selector] = (oldFacet & CLEAR_ADDRESS_MASK) | bytes20(_newFacetAddress);\\n            }\\n        } else if (_action == IDiamondCut.FacetCutAction.Remove) {\\n            require(_newFacetAddress == address(0), \\\"LibDiamondCut: Remove facet address must be address(0)\\\");\\n            // \\\"_selectorCount >> 3\\\" is a gas efficient division by 8 \\\"_selectorCount / 8\\\"\\n            uint256 selectorSlotCount = _selectorCount >> 3;\\n            // \\\"_selectorCount & 7\\\" is a gas efficient modulo by eight \\\"_selectorCount % 8\\\"\\n            uint256 selectorInSlotIndex = _selectorCount & 7;\\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; selectorIndex++) {\\n                if (_selectorSlot == 0) {\\n                    // get last selectorSlot\\n                    selectorSlotCount--;\\n                    _selectorSlot = ds.selectorSlots[selectorSlotCount];\\n                    selectorInSlotIndex = 7;\\n                } else {\\n                    selectorInSlotIndex--;\\n                }\\n                bytes4 lastSelector;\\n                uint256 oldSelectorsSlotCount;\\n                uint256 oldSelectorInSlotPosition;\\n                // adding a block here prevents stack too deep error\\n                {\\n                    bytes4 selector = _selectors[selectorIndex];\\n                    bytes32 oldFacet = ds.facets[selector];\\n                    require(address(bytes20(oldFacet)) != address(0), \\\"LibDiamondCut: Can't remove function that doesn't exist\\\");\\n                    // only useful if immutable functions exist\\n                    require(address(bytes20(oldFacet)) != address(this), \\\"LibDiamondCut: Can't remove immutable function\\\");\\n                    // replace selector with last selector in ds.facets\\n                    // gets the last selector\\n                    lastSelector = bytes4(_selectorSlot << (selectorInSlotIndex << 5));\\n                    if (lastSelector != selector) {\\n                        // update last selector slot position info\\n                        ds.facets[lastSelector] = (oldFacet & CLEAR_ADDRESS_MASK) | bytes20(ds.facets[lastSelector]);\\n                    }\\n                    delete ds.facets[selector];\\n                    uint256 oldSelectorCount = uint16(uint256(oldFacet));\\n                    // \\\"oldSelectorCount >> 3\\\" is a gas efficient division by 8 \\\"oldSelectorCount / 8\\\"\\n                    oldSelectorsSlotCount = oldSelectorCount >> 3;\\n                    // \\\"oldSelectorCount & 7\\\" is a gas efficient modulo by eight \\\"oldSelectorCount % 8\\\"\\n                    oldSelectorInSlotPosition = (oldSelectorCount & 7) << 5;\\n                }\\n                if (oldSelectorsSlotCount != selectorSlotCount) {\\n                    bytes32 oldSelectorSlot = ds.selectorSlots[oldSelectorsSlotCount];\\n                    // clears the selector we are deleting and puts the last selector in its place.\\n                    oldSelectorSlot = (oldSelectorSlot & ~(CLEAR_SELECTOR_MASK >> oldSelectorInSlotPosition)) | (bytes32(lastSelector) >> oldSelectorInSlotPosition);\\n                    // update storage with the modified slot\\n                    ds.selectorSlots[oldSelectorsSlotCount] = oldSelectorSlot;\\n                } else {\\n                    // clears the selector we are deleting and puts the last selector in its place.\\n                    _selectorSlot = (_selectorSlot & ~(CLEAR_SELECTOR_MASK >> oldSelectorInSlotPosition)) | (bytes32(lastSelector) >> oldSelectorInSlotPosition);\\n                }\\n                if (selectorInSlotIndex == 0) {\\n                    delete ds.selectorSlots[selectorSlotCount];\\n                    _selectorSlot = 0;\\n                }\\n            }\\n            _selectorCount = selectorSlotCount * 8 + selectorInSlotIndex;\\n        } else {\\n            revert(\\\"LibDiamondCut: Incorrect FacetCutAction\\\");\\n        }\\n        return (_selectorCount, _selectorSlot);\\n    }\\n\\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\\n        if (_init == address(0)) {\\n            require(_calldata.length == 0, \\\"LibDiamondCut: _init is address(0) but_calldata is not empty\\\");\\n        } else {\\n            require(_calldata.length > 0, \\\"LibDiamondCut: _calldata is empty but _init is not address(0)\\\");\\n            if (_init != address(this)) {\\n                enforceHasContractCode(_init, \\\"LibDiamondCut: _init address has no code\\\");\\n            }\\n            (bool success, bytes memory error) = _init.delegatecall(_calldata);\\n            if (!success) {\\n                if (error.length > 0) {\\n                    // bubble up the error\\n                    revert(string(error));\\n                } else {\\n                    revert InitializationFunctionReverted(_init, _calldata);\\n                }\\n            }\\n        }\\n    }\\n\\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\\n        uint256 contractSize;\\n        assembly {\\n            contractSize := extcodesize(_contract)\\n        }\\n        require(contractSize > 0, _errorMessage);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/erc20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\n/**\\n * See https://github.com/OpenZeppelin/openzeppelin-contracts/tree/master/contracts/token/ERC20\\n */\\ninterface IERC20 {\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function decimals() external view returns (uint8);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address who) external view returns (uint256);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external returns (bool);\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"src/diamonds/nayms/interfaces/FreeStructs.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nstruct MarketInfo {\\n    bytes32 creator; // entity ID\\n    bytes32 sellToken;\\n    uint256 sellAmount;\\n    uint256 sellAmountInitial;\\n    bytes32 buyToken;\\n    uint256 buyAmount;\\n    uint256 buyAmountInitial;\\n    uint256 feeSchedule;\\n    uint256 state;\\n    uint256 rankNext;\\n    uint256 rankPrev;\\n}\\n\\nstruct TokenAmount {\\n    bytes32 token;\\n    uint256 amount;\\n}\\n\\n/**\\n * @param maxCapacity Maximum allowable amount of capacity that an entity is given. Denominated by assetId.\\n * @param utilizedCapacity The utilized capacity of the entity. Denominated by assetId.\\n */\\nstruct Entity {\\n    bytes32 assetId;\\n    uint256 collateralRatio;\\n    uint256 maxCapacity;\\n    uint256 utilizedCapacity;\\n    bool simplePolicyEnabled;\\n}\\n\\n/// @dev Only pass in the fields that are allowed to be updated.\\n/// @dev These are the variables of an entity that are allowed to be updated by the method updateEntity()\\nstruct UpdateEntityTypeCell {\\n    uint256 collateralRatio;\\n    uint256 maxCapacity;\\n    bool simplePolicyEnabled;\\n}\\n\\nstruct SimplePolicy {\\n    uint256 startDate;\\n    uint256 maturationDate;\\n    bytes32 asset;\\n    uint256 limit;\\n    bool fundsLocked;\\n    bool cancelled;\\n    uint256 claimsPaid;\\n    uint256 premiumsPaid;\\n    bytes32[] commissionReceivers;\\n    uint256[] commissionBasisPoints;\\n}\\n\\nstruct SimplePolicyInfo {\\n    uint256 startDate;\\n    uint256 maturationDate;\\n    bytes32 asset;\\n    uint256 limit;\\n    bool fundsLocked;\\n    bool cancelled;\\n    uint256 claimsPaid;\\n    uint256 premiumsPaid;\\n}\\n\\nstruct Stakeholders {\\n    bytes32[] roles;\\n    bytes32[] entityIds;\\n    bytes[] signatures;\\n}\\n\\n// Used in StakingFacet\\nstruct LockedBalance {\\n    uint256 amount;\\n    uint256 endTime;\\n}\\n\\nstruct StakingCheckpoint {\\n    int128 bias;\\n    int128 slope; // - dweight / dt\\n    uint256 ts; // timestamp\\n    uint256 blk; // block number\\n}\\n\\nstruct FeeSchedule {\\n    bytes32[] receiver;\\n    uint16[] basisPoints;\\n}\\n\\nstruct FeeAllocation {\\n    bytes32 from; // The ID of the entity that paid the fee\\n    bytes32 to; // The ID of the entity that receives the fee\\n    bytes32 token; // The ID of the token that was used to pay the fee\\n    uint256 fee; // The amount of fees paid to the receiver\\n    uint256 basisPoints; // The basis points taken from the amount transacted\\n}\\n\\nstruct CalculatedFees {\\n    uint256 totalFees; // total amount of fees paid\\n    uint256 totalBP; // total basis points of fees paid\\n    FeeAllocation[] feeAllocations; // The list of entities that receive a portion of the fees.\\n}\\n\"\r\n    },\r\n    \"src/diamonds/nayms/libs/LibEIP712.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport { AppStorage, LibAppStorage } from \\\"../AppStorage.sol\\\";\\n\\nimport { ECDSA } from \\\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\\\";\\n\\nlibrary LibEIP712 {\\n    function _domainSeparatorV4() internal view returns (bytes32) {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n\\n        return block.chainid == s.initialChainId ? s.initialDomainSeparator : _computeDomainSeparator();\\n    }\\n\\n    function _computeDomainSeparator() internal view returns (bytes32) {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                    keccak256(bytes(s.name)),\\n                    keccak256(\\\"1\\\"),\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    function _hashTypedDataV4(bytes32 structHash) internal view returns (bytes32) {\\n        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/ozv4/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/Math.sol\\\";\\nimport \\\"./math/SignedMath.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(int256 value) internal pure returns (string memory) {\\n        return string(abi.encodePacked(value < 0 ? \\\"-\\\" : \\\"\\\", toString(SignedMath.abs(value))));\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n\\n    /**\\n     * @dev Returns true if the two strings are equal.\\n     */\\n    function equal(string memory a, string memory b) internal pure returns (bool) {\\n        return keccak256(bytes(a)) == keccak256(bytes(b));\\n    }\\n}\\n\"\r\n    },\r\n    \"src/diamonds/nayms/INayms.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\n// solhint-disable no-empty-blocks\\n\\nimport { IDiamondCut } from \\\"../shared/interfaces/IDiamondCut.sol\\\";\\nimport { IDiamondLoupe } from \\\"../shared/interfaces/IDiamondLoupe.sol\\\";\\nimport { IERC165 } from \\\"../shared/interfaces/IERC165.sol\\\";\\nimport { IERC173 } from \\\"../shared/interfaces/IERC173.sol\\\";\\n\\nimport { IACLFacet } from \\\"./interfaces/IACLFacet.sol\\\";\\nimport { IUserFacet } from \\\"./interfaces/IUserFacet.sol\\\";\\nimport { IAdminFacet } from \\\"./interfaces/IAdminFacet.sol\\\";\\nimport { ISystemFacet } from \\\"./interfaces/ISystemFacet.sol\\\";\\nimport { INaymsTokenFacet } from \\\"./interfaces/INaymsTokenFacet.sol\\\";\\nimport { ITokenizedVaultFacet } from \\\"./interfaces/ITokenizedVaultFacet.sol\\\";\\nimport { ITokenizedVaultIOFacet } from \\\"./interfaces/ITokenizedVaultIOFacet.sol\\\";\\nimport { IMarketFacet } from \\\"./interfaces/IMarketFacet.sol\\\";\\nimport { IEntityFacet } from \\\"./interfaces/IEntityFacet.sol\\\";\\nimport { ISimplePolicyFacet } from \\\"./interfaces/ISimplePolicyFacet.sol\\\";\\nimport { IGovernanceFacet } from \\\"./interfaces/IGovernanceFacet.sol\\\";\\n\\n/**\\n * @title Nayms Diamond\\n * @notice Everything is a part of one big diamond.\\n * @dev Every facet should be cut into this diamond.\\n */\\ninterface INayms is\\n    IDiamondCut,\\n    IDiamondLoupe,\\n    IERC165,\\n    IERC173,\\n    IACLFacet,\\n    IAdminFacet,\\n    IUserFacet,\\n    ISystemFacet,\\n    INaymsTokenFacet,\\n    ITokenizedVaultFacet,\\n    ITokenizedVaultIOFacet,\\n    IMarketFacet,\\n    IEntityFacet,\\n    ISimplePolicyFacet,\\n    IGovernanceFacet\\n{\\n\\n}\\n\"\r\n    },\r\n    \"src/diamonds/shared/interfaces/IDiamondCut.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\n\\ninterface IDiamondCut {\\n    enum FacetCutAction {\\n        Add,\\n        Replace,\\n        Remove\\n    }\\n    // Add=0, Replace=1, Remove=2\\n\\n    struct FacetCut {\\n        address facetAddress;\\n        FacetCutAction action;\\n        bytes4[] functionSelectors;\\n    }\\n\\n    /// @notice Add/replace/remove any number of functions and optionally execute\\n    ///         a function with delegatecall\\n    /// @param _diamondCut Contains the facet addresses and function selectors\\n    /// @param _init The address of the contract or facet to execute _calldata\\n    /// @param _calldata A function call, including function selector and arguments\\n    ///                  _calldata is executed with delegatecall on _init\\n    function diamondCut(\\n        FacetCut[] calldata _diamondCut,\\n        address _init,\\n        bytes calldata _calldata\\n    ) external;\\n\\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\\n}\\n\"\r\n    },\r\n    \"src/diamonds/shared/interfaces/IDiamondLoupe.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\n\\n// A loupe is a small magnifying glass used to look at diamonds.\\n// These functions look at diamonds\\ninterface IDiamondLoupe {\\n    /// These functions are expected to be called frequently\\n    /// by tools.\\n\\n    struct Facet {\\n        address facetAddress;\\n        bytes4[] functionSelectors;\\n    }\\n\\n    /// @notice Gets all facet addresses and their four byte function selectors.\\n    /// @return facets_ Facet\\n    function facets() external view returns (Facet[] memory facets_);\\n\\n    /// @notice Gets all the function selectors supported by a specific facet.\\n    /// @param _facet The facet address.\\n    /// @return facetFunctionSelectors_\\n    function facetFunctionSelectors(address _facet) external view returns (bytes4[] memory facetFunctionSelectors_);\\n\\n    /// @notice Get all the facet addresses used by a diamond.\\n    /// @return facetAddresses_\\n    function facetAddresses() external view returns (address[] memory facetAddresses_);\\n\\n    /// @notice Gets the facet that supports the given selector.\\n    /// @dev If facet is not found return address(0).\\n    /// @param _functionSelector The function selector.\\n    /// @return facetAddress_ The facet address.\\n    function facetAddress(bytes4 _functionSelector) external view returns (address facetAddress_);\\n}\\n\"\r\n    },\r\n    \"src/diamonds/shared/interfaces/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\ninterface IERC165 {\\n    /// @notice Query if a contract implements an interface\\n    /// @param interfaceId The interface identifier, as specified in ERC-165\\n    /// @dev Interface identification is specified in ERC-165. This function\\n    ///  uses less than 30,000 gas.\\n    /// @return `true` if the contract implements `interfaceID` and\\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"src/diamonds/shared/interfaces/IERC173.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\n/// @title ERC-173 Contract Ownership Standard\\n///  Note: the ERC-165 identifier for this interface is 0x7f5828d0 is ERC165\\ninterface IERC173 {\\n    /// @dev This emits when ownership of a contract changes.\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /// @notice Get the address of the owner\\n    /// @return owner_ The address of the owner.\\n    function owner() external view returns (address owner_);\\n\\n    /// @notice Set the address of the new owner of the contract\\n    /// @dev Set _newOwner to address(0) to renounce any ownership.\\n    /// @param _newOwner The address of the new owner of the contract\\n    function transferOwnership(address _newOwner) external;\\n}\\n\"\r\n    },\r\n    \"src/diamonds/nayms/interfaces/IACLFacet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\n/**\\n * @title Access Control List\\n * @notice Use it to authorize various actions on the contracts\\n * @dev Use it to (un)assign or check role membership\\n */\\ninterface IACLFacet {\\n    /**\\n     * @notice Assign a `_roleId` to the object in given context\\n     * @dev Any object ID can be a context, system is a special context with highest priority\\n     * @param _objectId ID of an object that is being assigned a role\\n     * @param _contextId ID of the context in which a role is being assigned\\n     * @param _role Name of the role being assigned\\n     */\\n    function assignRole(\\n        bytes32 _objectId,\\n        bytes32 _contextId,\\n        string memory _role\\n    ) external;\\n\\n    /**\\n     * @notice Unassign object from a role in given context\\n     * @dev Any object ID can be a context, system is a special context with highest priority\\n     * @param _objectId ID of an object that is being unassigned from a role\\n     * @param _contextId ID of the context in which a role membership is being revoked\\n     */\\n    function unassignRole(bytes32 _objectId, bytes32 _contextId) external;\\n\\n    /**\\n     * @notice Checks if an object belongs to `_group` group in given context\\n     * @dev Assigning a role to the object makes it a member of a corresponding role group\\n     * @param _objectId ID of an object that is being checked for role group membership\\n     * @param _contextId Context in which membership should be checked\\n     * @param _group name of the role group\\n     * @return true if object with given ID is a member, false otherwise\\n     */\\n    function isInGroup(\\n        bytes32 _objectId,\\n        bytes32 _contextId,\\n        string memory _group\\n    ) external view returns (bool);\\n\\n    /**\\n     * @notice Check whether a parent object belongs to the `_group` group in given context\\n     * @dev Objects can have a parent object, i.e. entity is a parent of a user\\n     * @param _objectId ID of an object whose parent is being checked for role group membership\\n     * @param _contextId Context in which the role group membership is being checked\\n     * @param _group name of the role group\\n     * @return true if object's parent is a member of this role group, false otherwise\\n     */\\n    function isParentInGroup(\\n        bytes32 _objectId,\\n        bytes32 _contextId,\\n        string memory _group\\n    ) external view returns (bool);\\n\\n    /**\\n     * @notice Check whether a user can assign specific object to the `_role` role in given context\\n     * @dev Check permission to assign to a role\\n     * @param _assignerId The object ID of the user who is assigning a role to  another object.\\n     * @param _objectId ID of an object that is being checked for assigning rights\\n     * @param _contextId ID of the context in which permission is checked\\n     * @param _role name of the role to check\\n     * @return true if user the right to assign, false otherwise\\n     */\\n    function canAssign(\\n        bytes32 _assignerId,\\n        bytes32 _objectId,\\n        bytes32 _contextId,\\n        string memory _role\\n    ) external view returns (bool);\\n\\n    /**\\n     * @notice Check whether a user can call a specific function.\\n     * @param _userId The object ID of the user who is calling the function.\\n     * @param _contextId ID of the context in which permission is checked.\\n     * @param _groupId ID of the group in which permission is checked.\\n     */\\n    function hasGroupPrivilege(\\n        bytes32 _userId,\\n        bytes32 _contextId,\\n        bytes32 _groupId\\n    ) external view returns (bool);\\n\\n    /**\\n     * @notice Get a user's (an objectId's) assigned role in a specific context\\n     * @param objectId ID of an object that is being checked for its assigned role in a specific context\\n     * @param contextId ID of the context in which the objectId's role is being checked\\n     * @return roleId objectId's role in the contextId\\n     */\\n    function getRoleInContext(bytes32 objectId, bytes32 contextId) external view returns (bytes32);\\n\\n    /**\\n     * @notice Get whether role is in group.\\n     * @dev Get whether role is in group.\\n     * @param role the role.\\n     * @param group the group.\\n     * @return true if role is in group, false otherwise.\\n     */\\n    function isRoleInGroup(string memory role, string memory group) external view returns (bool);\\n\\n    /**\\n     * @notice Get whether given group can assign given role.\\n     * @dev Get whether given group can assign given role.\\n     * @param role the role.\\n     * @param group the group.\\n     * @return true if role can be assigned by group, false otherwise.\\n     */\\n    function canGroupAssignRole(string memory role, string memory group) external view returns (bool);\\n\\n    /**\\n     * @notice Update who can assign `_role` role\\n     * @dev Update who has permission to assign this role\\n     * @param _role name of the role\\n     * @param _assignerGroup Group who can assign members to this role\\n     */\\n    function updateRoleAssigner(string memory _role, string memory _assignerGroup) external;\\n\\n    /**\\n     * @notice Update role group memebership for `_role` role and `_group` group\\n     * @dev Update role group memebership\\n     * @param _role name of the role\\n     * @param _group name of the group\\n     * @param _roleInGroup is member of\\n     */\\n    function updateRoleGroup(\\n        string memory _role,\\n        string memory _group,\\n        bool _roleInGroup\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"src/diamonds/nayms/interfaces/IGovernanceFacet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\ninterface IGovernanceFacet {\\n    /**\\n     * @notice Check if the diamond has been initialized.\\n     * @dev This will get the value from AppStorage.diamondInitialized.\\n     */\\n    function isDiamondInitialized() external view returns (bool);\\n\\n    /**\\n     * @notice Approve the following upgrade hash: `id`\\n     * @dev The diamondCut() has been modified to check if the upgrade has been scheduled. This method needs to be called in order\\n     *      for an upgrade to be executed.\\n     * @param id This is the keccak256(abi.encode(cut)), where cut is the array of FacetCut struct, IDiamondCut.FacetCut[].\\n     */\\n    function createUpgrade(bytes32 id) external;\\n\\n    /**\\n     * @notice Update the diamond cut upgrade expiration period.\\n     * @dev When createUpgrade() is called, it allows a diamondCut() upgrade to be executed. This upgrade must be executed before the\\n     *      upgrade expires. The upgrade expires based on when the upgrade was scheduled (when createUpgrade() was called) + AppStorage.upgradeExpiration.\\n     * @param duration The duration until the upgrade expires.\\n     */\\n    function updateUpgradeExpiration(uint256 duration) external;\\n\\n    /**\\n     * @notice Cancel the following upgrade hash: `id`\\n     * @dev This will set the mapping AppStorage.upgradeScheduled back to 0.\\n     * @param id This is the keccak256(abi.encode(cut)), where cut is the array of FacetCut struct, IDiamondCut.FacetCut[].\\n     */\\n    function cancelUpgrade(bytes32 id) external;\\n\\n    /**\\n     * @notice Get the expiry date for provided upgrade hash.\\n     * @dev This will get the value from AppStorage.upgradeScheduled  mapping.\\n     * @param id This is the keccak256(abi.encode(cut)), where cut is the array of FacetCut struct, IDiamondCut.FacetCut[].\\n     */\\n    function getUpgrade(bytes32 id) external view returns (uint256 expiry);\\n\\n    /**\\n     * @notice Get the upgrade expiration period.\\n     * @dev This will get the value from AppStorage.upgradeExpiration. AppStorage.upgradeExpiration is added to the block.timestamp to create the upgrade expiration date.\\n     */\\n    function getUpgradeExpiration() external view returns (uint256 upgradeExpiration);\\n}\\n\"\r\n    },\r\n    \"lib/ozv4/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1, \\\"Math: mulDiv overflow\\\");\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/ozv4/contracts/utils/math/SignedMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard signed math utilities missing in the Solidity language.\\n */\\nlibrary SignedMath {\\n    /**\\n     * @dev Returns the largest of two signed numbers.\\n     */\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two signed numbers.\\n     */\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two signed numbers without overflow.\\n     * The result is rounded towards zero.\\n     */\\n    function average(int256 a, int256 b) internal pure returns (int256) {\\n        // Formula from the book \\\"Hacker's Delight\\\"\\n        int256 x = (a & b) + ((a ^ b) >> 1);\\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\\n    }\\n\\n    /**\\n     * @dev Returns the absolute unsigned value of a signed value.\\n     */\\n    function abs(int256 n) internal pure returns (uint256) {\\n        unchecked {\\n            // must be unchecked in order to support `n = type(int256).min`\\n            return uint256(n >= 0 ? n : -n);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/diamonds/nayms/interfaces/IUserFacet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\n/**\\n * @title Users\\n * @notice Utility functions for managing a user's entity.\\n * @dev This contract includes functions to set and get user-entity relationships,\\n *      and to convert wallet addresses to platform IDs and vice versa.\\n */\\ninterface IUserFacet {\\n    /**\\n     * @notice Get the platform ID of `addr` account\\n     * @dev Convert address to platform ID\\n     * @param addr Account address\\n     * @return userId Unique platform ID\\n     */\\n    function getUserIdFromAddress(address addr) external pure returns (bytes32 userId);\\n\\n    /**\\n     * @notice Get the token address from ID of the external token\\n     * @dev Convert the bytes32 external token ID to its respective ERC20 contract address\\n     * @param _externalTokenId The ID assigned to an external token\\n     * @return tokenAddress Contract address\\n     */\\n    function getAddressFromExternalTokenId(bytes32 _externalTokenId) external pure returns (address tokenAddress);\\n\\n    /**\\n     * @notice Set the entity for the user\\n     * @dev Assign the user an entity. The entity must exist in order to associate it with a user.\\n     * @param _userId Unique platform ID of the user account\\n     * @param _entityId Unique platform ID of the entity\\n     */\\n    function setEntity(bytes32 _userId, bytes32 _entityId) external;\\n\\n    /**\\n     * @notice Get the entity for the user\\n     * @dev Gets the entity related to the user\\n     * @param _userId Unique platform ID of the user account\\n     * @return entityId Unique platform ID of the entity\\n     */\\n    function getEntity(bytes32 _userId) external view returns (bytes32 entityId);\\n}\\n\"\r\n    },\r\n    \"src/diamonds/nayms/interfaces/IAdminFacet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport { FeeSchedule } from \\\"./FreeStructs.sol\\\";\\n\\n/**\\n * @title Administration\\n * @notice Exposes methods that require administrative priviledges\\n * @dev Use it to configure various core parameters\\n */\\ninterface IAdminFacet {\\n    /**\\n     * @notice Set `_newMax` as the max dividend denominations value.\\n     * @param _newMax new value to be used.\\n     */\\n    function setMaxDividendDenominations(uint8 _newMax) external;\\n\\n    /**\\n     * @notice Get the max dividend denominations value\\n     * @return max dividend denominations\\n     */\\n    function getMaxDividendDenominations() external view returns (uint8);\\n\\n    /**\\n     * @notice Is the specified tokenId an external ERC20 that is supported by the Nayms platform?\\n     * @param _tokenId token address converted to bytes32\\n     * @return whether token issupported or not\\n     */\\n    function isSupportedExternalToken(bytes32 _tokenId) external view returns (bool);\\n\\n    /**\\n     * @notice Add another token to the supported tokens list\\n     * @param _tokenAddress address of the token to support\\n     */\\n    function addSupportedExternalToken(address _tokenAddress) external;\\n\\n    /**\\n     * @notice Get the supported tokens list as an array\\n     * @return array containing address of all supported tokens\\n     */\\n    function getSupportedExternalTokens() external view returns (address[] memory);\\n\\n    /**\\n     * @notice Gets the System context ID.\\n     * @return System Identifier\\n     */\\n    function getSystemId() external pure returns (bytes32);\\n\\n    /**\\n     * @notice Check if object can be tokenized\\n     * @param _objectId ID of the object\\n     */\\n    function isObjectTokenizable(bytes32 _objectId) external view returns (bool);\\n\\n    /**\\n     * @notice System Admin can lock a function\\n     * @dev This toggles FunctionLockedStorage.lock to true\\n     * @param functionSelector the bytes4 function selector\\n     */\\n    function lockFunction(bytes4 functionSelector) external;\\n\\n    /**\\n     * @notice System Admin can unlock a function\\n     * @dev This toggles FunctionLockedStorage.lock to false\\n     * @param functionSelector the bytes4 function selector\\n     */\\n    function unlockFunction(bytes4 functionSelector) external;\\n\\n    /**\\n     * @notice Check if a function has been locked by a system admin\\n     * @dev This views FunctionLockedStorage.lock\\n     * @param functionSelector the bytes4 function selector\\n     */\\n    function isFunctionLocked(bytes4 functionSelector) external view returns (bool);\\n\\n    /**\\n     * @notice Lock all contract methods involving fund transfers\\n     */\\n    function lockAllFundTransferFunctions() external;\\n\\n    /**\\n     * @notice Unlock all contract methods involving fund transfers\\n     */\\n    function unlockAllFundTransferFunctions() external;\\n\\n    /**\\n     * @notice Update market maker fee basis points\\n     * @param _newMakerBP new maker fee value\\n     */\\n    function replaceMakerBP(uint16 _newMakerBP) external;\\n\\n    function addFeeSchedule(\\n        bytes32 entityId,\\n        uint256 _feeScheduleType,\\n        bytes32[] calldata _receiver,\\n        uint16[] calldata _basisPoints\\n    ) external;\\n\\n    function removeFeeSchedule(bytes32 _entityId, uint256 _feeScheduleType) external;\\n}\\n\"\r\n    },\r\n    \"src/diamonds/nayms/interfaces/ISystemFacet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport { Entity } from \\\"./FreeStructs.sol\\\";\\n\\n/**\\n * @title System\\n * @notice Use it to perform system level operations\\n * @dev Use it to perform system level operations\\n */\\ninterface ISystemFacet {\\n    /**\\n     * @notice Create an entity\\n     * @dev An entity can be created with a zero max capacity! This is in the event where an entity cannot write any policies.\\n     * @param _entityId Unique ID for the entity\\n     * @param _entityAdmin Unique ID of the entity administrator\\n     * @param _entityData remaining entity metadata\\n     * @param _dataHash hash of the offchain data\\n     */\\n    function createEntity(\\n        bytes32 _entityId,\\n        bytes32 _entityAdmin,\\n        Entity memory _entityData,\\n        bytes32 _dataHash\\n    ) external;\\n\\n    /**\\n     * @notice Convert a string type to a bytes32 type\\n     * @param _strIn a string\\n     */\\n    function stringToBytes32(string memory _strIn) external pure returns (bytes32 result);\\n\\n    /**\\n     * @dev Get whether given id is an object in the system.\\n     * @param _id object id.\\n     * @return true if it is an object, false otherwise\\n     */\\n    function isObject(bytes32 _id) external view returns (bool);\\n\\n    /**\\n     * @dev Get meta of given object.\\n     * @param _id object id.\\n     * @return parent object parent\\n     * @return dataHash object data hash\\n     * @return tokenSymbol object token symbol\\n     * @return tokenName object token name\\n     * @return tokenWrapper object token ERC20 wrapper address\\n     */\\n    function getObjectMeta(bytes32 _id)\\n        external\\n        view\\n        returns (\\n            bytes32 parent,\\n            bytes32 dataHash,\\n            string memory tokenSymbol,\\n            string memory tokenName,\\n            address tokenWrapper\\n        );\\n\\n    /**\\n     * @notice Wrap an object token as ERC20\\n     * @param _objectId ID of the tokenized object\\n     */\\n    function wrapToken(bytes32 _objectId) external;\\n}\\n\"\r\n    },\r\n    \"src/diamonds/nayms/interfaces/INaymsTokenFacet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\n/**\\n * @title Nayms token facet.\\n * @dev Use it to access and manipulate Nayms token.\\n */\\ninterface INaymsTokenFacet {\\n    /**\\n     * @dev Get total supply of token.\\n     * @return total supply.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Get token balance of given wallet.\\n     * @param addr wallet whose balance to get.\\n     * @return balance of wallet.\\n     */\\n    function balanceOf(address addr) external view returns (uint256);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@openzeppelin/=lib/ozv4/\",\r\n      \"@uniswap/lib/=lib/solidity-lib/\",\r\n      \"@uniswap/v2-core/=lib/v2-core/\",\r\n      \"@uniswap/v3-core/=lib/v3-core/\",\r\n      \"@uniswap/v3-periphery/=lib/v3-periphery/\",\r\n      \"base64-sol/=lib/base64/\",\r\n      \"ds-test/=lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/ozv4/lib/erc4626-tests/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"ozv4/=lib/ozv4/\",\r\n      \"script/=script/\",\r\n      \"solidity-lib/=lib/solidity-lib/contracts/\",\r\n      \"solidity-stringutils/=lib/solidity-stringutils/\",\r\n      \"solmate/=lib/solmate/src/\",\r\n      \"src/=src/\",\r\n      \"test/=test/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"debug\": {\r\n      \"revertStrings\": \"default\"\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"name\":\"ExternalDepositAmountCannotBeZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ExternalWithdrawAmountCannotBeZero\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"ExternalWithdrawInvalidReceiver\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"msgSenderId\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"context\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"roleInContext\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"group\",\"type\":\"string\"}],\"name\":\"InvalidGroupPrivilege\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_externalTokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"externalDeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_entityId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_externalTokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"externalWithdrawFromEntity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "TokenizedVaultIOFacet", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "london", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}